record_number,buggy_code,fixed_code,code_similarity
194001,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194002,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194003,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194004,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194005,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194006,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194007,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194008,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194009,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194010,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194011,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194012,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194013,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194014,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194015,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194016,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194017,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194018,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194019,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194020,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194021,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194022,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194023,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194024,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194025,"private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}","private final void addProcessNameLocked(ProcessRecord proc){
  ProcessRecord old=removeProcessNameLocked(proc.processName,proc.uid);
  if (old == proc && proc.persistent) {
    Slog.w(TAG,""String_Node_Str"" + proc);
  }
 else   if (old != null) {
    Slog.wtf(TAG,""String_Node_Str"" + old + ""String_Node_Str""+ proc);
  }
  UidRecord uidRec=mActiveUids.get(proc.uid);
  if (uidRec == null) {
    uidRec=new UidRecord(proc.uid);
    if (DEBUG_UID_OBSERVERS)     Slog.i(TAG_UID_OBSERVERS,""String_Node_Str"" + uidRec);
    mActiveUids.put(proc.uid,uidRec);
    enqueueUidChangeLocked(uidRec,false);
  }
  proc.uidRecord=uidRec;
  uidRec.numProcs++;
  mProcessNames.put(proc.processName,proc.uid,proc);
  if (proc.isolated) {
    mIsolatedProcesses.put(proc.uid,proc);
  }
}",0.9361111111111112
194026,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194027,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194028,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194029,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,ActivityStackSupervisor supervisor,ActivityContainer container,Bundle options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  stackConfigOverride=(container != null) ? container.mStack.mOverrideConfig : Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=new ActivityOptions(options);
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && isNotResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
  }
}",0.9982647749311012
194030,"/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}","/** 
 * Match this intent filter against the given Intent data.  This ignores the data scheme -- unlike   {@link #matchData}, the authority will match regardless of whether there is a matching scheme.
 * @param data The data whose authority is being looked for.
 * @return Returns either {@link #MATCH_CATEGORY_HOST},  {@link #MATCH_CATEGORY_PORT},   {@link #NO_MATCH_DATA}.
 */
public final int matchDataAuthority(Uri data){
  if (mDataAuthorities == null || data == null) {
    return NO_MATCH_DATA;
  }
  final int numDataAuthorities=mDataAuthorities.size();
  for (int i=0; i < numDataAuthorities; i++) {
    final AuthorityEntry ae=mDataAuthorities.get(i);
    int match=ae.match(data);
    if (match >= 0) {
      return match;
    }
  }
  return NO_MATCH_DATA;
}",0.9894875164257556
194031,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data.  If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes ""content:"" or ""file:"" (basically performing a MIME-type only match).  If the filter does not specify any MIME types, the Intent also must not specify a MIME type. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    final ArrayList<PatternMatcher> schemeSpecificParts=mDataSchemeSpecificParts;
    if (schemeSpecificParts != null && data != null) {
      match=hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
    }
    if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
      final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
      if (authorities != null) {
        int authMatch=matchDataAuthority(data);
        if (authMatch >= 0) {
          final ArrayList<PatternMatcher> paths=mDataPaths;
          if (paths == null) {
            match=authMatch;
          }
 else           if (hasDataPath(data.getPath())) {
            match=MATCH_CATEGORY_PATH;
          }
 else {
            return NO_MATCH_DATA;
          }
        }
 else {
          return NO_MATCH_DATA;
        }
      }
    }
    if (match == NO_MATCH_DATA) {
      return NO_MATCH_DATA;
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9978207572868428
194032,"@Override public void onClick(View v){
  detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
}","@Override public void onClick(View v){
  boolean checked=!mQsDetailHeaderSwitch.isChecked();
  mQsDetailHeaderSwitch.setChecked(checked);
  detail.setToggleState(checked);
}",0.6131386861313869
194033,"private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}","private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          boolean checked=!mQsDetailHeaderSwitch.isChecked();
          mQsDetailHeaderSwitch.setChecked(checked);
          detail.setToggleState(checked);
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}",0.865616311399444
194034,"@Override public void onClick(View v){
  detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
}","@Override public void onClick(View v){
  boolean checked=!mQsDetailHeaderSwitch.isChecked();
  mQsDetailHeaderSwitch.setChecked(checked);
  detail.setToggleState(checked);
}",0.6131386861313869
194035,"private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}","private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          boolean checked=!mQsDetailHeaderSwitch.isChecked();
          mQsDetailHeaderSwitch.setChecked(checked);
          detail.setToggleState(checked);
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}",0.865616311399444
194036,"@Override public void onClick(View v){
  detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
}","@Override public void onClick(View v){
  boolean checked=!mQsDetailHeaderSwitch.isChecked();
  mQsDetailHeaderSwitch.setChecked(checked);
  detail.setToggleState(checked);
}",0.6131386861313869
194037,"private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}","private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          boolean checked=!mQsDetailHeaderSwitch.isChecked();
          mQsDetailHeaderSwitch.setChecked(checked);
          detail.setToggleState(checked);
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}",0.865616311399444
194038,"@Override public void onClick(View v){
  detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
}","@Override public void onClick(View v){
  boolean checked=!mQsDetailHeaderSwitch.isChecked();
  mQsDetailHeaderSwitch.setChecked(checked);
  detail.setToggleState(checked);
}",0.6131386861313869
194039,"private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}","private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          boolean checked=!mQsDetailHeaderSwitch.isChecked();
          mQsDetailHeaderSwitch.setChecked(checked);
          detail.setToggleState(checked);
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}",0.865616311399444
194040,"@Override public void onClick(View v){
  detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
}","@Override public void onClick(View v){
  boolean checked=!mQsDetailHeaderSwitch.isChecked();
  mQsDetailHeaderSwitch.setChecked(checked);
  detail.setToggleState(checked);
}",0.6131386861313869
194041,"private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}","private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          boolean checked=!mQsDetailHeaderSwitch.isChecked();
          mQsDetailHeaderSwitch.setChecked(checked);
          detail.setToggleState(checked);
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}",0.865616311399444
194042,"@Override public void onClick(View v){
  detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
}","@Override public void onClick(View v){
  boolean checked=!mQsDetailHeaderSwitch.isChecked();
  mQsDetailHeaderSwitch.setChecked(checked);
  detail.setToggleState(checked);
}",0.6131386861313869
194043,"private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          detail.setToggleState(!mQsDetailHeaderSwitch.isChecked());
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}","private void handleShowingDetail(final QSTile.DetailAdapter detail){
  final boolean showingDetail=detail != null;
  transition(mClock,!showingDetail);
  transition(mDateGroup,!showingDetail);
  if (mAlarmShowing) {
    transition(mAlarmStatus,!showingDetail);
  }
  transition(mQsDetailHeader,showingDetail);
  mShowingDetail=showingDetail;
  if (showingDetail) {
    mQsDetailHeaderTitle.setText(detail.getTitle());
    final Boolean toggleState=detail.getToggleState();
    if (toggleState == null) {
      mQsDetailHeaderSwitch.setVisibility(INVISIBLE);
      mQsDetailHeader.setClickable(false);
    }
 else {
      mQsDetailHeaderSwitch.setVisibility(VISIBLE);
      mQsDetailHeaderSwitch.setChecked(toggleState);
      mQsDetailHeader.setClickable(true);
      mQsDetailHeader.setOnClickListener(new OnClickListener(){
        @Override public void onClick(        View v){
          boolean checked=!mQsDetailHeaderSwitch.isChecked();
          mQsDetailHeaderSwitch.setChecked(checked);
          detail.setToggleState(checked);
        }
      }
);
    }
  }
 else {
    mQsDetailHeader.setClickable(false);
  }
}",0.865616311399444
194044,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194045,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194046,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194047,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194048,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194049,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194050,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194051,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194052,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194053,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194054,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194055,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194056,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194057,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194058,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194059,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194060,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194061,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194062,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194063,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194064,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194065,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194066,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194067,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194068,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194069,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194070,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194071,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194072,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194073,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194074,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194075,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9657477025898078
194076,"public void runListDisks() throws RemoteException {
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    System.out.println(disk.getId());
  }
}","public void runListDisks() throws RemoteException {
  final boolean onlyAdoptable=""String_Node_Str"".equals(nextArg());
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    if (!onlyAdoptable || disk.isAdoptable()) {
      System.out.println(disk.getId());
    }
  }
}",0.7300215982721382
194077,"public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}","public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runBenchmark();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}",0.9692307692307692
194078,"/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=Environment.getDataUserDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(mContext,volumeUuid,user.id);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}","/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataUserDirectory(volumeUuid));
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(mContext,volumeUuid,user.id);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}",0.95878398129202
194079,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  killApplication(packageName,appId,""String_Node_Str"");
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  final long token=Binder.clearCallingIdentity();
  try {
    killApplication(packageName,appId,""String_Node_Str"");
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}",0.9900212661540978
194080,"/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=Environment.getDataAppDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}","/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}",0.9607562303065024
194081,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194082,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194083,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9657477025898078
194084,"public void runListDisks() throws RemoteException {
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    System.out.println(disk.getId());
  }
}","public void runListDisks() throws RemoteException {
  final boolean onlyAdoptable=""String_Node_Str"".equals(nextArg());
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    if (!onlyAdoptable || disk.isAdoptable()) {
      System.out.println(disk.getId());
    }
  }
}",0.7300215982721382
194085,"public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}","public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runBenchmark();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}",0.9692307692307692
194086,"/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=Environment.getDataUserDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(userDir);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}","/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataUserDirectory(volumeUuid));
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(userDir);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}",0.95829636202307
194087,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  killApplication(packageName,appId,""String_Node_Str"");
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  final long token=Binder.clearCallingIdentity();
  try {
    killApplication(packageName,appId,""String_Node_Str"");
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}",0.9900212661540978
194088,"/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=Environment.getDataAppDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}","/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}",0.9607562303065024
194089,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194090,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194091,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194092,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194093,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194094,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194095,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194096,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194097,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194098,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194099,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194100,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194101,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194102,"Parcel readParcel(){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  if (mCurParcel.readInt() != 0) {
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}","Parcel readParcel(int validateToken,int level){
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews+ ""String_Node_Str""+ level);
  int token=mCurParcel.readInt();
  if (token != 0) {
    if (token != validateToken) {
      throw new BadParcelableException(""String_Node_Str"" + Integer.toHexString(token) + ""String_Node_Str""+ Integer.toHexString(validateToken));
    }
    return mCurParcel;
  }
  mTransferToken=mCurParcel.readStrongBinder();
  if (mTransferToken == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mTransferToken);
  fetchData();
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition());
  mStringReader=new PooledStringReader(mCurParcel);
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mStringReader.getStringCount());
  if (DEBUG_PARCEL)   Log.d(TAG,""String_Node_Str"" + mCurParcel.dataPosition() + ""String_Node_Str""+ mCurParcel.dataAvail()+ ""String_Node_Str""+ mNumReadWindows+ ""String_Node_Str""+ mNumReadViews);
  mCurParcel.readInt();
  return mCurParcel;
}",0.8693733451015004
194103,"ViewNode(ParcelTransferReader reader){
  final Parcel in=reader.readParcel();
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader);
    }
  }
}","ViewNode(ParcelTransferReader reader,int nestingLevel){
  final Parcel in=reader.readParcel(VALIDATE_VIEW_TOKEN,nestingLevel);
  reader.mNumReadViews++;
  final PooledStringReader preader=reader.mStringReader;
  mClassName=preader.readString();
  mFlags=in.readInt();
  final int flags=mFlags;
  if ((flags & FLAGS_HAS_ID) != 0) {
    mId=in.readInt();
    if (mId != 0) {
      mIdEntry=preader.readString();
      if (mIdEntry != null) {
        mIdType=preader.readString();
        mIdPackage=preader.readString();
      }
    }
  }
  if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
    mX=in.readInt();
    mY=in.readInt();
    mWidth=in.readInt();
    mHeight=in.readInt();
  }
 else {
    int val=in.readInt();
    mX=val & 0x7fff;
    mY=(val >> 16) & 0x7fff;
    val=in.readInt();
    mWidth=val & 0x7fff;
    mHeight=(val >> 16) & 0x7fff;
  }
  if ((flags & FLAGS_HAS_SCROLL) != 0) {
    mScrollX=in.readInt();
    mScrollY=in.readInt();
  }
  if ((flags & FLAGS_HAS_MATRIX) != 0) {
    mMatrix=new Matrix();
    in.readFloatArray(reader.mTmpMatrix);
    mMatrix.setValues(reader.mTmpMatrix);
  }
  if ((flags & FLAGS_HAS_ELEVATION) != 0) {
    mElevation=in.readFloat();
  }
  if ((flags & FLAGS_HAS_ALPHA) != 0) {
    mAlpha=in.readFloat();
  }
  if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
    mContentDescription=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  }
  if ((flags & FLAGS_HAS_TEXT) != 0) {
    mText=new ViewNodeText(in,(flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
  }
  if ((flags & FLAGS_HAS_EXTRAS) != 0) {
    mExtras=in.readBundle();
  }
  if ((flags & FLAGS_HAS_CHILDREN) != 0) {
    final int NCHILDREN=in.readInt();
    if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)     Log.d(TAG,""String_Node_Str"" + NCHILDREN + ""String_Node_Str""+ reader.mNumReadViews+ ""String_Node_Str""+ nestingLevel);
    mChildren=new ViewNode[NCHILDREN];
    for (int i=0; i < NCHILDREN; i++) {
      mChildren[i]=new ViewNode(reader,nestingLevel + 1);
    }
  }
}",0.9357354127453616
194104,"boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      if (DEBUG_PARCEL)       Log.d(TAG,""String_Node_Str"" + out.dataPosition() + ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
      out.writeInt(1);
      int flags=child.writeSelfToParcel(out,pwriter,mTmpMatrix);
      mNumWrittenViews++;
      if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"" + child.mChildren.length + ""String_Node_Str""+ child);
        out.writeInt(child.mChildren.length);
        int pos=++mCurViewStackPos;
        pushViewStackEntry(child,pos);
      }
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(1);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    pushViewStackEntry(root,0);
    return true;
  }
  return false;
}","boolean writeNextEntryToParcel(AssistStructure as,Parcel out,PooledStringWriter pwriter){
  if (mCurViewStackEntry != null) {
    if (mCurViewStackEntry.curChild < mCurViewStackEntry.numChildren) {
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.curChild + ""String_Node_Str""+ mCurViewStackEntry.node);
      ViewNode child=mCurViewStackEntry.node.mChildren[mCurViewStackEntry.curChild];
      mCurViewStackEntry.curChild++;
      writeView(child,out,pwriter,1);
      return true;
    }
    do {
      int pos=--mCurViewStackPos;
      if (DEBUG_PARCEL_TREE)       Log.d(TAG,""String_Node_Str"" + mCurViewStackEntry.node + ""String_Node_Str""+ pos);
      if (pos < 0) {
        if (DEBUG_PARCEL_TREE)         Log.d(TAG,""String_Node_Str"");
        mCurViewStackEntry=null;
        break;
      }
      mCurViewStackEntry=mViewStack.get(pos);
    }
 while (mCurViewStackEntry.curChild >= mCurViewStackEntry.numChildren);
    return true;
  }
  int pos=mCurWindow;
  if (pos < mNumWindows) {
    WindowNode win=as.mWindowNodes.get(pos);
    mCurWindow++;
    if (DEBUG_PARCEL)     Log.d(TAG,""String_Node_Str"" + pos + ""String_Node_Str""+ out.dataPosition()+ ""String_Node_Str""+ mNumWrittenWindows+ ""String_Node_Str""+ mNumWrittenViews);
    out.writeInt(VALIDATE_WINDOW_TOKEN);
    win.writeSelfToParcel(out,pwriter,mTmpMatrix);
    mNumWrittenWindows++;
    ViewNode root=win.mRoot;
    mCurViewStackPos=0;
    if (DEBUG_PARCEL_TREE)     Log.d(TAG,""String_Node_Str"" + root);
    writeView(root,out,pwriter,0);
    return true;
  }
  return false;
}",0.4139623670575402
194105,"WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel();
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader);
}","WindowNode(ParcelTransferReader reader){
  Parcel in=reader.readParcel(VALIDATE_WINDOW_TOKEN,0);
  reader.mNumReadWindows++;
  mX=in.readInt();
  mY=in.readInt();
  mWidth=in.readInt();
  mHeight=in.readInt();
  mTitle=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
  mDisplayId=in.readInt();
  mRoot=new ViewNode(reader,0);
}",0.9609984399375976
194106,"@Override public long getStartClockTime(){
  if (!isStartClockTimeValid()) {
    mStartClockTime=System.currentTimeMillis();
    if (isStartClockTimeValid()) {
      recordCurrentTimeChangeLocked(mStartClockTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
    }
  }
  return mStartClockTime;
}","@Override public long getStartClockTime(){
  final long currentTime=System.currentTimeMillis();
  if (ensureStartClockTime(currentTime)) {
    recordCurrentTimeChangeLocked(currentTime,SystemClock.elapsedRealtime(),SystemClock.uptimeMillis());
  }
  return mStartClockTime;
}",0.274442538593482
194107,"public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  if (isStartClockTimeValid()) {
    mStartClockTime=currentTime;
  }
}","public void noteCurrentTimeChangedLocked(){
  final long currentTime=System.currentTimeMillis();
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  final long uptime=SystemClock.uptimeMillis();
  recordCurrentTimeChangeLocked(currentTime,elapsedRealtime,uptime);
  ensureStartClockTime(currentTime);
}",0.8858447488584474
194108,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194109,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194110,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9657477025898078
194111,"public void runListDisks() throws RemoteException {
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    System.out.println(disk.getId());
  }
}","public void runListDisks() throws RemoteException {
  final boolean onlyAdoptable=""String_Node_Str"".equals(nextArg());
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    if (!onlyAdoptable || disk.isAdoptable()) {
      System.out.println(disk.getId());
    }
  }
}",0.7300215982721382
194112,"public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}","public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runBenchmark();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}",0.9692307692307692
194113,"/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=Environment.getDataUserDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(userDir);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}","/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataUserDirectory(volumeUuid));
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(userDir);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}",0.95829636202307
194114,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  killApplication(packageName,appId,""String_Node_Str"");
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  final long token=Binder.clearCallingIdentity();
  try {
    killApplication(packageName,appId,""String_Node_Str"");
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}",0.9900212661540978
194115,"/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=Environment.getDataAppDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}","/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}",0.9607562303065024
194116,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9657477025898078
194117,"public void runListDisks() throws RemoteException {
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    System.out.println(disk.getId());
  }
}","public void runListDisks() throws RemoteException {
  final boolean onlyAdoptable=""String_Node_Str"".equals(nextArg());
  final DiskInfo[] disks=mSm.getDisks();
  for (  DiskInfo disk : disks) {
    if (!onlyAdoptable || disk.isAdoptable()) {
      System.out.println(disk.getId());
    }
  }
}",0.7300215982721382
194118,"public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}","public void run(String[] args) throws Exception {
  if (args.length < 1) {
    throw new IllegalArgumentException();
  }
  mSm=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mSm == null) {
    throw new RemoteException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runListDisks();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runListVolumes();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runHasAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runGetPrimaryStorageUuid();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runSetForceAdoptable();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runPartition();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runMount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runUnmount();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runFormat();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runBenchmark();
  }
 else   if (""String_Node_Str"".equals(op)) {
    runForget();
  }
 else {
    throw new IllegalArgumentException();
  }
}",0.9692307692307692
194119,"/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=Environment.getDataUserDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(userDir);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}","/** 
 * Examine all users present on given mounted volume, and destroy data belonging to users that are no longer valid, or whose user ID has been recycled.
 */
private void reconcileUsers(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataUserDirectory(volumeUuid));
  for (  File file : files) {
    if (!file.isDirectory())     continue;
    final int userId;
    final UserInfo info;
    try {
      userId=Integer.parseInt(file.getName());
      info=sUserManager.getUserInfo(userId);
    }
 catch (    NumberFormatException e) {
      Slog.w(TAG,""String_Node_Str"" + file);
      continue;
    }
    boolean destroyUser=false;
    if (info == null) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str"");
      destroyUser=true;
    }
 else {
      try {
        UserManagerService.enforceSerialNumber(file,info.serialNumber);
      }
 catch (      IOException e) {
        logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
        destroyUser=true;
      }
    }
    if (destroyUser) {
synchronized (mInstallLock) {
        mInstaller.removeUserDataDirs(volumeUuid,userId);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    final File userDir=Environment.getDataUserDirectory(volumeUuid,user.id);
    if (userDir.exists())     continue;
    try {
      UserManagerService.prepareUserDirectory(userDir);
      UserManagerService.enforceSerialNumber(userDir,user.serialNumber);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"" + volumeUuid,e);
    }
  }
}",0.95829636202307
194120,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  killApplication(packageName,appId,""String_Node_Str"");
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (Objects.equals(ps.volumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    final File probe=new File(pkg.codePath);
    final File probeOat=new File(probe,""String_Node_Str"");
    if (!probe.isDirectory() || !probeOat.isDirectory()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    if (ps.frozen) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    ps.frozen=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  final long token=Binder.clearCallingIdentity();
  try {
    killApplication(packageName,appId,""String_Node_Str"");
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      unfreezePackage(packageName);
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    unfreezePackage(packageName);
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      unfreezePackage(packageName);
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null);
mHandler.sendMessage(msg);
}",0.9900212661540978
194121,"/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=Environment.getDataAppDirectory(volumeUuid).listFiles();
  if (ArrayUtils.isEmpty(files)) {
    Slog.d(TAG,""String_Node_Str"" + volumeUuid);
    return;
  }
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}","/** 
 * Examine all apps present on given mounted volume, and destroy apps that aren't expected, either due to uninstallation or reinstallation on another volume.
 */
private void reconcileApps(String volumeUuid){
  final File[] files=FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
  for (  File file : files) {
    final boolean isPackage=(isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
    if (!isPackage) {
      continue;
    }
    boolean destroyApp=false;
    String packageName=null;
    try {
      final PackageLite pkg=PackageParser.parsePackageLite(file,PackageParser.PARSE_MUST_BE_APK);
      packageName=pkg.packageName;
synchronized (mPackages) {
        final PackageSetting ps=mSettings.mPackages.get(packageName);
        if (ps == null) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str"");
          destroyApp=true;
        }
 else         if (!TextUtils.equals(volumeUuid,ps.volumeUuid)) {
          logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str""+ volumeUuid+ ""String_Node_Str""+ ps.volumeUuid);
          destroyApp=true;
        }
      }
    }
 catch (    PackageParserException e) {
      logCriticalInfo(Log.WARN,""String_Node_Str"" + file + ""String_Node_Str""+ e);
      destroyApp=true;
    }
    if (destroyApp) {
synchronized (mInstallLock) {
        if (packageName != null) {
          removeDataDirsLI(volumeUuid,packageName);
        }
        if (file.isDirectory()) {
          mInstaller.rmPackageDir(file.getAbsolutePath());
        }
 else {
          file.delete();
        }
      }
    }
  }
}",0.9607562303065024
194122,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194123,"/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        return null;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}","/** 
 * Returns the first activity (starting from the top of the stack) that is the same as the given activity.  Returns null if no such activity is found.
 */
ActivityRecord findActivityLocked(Intent intent,ActivityInfo info){
  ComponentName cls=intent.getComponent();
  if (info.targetActivity != null) {
    cls=new ComponentName(info.packageName,info.targetActivity);
  }
  final int userId=UserHandle.getUserId(info.applicationInfo.uid);
  for (int taskNdx=mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=mTaskHistory.get(taskNdx);
    final boolean notCurrentUserTask=!mStackSupervisor.isCurrentProfileLocked(task.userId);
    final ArrayList<ActivityRecord> activities=task.mActivities;
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      ActivityRecord r=activities.get(activityNdx);
      if (notCurrentUserTask && (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) {
        continue;
      }
      if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
        return r;
      }
    }
  }
  return null;
}",0.9914221218961624
194124,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194125,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194126,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194127,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194128,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194129,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194130,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194131,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194132,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194133,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194134,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194135,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194136,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194137,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194138,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        if (!w.isHiddenFromUserLocked()) {
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,""String_Node_Str"" + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateInputWindowsNeeded=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mInnerFields.mHoldScreen=null;
  mInnerFields.mScreenBrightness=-1;
  mInnerFields.mButtonBrightness=-1;
  mInnerFields.mUserActivityTimeout=-1;
  mInnerFields.mObscureApplicationContentOnSecondaryDisplays=false;
  mTransactionSequence++;
  final DisplayContent defaultDisplay=getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  SurfaceControl.openTransaction();
  try {
    if (mWatermark != null) {
      mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mStrictModeFlash != null) {
      mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mCircularDisplayMask != null) {
      mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mRotation);
    }
    if (mEmulatorDisplayOverlay != null) {
      mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mInnerFields.mDisplayHasContent=false;
      mInnerFields.mPreferredRefreshRate=0;
      mInnerFields.mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,""String_Node_Str"");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && adjustWallpaperWindowsLocked()) {
          assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < 4) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mInnerFields.mObscured=false;
      mInnerFields.mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final TaskStack stack=w.getStack();
        if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mInnerFields.mObscured;
        w.mObscured=mInnerFields.mObscured;
        if (!mInnerFields.mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (stack != null && !stack.testDimmingTag()) {
          handleFlagDimBehind(w);
        }
        if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w)&& w.isVisibleLw()) {
          updateWallpaperVisibilityLocked();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,""String_Node_Str"" + w);
              mInnerFields.mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats(""String_Node_Str"",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
          final AppWindowToken atoken=w.mAppToken;
          if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
            Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isOnScreen()+ ""String_Node_Str""+ atoken.allDrawn+ ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen);
          }
          if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
            if (atoken.lastTransactionSequence != mTransactionSequence) {
              atoken.lastTransactionSequence=mTransactionSequence;
              atoken.numInterestingWindows=atoken.numDrawnWindows=0;
              atoken.startingDisplayed=false;
            }
            if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
              if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ winAnimator.isAnimating());
                if (!w.isDrawnLw()) {
                  Slog.v(TAG,""String_Node_Str"" + winAnimator.mSurfaceControl + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ winAnimator.drawStateToString()+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ winAnimator.mAnimating);
                }
              }
              if (w != atoken.startingWindow) {
                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                  atoken.numInterestingWindows++;
                  if (w.isDrawnLw()) {
                    atoken.numDrawnWindows++;
                    if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                     Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.mAppAnimator.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                    updateAllDrawn=true;
                  }
                }
              }
 else               if (w.isDrawnLw()) {
                atoken.startingDisplayed=true;
              }
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        updateResizingWindows(w);
      }
      mDisplayManagerInternal.setDisplayProperties(displayId,mInnerFields.mDisplayHasContent,mInnerFields.mPreferredRefreshRate,mInnerFields.mPreferredModeId,true);
      getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
    }
    mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (!mAnimator.mAppWindowAnimating && mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  mInnerFields.mWallpaperForceHidingChanged=false;
  if (mInnerFields.mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,""String_Node_Str"");
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  if (mFocusMayChange) {
    mFocusMayChange=false;
    if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats(""String_Node_Str"",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Slog.v(TAG,""String_Node_Str"" + mInnerFields.mOrientationChangeComplete);
  if (mInnerFields.mOrientationChangeComplete) {
    if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mLastFinishedFreezeSource=mInnerFields.mLastWindowFreezeSource;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      if (win == mWallpaperTarget) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperTokens.remove(token);
        }
      }
    }
  }
  for (int stackNdx=mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,""String_Node_Str"" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mInputMonitor.updateInputWindowsLw(true);
  setHoldScreenLocked(mInnerFields.mHoldScreen);
  if (!mDisplayFrozen) {
    if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
    }
    if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
    }
    mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
  }
  if (mTurnOnScreen) {
    if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,""String_Node_Str"");
      }
      mPowerManager.wakeUp(SystemClock.uptimeMillis(),""String_Node_Str"");
    }
    mTurnOnScreen=false;
  }
  if (mInnerFields.mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,""String_Node_Str"");
    if (updateRotationUncheckedLocked(false)) {
      mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
 else {
      mInnerFields.mUpdateRotation=false;
    }
  }
  if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
    checkDrawnWindowsLocked();
  }
  final int N=mPendingRemove.size();
  if (N > 0) {
    if (mPendingRemoveTmp.length < N) {
      mPendingRemoveTmp=new WindowState[N + 10];
    }
    mPendingRemove.toArray(mPendingRemoveTmp);
    mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mPendingRemoveTmp[i];
      removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mInputMonitor.updateInputWindowsLw(false);
  }
  setFocusedStackFrame();
  enableScreenIfNeededLocked();
  scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,""String_Node_Str"" + mAnimator.mAnimating);
  }
}",0.9976436265709157
194139,"boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}","boolean performShowLocked(){
  if (mWin.isHiddenFromUserLocked()) {
    if (DEBUG_VISIBILITY)     Slog.w(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ mWin.mOwnerUid);
    mWin.hideLw(false);
    return false;
  }
  if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ drawStateToString()+ ""String_Node_Str""+ mWin.isReadyForDisplayIgnoringKeyguard()+ ""String_Node_Str""+ (mWin.mAttrs.type == TYPE_APPLICATION_STARTING)+ ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false)+ ""String_Node_Str""+ Debug.getCallers(3));
  }
  if (mDrawState == READY_TO_SHOW && mWin.isReadyForDisplayIgnoringKeyguard()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY || (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING)) {
      Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mWin.mPolicyVisibility+ ""String_Node_Str""+ mWin.mAttachedHidden+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mWin.mAppToken != null ? mWin.mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppAnimator != null ? mAppAnimator.animating : false));
    }
    mService.enableScreenIfNeededLocked();
    applyEnterAnimationLocked();
    mLastAlpha=-1;
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM)     Slog.v(TAG,""String_Node_Str"" + this);
    mDrawState=HAS_DRAWN;
    mService.scheduleAnimationLocked();
    int i=mWin.mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mWinAnimator.mSurfaceControl != null) {
          c.mWinAnimator.performShowLocked();
          final DisplayContent displayContent=c.getDisplayContent();
          if (displayContent != null) {
            displayContent.layoutNeeded=true;
          }
        }
      }
    }
    if (mWin.mAttrs.type != TYPE_APPLICATION_STARTING && mWin.mAppToken != null) {
      mWin.mAppToken.firstWindowDrawn=true;
      if (mWin.mAppToken.startingData != null) {
        if (WindowManagerService.DEBUG_STARTING_WINDOW || WindowManagerService.DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mWin.mToken + ""String_Node_Str"");
        clearAnimation();
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return true;
  }
  return false;
}",0.1885245901639344
194140,"private UserInfo createUserInternal(String name,int flags,int parentId){
  if (getUserRestrictions(UserHandle.getCallingUserId()).getBoolean(UserManager.DISALLOW_ADD_USER,false)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    return null;
  }
  if (ActivityManager.isLowRamDeviceStatic()) {
    return null;
  }
  final boolean isGuest=(flags & UserInfo.FLAG_GUEST) != 0;
  final boolean isManagedProfile=(flags & UserInfo.FLAG_MANAGED_PROFILE) != 0;
  final long ident=Binder.clearCallingIdentity();
  UserInfo userInfo=null;
  final int userId;
  try {
synchronized (mInstallLock) {
synchronized (mPackagesLock) {
        UserInfo parent=null;
        if (parentId != UserHandle.USER_NULL) {
          parent=getUserInfoLocked(parentId);
          if (parent == null)           return null;
        }
        if (isManagedProfile && !canAddMoreManagedProfiles()) {
          return null;
        }
        if (!isGuest && !isManagedProfile && isUserLimitReachedLocked()) {
          return null;
        }
        if (isGuest && findCurrentGuestUserLocked() != null) {
          return null;
        }
        if (UserManager.isSplitSystemUser() && !isGuest && !isManagedProfile&& mUsers.size() == 1) {
          flags|=UserInfo.FLAG_PRIMARY;
          if (!mUsers.get(UserHandle.USER_SYSTEM).isAdmin()) {
            flags|=UserInfo.FLAG_ADMIN;
          }
        }
        userId=getNextAvailableIdLocked();
        userInfo=new UserInfo(userId,name,null,flags);
        userInfo.serialNumber=mNextSerialNumber++;
        long now=System.currentTimeMillis();
        userInfo.creationTime=(now > EPOCH_PLUS_30_YEARS) ? now : 0;
        userInfo.partial=true;
        Environment.getUserSystemDirectory(userInfo.id).mkdirs();
        mUsers.put(userId,userInfo);
        writeUserListLocked();
        if (parent != null) {
          if (parent.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID) {
            parent.profileGroupId=parent.id;
            scheduleWriteUserLocked(parent);
          }
          userInfo.profileGroupId=parent.profileGroupId;
        }
        final StorageManager storage=mContext.getSystemService(StorageManager.class);
        for (        VolumeInfo vol : storage.getWritablePrivateVolumes()) {
          final String volumeUuid=vol.getFsUuid();
          try {
            final File userDir=Environment.getDataUserDirectory(volumeUuid,userId);
            prepareUserDirectory(mContext,volumeUuid,userId);
            enforceSerialNumber(userDir,userInfo.serialNumber);
          }
 catch (          IOException e) {
            Log.wtf(LOG_TAG,""String_Node_Str"" + volumeUuid,e);
          }
        }
        mPm.createNewUserLILPw(userId);
        userInfo.partial=false;
        scheduleWriteUserLocked(userInfo);
        updateUserIdsLocked();
        Bundle restrictions=new Bundle();
        mUserRestrictions.append(userId,restrictions);
      }
    }
    mPm.newUserCreated(userId);
    if (userInfo != null) {
      Intent addedIntent=new Intent(Intent.ACTION_USER_ADDED);
      addedIntent.putExtra(Intent.EXTRA_USER_HANDLE,userInfo.id);
      mContext.sendBroadcastAsUser(addedIntent,UserHandle.ALL,android.Manifest.permission.MANAGE_USERS);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return userInfo;
}","private UserInfo createUserInternal(String name,int flags,int parentId){
  if (getUserRestrictions(UserHandle.getCallingUserId()).getBoolean(UserManager.DISALLOW_ADD_USER,false)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    return null;
  }
  if (ActivityManager.isLowRamDeviceStatic()) {
    return null;
  }
  final boolean isGuest=(flags & UserInfo.FLAG_GUEST) != 0;
  final boolean isManagedProfile=(flags & UserInfo.FLAG_MANAGED_PROFILE) != 0;
  final long ident=Binder.clearCallingIdentity();
  UserInfo userInfo=null;
  final int userId;
  try {
synchronized (mInstallLock) {
synchronized (mPackagesLock) {
        UserInfo parent=null;
        if (parentId != UserHandle.USER_NULL) {
          parent=getUserInfoLocked(parentId);
          if (parent == null)           return null;
        }
        if (isManagedProfile && !canAddMoreManagedProfiles()) {
          return null;
        }
        if (!isGuest && !isManagedProfile && isUserLimitReachedLocked()) {
          return null;
        }
        if (isGuest && findCurrentGuestUserLocked() != null) {
          return null;
        }
        if (UserManager.isSplitSystemUser() && !isGuest && !isManagedProfile&& getPrimaryUser() == null) {
          flags|=UserInfo.FLAG_PRIMARY;
          DevicePolicyManager devicePolicyManager=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
          if (devicePolicyManager == null || devicePolicyManager.getDeviceOwner() == null) {
            flags|=UserInfo.FLAG_ADMIN;
          }
        }
        userId=getNextAvailableIdLocked();
        userInfo=new UserInfo(userId,name,null,flags);
        userInfo.serialNumber=mNextSerialNumber++;
        long now=System.currentTimeMillis();
        userInfo.creationTime=(now > EPOCH_PLUS_30_YEARS) ? now : 0;
        userInfo.partial=true;
        Environment.getUserSystemDirectory(userInfo.id).mkdirs();
        mUsers.put(userId,userInfo);
        writeUserListLocked();
        if (parent != null) {
          if (parent.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID) {
            parent.profileGroupId=parent.id;
            scheduleWriteUserLocked(parent);
          }
          userInfo.profileGroupId=parent.profileGroupId;
        }
        final StorageManager storage=mContext.getSystemService(StorageManager.class);
        for (        VolumeInfo vol : storage.getWritablePrivateVolumes()) {
          final String volumeUuid=vol.getFsUuid();
          try {
            final File userDir=Environment.getDataUserDirectory(volumeUuid,userId);
            prepareUserDirectory(mContext,volumeUuid,userId);
            enforceSerialNumber(userDir,userInfo.serialNumber);
          }
 catch (          IOException e) {
            Log.wtf(LOG_TAG,""String_Node_Str"" + volumeUuid,e);
          }
        }
        mPm.createNewUserLILPw(userId);
        userInfo.partial=false;
        scheduleWriteUserLocked(userInfo);
        updateUserIdsLocked();
        Bundle restrictions=new Bundle();
        mUserRestrictions.append(userId,restrictions);
      }
    }
    mPm.newUserCreated(userId);
    if (userInfo != null) {
      Intent addedIntent=new Intent(Intent.ACTION_USER_ADDED);
      addedIntent.putExtra(Intent.EXTRA_USER_HANDLE,userInfo.id);
      mContext.sendBroadcastAsUser(addedIntent,UserHandle.ALL,android.Manifest.permission.MANAGE_USERS);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return userInfo;
}",0.9569748399583148
194141,"private UserInfo createUserInternal(String name,int flags,int parentId){
  if (getUserRestrictions(UserHandle.getCallingUserId()).getBoolean(UserManager.DISALLOW_ADD_USER,false)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    return null;
  }
  if (ActivityManager.isLowRamDeviceStatic()) {
    return null;
  }
  final boolean isGuest=(flags & UserInfo.FLAG_GUEST) != 0;
  final boolean isManagedProfile=(flags & UserInfo.FLAG_MANAGED_PROFILE) != 0;
  final long ident=Binder.clearCallingIdentity();
  UserInfo userInfo=null;
  final int userId;
  try {
synchronized (mInstallLock) {
synchronized (mPackagesLock) {
        UserInfo parent=null;
        if (parentId != UserHandle.USER_NULL) {
          parent=getUserInfoLocked(parentId);
          if (parent == null)           return null;
        }
        if (isManagedProfile && !canAddMoreManagedProfiles()) {
          return null;
        }
        if (!isGuest && !isManagedProfile && isUserLimitReachedLocked()) {
          return null;
        }
        if (isGuest && findCurrentGuestUserLocked() != null) {
          return null;
        }
        if (UserManager.isSplitSystemUser() && !isGuest && !isManagedProfile&& mUsers.size() == 1) {
          flags|=UserInfo.FLAG_PRIMARY;
          if (!mUsers.get(UserHandle.USER_SYSTEM).isAdmin()) {
            flags|=UserInfo.FLAG_ADMIN;
          }
        }
        userId=getNextAvailableIdLocked();
        userInfo=new UserInfo(userId,name,null,flags);
        userInfo.serialNumber=mNextSerialNumber++;
        long now=System.currentTimeMillis();
        userInfo.creationTime=(now > EPOCH_PLUS_30_YEARS) ? now : 0;
        userInfo.partial=true;
        Environment.getUserSystemDirectory(userInfo.id).mkdirs();
        mUsers.put(userId,userInfo);
        writeUserListLocked();
        if (parent != null) {
          if (parent.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID) {
            parent.profileGroupId=parent.id;
            scheduleWriteUserLocked(parent);
          }
          userInfo.profileGroupId=parent.profileGroupId;
        }
        final StorageManager storage=mContext.getSystemService(StorageManager.class);
        for (        VolumeInfo vol : storage.getWritablePrivateVolumes()) {
          final String volumeUuid=vol.getFsUuid();
          try {
            final File userDir=Environment.getDataUserDirectory(volumeUuid,userId);
            prepareUserDirectory(mContext,volumeUuid,userId);
            enforceSerialNumber(userDir,userInfo.serialNumber);
          }
 catch (          IOException e) {
            Log.wtf(LOG_TAG,""String_Node_Str"" + volumeUuid,e);
          }
        }
        mPm.createNewUserLILPw(userId);
        userInfo.partial=false;
        scheduleWriteUserLocked(userInfo);
        updateUserIdsLocked();
        Bundle restrictions=new Bundle();
        mUserRestrictions.append(userId,restrictions);
      }
    }
    mPm.newUserCreated(userId);
    if (userInfo != null) {
      Intent addedIntent=new Intent(Intent.ACTION_USER_ADDED);
      addedIntent.putExtra(Intent.EXTRA_USER_HANDLE,userInfo.id);
      mContext.sendBroadcastAsUser(addedIntent,UserHandle.ALL,android.Manifest.permission.MANAGE_USERS);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return userInfo;
}","private UserInfo createUserInternal(String name,int flags,int parentId){
  if (getUserRestrictions(UserHandle.getCallingUserId()).getBoolean(UserManager.DISALLOW_ADD_USER,false)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    return null;
  }
  if (ActivityManager.isLowRamDeviceStatic()) {
    return null;
  }
  final boolean isGuest=(flags & UserInfo.FLAG_GUEST) != 0;
  final boolean isManagedProfile=(flags & UserInfo.FLAG_MANAGED_PROFILE) != 0;
  final long ident=Binder.clearCallingIdentity();
  UserInfo userInfo=null;
  final int userId;
  try {
synchronized (mInstallLock) {
synchronized (mPackagesLock) {
        UserInfo parent=null;
        if (parentId != UserHandle.USER_NULL) {
          parent=getUserInfoLocked(parentId);
          if (parent == null)           return null;
        }
        if (isManagedProfile && !canAddMoreManagedProfiles()) {
          return null;
        }
        if (!isGuest && !isManagedProfile && isUserLimitReachedLocked()) {
          return null;
        }
        if (isGuest && findCurrentGuestUserLocked() != null) {
          return null;
        }
        if (UserManager.isSplitSystemUser() && !isGuest && !isManagedProfile&& getPrimaryUser() == null) {
          flags|=UserInfo.FLAG_PRIMARY;
          DevicePolicyManager devicePolicyManager=(DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
          if (devicePolicyManager == null || devicePolicyManager.getDeviceOwner() == null) {
            flags|=UserInfo.FLAG_ADMIN;
          }
        }
        userId=getNextAvailableIdLocked();
        userInfo=new UserInfo(userId,name,null,flags);
        userInfo.serialNumber=mNextSerialNumber++;
        long now=System.currentTimeMillis();
        userInfo.creationTime=(now > EPOCH_PLUS_30_YEARS) ? now : 0;
        userInfo.partial=true;
        Environment.getUserSystemDirectory(userInfo.id).mkdirs();
        mUsers.put(userId,userInfo);
        writeUserListLocked();
        if (parent != null) {
          if (parent.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID) {
            parent.profileGroupId=parent.id;
            scheduleWriteUserLocked(parent);
          }
          userInfo.profileGroupId=parent.profileGroupId;
        }
        final StorageManager storage=mContext.getSystemService(StorageManager.class);
        for (        VolumeInfo vol : storage.getWritablePrivateVolumes()) {
          final String volumeUuid=vol.getFsUuid();
          try {
            final File userDir=Environment.getDataUserDirectory(volumeUuid,userId);
            prepareUserDirectory(mContext,volumeUuid,userId);
            enforceSerialNumber(userDir,userInfo.serialNumber);
          }
 catch (          IOException e) {
            Log.wtf(LOG_TAG,""String_Node_Str"" + volumeUuid,e);
          }
        }
        mPm.createNewUserLILPw(userId);
        userInfo.partial=false;
        scheduleWriteUserLocked(userInfo);
        updateUserIdsLocked();
        Bundle restrictions=new Bundle();
        mUserRestrictions.append(userId,restrictions);
      }
    }
    mPm.newUserCreated(userId);
    if (userInfo != null) {
      Intent addedIntent=new Intent(Intent.ACTION_USER_ADDED);
      addedIntent.putExtra(Intent.EXTRA_USER_HANDLE,userInfo.id);
      mContext.sendBroadcastAsUser(addedIntent,UserHandle.ALL,android.Manifest.permission.MANAGE_USERS);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return userInfo;
}",0.9569748399583148
194142,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194143,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194144,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194145,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194146,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194147,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194148,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194149,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194150,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194151,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194152,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194153,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194154,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194155,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194156,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194157,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194158,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194159,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194160,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194161,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194162,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194163,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194164,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194165,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194166,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194167,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194168,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194169,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194170,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194171,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194172,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194173,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194174,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194175,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194176,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194177,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194178,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194179,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194180,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194181,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194182,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194183,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194184,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194185,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194186,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194187,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194188,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194189,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194190,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194191,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194192,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194193,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194194,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194195,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194196,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194197,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194198,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194199,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194200,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194201,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194202,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194203,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194204,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194205,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194206,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194207,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194208,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194209,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194210,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194211,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194212,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194213,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194214,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194215,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194216,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194217,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194218,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194219,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194220,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194221,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194222,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194223,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194224,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194225,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194226,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194227,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194228,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194229,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194230,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194231,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194232,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194233,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194234,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194235,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194236,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194237,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194238,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194239,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194240,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194241,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194242,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194243,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194244,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194245,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194246,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194247,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194248,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194249,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194250,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194251,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194252,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194253,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194254,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194255,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194256,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194257,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194258,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194259,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194260,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194261,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194262,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194263,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194264,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194265,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194266,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194267,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194268,"/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (mUpdateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser())) {
    finish=true;
  }
 else   if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None || !mLockPatternUtils.isLockScreenDisabled(KeyguardUpdateMonitor.getCurrentUser())) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9915902140672784
194269,"public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId) || mUserFingerprintAuthenticated.get(userId);
}","public boolean getUserHasTrust(int userId){
  return !isTrustDisabled(userId) && mUserHasTrust.get(userId);
}",0.8288973384030418
194270,"@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!(mKeyguard.isSecure() && mKeyguard.isShowing() && !mKeyguard.isTrusted());
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}","@Override protected void handleUpdateState(BooleanState state,Object arg){
  state.visible=!mKeyguard.isSecure() || !mKeyguard.isShowing() || mKeyguard.canSkipBouncer();
  state.label=mContext.getString(R.string.quick_settings_cast_title);
  state.value=false;
  state.autoMirrorDrawable=false;
  final Set<CastDevice> devices=mController.getCastDevices();
  boolean connecting=false;
  for (  CastDevice device : devices) {
    if (device.state == CastDevice.STATE_CONNECTED) {
      state.value=true;
      state.label=getDeviceName(device);
    }
 else     if (device.state == CastDevice.STATE_CONNECTING) {
      connecting=true;
    }
  }
  if (!state.value && connecting) {
    state.label=mContext.getString(R.string.quick_settings_connecting);
  }
  state.icon=ResourceIcon.get(state.value ? R.drawable.ic_qs_cast_on : R.drawable.ic_qs_cast_off);
  mDetailAdapter.updateItems(devices);
}",0.9569110240626748
194271,"private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean currentUserHasTrust=updateMonitor.getUserHasTrust(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !currentUserHasTrust) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}","private Intent getCameraIntent(){
  KeyguardUpdateMonitor updateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  boolean canSkipBouncer=updateMonitor.getUserCanSkipBouncer(KeyguardUpdateMonitor.getCurrentUser());
  boolean secure=mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
  return (secure && !canSkipBouncer) ? SECURE_CAMERA_INTENT : INSECURE_CAMERA_INTENT;
}",0.8931297709923665
194272,"private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isCurrentlyInsecure()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}","private int getAnimationResForTransition(int oldState,int newState,boolean oldScreenOn,boolean screenOn){
  if (oldState == STATE_FINGERPRINT && newState == STATE_FINGERPRINT_ERROR) {
    return R.drawable.lockscreen_fingerprint_fp_to_error_state_animation;
  }
 else   if (oldState == STATE_FINGERPRINT_ERROR && newState == STATE_FINGERPRINT) {
    return R.drawable.lockscreen_fingerprint_error_state_to_fp_animation;
  }
 else   if (oldState == STATE_FINGERPRINT && newState == STATE_LOCK_OPEN && !mUnlockMethodCache.isTrusted()) {
    return R.drawable.lockscreen_fingerprint_draw_off_animation;
  }
 else   if (newState == STATE_FINGERPRINT && !oldScreenOn && screenOn) {
    return R.drawable.lockscreen_fingerprint_draw_on_animation;
  }
 else {
    return -1;
  }
}",0.9858611825192802
194273,"private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.isCurrentlyInsecure()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}","private int getState(){
  boolean fingerprintRunning=KeyguardUpdateMonitor.getInstance(mContext).isFingerprintDetectionRunning();
  if (mUnlockMethodCache.canSkipBouncer()) {
    return STATE_LOCK_OPEN;
  }
 else   if (mTransientFpError) {
    return STATE_FINGERPRINT_ERROR;
  }
 else   if (fingerprintRunning) {
    return STATE_FINGERPRINT;
  }
 else   if (mUnlockMethodCache.isFaceUnlockRunning()) {
    return STATE_FACE_UNLOCK;
  }
 else {
    return STATE_LOCKED;
  }
}",0.9655172413793104
194274,"public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
      showBouncer();
    }
  }
}","public void onTrackingStopped(boolean expand){
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    if (!expand && !mUnlockMethodCache.canSkipBouncer()) {
      showBouncer();
    }
  }
}",0.9265033407572384
194275,"private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean isCurrentlyInsecure=mUnlockMethodCache.isCurrentlyInsecure();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,isCurrentlyInsecure);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,isCurrentlyInsecure ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}","private void logStateToEventlog(){
  boolean isShowing=mStatusBarKeyguardViewManager.isShowing();
  boolean isOccluded=mStatusBarKeyguardViewManager.isOccluded();
  boolean isBouncerShowing=mStatusBarKeyguardViewManager.isBouncerShowing();
  boolean isSecure=mUnlockMethodCache.isMethodSecure();
  boolean canSkipBouncer=mUnlockMethodCache.canSkipBouncer();
  int stateFingerprint=getLoggingFingerprint(mState,isShowing,isOccluded,isBouncerShowing,isSecure,canSkipBouncer);
  if (stateFingerprint != mLastLoggedStateFingerprint) {
    EventLogTags.writeSysuiStatusBarState(mState,isShowing ? 1 : 0,isOccluded ? 1 : 0,isBouncerShowing ? 1 : 0,isSecure ? 1 : 0,canSkipBouncer ? 1 : 0);
    mLastLoggedStateFingerprint=stateFingerprint;
  }
}",0.9118825100133512
194276,"public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.isCurrentlyInsecure();
}","public boolean isKeyguardCurrentlySecure(){
  return !mUnlockMethodCache.canSkipBouncer();
}",0.8571428571428571
194277,"public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.isCurrentlyInsecure();
}","public void onTrackingStarted(){
  mExpanding=true;
  mDarkenWhileDragging=!mUnlockMethodCache.canSkipBouncer();
}",0.8841201716738197
194278,"private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean currentlyInsecure=!secure || mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || currentlyInsecure != mCurrentlyInsecure || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCurrentlyInsecure=currentlyInsecure;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}","private void update(boolean updateAlways){
  int user=KeyguardUpdateMonitor.getCurrentUser();
  boolean secure=mLockPatternUtils.isSecure(user);
  boolean canSkipBouncer=!secure || mKeyguardUpdateMonitor.getUserCanSkipBouncer(user);
  boolean trustManaged=mKeyguardUpdateMonitor.getUserTrustIsManaged(user);
  boolean trusted=mKeyguardUpdateMonitor.getUserHasTrust(user);
  boolean faceUnlockRunning=mKeyguardUpdateMonitor.isFaceUnlockRunning(user) && trustManaged;
  boolean changed=secure != mSecure || canSkipBouncer != mCanSkipBouncer || trustManaged != mTrustManaged || faceUnlockRunning != mFaceUnlockRunning;
  if (changed || updateAlways) {
    mSecure=secure;
    mCanSkipBouncer=canSkipBouncer;
    mTrusted=trusted;
    mTrustManaged=trustManaged;
    mFaceUnlockRunning=faceUnlockRunning;
    notifyListeners();
  }
}",0.573055028462998
194279,"public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateTrustedState();
    }
  }
;
}","public KeyguardMonitor(Context context){
  mContext=context;
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
  mUserTracker=new CurrentUserTracker(mContext){
    @Override public void onUserSwitched(    int newUserId){
      mCurrentUser=newUserId;
      updateCanSkipBouncerState();
    }
  }
;
}",0.9667194928684628
194280,"@Override public void onTrustChanged(int userId){
  updateTrustedState();
  notifyKeyguardChanged();
}","@Override public void onTrustChanged(int userId){
  updateCanSkipBouncerState();
  notifyKeyguardChanged();
}",0.909952606635071
194281,"@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateTrustedState();
}","@Override public void onUserSwitched(int newUserId){
  mCurrentUser=newUserId;
  updateCanSkipBouncerState();
}",0.9116279069767442
194282,"public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateTrustedState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}","public void addCallback(Callback callback){
  mCallbacks.add(callback);
  if (mCallbacks.size() != 0 && !mListening) {
    mListening=true;
    mCurrentUser=ActivityManager.getCurrentUser();
    updateCanSkipBouncerState();
    mKeyguardUpdateMonitor.registerCallback(this);
    mUserTracker.startTracking();
  }
}",0.966183574879227
194283,"@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.isTrusted();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}","@Override public int getCount(){
  boolean secureKeyguardShowing=mController.mKeyguardMonitor.isShowing() && mController.mKeyguardMonitor.isSecure() && !mController.mKeyguardMonitor.canSkipBouncer();
  if (!secureKeyguardShowing) {
    return mController.mUsers.size();
  }
  final int N=mController.mUsers.size();
  int count=0;
  for (int i=0; i < N; i++) {
    if (mController.mUsers.get(i).isRestricted) {
      break;
    }
 else {
      count++;
    }
  }
  return count;
}",0.9758656873032528
194284,"private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mContext.getPackageName(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}","private RemoteViews generateActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mContext.getApplicationInfo(),tombstone ? getActionTombstoneLayoutResource() : getActionLayoutResource());
  button.setTextViewCompoundDrawablesRelative(R.id.action0,action.icon,0,0,0);
  button.setTextViewText(R.id.action0,processLegacyText(action.title));
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  processLegacyAction(action,button);
  return button;
}",0.973365617433414
194285,"private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new RemoteViews(mBuilder.mContext.getPackageName(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}","private RemoteViews generateMediaActionButton(Action action){
  final boolean tombstone=(action.actionIntent == null);
  RemoteViews button=new BuilderRemoteViews(mBuilder.mContext.getApplicationInfo(),R.layout.notification_material_media_action);
  button.setImageViewResource(R.id.action0,action.icon);
  button.setDrawableParameters(R.id.action0,false,-1,0xFFFFFFFF,PorterDuff.Mode.SRC_ATOP,-1);
  if (!tombstone) {
    button.setOnClickPendingIntent(R.id.action0,action.actionIntent);
  }
  button.setContentDescription(R.id.action0,action.title);
  return button;
}",0.970770593445527
194286,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194287,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194288,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194289,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194290,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194291,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194292,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194293,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  mPermissionsState.copyFrom(base.mPermissionsState);
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  installPermissionsFixed=base.installPermissionsFixed;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  verificationInfo=base.verificationInfo;
  installerPackageName=base.installerPackageName;
}",0.9680306905370843
194294,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194295,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194296,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194297,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194298,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194299,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194300,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194301,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  installerPackageName=base.installerPackageName;
}",0.9671916010498688
194302,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194303,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  installerPackageName=base.installerPackageName;
}",0.9671916010498688
194304,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194305,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194306,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194307,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194308,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194309,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194310,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194311,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194312,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194313,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194314,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194315,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194316,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194317,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194318,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194319,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194320,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194321,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194322,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194323,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194324,"/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) == 0;
}","/** 
 * Returns true if assist data has been blocked starting at this node in the hierarchy.
 */
public boolean isAssistBlocked(){
  return (mFlags & ViewNode.FLAGS_ASSIST_BLOCKED) != 0;
}",0.9946808510638298
194325,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
  IResultReceiver sendReceiver=null;
  Bundle sendBundle=null;
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if ((sendReceiver=pae.receiver) != null) {
      sendBundle=new Bundle();
      sendBundle.putBundle(""String_Node_Str"",pae.extras);
      sendBundle.putParcelable(""String_Node_Str"",pae.structure);
      sendBundle.putParcelable(""String_Node_Str"",pae.content);
    }
  }
  if (sendReceiver != null) {
    try {
      sendReceiver.send(0,sendBundle);
    }
 catch (    RemoteException e) {
    }
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.926859250153657
194326,"@Override public void executeMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
}","@Override public void executeMessage(Message msg){
  SomeArgs args=null;
switch (msg.what) {
case MSG_START_CONFIRMATION:
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + msg.obj);
  onRequestConfirmation((ConfirmationRequest)msg.obj);
break;
case MSG_START_PICK_OPTION:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestPickOption((PickOptionRequest)msg.obj);
break;
case MSG_START_COMPLETE_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCompleteVoice((CompleteVoiceRequest)msg.obj);
break;
case MSG_START_ABORT_VOICE:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestAbortVoice((AbortVoiceRequest)msg.obj);
break;
case MSG_START_COMMAND:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onRequestCommand((CommandRequest)msg.obj);
break;
case MSG_SUPPORTS_COMMANDS:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1);
args.arg1=onGetSupportedCommands((String[])args.arg1);
args.complete();
args=null;
break;
case MSG_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + ((Request)msg.obj));
onCancelRequest((Request)msg.obj);
break;
case MSG_TASK_STARTED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskStarted((Intent)msg.obj,msg.arg1);
break;
case MSG_TASK_FINISHED:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ msg.arg1);
onTaskFinished((Intent)msg.obj,msg.arg1);
break;
case MSG_CLOSE_SYSTEM_DIALOGS:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
onCloseSystemDialogs();
break;
case MSG_DESTROY:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doDestroy();
break;
case MSG_HANDLE_ASSIST:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ args.arg2+ ""String_Node_Str""+ args.arg3);
doOnHandleAssist((Bundle)args.arg1,(AssistStructure)args.arg2,(Throwable)args.arg3,(AssistContent)args.arg4);
break;
case MSG_HANDLE_SCREENSHOT:
if (DEBUG) Log.d(TAG,""String_Node_Str"" + msg.obj);
onHandleScreenshot((Bitmap)msg.obj);
break;
case MSG_SHOW:
args=(SomeArgs)msg.obj;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + args.arg1 + ""String_Node_Str""+ msg.arg1+ ""String_Node_Str""+ args.arg2);
doShow((Bundle)args.arg1,msg.arg1,(IVoiceInteractionSessionShowCallback)args.arg2);
break;
case MSG_HIDE:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
doHide();
break;
}
if (args != null) {
args.recycle();
}
}",0.9846287075124486
194327,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!isVoiceInteraction()) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (!VoiceInteractionService.isActiveService(this,new ComponentName(this,MainInteractionService.class))) {
    Log.w(TAG,""String_Node_Str"");
    finish();
    return;
  }
  setContentView(R.layout.test_interaction);
  mLog=(TextView)findViewById(R.id.log);
  mAbortButton=(Button)findViewById(R.id.abort);
  mAbortButton.setOnClickListener(this);
  mCompleteButton=(Button)findViewById(R.id.complete);
  mCompleteButton.setOnClickListener(this);
  mCommandButton=(Button)findViewById(R.id.command);
  mCommandButton.setOnClickListener(this);
  mPickButton=(Button)findViewById(R.id.pick);
  mPickButton.setOnClickListener(this);
  mJumpOutButton=(Button)findViewById(R.id.jump);
  mJumpOutButton.setOnClickListener(this);
  mCancelButton=(Button)findViewById(R.id.cancel);
  mCancelButton.setOnClickListener(this);
  mInteractor=getVoiceInteractor();
  VoiceInteractor.Request[] active=mInteractor.getActiveRequests();
  for (int i=0; i < active.length; i++) {
    Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ active[i].getName()+ ""String_Node_Str""+ active[i]);
  }
  mCurrentRequest=mInteractor.getActiveRequest(REQUEST_CONFIRM);
  if (mCurrentRequest == null) {
    mCurrentRequest=new VoiceInteractor.ConfirmationRequest(new VoiceInteractor.Prompt(""String_Node_Str""),null){
      @Override public void onCancel(){
        Log.i(TAG,""String_Node_Str"");
        getActivity().finish();
      }
      @Override public void onConfirmationResult(      boolean confirmed,      Bundle result){
        Log.i(TAG,""String_Node_Str"" + confirmed + ""String_Node_Str""+ result);
        getActivity().finish();
      }
    }
;
    mInteractor.submitRequest(mCurrentRequest,REQUEST_CONFIRM);
    String[] cmds=new String[]{""String_Node_Str"",""String_Node_Str""};
    boolean sup[]=mInteractor.supportsCommands(cmds);
    for (int i=0; i < cmds.length; i++) {
      mLog.append(cmds[i] + ""String_Node_Str"" + (sup[i] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + mCurrentRequest);
  }
}",0.9310427105702695
194328,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194329,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194330,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194331,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194332,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194333,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194334,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194335,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194336,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194337,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194338,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194339,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194340,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194341,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194342,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194343,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194344,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194345,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194346,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194347,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194348,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194349,"@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,null,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  IIntentReceiver rd=null;
  if (resultReceiver != null) {
    if (mPackageInfo != null) {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=mPackageInfo.getReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,mMainThread.getInstrumentation(),false);
    }
 else {
      if (scheduler == null) {
        scheduler=mMainThread.getHandler();
      }
      rd=new LoadedApk.ReceiverDispatcher(resultReceiver,getOuterContext(),scheduler,null,false).getIIntentReceiver();
    }
  }
  String resolvedType=intent.resolveTypeIfNeeded(getContentResolver());
  String[] receiverPermissions=receiverPermission == null ? null : new String[]{receiverPermission};
  try {
    intent.prepareToLeaveProcess();
    ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(),intent,resolvedType,rd,initialCode,initialData,initialExtras,receiverPermissions,appOp,options,true,false,user.getIdentifier());
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.98989898989899
194350,"/** 
 * Similar to above but takes an appOp as well, to enforce restrictions.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);","/** 
 * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
 * @see #sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)
 * @hide
 */
public abstract void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,@Nullable String receiverPermission,int appOp,@Nullable Bundle options,BroadcastReceiver resultReceiver,@Nullable Handler scheduler,int initialCode,@Nullable String initialData,@Nullable Bundle initialExtras);",0.9503105590062112
194351,"/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}","/** 
 * @hide 
 */
@Override public void sendOrderedBroadcastAsUser(Intent intent,UserHandle user,String receiverPermission,int appOp,Bundle options,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras){
  mBase.sendOrderedBroadcastAsUser(intent,user,receiverPermission,appOp,options,resultReceiver,scheduler,initialCode,initialData,initialExtras);
}",0.9707006369426752
194352,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194353,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194354,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194355,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194356,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194357,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194358,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194359,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194360,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194361,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194362,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194363,"/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}","/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (isPasspoint() == false && networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}",0.9610778443113772
194364,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194365,"/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}","/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (isPasspoint() == false && networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}",0.9610778443113772
194366,"/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}","/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (isPasspoint() == false && networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}",0.9610778443113772
194367,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194368,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194369,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194370,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194371,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
        mCallbackHandler.setSubs(subs);
      }
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.9986168741355465
194372,"@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}","@Override public boolean onPreferenceChange(Preference preference,Object newValue){
  if (preference == mEnabledSwitch) {
    if (newValue != Boolean.TRUE) {
      mOnSwitch.setChecked(false);
      stopDemoMode();
    }
    setGlobal(DEMO_MODE_ALLOWED,newValue == Boolean.TRUE ? 1 : 0);
  }
 else   if (preference == mOnSwitch) {
    if (newValue == Boolean.TRUE) {
      startDemoMode();
    }
 else {
      stopDemoMode();
    }
  }
 else {
    return false;
  }
  return true;
}",0.8855491329479769
194373,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194374,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194375,"@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPrevLine,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPrevLine;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPrevLine;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}","@Override public void updatePosition(float x,float y){
  final Layout layout=mTextView.getLayout();
  if (layout == null) {
    positionAtCursorOffset(mTextView.getOffsetForPosition(x,y),false);
    return;
  }
  if (mPreviousLineTouched == UNSET_LINE) {
    mPreviousLineTouched=mTextView.getLineAtCoordinate(y);
  }
  boolean positionCursor=false;
  final int selectionStart=mTextView.getSelectionStart();
  int currLine=getCurrentLineAdjustedForSlop(layout,mPreviousLineTouched,y);
  int initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  if (initialOffset <= selectionStart) {
    currLine=layout.getLineForOffset(selectionStart);
    initialOffset=mTextView.getOffsetAtCoordinate(currLine,x);
  }
  int offset=initialOffset;
  int end=getWordEnd(offset);
  int start=getWordStart(offset);
  if (mPrevX == UNSET_X_VALUE) {
    mPrevX=x;
  }
  final int selectionEnd=mTextView.getSelectionEnd();
  final boolean selectionEndRtl=layout.isRtlCharAt(selectionEnd);
  final boolean atRtl=layout.isRtlCharAt(offset);
  final boolean isLvlBoundary=layout.isLevelBoundary(offset);
  boolean isExpanding;
  if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
    mLanguageDirectionChanged=true;
    mTouchWordDelta=0.0f;
    positionAtCursorOffset(offset,false);
    return;
  }
 else   if (mLanguageDirectionChanged && !isLvlBoundary) {
    positionAtCursorOffset(offset,false);
    mTouchWordDelta=0.0f;
    mLanguageDirectionChanged=false;
    return;
  }
 else {
    final float xDiff=x - mPrevX;
    if (atRtl) {
      isExpanding=xDiff < 0 || currLine < mPreviousLineTouched;
    }
 else {
      isExpanding=xDiff > 0 || currLine > mPreviousLineTouched;
    }
  }
  if (isExpanding) {
    if (!mInWord || currLine > mPrevLine) {
      int wordEndOnCurrLine=end;
      if (layout != null && layout.getLineForOffset(end) != currLine) {
        wordEndOnCurrLine=layout.getLineEnd(currLine);
      }
      final int offsetThresholdToSnap=start + ((wordEndOnCurrLine - start) / 2);
      if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
        offset=end;
      }
 else {
        offset=mPreviousOffset;
      }
    }
    if (offset > initialOffset) {
      final float adjustedX=layout.getPrimaryHorizontal(offset);
      mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
    }
 else {
      mTouchWordDelta=0.0f;
    }
    positionCursor=true;
  }
 else {
    final int adjustedOffset=mTextView.getOffsetAtCoordinate(currLine,x + mTouchWordDelta);
    if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
      if (currLine < mPrevLine) {
        offset=end;
        if (offset > initialOffset) {
          final float adjustedX=layout.getPrimaryHorizontal(offset);
          mTouchWordDelta=adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        }
 else {
          mTouchWordDelta=0.0f;
        }
      }
 else {
        offset=adjustedOffset;
      }
      positionCursor=true;
    }
 else     if (adjustedOffset > mPreviousOffset) {
      mTouchWordDelta=layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
    }
  }
  if (positionCursor) {
    if (offset <= selectionStart) {
      offset=getNextCursorOffset(selectionStart,true);
      mTouchWordDelta=0.0f;
    }
    mPreviousLineTouched=currLine;
    positionAtCursorOffset(offset,false);
  }
  mPrevX=x;
}",0.9511645379413974
194376,"/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}","/** 
 * Return whether the given   {@link WifiInfo} is for this access point. 
 */
private boolean isInfoForThisAccessPoint(WifiInfo info){
  if (isPasspoint() == false && networkId != WifiConfiguration.INVALID_NETWORK_ID) {
    return networkId == info.getNetworkId();
  }
 else {
    return ssid.equals(removeDoubleQuotes(info.getSSID()));
  }
}",0.9610778443113772
194377,"/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
}","/** 
 * Make a shallow copy of this package settings.
 */
public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  primaryCpuAbiString=base.primaryCpuAbiString;
  secondaryCpuAbiString=base.secondaryCpuAbiString;
  cpuAbiOverrideString=base.cpuAbiOverrideString;
  timeStamp=base.timeStamp;
  firstInstallTime=base.firstInstallTime;
  lastUpdateTime=base.lastUpdateTime;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  userState.clear();
  for (int i=0; i < base.userState.size(); i++) {
    userState.put(base.userState.keyAt(i),base.userState.valueAt(i));
  }
  installStatus=base.installStatus;
  keySetData=base.keySetData;
  installerPackageName=base.installerPackageName;
}",0.9671916010498688
194378,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194379,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194380,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194381,"@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    wifiFirmwareReload(wlanIface,""String_Node_Str"");
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}","@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}",0.9616220130340332
194382,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194383,"/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    srcBuffer=srcPlanes[i].getBuffer();
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer=dstPlanes[i].getBuffer();
    dstBuffer.rewind();
    dstBuffer.put(srcBuffer);
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}","/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    int srcRowStride=srcPlanes[i].getRowStride();
    int dstRowStride=dstPlanes[i].getRowStride();
    srcBuffer=srcPlanes[i].getBuffer();
    dstBuffer=dstPlanes[i].getBuffer();
    if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
      throw new IllegalArgumentException(""String_Node_Str"" + srcPlanes[i].getPixelStride() + ""String_Node_Str""+ dstPlanes[i].getPixelStride());
    }
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer.rewind();
    if (srcRowStride == dstRowStride) {
      dstBuffer.put(srcBuffer);
    }
 else {
      int srcOffset=srcBuffer.position();
      int dstOffset=dstBuffer.position();
      Size effectivePlaneSize=getEffectivePlaneSizeForImage(src,i);
      int srcByteCount=effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
      for (int row=0; row < effectivePlaneSize.getHeight(); row++) {
        if (row == effectivePlaneSize.getHeight() - 1) {
          int remainingBytes=srcBuffer.remaining() - srcOffset;
          if (srcByteCount > remainingBytes) {
            srcByteCount=remainingBytes;
          }
        }
        directByteBufferCopy(srcBuffer,srcOffset,dstBuffer,dstOffset,srcByteCount);
        srcOffset+=srcRowStride;
        dstOffset+=dstRowStride;
      }
    }
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}",0.679140127388535
194384,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194385,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194386,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194387,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194388,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194389,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194390,"private void runPostCollapseRunnables(){
  int size=mPostCollapseRunnables.size();
  for (int i=0; i < size; i++) {
    mPostCollapseRunnables.get(i).run();
  }
  mPostCollapseRunnables.clear();
}","private void runPostCollapseRunnables(){
  ArrayList<Runnable> clonedList=new ArrayList<>(mPostCollapseRunnables);
  mPostCollapseRunnables.clear();
  int size=clonedList.size();
  for (int i=0; i < size; i++) {
    clonedList.get(i).run();
  }
}",0.5972850678733032
194391,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194392,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194393,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194394,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194395,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194396,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194397,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194398,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194399,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194400,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194401,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194402,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  final boolean hideWhenLocked=!(((win.mIsImWindow || imeTarget == win) && showImeOverKeyguard) || (appShowWhenLocked != null && (appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0)));
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && hideWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.isAnimatingLw() || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY);
}",0.8339587242026266
194403,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194404,"public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && group.expanded) {
    return true;
  }
  return false;
}","public boolean isVisible(StatusBarNotification sbn){
  if (!sbn.getNotification().isGroupChild()) {
    return true;
  }
  NotificationGroup group=mGroupMap.get(sbn.getGroupKey());
  if (group != null && (group.expanded || group.summary == null)) {
    return true;
  }
  return false;
}",0.9506398537477148
194405,"@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    wifiFirmwareReload(wlanIface,""String_Node_Str"");
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}","@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}",0.9616220130340332
194406,"@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    wifiFirmwareReload(wlanIface,""String_Node_Str"");
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}","@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}",0.9616220130340332
194407,"@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    wifiFirmwareReload(wlanIface,""String_Node_Str"");
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}","@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}",0.9616220130340332
194408,"@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    wifiFirmwareReload(wlanIface,""String_Node_Str"");
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}","@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}",0.9616220130340332
194409,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194410,"/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    srcBuffer=srcPlanes[i].getBuffer();
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer=dstPlanes[i].getBuffer();
    dstBuffer.rewind();
    dstBuffer.put(srcBuffer);
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}","/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    int srcRowStride=srcPlanes[i].getRowStride();
    int dstRowStride=dstPlanes[i].getRowStride();
    srcBuffer=srcPlanes[i].getBuffer();
    dstBuffer=dstPlanes[i].getBuffer();
    if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
      throw new IllegalArgumentException(""String_Node_Str"" + srcPlanes[i].getPixelStride() + ""String_Node_Str""+ dstPlanes[i].getPixelStride());
    }
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer.rewind();
    if (srcRowStride == dstRowStride) {
      dstBuffer.put(srcBuffer);
    }
 else {
      int srcOffset=srcBuffer.position();
      int dstOffset=dstBuffer.position();
      Size effectivePlaneSize=getEffectivePlaneSizeForImage(src,i);
      int srcByteCount=effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
      for (int row=0; row < effectivePlaneSize.getHeight(); row++) {
        if (row == effectivePlaneSize.getHeight() - 1) {
          int remainingBytes=srcBuffer.remaining() - srcOffset;
          if (srcByteCount > remainingBytes) {
            srcByteCount=remainingBytes;
          }
        }
        directByteBufferCopy(srcBuffer,srcOffset,dstBuffer,dstOffset,srcByteCount);
        srcOffset+=srcRowStride;
        dstOffset+=dstRowStride;
      }
    }
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}",0.679140127388535
194411,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194412,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194413,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194414,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194415,"/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    srcBuffer=srcPlanes[i].getBuffer();
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer=dstPlanes[i].getBuffer();
    dstBuffer.rewind();
    dstBuffer.put(srcBuffer);
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}","/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    int srcRowStride=srcPlanes[i].getRowStride();
    int dstRowStride=dstPlanes[i].getRowStride();
    srcBuffer=srcPlanes[i].getBuffer();
    dstBuffer=dstPlanes[i].getBuffer();
    if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
      throw new IllegalArgumentException(""String_Node_Str"" + srcPlanes[i].getPixelStride() + ""String_Node_Str""+ dstPlanes[i].getPixelStride());
    }
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer.rewind();
    if (srcRowStride == dstRowStride) {
      dstBuffer.put(srcBuffer);
    }
 else {
      int srcOffset=srcBuffer.position();
      int dstOffset=dstBuffer.position();
      Size effectivePlaneSize=getEffectivePlaneSizeForImage(src,i);
      int srcByteCount=effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
      for (int row=0; row < effectivePlaneSize.getHeight(); row++) {
        if (row == effectivePlaneSize.getHeight() - 1) {
          int remainingBytes=srcBuffer.remaining() - srcOffset;
          if (srcByteCount > remainingBytes) {
            srcByteCount=remainingBytes;
          }
        }
        directByteBufferCopy(srcBuffer,srcOffset,dstBuffer,dstOffset,srcByteCount);
        srcOffset+=srcRowStride;
        dstOffset+=dstRowStride;
      }
    }
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}",0.679140127388535
194416,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194417,"/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    srcBuffer=srcPlanes[i].getBuffer();
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer=dstPlanes[i].getBuffer();
    dstBuffer.rewind();
    dstBuffer.put(srcBuffer);
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}","/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    int srcRowStride=srcPlanes[i].getRowStride();
    int dstRowStride=dstPlanes[i].getRowStride();
    srcBuffer=srcPlanes[i].getBuffer();
    dstBuffer=dstPlanes[i].getBuffer();
    if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
      throw new IllegalArgumentException(""String_Node_Str"" + srcPlanes[i].getPixelStride() + ""String_Node_Str""+ dstPlanes[i].getPixelStride());
    }
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer.rewind();
    if (srcRowStride == dstRowStride) {
      dstBuffer.put(srcBuffer);
    }
 else {
      int srcOffset=srcBuffer.position();
      int dstOffset=dstBuffer.position();
      Size effectivePlaneSize=getEffectivePlaneSizeForImage(src,i);
      int srcByteCount=effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
      for (int row=0; row < effectivePlaneSize.getHeight(); row++) {
        if (row == effectivePlaneSize.getHeight() - 1) {
          int remainingBytes=srcBuffer.remaining() - srcOffset;
          if (srcByteCount > remainingBytes) {
            srcByteCount=remainingBytes;
          }
        }
        directByteBufferCopy(srcBuffer,srcOffset,dstBuffer,dstOffset,srcByteCount);
        srcOffset+=srcRowStride;
        dstOffset+=dstRowStride;
      }
    }
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}",0.679140127388535
194418,"/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    srcBuffer=srcPlanes[i].getBuffer();
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer=dstPlanes[i].getBuffer();
    dstBuffer.rewind();
    dstBuffer.put(srcBuffer);
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}","/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    int srcRowStride=srcPlanes[i].getRowStride();
    int dstRowStride=dstPlanes[i].getRowStride();
    srcBuffer=srcPlanes[i].getBuffer();
    dstBuffer=dstPlanes[i].getBuffer();
    if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
      throw new IllegalArgumentException(""String_Node_Str"" + srcPlanes[i].getPixelStride() + ""String_Node_Str""+ dstPlanes[i].getPixelStride());
    }
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer.rewind();
    if (srcRowStride == dstRowStride) {
      dstBuffer.put(srcBuffer);
    }
 else {
      int srcOffset=srcBuffer.position();
      int dstOffset=dstBuffer.position();
      Size effectivePlaneSize=getEffectivePlaneSizeForImage(src,i);
      int srcByteCount=effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
      for (int row=0; row < effectivePlaneSize.getHeight(); row++) {
        if (row == effectivePlaneSize.getHeight() - 1) {
          int remainingBytes=srcBuffer.remaining() - srcOffset;
          if (srcByteCount > remainingBytes) {
            srcByteCount=remainingBytes;
          }
        }
        directByteBufferCopy(srcBuffer,srcOffset,dstBuffer,dstOffset,srcByteCount);
        srcOffset+=srcRowStride;
        dstOffset+=dstRowStride;
      }
    }
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}",0.679140127388535
194419,"private void onViewAddedInternal(View child){
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}","private void onViewAddedInternal(View child){
  updateHideSensitiveForChild(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  ((ExpandableView)child).setOnHeightChangedListener(this);
  generateAddAnimation(child,false);
  updateAnimationState(child);
  if (canChildBeDismissed(child)) {
    mDismissView.showClearButton();
  }
}",0.9411764705882352
194420,"/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    srcBuffer=srcPlanes[i].getBuffer();
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer=dstPlanes[i].getBuffer();
    dstBuffer.rewind();
    dstBuffer.put(srcBuffer);
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}","/** 
 * <p> Copy source image data to destination Image. </p> <p> Only support the copy between two non-  {@link ImageFormat#PRIVATE PRIVATE} formatimages with same properties (format, size, etc.). The data from the source image will be copied to the byteBuffers from the destination Image starting from position zero, and the destination image will be rewound to zero after copy is done. </p>
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination imageshave different format, or one of the images is not copyable.
 */
public static void imageCopy(Image src,Image dst){
  if (src == null || dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() != dst.getFormat()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(dst.getOwner() instanceof ImageWriter)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Size srcSize=new Size(src.getWidth(),src.getHeight());
  Size dstSize=new Size(dst.getWidth(),dst.getHeight());
  if (!srcSize.equals(dstSize)) {
    throw new IllegalArgumentException(""String_Node_Str"" + srcSize + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ dstSize);
  }
  Plane[] srcPlanes=src.getPlanes();
  Plane[] dstPlanes=dst.getPlanes();
  ByteBuffer srcBuffer=null;
  ByteBuffer dstBuffer=null;
  for (int i=0; i < srcPlanes.length; i++) {
    int srcRowStride=srcPlanes[i].getRowStride();
    int dstRowStride=dstPlanes[i].getRowStride();
    srcBuffer=srcPlanes[i].getBuffer();
    dstBuffer=dstPlanes[i].getBuffer();
    if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
      throw new IllegalArgumentException(""String_Node_Str"" + srcPlanes[i].getPixelStride() + ""String_Node_Str""+ dstPlanes[i].getPixelStride());
    }
    int srcPos=srcBuffer.position();
    srcBuffer.rewind();
    dstBuffer.rewind();
    if (srcRowStride == dstRowStride) {
      dstBuffer.put(srcBuffer);
    }
 else {
      int srcOffset=srcBuffer.position();
      int dstOffset=dstBuffer.position();
      Size effectivePlaneSize=getEffectivePlaneSizeForImage(src,i);
      int srcByteCount=effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
      for (int row=0; row < effectivePlaneSize.getHeight(); row++) {
        if (row == effectivePlaneSize.getHeight() - 1) {
          int remainingBytes=srcBuffer.remaining() - srcOffset;
          if (srcByteCount > remainingBytes) {
            srcByteCount=remainingBytes;
          }
        }
        directByteBufferCopy(srcBuffer,srcOffset,dstBuffer,dstOffset,srcByteCount);
        srcOffset+=srcRowStride;
        dstOffset+=dstRowStride;
      }
    }
    srcBuffer.position(srcPos);
    dstBuffer.rewind();
  }
}",0.679140127388535
194421,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194422,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194423,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194424,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194425,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194426,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194427,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194428,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194429,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194430,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194431,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194432,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194433,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194434,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194435,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194436,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194437,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194438,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194439,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194440,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194441,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194442,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194443,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194444,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194445,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194446,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194447,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194448,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194449,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194450,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194451,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194452,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194453,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194454,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194455,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194456,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194457,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194458,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194459,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194460,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194461,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194462,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194463,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194464,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194465,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194466,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194467,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194468,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194469,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194470,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194471,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194472,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194473,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194474,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194475,"@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawUptimeUs,long rawRealtimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}","@Override public void calculateApp(BatterySipper app,BatteryStats.Uid u,long rawRealtimeUs,long rawUptimeUs,int statsType){
  long wakeLockTimeUs=0;
  final ArrayMap<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
  final int wakelockStatsCount=wakelockStats.size();
  for (int i=0; i < wakelockStatsCount; i++) {
    final BatteryStats.Uid.Wakelock wakelock=wakelockStats.valueAt(i);
    BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
    if (timer != null) {
      wakeLockTimeUs+=timer.getTotalTimeLocked(rawRealtimeUs,statsType);
    }
  }
  app.wakeLockTimeMs=wakeLockTimeUs / 1000;
  mTotalAppWakelockTimeMs+=app.wakeLockTimeMs;
  app.wakeLockPowerMah=(app.wakeLockTimeMs * mPowerWakelock) / (1000 * 60 * 60);
  if (DEBUG && app.wakeLockPowerMah != 0) {
    Log.d(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ app.wakeLockTimeMs+ ""String_Node_Str""+ BatteryStatsHelper.makemAh(app.wakeLockPowerMah));
  }
}",0.9939086294416244
194476,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
final String packageName=res.pkg.applicationInfo.packageName;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,""String_Node_Str"" + idx + ""String_Node_Str""+ params);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,""String_Node_Str"");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,""String_Node_Str"");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,""String_Node_Str"");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,""String_Node_Str"");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,""String_Node_Str"");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier());
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,""String_Node_Str"" + res.pkg + ""String_Node_Str"");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"" + reportStatus + ""String_Node_Str""+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings(""String_Node_Str"") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,""String_Node_Str"" + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,""String_Node_Str"" + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,""String_Node_Str"");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,""String_Node_Str"" + verificationId + ""String_Node_Str"");
}
break;
}
}
}",0.9949732446894762
194477,"/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorId;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}","/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorInfo;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}",0.998017839444995
194478,"@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  Inet4Address example2=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}","@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=v4Address(""String_Node_Str"");
  Inet4Address example2=v4Address(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}",0.948586118251928
194479,"private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorId);
}","private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorInfo);
}",0.9956896551724138
194480,"public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_CLASS_ID,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}","public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_INFO,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}",0.9891774891774892
194481,"/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorId;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}","/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorInfo;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}",0.998017839444995
194482,"@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  Inet4Address example2=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}","@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=v4Address(""String_Node_Str"");
  Inet4Address example2=v4Address(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}",0.948586118251928
194483,"private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorId);
}","private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorInfo);
}",0.9956896551724138
194484,"public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_CLASS_ID,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}","public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_INFO,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}",0.9891774891774892
194485,"/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorId;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}","/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorInfo;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}",0.998017839444995
194486,"@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  Inet4Address example2=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}","@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=v4Address(""String_Node_Str"");
  Inet4Address example2=v4Address(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}",0.948586118251928
194487,"private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorId);
}","private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorInfo);
}",0.9956896551724138
194488,"public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_CLASS_ID,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}","public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_INFO,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}",0.9891774891774892
194489,"/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorId;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}","/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorInfo;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}",0.998017839444995
194490,"@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  Inet4Address example2=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}","@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=v4Address(""String_Node_Str"");
  Inet4Address example2=v4Address(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}",0.948586118251928
194491,"private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorId);
}","private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorInfo);
}",0.9956896551724138
194492,"public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_CLASS_ID,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}","public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_INFO,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}",0.9891774891774892
194493,"/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorId;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}","/** 
 * Construct a DhcpResults object from a DHCP reply packet.
 */
public DhcpResults toDhcpResults(){
  Inet4Address ipAddress=mYourIp;
  if (ipAddress.equals(Inet4Address.ANY)) {
    ipAddress=mClientIp;
    if (ipAddress.equals(Inet4Address.ANY)) {
      return null;
    }
  }
  int prefixLength;
  if (mSubnetMask != null) {
    try {
      prefixLength=NetworkUtils.netmaskToPrefixLength(mSubnetMask);
    }
 catch (    IllegalArgumentException e) {
      return null;
    }
  }
 else {
    prefixLength=NetworkUtils.getImplicitNetmask(ipAddress);
  }
  DhcpResults results=new DhcpResults();
  try {
    results.ipAddress=new LinkAddress(ipAddress,prefixLength);
  }
 catch (  IllegalArgumentException e) {
    return null;
  }
  results.gateway=mGateway;
  results.dnsServers.addAll(mDnsServers);
  results.domains=mDomainName;
  results.serverAddress=mServerIdentifier;
  results.vendorInfo=mVendorInfo;
  results.leaseDuration=(mLeaseTime != null) ? mLeaseTime : INFINITE_LEASE;
  return results;
}",0.998017839444995
194494,"@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  Inet4Address example2=(Inet4Address)NetworkUtils.numericToInetAddress(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}","@SmallTest public void testIpAddress() throws Exception {
  byte[] slash11Netmask=new byte[]{(byte)0xff,(byte)0xe0,0x00,0x00};
  byte[] slash24Netmask=new byte[]{(byte)0xff,(byte)0xff,(byte)0xff,0x00};
  byte[] invalidNetmask=new byte[]{(byte)0xff,(byte)0xfb,(byte)0xff,0x00};
  Inet4Address example1=v4Address(""String_Node_Str"");
  Inet4Address example2=v4Address(""String_Node_Str"");
  checkIpAddress(null,ANY,ANY,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,example1,slash24Netmask);
  checkIpAddress(""String_Node_Str"",example2,ANY,slash11Netmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,slash11Netmask);
  checkIpAddress(null,example2,ANY,invalidNetmask);
  checkIpAddress(""String_Node_Str"",ANY,example2,null);
}",0.948586118251928
194495,"private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorId);
}","private void assertDomainAndVendorInfoParses(String expectedDomain,byte[] domainBytes,String expectedVendorInfo,byte[] vendorInfoBytes){
  ByteBuffer packet=new TestDhcpPacket(DHCP_MESSAGE_TYPE_OFFER).setDomainBytes(domainBytes).setVendorInfoBytes(vendorInfoBytes).build();
  DhcpPacket offerPacket=DhcpPacket.decodeFullPacket(packet,ENCAP_BOOTP);
  assertEquals(expectedDomain,offerPacket.mDomainName);
  assertEquals(expectedVendorInfo,offerPacket.mVendorInfo);
}",0.9956896551724138
194496,"public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_CLASS_ID,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}","public void finishPacket(ByteBuffer buffer){
  addTlv(buffer,DHCP_MESSAGE_TYPE,mType);
  if (mDomainBytes != null) {
    addTlv(buffer,DHCP_DOMAIN_NAME,mDomainBytes);
  }
  if (mVendorInfoBytes != null) {
    addTlv(buffer,DHCP_VENDOR_INFO,mVendorInfoBytes);
  }
  if (mLeaseTimeBytes != null) {
    addTlv(buffer,DHCP_LEASE_TIME,mLeaseTimeBytes);
  }
  if (mNetmaskBytes != null) {
    addTlv(buffer,DHCP_SUBNET_MASK,mNetmaskBytes);
  }
  addTlvEnd(buffer);
}",0.9891774891774892
194497,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int callingUid,int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    int callingAppId=UserHandle.getAppId(callingUid);
    if (callingAppId >= Process.FIRST_APPLICATION_UID) {
      if (!mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
        throw new SecurityException(""String_Node_Str"" + UserHandle.formatUid(callingUid) + ""String_Node_Str"");
      }
    }
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}",0.8305540613232921
194498,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mPowerSaveWhitelistApps.put(ai.packageName,UserHandle.getAppId(ai.uid));
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          int appid=UserHandle.getAppId(ai.uid);
          mPowerSaveWhitelistApps.put(ai.packageName,appid);
          mPowerSaveWhitelistSystemAppIds.put(appid,true);
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}",0.940273037542662
194499,"private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
  }
}","private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAllAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAllAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAllAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAllAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
  }
}",0.9851668726823238
194500,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(int callingUid,String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(callingUid,appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}",0.9737373737373738
194501,"public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAppIdArray;
  }
}","public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAllAppIdArray;
  }
}",0.9866666666666668
194502,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9901095963646084
194503,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          stepIdleStateLocked();
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (mEnabled) {
            mEnabled=false;
            becomeActiveLocked(""String_Node_Str"",Process.myUid());
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (!mEnabled) {
            mEnabled=true;
            becomeInactiveIfAppropriateLocked();
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        while (i < args.length) {
          arg=args[i];
          i++;
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
            pw.println(""String_Node_Str"" + arg);
            return;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          return;
        }
        while (i < args.length) {
          arg=args[i];
          i++;
          addPowerSaveTempWhitelistAppInternal(arg,10000L,userId);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked(""String_Node_Str"",Process.myUid());
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println(""String_Node_Str"" + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
 else {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println(""String_Node_Str"");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}",0.93003300330033
194504,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_IDLE_OFF:
{
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  EventLogTags.writeDeviceIdleOnStart();
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}",0.8922974324774925
194505,"@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  final int callingUid=Binder.getCallingUid();
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),callingUid,userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(callingUid,packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9427662957074722
194506,"public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
}","public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  addPowerSaveTempWhitelistAppDirectInternal(0,appId,duration);
}",0.9066666666666666
194507,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int callingUid,int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    int callingAppId=UserHandle.getAppId(callingUid);
    if (callingAppId >= Process.FIRST_APPLICATION_UID) {
      if (!mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
        throw new SecurityException(""String_Node_Str"" + UserHandle.formatUid(callingUid) + ""String_Node_Str"");
      }
    }
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}",0.8305540613232921
194508,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mPowerSaveWhitelistApps.put(ai.packageName,UserHandle.getAppId(ai.uid));
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          int appid=UserHandle.getAppId(ai.uid);
          mPowerSaveWhitelistApps.put(ai.packageName,appid);
          mPowerSaveWhitelistSystemAppIds.put(appid,true);
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}",0.940273037542662
194509,"private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
  }
}","private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAllAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAllAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAllAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAllAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
  }
}",0.9851668726823238
194510,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(int callingUid,String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(callingUid,appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}",0.9737373737373738
194511,"public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAppIdArray;
  }
}","public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAllAppIdArray;
  }
}",0.9866666666666668
194512,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9901095963646084
194513,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          stepIdleStateLocked();
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (mEnabled) {
            mEnabled=false;
            becomeActiveLocked(""String_Node_Str"",Process.myUid());
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (!mEnabled) {
            mEnabled=true;
            becomeInactiveIfAppropriateLocked();
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        while (i < args.length) {
          arg=args[i];
          i++;
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
            pw.println(""String_Node_Str"" + arg);
            return;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          return;
        }
        while (i < args.length) {
          arg=args[i];
          i++;
          addPowerSaveTempWhitelistAppInternal(arg,10000L,userId);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked(""String_Node_Str"",Process.myUid());
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println(""String_Node_Str"" + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
 else {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println(""String_Node_Str"");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}",0.93003300330033
194514,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_IDLE_OFF:
{
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  EventLogTags.writeDeviceIdleOnStart();
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}",0.8922974324774925
194515,"@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  final int callingUid=Binder.getCallingUid();
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),callingUid,userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(callingUid,packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9427662957074722
194516,"public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
}","public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  addPowerSaveTempWhitelistAppDirectInternal(0,appId,duration);
}",0.9066666666666666
194517,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int callingUid,int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    int callingAppId=UserHandle.getAppId(callingUid);
    if (callingAppId >= Process.FIRST_APPLICATION_UID) {
      if (!mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
        throw new SecurityException(""String_Node_Str"" + UserHandle.formatUid(callingUid) + ""String_Node_Str"");
      }
    }
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}",0.8305540613232921
194518,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mPowerSaveWhitelistApps.put(ai.packageName,UserHandle.getAppId(ai.uid));
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          int appid=UserHandle.getAppId(ai.uid);
          mPowerSaveWhitelistApps.put(ai.packageName,appid);
          mPowerSaveWhitelistSystemAppIds.put(appid,true);
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}",0.940273037542662
194519,"private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
  }
}","private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAllAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAllAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAllAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAllAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
  }
}",0.9851668726823238
194520,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(int callingUid,String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(callingUid,appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}",0.9737373737373738
194521,"public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAppIdArray;
  }
}","public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAllAppIdArray;
  }
}",0.9866666666666668
194522,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9901095963646084
194523,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          stepIdleStateLocked();
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (mEnabled) {
            mEnabled=false;
            becomeActiveLocked(""String_Node_Str"",Process.myUid());
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (!mEnabled) {
            mEnabled=true;
            becomeInactiveIfAppropriateLocked();
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        while (i < args.length) {
          arg=args[i];
          i++;
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
            pw.println(""String_Node_Str"" + arg);
            return;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          return;
        }
        while (i < args.length) {
          arg=args[i];
          i++;
          addPowerSaveTempWhitelistAppInternal(arg,10000L,userId);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked(""String_Node_Str"",Process.myUid());
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println(""String_Node_Str"" + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
 else {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println(""String_Node_Str"");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}",0.93003300330033
194524,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_IDLE_OFF:
{
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  EventLogTags.writeDeviceIdleOnStart();
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}",0.8922974324774925
194525,"@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  final int callingUid=Binder.getCallingUid();
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),callingUid,userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(callingUid,packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9427662957074722
194526,"public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
}","public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  addPowerSaveTempWhitelistAppDirectInternal(0,appId,duration);
}",0.9066666666666666
194527,"@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    wifiFirmwareReload(wlanIface,""String_Node_Str"");
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}","@Override public void startAccessPoint(WifiConfiguration wifiConfig,String wlanIface){
  mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL,TAG);
  try {
    if (wifiConfig == null) {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface);
    }
 else {
      mConnector.execute(""String_Node_Str"",""String_Node_Str"",wlanIface,wifiConfig.SSID,""String_Node_Str"",Integer.toString(wifiConfig.apChannel),getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey));
    }
    mConnector.execute(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  NativeDaemonConnectorException e) {
    throw e.rethrowAsParcelableException();
  }
}",0.9616220130340332
194528,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int callingUid,int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    int callingAppId=UserHandle.getAppId(callingUid);
    if (callingAppId >= Process.FIRST_APPLICATION_UID) {
      if (!mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
        throw new SecurityException(""String_Node_Str"" + UserHandle.formatUid(callingUid) + ""String_Node_Str"");
      }
    }
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}",0.8305540613232921
194529,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mPowerSaveWhitelistApps.put(ai.packageName,UserHandle.getAppId(ai.uid));
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          int appid=UserHandle.getAppId(ai.uid);
          mPowerSaveWhitelistApps.put(ai.packageName,appid);
          mPowerSaveWhitelistSystemAppIds.put(appid,true);
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}",0.940273037542662
194530,"private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
  }
}","private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAllAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAllAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAllAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAllAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
  }
}",0.9851668726823238
194531,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(int callingUid,String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(callingUid,appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}",0.9737373737373738
194532,"public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAppIdArray;
  }
}","public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAllAppIdArray;
  }
}",0.9866666666666668
194533,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9901095963646084
194534,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          stepIdleStateLocked();
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (mEnabled) {
            mEnabled=false;
            becomeActiveLocked(""String_Node_Str"",Process.myUid());
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (!mEnabled) {
            mEnabled=true;
            becomeInactiveIfAppropriateLocked();
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        while (i < args.length) {
          arg=args[i];
          i++;
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
            pw.println(""String_Node_Str"" + arg);
            return;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          return;
        }
        while (i < args.length) {
          arg=args[i];
          i++;
          addPowerSaveTempWhitelistAppInternal(arg,10000L,userId);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked(""String_Node_Str"",Process.myUid());
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println(""String_Node_Str"" + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
 else {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println(""String_Node_Str"");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}",0.93003300330033
194535,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_IDLE_OFF:
{
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  EventLogTags.writeDeviceIdleOnStart();
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}",0.8922974324774925
194536,"@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  final int callingUid=Binder.getCallingUid();
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),callingUid,userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(callingUid,packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9427662957074722
194537,"public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
}","public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  addPowerSaveTempWhitelistAppDirectInternal(0,appId,duration);
}",0.9066666666666666
194538,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int callingUid,int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    int callingAppId=UserHandle.getAppId(callingUid);
    if (callingAppId >= Process.FIRST_APPLICATION_UID) {
      if (!mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
        throw new SecurityException(""String_Node_Str"" + UserHandle.formatUid(callingUid) + ""String_Node_Str"");
      }
    }
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}",0.8305540613232921
194539,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mPowerSaveWhitelistApps.put(ai.packageName,UserHandle.getAppId(ai.uid));
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          int appid=UserHandle.getAppId(ai.uid);
          mPowerSaveWhitelistApps.put(ai.packageName,appid);
          mPowerSaveWhitelistSystemAppIds.put(appid,true);
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}",0.940273037542662
194540,"private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
  }
}","private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAllAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAllAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAllAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAllAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
  }
}",0.9851668726823238
194541,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(int callingUid,String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(callingUid,appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}",0.9737373737373738
194542,"public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAppIdArray;
  }
}","public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAllAppIdArray;
  }
}",0.9866666666666668
194543,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9901095963646084
194544,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          stepIdleStateLocked();
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (mEnabled) {
            mEnabled=false;
            becomeActiveLocked(""String_Node_Str"",Process.myUid());
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (!mEnabled) {
            mEnabled=true;
            becomeInactiveIfAppropriateLocked();
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        while (i < args.length) {
          arg=args[i];
          i++;
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
            pw.println(""String_Node_Str"" + arg);
            return;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          return;
        }
        while (i < args.length) {
          arg=args[i];
          i++;
          addPowerSaveTempWhitelistAppInternal(arg,10000L,userId);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked(""String_Node_Str"",Process.myUid());
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println(""String_Node_Str"" + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
 else {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println(""String_Node_Str"");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}",0.93003300330033
194545,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_IDLE_OFF:
{
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  EventLogTags.writeDeviceIdleOnStart();
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}",0.8922974324774925
194546,"@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  final int callingUid=Binder.getCallingUid();
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),callingUid,userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(callingUid,packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9427662957074722
194547,"public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
}","public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  addPowerSaveTempWhitelistAppDirectInternal(0,appId,duration);
}",0.9066666666666666
194548,"/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left;
    }
 else {
      x=right;
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max;
      }
 else {
        x=left - max;
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1;
    }
  }
  return x;
}","/** 
 * Return the start position of the line, given the left and right bounds of the margins.
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */
private int getLineStartPos(int line,int left,int right){
  Alignment align=getParagraphAlignment(line);
  int dir=getParagraphDirection(line);
  if (align == Alignment.ALIGN_LEFT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
  }
 else   if (align == Alignment.ALIGN_RIGHT) {
    align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
  }
  int x;
  if (align == Alignment.ALIGN_NORMAL) {
    if (dir == DIR_LEFT_TO_RIGHT) {
      x=left + getIndentAdjust(line,Alignment.ALIGN_LEFT);
    }
 else {
      x=right + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
    }
  }
 else {
    TabStops tabStops=null;
    if (mSpannedText && getLineContainsTab(line)) {
      Spanned spanned=(Spanned)mText;
      int start=getLineStart(line);
      int spanEnd=spanned.nextSpanTransition(start,spanned.length(),TabStopSpan.class);
      TabStopSpan[] tabSpans=getParagraphSpans(spanned,start,spanEnd,TabStopSpan.class);
      if (tabSpans.length > 0) {
        tabStops=new TabStops(TAB_INCREMENT,tabSpans);
      }
    }
    int max=(int)getLineExtent(line,tabStops,false);
    if (align == Alignment.ALIGN_OPPOSITE) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=right - max + getIndentAdjust(line,Alignment.ALIGN_RIGHT);
      }
 else {
        x=left - max + getIndentAdjust(line,Alignment.ALIGN_LEFT);
      }
    }
 else {
      max=max & ~1;
      x=(left + right - max) >> 1 + getIndentAdjust(line,Alignment.ALIGN_CENTER);
    }
  }
  return x;
}",0.9346274621752784
194549,"/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}","/** 
 * @hide
 */
public void drawText(Canvas canvas,int firstLine,int lastLine){
  int previousLineBottom=getLineTop(firstLine);
  int previousLineEnd=getLineStart(firstLine);
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int lineNum=firstLine; lineNum <= lastLine; lineNum++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(lineNum + 1);
    int end=getLineVisibleEnd(lineNum,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(lineNum + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(lineNum);
    int dir=getParagraphDirection(lineNum);
    int left=0;
    int right=mWidth;
    if (mSpannedText) {
      Spanned sp=(Spanned)buf;
      int textLength=buf.length();
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      boolean useFirstLineMargin=isFirstParaLine;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan2) {
          int count=((LeadingMarginSpan2)spans[n]).getLeadingMarginLineCount();
          int startLine=getLineForOffset(sp.getSpanStart(spans[n]));
          if (lineNum < startLine + count) {
            useFirstLineMargin=true;
            break;
          }
        }
      }
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(canvas,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(canvas,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(lineNum);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
      }
 else {
        x=right + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
      }
    }
 else {
      int max=(int)getLineExtent(lineNum,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max + getIndentAdjust(lineNum,Alignment.ALIGN_RIGHT);
        }
 else {
          x=left - max + getIndentAdjust(lineNum,Alignment.ALIGN_LEFT);
        }
      }
 else {
        max=max & ~1;
        x=((right + left - max) >> 1) + getIndentAdjust(lineNum,Alignment.ALIGN_CENTER);
      }
    }
    paint.setHyphenEdit(getHyphen(lineNum));
    Directions directions=getLineDirections(lineNum);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
      canvas.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(canvas,x,ltop,lbaseline,lbottom);
    }
    paint.setHyphenEdit(0);
  }
  TextLine.recycle(tl);
}",0.971153846153846
194550,"/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 * @see android.widget.TextView#setIndents
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}","/** 
 * Set indents. Arguments are arrays holding an indent amount, one per line, measured in pixels. For lines past the last element in the array, the last element repeats.
 * @param leftIndents array of indent values for left margin, in pixels
 * @param rightIndents array of indent values for right margin, in pixels
 * @return this builder, useful for chaining
 */
public Builder setIndents(int[] leftIndents,int[] rightIndents){
  mLeftIndents=leftIndents;
  mRightIndents=rightIndents;
  int leftLen=leftIndents == null ? 0 : leftIndents.length;
  int rightLen=rightIndents == null ? 0 : rightIndents.length;
  int[] indents=new int[Math.max(leftLen,rightLen)];
  for (int i=0; i < indents.length; i++) {
    int leftMargin=i < leftLen ? leftIndents[i] : 0;
    int rightMargin=i < rightLen ? rightIndents[i] : 0;
    indents[i]=leftMargin + rightMargin;
  }
  nSetIndents(mNativePtr,indents);
  return this;
}",0.9444138690148596
194551,"private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}","private static void recycle(Builder b){
  b.mPaint=null;
  b.mText=null;
  MeasuredText.recycle(b.mMeasuredText);
  b.mMeasuredText=null;
  b.mLeftIndents=null;
  b.mRightIndents=null;
  nFinishBuilder(b.mNativePtr);
  sPool.release(b);
}",0.8904428904428905
194552,"void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}","void generate(Builder b,boolean includepad,boolean trackpad){
  CharSequence source=b.mText;
  int bufStart=b.mStart;
  int bufEnd=b.mEnd;
  TextPaint paint=b.mPaint;
  int outerWidth=b.mWidth;
  TextDirectionHeuristic textDir=b.mTextDir;
  float spacingmult=b.mSpacingMult;
  float spacingadd=b.mSpacingAdd;
  float ellipsizedWidth=b.mEllipsizedWidth;
  TextUtils.TruncateAt ellipsize=b.mEllipsize;
  LineBreaks lineBreaks=new LineBreaks();
  int[] spanEndCache=new int[4];
  int[] fmCache=new int[4 * 4];
  b.setLocale(paint.getTextLocale());
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=b.mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=b.mMeasuredText;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineCount=1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          firstWidthLineCount=Math.max(firstWidthLineCount,lms2.getLeadingMarginLineCount());
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir,b);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    int[] variableTabStops=null;
    if (spanned != null) {
      TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
      if (spans.length > 0) {
        int[] stops=new int[spans.length];
        for (int i=0; i < spans.length; i++) {
          stops[i]=spans[i].getTabStop();
        }
        Arrays.sort(stops,0,stops.length);
        variableTabStops=stops;
      }
    }
    nSetupParagraph(b.mNativePtr,chs,paraEnd - paraStart,firstWidth,firstWidthLineCount,restWidth,variableTabStops,TAB_INCREMENT,b.mBreakStrategy,b.mHyphenationFrequency);
    if (mLeftIndents != null || mRightIndents != null) {
      int leftLen=mLeftIndents == null ? 0 : mLeftIndents.length;
      int rightLen=mRightIndents == null ? 0 : mRightIndents.length;
      int indentsLen=Math.max(1,Math.min(leftLen,rightLen) - mLineCount);
      int[] indents=new int[indentsLen];
      for (int i=0; i < indentsLen; i++) {
        int leftMargin=mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount,leftLen - 1)];
        int rightMargin=mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount,rightLen - 1)];
        indents[i]=leftMargin + rightMargin;
      }
      nSetIndents(b.mNativePtr,indents);
    }
    int fmCacheCount=0;
    int spanEndCacheCount=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (fmCacheCount * 4 >= fmCache.length) {
        int[] grow=new int[fmCacheCount * 4 * 2];
        System.arraycopy(fmCache,0,grow,0,fmCacheCount * 4);
        fmCache=grow;
      }
      if (spanEndCacheCount >= spanEndCache.length) {
        int[] grow=new int[spanEndCacheCount * 2];
        System.arraycopy(spanEndCache,0,grow,0,spanEndCacheCount);
        spanEndCache=grow;
      }
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      fmCache[fmCacheCount * 4 + 0]=fm.top;
      fmCache[fmCacheCount * 4 + 1]=fm.bottom;
      fmCache[fmCacheCount * 4 + 2]=fm.ascent;
      fmCache[fmCacheCount * 4 + 3]=fm.descent;
      fmCacheCount++;
      spanEndCache[spanEndCacheCount]=spanEnd;
      spanEndCacheCount++;
    }
    nGetWidths(b.mNativePtr,widths);
    int breakCount=nComputeLineBreaks(b.mNativePtr,lineBreaks,lineBreaks.breaks,lineBreaks.widths,lineBreaks.flags,lineBreaks.breaks.length);
    int[] breaks=lineBreaks.breaks;
    float[] lineWidths=lineBreaks.widths;
    int[] flags=lineBreaks.flags;
    final int remainingLineCount=mMaximumVisibleLineCount - mLineCount;
    final boolean ellipsisMayBeApplied=ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
    if (remainingLineCount < breakCount && ellipsisMayBeApplied) {
      breaks[remainingLineCount - 1]=breaks[breakCount - 1];
      float width=0;
      int flag=0;
      for (int i=remainingLineCount - 1; i < breakCount; i++) {
        width+=lineWidths[i];
        flag|=flags[i] & TAB_MASK;
      }
      lineWidths[remainingLineCount - 1]=width;
      flags[remainingLineCount - 1]=flag;
      breakCount=remainingLineCount;
    }
    int here=paraStart;
    int fmTop=0, fmBottom=0, fmAscent=0, fmDescent=0;
    int fmCacheIndex=0;
    int spanEndCacheIndex=0;
    int breakIndex=0;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      spanEnd=spanEndCache[spanEndCacheIndex++];
      fm.top=fmCache[fmCacheIndex * 4 + 0];
      fm.bottom=fmCache[fmCacheIndex * 4 + 1];
      fm.ascent=fmCache[fmCacheIndex * 4 + 2];
      fm.descent=fmCache[fmCacheIndex * 4 + 3];
      fmCacheIndex++;
      if (fm.top < fmTop) {
        fmTop=fm.top;
      }
      if (fm.ascent < fmAscent) {
        fmAscent=fm.ascent;
      }
      if (fm.descent > fmDescent) {
        fmDescent=fm.descent;
      }
      if (fm.bottom > fmBottom) {
        fmBottom=fm.bottom;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
        breakIndex++;
      }
      while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
        int endPos=paraStart + breaks[breakIndex];
        boolean moreChars=(endPos < bufEnd);
        v=out(source,here,endPos,fmAscent,fmDescent,fmTop,fmBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,flags[breakIndex],needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,lineWidths[breakIndex],paint,moreChars);
        if (endPos < spanEnd) {
          fmTop=fm.top;
          fmBottom=fm.bottom;
          fmAscent=fm.ascent;
          fmDescent=fm.descent;
        }
 else {
          fmTop=fmBottom=fmAscent=fmDescent=0;
        }
        here=endPos;
        breakIndex++;
        if (mLineCount >= mMaximumVisibleLineCount) {
          return;
        }
      }
    }
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufEnd,bufEnd,textDir,b);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,0,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}",0.9584648402979422
194553,"private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  generate(b,b.mIncludePad,b.mIncludePad);
}","private StaticLayout(Builder b){
  super((b.mEllipsize == null) ? b.mText : (b.mText instanceof Spanned) ? new SpannedEllipsizer(b.mText) : new Ellipsizer(b.mText),b.mPaint,b.mWidth,b.mAlignment,b.mSpacingMult,b.mSpacingAdd);
  if (b.mEllipsize != null) {
    Ellipsizer e=(Ellipsizer)getText();
    e.mLayout=this;
    e.mWidth=b.mEllipsizedWidth;
    e.mMethod=b.mEllipsize;
    mEllipsizedWidth=b.mEllipsizedWidth;
    mColumns=COLUMNS_ELLIPSIZE;
  }
 else {
    mColumns=COLUMNS_NORMAL;
    mEllipsizedWidth=b.mWidth;
  }
  mLineDirections=ArrayUtils.newUnpaddedArray(Directions.class,2 * mColumns);
  mLines=new int[mLineDirections.length];
  mMaximumVisibleLineCount=b.mMaxLines;
  mLeftIndents=b.mLeftIndents;
  mRightIndents=b.mRightIndents;
  generate(b,b.mIncludePad,b.mIncludePad);
}",0.958005249343832
194554,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppDirectInternal(int callingUid,int appId,long duration){
  final long timeNow=SystemClock.elapsedRealtime();
synchronized (this) {
    int callingAppId=UserHandle.getAppId(callingUid);
    if (callingAppId >= Process.FIRST_APPLICATION_UID) {
      if (!mPowerSaveWhitelistSystemAppIds.get(callingAppId)) {
        throw new SecurityException(""String_Node_Str"" + UserHandle.formatUid(callingUid) + ""String_Node_Str"");
      }
    }
    duration=Math.min(duration,mConstants.MAX_TEMP_APP_WHITELIST_DURATION);
    long currentEndTime=mTempWhitelistAppIdEndTimes.get(appId);
    mTempWhitelistAppIdEndTimes.put(appId,timeNow + duration);
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + appId + ""String_Node_Str"");
    }
    if (currentEndTime == 0) {
      postTempActiveTimeoutMessage(appId,duration);
      updateTempWhitelistAppIdsLocked();
      reportTempWhitelistChangedLocked();
    }
  }
}",0.8305540613232921
194555,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mPowerSaveWhitelistApps.put(ai.packageName,UserHandle.getAppId(ai.uid));
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,0);
        if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          int appid=UserHandle.getAppId(ai.uid);
          mPowerSaveWhitelistApps.put(ai.packageName,appid);
          mPowerSaveWhitelistSystemAppIds.put(appid,true);
        }
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,new BinderService());
  publishLocalService(LocalService.class,new LocalService());
}",0.940273037542662
194556,"private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
  }
}","private void updateWhitelistAppIdsLocked(){
  mPowerSaveWhitelistAllAppIds.clear();
  for (int i=0; i < mPowerSaveWhitelistApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistApps.valueAt(i),true);
  }
  for (int i=0; i < mPowerSaveWhitelistUserApps.size(); i++) {
    mPowerSaveWhitelistAllAppIds.put(mPowerSaveWhitelistUserApps.valueAt(i),true);
  }
  int size=mPowerSaveWhitelistAllAppIds.size();
  int[] appids=new int[size];
  for (int i=0; i < size; i++) {
    appids[i]=mPowerSaveWhitelistAllAppIds.keyAt(i);
  }
  mPowerSaveWhitelistAllAppIdArray=appids;
  if (mLocalPowerManager != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));
    }
    mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
  }
}",0.9851668726823238
194557,"/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}","/** 
 * Adds an app to the temporary whitelist and resets the endTime for granting the app an exemption to access network and acquire wakelocks.
 */
public void addPowerSaveTempWhitelistAppInternal(int callingUid,String packageName,long duration,int userId){
  try {
    int uid=getContext().getPackageManager().getPackageUid(packageName,userId);
    int appId=UserHandle.getAppId(uid);
    addPowerSaveTempWhitelistAppDirectInternal(callingUid,appId,duration);
  }
 catch (  NameNotFoundException e) {
  }
}",0.9737373737373738
194558,"public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAppIdArray;
  }
}","public int[] getAppIdWhitelistInternal(){
synchronized (this) {
    return mPowerSaveWhitelistAllAppIdArray;
  }
}",0.9866666666666668
194559,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      mSigMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
      mAnyMotionDetector=new AnyMotionDetector(mAlarmManager,(PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this);
      Intent intent=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intent,0);
      Intent intentSensing=new Intent(ACTION_STEP_IDLE_STATE).setPackage(""String_Node_Str"").setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      mSensingAlarmIntent=PendingIntent.getBroadcast(getContext(),0,intentSensing,0);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      filter.addAction(ACTION_STEP_IDLE_STATE);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9901095963646084
194560,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          stepIdleStateLocked();
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (mEnabled) {
            mEnabled=false;
            becomeActiveLocked(""String_Node_Str"",Process.myUid());
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          if (!mEnabled) {
            mEnabled=true;
            becomeInactiveIfAppropriateLocked();
            pw.println(""String_Node_Str"");
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        while (i < args.length) {
          arg=args[i];
          i++;
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
            pw.println(""String_Node_Str"" + arg);
            return;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          return;
        }
        while (i < args.length) {
          arg=args[i];
          i++;
          addPowerSaveTempWhitelistAppInternal(arg,10000L,userId);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked(""String_Node_Str"",Process.myUid());
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println(""String_Node_Str"");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? ""String_Node_Str"" : ""String_Node_Str"");
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println(""String_Node_Str"" + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
 else {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println(""String_Node_Str"" + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println(""String_Node_Str"");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println(""String_Node_Str"");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println(""String_Node_Str"");
      for (int i=0; i < size; i++) {
        pw.print(""String_Node_Str"");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mEnabled);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionSensor);
    pw.print(""String_Node_Str"");
    pw.println(mCurDisplay);
    pw.print(""String_Node_Str"");
    pw.println(mScreenOn);
    pw.print(""String_Node_Str"");
    pw.println(mCharging);
    pw.print(""String_Node_Str"");
    pw.println(mSigMotionActive);
    pw.print(""String_Node_Str"");
    pw.println(stateToString(mState));
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}",0.93003300330033
194561,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_IDLE_OFF:
{
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
{
  EventLogTags.writeDeviceIdleOnStart();
  mLocalPowerManager.setDeviceIdleMode(true);
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(true,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,null,Process.myUid());
}
 catch (RemoteException e) {
}
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
boolean needBroadcast=msg.arg2 != 0;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
mLocalPowerManager.setDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(false,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (needBroadcast) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
}
}",0.8922974324774925
194562,"@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","@Override public void addPowerSaveTempWhitelistApp(String packageName,long duration,int userId) throws RemoteException {
  getContext().enforceCallingPermission(Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,""String_Node_Str"");
  final int callingUid=Binder.getCallingUid();
  userId=ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),callingUid,userId,false,false,""String_Node_Str"",null);
  final long token=Binder.clearCallingIdentity();
  try {
    DeviceIdleController.this.addPowerSaveTempWhitelistAppInternal(callingUid,packageName,duration,userId);
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9427662957074722
194563,"public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  DeviceIdleController.this.addPowerSaveTempWhitelistAppDirectInternal(appId,duration);
}","public void addPowerSaveTempWhitelistAppDirect(int appId,long duration){
  addPowerSaveTempWhitelistAppDirectInternal(0,appId,duration);
}",0.9066666666666666
194564,"public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runResetPermissions();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.9894032348020078
194565,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9883357041251778
194566,"public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runResetPermissions();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.9894032348020078
194567,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9883357041251778
194568,"public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runResetPermissions();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.9894032348020078
194569,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9883357041251778
194570,"public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runResetPermissions();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.9894032348020078
194571,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9883357041251778
194572,"public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runResetPermissions();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.9894032348020078
194573,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9883357041251778
194574,"public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public int run(String[] args) throws IOException, RemoteException {
  boolean validCommand=false;
  if (args.length < 1) {
    return showUsage();
  }
  mUm=IUserManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return 1;
  }
  mInstaller=mPm.getPackageInstaller();
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    return runList();
  }
  if (""String_Node_Str"".equals(op)) {
    return runPath();
  }
  if (""String_Node_Str"".equals(op)) {
    return runDump();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCreate();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallWrite();
  }
  if (""String_Node_Str"".equals(op)) {
    return runInstallCommit();
  }
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    return runInstallAbandon();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstaller();
  }
  if (""String_Node_Str"".equals(op)) {
    return runUninstall();
  }
  if (""String_Node_Str"".equals(op)) {
    return runClear();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetHiddenSetting(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(true);
  }
  if (""String_Node_Str"".equals(op)) {
    return runGrantRevokePermission(false);
  }
  if (""String_Node_Str"".equals(op)) {
    return runResetPermissions();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetPermissionEnforced();
  }
  if (""String_Node_Str"".equals(op)) {
    return runSetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetInstallLocation();
  }
  if (""String_Node_Str"".equals(op)) {
    return runTrimCaches();
  }
  if (""String_Node_Str"".equals(op)) {
    return runCreateUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runRemoveUser();
  }
  if (""String_Node_Str"".equals(op)) {
    return runGetMaxUsers();
  }
  if (""String_Node_Str"".equals(op)) {
    return runForceDexOpt();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePackage();
  }
  if (""String_Node_Str"".equals(op)) {
    return runMovePrimaryStorage();
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        return displayPackageFilePath(args[1]);
      }
    }
    return 1;
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.9894032348020078
194575,"private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}","private static int showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return 1;
}",0.9883357041251778
194576,"/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    mUpdateMonitor.registerCallback(mUpdateCallback);
    doKeyguardLocked(null);
  }
  maybeSendUserPresentBroadcast();
}","/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    doKeyguardLocked(null);
    mUpdateMonitor.registerCallback(mUpdateCallback);
  }
  maybeSendUserPresentBroadcast();
}",0.9285714285714286
194577,"/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}","/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  ensureView();
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}",0.7704918032786885
194578,"@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mAnimateKeyguardFadingOut=false;
  mDurationOverride=-1;
  mAnimationDelay=0;
  if (!mAnimationStarted && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mAnimationStarted=false;
  return true;
}","@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mDurationOverride=-1;
  mAnimationDelay=0;
  endAnimateKeyguardFadingOut();
  mAnimationStarted=false;
  return true;
}",0.5907046476761619
194579,"/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  reset();
}","/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  mScrimController.abortKeyguardFadingOut();
  reset();
}",0.9032258064516128
194580,"/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    mUpdateMonitor.registerCallback(mUpdateCallback);
    doKeyguardLocked(null);
  }
  maybeSendUserPresentBroadcast();
}","/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    doKeyguardLocked(null);
    mUpdateMonitor.registerCallback(mUpdateCallback);
  }
  maybeSendUserPresentBroadcast();
}",0.9285714285714286
194581,"/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}","/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  ensureView();
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}",0.7704918032786885
194582,"@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mAnimateKeyguardFadingOut=false;
  mDurationOverride=-1;
  mAnimationDelay=0;
  if (!mAnimationStarted && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mAnimationStarted=false;
  return true;
}","@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mDurationOverride=-1;
  mAnimationDelay=0;
  endAnimateKeyguardFadingOut();
  mAnimationStarted=false;
  return true;
}",0.5907046476761619
194583,"/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  reset();
}","/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  mScrimController.abortKeyguardFadingOut();
  reset();
}",0.9032258064516128
194584,"/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    mUpdateMonitor.registerCallback(mUpdateCallback);
    doKeyguardLocked(null);
  }
  maybeSendUserPresentBroadcast();
}","/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    doKeyguardLocked(null);
    mUpdateMonitor.registerCallback(mUpdateCallback);
  }
  maybeSendUserPresentBroadcast();
}",0.9285714285714286
194585,"/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}","/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  ensureView();
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}",0.7704918032786885
194586,"@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mAnimateKeyguardFadingOut=false;
  mDurationOverride=-1;
  mAnimationDelay=0;
  if (!mAnimationStarted && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mAnimationStarted=false;
  return true;
}","@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mDurationOverride=-1;
  mAnimationDelay=0;
  endAnimateKeyguardFadingOut();
  mAnimationStarted=false;
  return true;
}",0.5907046476761619
194587,"/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  reset();
}","/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  mScrimController.abortKeyguardFadingOut();
  reset();
}",0.9032258064516128
194588,"/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    mUpdateMonitor.registerCallback(mUpdateCallback);
    doKeyguardLocked(null);
  }
  maybeSendUserPresentBroadcast();
}","/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    doKeyguardLocked(null);
    mUpdateMonitor.registerCallback(mUpdateCallback);
  }
  maybeSendUserPresentBroadcast();
}",0.9285714285714286
194589,"/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}","/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  ensureView();
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}",0.7704918032786885
194590,"@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mAnimateKeyguardFadingOut=false;
  mDurationOverride=-1;
  mAnimationDelay=0;
  if (!mAnimationStarted && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mAnimationStarted=false;
  return true;
}","@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mDurationOverride=-1;
  mAnimationDelay=0;
  endAnimateKeyguardFadingOut();
  mAnimationStarted=false;
  return true;
}",0.5907046476761619
194591,"/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  reset();
}","/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  mScrimController.abortKeyguardFadingOut();
  reset();
}",0.9032258064516128
194592,"/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    mUpdateMonitor.registerCallback(mUpdateCallback);
    doKeyguardLocked(null);
  }
  maybeSendUserPresentBroadcast();
}","/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    doKeyguardLocked(null);
    mUpdateMonitor.registerCallback(mUpdateCallback);
  }
  maybeSendUserPresentBroadcast();
}",0.9285714285714286
194593,"/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}","/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  ensureView();
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}",0.7704918032786885
194594,"@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mAnimateKeyguardFadingOut=false;
  mDurationOverride=-1;
  mAnimationDelay=0;
  if (!mAnimationStarted && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mAnimationStarted=false;
  return true;
}","@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mDurationOverride=-1;
  mAnimationDelay=0;
  endAnimateKeyguardFadingOut();
  mAnimationStarted=false;
  return true;
}",0.5907046476761619
194595,"/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  reset();
}","/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  mScrimController.abortKeyguardFadingOut();
  reset();
}",0.9032258064516128
194596,"/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long now=SystemClock.elapsedRealtime();
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffMs=(now - mLastTimeRead) * 1000;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffMs || systemTimeDeltaUs > timeDiffMs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffMs,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeRead=now;
}","/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long nowUs=SystemClock.elapsedRealtime() * 1000;
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffUs=nowUs - mLastTimeReadUs;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffUs || systemTimeDeltaUs > timeDiffUs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeReadUs=nowUs;
}",0.992543783596324
194597,"/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long now=SystemClock.elapsedRealtime();
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffMs=(now - mLastTimeRead) * 1000;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffMs || systemTimeDeltaUs > timeDiffMs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffMs,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeRead=now;
}","/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long nowUs=SystemClock.elapsedRealtime() * 1000;
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffUs=nowUs - mLastTimeReadUs;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffUs || systemTimeDeltaUs > timeDiffUs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeReadUs=nowUs;
}",0.992543783596324
194598,"/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long now=SystemClock.elapsedRealtime();
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffMs=(now - mLastTimeRead) * 1000;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffMs || systemTimeDeltaUs > timeDiffMs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffMs,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeRead=now;
}","/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long nowUs=SystemClock.elapsedRealtime() * 1000;
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffUs=nowUs - mLastTimeReadUs;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffUs || systemTimeDeltaUs > timeDiffUs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeReadUs=nowUs;
}",0.992543783596324
194599,"/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long now=SystemClock.elapsedRealtime();
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffMs=(now - mLastTimeRead) * 1000;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffMs || systemTimeDeltaUs > timeDiffMs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffMs,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeRead=now;
}","/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long nowUs=SystemClock.elapsedRealtime() * 1000;
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffUs=nowUs - mLastTimeReadUs;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffUs || systemTimeDeltaUs > timeDiffUs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeReadUs=nowUs;
}",0.992543783596324
194600,"/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long now=SystemClock.elapsedRealtime();
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffMs=(now - mLastTimeRead) * 1000;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffMs || systemTimeDeltaUs > timeDiffMs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffMs,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeRead=now;
}","/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long nowUs=SystemClock.elapsedRealtime() * 1000;
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffUs=nowUs - mLastTimeReadUs;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffUs || systemTimeDeltaUs > timeDiffUs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeReadUs=nowUs;
}",0.992543783596324
194601,"/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long now=SystemClock.elapsedRealtime();
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffMs=(now - mLastTimeRead) * 1000;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffMs || systemTimeDeltaUs > timeDiffMs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffMs,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeRead=now;
}","/** 
 * Reads the proc file, calling into the callback with a delta of time for each UID.
 * @param callback The callback to invoke for each line of the proc file. If null,the data is consumed and subsequent calls to readDelta will provide a fresh delta.
 */
public void readDelta(@Nullable Callback callback){
  long nowUs=SystemClock.elapsedRealtime() * 1000;
  try (BufferedReader reader=new BufferedReader(new FileReader(sProcFile))){
    TextUtils.SimpleStringSplitter splitter=new TextUtils.SimpleStringSplitter(' ');
    String line;
    while ((line=reader.readLine()) != null) {
      splitter.setString(line);
      final String uidStr=splitter.next();
      final int uid=Integer.parseInt(uidStr.substring(0,uidStr.length() - 1),10);
      final long userTimeUs=Long.parseLong(splitter.next(),10);
      final long systemTimeUs=Long.parseLong(splitter.next(),10);
      if (callback != null) {
        long userTimeDeltaUs=userTimeUs;
        long systemTimeDeltaUs=systemTimeUs;
        int index=mLastUserTimeUs.indexOfKey(uid);
        if (index >= 0) {
          userTimeDeltaUs-=mLastUserTimeUs.valueAt(index);
          systemTimeDeltaUs-=mLastSystemTimeUs.valueAt(index);
          final long timeDiffUs=nowUs - mLastTimeReadUs;
          if (userTimeDeltaUs < 0 || systemTimeDeltaUs < 0 || userTimeDeltaUs > timeDiffUs || systemTimeDeltaUs > timeDiffUs) {
            StringBuilder sb=new StringBuilder(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeDiffUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastUserTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(mLastSystemTimeUs.valueAt(index) / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeUs / 1000,sb);
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"").append(uid).append(""String_Node_Str"");
            TimeUtils.formatDuration(userTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(systemTimeDeltaUs / 1000,sb);
            sb.append(""String_Node_Str"");
            Slog.wtf(TAG,sb.toString());
            userTimeDeltaUs=0;
            systemTimeDeltaUs=0;
          }
        }
        if (userTimeDeltaUs != 0 || systemTimeDeltaUs != 0) {
          callback.onUidCpuTime(uid,userTimeDeltaUs,systemTimeDeltaUs);
        }
      }
      mLastUserTimeUs.put(uid,userTimeUs);
      mLastSystemTimeUs.put(uid,systemTimeUs);
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
  mLastTimeReadUs=nowUs;
}",0.992543783596324
194602,"/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    mUpdateMonitor.registerCallback(mUpdateCallback);
    doKeyguardLocked(null);
  }
  maybeSendUserPresentBroadcast();
}","/** 
 * Let us know that the system is ready after startup.
 */
public void onSystemReady(){
  mSearchManager=(SearchManager)mContext.getSystemService(Context.SEARCH_SERVICE);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mSystemReady=true;
    doKeyguardLocked(null);
    mUpdateMonitor.registerCallback(mUpdateCallback);
  }
  maybeSendUserPresentBroadcast();
}",0.9285714285714286
194603,"/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}","/** 
 * @return True if and only if the security method should be shown before showing thenotifications on Keyguard, like SIM PIN/PUK.
 */
public boolean needsFullscreenBouncer(){
  ensureView();
  if (mKeyguardView != null) {
    SecurityMode mode=mKeyguardView.getSecurityMode();
    return mode == SecurityMode.SimPin || mode == SecurityMode.SimPuk;
  }
  return false;
}",0.7704918032786885
194604,"@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mAnimateKeyguardFadingOut=false;
  mDurationOverride=-1;
  mAnimationDelay=0;
  if (!mAnimationStarted && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mAnimationStarted=false;
  return true;
}","@Override public boolean onPreDraw(){
  mScrimBehind.getViewTreeObserver().removeOnPreDrawListener(this);
  mUpdatePending=false;
  updateScrims();
  mDurationOverride=-1;
  mAnimationDelay=0;
  endAnimateKeyguardFadingOut();
  mAnimationStarted=false;
  return true;
}",0.5907046476761619
194605,"/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  reset();
}","/** 
 * Show the keyguard.  Will handle creating and attaching to the view manager lazily.
 */
public void show(Bundle options){
  mShowing=true;
  mStatusBarWindowManager.setKeyguardShowing(true);
  mScrimController.abortKeyguardFadingOut();
  reset();
}",0.9032258064516128
194606,"@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
}","@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
  mAssistManager.onUserSwitched(newUserId);
}",0.9325153374233128
194607,"@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
}","@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
  mAssistManager.onUserSwitched(newUserId);
}",0.9325153374233128
194608,"/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}","/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}",0.9992831541218636
194609,"/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}","/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}",0.9992831541218636
194610,"/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}","/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}",0.9992831541218636
194611,"@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
}","@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
  mAssistManager.onUserSwitched(newUserId);
}",0.9325153374233128
194612,"/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}","/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}",0.9992831541218636
194613,"@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
}","@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
  mAssistManager.onUserSwitched(newUserId);
}",0.9325153374233128
194614,"/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}","/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}",0.9992831541218636
194615,"@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
}","@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
  mAssistManager.onUserSwitched(newUserId);
}",0.9325153374233128
194616,"@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
}","@Override public void userSwitched(int newUserId){
  super.userSwitched(newUserId);
  if (MULTIUSER_DEBUG)   mNotificationPanelDebugText.setText(""String_Node_Str"" + newUserId);
  animateCollapsePanels();
  updatePublicMode();
  updateNotifications();
  resetUserSetupObserver();
  setControllerUsers();
  mAssistManager.onUserSwitched(newUserId);
}",0.9325153374233128
194617,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  pae.intent.replaceExtras(pae.extras);
  pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  closeSystemDialogs(""String_Node_Str"");
  try {
    mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
  }
 catch (  ActivityNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9563492063492064
194618,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  pae.intent.replaceExtras(pae.extras);
  pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  closeSystemDialogs(""String_Node_Str"");
  try {
    mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
  }
 catch (  ActivityNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9563492063492064
194619,"/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}","/** 
 * Called from Parcel.readException() when the exception is EX_STRICT_MODE_VIOLATIONS, we here read back all the encoded violations.
 */
static void readAndHandleBinderCallViolations(Parcel p){
  StringWriter sw=new StringWriter();
  PrintWriter pw=new FastPrintWriter(sw,false,256);
  new LogStackTrace().printStackTrace(pw);
  pw.flush();
  String ourStack=sw.toString();
  int policyMask=getThreadPolicyMask();
  boolean currentlyGathering=(policyMask & PENALTY_GATHER) != 0;
  int numViolations=p.readInt();
  for (int i=0; i < numViolations; ++i) {
    if (LOG_V)     Log.d(TAG,""String_Node_Str"" + i);
    ViolationInfo info=new ViolationInfo(p,!currentlyGathering);
    if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
      String front=info.crashInfo.stackTrace.substring(256);
      while (i < numViolations) {
        info=new ViolationInfo(p,!currentlyGathering);
        i++;
      }
      clearGatheredViolations();
      Slog.wtfStack(TAG,""String_Node_Str"" + numViolations + ""String_Node_Str""+ Integer.toHexString(policyMask)+ ""String_Node_Str""+ front);
      return;
    }
    info.crashInfo.stackTrace+=""String_Node_Str"" + ourStack;
    BlockGuard.Policy policy=BlockGuard.getThreadPolicy();
    if (policy instanceof AndroidBlockGuardPolicy) {
      ((AndroidBlockGuardPolicy)policy).handleViolationWithTimingAttempt(info);
    }
  }
}",0.9992831541218636
194620,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  pae.intent.replaceExtras(pae.extras);
  pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  closeSystemDialogs(""String_Node_Str"");
  try {
    mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
  }
 catch (  ActivityNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9563492063492064
194621,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  pae.intent.replaceExtras(pae.extras);
  pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  closeSystemDialogs(""String_Node_Str"");
  try {
    mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
  }
 catch (  ActivityNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9563492063492064
194622,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  pae.intent.replaceExtras(pae.extras);
  pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  closeSystemDialogs(""String_Node_Str"");
  try {
    mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
  }
 catch (  ActivityNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9563492063492064
194623,"public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  pae.intent.replaceExtras(pae.extras);
  pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  closeSystemDialogs(""String_Node_Str"");
  try {
    mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
  }
 catch (  ActivityNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","public void reportAssistContextExtras(IBinder token,Bundle extras,AssistStructure structure,AssistContent content,Uri referrer){
  PendingAssistExtras pae=(PendingAssistExtras)token;
synchronized (pae) {
    pae.result=extras;
    pae.structure=structure;
    pae.content=content;
    if (referrer != null) {
      pae.extras.putParcelable(Intent.EXTRA_REFERRER,referrer);
    }
    pae.haveResult=true;
    pae.notifyAll();
    if (pae.intent == null && pae.receiver == null) {
      return;
    }
  }
synchronized (this) {
    buildAssistBundleLocked(pae,extras);
    boolean exists=mPendingAssistExtras.remove(pae);
    mHandler.removeCallbacks(pae);
    if (!exists) {
      return;
    }
    if (pae.receiver != null) {
      Bundle topBundle=new Bundle();
      topBundle.putBundle(""String_Node_Str"",pae.extras);
      topBundle.putParcelable(""String_Node_Str"",pae.structure);
      topBundle.putParcelable(""String_Node_Str"",pae.content);
      try {
        pae.receiver.send(0,topBundle);
      }
 catch (      RemoteException e) {
      }
      return;
    }
  }
  long ident=Binder.clearCallingIdentity();
  try {
    pae.intent.replaceExtras(pae.extras);
    pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    closeSystemDialogs(""String_Node_Str"");
    try {
      mContext.startActivityAsUser(pae.intent,new UserHandle(pae.userHandle));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9563492063492064
194624,"@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  super.engineUpdateAAD(input,inputOffset,inputLen);
}","@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  engineUpdateAAD(input,inputOffset,inputLen);
}",0.9947735191637632
194625,"@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  super.engineUpdateAAD(input,inputOffset,inputLen);
}","@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  engineUpdateAAD(input,inputOffset,inputLen);
}",0.9947735191637632
194626,"@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  super.engineUpdateAAD(input,inputOffset,inputLen);
}","@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  engineUpdateAAD(input,inputOffset,inputLen);
}",0.9947735191637632
194627,"@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  super.engineUpdateAAD(input,inputOffset,inputLen);
}","@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  engineUpdateAAD(input,inputOffset,inputLen);
}",0.9947735191637632
194628,"@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  super.engineUpdateAAD(input,inputOffset,inputLen);
}","@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  engineUpdateAAD(input,inputOffset,inputLen);
}",0.9947735191637632
194629,"@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  super.engineUpdateAAD(input,inputOffset,inputLen);
}","@Override protected final void engineUpdateAAD(ByteBuffer src){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!src.hasRemaining()) {
    return;
  }
  byte[] input;
  int inputOffset;
  int inputLen;
  if (src.hasArray()) {
    input=src.array();
    inputOffset=src.arrayOffset() + src.position();
    inputLen=src.remaining();
    src.position(src.limit());
  }
 else {
    input=new byte[src.remaining()];
    inputOffset=0;
    inputLen=input.length;
    src.get(input);
  }
  engineUpdateAAD(input,inputOffset,inputLen);
}",0.9947735191637632
194630,"private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}","private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}",0.9596958174904944
194631,"/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=cf.left=vf.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=cf.right=vf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.right=vf.right=mStableRight;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}",0.9818731996857634
194632,"private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}","private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}",0.9596958174904944
194633,"/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=cf.left=vf.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=cf.right=vf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.right=vf.right=mStableRight;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}",0.9818731996857634
194634,"private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
      return;
    }
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.CURRENT,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}","private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  if (iconPkg == null) {
    iconPkg=mContext.getPackageName();
  }
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
    }
    return;
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.OWNER,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}",0.944973544973545
194635,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      boolean show=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(show);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.99644128113879
194636,"@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    notifyListeners();
  }
}","@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    mCallbackHandler.setNoSims(mHasNoSims);
  }
}",0.8850325379609545
194637,"private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}","private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}",0.9870748299319728
194638,"private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}","private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}",0.9596958174904944
194639,"/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=cf.left=vf.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=cf.right=vf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.right=vf.right=mStableRight;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}",0.9818731996857634
194640,"private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}","private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}",0.9596958174904944
194641,"/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=cf.left=vf.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=cf.right=vf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.right=vf.right=mStableRight;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}",0.9818731996857634
194642,"private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
      return;
    }
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.CURRENT,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}","private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  if (iconPkg == null) {
    iconPkg=mContext.getPackageName();
  }
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
    }
    return;
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.OWNER,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}",0.944973544973545
194643,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      boolean show=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(show);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.99644128113879
194644,"@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    notifyListeners();
  }
}","@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    mCallbackHandler.setNoSims(mHasNoSims);
  }
}",0.8850325379609545
194645,"private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}","private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}",0.9870748299319728
194646,"private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
      return;
    }
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.CURRENT,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}","private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  if (iconPkg == null) {
    iconPkg=mContext.getPackageName();
  }
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
    }
    return;
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.OWNER,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}",0.944973544973545
194647,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      boolean show=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(show);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.99644128113879
194648,"@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    notifyListeners();
  }
}","@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    mCallbackHandler.setNoSims(mHasNoSims);
  }
}",0.8850325379609545
194649,"private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}","private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}",0.9870748299319728
194650,"private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
      return;
    }
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.CURRENT,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}","private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  if (iconPkg == null) {
    iconPkg=mContext.getPackageName();
  }
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
    }
    return;
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.OWNER,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}",0.944973544973545
194651,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      boolean show=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(show);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.99644128113879
194652,"@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    notifyListeners();
  }
}","@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    mCallbackHandler.setNoSims(mHasNoSims);
  }
}",0.8850325379609545
194653,"private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}","private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}",0.9870748299319728
194654,"private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
      return;
    }
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.CURRENT,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}","private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  if (iconPkg == null) {
    iconPkg=mContext.getPackageName();
  }
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
    }
    return;
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.OWNER,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}",0.944973544973545
194655,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      boolean show=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(show);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.99644128113879
194656,"@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    notifyListeners();
  }
}","@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    mCallbackHandler.setNoSims(mHasNoSims);
  }
}",0.8850325379609545
194657,"private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}","private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}",0.9870748299319728
194658,"private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
      return;
    }
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.CURRENT,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}","private void updateSlot(String slot,String iconPkg,int iconId){
  if (!mDemoMode)   return;
  if (iconPkg == null) {
    iconPkg=mContext.getPackageName();
  }
  int removeIndex=-1;
  for (int i=0; i < getChildCount(); i++) {
    StatusBarIconView v=(StatusBarIconView)getChildAt(i);
    if (slot.equals(v.getTag())) {
      if (iconId == 0) {
        removeIndex=i;
        break;
      }
 else {
        StatusBarIcon icon=v.getStatusBarIcon();
        icon.icon=Icon.createWithResource(icon.icon.getResPackage(),iconId);
        v.set(icon);
        v.updateDrawable();
        return;
      }
    }
  }
  if (iconId == 0) {
    if (removeIndex != -1) {
      removeViewAt(removeIndex);
    }
    return;
  }
  StatusBarIcon icon=new StatusBarIcon(iconPkg,UserHandle.OWNER,iconId,0,0,""String_Node_Str"");
  StatusBarIconView v=new StatusBarIconView(getContext(),null,null);
  v.setTag(slot);
  v.set(icon);
  addView(v,0,new LinearLayout.LayoutParams(mIconSize,mIconSize));
}",0.944973544973545
194659,"@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      boolean show=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(show);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}","@Override public void dispatchDemoCommand(String command,Bundle args){
  if (!mDemoMode && command.equals(COMMAND_ENTER)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    unregisterListeners();
    mDemoMode=true;
    mDemoInetCondition=mInetCondition;
    mDemoWifiState=mWifiSignalController.getState();
  }
 else   if (mDemoMode && command.equals(COMMAND_EXIT)) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mDemoMode=false;
    updateMobileControllers();
    for (    MobileSignalController controller : mMobileSignalControllers.values()) {
      controller.resetLastState();
    }
    mWifiSignalController.resetLastState();
    mReceiverHandler.post(mRegisterListeners);
    notifyAllListeners();
  }
 else   if (mDemoMode && command.equals(COMMAND_NETWORK)) {
    String airplane=args.getString(""String_Node_Str"");
    if (airplane != null) {
      boolean show=airplane.equals(""String_Node_Str"");
      mCallbackHandler.setIsAirplaneMode(new IconState(show,TelephonyIcons.FLIGHT_MODE_ICON,R.string.accessibility_airplane_mode,mContext));
    }
    String fully=args.getString(""String_Node_Str"");
    if (fully != null) {
      mDemoInetCondition=Boolean.parseBoolean(fully);
      BitSet connected=new BitSet();
      if (mDemoInetCondition) {
        connected.set(mWifiSignalController.mTransportType);
      }
      mWifiSignalController.updateConnectivity(connected,connected);
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        if (mDemoInetCondition) {
          connected.set(controller.mTransportType);
        }
        controller.updateConnectivity(connected,connected);
      }
    }
    String wifi=args.getString(""String_Node_Str"");
    if (wifi != null) {
      boolean show=wifi.equals(""String_Node_Str"");
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        mDemoWifiState.level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),WifiIcons.WIFI_LEVEL_COUNT - 1);
        mDemoWifiState.connected=mDemoWifiState.level >= 0;
      }
      mDemoWifiState.enabled=show;
      mWifiSignalController.notifyListeners();
    }
    String sims=args.getString(""String_Node_Str"");
    if (sims != null) {
      int num=MathUtils.constrain(Integer.parseInt(sims),1,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      if (num != mMobileSignalControllers.size()) {
        mMobileSignalControllers.clear();
        int start=mSubscriptionManager.getActiveSubscriptionInfoCountMax();
        for (int i=start; i < start + num; i++) {
          subs.add(addSignalController(i,i));
        }
      }
      mCallbackHandler.setSubs(subs);
    }
    String nosim=args.getString(""String_Node_Str"");
    if (nosim != null) {
      mHasNoSims=nosim.equals(""String_Node_Str"");
      mCallbackHandler.setNoSims(mHasNoSims);
    }
    String mobile=args.getString(""String_Node_Str"");
    if (mobile != null) {
      boolean show=mobile.equals(""String_Node_Str"");
      String datatype=args.getString(""String_Node_Str"");
      String slotString=args.getString(""String_Node_Str"");
      int slot=TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
      slot=MathUtils.constrain(slot,0,8);
      List<SubscriptionInfo> subs=new ArrayList<>();
      while (mMobileSignalControllers.size() <= slot) {
        int nextSlot=mMobileSignalControllers.size();
        subs.add(addSignalController(nextSlot,nextSlot));
      }
      if (!subs.isEmpty()) {
        mCallbackHandler.setSubs(subs);
      }
      MobileSignalController controller=mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
      controller.getState().dataSim=datatype != null;
      if (datatype != null) {
        controller.getState().iconGroup=datatype.equals(""String_Node_Str"") ? TelephonyIcons.ONE_X : datatype.equals(""String_Node_Str"") ? TelephonyIcons.THREE_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.FOUR_G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.E : datatype.equals(""String_Node_Str"") ? TelephonyIcons.G : datatype.equals(""String_Node_Str"") ? TelephonyIcons.H : datatype.equals(""String_Node_Str"") ? TelephonyIcons.LTE : datatype.equals(""String_Node_Str"") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
      }
      int[][] icons=TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
      String level=args.getString(""String_Node_Str"");
      if (level != null) {
        controller.getState().level=level.equals(""String_Node_Str"") ? -1 : Math.min(Integer.parseInt(level),icons[0].length - 1);
        controller.getState().connected=controller.getState().level >= 0;
      }
      controller.getState().enabled=show;
      controller.notifyListeners();
    }
    String carrierNetworkChange=args.getString(""String_Node_Str"");
    if (carrierNetworkChange != null) {
      boolean show=carrierNetworkChange.equals(""String_Node_Str"");
      for (      MobileSignalController controller : mMobileSignalControllers.values()) {
        controller.setCarrierNetworkChangeMode(show);
      }
    }
  }
}",0.99644128113879
194660,"@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    notifyListeners();
  }
}","@VisibleForTesting protected void updateNoSims(){
  boolean hasNoSims=mHasMobileDataFeature && mMobileSignalControllers.size() == 0;
  if (hasNoSims != mHasNoSims) {
    mHasNoSims=hasNoSims;
    mCallbackHandler.setNoSims(mHasNoSims);
  }
}",0.8850325379609545
194661,"private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}","private void startDemoMode(){
  Intent intent=new Intent(DemoMode.ACTION_DEMO);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_ENTER);
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_CLOCK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NETWORK);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_BATTERY);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_STATUS);
  for (  String icon : STATUS_ICONS) {
    intent.putExtra(icon,""String_Node_Str"");
  }
  getContext().sendBroadcast(intent);
  intent.putExtra(DemoMode.EXTRA_COMMAND,DemoMode.COMMAND_NOTIFICATIONS);
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  getContext().sendBroadcast(intent);
  setGlobal(DEMO_MODE_ON,1);
}",0.9870748299319728
194662,"private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}","private void doOnCreate(){
  mTheme=mTheme != 0 ? mTheme : com.android.internal.R.style.Theme_DeviceDefault_VoiceInteractionSession;
  mInflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mWindow=new SoftInputWindow(mContext,""String_Node_Str"",mTheme,mCallbacks,this,mDispatcherState,WindowManager.LayoutParams.TYPE_VOICE_INTERACTION,Gravity.BOTTOM,true);
  mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
  initViews();
  mWindow.getWindow().setLayout(MATCH_PARENT,MATCH_PARENT);
  mWindow.setToken(mToken);
}",0.9596958174904944
194663,"/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=cf.left=vf.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=cf.right=vf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void layoutWindowLw(WindowState win,WindowState attached){
  if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
    return;
  }
  final WindowManager.LayoutParams attrs=win.getAttrs();
  final boolean isDefaultDisplay=win.isDefaultDisplay();
  final boolean needsToOffsetInputMethodTarget=isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
  if (needsToOffsetInputMethodTarget) {
    if (DEBUG_LAYOUT)     Slog.i(TAG,""String_Node_Str"");
    offsetInputMethodWindowLw(mLastInputMethodWindow);
  }
  final int fl=PolicyControl.getWindowFlags(win,attrs);
  final int sim=attrs.softInputMode;
  final int sysUiFl=PolicyControl.getSystemUiVisibility(win,null);
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect of=mTmpOverscanFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  final Rect dcf=mTmpDecorFrame;
  final Rect sf=mTmpStableFrame;
  Rect osf=null;
  dcf.setEmpty();
  final boolean hasNavBar=(isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
  final int adjust=sim & SOFT_INPUT_MASK_ADJUST;
  if (isDefaultDisplay) {
    sf.set(mStableLeft,mStableTop,mStableRight,mStableBottom);
  }
 else {
    sf.set(mOverscanLeft,mOverscanTop,mOverscanRight,mOverscanBottom);
  }
  if (!isDefaultDisplay) {
    if (attached != null) {
      setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
    }
 else {
      pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
      pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
      pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
      pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
    }
  }
 else   if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=of.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=of.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=of.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else   if (attrs.type == TYPE_VOICE_INTERACTION) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
    cf.bottom=vf.bottom=mStableBottom;
    cf.right=vf.right=mStableRight;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
  }
 else   if (win == mStatusBar) {
    pf.left=df.left=of.left=mUnrestrictedScreenLeft;
    pf.top=df.top=of.top=mUnrestrictedScreenTop;
    pf.right=df.right=of.right=mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
    pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
    cf.left=vf.left=mStableLeft;
    cf.top=vf.top=mStableTop;
    cf.right=vf.right=mStableRight;
    vf.bottom=mStableBottom;
    cf.bottom=mContentBottom;
  }
 else {
    dcf.left=mSystemLeft;
    dcf.top=mSystemTop;
    dcf.right=mSystemRight;
    dcf.bottom=mSystemBottom;
    final boolean inheritTranslucentDecor=(attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
    final boolean isAppWindow=attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
    final boolean topAtRest=win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
    if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
      if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.top=mStableTop;
      }
      if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
        dcf.bottom=mStableBottom;
        dcf.right=mStableRight;
      }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attached != null) {
        setAttachedWindowFrames(win,fl,adjust,attached,true,pf,df,of,cf,vf);
      }
 else {
        if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
          pf.left=df.left=of.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
          pf.top=df.top=of.top=mUnrestrictedScreenTop;
          pf.right=df.right=of.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          pf.bottom=df.bottom=of.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
          if (DEBUG_LAYOUT)           Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
        }
 else         if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=of.left=mOverscanScreenLeft;
          pf.top=df.top=of.top=mOverscanScreenTop;
          pf.right=df.right=of.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=of.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        }
 else         if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
          pf.left=df.left=mOverscanScreenLeft;
          pf.top=df.top=mOverscanScreenTop;
          pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
          pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
 else {
          pf.left=df.left=mRestrictedOverscanScreenLeft;
          pf.top=df.top=mRestrictedOverscanScreenTop;
          pf.right=df.right=mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
          pf.bottom=df.bottom=mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
          of.left=mUnrestrictedScreenLeft;
          of.top=mUnrestrictedScreenTop;
          of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
          of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        }
        if ((fl & FLAG_FULLSCREEN) == 0) {
          if (win.isVoiceInteraction()) {
            cf.left=mVoiceContentLeft;
            cf.top=mVoiceContentTop;
            cf.right=mVoiceContentRight;
            cf.bottom=mVoiceContentBottom;
          }
 else {
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
              cf.left=mDockLeft;
              cf.top=mDockTop;
              cf.right=mDockRight;
              cf.bottom=mDockBottom;
            }
 else {
              cf.left=mContentLeft;
              cf.top=mContentTop;
              cf.right=mContentRight;
              cf.bottom=mContentBottom;
            }
          }
        }
 else {
          cf.left=mRestrictedScreenLeft;
          cf.top=mRestrictedScreenTop;
          cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
          cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        applyStableConstraints(sysUiFl,fl,cf);
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
        pf.left=df.left=of.left=cf.left=hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
        pf.left=df.left=of.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (DEBUG_LAYOUT)         Slog.v(TAG,String.format(""String_Node_Str"",pf.left,pf.top,pf.right,pf.bottom));
      }
 else       if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_BOOT_PROGRESS) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (attrs.type == TYPE_WALLPAPER) {
        pf.left=df.left=mOverscanScreenLeft;
        pf.top=df.top=mOverscanScreenTop;
        pf.right=df.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=mOverscanScreenTop + mOverscanScreenHeight;
        of.left=cf.left=mUnrestrictedScreenLeft;
        of.top=cf.top=mUnrestrictedScreenTop;
        of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else       if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
        pf.left=df.left=of.left=cf.left=mOverscanScreenLeft;
        pf.top=df.top=of.top=cf.top=mOverscanScreenTop;
        pf.right=df.right=of.right=cf.right=mOverscanScreenLeft + mOverscanScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mOverscanScreenTop + mOverscanScreenHeight;
      }
 else       if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
        pf.left=df.left=of.left=cf.left=mUnrestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mUnrestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
      }
 else {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
      applyStableConstraints(sysUiFl,fl,cf);
      if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
 else {
        vf.set(cf);
      }
    }
 else     if (attached != null) {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ attached);
      setAttachedWindowFrames(win,fl,adjust,attached,false,pf,df,of,cf,vf);
    }
 else {
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str"");
      if (attrs.type == TYPE_STATUS_BAR_PANEL) {
        pf.left=df.left=of.left=cf.left=mRestrictedScreenLeft;
        pf.top=df.top=of.top=cf.top=mRestrictedScreenTop;
        pf.right=df.right=of.right=cf.right=mRestrictedScreenLeft + mRestrictedScreenWidth;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mRestrictedScreenTop + mRestrictedScreenHeight;
      }
 else       if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
        pf.left=df.left=of.left=cf.left=mStableLeft;
        pf.top=df.top=of.top=cf.top=mStableTop;
        pf.right=df.right=of.right=cf.right=mStableRight;
        pf.bottom=df.bottom=of.bottom=cf.bottom=mStableBottom;
      }
 else {
        pf.left=mContentLeft;
        pf.top=mContentTop;
        pf.right=mContentRight;
        pf.bottom=mContentBottom;
        if (win.isVoiceInteraction()) {
          df.left=of.left=cf.left=mVoiceContentLeft;
          df.top=of.top=cf.top=mVoiceContentTop;
          df.right=of.right=cf.right=mVoiceContentRight;
          df.bottom=of.bottom=cf.bottom=mVoiceContentBottom;
        }
 else         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
          df.left=of.left=cf.left=mDockLeft;
          df.top=of.top=cf.top=mDockTop;
          df.right=of.right=cf.right=mDockRight;
          df.bottom=of.bottom=cf.bottom=mDockBottom;
        }
 else {
          df.left=of.left=cf.left=mContentLeft;
          df.top=of.top=cf.top=mContentTop;
          df.right=of.right=cf.right=mContentRight;
          df.bottom=of.bottom=cf.bottom=mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
          vf.left=mCurLeft;
          vf.top=mCurTop;
          vf.right=mCurRight;
          vf.bottom=mCurBottom;
        }
 else {
          vf.set(cf);
        }
      }
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
    df.left=df.top=-10000;
    df.right=df.bottom=10000;
    if (attrs.type != TYPE_WALLPAPER) {
      of.left=of.top=cf.left=cf.top=vf.left=vf.top=-10000;
      of.right=of.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
    }
  }
  final boolean useOutsets=attrs.type == TYPE_WALLPAPER || (fl & (WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN)) != 0;
  if (isDefaultDisplay && useOutsets) {
    osf=mTmpOutsetFrame;
    osf.set(cf.left,cf.top,cf.right,cf.bottom);
    int outset=ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
    if (outset > 0) {
      int rotation=Surface.ROTATION_0;
      try {
        rotation=mWindowManager.getRotation();
      }
 catch (      RemoteException e) {
      }
      if (rotation == Surface.ROTATION_0) {
        osf.bottom+=outset;
      }
 else       if (rotation == Surface.ROTATION_90) {
        osf.right+=outset;
      }
 else       if (rotation == Surface.ROTATION_180) {
        osf.top-=outset;
      }
 else       if (rotation == Surface.ROTATION_270) {
        osf.left-=outset;
      }
      if (DEBUG_LAYOUT)       Slog.v(TAG,""String_Node_Str"" + outset + ""String_Node_Str""+ rotation+ ""String_Node_Str""+ osf);
    }
  }
  if (DEBUG_LAYOUT)   Slog.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ attached+ ""String_Node_Str""+ attrs.type+ String.format(""String_Node_Str"",fl)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ of.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString()+ ""String_Node_Str""+ dcf.toShortString()+ ""String_Node_Str""+ sf.toShortString()+ ""String_Node_Str""+ (osf == null ? ""String_Node_Str"" : osf.toShortString()));
  win.computeFrameLw(pf,df,of,cf,vf,dcf,sf,osf);
  if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    setLastInputMethodWindowLw(null,null);
    offsetInputMethodWindowLw(win);
  }
  if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
    offsetVoiceInputWindowLw(win);
  }
}",0.9818731996857634
194664,"private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}","private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
    mStatusBarView.removePendingHideExpandedRunnables();
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}",0.9751417357174008
194665,"@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(new Runnable(){
    @Override public void run(){
      mBar.makeExpandedInvisible();
    }
  }
);
  mLastFullyOpenedPanel=null;
}","@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(mHideExpandedRunnable);
  mLastFullyOpenedPanel=null;
}",0.8677248677248677
194666,"private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}","private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
    mStatusBarView.removePendingHideExpandedRunnables();
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}",0.9751417357174008
194667,"@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(new Runnable(){
    @Override public void run(){
      mBar.makeExpandedInvisible();
    }
  }
);
  mLastFullyOpenedPanel=null;
}","@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(mHideExpandedRunnable);
  mLastFullyOpenedPanel=null;
}",0.8677248677248677
194668,"private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}","private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
    mStatusBarView.removePendingHideExpandedRunnables();
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}",0.9751417357174008
194669,"@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(new Runnable(){
    @Override public void run(){
      mBar.makeExpandedInvisible();
    }
  }
);
  mLastFullyOpenedPanel=null;
}","@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(mHideExpandedRunnable);
  mLastFullyOpenedPanel=null;
}",0.8677248677248677
194670,"private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}","private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
    mStatusBarView.removePendingHideExpandedRunnables();
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}",0.9751417357174008
194671,"@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(new Runnable(){
    @Override public void run(){
      mBar.makeExpandedInvisible();
    }
  }
);
  mLastFullyOpenedPanel=null;
}","@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(mHideExpandedRunnable);
  mLastFullyOpenedPanel=null;
}",0.8677248677248677
194672,"private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}","private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
    mStatusBarView.removePendingHideExpandedRunnables();
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}",0.9751417357174008
194673,"@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(new Runnable(){
    @Override public void run(){
      mBar.makeExpandedInvisible();
    }
  }
);
  mLastFullyOpenedPanel=null;
}","@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(mHideExpandedRunnable);
  mLastFullyOpenedPanel=null;
}",0.8677248677248677
194674,"private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}","private void updateKeyguardState(boolean goingToFullShade,boolean fromShadeLocked){
  if (mState == StatusBarState.KEYGUARD) {
    mKeyguardIndicationController.setVisible(true);
    mNotificationPanel.resetViews();
    mKeyguardUserSwitcher.setKeyguard(true,fromShadeLocked);
    mStatusBarView.removePendingHideExpandedRunnables();
  }
 else {
    mKeyguardIndicationController.setVisible(false);
    mKeyguardUserSwitcher.setKeyguard(false,goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
  }
  if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
    mScrimController.setKeyguardShowing(true);
    mIconPolicy.setKeyguardShowing(true);
  }
 else {
    mScrimController.setKeyguardShowing(false);
    mIconPolicy.setKeyguardShowing(false);
  }
  mNotificationPanel.setBarState(mState,mKeyguardFadingAway,goingToFullShade);
  updateDozingState();
  updatePublicMode();
  updateStackScrollerState(goingToFullShade);
  updateNotifications();
  checkBarModes();
  updateMediaMetaData(false);
  mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(),mStatusBarKeyguardViewManager.isSecure());
}",0.9751417357174008
194675,"@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(new Runnable(){
    @Override public void run(){
      mBar.makeExpandedInvisible();
    }
  }
);
  mLastFullyOpenedPanel=null;
}","@Override public void onAllPanelsCollapsed(){
  super.onAllPanelsCollapsed();
  if (PhoneStatusBar.DEBUG_EMPTY_KEYGUARD && mBar.getBarState() == StatusBarState.KEYGUARD) {
    Log.i(PhoneStatusBar.TAG,""String_Node_Str"" + Log.getStackTraceString(new Throwable()));
  }
  postOnAnimation(mHideExpandedRunnable);
  mLastFullyOpenedPanel=null;
}",0.8677248677248677
194676,"void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    ActivityManager.RunningTaskInfo topTask=mSystemServicesProxy.getTopMostTask();
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask,null)) {
      Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
      intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
      intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
    }
  }
}","void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
    intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
    mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
  }
}",0.8182741116751269
194677,"@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}","@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  if (mContext == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}",0.9611872146118722
194678,"void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    ActivityManager.RunningTaskInfo topTask=mSystemServicesProxy.getTopMostTask();
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask,null)) {
      Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
      intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
      intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
    }
  }
}","void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
    intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
    mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
  }
}",0.8182741116751269
194679,"@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}","@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  if (mContext == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}",0.9611872146118722
194680,"void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    ActivityManager.RunningTaskInfo topTask=mSystemServicesProxy.getTopMostTask();
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask,null)) {
      Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
      intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
      intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
    }
  }
}","void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
    intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
    mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
  }
}",0.8182741116751269
194681,"@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}","@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  if (mContext == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}",0.9611872146118722
194682,"void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    ActivityManager.RunningTaskInfo topTask=mSystemServicesProxy.getTopMostTask();
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask,null)) {
      Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
      intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
      intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
    }
  }
}","void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
    intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
    mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
  }
}",0.8182741116751269
194683,"@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}","@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  if (mContext == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}",0.9611872146118722
194684,"void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    ActivityManager.RunningTaskInfo topTask=mSystemServicesProxy.getTopMostTask();
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask,null)) {
      Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
      intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
      intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
    }
  }
}","void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
    intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
    mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
  }
}",0.8182741116751269
194685,"@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}","@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  if (mContext == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}",0.9611872146118722
194686,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
}",0.963917525773196
194687,"/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(){
  if (mFocusedTaskIndex < 0) {
    int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
    int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      tv.getHitRect(mTmpRect);
      if (mTmpRect.contains(x,y)) {
        mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
        break;
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      mFocusedTaskIndex=taskViewCount - 1;
    }
  }
  return mFocusedTaskIndex >= 0;
}","/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(boolean findClosestToCenter){
  if (mFocusedTaskIndex < 0) {
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    if (findClosestToCenter) {
      int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
      int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
      for (int i=taskViewCount - 1; i >= 0; i--) {
        TaskView tv=taskViews.get(i);
        tv.getHitRect(mTmpRect);
        if (mTmpRect.contains(x,y)) {
          mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
          mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
          break;
        }
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      TaskView tv=taskViews.get(taskViewCount - 1);
      mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
      mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
    }
  }
  return mFocusedTaskIndex >= 0;
}",0.7315472936030618
194688,"/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      taskViews=getTaskViews();
      taskViewCount=taskViews.size();
      if (taskViewCount > 0 && ssp.isTouchExplorationEnabled()) {
        TaskView atv=taskViews.get(taskViewCount - 1);
        int indexOfTask=mStack.indexOfTask(atv.getTask());
        if (mPrevAccessibilityFocusedIndex != indexOfTask) {
          tv.requestAccessibilityFocus();
          mPrevAccessibilityFocusedIndex=indexOfTask;
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}","/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    boolean reaquireAccessibilityFocus=false;
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        reaquireAccessibilityFocus|=(i == mPrevAccessibilityFocusedIndex);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      if (reaquireAccessibilityFocus) {
        taskViews=getTaskViews();
        taskViewCount=taskViews.size();
        if (taskViewCount > 0 && ssp.isTouchExplorationEnabled() && mPrevAccessibilityFocusedIndex != -1) {
          TaskView atv=taskViews.get(taskViewCount - 1);
          int indexOfTask=mStack.indexOfTask(atv.getTask());
          if (mPrevAccessibilityFocusedIndex != indexOfTask) {
            tv.requestAccessibilityFocus();
            mPrevAccessibilityFocusedIndex=indexOfTask;
          }
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}",0.9582156133828996
194689,"/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
}","/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
  mPrevAccessibilityFocusedIndex=-1;
}",0.945827232796486
194690,"/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    Task t=mStack.getTasks().get(taskIndex);
    TaskView tv=getChildViewForTask(t);
    Runnable postScrollRunnable=null;
    if (tv != null) {
      tv.setFocusedTask(animateFocusedState);
    }
 else {
      postScrollRunnable=new Runnable(){
        @Override public void run(){
          Task t=mStack.getTasks().get(mFocusedTaskIndex);
          TaskView tv=getChildViewForTask(t);
          if (tv != null) {
            tv.setFocusedTask(animateFocusedState);
          }
        }
      }
;
    }
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}","/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    mPrevAccessibilityFocusedIndex=taskIndex;
    final Task t=mStack.getTasks().get(mFocusedTaskIndex);
    Runnable postScrollRunnable=new Runnable(){
      @Override public void run(){
        TaskView tv=getChildViewForTask(t);
        if (tv != null) {
          tv.setFocusedTask(animateFocusedState);
          tv.requestAccessibilityFocus();
        }
      }
    }
;
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}",0.8233183856502242
194691,"/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}","/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}",0.9934747145187602
194692,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
}",0.963917525773196
194693,"/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(){
  if (mFocusedTaskIndex < 0) {
    int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
    int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      tv.getHitRect(mTmpRect);
      if (mTmpRect.contains(x,y)) {
        mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
        break;
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      mFocusedTaskIndex=taskViewCount - 1;
    }
  }
  return mFocusedTaskIndex >= 0;
}","/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(boolean findClosestToCenter){
  if (mFocusedTaskIndex < 0) {
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    if (findClosestToCenter) {
      int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
      int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
      for (int i=taskViewCount - 1; i >= 0; i--) {
        TaskView tv=taskViews.get(i);
        tv.getHitRect(mTmpRect);
        if (mTmpRect.contains(x,y)) {
          mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
          mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
          break;
        }
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      TaskView tv=taskViews.get(taskViewCount - 1);
      mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
      mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
    }
  }
  return mFocusedTaskIndex >= 0;
}",0.7315472936030618
194694,"/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      taskViews=getTaskViews();
      taskViewCount=taskViews.size();
      if (taskViewCount > 0 && ssp.isTouchExplorationEnabled()) {
        TaskView atv=taskViews.get(taskViewCount - 1);
        int indexOfTask=mStack.indexOfTask(atv.getTask());
        if (mPrevAccessibilityFocusedIndex != indexOfTask) {
          tv.requestAccessibilityFocus();
          mPrevAccessibilityFocusedIndex=indexOfTask;
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}","/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    boolean reaquireAccessibilityFocus=false;
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        reaquireAccessibilityFocus|=(i == mPrevAccessibilityFocusedIndex);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      if (reaquireAccessibilityFocus) {
        taskViews=getTaskViews();
        taskViewCount=taskViews.size();
        if (taskViewCount > 0 && ssp.isTouchExplorationEnabled() && mPrevAccessibilityFocusedIndex != -1) {
          TaskView atv=taskViews.get(taskViewCount - 1);
          int indexOfTask=mStack.indexOfTask(atv.getTask());
          if (mPrevAccessibilityFocusedIndex != indexOfTask) {
            tv.requestAccessibilityFocus();
            mPrevAccessibilityFocusedIndex=indexOfTask;
          }
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}",0.9582156133828996
194695,"/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
}","/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
  mPrevAccessibilityFocusedIndex=-1;
}",0.945827232796486
194696,"/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    Task t=mStack.getTasks().get(taskIndex);
    TaskView tv=getChildViewForTask(t);
    Runnable postScrollRunnable=null;
    if (tv != null) {
      tv.setFocusedTask(animateFocusedState);
    }
 else {
      postScrollRunnable=new Runnable(){
        @Override public void run(){
          Task t=mStack.getTasks().get(mFocusedTaskIndex);
          TaskView tv=getChildViewForTask(t);
          if (tv != null) {
            tv.setFocusedTask(animateFocusedState);
          }
        }
      }
;
    }
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}","/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    mPrevAccessibilityFocusedIndex=taskIndex;
    final Task t=mStack.getTasks().get(mFocusedTaskIndex);
    Runnable postScrollRunnable=new Runnable(){
      @Override public void run(){
        TaskView tv=getChildViewForTask(t);
        if (tv != null) {
          tv.setFocusedTask(animateFocusedState);
          tv.requestAccessibilityFocus();
        }
      }
    }
;
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}",0.8233183856502242
194697,"/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}","/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}",0.9934747145187602
194698,"void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    ActivityManager.RunningTaskInfo topTask=mSystemServicesProxy.getTopMostTask();
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask,null)) {
      Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
      intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
      intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
    }
  }
}","void hideRecentsInternal(boolean triggeredFromAltTab,boolean triggeredFromHomeKey){
  if (mBootCompleted) {
    Intent intent=createLocalBroadcastIntent(mContext,ACTION_HIDE_RECENTS_ACTIVITY);
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB,triggeredFromAltTab);
    intent.putExtra(EXTRA_TRIGGERED_FROM_HOME_KEY,triggeredFromHomeKey);
    mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT);
  }
}",0.8182741116751269
194699,"@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}","@Override protected void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidgetInfo){
  if (mCb == null)   return;
  if (mContext == null)   return;
  SystemServicesProxy ssp=RecentsTaskLoader.getInstance().getSystemServicesProxy();
  if (appWidgetId > -1 && appWidgetId == mConfig.searchBarAppWidgetId) {
    ssp.unbindSearchAppWidget(this,appWidgetId);
    mConfig.updateSearchBarAppWidgetId(mContext,-1);
    mCb.refreshSearchWidget();
  }
}",0.9611872146118722
194700,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
}",0.963917525773196
194701,"/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(){
  if (mFocusedTaskIndex < 0) {
    int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
    int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      tv.getHitRect(mTmpRect);
      if (mTmpRect.contains(x,y)) {
        mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
        break;
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      mFocusedTaskIndex=taskViewCount - 1;
    }
  }
  return mFocusedTaskIndex >= 0;
}","/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(boolean findClosestToCenter){
  if (mFocusedTaskIndex < 0) {
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    if (findClosestToCenter) {
      int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
      int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
      for (int i=taskViewCount - 1; i >= 0; i--) {
        TaskView tv=taskViews.get(i);
        tv.getHitRect(mTmpRect);
        if (mTmpRect.contains(x,y)) {
          mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
          mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
          break;
        }
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      TaskView tv=taskViews.get(taskViewCount - 1);
      mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
      mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
    }
  }
  return mFocusedTaskIndex >= 0;
}",0.7315472936030618
194702,"/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      taskViews=getTaskViews();
      taskViewCount=taskViews.size();
      if (taskViewCount > 0 && ssp.isTouchExplorationEnabled()) {
        TaskView atv=taskViews.get(taskViewCount - 1);
        int indexOfTask=mStack.indexOfTask(atv.getTask());
        if (mPrevAccessibilityFocusedIndex != indexOfTask) {
          tv.requestAccessibilityFocus();
          mPrevAccessibilityFocusedIndex=indexOfTask;
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}","/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    boolean reaquireAccessibilityFocus=false;
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        reaquireAccessibilityFocus|=(i == mPrevAccessibilityFocusedIndex);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      if (reaquireAccessibilityFocus) {
        taskViews=getTaskViews();
        taskViewCount=taskViews.size();
        if (taskViewCount > 0 && ssp.isTouchExplorationEnabled() && mPrevAccessibilityFocusedIndex != -1) {
          TaskView atv=taskViews.get(taskViewCount - 1);
          int indexOfTask=mStack.indexOfTask(atv.getTask());
          if (mPrevAccessibilityFocusedIndex != indexOfTask) {
            tv.requestAccessibilityFocus();
            mPrevAccessibilityFocusedIndex=indexOfTask;
          }
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}",0.9582156133828996
194703,"/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
}","/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
  mPrevAccessibilityFocusedIndex=-1;
}",0.945827232796486
194704,"/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    Task t=mStack.getTasks().get(taskIndex);
    TaskView tv=getChildViewForTask(t);
    Runnable postScrollRunnable=null;
    if (tv != null) {
      tv.setFocusedTask(animateFocusedState);
    }
 else {
      postScrollRunnable=new Runnable(){
        @Override public void run(){
          Task t=mStack.getTasks().get(mFocusedTaskIndex);
          TaskView tv=getChildViewForTask(t);
          if (tv != null) {
            tv.setFocusedTask(animateFocusedState);
          }
        }
      }
;
    }
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}","/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    mPrevAccessibilityFocusedIndex=taskIndex;
    final Task t=mStack.getTasks().get(mFocusedTaskIndex);
    Runnable postScrollRunnable=new Runnable(){
      @Override public void run(){
        TaskView tv=getChildViewForTask(t);
        if (tv != null) {
          tv.setFocusedTask(animateFocusedState);
          tv.requestAccessibilityFocus();
        }
      }
    }
;
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}",0.8233183856502242
194705,"/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}","/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}",0.9934747145187602
194706,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
}",0.963917525773196
194707,"/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(){
  if (mFocusedTaskIndex < 0) {
    int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
    int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      tv.getHitRect(mTmpRect);
      if (mTmpRect.contains(x,y)) {
        mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
        break;
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      mFocusedTaskIndex=taskViewCount - 1;
    }
  }
  return mFocusedTaskIndex >= 0;
}","/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(boolean findClosestToCenter){
  if (mFocusedTaskIndex < 0) {
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    if (findClosestToCenter) {
      int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
      int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
      for (int i=taskViewCount - 1; i >= 0; i--) {
        TaskView tv=taskViews.get(i);
        tv.getHitRect(mTmpRect);
        if (mTmpRect.contains(x,y)) {
          mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
          mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
          break;
        }
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      TaskView tv=taskViews.get(taskViewCount - 1);
      mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
      mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
    }
  }
  return mFocusedTaskIndex >= 0;
}",0.7315472936030618
194708,"/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      taskViews=getTaskViews();
      taskViewCount=taskViews.size();
      if (taskViewCount > 0 && ssp.isTouchExplorationEnabled()) {
        TaskView atv=taskViews.get(taskViewCount - 1);
        int indexOfTask=mStack.indexOfTask(atv.getTask());
        if (mPrevAccessibilityFocusedIndex != indexOfTask) {
          tv.requestAccessibilityFocus();
          mPrevAccessibilityFocusedIndex=indexOfTask;
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}","/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    boolean reaquireAccessibilityFocus=false;
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        reaquireAccessibilityFocus|=(i == mPrevAccessibilityFocusedIndex);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      if (reaquireAccessibilityFocus) {
        taskViews=getTaskViews();
        taskViewCount=taskViews.size();
        if (taskViewCount > 0 && ssp.isTouchExplorationEnabled() && mPrevAccessibilityFocusedIndex != -1) {
          TaskView atv=taskViews.get(taskViewCount - 1);
          int indexOfTask=mStack.indexOfTask(atv.getTask());
          if (mPrevAccessibilityFocusedIndex != indexOfTask) {
            tv.requestAccessibilityFocus();
            mPrevAccessibilityFocusedIndex=indexOfTask;
          }
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}",0.9582156133828996
194709,"/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
}","/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
  mPrevAccessibilityFocusedIndex=-1;
}",0.945827232796486
194710,"/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    Task t=mStack.getTasks().get(taskIndex);
    TaskView tv=getChildViewForTask(t);
    Runnable postScrollRunnable=null;
    if (tv != null) {
      tv.setFocusedTask(animateFocusedState);
    }
 else {
      postScrollRunnable=new Runnable(){
        @Override public void run(){
          Task t=mStack.getTasks().get(mFocusedTaskIndex);
          TaskView tv=getChildViewForTask(t);
          if (tv != null) {
            tv.setFocusedTask(animateFocusedState);
          }
        }
      }
;
    }
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}","/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    mPrevAccessibilityFocusedIndex=taskIndex;
    final Task t=mStack.getTasks().get(mFocusedTaskIndex);
    Runnable postScrollRunnable=new Runnable(){
      @Override public void run(){
        TaskView tv=getChildViewForTask(t);
        if (tv != null) {
          tv.setFocusedTask(animateFocusedState);
          tv.requestAccessibilityFocus();
        }
      }
    }
;
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}",0.8233183856502242
194711,"/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}","/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}",0.9934747145187602
194712,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  setStack(stack);
  mConfig=RecentsConfiguration.getInstance();
  mViewPool=new ViewPool<TaskView,Task>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackViewLayoutAlgorithm(mConfig);
  mFilterAlgorithm=new TaskStackViewFilterAlgorithm(mConfig,this,mViewPool);
  mStackScroller=new TaskStackViewScroller(context,mConfig,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mConfig,mStackScroller);
  mUIDozeTrigger=new DozeTrigger(mConfig.taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
}",0.963917525773196
194713,"/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(){
  if (mFocusedTaskIndex < 0) {
    int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
    int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      tv.getHitRect(mTmpRect);
      if (mTmpRect.contains(x,y)) {
        mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
        break;
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      mFocusedTaskIndex=taskViewCount - 1;
    }
  }
  return mFocusedTaskIndex >= 0;
}","/** 
 * Ensures that there is a task focused, if nothing is focused, then we will use the task at the center of the visible stack.
 */
public boolean ensureFocusedTask(boolean findClosestToCenter){
  if (mFocusedTaskIndex < 0) {
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    if (findClosestToCenter) {
      int x=mLayoutAlgorithm.mStackVisibleRect.centerX();
      int y=mLayoutAlgorithm.mStackVisibleRect.centerY();
      for (int i=taskViewCount - 1; i >= 0; i--) {
        TaskView tv=taskViews.get(i);
        tv.getHitRect(mTmpRect);
        if (mTmpRect.contains(x,y)) {
          mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
          mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
          break;
        }
      }
    }
    if (mFocusedTaskIndex < 0 && taskViewCount > 0) {
      TaskView tv=taskViews.get(taskViewCount - 1);
      mFocusedTaskIndex=mStack.indexOfTask(tv.getTask());
      mPrevAccessibilityFocusedIndex=mFocusedTaskIndex;
    }
  }
  return mFocusedTaskIndex >= 0;
}",0.7315472936030618
194714,"/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      taskViews=getTaskViews();
      taskViewCount=taskViews.size();
      if (taskViewCount > 0 && ssp.isTouchExplorationEnabled()) {
        TaskView atv=taskViews.get(taskViewCount - 1);
        int indexOfTask=mStack.indexOfTask(atv.getTask());
        if (mPrevAccessibilityFocusedIndex != indexOfTask) {
          tv.requestAccessibilityFocus();
          mPrevAccessibilityFocusedIndex=indexOfTask;
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}","/** 
 * Synchronizes the views with the model 
 */
boolean synchronizeStackViewsWithModel(){
  if (mStackViewsDirty) {
    RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
    SystemServicesProxy ssp=loader.getSystemServicesProxy();
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleRange=mTmpVisibleRange;
    boolean isValidVisibleRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleRange,false);
    if (mDebugOverlay != null) {
      mDebugOverlay.setText(""String_Node_Str"" + visibleRange[1] + ""String_Node_Str""+ visibleRange[0]+ ""String_Node_Str"");
    }
    if (Constants.DebugFlags.App.EnableDismissAll && mDismissAllButton == null) {
      mDismissAllButton=(DismissView)mInflater.inflate(R.layout.recents_dismiss_button,this,false);
      mDismissAllButton.setOnButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mStack.removeAllTasks();
        }
      }
);
      addView(mDismissAllButton,0);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    int taskViewCount=taskViews.size();
    boolean reaquireAccessibilityFocus=false;
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (visibleRange[1] <= taskIndex && taskIndex <= visibleRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        mViewPool.returnViewToPool(tv);
        reaquireAccessibilityFocus|=(i == mPrevAccessibilityFocusedIndex);
        if (task == mStack.getFrontMostTask()) {
          hideDismissAllButton(null);
        }
      }
    }
    for (int i=visibleRange[0]; isValidVisibleRange && i >= visibleRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      int taskIndex=mStack.indexOfTask(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            mLayoutAlgorithm.getStackTransform(0f,0f,mTmpTransform,null);
          }
 else {
            mLayoutAlgorithm.getStackTransform(1f,0f,mTmpTransform,null);
          }
          tv.updateViewPropertiesToTaskTransform(mTmpTransform,0);
        }
        if (!mAwaitingFirstLayout && (task == mStack.getFrontMostTask())) {
          showDismissAllButton();
        }
      }
      tv.updateViewPropertiesToTaskTransform(mCurrentTaskTransforms.get(taskIndex),mStackViewsAnimationDuration,mRequestUpdateClippingListener);
      if (reaquireAccessibilityFocus) {
        taskViews=getTaskViews();
        taskViewCount=taskViews.size();
        if (taskViewCount > 0 && ssp.isTouchExplorationEnabled() && mPrevAccessibilityFocusedIndex != -1) {
          TaskView atv=taskViews.get(taskViewCount - 1);
          int indexOfTask=mStack.indexOfTask(atv.getTask());
          if (mPrevAccessibilityFocusedIndex != indexOfTask) {
            tv.requestAccessibilityFocus();
            mPrevAccessibilityFocusedIndex=indexOfTask;
          }
        }
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}",0.9582156133828996
194715,"/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
}","/** 
 * Resets the focused task. 
 */
void resetFocusedTask(){
  if ((0 <= mFocusedTaskIndex) && (mFocusedTaskIndex < mStack.getTaskCount())) {
    Task t=mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv=getChildViewForTask(t);
    if (tv != null) {
      tv.unsetFocusedTask();
    }
  }
  mFocusedTaskIndex=-1;
  mPrevAccessibilityFocusedIndex=-1;
}",0.945827232796486
194716,"/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    Task t=mStack.getTasks().get(taskIndex);
    TaskView tv=getChildViewForTask(t);
    Runnable postScrollRunnable=null;
    if (tv != null) {
      tv.setFocusedTask(animateFocusedState);
    }
 else {
      postScrollRunnable=new Runnable(){
        @Override public void run(){
          Task t=mStack.getTasks().get(mFocusedTaskIndex);
          TaskView tv=getChildViewForTask(t);
          if (tv != null) {
            tv.setFocusedTask(animateFocusedState);
          }
        }
      }
;
    }
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}","/** 
 * Focuses the task at the specified index in the stack 
 */
void focusTask(int taskIndex,boolean scrollToNewPosition,final boolean animateFocusedState){
  if (taskIndex == mFocusedTaskIndex)   return;
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
    mFocusedTaskIndex=taskIndex;
    mPrevAccessibilityFocusedIndex=taskIndex;
    final Task t=mStack.getTasks().get(mFocusedTaskIndex);
    Runnable postScrollRunnable=new Runnable(){
      @Override public void run(){
        TaskView tv=getChildViewForTask(t);
        if (tv != null) {
          tv.setFocusedTask(animateFocusedState);
          tv.requestAccessibilityFocus();
        }
      }
    }
;
    if (scrollToNewPosition) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
      newScroll=mStackScroller.getBoundedStackScroll(newScroll);
      mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,postScrollRunnable);
    }
 else {
      if (postScrollRunnable != null) {
        postScrollRunnable.run();
      }
    }
  }
}",0.8233183856502242
194717,"/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask()) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}","/** 
 * Handles generic motion events 
 */
public boolean onGenericMotionEvent(MotionEvent ev){
  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {
    int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_SCROLL:
      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);
    if (vScroll > 0) {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(true,false);
      }
    }
 else {
      if (mSv.ensureFocusedTask(true)) {
        mSv.focusNextTask(false,false);
      }
    }
  return true;
}
}
return false;
}",0.9934747145187602
194718,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    requestMetadata=new CameraMetadataNative(request.getNativeCopy());
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9856825972978424
194719,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    requestMetadata=new CameraMetadataNative(request.getNativeCopy());
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9856825972978424
194720,"private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (!mSleeping) {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
 else {
    if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
      isInteraction=true;
      app.fgInteractionTime=0;
    }
 else     if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
      final long now=SystemClock.elapsedRealtime();
      if (app.fgInteractionTime == 0) {
        app.fgInteractionTime=now;
        isInteraction=false;
      }
 else {
        isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
      }
    }
 else {
      isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.fgInteractionTime=0;
    }
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}","private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
    isInteraction=true;
    app.fgInteractionTime=0;
  }
 else   if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
    final long now=SystemClock.elapsedRealtime();
    if (app.fgInteractionTime == 0) {
      app.fgInteractionTime=now;
      isInteraction=false;
    }
 else {
      isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
    }
  }
 else {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}",0.9150908416759362
194721,"void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    if (mRunningVoice == null) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
    mRunningVoice=session;
  }
}","void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    boolean wasRunningVoice=mRunningVoice != null;
    mRunningVoice=session;
    if (!wasRunningVoice) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
  }
}",0.8126649076517151
194722,"@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  return super.onHandleForceStop(intent,packages,uid,doit);
}","@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ doit);
  int userHandle=UserHandle.getUserId(uid);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  boolean hit=false;
  for (  String pkg : packages) {
    if (curInteractor != null && pkg.equals(curInteractor.getPackageName())) {
      hit=true;
      break;
    }
 else     if (curRecognizer != null && pkg.equals(curRecognizer.getPackageName())) {
      hit=true;
      break;
    }
  }
  if (hit && doit) {
synchronized (VoiceInteractionManagerService.this) {
      mSoundTriggerHelper.stopAllRecognitions();
      if (mImpl != null) {
        mImpl.shutdownLocked();
        mImpl=null;
      }
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      switchImplementationIfNeededLocked(true);
    }
  }
  return hit;
}",0.1902356902356902
194723,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  if (curRecognizer == null) {
    if (anyPackagesAppearing()) {
      curRecognizer=findAvailRecognizer(null,userHandle);
      if (curRecognizer != null) {
        setCurRecognizer(curRecognizer,userHandle);
      }
    }
    return;
  }
  if (curInteractor != null) {
    int change=isPackageDisappearing(curInteractor.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE) {
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      return;
    }
    change=isPackageAppearing(curInteractor.getPackageName());
    if (change != PACKAGE_UNCHANGED) {
      if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
        switchImplementationIfNeededLocked(true);
      }
    }
    return;
  }
  int change=isPackageDisappearing(curRecognizer.getPackageName());
  if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
    setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
  }
 else   if (isPackageModified(curRecognizer.getPackageName())) {
    setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerService.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.9432228421398096
194724,"private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (!mSleeping) {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
 else {
    if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
      isInteraction=true;
      app.fgInteractionTime=0;
    }
 else     if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
      final long now=SystemClock.elapsedRealtime();
      if (app.fgInteractionTime == 0) {
        app.fgInteractionTime=now;
        isInteraction=false;
      }
 else {
        isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
      }
    }
 else {
      isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.fgInteractionTime=0;
    }
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}","private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
    isInteraction=true;
    app.fgInteractionTime=0;
  }
 else   if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
    final long now=SystemClock.elapsedRealtime();
    if (app.fgInteractionTime == 0) {
      app.fgInteractionTime=now;
      isInteraction=false;
    }
 else {
      isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
    }
  }
 else {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}",0.9150908416759362
194725,"void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    if (mRunningVoice == null) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
    mRunningVoice=session;
  }
}","void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    boolean wasRunningVoice=mRunningVoice != null;
    mRunningVoice=session;
    if (!wasRunningVoice) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
  }
}",0.8126649076517151
194726,"@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  return super.onHandleForceStop(intent,packages,uid,doit);
}","@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ doit);
  int userHandle=UserHandle.getUserId(uid);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  boolean hit=false;
  for (  String pkg : packages) {
    if (curInteractor != null && pkg.equals(curInteractor.getPackageName())) {
      hit=true;
      break;
    }
 else     if (curRecognizer != null && pkg.equals(curRecognizer.getPackageName())) {
      hit=true;
      break;
    }
  }
  if (hit && doit) {
synchronized (VoiceInteractionManagerService.this) {
      mSoundTriggerHelper.stopAllRecognitions();
      if (mImpl != null) {
        mImpl.shutdownLocked();
        mImpl=null;
      }
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      switchImplementationIfNeededLocked(true);
    }
  }
  return hit;
}",0.1902356902356902
194727,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  if (curRecognizer == null) {
    if (anyPackagesAppearing()) {
      curRecognizer=findAvailRecognizer(null,userHandle);
      if (curRecognizer != null) {
        setCurRecognizer(curRecognizer,userHandle);
      }
    }
    return;
  }
  if (curInteractor != null) {
    int change=isPackageDisappearing(curInteractor.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE) {
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      return;
    }
    change=isPackageAppearing(curInteractor.getPackageName());
    if (change != PACKAGE_UNCHANGED) {
      if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
        switchImplementationIfNeededLocked(true);
      }
    }
    return;
  }
  int change=isPackageDisappearing(curRecognizer.getPackageName());
  if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
    setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
  }
 else   if (isPackageModified(curRecognizer.getPackageName())) {
    setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerService.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.9432228421398096
194728,"private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (!mSleeping) {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
 else {
    if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
      isInteraction=true;
      app.fgInteractionTime=0;
    }
 else     if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
      final long now=SystemClock.elapsedRealtime();
      if (app.fgInteractionTime == 0) {
        app.fgInteractionTime=now;
        isInteraction=false;
      }
 else {
        isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
      }
    }
 else {
      isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.fgInteractionTime=0;
    }
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}","private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
    isInteraction=true;
    app.fgInteractionTime=0;
  }
 else   if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
    final long now=SystemClock.elapsedRealtime();
    if (app.fgInteractionTime == 0) {
      app.fgInteractionTime=now;
      isInteraction=false;
    }
 else {
      isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
    }
  }
 else {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}",0.9150908416759362
194729,"void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    if (mRunningVoice == null) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
    mRunningVoice=session;
  }
}","void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    boolean wasRunningVoice=mRunningVoice != null;
    mRunningVoice=session;
    if (!wasRunningVoice) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
  }
}",0.8126649076517151
194730,"@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  return super.onHandleForceStop(intent,packages,uid,doit);
}","@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ doit);
  int userHandle=UserHandle.getUserId(uid);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  boolean hit=false;
  for (  String pkg : packages) {
    if (curInteractor != null && pkg.equals(curInteractor.getPackageName())) {
      hit=true;
      break;
    }
 else     if (curRecognizer != null && pkg.equals(curRecognizer.getPackageName())) {
      hit=true;
      break;
    }
  }
  if (hit && doit) {
synchronized (VoiceInteractionManagerService.this) {
      mSoundTriggerHelper.stopAllRecognitions();
      if (mImpl != null) {
        mImpl.shutdownLocked();
        mImpl=null;
      }
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      switchImplementationIfNeededLocked(true);
    }
  }
  return hit;
}",0.1902356902356902
194731,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  if (curRecognizer == null) {
    if (anyPackagesAppearing()) {
      curRecognizer=findAvailRecognizer(null,userHandle);
      if (curRecognizer != null) {
        setCurRecognizer(curRecognizer,userHandle);
      }
    }
    return;
  }
  if (curInteractor != null) {
    int change=isPackageDisappearing(curInteractor.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE) {
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      return;
    }
    change=isPackageAppearing(curInteractor.getPackageName());
    if (change != PACKAGE_UNCHANGED) {
      if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
        switchImplementationIfNeededLocked(true);
      }
    }
    return;
  }
  int change=isPackageDisappearing(curRecognizer.getPackageName());
  if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
    setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
  }
 else   if (isPackageModified(curRecognizer.getPackageName())) {
    setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerService.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.9432228421398096
194732,"private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (!mSleeping) {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
 else {
    if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
      isInteraction=true;
      app.fgInteractionTime=0;
    }
 else     if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
      final long now=SystemClock.elapsedRealtime();
      if (app.fgInteractionTime == 0) {
        app.fgInteractionTime=now;
        isInteraction=false;
      }
 else {
        isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
      }
    }
 else {
      isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.fgInteractionTime=0;
    }
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}","private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
    isInteraction=true;
    app.fgInteractionTime=0;
  }
 else   if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
    final long now=SystemClock.elapsedRealtime();
    if (app.fgInteractionTime == 0) {
      app.fgInteractionTime=now;
      isInteraction=false;
    }
 else {
      isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
    }
  }
 else {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}",0.9150908416759362
194733,"void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    if (mRunningVoice == null) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
    mRunningVoice=session;
  }
}","void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    boolean wasRunningVoice=mRunningVoice != null;
    mRunningVoice=session;
    if (!wasRunningVoice) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
  }
}",0.8126649076517151
194734,"@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  return super.onHandleForceStop(intent,packages,uid,doit);
}","@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ doit);
  int userHandle=UserHandle.getUserId(uid);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  boolean hit=false;
  for (  String pkg : packages) {
    if (curInteractor != null && pkg.equals(curInteractor.getPackageName())) {
      hit=true;
      break;
    }
 else     if (curRecognizer != null && pkg.equals(curRecognizer.getPackageName())) {
      hit=true;
      break;
    }
  }
  if (hit && doit) {
synchronized (VoiceInteractionManagerService.this) {
      mSoundTriggerHelper.stopAllRecognitions();
      if (mImpl != null) {
        mImpl.shutdownLocked();
        mImpl=null;
      }
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      switchImplementationIfNeededLocked(true);
    }
  }
  return hit;
}",0.1902356902356902
194735,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  if (curRecognizer == null) {
    if (anyPackagesAppearing()) {
      curRecognizer=findAvailRecognizer(null,userHandle);
      if (curRecognizer != null) {
        setCurRecognizer(curRecognizer,userHandle);
      }
    }
    return;
  }
  if (curInteractor != null) {
    int change=isPackageDisappearing(curInteractor.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE) {
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      return;
    }
    change=isPackageAppearing(curInteractor.getPackageName());
    if (change != PACKAGE_UNCHANGED) {
      if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
        switchImplementationIfNeededLocked(true);
      }
    }
    return;
  }
  int change=isPackageDisappearing(curRecognizer.getPackageName());
  if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
    setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
  }
 else   if (isPackageModified(curRecognizer.getPackageName())) {
    setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerService.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.9432228421398096
194736,"private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (!mSleeping) {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
 else {
    if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
      isInteraction=true;
      app.fgInteractionTime=0;
    }
 else     if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
      final long now=SystemClock.elapsedRealtime();
      if (app.fgInteractionTime == 0) {
        app.fgInteractionTime=now;
        isInteraction=false;
      }
 else {
        isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
      }
    }
 else {
      isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.fgInteractionTime=0;
    }
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}","private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
    isInteraction=true;
    app.fgInteractionTime=0;
  }
 else   if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
    final long now=SystemClock.elapsedRealtime();
    if (app.fgInteractionTime == 0) {
      app.fgInteractionTime=now;
      isInteraction=false;
    }
 else {
      isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
    }
  }
 else {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}",0.9150908416759362
194737,"void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    if (mRunningVoice == null) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
    mRunningVoice=session;
  }
}","void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    boolean wasRunningVoice=mRunningVoice != null;
    mRunningVoice=session;
    if (!wasRunningVoice) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
  }
}",0.8126649076517151
194738,"@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  return super.onHandleForceStop(intent,packages,uid,doit);
}","@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ doit);
  int userHandle=UserHandle.getUserId(uid);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  boolean hit=false;
  for (  String pkg : packages) {
    if (curInteractor != null && pkg.equals(curInteractor.getPackageName())) {
      hit=true;
      break;
    }
 else     if (curRecognizer != null && pkg.equals(curRecognizer.getPackageName())) {
      hit=true;
      break;
    }
  }
  if (hit && doit) {
synchronized (VoiceInteractionManagerService.this) {
      mSoundTriggerHelper.stopAllRecognitions();
      if (mImpl != null) {
        mImpl.shutdownLocked();
        mImpl=null;
      }
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      switchImplementationIfNeededLocked(true);
    }
  }
  return hit;
}",0.1902356902356902
194739,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  if (curRecognizer == null) {
    if (anyPackagesAppearing()) {
      curRecognizer=findAvailRecognizer(null,userHandle);
      if (curRecognizer != null) {
        setCurRecognizer(curRecognizer,userHandle);
      }
    }
    return;
  }
  if (curInteractor != null) {
    int change=isPackageDisappearing(curInteractor.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE) {
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      return;
    }
    change=isPackageAppearing(curInteractor.getPackageName());
    if (change != PACKAGE_UNCHANGED) {
      if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
        switchImplementationIfNeededLocked(true);
      }
    }
    return;
  }
  int change=isPackageDisappearing(curRecognizer.getPackageName());
  if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
    setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
  }
 else   if (isPackageModified(curRecognizer.getPackageName())) {
    setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerService.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.9432228421398096
194740,"private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.VISIBLE);
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}","private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    if (!mDozing) {
      mKeyguardBottomArea.setVisibility(View.VISIBLE);
    }
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}",0.9833531510107016
194741,"private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}","private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}",0.983739837398374
194742,"private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.VISIBLE);
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}","private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    if (!mDozing) {
      mKeyguardBottomArea.setVisibility(View.VISIBLE);
    }
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}",0.9833531510107016
194743,"private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}","private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}",0.983739837398374
194744,"private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.VISIBLE);
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}","private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    if (!mDozing) {
      mKeyguardBottomArea.setVisibility(View.VISIBLE);
    }
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}",0.9833531510107016
194745,"private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}","private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}",0.983739837398374
194746,"private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.VISIBLE);
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}","private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    if (!mDozing) {
      mKeyguardBottomArea.setVisibility(View.VISIBLE);
    }
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}",0.9833531510107016
194747,"private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}","private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}",0.983739837398374
194748,"private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.VISIBLE);
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}","private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    if (!mDozing) {
      mKeyguardBottomArea.setVisibility(View.VISIBLE);
    }
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}",0.9833531510107016
194749,"private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}","private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}",0.983739837398374
194750,"private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.VISIBLE);
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}","private void setKeyguardBottomAreaVisibility(int statusBarState,boolean goingToFullShade){
  if (goingToFullShade) {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay()).setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).setInterpolator(PhoneStatusBar.ALPHA_OUT).withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
  }
 else   if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
    mKeyguardBottomArea.animate().cancel();
    if (!mDozing) {
      mKeyguardBottomArea.setVisibility(View.VISIBLE);
    }
    mKeyguardBottomArea.setAlpha(1f);
  }
 else {
    mKeyguardBottomArea.animate().cancel();
    mKeyguardBottomArea.setVisibility(View.GONE);
    mKeyguardBottomArea.setAlpha(1f);
  }
}",0.9833531510107016
194751,"private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}","private void updateHeaderKeyguard(){
  float alphaQsExpansion=1 - Math.min(1,getQsExpansionFraction() * 2);
  mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(),alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
  mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
  setQsTranslation(mQsExpansionHeight);
}",0.983739837398374
194752,"private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (!mSleeping) {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
 else {
    if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
      isInteraction=true;
      app.fgInteractionTime=0;
    }
 else     if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
      final long now=SystemClock.elapsedRealtime();
      if (app.fgInteractionTime == 0) {
        app.fgInteractionTime=now;
        isInteraction=false;
      }
 else {
        isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
      }
    }
 else {
      isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.fgInteractionTime=0;
    }
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}","private void maybeUpdateUsageStatsLocked(ProcessRecord app){
  if (DEBUG_USAGE_STATS) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(app.getPackageList()) + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState);
  }
  if (mUsageStatsService == null) {
    return;
  }
  boolean isInteraction;
  if (app.curProcState <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) {
    isInteraction=true;
    app.fgInteractionTime=0;
  }
 else   if (app.curProcState <= ActivityManager.PROCESS_STATE_TOP_SLEEPING) {
    final long now=SystemClock.elapsedRealtime();
    if (app.fgInteractionTime == 0) {
      app.fgInteractionTime=now;
      isInteraction=false;
    }
 else {
      isInteraction=now > app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME;
    }
  }
 else {
    isInteraction=app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    app.fgInteractionTime=0;
  }
  if (isInteraction && !app.reportedInteraction) {
    String[] packages=app.getPackageList();
    if (packages != null) {
      for (int i=0; i < packages.length; i++) {
        mUsageStatsService.reportEvent(packages[i],app.userId,UsageEvents.Event.SYSTEM_INTERACTION);
      }
    }
  }
  app.reportedInteraction=isInteraction;
}",0.9150908416759362
194753,"void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    if (mRunningVoice == null) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
    mRunningVoice=session;
  }
}","void startRunningVoiceLocked(IVoiceInteractionSession session,int targetUid){
  mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
  if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
    boolean wasRunningVoice=mRunningVoice != null;
    mRunningVoice=session;
    if (!wasRunningVoice) {
      mVoiceWakeLock.acquire();
      updateSleepIfNeededLocked();
    }
  }
}",0.8126649076517151
194754,"@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  return super.onHandleForceStop(intent,packages,uid,doit);
}","@Override public boolean onHandleForceStop(Intent intent,String[] packages,int uid,boolean doit){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ doit);
  int userHandle=UserHandle.getUserId(uid);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  boolean hit=false;
  for (  String pkg : packages) {
    if (curInteractor != null && pkg.equals(curInteractor.getPackageName())) {
      hit=true;
      break;
    }
 else     if (curRecognizer != null && pkg.equals(curRecognizer.getPackageName())) {
      hit=true;
      break;
    }
  }
  if (hit && doit) {
synchronized (VoiceInteractionManagerService.this) {
      mSoundTriggerHelper.stopAllRecognitions();
      if (mImpl != null) {
        mImpl.shutdownLocked();
        mImpl=null;
      }
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      switchImplementationIfNeededLocked(true);
    }
  }
  return hit;
}",0.1902356902356902
194755,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
  ComponentName curInteractor=getCurInteractor(userHandle);
  ComponentName curRecognizer=getCurRecognizer(userHandle);
  if (curRecognizer == null) {
    if (anyPackagesAppearing()) {
      curRecognizer=findAvailRecognizer(null,userHandle);
      if (curRecognizer != null) {
        setCurRecognizer(curRecognizer,userHandle);
      }
    }
    return;
  }
  if (curInteractor != null) {
    int change=isPackageDisappearing(curInteractor.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE) {
      setCurInteractor(null,userHandle);
      setCurRecognizer(null,userHandle);
      initForUser(userHandle);
      return;
    }
    change=isPackageAppearing(curInteractor.getPackageName());
    if (change != PACKAGE_UNCHANGED) {
      if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
        switchImplementationIfNeededLocked(true);
      }
    }
    return;
  }
  int change=isPackageDisappearing(curRecognizer.getPackageName());
  if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
    setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
  }
 else   if (isPackageModified(curRecognizer.getPackageName())) {
    setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerService.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.9432228421398096
194756,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Surface[] surfaces=(Surface[])outputSurfaces.toArray();
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(surfaces[0])) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(surfaces[0]);
    doubleTargetRequestBuilder.addTarget(surfaces[1]);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=surfaces[0];
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=surfaces[1];
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(surfaces[0]);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9277789407577978
194757,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Surface[] surfaces=(Surface[])outputSurfaces.toArray();
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(surfaces[0])) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(surfaces[0]);
    doubleTargetRequestBuilder.addTarget(surfaces[1]);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=surfaces[0];
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=surfaces[1];
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(surfaces[0]);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9277789407577978
194758,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Surface[] surfaces=(Surface[])outputSurfaces.toArray();
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(surfaces[0])) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(surfaces[0]);
    doubleTargetRequestBuilder.addTarget(surfaces[1]);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=surfaces[0];
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=surfaces[1];
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(surfaces[0]);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9277789407577978
194759,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Surface[] surfaces=(Surface[])outputSurfaces.toArray();
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(surfaces[0])) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(surfaces[0]);
    doubleTargetRequestBuilder.addTarget(surfaces[1]);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=surfaces[0];
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=surfaces[1];
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(surfaces[0]);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9277789407577978
194760,"public DismissViewButton(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mAnimatedDismissDrawable=(AnimatedVectorDrawable)getContext().getResources().getDrawable(R.drawable.dismiss_all_shape_animation).mutate();
  mAnimatedDismissDrawable.setCallback(this);
  mAnimatedDismissDrawable.setBounds(0,0,mAnimatedDismissDrawable.getIntrinsicWidth(),mAnimatedDismissDrawable.getIntrinsicHeight());
  mStaticDismissDrawable=getContext().getResources().getDrawable(R.drawable.dismiss_all_shape);
  mStaticDismissDrawable.setBounds(0,0,mStaticDismissDrawable.getIntrinsicWidth(),mStaticDismissDrawable.getIntrinsicHeight());
  mStaticDismissDrawable.setCallback(this);
  mActiveDrawable=mStaticDismissDrawable;
}","public DismissViewButton(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mAnimatedDismissDrawable=(AnimatedVectorDrawable)getContext().getDrawable(R.drawable.dismiss_all_shape_animation).mutate();
  mAnimatedDismissDrawable.setCallback(this);
  mAnimatedDismissDrawable.setBounds(0,0,mAnimatedDismissDrawable.getIntrinsicWidth(),mAnimatedDismissDrawable.getIntrinsicHeight());
  mStaticDismissDrawable=getContext().getDrawable(R.drawable.dismiss_all_shape);
  mStaticDismissDrawable.setBounds(0,0,mStaticDismissDrawable.getIntrinsicWidth(),mStaticDismissDrawable.getIntrinsicHeight());
  mStaticDismissDrawable.setCallback(this);
  mActiveDrawable=mStaticDismissDrawable;
}",0.4007884362680683
194761,"@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Surface[] surfaces=(Surface[])outputSurfaces.toArray();
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(surfaces[0])) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(surfaces[0]);
    doubleTargetRequestBuilder.addTarget(surfaces[1]);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=surfaces[0];
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=surfaces[1];
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(surfaces[0]);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}","@Override public List<CaptureRequest> createConstrainedHighSpeedRequestList(CaptureRequest request) throws CameraAccessException {
  if (request == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Collection<Surface> outputSurfaces=request.getTargets();
  Range<Integer> fpsRange=request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
  checkConstrainedHighSpeedSurfaces(outputSurfaces,fpsRange);
  int requestListSize=fpsRange.getUpper() / 30;
  List<CaptureRequest> requestList=new ArrayList<CaptureRequest>();
  CameraMetadataNative requestMetadata=new CameraMetadataNative(request.getNativeCopy());
  CaptureRequest.Builder singleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
  Iterator<Surface> iterator=outputSurfaces.iterator();
  Surface firstSurface=iterator.next();
  Surface secondSurface=null;
  if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
  }
 else {
    singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
  }
  singleTargetRequestBuilder.setPartOfCHSRequestList(true);
  CaptureRequest.Builder doubleTargetRequestBuilder=null;
  if (outputSurfaces.size() == 2) {
    doubleTargetRequestBuilder=new CaptureRequest.Builder(requestMetadata,false,CameraCaptureSession.SESSION_ID_NONE);
    doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT,CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    doubleTargetRequestBuilder.addTarget(firstSurface);
    secondSurface=iterator.next();
    doubleTargetRequestBuilder.addTarget(secondSurface);
    doubleTargetRequestBuilder.setPartOfCHSRequestList(true);
    Surface recordingSurface=firstSurface;
    if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
      recordingSurface=secondSurface;
    }
    singleTargetRequestBuilder.addTarget(recordingSurface);
  }
 else {
    singleTargetRequestBuilder.addTarget(firstSurface);
  }
  for (int i=0; i < requestListSize; i++) {
    if (i == 0 && doubleTargetRequestBuilder != null) {
      requestList.add(doubleTargetRequestBuilder.build());
    }
 else {
      requestList.add(singleTargetRequestBuilder.build());
    }
  }
  return Collections.unmodifiableList(requestList);
}",0.9277789407577978
194762,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 > when2) {
    return 1;
  }
  if (when1 < when2) {
    return -1;
  }
  return 0;
}",0.9695431472081218
194763,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 > when2) {
    return 1;
  }
  if (when1 < when2) {
    return -1;
  }
  return 0;
}",0.9695431472081218
194764,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 > when2) {
    return 1;
  }
  if (when1 < when2) {
    return -1;
  }
  return 0;
}",0.9695431472081218
194765,"/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link Build.VERSION.SDK_INT} is greater than {@link VERSION_CODES.LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}","/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link android.os.Build.VERSION#SDK_INT} is greater than{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}",0.9633671083398284
194766,"/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link Build.VERSION.SDK_INT} is greater than {@link VERSION_CODES.LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}","/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link android.os.Build.VERSION#SDK_INT} is greater than{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}",0.9633671083398284
194767,"/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link Build.VERSION.SDK_INT} is greater than {@link VERSION_CODES.LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}","/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link android.os.Build.VERSION#SDK_INT} is greater than{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}",0.9633671083398284
194768,"/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link Build.VERSION.SDK_INT} is greater than {@link VERSION_CODES.LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}","/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link android.os.Build.VERSION#SDK_INT} is greater than{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}",0.9633671083398284
194769,"/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link Build.VERSION.SDK_INT} is greater than {@link VERSION_CODES.LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}","/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link android.os.Build.VERSION#SDK_INT} is greater than{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}",0.9633671083398284
194770,"/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link Build.VERSION.SDK_INT} is greater than {@link VERSION_CODES.LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}","/** 
 * Changes the pressed state of the key. <p>Toggled state of the key will be flipped when all the following conditions are fulfilled:</p> <ul> <li>This is a sticky key, that is,   {@link #sticky} is {@code true}. <li>The parameter   {@code inside} is {@code true}. <li>  {@link android.os.Build.VERSION#SDK_INT} is greater than{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}. </ul>
 * @param inside whether the finger was released inside the key. Works only on Android M andlater. See the method document for details.
 * @see #onPressed()
 */
public void onReleased(boolean inside){
  pressed=!pressed;
  if (sticky && inside) {
    on=!on;
  }
}",0.9633671083398284
194771,"/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    return fd;
  }
}","/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    mClosed=true;
    mGuard.close();
    releaseResources();
    return fd;
  }
}",0.9552669552669552
194772,"/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    return fd;
  }
}","/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    mClosed=true;
    mGuard.close();
    releaseResources();
    return fd;
  }
}",0.9552669552669552
194773,"/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    return fd;
  }
}","/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    mClosed=true;
    mGuard.close();
    releaseResources();
    return fd;
  }
}",0.9552669552669552
194774,"/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    return fd;
  }
}","/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    mClosed=true;
    mGuard.close();
    releaseResources();
    return fd;
  }
}",0.9552669552669552
194775,"/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    return fd;
  }
}","/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    mClosed=true;
    mGuard.close();
    releaseResources();
    return fd;
  }
}",0.9552669552669552
194776,"/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    return fd;
  }
}","/** 
 * Return the native fd int for this ParcelFileDescriptor and detach it from the object here. You are now responsible for closing the fd in native code. <p> You should not detach when the original creator of the descriptor is expecting a reliable signal through   {@link #close()} or{@link #closeWithError(String)}.
 * @see #canDetectErrors()
 */
public int detachFd(){
  if (mWrapped != null) {
    return mWrapped.detachFd();
  }
 else {
    if (mClosed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final int fd=getFd();
    Parcel.clearFileDescriptor(mFd);
    writeCommStatusAndClose(Status.DETACHED,null);
    mClosed=true;
    mGuard.close();
    releaseResources();
    return fd;
  }
}",0.9552669552669552
194777,"public void onChildAnimationFinished(){
  requestChildrenUpdate();
  for (  Runnable runnable : mAnimationFinishedRunnables) {
    runnable.run();
  }
  mAnimationFinishedRunnables.clear();
}","public void onChildAnimationFinished(){
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
}",0.7006802721088435
194778,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
}",0.8936170212765957
194779,"public void onChildAnimationFinished(){
  requestChildrenUpdate();
  for (  Runnable runnable : mAnimationFinishedRunnables) {
    runnable.run();
  }
  mAnimationFinishedRunnables.clear();
}","public void onChildAnimationFinished(){
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
}",0.7006802721088435
194780,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
}",0.8936170212765957
194781,"public void onChildAnimationFinished(){
  requestChildrenUpdate();
  for (  Runnable runnable : mAnimationFinishedRunnables) {
    runnable.run();
  }
  mAnimationFinishedRunnables.clear();
}","public void onChildAnimationFinished(){
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
}",0.7006802721088435
194782,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
}",0.8936170212765957
194783,"public void onChildAnimationFinished(){
  requestChildrenUpdate();
  for (  Runnable runnable : mAnimationFinishedRunnables) {
    runnable.run();
  }
  mAnimationFinishedRunnables.clear();
}","public void onChildAnimationFinished(){
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
}",0.7006802721088435
194784,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
}",0.8936170212765957
194785,"public void onChildAnimationFinished(){
  requestChildrenUpdate();
  for (  Runnable runnable : mAnimationFinishedRunnables) {
    runnable.run();
  }
  mAnimationFinishedRunnables.clear();
}","public void onChildAnimationFinished(){
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
}",0.7006802721088435
194786,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
}",0.8936170212765957
194787,"public void onChildAnimationFinished(){
  requestChildrenUpdate();
  for (  Runnable runnable : mAnimationFinishedRunnables) {
    runnable.run();
  }
  mAnimationFinishedRunnables.clear();
}","public void onChildAnimationFinished(){
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
}",0.7006802721088435
194788,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
}",0.8936170212765957
194789,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194790,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194791,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194792,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194793,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194794,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194795,"private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : getDisplayId();
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}","private ContextImpl(ContextImpl container,ActivityThread mainThread,LoadedApk packageInfo,IBinder activityToken,UserHandle user,boolean restricted,Display display,Configuration overrideConfiguration,int createDisplayWithId){
  mOuterContext=this;
  mMainThread=mainThread;
  mActivityToken=activityToken;
  mRestricted=restricted;
  if (user == null) {
    user=Process.myUserHandle();
  }
  mUser=user;
  mPackageInfo=packageInfo;
  mResourcesManager=ResourcesManager.getInstance();
  final int displayId=(createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
  CompatibilityInfo compatInfo=null;
  if (container != null) {
    compatInfo=container.getDisplayAdjustments(displayId).getCompatibilityInfo();
  }
  if (compatInfo == null) {
    compatInfo=(displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
  }
  mDisplayAdjustments.setCompatibilityInfo(compatInfo);
  mDisplayAdjustments.setConfiguration(overrideConfiguration);
  mDisplay=(createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId,mDisplayAdjustments);
  Resources resources=packageInfo.getResources(mainThread);
  if (resources != null) {
    if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null && compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) {
      resources=mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(),packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles,displayId,overrideConfiguration,compatInfo);
    }
  }
  mResources=resources;
  if (container != null) {
    mBasePackageName=container.mBasePackageName;
    mOpPackageName=container.mOpPackageName;
  }
 else {
    mBasePackageName=packageInfo.mPackageName;
    ApplicationInfo ainfo=packageInfo.getApplicationInfo();
    if (ainfo.uid == Process.SYSTEM_UID && ainfo.uid != Process.myUid()) {
      mOpPackageName=ActivityThread.currentPackageName();
    }
 else {
      mOpPackageName=mBasePackageName;
    }
  }
  mContentResolver=new ApplicationContentResolver(this,mainThread,user);
}",0.9819462791721708
194796,"private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStats(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}","private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStatsLocked(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}",0.9995366079703428
194797,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9993216506500848
194798,"public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}","public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}",0.970309152127334
194799,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (reportedInteraction || fgInteractionTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(reportedInteraction);
    if (fgInteractionTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(fgInteractionTime,SystemClock.elapsedRealtime(),pw);
    }
    pw.println();
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}",0.9831489713635894
194800,"private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStats(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}","private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStatsLocked(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}",0.9995366079703428
194801,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9993216506500848
194802,"public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}","public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}",0.970309152127334
194803,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (reportedInteraction || fgInteractionTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(reportedInteraction);
    if (fgInteractionTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(fgInteractionTime,SystemClock.elapsedRealtime(),pw);
    }
    pw.println();
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}",0.9831489713635894
194804,"private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStats(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}","private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStatsLocked(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}",0.9995366079703428
194805,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9993216506500848
194806,"public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}","public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}",0.970309152127334
194807,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (reportedInteraction || fgInteractionTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(reportedInteraction);
    if (fgInteractionTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(fgInteractionTime,SystemClock.elapsedRealtime(),pw);
    }
    pw.println();
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}",0.9831489713635894
194808,"private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStats(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}","private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStatsLocked(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}",0.9995366079703428
194809,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9993216506500848
194810,"public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}","public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}",0.970309152127334
194811,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (reportedInteraction || fgInteractionTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(reportedInteraction);
    if (fgInteractionTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(fgInteractionTime,SystemClock.elapsedRealtime(),pw);
    }
    pw.println();
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}",0.9831489713635894
194812,"private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStats(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}","private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStatsLocked(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}",0.9995366079703428
194813,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9993216506500848
194814,"public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}","public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}",0.970309152127334
194815,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (reportedInteraction || fgInteractionTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(reportedInteraction);
    if (fgInteractionTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(fgInteractionTime,SystemClock.elapsedRealtime(),pw);
    }
    pw.println();
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}",0.9831489713635894
194816,"@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  final Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}","@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}",0.998217468805704
194817,"@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  final Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}","@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}",0.998217468805704
194818,"@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  final Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}","@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}",0.998217468805704
194819,"@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  final Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}","@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}",0.998217468805704
194820,"@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  final Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}","@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}",0.998217468805704
194821,"@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  final Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}","@Override public void addOnSubscriptionsChangedListener(String callingPackage,IOnSubscriptionsChangedListener callback){
  int callerUserId=UserHandle.getCallingUserId();
  if (VDBG) {
    log(""String_Node_Str"" + callingPackage + ""String_Node_Str""+ UserHandle.myUserId()+ ""String_Node_Str""+ callerUserId+ ""String_Node_Str""+ callback+ ""String_Node_Str""+ callback.asBinder());
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,null);
  if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE,Binder.getCallingUid(),callingPackage) != AppOpsManager.MODE_ALLOWED) {
    return;
  }
  Record r;
synchronized (mRecords) {
    find_and_add: {
      IBinder b=callback.asBinder();
      final int N=mRecords.size();
      for (int i=0; i < N; i++) {
        r=mRecords.get(i);
        if (b == r.binder) {
          break find_and_add;
        }
      }
      r=new Record();
      r.binder=b;
      mRecords.add(r);
      if (DBG)       log(""String_Node_Str"");
    }
    r.onSubscriptionsChangedListenerCallback=callback;
    r.callingPackage=callingPackage;
    r.callerUserId=callerUserId;
    r.events=0;
    r.canReadPhoneState=true;
    if (DBG) {
      log(""String_Node_Str"" + r);
    }
    if (hasNotifySubscriptionInfoChangedOccurred) {
      try {
        if (VDBG)         log(""String_Node_Str"" + r);
        r.onSubscriptionsChangedListenerCallback.onSubscriptionsChanged();
        if (VDBG)         log(""String_Node_Str"" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log(""String_Node_Str"" + r + ""String_Node_Str""+ e);
        remove(r.binder);
      }
    }
 else {
      log(""String_Node_Str"");
    }
  }
}",0.998217468805704
194822,"private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStats(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}","private final boolean applyOomAdjLocked(ProcessRecord app,boolean doingAll,long now){
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.processName+ ""String_Node_Str""+ app.curAdj+ ""String_Node_Str""+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + app.pid + ""String_Node_Str""+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,""String_Node_Str"" + app.repProcState + ""String_Node_Str""+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
      long start=SystemClock.uptimeMillis();
      long pss=Debug.getPss(app.pid,mTmpLong,null);
      recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],now);
      mPendingPssProcesses.remove(app);
      Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.setProcState+ ""String_Node_Str""+ app.curProcState+ ""String_Node_Str""+ (SystemClock.uptimeMillis() - start)+ ""String_Node_Str"");
    }
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + ProcessList.makeProcStateString(app.setProcState) + ""String_Node_Str""+ ProcessList.makeProcStateString(app.curProcState)+ ""String_Node_Str""+ (app.nextPssTime - now)+ ""String_Node_Str""+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS)     Slog.d(TAG_PSS,""String_Node_Str"" + app + ""String_Node_Str""+ (app.nextPssTime - now));
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.curProcState);
    boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
    boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
    if (setImportant && !curImportant) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    maybeUpdateUsageStatsLocked(app);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + app + ""String_Node_Str""+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"");
        mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG_PROCESS_OBSERVERS,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(item)) + ""String_Node_Str""+ app.toShortString()+ ""String_Node_Str""+ item.changes+ ""String_Node_Str""+ item.processState+ ""String_Node_Str""+ item.foregroundActivities+ ""String_Node_Str""+ app.adjType+ ""String_Node_Str""+ app.adjSource+ ""String_Node_Str""+ app.adjTarget);
  }
  return success;
}",0.9995366079703428
194823,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str""+ r.app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_TOP) {
          procState=PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9993216506500848
194824,"public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}","public static String makeProcStateString(int curProcState){
  String procState;
switch (curProcState) {
case -1:
    procState=""String_Node_Str"";
  break;
case ActivityManager.PROCESS_STATE_PERSISTENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_PERSISTENT_UI:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_TOP_SLEEPING:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_BACKUP:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HEAVY_WEIGHT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_SERVICE:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_RECEIVER:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_HOME:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_LAST_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
procState=""String_Node_Str"";
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
procState=""String_Node_Str"";
break;
default :
procState=""String_Node_Str"";
break;
}
return procState;
}",0.970309152127334
194825,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(userId);
  pw.print(""String_Node_Str"");
  pw.print(info.uid);
  if (uid != info.uid) {
    pw.print(""String_Node_Str"");
    pw.print(uid);
  }
  pw.print(""String_Node_Str"");
  if (gids != null) {
    for (int gi=0; gi < gids.length; gi++) {
      if (gi != 0)       pw.print(""String_Node_Str"");
      pw.print(gids[gi]);
    }
  }
  pw.println(""String_Node_Str"");
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(requiredAbi);
  pw.print(""String_Node_Str"");
  pw.println(instructionSet);
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  for (int i=0; i < pkgList.size(); i++) {
    if (i > 0)     pw.print(""String_Node_Str"");
    pw.print(pkgList.keyAt(i));
  }
  pw.println(""String_Node_Str"");
  if (pkgDeps != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    for (int i=0; i < pkgDeps.size(); i++) {
      if (i > 0)       pw.print(""String_Node_Str"");
      pw.print(pkgDeps.valueAt(i));
    }
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(compat);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(thread);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.println(starting);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastPssTime,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(nextPssTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.print(lruSeq);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastPss * 1024);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,lastCachedPss * 1024);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(cached);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  if (serviceb) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(serviceb);
    pw.print(""String_Node_Str"");
    pw.println(serviceHighRam);
  }
  if (notCachedSinceIdle) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(notCachedSinceIdle);
    pw.print(""String_Node_Str"");
    pw.println(initialIdlePss);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(setSchedGroup);
  pw.print(""String_Node_Str"");
  pw.print(systemNoUi);
  pw.print(""String_Node_Str"");
  pw.println(trimMemoryLevel);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curProcState);
  pw.print(""String_Node_Str"");
  pw.print(repProcState);
  pw.print(""String_Node_Str"");
  pw.print(pssProcState);
  pw.print(""String_Node_Str"");
  pw.print(setProcState);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastStateTime,now,pw);
  pw.println();
  if (hasShownUi || pendingUiClean || hasAboveClient|| treatLikeActivity) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasShownUi);
    pw.print(""String_Node_Str"");
    pw.print(pendingUiClean);
    pw.print(""String_Node_Str"");
    pw.print(hasAboveClient);
    pw.print(""String_Node_Str"");
    pw.println(treatLikeActivity);
  }
  if (setIsForeground || foregroundServices || forcingToForeground != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(setIsForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundServices);
    pw.print(""String_Node_Str"");
    pw.println(forcingToForeground);
  }
  if (reportedInteraction || fgInteractionTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(reportedInteraction);
    if (fgInteractionTime != 0) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(fgInteractionTime,SystemClock.elapsedRealtime(),pw);
    }
    pw.println();
  }
  if (persistent || removed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(persistent);
    pw.print(""String_Node_Str"");
    pw.println(removed);
  }
  if (hasClientActivities || foregroundActivities || repForegroundActivities) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(hasClientActivities);
    pw.print(""String_Node_Str"");
    pw.print(foregroundActivities);
    pw.print(""String_Node_Str"");
    pw.print(repForegroundActivities);
    pw.println(""String_Node_Str"");
  }
  if (hasStartedServices) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(hasStartedServices);
  }
  if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
    long wtime;
synchronized (mBatteryStats) {
      wtime=mBatteryStats.getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(wtime - lastWakeTime,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killed || killedByAm || waitingToKill != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(killed);
    pw.print(""String_Node_Str"");
    pw.print(killedByAm);
    pw.print(""String_Node_Str"");
    pw.println(waitingToKill);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < activities.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(activities.get(i));
    }
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < services.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(services.valueAt(i));
    }
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(execServicesFg);
    pw.println(""String_Node_Str"");
    for (int i=0; i < executingServices.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(executingServices.valueAt(i));
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < connections.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(connections.valueAt(i));
    }
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < pubProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.keyAt(i));
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(pubProviders.valueAt(i));
    }
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < conProviders.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(conProviders.get(i).toShortString());
    }
  }
  if (curReceiver != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(curReceiver);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < receivers.size(); i++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(receivers.valueAt(i));
    }
  }
}",0.9831489713635894
194826,"protected boolean shouldInterrupt(StatusBarNotification sbn){
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}","protected boolean shouldInterrupt(Entry entry){
  StatusBarNotification sbn=entry.notification;
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean justLaunchedFullScreenIntent=entry.hasJustLaunchedFullScreenIntent();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& !justLaunchedFullScreenIntent&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}",0.9524714828897338
194827,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(notification);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(entry);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.9957658779576588
194828,"/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  if (row != null) {
    row.reset();
  }
}","/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  lastFullScreenIntentLaunchTime=NOT_LAUNCHED_YET;
  if (row != null) {
    row.reset();
  }
}",0.8617886178861789
194829,"@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(notification);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}","@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(shadeEntry);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
      shadeEntry.notifyFullScreenIntentLaunched();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}",0.9612732095490716
194830,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.961864406779661
194831,"protected boolean shouldInterrupt(StatusBarNotification sbn){
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}","protected boolean shouldInterrupt(Entry entry){
  StatusBarNotification sbn=entry.notification;
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean justLaunchedFullScreenIntent=entry.hasJustLaunchedFullScreenIntent();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& !justLaunchedFullScreenIntent&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}",0.9524714828897338
194832,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(notification);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(entry);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.9957658779576588
194833,"/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  if (row != null) {
    row.reset();
  }
}","/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  lastFullScreenIntentLaunchTime=NOT_LAUNCHED_YET;
  if (row != null) {
    row.reset();
  }
}",0.8617886178861789
194834,"@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(notification);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}","@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(shadeEntry);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
      shadeEntry.notifyFullScreenIntentLaunched();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}",0.9612732095490716
194835,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.961864406779661
194836,"protected boolean shouldInterrupt(StatusBarNotification sbn){
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}","protected boolean shouldInterrupt(Entry entry){
  StatusBarNotification sbn=entry.notification;
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean justLaunchedFullScreenIntent=entry.hasJustLaunchedFullScreenIntent();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& !justLaunchedFullScreenIntent&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}",0.9524714828897338
194837,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(notification);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(entry);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.9957658779576588
194838,"/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  if (row != null) {
    row.reset();
  }
}","/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  lastFullScreenIntentLaunchTime=NOT_LAUNCHED_YET;
  if (row != null) {
    row.reset();
  }
}",0.8617886178861789
194839,"@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(notification);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}","@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(shadeEntry);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
      shadeEntry.notifyFullScreenIntentLaunched();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}",0.9612732095490716
194840,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.961864406779661
194841,"protected boolean shouldInterrupt(StatusBarNotification sbn){
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}","protected boolean shouldInterrupt(Entry entry){
  StatusBarNotification sbn=entry.notification;
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean justLaunchedFullScreenIntent=entry.hasJustLaunchedFullScreenIntent();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& !justLaunchedFullScreenIntent&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}",0.9524714828897338
194842,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(notification);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(entry);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.9957658779576588
194843,"/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  if (row != null) {
    row.reset();
  }
}","/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  lastFullScreenIntentLaunchTime=NOT_LAUNCHED_YET;
  if (row != null) {
    row.reset();
  }
}",0.8617886178861789
194844,"@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(notification);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}","@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(shadeEntry);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
      shadeEntry.notifyFullScreenIntentLaunched();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}",0.9612732095490716
194845,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.961864406779661
194846,"protected boolean shouldInterrupt(StatusBarNotification sbn){
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}","protected boolean shouldInterrupt(Entry entry){
  StatusBarNotification sbn=entry.notification;
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean justLaunchedFullScreenIntent=entry.hasJustLaunchedFullScreenIntent();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& !justLaunchedFullScreenIntent&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}",0.9524714828897338
194847,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(notification);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(entry);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.9957658779576588
194848,"/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  if (row != null) {
    row.reset();
  }
}","/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  lastFullScreenIntentLaunchTime=NOT_LAUNCHED_YET;
  if (row != null) {
    row.reset();
  }
}",0.8617886178861789
194849,"@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(notification);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}","@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(shadeEntry);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
      shadeEntry.notifyFullScreenIntentLaunched();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}",0.9612732095490716
194850,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.961864406779661
194851,"protected boolean shouldInterrupt(StatusBarNotification sbn){
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}","protected boolean shouldInterrupt(Entry entry){
  StatusBarNotification sbn=entry.notification;
  if (mNotificationData.shouldFilterOut(sbn)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sbn.getKey() + ""String_Node_Str"");
    }
    return false;
  }
  if (isSnoozedPackage(sbn)) {
    return false;
  }
  Notification notification=sbn.getNotification();
  boolean isNoisy=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
  boolean isHighPriority=sbn.getScore() >= INTERRUPTION_THRESHOLD;
  boolean isFullscreen=notification.fullScreenIntent != null;
  boolean hasTicker=mHeadsUpTicker && !TextUtils.isEmpty(notification.tickerText);
  boolean isAllowed=notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP,Notification.HEADS_UP_ALLOWED) != Notification.HEADS_UP_NEVER;
  boolean accessibilityForcesLaunch=isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
  boolean justLaunchedFullScreenIntent=entry.hasJustLaunchedFullScreenIntent();
  boolean interrupt=(isFullscreen || (isHighPriority && (isNoisy || hasTicker))) && isAllowed && !accessibilityForcesLaunch&& !justLaunchedFullScreenIntent&& mPowerManager.isScreenOn()&& (!mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded())&& !mStatusBarKeyguardViewManager.isInputRestricted();
  try {
    interrupt=interrupt && !mDreamManager.isDreaming();
  }
 catch (  RemoteException e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + interrupt);
  return interrupt;
}",0.9524714828897338
194852,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(notification);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
  Notification n=notification.getNotification();
  if (DEBUG) {
    logUpdate(entry,n);
  }
  boolean applyInPlace=shouldApplyInPlace(entry,n);
  boolean shouldInterrupt=shouldInterrupt(entry);
  boolean alertAgain=alertAgain(entry,n);
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,entry.notification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + n.contentView.getPackage(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldInterrupt,alertAgain);
  mNotificationData.updateRanking(ranking);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.9957658779576588
194853,"/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  if (row != null) {
    row.reset();
  }
}","/** 
 * Resets the notification entry to be re-used.
 */
public void reset(){
  autoRedacted=false;
  legacy=false;
  lastFullScreenIntentLaunchTime=NOT_LAUNCHED_YET;
  if (row != null) {
    row.reset();
  }
}",0.8617886178861789
194854,"@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(notification);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}","@Override public void addNotification(StatusBarNotification notification,RankingMap ranking,Entry oldEntry){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification.getKey());
  Entry shadeEntry=createNotificationViews(notification);
  if (shadeEntry == null) {
    return;
  }
  boolean isHeadsUped=mUseHeadsUp && shouldInterrupt(shadeEntry);
  if (isHeadsUped) {
    mHeadsUpManager.showNotification(shadeEntry);
    setNotificationShown(notification);
  }
  if (!isHeadsUped && notification.getNotification().fullScreenIntent != null) {
    awakenDreams();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION,notification.getKey());
      notification.getNotification().fullScreenIntent.send();
      shadeEntry.notifyFullScreenIntentLaunched();
    }
 catch (    PendingIntent.CanceledException e) {
    }
  }
  addNotificationViews(shadeEntry,ranking);
  setAreThereNotifications();
}",0.9612732095490716
194855,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.961864406779661
194856,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 > when2) {
    return 1;
  }
  if (when1 < when2) {
    return -1;
  }
  return 0;
}",0.9695431472081218
194857,"/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int suggestedWidth){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=getAdjustedToolbarWidth(mContext,suggestedWidth) - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}","/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int width){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=width - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}",0.9860990443092964
194858,"/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2));
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}","/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  refreshViewPort();
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2) - mViewPort.top);
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}",0.9764780673871584
194859,"/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}","/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshViewPort();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}",0.9802816901408452
194860,"private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top > getHeight()) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top > getToolbarHeightWithVerticalMargin()) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}","private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top - getHeight() > mViewPort.top) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top - getToolbarHeightWithVerticalMargin() > mViewPort.top) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  x=Math.max(0,Math.min(x,mViewPort.right - getWidth()));
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}",0.8786666666666667
194861,"/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int suggestedWidth){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=getAdjustedToolbarWidth(mContext,suggestedWidth) - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}","/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int width){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=width - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}",0.9860990443092964
194862,"/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2));
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}","/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  refreshViewPort();
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2) - mViewPort.top);
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}",0.9764780673871584
194863,"/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}","/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshViewPort();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}",0.9802816901408452
194864,"private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top > getHeight()) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top > getToolbarHeightWithVerticalMargin()) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}","private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top - getHeight() > mViewPort.top) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top - getToolbarHeightWithVerticalMargin() > mViewPort.top) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  x=Math.max(0,Math.min(x,mViewPort.right - getWidth()));
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}",0.8786666666666667
194865,"/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int suggestedWidth){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=getAdjustedToolbarWidth(mContext,suggestedWidth) - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}","/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int width){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=width - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}",0.9860990443092964
194866,"/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2));
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}","/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  refreshViewPort();
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2) - mViewPort.top);
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}",0.9764780673871584
194867,"/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}","/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshViewPort();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}",0.9802816901408452
194868,"private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top > getHeight()) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top > getToolbarHeightWithVerticalMargin()) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}","private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top - getHeight() > mViewPort.top) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top - getToolbarHeightWithVerticalMargin() > mViewPort.top) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  x=Math.max(0,Math.min(x,mViewPort.right - getWidth()));
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}",0.8786666666666667
194869,"/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int suggestedWidth){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=getAdjustedToolbarWidth(mContext,suggestedWidth) - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}","/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int width){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=width - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}",0.9860990443092964
194870,"/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2));
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}","/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  refreshViewPort();
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2) - mViewPort.top);
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}",0.9764780673871584
194871,"/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}","/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshViewPort();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}",0.9802816901408452
194872,"private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top > getHeight()) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top > getToolbarHeightWithVerticalMargin()) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}","private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top - getHeight() > mViewPort.top) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top - getToolbarHeightWithVerticalMargin() > mViewPort.top) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  x=Math.max(0,Math.min(x,mViewPort.right - getWidth()));
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}",0.8786666666666667
194873,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
switch (intent.getAction()) {
case CONFIG_SERVICE_INTERFACE:
case BIND_SERVICE_INTERFACE:
    return mStubWrapper;
default :
  return null;
}
}",0.5103448275862069
194874,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
  if (!CONFIG_SERVICE_INTERFACE.equals(intent.getAction()) || !BIND_SERVICE_INTERFACE.equals(intent.getAction())) {
    return null;
  }
  return mStubWrapper;
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}",0.4805194805194805
194875,"/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int suggestedWidth){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=getAdjustedToolbarWidth(mContext,suggestedWidth) - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}","/** 
 * Fits as many menu items in the main panel and returns a list of the menu items that were not fit in.
 * @return The menu items that are not included in this main panel.
 */
public List<MenuItem> layoutMenuItems(List<MenuItem> menuItems,int width){
  Preconditions.checkNotNull(menuItems);
  final int toolbarWidth=width - getEstimatedOpenOverflowButtonWidth(mContext);
  int availableWidth=toolbarWidth;
  final LinkedList<MenuItem> remainingMenuItems=new LinkedList<MenuItem>(menuItems);
  mContentView.removeAllViews();
  boolean isFirstItem=true;
  while (!remainingMenuItems.isEmpty()) {
    final MenuItem menuItem=remainingMenuItems.peek();
    View menuItemButton=createMenuItemButton(mContext,menuItem);
    if (isFirstItem) {
      menuItemButton.setPaddingRelative((int)(1.5 * menuItemButton.getPaddingStart()),menuItemButton.getPaddingTop(),menuItemButton.getPaddingEnd(),menuItemButton.getPaddingBottom());
      isFirstItem=false;
    }
    if (remainingMenuItems.size() == 1) {
      menuItemButton.setPaddingRelative(menuItemButton.getPaddingStart(),menuItemButton.getPaddingTop(),(int)(1.5 * menuItemButton.getPaddingEnd()),menuItemButton.getPaddingBottom());
    }
    menuItemButton.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);
    int menuItemButtonWidth=Math.min(menuItemButton.getMeasuredWidth(),toolbarWidth);
    if (menuItemButtonWidth <= availableWidth) {
      setButtonTagAndClickListener(menuItemButton,menuItem);
      mContentView.addView(menuItemButton);
      ViewGroup.LayoutParams params=menuItemButton.getLayoutParams();
      params.width=menuItemButtonWidth;
      menuItemButton.setLayoutParams(params);
      availableWidth-=menuItemButtonWidth;
      remainingMenuItems.pop();
    }
 else {
      if (mOpenOverflowButton == null) {
        mOpenOverflowButton=LayoutInflater.from(mContext).inflate(R.layout.floating_popup_open_overflow_button,null);
        mOpenOverflowButton.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            if (mOpenOverflowButton != null) {
              mOpenOverflow.run();
            }
          }
        }
);
      }
      mContentView.addView(mOpenOverflowButton);
      break;
    }
  }
  return remainingMenuItems;
}",0.9860990443092964
194876,"/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2));
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}","/** 
 * Shows this popup at the specified coordinates. The specified coordinates may be adjusted to make sure the popup is entirely on-screen.
 */
public void show(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (isShowing()) {
    return;
  }
  mHidden=false;
  mDismissed=false;
  cancelDismissAndHideAnimations();
  cancelOverflowAnimations();
  if (mContentContainer.getChildCount() == 0) {
    setMainPanelAsContent();
    mContentContainer.setAlpha(0);
  }
  refreshViewPort();
  updateOverflowHeight(contentRect.top - (mMarginVertical * 2) - mViewPort.top);
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.showAtLocation(mParent,Gravity.NO_GRAVITY,mCoords.x,mCoords.y);
  setTouchableSurfaceInsetsComputer();
  runShowAnimation();
}",0.9764780673871584
194877,"/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}","/** 
 * Updates the coordinates of this popup. The specified coordinates may be adjusted to make sure the popup is entirely on-screen. This is a no-op if this popup is not showing.
 */
public void updateCoordinates(Rect contentRect){
  Preconditions.checkNotNull(contentRect);
  if (!isShowing() || !mPopupWindow.isShowing()) {
    return;
  }
  cancelOverflowAnimations();
  refreshViewPort();
  refreshCoordinatesAndOverflowDirection(contentRect);
  preparePopupContent();
  mPopupWindow.update(mCoords.x,mCoords.y,getWidth(),getHeight());
}",0.9802816901408452
194878,"private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top > getHeight()) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top > getToolbarHeightWithVerticalMargin()) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}","private void refreshCoordinatesAndOverflowDirection(Rect contentRect){
  int x=contentRect.centerX() - getWidth() / 2;
  int y;
  if (contentRect.top - getHeight() > mViewPort.top) {
    y=contentRect.top - getHeight();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_UP;
  }
 else   if (contentRect.top - getToolbarHeightWithVerticalMargin() > mViewPort.top) {
    y=contentRect.top - getToolbarHeightWithVerticalMargin();
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
 else {
    y=contentRect.bottom;
    mOverflowDirection=FloatingToolbarPopup.OVERFLOW_DIRECTION_DOWN;
  }
  x=Math.max(0,Math.min(x,mViewPort.right - getWidth()));
  mCoords.set(x,y);
  if (mOverflowPanel != null) {
    mOverflowPanel.setOverflowDirection(mOverflowDirection);
  }
}",0.8786666666666667
194879,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
  if (!CONFIG_SERVICE_INTERFACE.equals(intent.getAction()) || !BIND_SERVICE_INTERFACE.equals(intent.getAction())) {
    return null;
  }
  return mStubWrapper;
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}",0.4805194805194805
194880,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
switch (intent.getAction()) {
case CONFIG_SERVICE_INTERFACE:
case BIND_SERVICE_INTERFACE:
    return mStubWrapper;
default :
  return null;
}
}",0.5103448275862069
194881,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
switch (intent.getAction()) {
case CONFIG_SERVICE_INTERFACE:
case BIND_SERVICE_INTERFACE:
    return mStubWrapper;
default :
  return null;
}
}",0.5103448275862069
194882,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
switch (intent.getAction()) {
case CONFIG_SERVICE_INTERFACE:
case BIND_SERVICE_INTERFACE:
    return mStubWrapper;
default :
  return null;
}
}",0.5103448275862069
194883,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
  if (!CONFIG_SERVICE_INTERFACE.equals(intent.getAction()) || !BIND_SERVICE_INTERFACE.equals(intent.getAction())) {
    return null;
  }
  return mStubWrapper;
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}",0.4805194805194805
194884,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
  if (!CONFIG_SERVICE_INTERFACE.equals(intent.getAction()) || !BIND_SERVICE_INTERFACE.equals(intent.getAction())) {
    return null;
  }
  return mStubWrapper;
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}",0.4805194805194805
194885,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
switch (intent.getAction()) {
case CONFIG_SERVICE_INTERFACE:
case BIND_SERVICE_INTERFACE:
    return mStubWrapper;
default :
  return null;
}
}",0.5103448275862069
194886,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
  if (!CONFIG_SERVICE_INTERFACE.equals(intent.getAction()) || !BIND_SERVICE_INTERFACE.equals(intent.getAction())) {
    return null;
  }
  return mStubWrapper;
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}",0.4805194805194805
194887,"/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
  if (!CONFIG_SERVICE_INTERFACE.equals(intent.getAction()) || !BIND_SERVICE_INTERFACE.equals(intent.getAction())) {
    return null;
  }
  return mStubWrapper;
}","/** 
 * @hide 
 */
@Override public final IBinder onBind(Intent intent){
}",0.4805194805194805
194888,"private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
  }
}","private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
      setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
    }
  }
}",0.8732394366197183
194889,"private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
  }
}","private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
      setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
    }
  }
}",0.8732394366197183
194890,"private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
  }
}","private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
      setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
    }
  }
}",0.8732394366197183
194891,"private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
  }
}","private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
      setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
    }
  }
}",0.8732394366197183
194892,"private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
  }
}","private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
      setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
    }
  }
}",0.8732394366197183
194893,"private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
  }
}","private void processPhonebookAccess(){
  if (mDevice.getBondState() != BluetoothDevice.BOND_BONDED)   return;
  ParcelUuid[] uuids=mDevice.getUuids();
  if (BluetoothUuid.containsAnyUuid(uuids,PbapServerProfile.PBAB_CLIENT_UUIDS)) {
    if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
      setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
    }
  }
}",0.8732394366197183
194894,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194895,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194896,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194897,"/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}","/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}",0.9696969696969696
194898,"/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}","/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}",0.90481522956327
194899,"/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}","/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}",0.9696969696969696
194900,"/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}","/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}",0.90481522956327
194901,"/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}","/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}",0.9696969696969696
194902,"/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}","/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}",0.90481522956327
194903,"/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}","/** 
 * Initializes and acquires the scene, creating various Android objects such as context, inflater, and parser.
 * @param timeout the time to wait if another rendering is happening.
 * @return whether the scene was prepared
 * @see #acquire(long)
 * @see #release()
 */
public Result init(long timeout){
  Result result=acquireLock(timeout);
  if (result != null) {
    return result;
  }
  HardwareConfig hardwareConfig=mParams.getHardwareConfig();
  DisplayMetrics metrics=new DisplayMetrics();
  metrics.densityDpi=metrics.noncompatDensityDpi=hardwareConfig.getDensity().getDpiValue();
  metrics.density=metrics.noncompatDensity=metrics.densityDpi / (float)DisplayMetrics.DENSITY_DEFAULT;
  metrics.scaledDensity=metrics.noncompatScaledDensity=metrics.density;
  metrics.widthPixels=metrics.noncompatWidthPixels=hardwareConfig.getScreenWidth();
  metrics.heightPixels=metrics.noncompatHeightPixels=hardwareConfig.getScreenHeight();
  metrics.xdpi=metrics.noncompatXdpi=hardwareConfig.getXdpi();
  metrics.ydpi=metrics.noncompatYdpi=hardwareConfig.getYdpi();
  RenderResources resources=mParams.getResources();
  mContext=new BridgeContext(mParams.getProjectKey(),metrics,resources,mParams.getAssets(),mParams.getLayoutlibCallback(),getConfiguration(),mParams.getTargetSdkVersion(),mParams.isRtlSupported());
  setUp();
  return SUCCESS.createResult();
}",0.9696969696969696
194904,"/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}","/** 
 * Sets up the session for rendering. <p/> The counterpart is   {@link #tearDown()}.
 */
private void setUp(){
  ParserFactory.setParserFactory(mParams.getLayoutlibCallback().getParserFactory());
  mContext.initResources();
  sCurrentContext=mContext;
  InputMethodManager.getInstance();
  LayoutLog currentLog=mParams.getLog();
  Bridge.setLog(currentLog);
  mContext.getRenderResources().setFrameworkResourceIdProvider(this);
  mContext.getRenderResources().setLogger(currentLog);
}",0.90481522956327
194905,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194906,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the z,x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z,x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre> See   {@link #getOrientation} for more detailed definition of the output.
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change(in radians) is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.9798685291700904
194907,"/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines on which world axis and direction the X axis of the device is mapped.
 * @param Y defines on which world axis and direction the Y axis of the device is mapped.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}","/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system.
 * @param Y defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}",0.9448476052249636
194908,"/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p>The reference coordinate-system used is different from the world coordinate-system defined for the rotation matrix:</p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points West).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the center of the Earth and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe_inverted.png"" alt=""Inverted world coordinate-system diagram."" border=""0"" /></center> </p> <p> All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}","/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the -Z axis, i.e. the opposite direction of Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the -X axis, i.e the opposite direction of X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p> Applying these three intrinsic rotations in azimuth, pitch and roll order transforms identity matrix to the rotation matrix given in input R. All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction. Range of output is: azimuth from -&pi; to &pi;, pitch from -&pi;/2 to &pi;/2 and roll from -&pi; to &pi;.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}",0.7022508038585209
194909,"/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}","/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float normsqA=(Ax * Ax + Ay * Ay + Az * Az);
  final float g=9.81f;
  final float freeFallGravitySquared=0.01f * g * g;
  if (normsqA < freeFallGravitySquared) {
    return false;
  }
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}",0.9755142017629774
194910,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the z,x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z,x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre> See   {@link #getOrientation} for more detailed definition of the output.
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change(in radians) is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.9798685291700904
194911,"/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines on which world axis and direction the X axis of the device is mapped.
 * @param Y defines on which world axis and direction the Y axis of the device is mapped.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}","/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system.
 * @param Y defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}",0.9448476052249636
194912,"/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p>The reference coordinate-system used is different from the world coordinate-system defined for the rotation matrix:</p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points West).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the center of the Earth and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe_inverted.png"" alt=""Inverted world coordinate-system diagram."" border=""0"" /></center> </p> <p> All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}","/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the -Z axis, i.e. the opposite direction of Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the -X axis, i.e the opposite direction of X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p> Applying these three intrinsic rotations in azimuth, pitch and roll order transforms identity matrix to the rotation matrix given in input R. All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction. Range of output is: azimuth from -&pi; to &pi;, pitch from -&pi;/2 to &pi;/2 and roll from -&pi; to &pi;.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}",0.7022508038585209
194913,"/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}","/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float normsqA=(Ax * Ax + Ay * Ay + Az * Az);
  final float g=9.81f;
  final float freeFallGravitySquared=0.01f * g * g;
  if (normsqA < freeFallGravitySquared) {
    return false;
  }
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}",0.9755142017629774
194914,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the z,x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z,x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre> See   {@link #getOrientation} for more detailed definition of the output.
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change(in radians) is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.9798685291700904
194915,"/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines on which world axis and direction the X axis of the device is mapped.
 * @param Y defines on which world axis and direction the Y axis of the device is mapped.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}","/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system.
 * @param Y defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}",0.9448476052249636
194916,"/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p>The reference coordinate-system used is different from the world coordinate-system defined for the rotation matrix:</p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points West).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the center of the Earth and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe_inverted.png"" alt=""Inverted world coordinate-system diagram."" border=""0"" /></center> </p> <p> All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}","/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the -Z axis, i.e. the opposite direction of Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the -X axis, i.e the opposite direction of X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p> Applying these three intrinsic rotations in azimuth, pitch and roll order transforms identity matrix to the rotation matrix given in input R. All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction. Range of output is: azimuth from -&pi; to &pi;, pitch from -&pi;/2 to &pi;/2 and roll from -&pi; to &pi;.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}",0.7022508038585209
194917,"/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}","/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float normsqA=(Ax * Ax + Ay * Ay + Az * Az);
  final float g=9.81f;
  final float freeFallGravitySquared=0.01f * g * g;
  if (normsqA < freeFallGravitySquared) {
    return false;
  }
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}",0.9755142017629774
194918,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the z,x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z,x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre> See   {@link #getOrientation} for more detailed definition of the output.
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change(in radians) is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.9798685291700904
194919,"/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines on which world axis and direction the X axis of the device is mapped.
 * @param Y defines on which world axis and direction the Y axis of the device is mapped.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}","/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system.
 * @param Y defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}",0.9448476052249636
194920,"/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p>The reference coordinate-system used is different from the world coordinate-system defined for the rotation matrix:</p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points West).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the center of the Earth and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe_inverted.png"" alt=""Inverted world coordinate-system diagram."" border=""0"" /></center> </p> <p> All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}","/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the -Z axis, i.e. the opposite direction of Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the -X axis, i.e the opposite direction of X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p> Applying these three intrinsic rotations in azimuth, pitch and roll order transforms identity matrix to the rotation matrix given in input R. All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction. Range of output is: azimuth from -&pi; to &pi;, pitch from -&pi;/2 to &pi;/2 and roll from -&pi; to &pi;.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}",0.7022508038585209
194921,"/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}","/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float normsqA=(Ax * Ax + Ay * Ay + Az * Az);
  final float g=9.81f;
  final float freeFallGravitySquared=0.01f * g * g;
  if (normsqA < freeFallGravitySquared) {
    return false;
  }
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}",0.9755142017629774
194922,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the z,x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z,x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre> See   {@link #getOrientation} for more detailed definition of the output.
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change(in radians) is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.9798685291700904
194923,"/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines on which world axis and direction the X axis of the device is mapped.
 * @param Y defines on which world axis and direction the Y axis of the device is mapped.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}","/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system.
 * @param Y defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}",0.9448476052249636
194924,"/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p>The reference coordinate-system used is different from the world coordinate-system defined for the rotation matrix:</p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points West).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the center of the Earth and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe_inverted.png"" alt=""Inverted world coordinate-system diagram."" border=""0"" /></center> </p> <p> All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}","/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the -Z axis, i.e. the opposite direction of Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the -X axis, i.e the opposite direction of X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p> Applying these three intrinsic rotations in azimuth, pitch and roll order transforms identity matrix to the rotation matrix given in input R. All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction. Range of output is: azimuth from -&pi; to &pi;, pitch from -&pi;/2 to &pi;/2 and roll from -&pi; to &pi;.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}",0.7022508038585209
194925,"/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}","/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float normsqA=(Ax * Ax + Ay * Ay + Az * Az);
  final float g=9.81f;
  final float freeFallGravitySquared=0.01f * g * g;
  if (normsqA < freeFallGravitySquared) {
    return false;
  }
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}",0.9755142017629774
194926,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194927,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194928,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194929,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194930,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  Canvas c=new Canvas();
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  int overlayColor=0x40FFFFFF;
  Bitmap picture=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  matrix.setTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.setBitmap(picture);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  float scale=(float)iconSize / Math.min(mImageWidth,mImageHeight);
  Bitmap icon=Bitmap.createBitmap(iconSize,iconSize,data.image.getConfig());
  matrix.setScale(scale,scale);
  matrix.postTranslate((iconSize - (scale * mImageWidth)) / 2,(iconSize - (scale * mImageHeight)) / 2);
  c.setBitmap(icon);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(picture);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(icon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}",0.8051635111876075
194931,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  Canvas c=new Canvas();
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  int overlayColor=0x40FFFFFF;
  Bitmap picture=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  matrix.setTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.setBitmap(picture);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  float scale=(float)iconSize / Math.min(mImageWidth,mImageHeight);
  Bitmap icon=Bitmap.createBitmap(iconSize,iconSize,data.image.getConfig());
  matrix.setScale(scale,scale);
  matrix.postTranslate((iconSize - (scale * mImageWidth)) / 2,(iconSize - (scale * mImageHeight)) / 2);
  c.setBitmap(icon);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(picture);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(icon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}",0.8051635111876075
194932,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  Canvas c=new Canvas();
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  int overlayColor=0x40FFFFFF;
  Bitmap picture=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  matrix.setTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.setBitmap(picture);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  float scale=(float)iconSize / Math.min(mImageWidth,mImageHeight);
  Bitmap icon=Bitmap.createBitmap(iconSize,iconSize,data.image.getConfig());
  matrix.setScale(scale,scale);
  matrix.postTranslate((iconSize - (scale * mImageWidth)) / 2,(iconSize - (scale * mImageHeight)) / 2);
  c.setBitmap(icon);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(picture);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(icon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}",0.8051635111876075
194933,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  Canvas c=new Canvas();
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  int overlayColor=0x40FFFFFF;
  Bitmap picture=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  matrix.setTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.setBitmap(picture);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  float scale=(float)iconSize / Math.min(mImageWidth,mImageHeight);
  Bitmap icon=Bitmap.createBitmap(iconSize,iconSize,data.image.getConfig());
  matrix.setScale(scale,scale);
  matrix.postTranslate((iconSize - (scale * mImageWidth)) / 2,(iconSize - (scale * mImageHeight)) / 2);
  c.setBitmap(icon);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(picture);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(icon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}",0.8051635111876075
194934,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  Canvas c=new Canvas();
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  int overlayColor=0x40FFFFFF;
  Bitmap picture=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  matrix.setTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.setBitmap(picture);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  float scale=(float)iconSize / Math.min(mImageWidth,mImageHeight);
  Bitmap icon=Bitmap.createBitmap(iconSize,iconSize,data.image.getConfig());
  matrix.setScale(scale,scale);
  matrix.postTranslate((iconSize - (scale * mImageWidth)) / 2,(iconSize - (scale * mImageHeight)) / 2);
  c.setBitmap(icon);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(picture);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(icon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}",0.8051635111876075
194935,"SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  final int shortSide=mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
  Bitmap preview=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  Canvas c=new Canvas(preview);
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  matrix.postTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(0x40FFFFFF);
  c.setBitmap(null);
  Bitmap croppedIcon=Bitmap.createScaledBitmap(preview,iconSize,iconSize,true);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(preview);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(croppedIcon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}","SaveImageInBackgroundTask(Context context,SaveImageInBackgroundData data,NotificationManager nManager,int nId){
  Resources r=context.getResources();
  mImageTime=System.currentTimeMillis();
  String imageDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
  mImageFileName=String.format(SCREENSHOT_FILE_NAME_TEMPLATE,imageDate);
  mScreenshotDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SCREENSHOTS_DIR_NAME);
  mImageFilePath=new File(mScreenshotDir,mImageFileName).getAbsolutePath();
  mImageWidth=data.image.getWidth();
  mImageHeight=data.image.getHeight();
  int iconSize=data.iconSize;
  int previewWidth=data.previewWidth;
  int previewHeight=data.previewheight;
  Canvas c=new Canvas();
  Paint paint=new Paint();
  ColorMatrix desat=new ColorMatrix();
  desat.setSaturation(0.25f);
  paint.setColorFilter(new ColorMatrixColorFilter(desat));
  Matrix matrix=new Matrix();
  int overlayColor=0x40FFFFFF;
  Bitmap picture=Bitmap.createBitmap(previewWidth,previewHeight,data.image.getConfig());
  matrix.setTranslate((previewWidth - mImageWidth) / 2,(previewHeight - mImageHeight) / 2);
  c.setBitmap(picture);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  float scale=(float)iconSize / Math.min(mImageWidth,mImageHeight);
  Bitmap icon=Bitmap.createBitmap(iconSize,iconSize,data.image.getConfig());
  matrix.setScale(scale,scale);
  matrix.postTranslate((iconSize - (scale * mImageWidth)) / 2,(iconSize - (scale * mImageHeight)) / 2);
  c.setBitmap(icon);
  c.drawBitmap(data.image,matrix,paint);
  c.drawColor(overlayColor);
  c.setBitmap(null);
  mTickerAddSpace=!mTickerAddSpace;
  mNotificationId=nId;
  mNotificationManager=nManager;
  final long now=System.currentTimeMillis();
  mNotificationBuilder=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? ""String_Node_Str"" : ""String_Node_Str"")).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationStyle=new Notification.BigPictureStyle().bigPicture(picture);
  mNotificationBuilder.setStyle(mNotificationStyle);
  mPublicNotificationBuilder=new Notification.Builder(context).setContentTitle(r.getString(R.string.screenshot_saving_title)).setContentText(r.getString(R.string.screenshot_saving_text)).setSmallIcon(R.drawable.stat_notify_image).setCategory(Notification.CATEGORY_PROGRESS).setWhen(now).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
  mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
  Notification n=mNotificationBuilder.build();
  n.flags|=Notification.FLAG_NO_CLEAR;
  mNotificationManager.notify(nId,n);
  mNotificationBuilder.setLargeIcon(icon);
  mNotificationStyle.bigLargeIcon((Bitmap)null);
}",0.8051635111876075
194936,"public int compare(Alarm a1,Alarm a2){
  long when1=a1.when;
  long when2=a2.when;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}","public int compare(Alarm a1,Alarm a2){
  long when1=a1.whenElapsed;
  long when2=a2.whenElapsed;
  if (when1 - when2 > 0) {
    return 1;
  }
  if (when1 - when2 < 0) {
    return -1;
  }
  return 0;
}",0.963917525773196
194937,"/** 
 * Returns an intent to an   {@link Activity} that prompts the user to choose from a list ofaccounts. The caller will then typically start the activity by calling <code>startActivityForResult(intent, ...);</code>. <p> On success the activity returns a Bundle with the account name and type specified using keys  {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}. <p> The most common case is to call this with one account type, e.g.: <p> <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null, null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currentlyselected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to beshown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are usedboth to filter the shown accounts and to filter the list of account types that are shown when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwiseit is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in theaccounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} optionsparameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
static public Intent newChooseAccountIntent(Account selectedAccount,ArrayList<Account> allowableAccounts,String[] allowableAccountTypes,boolean alwaysPromptForAccount,String descriptionOverrideText,String addAccountAuthTokenType,String[] addAccountRequiredFeatures,Bundle addAccountOptions){
  Intent intent=new Intent();
  ComponentName componentName=ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseTypeAndAccountActivity));
  intent.setClassName(componentName.getPackageName(),componentName.getClassName());
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST,allowableAccounts);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY,allowableAccountTypes);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE,addAccountOptions);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT,selectedAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,alwaysPromptForAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE,descriptionOverrideText);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING,addAccountAuthTokenType);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY,addAccountRequiredFeatures);
  return intent;
}","/** 
 * Returns an intent to an   {@link Activity} that prompts the user to choose from a list ofaccounts. The caller will then typically start the activity by calling <code>startActivityForResult(intent, ...);</code>. <p> On success the activity returns a Bundle with the account name and type specified using keys  {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}. <p> The most common case is to call this with one account type, e.g.: <p> <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null, null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currentlyselected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to beshown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are usedboth to filter the shown accounts and to filter the list of account types that are shown when adding an account. If not specified then this field will not limit the displayed account types when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwiseit is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in theaccounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} optionsparameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
static public Intent newChooseAccountIntent(Account selectedAccount,ArrayList<Account> allowableAccounts,String[] allowableAccountTypes,boolean alwaysPromptForAccount,String descriptionOverrideText,String addAccountAuthTokenType,String[] addAccountRequiredFeatures,Bundle addAccountOptions){
  Intent intent=new Intent();
  ComponentName componentName=ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseTypeAndAccountActivity));
  intent.setClassName(componentName.getPackageName(),componentName.getClassName());
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST,allowableAccounts);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY,allowableAccountTypes);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE,addAccountOptions);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT,selectedAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,alwaysPromptForAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE,descriptionOverrideText);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING,addAccountAuthTokenType);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY,addAccountRequiredFeatures);
  return intent;
}",0.9847514486123818
194938,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + savedInstanceState + ""String_Node_Str"");
  }
  String message=null;
  try {
    IBinder activityToken=getActivityToken();
    mCallingUid=ActivityManagerNative.getDefault().getLaunchedFromUid(activityToken);
    mCallingPackage=ActivityManagerNative.getDefault().getLaunchedFromPackage(activityToken);
    if (mCallingUid != 0 && mCallingPackage != null) {
      Bundle restrictions=UserManager.get(this).getUserRestrictions(new UserHandle(UserHandle.getUserId(mCallingUid)));
      mDisallowAddAccounts=restrictions.getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS,false);
    }
  }
 catch (  RemoteException re) {
    Log.w(getClass().getSimpleName(),""String_Node_Str"" + re);
  }
  final Intent intent=getIntent();
  if (savedInstanceState != null) {
    mPendingRequest=savedInstanceState.getInt(KEY_INSTANCE_STATE_PENDING_REQUEST);
    mExistingAccounts=savedInstanceState.getParcelableArray(KEY_INSTANCE_STATE_EXISTING_ACCOUNTS);
    mSelectedAccountName=savedInstanceState.getString(KEY_INSTANCE_STATE_SELECTED_ACCOUNT_NAME);
    mSelectedAddNewAccount=savedInstanceState.getBoolean(KEY_INSTANCE_STATE_SELECTED_ADD_ACCOUNT,false);
    mAccounts=savedInstanceState.getParcelableArrayList(KEY_INSTANCE_STATE_ACCOUNT_LIST);
  }
 else {
    mPendingRequest=REQUEST_NULL;
    mExistingAccounts=null;
    Account selectedAccount=(Account)intent.getParcelableExtra(EXTRA_SELECTED_ACCOUNT);
    if (selectedAccount != null) {
      mSelectedAccountName=selectedAccount.name;
    }
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + mSelectedAccountName);
  }
  mSetOfAllowableAccounts=getAllowableAccountSet(intent);
  mSetOfRelevantAccountTypes=getReleventAccountTypes(intent);
  mAlwaysPromptForAccount=intent.getBooleanExtra(EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,false);
  mDescriptionOverride=intent.getStringExtra(EXTRA_DESCRIPTION_TEXT_OVERRIDE);
  mAccounts=getAcceptableAccountChoices(AccountManager.get(this));
  if (mAccounts.isEmpty() && mDisallowAddAccounts) {
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.app_not_authorized);
    mDontShowPicker=true;
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + savedInstanceState + ""String_Node_Str"");
  }
  String message=null;
  try {
    IBinder activityToken=getActivityToken();
    mCallingUid=ActivityManagerNative.getDefault().getLaunchedFromUid(activityToken);
    mCallingPackage=ActivityManagerNative.getDefault().getLaunchedFromPackage(activityToken);
    if (mCallingUid != 0 && mCallingPackage != null) {
      Bundle restrictions=UserManager.get(this).getUserRestrictions(new UserHandle(UserHandle.getUserId(mCallingUid)));
      mDisallowAddAccounts=restrictions.getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS,false);
    }
  }
 catch (  RemoteException re) {
    Log.w(getClass().getSimpleName(),""String_Node_Str"" + re);
  }
  final Intent intent=getIntent();
  if (savedInstanceState != null) {
    mPendingRequest=savedInstanceState.getInt(KEY_INSTANCE_STATE_PENDING_REQUEST);
    mExistingAccounts=savedInstanceState.getParcelableArray(KEY_INSTANCE_STATE_EXISTING_ACCOUNTS);
    mSelectedAccountName=savedInstanceState.getString(KEY_INSTANCE_STATE_SELECTED_ACCOUNT_NAME);
    mSelectedAddNewAccount=savedInstanceState.getBoolean(KEY_INSTANCE_STATE_SELECTED_ADD_ACCOUNT,false);
    mAccounts=savedInstanceState.getParcelableArrayList(KEY_INSTANCE_STATE_ACCOUNT_LIST);
  }
 else {
    mPendingRequest=REQUEST_NULL;
    mExistingAccounts=null;
    Account selectedAccount=(Account)intent.getParcelableExtra(EXTRA_SELECTED_ACCOUNT);
    if (selectedAccount != null) {
      mSelectedAccountName=selectedAccount.name;
    }
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + mSelectedAccountName);
  }
  mSetOfAllowableAccounts=getAllowableAccountSet(intent);
  mSetOfRelevantAccountTypes=getReleventAccountTypes(intent);
  mAlwaysPromptForAccount=intent.getBooleanExtra(EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,false);
  mDescriptionOverride=intent.getStringExtra(EXTRA_DESCRIPTION_TEXT_OVERRIDE);
  mAccounts=getAcceptableAccountChoices(AccountManager.get(this));
  if (mAccounts.isEmpty() && mDisallowAddAccounts) {
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.app_not_authorized);
    mDontShowPicker=true;
  }
  if (mDontShowPicker) {
    super.onCreate(savedInstanceState);
    return;
  }
  if (mPendingRequest == REQUEST_NULL) {
    if (mAccounts.isEmpty()) {
      setNonLabelThemeAndCallSuperCreate(savedInstanceState);
      if (mSetOfRelevantAccountTypes.size() == 1) {
        runAddAccountForAuthenticator(mSetOfRelevantAccountTypes.iterator().next());
      }
 else {
        startChooseAccountTypeActivity();
      }
      return;
    }
    if (!mAlwaysPromptForAccount && mAccounts.size() == 1) {
      Account account=mAccounts.get(0);
      super.onCreate(savedInstanceState);
      setResultAndFinish(account.name,account.type);
      return;
    }
  }
  String[] listItems=getListOfDisplayableOptions(mAccounts);
  mSelectedItemIndex=getItemIndexToSelect(mAccounts,mSelectedAccountName,mSelectedAddNewAccount);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.choose_type_and_account);
  overrideDescriptionIfSupplied(mDescriptionOverride);
  populateUIAccountList(listItems);
  mOkButton=(Button)findViewById(android.R.id.button2);
  mOkButton.setEnabled(mSelectedItemIndex != SELECTED_ITEM_NONE);
}",0.7958392101551481
194939,"/** 
 * Return a set of account types speficied by the intent as well as supported by the AccountManager.
 */
private Set<String> getReleventAccountTypes(final Intent intent){
  Set<String> setOfRelevantAccountTypes=null;
  final String[] allowedAccountTypes=intent.getStringArrayExtra(EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY);
  if (allowedAccountTypes != null) {
    setOfRelevantAccountTypes=Sets.newHashSet(allowedAccountTypes);
    AuthenticatorDescription[] descs=AccountManager.get(this).getAuthenticatorTypes();
    Set<String> supportedAccountTypes=new HashSet<String>(descs.length);
    for (    AuthenticatorDescription desc : descs) {
      supportedAccountTypes.add(desc.type);
    }
    setOfRelevantAccountTypes.retainAll(supportedAccountTypes);
  }
  return setOfRelevantAccountTypes;
}","/** 
 * Return a set of account types specified by the intent as well as supported by the AccountManager.
 */
private Set<String> getReleventAccountTypes(final Intent intent){
  Set<String> setOfRelevantAccountTypes=null;
  final String[] allowedAccountTypes=intent.getStringArrayExtra(EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY);
  AuthenticatorDescription[] descs=AccountManager.get(this).getAuthenticatorTypes();
  Set<String> supportedAccountTypes=new HashSet<String>(descs.length);
  for (  AuthenticatorDescription desc : descs) {
    supportedAccountTypes.add(desc.type);
  }
  if (allowedAccountTypes != null) {
    setOfRelevantAccountTypes=Sets.newHashSet(allowedAccountTypes);
    setOfRelevantAccountTypes.retainAll(supportedAccountTypes);
  }
 else {
    setOfRelevantAccountTypes=supportedAccountTypes;
  }
  return setOfRelevantAccountTypes;
}",0.5363800360793747
194940,"/** 
 * Returns an intent to an   {@link Activity} that prompts the user to choose from a list ofaccounts. The caller will then typically start the activity by calling <code>startActivityForResult(intent, ...);</code>. <p> On success the activity returns a Bundle with the account name and type specified using keys  {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}. <p> The most common case is to call this with one account type, e.g.: <p> <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null, null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currentlyselected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to beshown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are usedboth to filter the shown accounts and to filter the list of account types that are shown when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwiseit is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in theaccounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} optionsparameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
static public Intent newChooseAccountIntent(Account selectedAccount,ArrayList<Account> allowableAccounts,String[] allowableAccountTypes,boolean alwaysPromptForAccount,String descriptionOverrideText,String addAccountAuthTokenType,String[] addAccountRequiredFeatures,Bundle addAccountOptions){
  Intent intent=new Intent();
  ComponentName componentName=ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseTypeAndAccountActivity));
  intent.setClassName(componentName.getPackageName(),componentName.getClassName());
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST,allowableAccounts);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY,allowableAccountTypes);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE,addAccountOptions);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT,selectedAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,alwaysPromptForAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE,descriptionOverrideText);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING,addAccountAuthTokenType);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY,addAccountRequiredFeatures);
  return intent;
}","/** 
 * Returns an intent to an   {@link Activity} that prompts the user to choose from a list ofaccounts. The caller will then typically start the activity by calling <code>startActivityForResult(intent, ...);</code>. <p> On success the activity returns a Bundle with the account name and type specified using keys  {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}. <p> The most common case is to call this with one account type, e.g.: <p> <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null, null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currentlyselected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to beshown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are usedboth to filter the shown accounts and to filter the list of account types that are shown when adding an account. If not specified then this field will not limit the displayed account types when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwiseit is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in theaccounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} optionsparameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
static public Intent newChooseAccountIntent(Account selectedAccount,ArrayList<Account> allowableAccounts,String[] allowableAccountTypes,boolean alwaysPromptForAccount,String descriptionOverrideText,String addAccountAuthTokenType,String[] addAccountRequiredFeatures,Bundle addAccountOptions){
  Intent intent=new Intent();
  ComponentName componentName=ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseTypeAndAccountActivity));
  intent.setClassName(componentName.getPackageName(),componentName.getClassName());
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST,allowableAccounts);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY,allowableAccountTypes);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE,addAccountOptions);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT,selectedAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,alwaysPromptForAccount);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE,descriptionOverrideText);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING,addAccountAuthTokenType);
  intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY,addAccountRequiredFeatures);
  return intent;
}",0.9847514486123818
194941,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + savedInstanceState + ""String_Node_Str"");
  }
  String message=null;
  try {
    IBinder activityToken=getActivityToken();
    mCallingUid=ActivityManagerNative.getDefault().getLaunchedFromUid(activityToken);
    mCallingPackage=ActivityManagerNative.getDefault().getLaunchedFromPackage(activityToken);
    if (mCallingUid != 0 && mCallingPackage != null) {
      Bundle restrictions=UserManager.get(this).getUserRestrictions(new UserHandle(UserHandle.getUserId(mCallingUid)));
      mDisallowAddAccounts=restrictions.getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS,false);
    }
  }
 catch (  RemoteException re) {
    Log.w(getClass().getSimpleName(),""String_Node_Str"" + re);
  }
  final Intent intent=getIntent();
  if (savedInstanceState != null) {
    mPendingRequest=savedInstanceState.getInt(KEY_INSTANCE_STATE_PENDING_REQUEST);
    mExistingAccounts=savedInstanceState.getParcelableArray(KEY_INSTANCE_STATE_EXISTING_ACCOUNTS);
    mSelectedAccountName=savedInstanceState.getString(KEY_INSTANCE_STATE_SELECTED_ACCOUNT_NAME);
    mSelectedAddNewAccount=savedInstanceState.getBoolean(KEY_INSTANCE_STATE_SELECTED_ADD_ACCOUNT,false);
    mAccounts=savedInstanceState.getParcelableArrayList(KEY_INSTANCE_STATE_ACCOUNT_LIST);
  }
 else {
    mPendingRequest=REQUEST_NULL;
    mExistingAccounts=null;
    Account selectedAccount=(Account)intent.getParcelableExtra(EXTRA_SELECTED_ACCOUNT);
    if (selectedAccount != null) {
      mSelectedAccountName=selectedAccount.name;
    }
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + mSelectedAccountName);
  }
  mSetOfAllowableAccounts=getAllowableAccountSet(intent);
  mSetOfRelevantAccountTypes=getReleventAccountTypes(intent);
  mAlwaysPromptForAccount=intent.getBooleanExtra(EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,false);
  mDescriptionOverride=intent.getStringExtra(EXTRA_DESCRIPTION_TEXT_OVERRIDE);
  mAccounts=getAcceptableAccountChoices(AccountManager.get(this));
  if (mAccounts.isEmpty() && mDisallowAddAccounts) {
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.app_not_authorized);
    mDontShowPicker=true;
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + savedInstanceState + ""String_Node_Str"");
  }
  String message=null;
  try {
    IBinder activityToken=getActivityToken();
    mCallingUid=ActivityManagerNative.getDefault().getLaunchedFromUid(activityToken);
    mCallingPackage=ActivityManagerNative.getDefault().getLaunchedFromPackage(activityToken);
    if (mCallingUid != 0 && mCallingPackage != null) {
      Bundle restrictions=UserManager.get(this).getUserRestrictions(new UserHandle(UserHandle.getUserId(mCallingUid)));
      mDisallowAddAccounts=restrictions.getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS,false);
    }
  }
 catch (  RemoteException re) {
    Log.w(getClass().getSimpleName(),""String_Node_Str"" + re);
  }
  final Intent intent=getIntent();
  if (savedInstanceState != null) {
    mPendingRequest=savedInstanceState.getInt(KEY_INSTANCE_STATE_PENDING_REQUEST);
    mExistingAccounts=savedInstanceState.getParcelableArray(KEY_INSTANCE_STATE_EXISTING_ACCOUNTS);
    mSelectedAccountName=savedInstanceState.getString(KEY_INSTANCE_STATE_SELECTED_ACCOUNT_NAME);
    mSelectedAddNewAccount=savedInstanceState.getBoolean(KEY_INSTANCE_STATE_SELECTED_ADD_ACCOUNT,false);
    mAccounts=savedInstanceState.getParcelableArrayList(KEY_INSTANCE_STATE_ACCOUNT_LIST);
  }
 else {
    mPendingRequest=REQUEST_NULL;
    mExistingAccounts=null;
    Account selectedAccount=(Account)intent.getParcelableExtra(EXTRA_SELECTED_ACCOUNT);
    if (selectedAccount != null) {
      mSelectedAccountName=selectedAccount.name;
    }
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + mSelectedAccountName);
  }
  mSetOfAllowableAccounts=getAllowableAccountSet(intent);
  mSetOfRelevantAccountTypes=getReleventAccountTypes(intent);
  mAlwaysPromptForAccount=intent.getBooleanExtra(EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT,false);
  mDescriptionOverride=intent.getStringExtra(EXTRA_DESCRIPTION_TEXT_OVERRIDE);
  mAccounts=getAcceptableAccountChoices(AccountManager.get(this));
  if (mAccounts.isEmpty() && mDisallowAddAccounts) {
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.app_not_authorized);
    mDontShowPicker=true;
  }
  if (mDontShowPicker) {
    super.onCreate(savedInstanceState);
    return;
  }
  if (mPendingRequest == REQUEST_NULL) {
    if (mAccounts.isEmpty()) {
      setNonLabelThemeAndCallSuperCreate(savedInstanceState);
      if (mSetOfRelevantAccountTypes.size() == 1) {
        runAddAccountForAuthenticator(mSetOfRelevantAccountTypes.iterator().next());
      }
 else {
        startChooseAccountTypeActivity();
      }
      return;
    }
    if (!mAlwaysPromptForAccount && mAccounts.size() == 1) {
      Account account=mAccounts.get(0);
      super.onCreate(savedInstanceState);
      setResultAndFinish(account.name,account.type);
      return;
    }
  }
  String[] listItems=getListOfDisplayableOptions(mAccounts);
  mSelectedItemIndex=getItemIndexToSelect(mAccounts,mSelectedAccountName,mSelectedAddNewAccount);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.choose_type_and_account);
  overrideDescriptionIfSupplied(mDescriptionOverride);
  populateUIAccountList(listItems);
  mOkButton=(Button)findViewById(android.R.id.button2);
  mOkButton.setEnabled(mSelectedItemIndex != SELECTED_ITEM_NONE);
}",0.7958392101551481
194942,"/** 
 * Return a set of account types speficied by the intent as well as supported by the AccountManager.
 */
private Set<String> getReleventAccountTypes(final Intent intent){
  Set<String> setOfRelevantAccountTypes=null;
  final String[] allowedAccountTypes=intent.getStringArrayExtra(EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY);
  if (allowedAccountTypes != null) {
    setOfRelevantAccountTypes=Sets.newHashSet(allowedAccountTypes);
    AuthenticatorDescription[] descs=AccountManager.get(this).getAuthenticatorTypes();
    Set<String> supportedAccountTypes=new HashSet<String>(descs.length);
    for (    AuthenticatorDescription desc : descs) {
      supportedAccountTypes.add(desc.type);
    }
    setOfRelevantAccountTypes.retainAll(supportedAccountTypes);
  }
  return setOfRelevantAccountTypes;
}","/** 
 * Return a set of account types specified by the intent as well as supported by the AccountManager.
 */
private Set<String> getReleventAccountTypes(final Intent intent){
  Set<String> setOfRelevantAccountTypes=null;
  final String[] allowedAccountTypes=intent.getStringArrayExtra(EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY);
  AuthenticatorDescription[] descs=AccountManager.get(this).getAuthenticatorTypes();
  Set<String> supportedAccountTypes=new HashSet<String>(descs.length);
  for (  AuthenticatorDescription desc : descs) {
    supportedAccountTypes.add(desc.type);
  }
  if (allowedAccountTypes != null) {
    setOfRelevantAccountTypes=Sets.newHashSet(allowedAccountTypes);
    setOfRelevantAccountTypes.retainAll(supportedAccountTypes);
  }
 else {
    setOfRelevantAccountTypes=supportedAccountTypes;
  }
  return setOfRelevantAccountTypes;
}",0.5363800360793747
194943,"private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}","private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
        if (!SELinux.restorecon(fpDir)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.912667191188041
194944,"public void destroy(){
  if (token != null) {
    token.unlinkToDeath(this,0);
    token=null;
  }
  receiver=null;
}","public void destroy(){
  if (token != null) {
    try {
      token.unlinkToDeath(this,0);
    }
 catch (    NoSuchElementException e) {
      Slog.e(TAG,""String_Node_Str"" + this + ""String_Node_Str"",new Exception(""String_Node_Str""));
    }
    token=null;
  }
  receiver=null;
}",0.5924050632911393
194945,"private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}","private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
        if (!SELinux.restorecon(fpDir)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.912667191188041
194946,"public void destroy(){
  if (token != null) {
    token.unlinkToDeath(this,0);
    token=null;
  }
  receiver=null;
}","public void destroy(){
  if (token != null) {
    try {
      token.unlinkToDeath(this,0);
    }
 catch (    NoSuchElementException e) {
      Slog.e(TAG,""String_Node_Str"" + this + ""String_Node_Str"",new Exception(""String_Node_Str""));
    }
    token=null;
  }
  receiver=null;
}",0.5924050632911393
194947,"private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}","private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
        if (!SELinux.restorecon(fpDir)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.912667191188041
194948,"public void destroy(){
  if (token != null) {
    token.unlinkToDeath(this,0);
    token=null;
  }
  receiver=null;
}","public void destroy(){
  if (token != null) {
    try {
      token.unlinkToDeath(this,0);
    }
 catch (    NoSuchElementException e) {
      Slog.e(TAG,""String_Node_Str"" + this + ""String_Node_Str"",new Exception(""String_Node_Str""));
    }
    token=null;
  }
  receiver=null;
}",0.5924050632911393
194949,"private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}","private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
        if (!SELinux.restorecon(fpDir)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.912667191188041
194950,"public void destroy(){
  if (token != null) {
    token.unlinkToDeath(this,0);
    token=null;
  }
  receiver=null;
}","public void destroy(){
  if (token != null) {
    try {
      token.unlinkToDeath(this,0);
    }
 catch (    NoSuchElementException e) {
      Slog.e(TAG,""String_Node_Str"" + this + ""String_Node_Str"",new Exception(""String_Node_Str""));
    }
    token=null;
  }
  receiver=null;
}",0.5924050632911393
194951,"private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}","private void updateActiveGroup(int userId){
  IFingerprintDaemon daemon=getFingerprintDaemon();
  if (daemon != null) {
    try {
      final File systemDir=Environment.getUserSystemDirectory(userId);
      final File fpDir=new File(systemDir,FP_DATA_DIR);
      if (!fpDir.exists()) {
        if (!fpDir.mkdir()) {
          Slog.v(TAG,""String_Node_Str"" + fpDir.getAbsolutePath());
          return;
        }
        if (!SELinux.restorecon(fpDir)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
      daemon.setActiveGroup(userId,fpDir.getAbsolutePath().getBytes());
    }
 catch (    RemoteException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.912667191188041
194952,"public void destroy(){
  if (token != null) {
    token.unlinkToDeath(this,0);
    token=null;
  }
  receiver=null;
}","public void destroy(){
  if (token != null) {
    try {
      token.unlinkToDeath(this,0);
    }
 catch (    NoSuchElementException e) {
      Slog.e(TAG,""String_Node_Str"" + this + ""String_Node_Str"",new Exception(""String_Node_Str""));
    }
    token=null;
  }
  receiver=null;
}",0.5924050632911393
194953,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the z,x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z,x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre> See   {@link #getOrientation} for more detailed definition of the output.
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an an array of floats (z, x, and y) in which the angle change(in radians) is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.9798685291700904
194954,"/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines on which world axis and direction the X axis of the device is mapped.
 * @param Y defines on which world axis and direction the Y axis of the device is mapped.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}","/** 
 * <p> Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see  {@link #getOrientation}) in a different coordinate system. </p> <p> When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually <b>doesn't need</b> to be transformed by this function, unless the screen is physically rotated, in which case you can use  {@link android.view.Display#getRotation() Display.getRotation()} toretrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. </p> <p> <u>Examples:</u> <p> <ul> <li>Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);</code> </ul> </p> <li>Using the device as a mechanical compass when rotation is {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:</li> <p> <ul> <code>remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);</code> </ul> </p> Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see   {@link #getOrientation}). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your  {@link android.app.Activity Activity} is running in landscape mode.</ul> <p> Since the resulting coordinate system is orthonormal, only two axes need to be specified.
 * @param inR the rotation matrix to be transformed. Usually it is the matrix returned by  {@link #getRotationMatrix}.
 * @param X defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system.
 * @param Y defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system.
 * @param outR the transformed rotation matrix. inR and outR should not be the same array.
 * @return <code>true</code> on success. <code>false</code> if the inputparameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 */
public static boolean remapCoordinateSystem(float[] inR,int X,int Y,float[] outR){
  if (inR == outR) {
    final float[] temp=mTempMatrix;
synchronized (temp) {
      if (remapCoordinateSystemImpl(inR,X,Y,temp)) {
        final int size=outR.length;
        for (int i=0; i < size; i++)         outR[i]=temp[i];
        return true;
      }
    }
  }
  return remapCoordinateSystemImpl(inR,X,Y,outR);
}",0.9448476052249636
194955,"/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p>The reference coordinate-system used is different from the world coordinate-system defined for the rotation matrix:</p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points West).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the center of the Earth and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe_inverted.png"" alt=""Inverted world coordinate-system diagram."" border=""0"" /></center> </p> <p> All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}","/** 
 * Computes the device's orientation based on the rotation matrix. <p> When it returns, the array values is filled with the result: <ul> <li>values[0]: <i>azimuth</i>, rotation around the -Z axis, i.e. the opposite direction of Z axis.</li> <li>values[1]: <i>pitch</i>, rotation around the -X axis, i.e the opposite direction of X axis.</li> <li>values[2]: <i>roll</i>, rotation around the Y axis.</li> </ul> <p> Applying these three intrinsic rotations in azimuth, pitch and roll order transforms identity matrix to the rotation matrix given in input R. All three angles above are in <b>radians</b> and <b>positive</b> in the <b>counter-clockwise</b> direction. Range of output is: azimuth from -&pi; to &pi;, pitch from -&pi;/2 to &pi;/2 and roll from -&pi; to &pi;.
 * @param R rotation matrix see  {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 * @see #getRotationMatrix(float[],float[],float[],float[])
 * @see GeomagneticField
 */
public static float[] getOrientation(float[] R,float values[]){
  if (R.length == 9) {
    values[0]=(float)Math.atan2(R[1],R[4]);
    values[1]=(float)Math.asin(-R[7]);
    values[2]=(float)Math.atan2(-R[6],R[8]);
  }
 else {
    values[0]=(float)Math.atan2(R[1],R[5]);
    values[1]=(float)Math.asin(-R[9]);
    values[2]=(float)Math.atan2(-R[8],R[10]);
  }
  return values;
}",0.7022508038585209
194956,"/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}","/** 
 * <p> Computes the inclination matrix <b>I</b> as well as the rotation matrix <b>R</b> transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where: </p> <ul> <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to the ground at the device's current location and roughly points East).</li> <li>Y is tangential to the ground at the device's current location and points towards the magnetic North Pole.</li> <li>Z points towards the sky and is perpendicular to the ground.</li> </ul> <p> <center><img src=""../../../images/axis_globe.png"" alt=""World coordinate-system diagram."" border=""0"" /></center> </p> <p> <hr> <p> By definition: <p> [0 0 g] = <b>R</b> * <b>gravity</b> (g = magnitude of gravity) <p> [0 m 0] = <b>I</b> * <b>R</b> * <b>geomagnetic</b> (m = magnitude of geomagnetic field) <p> <b>R</b> is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. <p> <b>I</b> is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). <b>I</b> is a simple rotation around the X axis. The inclination angle in radians can be computed with   {@link #getInclination}. <hr> <p> Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p> <u>If the array length is 16:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \ |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  | |  M[ 8]   M[ 9]   M[10]   M[11]  | \  M[12]   M[13]   M[14]   M[15]  / </pre> This matrix is ready to be used by OpenGL ES's  {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[],int) glLoadMatrixf(float[], int)}. <p> Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. <p> Also note that the returned matrices always have this form: <pre> /  M[ 0]   M[ 1]   M[ 2]   0  \ |  M[ 4]   M[ 5]   M[ 6]   0  | |  M[ 8]   M[ 9]   M[10]   0  | \      0       0       0   1  / </pre> <p> <u>If the array length is 9:</u> <pre> /  M[ 0]   M[ 1]   M[ 2]  \ |  M[ 3]   M[ 4]   M[ 5]  | \  M[ 6]   M[ 7]   M[ 8]  / </pre> <hr> <p> The inverse of each matrix can be computed easily by taking its transpose. <p> The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.
 * @param R is an array of 9 floats holding the rotation matrix <b>R</b> when this function returns. R can be null. <p>
 * @param I is an array of 9 floats holding the rotation matrix <b>I</b> when this function returns. I can be null. <p>
 * @param gravity is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_ACCELEROMETER TYPE_ACCELEROMETER}. <p>
 * @param geomagnetic is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the {@link android.hardware.SensorEvent#values values} returned by a{@link android.hardware.SensorEvent SensorEvent} of a{@link android.hardware.Sensor Sensor} of type{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD TYPE_MAGNETIC_FIELD}.
 * @return <code>true</code> on success, <code>false</code> on failure (forinstance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified.
 * @see #getInclination(float[])
 * @see #getOrientation(float[],float[])
 * @see #remapCoordinateSystem(float[],int,int,float[])
 */
public static boolean getRotationMatrix(float[] R,float[] I,float[] gravity,float[] geomagnetic){
  float Ax=gravity[0];
  float Ay=gravity[1];
  float Az=gravity[2];
  final float normsqA=(Ax * Ax + Ay * Ay + Az * Az);
  final float g=9.81f;
  final float freeFallGravitySquared=0.01f * g * g;
  if (normsqA < freeFallGravitySquared) {
    return false;
  }
  final float Ex=geomagnetic[0];
  final float Ey=geomagnetic[1];
  final float Ez=geomagnetic[2];
  float Hx=Ey * Az - Ez * Ay;
  float Hy=Ez * Ax - Ex * Az;
  float Hz=Ex * Ay - Ey * Ax;
  final float normH=(float)Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
  if (normH < 0.1f) {
    return false;
  }
  final float invH=1.0f / normH;
  Hx*=invH;
  Hy*=invH;
  Hz*=invH;
  final float invA=1.0f / (float)Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
  Ax*=invA;
  Ay*=invA;
  Az*=invA;
  final float Mx=Ay * Hz - Az * Hy;
  final float My=Az * Hx - Ax * Hz;
  final float Mz=Ax * Hy - Ay * Hx;
  if (R != null) {
    if (R.length == 9) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=Mx;
      R[4]=My;
      R[5]=Mz;
      R[6]=Ax;
      R[7]=Ay;
      R[8]=Az;
    }
 else     if (R.length == 16) {
      R[0]=Hx;
      R[1]=Hy;
      R[2]=Hz;
      R[3]=0;
      R[4]=Mx;
      R[5]=My;
      R[6]=Mz;
      R[7]=0;
      R[8]=Ax;
      R[9]=Ay;
      R[10]=Az;
      R[11]=0;
      R[12]=0;
      R[13]=0;
      R[14]=0;
      R[15]=1;
    }
  }
  if (I != null) {
    final float invE=1.0f / (float)Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
    final float c=(Ex * Mx + Ey * My + Ez * Mz) * invE;
    final float s=(Ex * Ax + Ey * Ay + Ez * Az) * invE;
    if (I.length == 9) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[3]=0;
      I[4]=c;
      I[5]=s;
      I[6]=0;
      I[7]=-s;
      I[8]=c;
    }
 else     if (I.length == 16) {
      I[0]=1;
      I[1]=0;
      I[2]=0;
      I[4]=0;
      I[5]=c;
      I[6]=s;
      I[8]=0;
      I[9]=-s;
      I[10]=c;
      I[3]=I[7]=I[11]=I[12]=I[13]=I[14]=0;
      I[15]=1;
    }
  }
  return true;
}",0.9755142017629774
194957,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9172185430463576
194958,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9172185430463576
194959,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9172185430463576
194960,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9172185430463576
194961,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  int maxKeyguardNotifications=getMaxKeyguardNotifications();
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    if (onKeyguard) {
      entry.row.setExpansionDisabled(true);
    }
 else {
      entry.row.setExpansionDisabled(false);
      if (!entry.row.isUserLocked()) {
        boolean top=(i == 0);
        entry.row.setSystemExpanded(top);
      }
    }
    boolean isInvisibleChild=!mGroupManager.isVisible(entry.notification);
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if ((isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxKeyguardNotifications || !showOnKeyguard || isInvisibleChild))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !isInvisibleChild) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!isInvisibleChild) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,true);
        }
        visibleNotifications++;
      }
    }
  }
  if (onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0) {
    mKeyguardIconOverflowContainer.setVisibility(View.VISIBLE);
  }
 else {
    mKeyguardIconOverflowContainer.setVisibility(View.GONE);
  }
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9172185430463576
194962,"public void onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    final float x=event.getX();
  final float y=event.getY();
mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(x,y);
if (mGestureStayedInTapRegion) {
if (mDoubleTap) {
  final float deltaX=x - mDownPositionX;
  final float deltaY=y - mDownPositionY;
  final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
  ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
  int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
  boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
  if (stayedInArea && isPositionOnText(x,y)) {
    startSelectionActionModeWithSelectionAndStartDrag();
    mDiscardNextActionUp=true;
  }
}
}
mDownPositionX=x;
mDownPositionY=y;
mGestureStayedInTapRegion=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
if (mGestureStayedInTapRegion) {
final float deltaX=event.getX() - mDownPositionX;
final float deltaY=event.getY() - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
int doubleTapTouchSlop=viewConfiguration.getScaledDoubleTapTouchSlop();
if (distanceSquared > doubleTapTouchSlop * doubleTapTouchSlop) {
mGestureStayedInTapRegion=false;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
final int rawOffset=mTextView.getOffsetForPosition(event.getX(),event.getY());
int offset=rawOffset;
int firstWordStart=getWordStart(mStartOffset);
int firstWordEnd=getWordEnd(mStartOffset);
if (offset > firstWordEnd || offset < firstWordStart) {
int fingerOffset=viewConfiguration.getScaledTouchSlop();
float mx=event.getX();
float my=event.getY();
if (mx > fingerOffset) mx-=fingerOffset;
if (my > fingerOffset) my-=fingerOffset;
offset=mTextView.getOffsetForPosition(mx,my);
if (mTextView.getWidth() - fingerOffset > mx) {
final WordIterator wordIterator=getWordIteratorWithText();
final int precedingOffset=wordIterator.preceding(offset);
if (mStartOffset < offset) {
offset=Math.max(precedingOffset - 1,0);
}
 else {
if (precedingOffset == WordIterator.DONE) {
offset=0;
}
 else {
offset=wordIterator.preceding(precedingOffset);
}
}
}
if (offset == WordIterator.DONE) offset=rawOffset;
int newStart=mStartOffset < offset ? getWordStart(mStartOffset) : getWordEnd(mStartOffset);
Selection.setSelection((Spannable)mTextView.getText(),newStart,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}","public void onTouchEvent(MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(eventX,eventY);
  if (mGestureStayedInTapRegion) {
    if (mDoubleTap) {
      final float deltaX=eventX - mDownPositionX;
      final float deltaY=eventY - mDownPositionY;
      final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
      ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
      int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
      boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
      if (stayedInArea && isPositionOnText(eventX,eventY)) {
        startSelectionActionModeWithSelectionAndStartDrag();
        mDiscardNextActionUp=true;
      }
    }
  }
mDownPositionX=eventX;
mDownPositionY=eventY;
mGestureStayedInTapRegion=true;
mHaventMovedEnoughToStartDrag=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfig=ViewConfiguration.get(mTextView.getContext());
final int touchSlop=viewConfig.getScaledTouchSlop();
if (mGestureStayedInTapRegion || mHaventMovedEnoughToStartDrag) {
final float deltaX=eventX - mDownPositionX;
final float deltaY=eventY - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
if (mGestureStayedInTapRegion) {
int doubleTapTouchSlop=viewConfig.getScaledDoubleTapTouchSlop();
mGestureStayedInTapRegion=distanceSquared <= doubleTapTouchSlop * doubleTapTouchSlop;
}
if (mHaventMovedEnoughToStartDrag) {
mHaventMovedEnoughToStartDrag=distanceSquared <= touchSlop * touchSlop;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
if (!mHaventMovedEnoughToStartDrag) {
final float fingerOffset=(mStartHandle != null) ? mStartHandle.getIdealVerticalOffset() : touchSlop;
int offset=mTextView.getOffsetForPosition(eventX,eventY - fingerOffset);
int startOffset;
if (mStartOffset < offset) {
offset=getWordEnd(offset);
startOffset=getWordStart(mStartOffset);
}
 else {
offset=getWordStart(offset);
startOffset=getWordEnd(mStartOffset);
}
Selection.setSelection((Spannable)mTextView.getText(),startOffset,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}",0.4884821710318712
194963,"public void onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    final float x=event.getX();
  final float y=event.getY();
mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(x,y);
if (mGestureStayedInTapRegion) {
if (mDoubleTap) {
  final float deltaX=x - mDownPositionX;
  final float deltaY=y - mDownPositionY;
  final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
  ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
  int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
  boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
  if (stayedInArea && isPositionOnText(x,y)) {
    startSelectionActionModeWithSelectionAndStartDrag();
    mDiscardNextActionUp=true;
  }
}
}
mDownPositionX=x;
mDownPositionY=y;
mGestureStayedInTapRegion=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
if (mGestureStayedInTapRegion) {
final float deltaX=event.getX() - mDownPositionX;
final float deltaY=event.getY() - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
int doubleTapTouchSlop=viewConfiguration.getScaledDoubleTapTouchSlop();
if (distanceSquared > doubleTapTouchSlop * doubleTapTouchSlop) {
mGestureStayedInTapRegion=false;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
final int rawOffset=mTextView.getOffsetForPosition(event.getX(),event.getY());
int offset=rawOffset;
int firstWordStart=getWordStart(mStartOffset);
int firstWordEnd=getWordEnd(mStartOffset);
if (offset > firstWordEnd || offset < firstWordStart) {
int fingerOffset=viewConfiguration.getScaledTouchSlop();
float mx=event.getX();
float my=event.getY();
if (mx > fingerOffset) mx-=fingerOffset;
if (my > fingerOffset) my-=fingerOffset;
offset=mTextView.getOffsetForPosition(mx,my);
if (mTextView.getWidth() - fingerOffset > mx) {
final WordIterator wordIterator=getWordIteratorWithText();
final int precedingOffset=wordIterator.preceding(offset);
if (mStartOffset < offset) {
offset=Math.max(precedingOffset - 1,0);
}
 else {
if (precedingOffset == WordIterator.DONE) {
offset=0;
}
 else {
offset=wordIterator.preceding(precedingOffset);
}
}
}
if (offset == WordIterator.DONE) offset=rawOffset;
int newStart=mStartOffset < offset ? getWordStart(mStartOffset) : getWordEnd(mStartOffset);
Selection.setSelection((Spannable)mTextView.getText(),newStart,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}","public void onTouchEvent(MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(eventX,eventY);
  if (mGestureStayedInTapRegion) {
    if (mDoubleTap) {
      final float deltaX=eventX - mDownPositionX;
      final float deltaY=eventY - mDownPositionY;
      final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
      ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
      int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
      boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
      if (stayedInArea && isPositionOnText(eventX,eventY)) {
        startSelectionActionModeWithSelectionAndStartDrag();
        mDiscardNextActionUp=true;
      }
    }
  }
mDownPositionX=eventX;
mDownPositionY=eventY;
mGestureStayedInTapRegion=true;
mHaventMovedEnoughToStartDrag=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfig=ViewConfiguration.get(mTextView.getContext());
final int touchSlop=viewConfig.getScaledTouchSlop();
if (mGestureStayedInTapRegion || mHaventMovedEnoughToStartDrag) {
final float deltaX=eventX - mDownPositionX;
final float deltaY=eventY - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
if (mGestureStayedInTapRegion) {
int doubleTapTouchSlop=viewConfig.getScaledDoubleTapTouchSlop();
mGestureStayedInTapRegion=distanceSquared <= doubleTapTouchSlop * doubleTapTouchSlop;
}
if (mHaventMovedEnoughToStartDrag) {
mHaventMovedEnoughToStartDrag=distanceSquared <= touchSlop * touchSlop;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
if (!mHaventMovedEnoughToStartDrag) {
final float fingerOffset=(mStartHandle != null) ? mStartHandle.getIdealVerticalOffset() : touchSlop;
int offset=mTextView.getOffsetForPosition(eventX,eventY - fingerOffset);
int startOffset;
if (mStartOffset < offset) {
offset=getWordEnd(offset);
startOffset=getWordStart(mStartOffset);
}
 else {
offset=getWordStart(offset);
startOffset=getWordEnd(mStartOffset);
}
Selection.setSelection((Spannable)mTextView.getText(),startOffset,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}",0.4884821710318712
194964,"public void onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    final float x=event.getX();
  final float y=event.getY();
mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(x,y);
if (mGestureStayedInTapRegion) {
if (mDoubleTap) {
  final float deltaX=x - mDownPositionX;
  final float deltaY=y - mDownPositionY;
  final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
  ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
  int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
  boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
  if (stayedInArea && isPositionOnText(x,y)) {
    startSelectionActionModeWithSelectionAndStartDrag();
    mDiscardNextActionUp=true;
  }
}
}
mDownPositionX=x;
mDownPositionY=y;
mGestureStayedInTapRegion=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
if (mGestureStayedInTapRegion) {
final float deltaX=event.getX() - mDownPositionX;
final float deltaY=event.getY() - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
int doubleTapTouchSlop=viewConfiguration.getScaledDoubleTapTouchSlop();
if (distanceSquared > doubleTapTouchSlop * doubleTapTouchSlop) {
mGestureStayedInTapRegion=false;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
final int rawOffset=mTextView.getOffsetForPosition(event.getX(),event.getY());
int offset=rawOffset;
int firstWordStart=getWordStart(mStartOffset);
int firstWordEnd=getWordEnd(mStartOffset);
if (offset > firstWordEnd || offset < firstWordStart) {
int fingerOffset=viewConfiguration.getScaledTouchSlop();
float mx=event.getX();
float my=event.getY();
if (mx > fingerOffset) mx-=fingerOffset;
if (my > fingerOffset) my-=fingerOffset;
offset=mTextView.getOffsetForPosition(mx,my);
if (mTextView.getWidth() - fingerOffset > mx) {
final WordIterator wordIterator=getWordIteratorWithText();
final int precedingOffset=wordIterator.preceding(offset);
if (mStartOffset < offset) {
offset=Math.max(precedingOffset - 1,0);
}
 else {
if (precedingOffset == WordIterator.DONE) {
offset=0;
}
 else {
offset=wordIterator.preceding(precedingOffset);
}
}
}
if (offset == WordIterator.DONE) offset=rawOffset;
int newStart=mStartOffset < offset ? getWordStart(mStartOffset) : getWordEnd(mStartOffset);
Selection.setSelection((Spannable)mTextView.getText(),newStart,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}","public void onTouchEvent(MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(eventX,eventY);
  if (mGestureStayedInTapRegion) {
    if (mDoubleTap) {
      final float deltaX=eventX - mDownPositionX;
      final float deltaY=eventY - mDownPositionY;
      final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
      ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
      int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
      boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
      if (stayedInArea && isPositionOnText(eventX,eventY)) {
        startSelectionActionModeWithSelectionAndStartDrag();
        mDiscardNextActionUp=true;
      }
    }
  }
mDownPositionX=eventX;
mDownPositionY=eventY;
mGestureStayedInTapRegion=true;
mHaventMovedEnoughToStartDrag=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfig=ViewConfiguration.get(mTextView.getContext());
final int touchSlop=viewConfig.getScaledTouchSlop();
if (mGestureStayedInTapRegion || mHaventMovedEnoughToStartDrag) {
final float deltaX=eventX - mDownPositionX;
final float deltaY=eventY - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
if (mGestureStayedInTapRegion) {
int doubleTapTouchSlop=viewConfig.getScaledDoubleTapTouchSlop();
mGestureStayedInTapRegion=distanceSquared <= doubleTapTouchSlop * doubleTapTouchSlop;
}
if (mHaventMovedEnoughToStartDrag) {
mHaventMovedEnoughToStartDrag=distanceSquared <= touchSlop * touchSlop;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
if (!mHaventMovedEnoughToStartDrag) {
final float fingerOffset=(mStartHandle != null) ? mStartHandle.getIdealVerticalOffset() : touchSlop;
int offset=mTextView.getOffsetForPosition(eventX,eventY - fingerOffset);
int startOffset;
if (mStartOffset < offset) {
offset=getWordEnd(offset);
startOffset=getWordStart(mStartOffset);
}
 else {
offset=getWordStart(offset);
startOffset=getWordEnd(mStartOffset);
}
Selection.setSelection((Spannable)mTextView.getText(),startOffset,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}",0.4884821710318712
194965,"public void onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    final float x=event.getX();
  final float y=event.getY();
mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(x,y);
if (mGestureStayedInTapRegion) {
if (mDoubleTap) {
  final float deltaX=x - mDownPositionX;
  final float deltaY=y - mDownPositionY;
  final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
  ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
  int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
  boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
  if (stayedInArea && isPositionOnText(x,y)) {
    startSelectionActionModeWithSelectionAndStartDrag();
    mDiscardNextActionUp=true;
  }
}
}
mDownPositionX=x;
mDownPositionY=y;
mGestureStayedInTapRegion=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
if (mGestureStayedInTapRegion) {
final float deltaX=event.getX() - mDownPositionX;
final float deltaY=event.getY() - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
int doubleTapTouchSlop=viewConfiguration.getScaledDoubleTapTouchSlop();
if (distanceSquared > doubleTapTouchSlop * doubleTapTouchSlop) {
mGestureStayedInTapRegion=false;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
final int rawOffset=mTextView.getOffsetForPosition(event.getX(),event.getY());
int offset=rawOffset;
int firstWordStart=getWordStart(mStartOffset);
int firstWordEnd=getWordEnd(mStartOffset);
if (offset > firstWordEnd || offset < firstWordStart) {
int fingerOffset=viewConfiguration.getScaledTouchSlop();
float mx=event.getX();
float my=event.getY();
if (mx > fingerOffset) mx-=fingerOffset;
if (my > fingerOffset) my-=fingerOffset;
offset=mTextView.getOffsetForPosition(mx,my);
if (mTextView.getWidth() - fingerOffset > mx) {
final WordIterator wordIterator=getWordIteratorWithText();
final int precedingOffset=wordIterator.preceding(offset);
if (mStartOffset < offset) {
offset=Math.max(precedingOffset - 1,0);
}
 else {
if (precedingOffset == WordIterator.DONE) {
offset=0;
}
 else {
offset=wordIterator.preceding(precedingOffset);
}
}
}
if (offset == WordIterator.DONE) offset=rawOffset;
int newStart=mStartOffset < offset ? getWordStart(mStartOffset) : getWordEnd(mStartOffset);
Selection.setSelection((Spannable)mTextView.getText(),newStart,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}","public void onTouchEvent(MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(eventX,eventY);
  if (mGestureStayedInTapRegion) {
    if (mDoubleTap) {
      final float deltaX=eventX - mDownPositionX;
      final float deltaY=eventY - mDownPositionY;
      final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
      ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
      int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
      boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
      if (stayedInArea && isPositionOnText(eventX,eventY)) {
        startSelectionActionModeWithSelectionAndStartDrag();
        mDiscardNextActionUp=true;
      }
    }
  }
mDownPositionX=eventX;
mDownPositionY=eventY;
mGestureStayedInTapRegion=true;
mHaventMovedEnoughToStartDrag=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfig=ViewConfiguration.get(mTextView.getContext());
final int touchSlop=viewConfig.getScaledTouchSlop();
if (mGestureStayedInTapRegion || mHaventMovedEnoughToStartDrag) {
final float deltaX=eventX - mDownPositionX;
final float deltaY=eventY - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
if (mGestureStayedInTapRegion) {
int doubleTapTouchSlop=viewConfig.getScaledDoubleTapTouchSlop();
mGestureStayedInTapRegion=distanceSquared <= doubleTapTouchSlop * doubleTapTouchSlop;
}
if (mHaventMovedEnoughToStartDrag) {
mHaventMovedEnoughToStartDrag=distanceSquared <= touchSlop * touchSlop;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
if (!mHaventMovedEnoughToStartDrag) {
final float fingerOffset=(mStartHandle != null) ? mStartHandle.getIdealVerticalOffset() : touchSlop;
int offset=mTextView.getOffsetForPosition(eventX,eventY - fingerOffset);
int startOffset;
if (mStartOffset < offset) {
offset=getWordEnd(offset);
startOffset=getWordStart(mStartOffset);
}
 else {
offset=getWordStart(offset);
startOffset=getWordEnd(mStartOffset);
}
Selection.setSelection((Spannable)mTextView.getText(),startOffset,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}",0.4884821710318712
194966,"public void onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    final float x=event.getX();
  final float y=event.getY();
mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(x,y);
if (mGestureStayedInTapRegion) {
if (mDoubleTap) {
  final float deltaX=x - mDownPositionX;
  final float deltaY=y - mDownPositionY;
  final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
  ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
  int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
  boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
  if (stayedInArea && isPositionOnText(x,y)) {
    startSelectionActionModeWithSelectionAndStartDrag();
    mDiscardNextActionUp=true;
  }
}
}
mDownPositionX=x;
mDownPositionY=y;
mGestureStayedInTapRegion=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
if (mGestureStayedInTapRegion) {
final float deltaX=event.getX() - mDownPositionX;
final float deltaY=event.getY() - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
int doubleTapTouchSlop=viewConfiguration.getScaledDoubleTapTouchSlop();
if (distanceSquared > doubleTapTouchSlop * doubleTapTouchSlop) {
mGestureStayedInTapRegion=false;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
final int rawOffset=mTextView.getOffsetForPosition(event.getX(),event.getY());
int offset=rawOffset;
int firstWordStart=getWordStart(mStartOffset);
int firstWordEnd=getWordEnd(mStartOffset);
if (offset > firstWordEnd || offset < firstWordStart) {
int fingerOffset=viewConfiguration.getScaledTouchSlop();
float mx=event.getX();
float my=event.getY();
if (mx > fingerOffset) mx-=fingerOffset;
if (my > fingerOffset) my-=fingerOffset;
offset=mTextView.getOffsetForPosition(mx,my);
if (mTextView.getWidth() - fingerOffset > mx) {
final WordIterator wordIterator=getWordIteratorWithText();
final int precedingOffset=wordIterator.preceding(offset);
if (mStartOffset < offset) {
offset=Math.max(precedingOffset - 1,0);
}
 else {
if (precedingOffset == WordIterator.DONE) {
offset=0;
}
 else {
offset=wordIterator.preceding(precedingOffset);
}
}
}
if (offset == WordIterator.DONE) offset=rawOffset;
int newStart=mStartOffset < offset ? getWordStart(mStartOffset) : getWordEnd(mStartOffset);
Selection.setSelection((Spannable)mTextView.getText(),newStart,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}","public void onTouchEvent(MotionEvent event){
  final float eventX=event.getX();
  final float eventY=event.getY();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(eventX,eventY);
  if (mGestureStayedInTapRegion) {
    if (mDoubleTap) {
      final float deltaX=eventX - mDownPositionX;
      final float deltaY=eventY - mDownPositionY;
      final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
      ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
      int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
      boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
      if (stayedInArea && isPositionOnText(eventX,eventY)) {
        startSelectionActionModeWithSelectionAndStartDrag();
        mDiscardNextActionUp=true;
      }
    }
  }
mDownPositionX=eventX;
mDownPositionY=eventY;
mGestureStayedInTapRegion=true;
mHaventMovedEnoughToStartDrag=true;
break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfig=ViewConfiguration.get(mTextView.getContext());
final int touchSlop=viewConfig.getScaledTouchSlop();
if (mGestureStayedInTapRegion || mHaventMovedEnoughToStartDrag) {
final float deltaX=eventX - mDownPositionX;
final float deltaY=eventY - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
if (mGestureStayedInTapRegion) {
int doubleTapTouchSlop=viewConfig.getScaledDoubleTapTouchSlop();
mGestureStayedInTapRegion=distanceSquared <= doubleTapTouchSlop * doubleTapTouchSlop;
}
if (mHaventMovedEnoughToStartDrag) {
mHaventMovedEnoughToStartDrag=distanceSquared <= touchSlop * touchSlop;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1) {
if (!mHaventMovedEnoughToStartDrag) {
final float fingerOffset=(mStartHandle != null) ? mStartHandle.getIdealVerticalOffset() : touchSlop;
int offset=mTextView.getOffsetForPosition(eventX,eventY - fingerOffset);
int startOffset;
if (mStartOffset < offset) {
offset=getWordEnd(offset);
startOffset=getWordStart(mStartOffset);
}
 else {
offset=getWordStart(offset);
startOffset=getWordEnd(mStartOffset);
}
Selection.setSelection((Spannable)mTextView.getText(),startOffset,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
mDragAcceleratorActive=false;
mStartOffset=-1;
}
break;
}
}",0.4884821710318712
194967,"private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  UserAccounts accounts=getUserAccounts(userId);
  long identityToken=clearCallingIdentity();
  try {
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}","private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  long identityToken=clearCallingIdentity();
  try {
    UserAccounts accounts=getUserAccounts(userId);
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}",0.7585886722376973
194968,"private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  UserAccounts accounts=getUserAccounts(userId);
  long identityToken=clearCallingIdentity();
  try {
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}","private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  long identityToken=clearCallingIdentity();
  try {
    UserAccounts accounts=getUserAccounts(userId);
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}",0.7585886722376973
194969,"private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  UserAccounts accounts=getUserAccounts(userId);
  long identityToken=clearCallingIdentity();
  try {
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}","private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  long identityToken=clearCallingIdentity();
  try {
    UserAccounts accounts=getUserAccounts(userId);
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}",0.7585886722376973
194970,"private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  UserAccounts accounts=getUserAccounts(userId);
  long identityToken=clearCallingIdentity();
  try {
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}","private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  long identityToken=clearCallingIdentity();
  try {
    UserAccounts accounts=getUserAccounts(userId);
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}",0.7585886722376973
194971,"private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  UserAccounts accounts=getUserAccounts(userId);
  long identityToken=clearCallingIdentity();
  try {
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}","private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  long identityToken=clearCallingIdentity();
  try {
    UserAccounts accounts=getUserAccounts(userId);
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}",0.7585886722376973
194972,"private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  UserAccounts accounts=getUserAccounts(userId);
  long identityToken=clearCallingIdentity();
  try {
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}","private Account[] getAccountsAsUser(String type,int userId,String callingPackage,int packageUid){
  int callingUid=Binder.getCallingUid();
  if (userId != UserHandle.getCallingUserId() && callingUid != Process.myUid() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + UserHandle.getCallingUserId() + ""String_Node_Str""+ userId);
  }
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + type + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ Binder.getCallingPid());
  }
  if (packageUid != -1 && UserHandle.isSameApp(callingUid,Process.myUid())) {
    callingUid=packageUid;
  }
  checkReadAccountsPermission();
  long identityToken=clearCallingIdentity();
  try {
    UserAccounts accounts=getUserAccounts(userId);
synchronized (accounts.cacheLock) {
      return getAccountsFromCacheLocked(accounts,type,callingUid,callingPackage);
    }
  }
  finally {
    restoreCallingIdentity(identityToken);
  }
}",0.7585886722376973
194973,"@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  mHeadsUpManager.setIsExpanded(!isFullyCollapsed());
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}","@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  updatePanelExpanded();
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}",0.9693924166285977
194974,"void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setStatusBarExpanded(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}","void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setPanelVisible(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}",0.97351598173516
194975,"void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setStatusBarExpanded(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}","void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setPanelVisible(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}",0.9838978345363688
194976,"private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.statusBarExpanded || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}","private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.panelVisible || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}",0.9588652482269504
194977,"private void applyFocusableFlag(State state){
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && state.statusBarExpanded) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || state.statusBarFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}","private void applyFocusableFlag(State state){
  boolean panelFocusable=state.statusBarFocusable && state.panelExpanded;
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}",0.9148797920727744
194978,"@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  mHeadsUpManager.setIsExpanded(!isFullyCollapsed());
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}","@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  updatePanelExpanded();
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}",0.9693924166285977
194979,"void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setStatusBarExpanded(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}","void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setPanelVisible(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}",0.97351598173516
194980,"void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setStatusBarExpanded(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}","void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setPanelVisible(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}",0.9838978345363688
194981,"private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.statusBarExpanded || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}","private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.panelVisible || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}",0.9588652482269504
194982,"private void applyFocusableFlag(State state){
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && state.statusBarExpanded) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || state.statusBarFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}","private void applyFocusableFlag(State state){
  boolean panelFocusable=state.statusBarFocusable && state.panelExpanded;
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}",0.9148797920727744
194983,"@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  mHeadsUpManager.setIsExpanded(!isFullyCollapsed());
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}","@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  updatePanelExpanded();
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}",0.9693924166285977
194984,"void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setStatusBarExpanded(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}","void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setPanelVisible(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}",0.97351598173516
194985,"void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setStatusBarExpanded(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}","void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setPanelVisible(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}",0.9838978345363688
194986,"private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.statusBarExpanded || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}","private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.panelVisible || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}",0.9588652482269504
194987,"private void applyFocusableFlag(State state){
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && state.statusBarExpanded) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || state.statusBarFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}","private void applyFocusableFlag(State state){
  boolean panelFocusable=state.statusBarFocusable && state.panelExpanded;
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}",0.9148797920727744
194988,"@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  mHeadsUpManager.setIsExpanded(!isFullyCollapsed());
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}","@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  updatePanelExpanded();
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}",0.9693924166285977
194989,"void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setStatusBarExpanded(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}","void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setPanelVisible(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}",0.97351598173516
194990,"void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setStatusBarExpanded(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}","void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setPanelVisible(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}",0.9838978345363688
194991,"private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.statusBarExpanded || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}","private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.panelVisible || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}",0.9588652482269504
194992,"private void applyFocusableFlag(State state){
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && state.statusBarExpanded) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || state.statusBarFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}","private void applyFocusableFlag(State state){
  boolean panelFocusable=state.statusBarFocusable && state.panelExpanded;
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}",0.9148797920727744
194993,"@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  mHeadsUpManager.setIsExpanded(!isFullyCollapsed());
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}","@Override protected void onHeightUpdated(float expandedHeight){
  if (!mQsExpanded || mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    positionClockAndNotifications();
  }
  if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
    float t;
    if (mKeyguardShowing) {
      t=expandedHeight / getMaxPanelHeight();
    }
 else {
      float panelHeightQsCollapsed=mNotificationStackScroller.getIntrinsicPadding() + mNotificationStackScroller.getMinStackHeight();
      float panelHeightQsExpanded=calculatePanelHeightQsExpanded();
      t=(expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
    }
    setQsExpansion(mQsMinExpansionHeight + t * (getTempQsMaxExpansion() - mQsMinExpansionHeight));
  }
  updateStackHeight(expandedHeight);
  updateHeader();
  updateUnlockIcon();
  updateNotificationTranslucency();
  updatePanelExpanded();
  mNotificationStackScroller.setShadeExpanded(!isFullyCollapsed());
  if (DEBUG) {
    invalidate();
  }
}",0.9693924166285977
194994,"void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setStatusBarExpanded(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}","void makeExpandedVisible(boolean force){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible);
  if (!force && (mExpandedVisible || !panelsEnabled())) {
    return;
  }
  mExpandedVisible=true;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(true);
  mStatusBarWindowManager.setPanelVisible(true);
  mStatusBarView.setFocusable(false);
  visibilityChanged(true);
  mWaitingForKeyguardExit=false;
  disable(mDisabledUnmodified1,mDisabledUnmodified2,!force);
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,true);
}",0.97351598173516
194995,"void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setStatusBarExpanded(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}","void makeExpandedInvisible(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible || mStatusBarWindow == null) {
    return;
  }
  mStatusBarView.collapseAllPanels(false,false,1.0f);
  mNotificationPanel.closeQs();
  mExpandedVisible=false;
  if (mNavigationBarView != null)   mNavigationBarView.setSlippery(false);
  visibilityChanged(false);
  mStatusBarWindowManager.setPanelVisible(false);
  mStatusBarWindowManager.setForceStatusBarVisible(false);
  mStatusBarView.setFocusable(true);
  dismissPopups();
  runPostCollapseRunnables();
  setInteracting(StatusBarManager.WINDOW_STATUS_BAR,false);
  showBouncer();
  disable(mDisabledUnmodified1,mDisabledUnmodified2,true);
  if (!mStatusBarKeyguardViewManager.isShowing()) {
    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
}",0.9838978345363688
194996,"private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.statusBarExpanded || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}","private void applyHeight(State state){
  boolean expanded=!state.forceCollapsed && (state.isKeyguardShowingAndNotOccluded() || state.panelVisible || state.keyguardFadingAway|| state.bouncerShowing|| state.headsUpShowing);
  if (expanded) {
    mLpChanged.height=ViewGroup.LayoutParams.MATCH_PARENT;
  }
 else {
    mLpChanged.height=mBarHeight;
  }
}",0.9588652482269504
194997,"private void applyFocusableFlag(State state){
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && state.statusBarExpanded) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || state.statusBarFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}","private void applyFocusableFlag(State state){
  boolean panelFocusable=state.statusBarFocusable && state.panelExpanded;
  if (state.isKeyguardShowingAndNotOccluded() && state.keyguardNeedsInput && state.bouncerShowing || BaseStatusBar.ENABLE_REMOTE_INPUT && panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else   if (state.isKeyguardShowingAndNotOccluded() || panelFocusable) {
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
 else {
    mLpChanged.flags|=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    mLpChanged.flags&=~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
  }
}",0.9148797920727744
194998,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxViewHeight;
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int maxChildHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE || isChildInvisible(child)) {
      continue;
    }
    int childHeightSpec=newHeightSpec;
    ViewGroup.LayoutParams layoutParams=child.getLayoutParams();
    if (layoutParams.height != ViewGroup.LayoutParams.MATCH_PARENT) {
      if (layoutParams.height >= 0) {
        childHeightSpec=layoutParams.height > ownMaxHeight ? MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(layoutParams.height,MeasureSpec.EXACTLY);
      }
      child.measure(getChildMeasureSpec(widthMeasureSpec,0,layoutParams.width),childHeightSpec);
      int childHeight=child.getMeasuredHeight();
      maxChildHeight=Math.max(maxChildHeight,childHeight);
    }
 else {
      mMatchParentViews.add(child);
    }
  }
  int ownHeight=Math.min(ownMaxHeight,maxChildHeight);
  newHeightSpec=MeasureSpec.makeMeasureSpec(ownHeight,MeasureSpec.EXACTLY);
  for (  View child : mMatchParentViews) {
    child.measure(getChildMeasureSpec(widthMeasureSpec,0,child.getLayoutParams().width),newHeightSpec);
  }
  mMatchParentViews.clear();
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (canHaveBottomDecor()) {
    ownHeight+=mBottomDecorHeight;
  }
  setMeasuredDimension(width,ownHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxViewHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  if (hasFixedHeight) {
    ownMaxHeight=Math.min(MeasureSpec.getSize(heightMeasureSpec),ownMaxHeight);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int maxChildHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE || isChildInvisible(child)) {
      continue;
    }
    int childHeightSpec=newHeightSpec;
    ViewGroup.LayoutParams layoutParams=child.getLayoutParams();
    if (layoutParams.height != ViewGroup.LayoutParams.MATCH_PARENT) {
      if (layoutParams.height >= 0) {
        childHeightSpec=layoutParams.height > ownMaxHeight ? MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(layoutParams.height,MeasureSpec.EXACTLY);
      }
      child.measure(getChildMeasureSpec(widthMeasureSpec,0,layoutParams.width),childHeightSpec);
      int childHeight=child.getMeasuredHeight();
      maxChildHeight=Math.max(maxChildHeight,childHeight);
    }
 else {
      mMatchParentViews.add(child);
    }
  }
  int ownHeight=hasFixedHeight ? ownMaxHeight : Math.min(ownMaxHeight,maxChildHeight);
  newHeightSpec=MeasureSpec.makeMeasureSpec(ownHeight,MeasureSpec.EXACTLY);
  for (  View child : mMatchParentViews) {
    child.measure(getChildMeasureSpec(widthMeasureSpec,0,child.getLayoutParams().width),newHeightSpec);
  }
  mMatchParentViews.clear();
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (canHaveBottomDecor()) {
    ownHeight+=mBottomDecorHeight;
  }
  setMeasuredDimension(width,ownHeight);
}",0.924255820807545
194999,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxViewHeight;
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int maxChildHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE || isChildInvisible(child)) {
      continue;
    }
    int childHeightSpec=newHeightSpec;
    ViewGroup.LayoutParams layoutParams=child.getLayoutParams();
    if (layoutParams.height != ViewGroup.LayoutParams.MATCH_PARENT) {
      if (layoutParams.height >= 0) {
        childHeightSpec=layoutParams.height > ownMaxHeight ? MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(layoutParams.height,MeasureSpec.EXACTLY);
      }
      child.measure(getChildMeasureSpec(widthMeasureSpec,0,layoutParams.width),childHeightSpec);
      int childHeight=child.getMeasuredHeight();
      maxChildHeight=Math.max(maxChildHeight,childHeight);
    }
 else {
      mMatchParentViews.add(child);
    }
  }
  int ownHeight=Math.min(ownMaxHeight,maxChildHeight);
  newHeightSpec=MeasureSpec.makeMeasureSpec(ownHeight,MeasureSpec.EXACTLY);
  for (  View child : mMatchParentViews) {
    child.measure(getChildMeasureSpec(widthMeasureSpec,0,child.getLayoutParams().width),newHeightSpec);
  }
  mMatchParentViews.clear();
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (canHaveBottomDecor()) {
    ownHeight+=mBottomDecorHeight;
  }
  setMeasuredDimension(width,ownHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxViewHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  if (hasFixedHeight) {
    ownMaxHeight=Math.min(MeasureSpec.getSize(heightMeasureSpec),ownMaxHeight);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int maxChildHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE || isChildInvisible(child)) {
      continue;
    }
    int childHeightSpec=newHeightSpec;
    ViewGroup.LayoutParams layoutParams=child.getLayoutParams();
    if (layoutParams.height != ViewGroup.LayoutParams.MATCH_PARENT) {
      if (layoutParams.height >= 0) {
        childHeightSpec=layoutParams.height > ownMaxHeight ? MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(layoutParams.height,MeasureSpec.EXACTLY);
      }
      child.measure(getChildMeasureSpec(widthMeasureSpec,0,layoutParams.width),childHeightSpec);
      int childHeight=child.getMeasuredHeight();
      maxChildHeight=Math.max(maxChildHeight,childHeight);
    }
 else {
      mMatchParentViews.add(child);
    }
  }
  int ownHeight=hasFixedHeight ? ownMaxHeight : Math.min(ownMaxHeight,maxChildHeight);
  newHeightSpec=MeasureSpec.makeMeasureSpec(ownHeight,MeasureSpec.EXACTLY);
  for (  View child : mMatchParentViews) {
    child.measure(getChildMeasureSpec(widthMeasureSpec,0,child.getLayoutParams().width),newHeightSpec);
  }
  mMatchParentViews.clear();
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (canHaveBottomDecor()) {
    ownHeight+=mBottomDecorHeight;
  }
  setMeasuredDimension(width,ownHeight);
}",0.924255820807545
195000,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxViewHeight;
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int maxChildHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE || isChildInvisible(child)) {
      continue;
    }
    int childHeightSpec=newHeightSpec;
    ViewGroup.LayoutParams layoutParams=child.getLayoutParams();
    if (layoutParams.height != ViewGroup.LayoutParams.MATCH_PARENT) {
      if (layoutParams.height >= 0) {
        childHeightSpec=layoutParams.height > ownMaxHeight ? MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(layoutParams.height,MeasureSpec.EXACTLY);
      }
      child.measure(getChildMeasureSpec(widthMeasureSpec,0,layoutParams.width),childHeightSpec);
      int childHeight=child.getMeasuredHeight();
      maxChildHeight=Math.max(maxChildHeight,childHeight);
    }
 else {
      mMatchParentViews.add(child);
    }
  }
  int ownHeight=Math.min(ownMaxHeight,maxChildHeight);
  newHeightSpec=MeasureSpec.makeMeasureSpec(ownHeight,MeasureSpec.EXACTLY);
  for (  View child : mMatchParentViews) {
    child.measure(getChildMeasureSpec(widthMeasureSpec,0,child.getLayoutParams().width),newHeightSpec);
  }
  mMatchParentViews.clear();
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (canHaveBottomDecor()) {
    ownHeight+=mBottomDecorHeight;
  }
  setMeasuredDimension(width,ownHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxViewHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  if (hasFixedHeight) {
    ownMaxHeight=Math.min(MeasureSpec.getSize(heightMeasureSpec),ownMaxHeight);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int maxChildHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE || isChildInvisible(child)) {
      continue;
    }
    int childHeightSpec=newHeightSpec;
    ViewGroup.LayoutParams layoutParams=child.getLayoutParams();
    if (layoutParams.height != ViewGroup.LayoutParams.MATCH_PARENT) {
      if (layoutParams.height >= 0) {
        childHeightSpec=layoutParams.height > ownMaxHeight ? MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(layoutParams.height,MeasureSpec.EXACTLY);
      }
      child.measure(getChildMeasureSpec(widthMeasureSpec,0,layoutParams.width),childHeightSpec);
      int childHeight=child.getMeasuredHeight();
      maxChildHeight=Math.max(maxChildHeight,childHeight);
    }
 else {
      mMatchParentViews.add(child);
    }
  }
  int ownHeight=hasFixedHeight ? ownMaxHeight : Math.min(ownMaxHeight,maxChildHeight);
  newHeightSpec=MeasureSpec.makeMeasureSpec(ownHeight,MeasureSpec.EXACTLY);
  for (  View child : mMatchParentViews) {
    child.measure(getChildMeasureSpec(widthMeasureSpec,0,child.getLayoutParams().width),newHeightSpec);
  }
  mMatchParentViews.clear();
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (canHaveBottomDecor()) {
    ownHeight+=mBottomDecorHeight;
  }
  setMeasuredDimension(width,ownHeight);
}",0.924255820807545
