record_number,buggy_code,fixed_code,code_similarity
22001,"/** 
 * Build the check box for showing the PMD perspective
 * @param viewGroup the parent composite
 */
private Button buildCheckCodeOnSaveButton(Composite viewGroup){
  Button button=new Button(viewGroup,SWT.CHECK);
  button.setText(""String_Node_Str"");
  button.setSelection(preferences.isCheckAfterSaveEnabled());
  return button;
}","/** 
 * Build the check box for showing the PMD perspective
 * @param viewGroup the parent composite
 */
private Button buildCheckCodeOnSaveButton(Composite viewGroup){
  Button button=new Button(viewGroup,SWT.CHECK);
  button.setText(""String_Node_Str"");
  button.setSelection(preferences.isCheckAfterSaveEnabled());
  button.setEnabled(false);
  return button;
}",0.9598853868194842
22002,"/** 
 * Build the group of general preferences
 * @param parent the parent composite
 * @return the group widget
 */
private Group buildGeneralGroup(final Composite parent){
  Group group=new Group(parent,SWT.SHADOW_IN);
  group.setText(getMessage(StringKeys.MSGKEY_PREF_GENERAL_GROUP_GENERAL));
  group.setLayout(new GridLayout(1,false));
  showPerspectiveBox=buildShowPerspectiveBoxButton(group);
  useProjectBuildPath=buildUseProjectBuildPathButton(group);
  checkCodeOnSave=buildCheckCodeOnSaveButton(group);
  Label separator=new Label(group,SWT.SEPARATOR | SWT.SHADOW_IN | SWT.HORIZONTAL);
  maxViolationsPerFilePerRule=buildMaxViolationsPerFilePerRuleText(group);
  GridData data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  this.showPerspectiveBox.setLayoutData(data);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  this.useProjectBuildPath.setLayoutData(data);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  separator.setLayoutData(data);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  maxViolationsPerFilePerRule.setLayoutData(data);
  return group;
}","/** 
 * Build the group of general preferences
 * @param parent the parent composite
 * @return the group widget
 */
private Group buildGeneralGroup(final Composite parent){
  Group group=new Group(parent,SWT.SHADOW_IN);
  group.setText(getMessage(StringKeys.MSGKEY_PREF_GENERAL_GROUP_GENERAL));
  group.setLayout(new GridLayout(1,false));
  showPerspectiveBox=buildShowPerspectiveBoxButton(group);
  useProjectBuildPath=buildUseProjectBuildPathButton(group);
  checkCodeOnSave=buildCheckCodeOnSaveButton(group);
  Label separator=new Label(group,SWT.SEPARATOR | SWT.SHADOW_IN | SWT.HORIZONTAL);
  maxViolationsPerFilePerRule=buildMaxViolationsPerFilePerRuleText(group);
  GridData data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  showPerspectiveBox.setLayoutData(data);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  useProjectBuildPath.setLayoutData(data);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  separator.setLayoutData(data);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.grabExcessHorizontalSpace=true;
  maxViolationsPerFilePerRule.setLayoutData(data);
  return group;
}",0.996114996114996
22003,"private Text buildNameText(Composite parent){
  int style=usageMode == EditorUsageMode.CreateNew ? SWT.SINGLE | SWT.BORDER : SWT.READ_ONLY | SWT.BORDER;
  final Text nameField=new Text(parent,style);
  nameField.setFocus();
  Listener validateListener=new Listener(){
    public void handleEvent(    Event event){
      validateRuleParams();
    }
  }
;
  nameField.addListener(SWT.Modify,validateListener);
  nameField.addListener(SWT.DefaultSelection,validateListener);
  return nameField;
}","private Text buildNameText(Composite parent){
  int style=creatingNewRule() ? SWT.SINGLE | SWT.BORDER : SWT.READ_ONLY | SWT.BORDER;
  final Text nameField=new Text(parent,style);
  nameField.setFocus();
  Listener validateListener=new Listener(){
    public void handleEvent(    Event event){
      validateRuleParams();
    }
  }
;
  nameField.addListener(SWT.Modify,validateListener);
  nameField.addListener(SWT.DefaultSelection,validateListener);
  return nameField;
}",0.9512953367875648
22004,"private void validateRuleParams(){
  boolean isOk=validate();
  if (isOk && usageMode == EditorUsageMode.CreateNew) {
    populateRuleInstance();
  }
  if (inSetup)   return;
  if (target != null) {
    target.rule(isOk ? rules.soleRule() : null);
  }
}","private void validateRuleParams(){
  boolean isOk=validate();
  if (isOk && creatingNewRule()) {
    populateRuleInstance();
  }
  if (inSetup)   return;
  if (target != null) {
    target.rule(isOk ? rules.soleRule() : null);
  }
}",0.9030927835051548
22005,"private Combo buildRuleSetNameField(Composite parent){
  int style=usageMode == EditorUsageMode.CreateNew ? SWT.BORDER : SWT.READ_ONLY;
  Combo field=new Combo(parent,style);
  Set<RuleSet> rs=PMDPlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();
  RuleSet[] ruleSets=rs.toArray(new RuleSet[rs.size()]);
  Arrays.sort(ruleSets,byNameComparator);
  for (  RuleSet ruleSet : ruleSets) {
    field.add(ruleSet.getName());
  }
  Listener validateListener=new Listener(){
    public void handleEvent(    Event event){
      validateRuleParams();
    }
  }
;
  field.addListener(SWT.Modify,validateListener);
  field.addListener(SWT.DefaultSelection,validateListener);
  return field;
}","private Combo buildRuleSetNameField(Composite parent){
  int style=creatingNewRule() ? SWT.BORDER : SWT.READ_ONLY;
  Combo field=new Combo(parent,style);
  Set<RuleSet> rs=PMDPlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();
  RuleSet[] ruleSets=rs.toArray(new RuleSet[rs.size()]);
  Arrays.sort(ruleSets,byNameComparator);
  for (  RuleSet ruleSet : ruleSets) {
    field.add(ruleSet.getName());
  }
  Listener validateListener=new Listener(){
    public void handleEvent(    Event event){
      validateRuleParams();
    }
  }
;
  field.addListener(SWT.Modify,validateListener);
  field.addListener(SWT.DefaultSelection,validateListener);
  return field;
}",0.964155084125823
22006,"private TypeText buildImplementationClassField(Composite parent){
  int style=usageMode == EditorUsageMode.CreateNew ? SWT.SINGLE | SWT.BORDER : SWT.READ_ONLY | SWT.BORDER;
  final TypeText classField=new TypeText(parent,style,true,""String_Node_Str"");
  classField.setEnabled(false);
  Listener validateListener=new Listener(){
    public void handleEvent(    Event event){
      validateRuleParams();
    }
  }
;
  classField.addListener(SWT.FocusOut,validateListener);
  classField.addListener(SWT.DefaultSelection,validateListener);
  return classField;
}","private TypeText buildImplementationClassField(Composite parent){
  int style=creatingNewRule() ? SWT.SINGLE | SWT.BORDER : SWT.READ_ONLY | SWT.BORDER;
  final TypeText classField=new TypeText(parent,style,true,""String_Node_Str"");
  classField.setEnabled(false);
  Listener validateListener=new Listener(){
    public void handleEvent(    Event event){
      validateRuleParams();
    }
  }
;
  classField.addListener(SWT.FocusOut,validateListener);
  classField.addListener(SWT.DefaultSelection,validateListener);
  return classField;
}",0.9570776255707762
22007,"@Override public Control setupOn(Composite parent){
  inSetup=true;
  labels=new ArrayList<Label>();
  Composite dlgArea=new Composite(parent,SWT.NONE);
  GridLayout gridLayout=new GridLayout();
  gridLayout.numColumns=4;
  dlgArea.setLayout(gridLayout);
  Label nameLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_NAME);
  GridData data=new GridData();
  data.horizontalSpan=1;
  nameLabel.setLayoutData(data);
  labels.add(nameLabel);
  nameField=buildNameText(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  nameField.setLayoutData(data);
  Label ruleSetNameLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_RULESET_NAME);
  data=new GridData();
  data.horizontalSpan=1;
  ruleSetNameLabel.setLayoutData(data);
  labels.add(ruleSetNameLabel);
  ruleSetNameField=buildRuleSetNameField(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  ruleSetNameField.setLayoutData(data);
  Label implTypeLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_IMPLEMENTED_BY);
  data=new GridData();
  data.horizontalSpan=1;
  implTypeLabel.setLayoutData(data);
  labels.add(implTypeLabel);
  implementationTypeCombo=buildImplementationTypeCombo(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  implementationTypeCombo.setLayoutData(data);
  Label implementationClassLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_IMPLEMENTATION_CLASS);
  data=new GridData();
  data.horizontalSpan=1;
  implementationClassLabel.setLayoutData(data);
  labels.add(implementationClassLabel);
  implementationClassField=buildImplementationClassField(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  implementationClassField.setLayoutData(data);
  buildLabel(dlgArea,null);
  usesTypeResolutionButton=buildUsesTypeResolutionButton(dlgArea);
  usesDfaButton=buildUsesDfaButton(dlgArea);
  buildLabel(dlgArea,null);
  Label languageLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_LANGUAGE);
  data=new GridData();
  data.horizontalSpan=1;
  languageLabel.setLayoutData(data);
  labels.add(languageLabel);
  languageCombo=buildLanguageCombo(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  languageCombo.setLayoutData(data);
  GridData lblGD=new GridData();
  lblGD.horizontalSpan=1;
  lblGD.horizontalAlignment=SWT.END;
  GridData cmboGD=new GridData();
  cmboGD.horizontalAlignment=GridData.FILL;
  cmboGD.horizontalSpan=2;
  cmboGD.grabExcessHorizontalSpace=true;
  buildLabel(dlgArea,null);
  minLanguageLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_LANGUAGE_MIN);
  minLanguageLabel.setAlignment(SWT.RIGHT);
  minLanguageLabel.setLayoutData(lblGD);
  labels.add(minLanguageLabel);
  minLanguageVersionCombo=buildLanguageVersionCombo(dlgArea,true);
  minLanguageVersionCombo.setLayoutData(cmboGD);
  buildLabel(dlgArea,null);
  maxLanguageLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_LANGUAGE_MAX);
  maxLanguageLabel.setAlignment(SWT.RIGHT);
  maxLanguageLabel.setLayoutData(lblGD);
  labels.add(maxLanguageLabel);
  maxLanguageVersionCombo=buildLanguageVersionCombo(dlgArea,false);
  maxLanguageVersionCombo.setLayoutData(cmboGD);
  Label priorityLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_PRIORITY);
  data=new GridData();
  data.horizontalSpan=1;
  priorityLabel.setLayoutData(data);
  labels.add(priorityLabel);
  Composite priorityComp=new Composite(dlgArea,0);
  priorityComp.setLayout(new GridLayout(2,false));
  priorityComp.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,false,false,2,1));
  priorityCombo=buildPriorityCombo(priorityComp);
  priorityCombo.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,false,false,1,1));
  priorityDisplay=new ShapePicker(priorityComp,SWT.NONE,14);
  priorityDisplay.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,true,false,1,1));
  priorityDisplay.setShapeMap(UISettings.shapesByPriority());
  priorityDisplay.setSize(90,25);
  if (usageMode == EditorUsageMode.CreateNew) {
    implementationType(ImplementationType.XPath);
  }
  setControl(dlgArea);
  validate();
  inSetup=false;
  return dlgArea;
}","@Override public Control setupOn(Composite parent){
  inSetup=true;
  labels=new ArrayList<Label>();
  Composite dlgArea=new Composite(parent,SWT.NONE);
  GridLayout gridLayout=new GridLayout();
  gridLayout.numColumns=4;
  dlgArea.setLayout(gridLayout);
  Label nameLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_NAME);
  GridData data=new GridData();
  data.horizontalSpan=1;
  nameLabel.setLayoutData(data);
  labels.add(nameLabel);
  nameField=buildNameText(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  nameField.setLayoutData(data);
  Label ruleSetNameLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_RULESET_NAME);
  data=new GridData();
  data.horizontalSpan=1;
  ruleSetNameLabel.setLayoutData(data);
  labels.add(ruleSetNameLabel);
  ruleSetNameField=buildRuleSetNameField(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  ruleSetNameField.setLayoutData(data);
  Label implTypeLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_IMPLEMENTED_BY);
  data=new GridData();
  data.horizontalSpan=1;
  implTypeLabel.setLayoutData(data);
  labels.add(implTypeLabel);
  implementationTypeCombo=buildImplementationTypeCombo(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  implementationTypeCombo.setLayoutData(data);
  Label implementationClassLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_IMPLEMENTATION_CLASS);
  data=new GridData();
  data.horizontalSpan=1;
  implementationClassLabel.setLayoutData(data);
  labels.add(implementationClassLabel);
  implementationClassField=buildImplementationClassField(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  implementationClassField.setLayoutData(data);
  buildLabel(dlgArea,null);
  usesTypeResolutionButton=buildUsesTypeResolutionButton(dlgArea);
  usesDfaButton=buildUsesDfaButton(dlgArea);
  buildLabel(dlgArea,null);
  Label languageLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_LANGUAGE);
  data=new GridData();
  data.horizontalSpan=1;
  languageLabel.setLayoutData(data);
  labels.add(languageLabel);
  languageCombo=buildLanguageCombo(dlgArea);
  data=new GridData();
  data.horizontalAlignment=GridData.FILL;
  data.horizontalSpan=3;
  data.grabExcessHorizontalSpace=true;
  languageCombo.setLayoutData(data);
  GridData lblGD=new GridData();
  lblGD.horizontalSpan=1;
  lblGD.horizontalAlignment=SWT.END;
  GridData cmboGD=new GridData();
  cmboGD.horizontalAlignment=GridData.FILL;
  cmboGD.horizontalSpan=2;
  cmboGD.grabExcessHorizontalSpace=true;
  buildLabel(dlgArea,null);
  minLanguageLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_LANGUAGE_MIN);
  minLanguageLabel.setAlignment(SWT.RIGHT);
  minLanguageLabel.setLayoutData(lblGD);
  labels.add(minLanguageLabel);
  minLanguageVersionCombo=buildLanguageVersionCombo(dlgArea,true);
  minLanguageVersionCombo.setLayoutData(cmboGD);
  buildLabel(dlgArea,null);
  maxLanguageLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_LANGUAGE_MAX);
  maxLanguageLabel.setAlignment(SWT.RIGHT);
  maxLanguageLabel.setLayoutData(lblGD);
  labels.add(maxLanguageLabel);
  maxLanguageVersionCombo=buildLanguageVersionCombo(dlgArea,false);
  maxLanguageVersionCombo.setLayoutData(cmboGD);
  Label priorityLabel=buildLabel(dlgArea,StringKeys.PREF_RULEEDIT_LABEL_PRIORITY);
  data=new GridData();
  data.horizontalSpan=1;
  priorityLabel.setLayoutData(data);
  labels.add(priorityLabel);
  Composite priorityComp=new Composite(dlgArea,0);
  priorityComp.setLayout(new GridLayout(2,false));
  priorityComp.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,false,false,2,1));
  priorityCombo=buildPriorityCombo(priorityComp);
  priorityCombo.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,false,false,1,1));
  priorityDisplay=new ShapePicker(priorityComp,SWT.NONE,14);
  priorityDisplay.setLayoutData(new GridData(SWT.LEFT,SWT.CENTER,true,false,1,1));
  priorityDisplay.setShapeMap(UISettings.shapesByPriority());
  priorityDisplay.setSize(90,25);
  if (creatingNewRule()) {
    implementationType(ImplementationType.XPath);
  }
  setControl(dlgArea);
  validate();
  inSetup=false;
  return dlgArea;
}",0.994467652704076
22008,"protected List<String> fieldErrors(){
  List<String> errors=new ArrayList<String>();
  if (!hasValidRuleType())   errors.add(""String_Node_Str"");
  if (!hasValidRuleName())   errors.add(""String_Node_Str"");
  if (!hasValidRulesetName())   errors.add(""String_Node_Str"");
  if (languageCombo.getSelectionIndex() < 0)   errors.add(""String_Node_Str"");
  return errors;
}","protected List<String> fieldErrors(){
  List<String> errors=new ArrayList<String>();
  if (!hasValidRuleType())   errors.add(""String_Node_Str"");
  if (!hasValidRuleName())   errors.add(""String_Node_Str"");
  if (creatingNewRule() && hasExistingRuleName())   errors.add(""String_Node_Str"");
  if (!hasValidRulesetName())   errors.add(""String_Node_Str"");
  if (languageCombo.getSelectionIndex() < 0)   errors.add(""String_Node_Str"");
  return errors;
}",0.8976572133168927
22009,"@Override protected void adapt(){
  show(ruleSetNameField,RuleUtil.commonRuleset(rules));
  Language language=RuleUtil.commonLanguage(rules);
  show(languageCombo,language == null ? ""String_Node_Str"" : language.getName());
  ImplementationType impType=rules == null ? ImplementationType.Mixed : rules.implementationType();
  implementationType(impType);
  implementationTypeCombo.setEnabled(usageMode == EditorUsageMode.CreateNew);
  Class<?> impClass=RuleUtil.commonImplementationClass(rules);
  show(implementationClassField,impClass);
  implementationClassField.setEnabled(impClass != null);
  show(priorityCombo,commonPriorityName());
  priorityDisplay.setItems(uniquePriorities().toArray());
  show(usesTypeResolutionButton,allRulesUseTypeResolution());
  show(usesDfaButton,allRulesUseDfa());
  showLanguageVersionFields(language);
  show(minLanguageVersionCombo,commonLanguageMinVersionName());
  show(maxLanguageVersionCombo,commonLanguageMaxVersionName());
  Rule soleRule=soleRule();
  if (soleRule == null) {
    shutdown(nameField);
  }
 else {
    show(nameField,asCleanString(soleRule.getName()));
  }
  validate();
}","@Override protected void adapt(){
  show(ruleSetNameField,RuleUtil.commonRuleset(rules));
  Language language=RuleUtil.commonLanguage(rules);
  show(languageCombo,language == null ? ""String_Node_Str"" : language.getName());
  ImplementationType impType=rules == null ? ImplementationType.Mixed : rules.implementationType();
  implementationType(impType);
  implementationTypeCombo.setEnabled(creatingNewRule());
  Class<?> impClass=RuleUtil.commonImplementationClass(rules);
  show(implementationClassField,impClass);
  implementationClassField.setEnabled(impClass != null);
  show(priorityCombo,commonPriorityName());
  priorityDisplay.setItems(uniquePriorities().toArray());
  show(usesTypeResolutionButton,allRulesUseTypeResolution());
  show(usesDfaButton,allRulesUseDfa());
  showLanguageVersionFields(language);
  show(minLanguageVersionCombo,commonLanguageMinVersionName());
  show(maxLanguageVersionCombo,commonLanguageMaxVersionName());
  Rule soleRule=soleRule();
  if (soleRule == null) {
    shutdown(nameField);
  }
 else {
    show(nameField,asCleanString(soleRule.getName()));
  }
  validate();
}",0.9781347612672914
22010,"private Combo buildLanguageVersionCombo(Composite parent,final boolean isMinVersion){
  int style=usageMode == EditorUsageMode.CreateNew ? SWT.SINGLE | SWT.BORDER : SWT.READ_ONLY | SWT.BORDER;
  final Combo combo=new Combo(parent,style);
  combo.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent event){
      if (rules == null)       return;
      final LanguageVersion version=selectedLanguage().getVersions().get(combo.getSelectionIndex());
      RuleVisitor visitor=new RuleVisitor(){
        public boolean accept(        Rule rule){
          if (isMinVersion) {
            rule.setMinimumLanguageVersion(version);
          }
 else {
            rule.setMaximumLanguageVersion(version);
          }
          return true;
        }
      }
;
      rules.rulesDo(visitor);
      valueChanged(null,version.getName());
    }
  }
);
  return combo;
}","private Combo buildLanguageVersionCombo(Composite parent,final boolean isMinVersion){
  int style=creatingNewRule() ? SWT.SINGLE | SWT.BORDER : SWT.READ_ONLY | SWT.BORDER;
  final Combo combo=new Combo(parent,style);
  combo.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent event){
      if (rules == null)       return;
      final LanguageVersion version=selectedLanguage().getVersions().get(combo.getSelectionIndex());
      RuleVisitor visitor=new RuleVisitor(){
        public boolean accept(        Rule rule){
          if (isMinVersion) {
            rule.setMinimumLanguageVersion(version);
          }
 else {
            rule.setMaximumLanguageVersion(version);
          }
          return true;
        }
      }
;
      rules.rulesDo(visitor);
      valueChanged(null,version.getName());
    }
  }
);
  return combo;
}",0.972425436128306
22011,"private void implementationType(ImplementationType type){
switch (type) {
case XPath:
{
      implementationClassField.setEnabled(false);
      usesTypeResolutionButton.setEnabled(false);
      usesTypeResolutionButton.setSelection(true);
      usesDfaButton.setEnabled(false);
      usesDfaButton.setSelection(false);
      implementationTypeCombo.select(0);
      if (usageMode == EditorUsageMode.CreateNew) {
        implementationClassField.setType(XPathRule.class);
      }
      break;
    }
case Java:
{
    implementationClassField.setEnabled(true);
    usesTypeResolutionButton.setEnabled(true);
    usesTypeResolutionButton.setSelection(true);
    usesDfaButton.setEnabled(true);
    usesDfaButton.setSelection(false);
    implementationTypeCombo.select(1);
    if (usageMode == EditorUsageMode.CreateNew) {
      implementationClassField.setType(null);
    }
    break;
  }
case Mixed:
{
  implementationTypeCombo.deselectAll();
}
}
validateRuleParams();
}","private void implementationType(ImplementationType type){
switch (type) {
case XPath:
{
      implementationClassField.setEnabled(false);
      usesTypeResolutionButton.setEnabled(false);
      usesTypeResolutionButton.setSelection(true);
      usesDfaButton.setEnabled(false);
      usesDfaButton.setSelection(false);
      implementationTypeCombo.select(0);
      if (creatingNewRule()) {
        implementationClassField.setType(XPathRule.class);
      }
      break;
    }
case Java:
{
    implementationClassField.setEnabled(true);
    usesTypeResolutionButton.setEnabled(true);
    usesTypeResolutionButton.setSelection(true);
    usesDfaButton.setEnabled(true);
    usesDfaButton.setSelection(false);
    implementationTypeCombo.select(1);
    if (creatingNewRule()) {
      implementationClassField.setType(null);
    }
    break;
  }
case Mixed:
{
  implementationTypeCombo.deselectAll();
}
}
validateRuleParams();
}",0.7970401691331924
22012,"public void addListener(int eventType,Listener listener){
  text.addListener(eventType,listener);
}","public void addListener(int eventType,Listener listener){
  super.addListener(eventType,listener);
  if (text == null)   return;
  text.addListener(eventType,listener);
}",0.7360594795539034
22013,"/** 
 * Gets the fileRecord from the currently active editor (if it is one).
 * @param part IWorkbenchPart
 * @return a new FileRecord
 */
public FileRecord getFileRecordFromWorkbenchPart(IWorkbenchPart part){
  FileRecord record=tryForFileRecordFrom(part);
  if (record != null)   return record;
  IEditorPart editorPart=getSite().getPage().getActiveEditor();
  return editorPart == null ? null : getFileRecordFromWorkbenchPart(editorPart);
}","/** 
 * Gets the fileRecord from the currently active editor.
 * @param part IWorkbenchPart
 * @return a new FileRecord
 */
private FileRecord getFileRecordFromWorkbenchPart(IWorkbenchPart part){
  if (part instanceof IEditorPart) {
    IEditorInput input=((IEditorPart)part).getEditorInput();
    if (input != null && input instanceof IFileEditorInput) {
      IFile file=((IFileEditorInput)input).getFile();
      return AbstractDefaultCommand.isJavaFile(file) ? new FileRecord(file) : null;
    }
  }
 else {
    IEditorPart editorPart=getSite().getPage().getActiveEditor();
    if (editorPart != null) {
      return getFileRecordFromWorkbenchPart(editorPart);
    }
  }
  return null;
}",0.5661375661375662
22014,"private void setupResources(Display display){
  textLayout=new TextLayout(display);
  renderFont=new Font(display,""String_Node_Str"",10,SWT.NORMAL);
  italicFont=new Font(display,""String_Node_Str"",10,SWT.ITALIC);
  labelStyle=new TextStyle(renderFont,display.getSystemColor(SWT.COLOR_BLACK),null);
  imageStyle=new TextStyle(renderFont,display.getSystemColor(SWT.COLOR_BLUE),null);
  derivedStyle=new TextStyle(italicFont,display.getSystemColor(SWT.COLOR_DARK_MAGENTA),null);
}","private void setupResources(Display display){
  textLayout=new TextLayout(display);
  renderFont=new Font(display,""String_Node_Str"",10,SWT.NORMAL);
  italicFont=new Font(display,""String_Node_Str"",10,SWT.ITALIC);
  labelStyle=new TextStyle(renderFont,display.getSystemColor(SWT.COLOR_BLACK),null);
  imageStyle=new TextStyle(renderFont,display.getSystemColor(SWT.COLOR_BLUE),null);
  derivedStyle=new TextStyle(italicFont,display.getSystemColor(SWT.COLOR_GRAY),null);
}",0.9851694915254238
22015,"/** 
 * TODO use an adjustable Sash to separate the two sections TODO add an XPath version combo widget
 */
public void createControl(Composite parent){
  astFrame=new Composite(parent,SWT.NONE);
  GridLayout mainLayout=new GridLayout(3,false);
  astFrame.setLayout(mainLayout);
  Composite titleArea=new Composite(astFrame,SWT.NONE);
  GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.horizontalSpan=2;
  titleArea.setLayoutData(gridData);
  titleArea.setLayout(new GridLayout(4,false));
  Label showLabel=new Label(titleArea,0);
  showLabel.setText(""String_Node_Str"");
  final Button classBtn=new Button(titleArea,SWT.RADIO);
  classBtn.setText(""String_Node_Str"");
  classBtn.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent se){
      if (classBtn.getSelection())       showClass();
    }
  }
);
  final Button methodBtn=new Button(titleArea,SWT.RADIO);
  methodBtn.setText(""String_Node_Str"");
  methodBtn.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent se){
      methodSelector.setEnabled(methodBtn.getSelection());
      methodPicked();
    }
  }
);
  buildMethodSelector(titleArea);
  astViewer=new TreeViewer(astFrame);
  astViewer.setContentProvider(new ASTContentProvider());
  astViewer.setLabelProvider(new ASTLabelProvider());
  setupListeners(astViewer.getTree());
  GridData data=new GridData(GridData.FILL_BOTH);
  data.horizontalSpan=2;
  astViewer.getTree().setLayoutData(data);
  Composite xpathTestPanel=new Composite(astFrame,SWT.NONE);
  data=new GridData(GridData.FILL_BOTH);
  data.horizontalSpan=1;
  xpathTestPanel.setLayoutData(data);
  GridLayout playLayout=new GridLayout(2,false);
  xpathTestPanel.setLayout(playLayout);
  xpathField=new StyledText(xpathTestPanel,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  gridData=new GridData(GridData.FILL_BOTH);
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalSpan=1;
  xpathField.setLayoutData(gridData);
  SyntaxManager.adapt(xpathField,""String_Node_Str"",null);
  addXPathValidator();
  goButton=new Button(xpathTestPanel,SWT.PUSH);
  goButton.setText(""String_Node_Str"");
  gridData=new GridData(GridData.FILL_BOTH);
  gridData.grabExcessHorizontalSpace=false;
  gridData.horizontalSpan=1;
  goButton.setLayoutData(gridData);
  goButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      evaluateXPath();
    }
  }
);
  outputField=new StyledText(xpathTestPanel,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  gridData=new GridData(GridData.FILL_BOTH);
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalSpan=2;
  outputField.setLayoutData(gridData);
  SyntaxManager.adapt(outputField,""String_Node_Str"",null);
  registerListeners();
  showFirstMethod();
}","/** 
 * TODO use an adjustable Sash to separate the two sections TODO add an XPath version combo widget
 */
public void createControl(Composite parent){
  astFrame=new Composite(parent,SWT.NONE);
  GridLayout mainLayout=new GridLayout(3,false);
  astFrame.setLayout(mainLayout);
  Composite titleArea=new Composite(astFrame,SWT.NONE);
  GridData gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.horizontalSpan=2;
  titleArea.setLayoutData(gridData);
  titleArea.setLayout(new GridLayout(4,false));
  Label showLabel=new Label(titleArea,0);
  showLabel.setText(""String_Node_Str"");
  final Button classBtn=new Button(titleArea,SWT.RADIO);
  classBtn.setText(""String_Node_Str"");
  classBtn.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent se){
      if (classBtn.getSelection())       showClass();
    }
  }
);
  final Button methodBtn=new Button(titleArea,SWT.RADIO);
  methodBtn.setText(""String_Node_Str"");
  methodBtn.setSelection(true);
  methodBtn.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent se){
      methodSelector.setEnabled(methodBtn.getSelection());
      methodPicked();
    }
  }
);
  buildMethodSelector(titleArea);
  astViewer=new TreeViewer(astFrame);
  astViewer.setContentProvider(new ASTContentProvider());
  astViewer.setLabelProvider(new ASTLabelProvider());
  setupListeners(astViewer.getTree());
  GridData data=new GridData(GridData.FILL_BOTH);
  data.horizontalSpan=2;
  astViewer.getTree().setLayoutData(data);
  Composite xpathTestPanel=new Composite(astFrame,SWT.NONE);
  data=new GridData(GridData.FILL_BOTH);
  data.horizontalSpan=1;
  xpathTestPanel.setLayoutData(data);
  GridLayout playLayout=new GridLayout(2,false);
  xpathTestPanel.setLayout(playLayout);
  xpathField=new StyledText(xpathTestPanel,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  gridData=new GridData(GridData.FILL_BOTH);
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalSpan=1;
  xpathField.setLayoutData(gridData);
  SyntaxManager.adapt(xpathField,""String_Node_Str"",null);
  addXPathValidator();
  goButton=new Button(xpathTestPanel,SWT.PUSH);
  goButton.setText(""String_Node_Str"");
  gridData=new GridData(GridData.FILL_BOTH);
  gridData.grabExcessHorizontalSpace=false;
  gridData.horizontalSpan=1;
  goButton.setLayoutData(gridData);
  goButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      evaluateXPath();
    }
  }
);
  outputField=new StyledText(xpathTestPanel,SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
  gridData=new GridData(GridData.FILL_BOTH);
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalSpan=2;
  outputField.setLayoutData(gridData);
  SyntaxManager.adapt(outputField,""String_Node_Str"",null);
  registerListeners();
  showFirstMethod();
}",0.994358251057828
22016,"/** 
 * Build the text for maximum violations per file per rule
 * @param parent
 * @return
 */
private Spinner buildMaxViolationsPerFilePerRuleText(Composite parent){
  buildLabel(parent,StringKeys.MSGKEY_PREF_GENERAL_LABEL_MAX_VIOLATIONS_PFPR);
  final Spinner spinner=new Spinner(parent,SWT.SINGLE | SWT.BORDER);
  spinner.setMinimum(preferences.getMaxViolationsPerFilePerRule());
  spinner.setToolTipText(getMessage(StringKeys.MSGKEY_PREF_GENERAL_TOOLTIP_MAX_VIOLATIONS_PFPR));
  return spinner;
}","/** 
 * Build the text for maximum violations per file per rule
 * @param parent
 * @return
 */
private Spinner buildMaxViolationsPerFilePerRuleText(Composite parent){
  Composite comp=new Composite(parent,0);
  comp.setLayout(new GridLayout(2,false));
  Label label=buildLabel(comp,StringKeys.MSGKEY_PREF_GENERAL_LABEL_MAX_VIOLATIONS_PFPR);
  label.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING,GridData.VERTICAL_ALIGN_CENTER,false,false,1,1));
  final Spinner spinner=new Spinner(comp,SWT.SINGLE | SWT.BORDER);
  spinner.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING,GridData.VERTICAL_ALIGN_CENTER,true,false,1,1));
  spinner.setMinimum(preferences.getMaxViolationsPerFilePerRule());
  spinner.setToolTipText(getMessage(StringKeys.MSGKEY_PREF_GENERAL_TOOLTIP_MAX_VIOLATIONS_PFPR));
  return spinner;
}",0.7219730941704036
22017,"public void selection(RuleSelection selection){
  for (  RulePropertyManager manager : rulePropertyManagers) {
    manager.manage(selection);
    manager.validate();
  }
}","public void selection(RuleSelection selection){
  if (rulePropertyManagers == null)   return;
  for (  RulePropertyManager manager : rulePropertyManagers) {
    manager.manage(selection);
    manager.validate();
  }
}",0.7835051546391752
22018,"/** 
 * @see org.eclipse.jface.viewers.ITableLabelProvider#getColumnImage(Object,int)
 */
public Image getColumnImage(Object element,int columnIndex){
  if (element instanceof RuleCollection) {
    return columnDescriptors[columnIndex].imageFor((RuleCollection)element);
  }
  if (element instanceof Rule) {
    return columnDescriptors[columnIndex].imageFor((Rule)element);
  }
  return null;
}","/** 
 * @see org.eclipse.jface.viewers.ITableLabelProvider#getColumnImage(Object,int)
 */
public Image getColumnImage(Object element,int columnIndex){
  if (columnIndex <= 0)   return null;
  if (element instanceof RuleCollection) {
    return columnDescriptors[columnIndex - 1].imageFor((RuleCollection)element);
  }
  if (element instanceof Rule) {
    return columnDescriptors[columnIndex - 1].imageFor((Rule)element);
  }
  return null;
}",0.9438470728793308
22019,"/** 
 * @see org.eclipse.jface.viewers.ITableLabelProvider#getColumnText(Object,int)
 */
public String getColumnText(Object element,int columnIndex){
  if (element instanceof RuleCollection) {
    if (columnIndex == 0) {
      RuleGroup rg=(RuleGroup)element;
      String label=rg.label();
      return standardized(label,rg.ruleCount());
    }
    return columnDescriptors[columnIndex].stringValueFor((RuleCollection)element);
  }
  if (element instanceof Rule) {
    return columnDescriptors[columnIndex].stringValueFor((Rule)element);
  }
  return ""String_Node_Str"";
}","/** 
 * @see org.eclipse.jface.viewers.ITableLabelProvider#getColumnText(Object,int)
 */
public String getColumnText(Object element,int columnIndex){
  if (columnIndex <= 0)   return ""String_Node_Str"";
  if (element instanceof RuleCollection) {
    if (columnIndex == 1) {
      RuleGroup rg=(RuleGroup)element;
      String label=rg.label();
      return standardized(label,rg.ruleCount());
    }
    return columnDescriptors[columnIndex - 1].stringValueFor((RuleCollection)element);
  }
  if (element instanceof Rule) {
    String text=columnDescriptors[columnIndex - 1].stringValueFor((Rule)element);
    return columnIndex == 1 ? ""String_Node_Str"" + text : text;
  }
  return ""String_Node_Str"";
}",0.8710691823899371
22020,"public String getDetailText(Object element,int columnIndex){
  if (columnIndex < 0) {
    return ""String_Node_Str"";
  }
  if (element instanceof Rule) {
    Rule rule=(Rule)element;
    return columnDescriptors[columnIndex].detailStringFor(rule);
  }
  if (element instanceof RuleGroup) {
    RuleGroup group=(RuleGroup)element;
    return columnDescriptors[columnIndex].detailStringFor(group);
  }
  return ""String_Node_Str"";
}","public String getDetailText(Object element,int columnIndex){
  if (columnIndex <= 0)   return ""String_Node_Str"";
  if (element instanceof Rule) {
    Rule rule=(Rule)element;
    return columnDescriptors[columnIndex - 1].detailStringFor(rule);
  }
  if (element instanceof RuleGroup) {
    RuleGroup group=(RuleGroup)element;
    return columnDescriptors[columnIndex - 1].detailStringFor(group);
  }
  return ""String_Node_Str"";
}",0.9801633605600932
22021,"public boolean hasOneRule(){
  if (ruleItems.length > 1)   return false;
  return allRules().size() == 1;
}","public boolean hasOneRule(){
  if (ruleItems == null || ruleItems.length > 1)   return false;
  return allRules().size() == 1;
}",0.9106382978723404
22022,"/** 
 * @param columnDescs RuleColumnDescriptor[]
 * @param groupingField RuleFieldAccessor
 */
private void setupTreeColumns(RuleColumnDescriptor[] columnDescs,RuleFieldAccessor groupingField){
  Tree ruleTree=cleanupRuleTree();
  for (int i=0; i < columnDescs.length; i++)   columnDescs[i].newTreeColumnFor(ruleTree,i,this,paintListeners());
  treeViewer.setLabelProvider(new RuleLabelProvider(columnDescs));
  treeViewer.setContentProvider(new RuleSetTreeItemProvider(groupingField,""String_Node_Str"",Util.comparatorFrom(columnSorter,sortDescending)));
  treeViewer.setInput(ruleSet);
  checkSelections();
  TreeColumn[] columns=ruleTree.getColumns();
  for (  TreeColumn column : columns)   column.pack();
}","/** 
 * @param columnDescs RuleColumnDescriptor[]
 * @param groupingField RuleFieldAccessor
 */
private void setupTreeColumns(RuleColumnDescriptor[] columnDescs,RuleFieldAccessor groupingField){
  Tree ruleTree=cleanupRuleTree();
  createCheckBoxColumn(ruleTree);
  for (int i=0; i < columnDescs.length; i++) {
    TreeColumn tc=columnDescs[i].newTreeColumnFor(ruleTree,i + 1,this,paintListeners());
    if (i == 0 && groupingColumn != null) {
      tc.setText(labelFor(tc));
    }
  }
  treeViewer.setLabelProvider(new RuleLabelProvider(columnDescs));
  treeViewer.setContentProvider(new RuleSetTreeItemProvider(groupingField,""String_Node_Str"",Util.comparatorFrom(columnSorter,sortDescending)));
  treeViewer.setInput(ruleSet);
  checkSelections();
  TreeColumn[] columns=ruleTree.getColumns();
  for (  TreeColumn column : columns)   column.pack();
}",0.9065300896286812
22023,"/** 
 * Method groupBy.
 * @param chosenColumn RuleColumnDescriptor
 */
public void groupBy(RuleColumnDescriptor chosenColumn){
  List<RuleColumnDescriptor> visibleColumns=new ArrayList<RuleColumnDescriptor>(availableColumns.length);
  for (  RuleColumnDescriptor desc : availableColumns) {
    if (desc == chosenColumn)     continue;
    if (isHidden(desc.label()))     continue;
    visibleColumns.add(desc);
  }
  setupTreeColumns(visibleColumns.toArray(new RuleColumnDescriptor[visibleColumns.size()]),chosenColumn == null ? null : chosenColumn.accessor());
}","/** 
 * Method groupBy.
 * @param chosenColumn RuleColumnDescriptor
 */
public void groupBy(RuleColumnDescriptor chosenColumn){
  groupColumnLabel=chosenColumn == null ? null : chosenColumn.label();
  List<RuleColumnDescriptor> visibleColumns=new ArrayList<RuleColumnDescriptor>(availableColumns.length);
  for (  RuleColumnDescriptor desc : availableColumns) {
    if (desc == chosenColumn)     continue;
    if (isHidden(desc.label()))     continue;
    visibleColumns.add(desc);
  }
  setupTreeColumns(visibleColumns.toArray(new RuleColumnDescriptor[visibleColumns.size()]),chosenColumn == null ? null : chosenColumn.accessor());
  selectedItems(new Object[0]);
}",0.9161920260374288
22024,"public static boolean isDefaultValue(Map.Entry<PropertyDescriptor<?>,Object> entry){
  PropertyDescriptor<?> desc=entry.getKey();
  Object value=entry.getValue();
  return CollectionUtil.areEqual(desc.defaultValue(),value);
}","public static boolean isDefaultValue(Map.Entry<PropertyDescriptor<?>,Object> entry){
  PropertyDescriptor<?> desc=entry.getKey();
  Object value=entry.getValue();
  return areEqual(desc.defaultValue(),value);
}",0.9655172413793104
22025,"private static boolean areEqual(Object a,Object b){
  return AbstractProperty.areEqual(a,b);
}","public static boolean areEqual(Object value,Object otherValue){
  if (value == otherValue) {
    return true;
  }
  if (value == null) {
    return false;
  }
  if (otherValue == null) {
    return false;
  }
  if (value.getClass().getComponentType() != null) {
    return CollectionUtil.arraysAreEqual(value,otherValue);
  }
  if (value instanceof Float || value instanceof Double) {
    return areEqualNumbers((Number)value,(Number)otherValue);
  }
  return value.equals(otherValue);
}",0.1755593803786574
22026,"/** 
 * puts an ArrayList into a Memento, the List is changed into a separated String
 * @param key
 * @param valueList
 */
public <T extends Object>void putList(String key,List<T> valueList){
  if (valueList.isEmpty()) {
    putString(key,""String_Node_Str"");
    return;
  }
  final StringBuilder sb=new StringBuilder(String.valueOf(valueList.get(0)));
  for (int k=0; k < valueList.size(); k++) {
    sb.append(LIST_SEPARATOR).append(valueList.get(k));
  }
  putString(key,sb.toString());
}","/** 
 * puts an ArrayList into a Memento, the List is changed into a delimited String
 * @param key
 * @param valueList
 */
public <T extends Object>void putList(String key,List<T> valueList){
  if (valueList.isEmpty()) {
    putString(key,""String_Node_Str"");
    return;
  }
  final StringBuilder sb=new StringBuilder(String.valueOf(valueList.get(0)));
  for (int k=1; k < valueList.size(); k++) {
    sb.append(LIST_SEPARATOR).append(valueList.get(k));
  }
  putString(key,sb.toString());
}",0.9857723577235772
22027,"/** 
 * Returns a Mewmento with the given Attribute
 * @param name
 * @return a Memento
 */
private IMemento getAttribute(String name){
  final IMemento[] mementos=this.memento.getChildren(ATTRIBUTE_PREFIX);
  IMemento mem=null;
  for (  IMemento memento2 : mementos) {
    final String attrName=memento2.getString(ATTR_NAME);
    if (name.equalsIgnoreCase(attrName)) {
      mem=memento2;
    }
  }
  if (mem == null) {
    mem=this.memento.createChild(ATTRIBUTE_PREFIX);
    mem.putString(ATTR_NAME,name);
  }
  return mem;
}","/** 
 * Returns a Memento with the given Attribute
 * @param name
 * @return a Memento
 */
private IMemento getAttribute(String name){
  final IMemento[] mementos=this.memento.getChildren(ATTRIBUTE_PREFIX);
  IMemento mem=null;
  for (  IMemento memento2 : mementos) {
    final String attrName=memento2.getString(ATTR_NAME);
    if (name.equalsIgnoreCase(attrName)) {
      mem=memento2;
    }
  }
  if (mem == null) {
    mem=this.memento.createChild(ATTRIBUTE_PREFIX);
    mem.putString(ATTR_NAME,name);
  }
  return mem;
}",0.9990503323836656
22028,"/** 
 * Set le log level
 */
void setLogLevel(Level level);","/** 
 * Set the log level
 */
void setLogLevel(Level level);",0.9747899159663864
22029,"/** 
 * Method arrangeFor.
 * @param theRule Rule
 */
public int arrangeFor(Rule theRule){
  if (rule == theRule)   return -1;
  clearChildren();
  rule=theRule;
  if (rule == null)   return -1;
  Map<PropertyDescriptor<?>,Object> valuesByDescriptor=PMDPreferencePage.filteredPropertiesOf(rule);
  if (valuesByDescriptor.isEmpty())   return 0;
  PropertyDescriptor<?>[] orderedDescs=(PropertyDescriptor[])valuesByDescriptor.keySet().toArray(new PropertyDescriptor[valuesByDescriptor.size()]);
  int maxColumns=2;
  int rowCount=0;
  for (int i=0; i < orderedDescs.length; i++) {
    EditorFactory factory=factoryFor(orderedDescs[i]);
    if (factory == null) {
      System.out.println(""String_Node_Str"" + orderedDescs[i]);
      continue;
    }
    int colsReqd=factory.columnsRequired();
    maxColumns=Math.max(maxColumns,colsReqd);
    rowCount++;
  }
  GridLayout layout=new GridLayout(maxColumns,false);
  layout.verticalSpacing=2;
  parent.setLayout(layout);
  widgets=new Control[rowCount][maxColumns];
  if (maxColumns < 1)   return 0;
  int rowsAdded=0;
  for (int i=0; i < orderedDescs.length; i++) {
    if (addRowWidgets(factoryFor(orderedDescs[i]),rowsAdded,orderedDescs[i]))     rowsAdded++;
  }
  if (rowsAdded > 0) {
    parent.pack();
  }
  return rowsAdded;
}","/** 
 * Method arrangeFor.
 * @param theRule Rule
 */
public int arrangeFor(Rule theRule){
  if (rule == theRule)   return -1;
  clearChildren();
  rule=theRule;
  if (rule == null)   return -1;
  Map<PropertyDescriptor<?>,Object> valuesByDescriptor=PMDPreferencePage.filteredPropertiesOf(rule);
  if (valuesByDescriptor.isEmpty())   return 0;
  PropertyDescriptor<?>[] orderedDescs=(PropertyDescriptor[])valuesByDescriptor.keySet().toArray(new PropertyDescriptor[valuesByDescriptor.size()]);
  int maxColumns=2;
  int rowCount=0;
  for (int i=0; i < orderedDescs.length; i++) {
    EditorFactory factory=factoryFor(orderedDescs[i]);
    if (factory == null) {
      System.out.println(""String_Node_Str"" + orderedDescs[i]);
      continue;
    }
    int colsReqd=factory.columnsRequired();
    maxColumns=Math.max(maxColumns,colsReqd);
    rowCount++;
  }
  GridLayout layout=new GridLayout(maxColumns,false);
  layout.verticalSpacing=2;
  layout.marginTop=1;
  parent.setLayout(layout);
  widgets=new Control[rowCount][maxColumns];
  if (maxColumns < 1)   return 0;
  int rowsAdded=0;
  for (int i=0; i < orderedDescs.length; i++) {
    if (addRowWidgets(factoryFor(orderedDescs[i]),rowsAdded,orderedDescs[i]))     rowsAdded++;
  }
  if (rowsAdded > 0) {
    parent.pack();
  }
  return rowsAdded;
}",0.991466252909232
22030,"/** 
 * @param parent Composite
 * @return Combo
 */
private Composite buildGroupCombo(Composite parent,String comboLabel){
  final Composite panel=new Composite(parent,0);
  RowLayout layout=new RowLayout(SWT.HORIZONTAL);
  panel.setLayout(layout);
  Label label=new Label(panel,0);
  label.setText(comboLabel);
  final ComboViewer viewer=new ComboViewer(panel,SWT.DROP_DOWN);
  viewer.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Object[])element)[1].toString();
    }
  }
);
  viewer.add(groupingChoices);
  viewer.setSelection(new StructuredSelection(groupingChoices[groupingChoices.length - 1]),true);
  final Combo combo=viewer.getCombo();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      int pos=combo.getSelectionIndex();
      Object[] choice=groupingChoices[pos];
      groupingColumn=(RuleColumnDescriptor)choice[0];
      redrawTable();
    }
  }
);
  return panel;
}","/** 
 * @param parent Composite
 * @return Combo
 */
private Composite buildGroupCombo(Composite parent,String comboLabel){
  final Composite panel=new Composite(parent,0);
  RowLayout layout=new RowLayout(SWT.HORIZONTAL);
  layout.marginTop=0;
  panel.setLayout(layout);
  Label label=new Label(panel,0);
  label.setText(comboLabel);
  final ComboViewer viewer=new ComboViewer(panel,SWT.DROP_DOWN);
  viewer.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Object[])element)[1].toString();
    }
  }
);
  viewer.add(groupingChoices);
  viewer.setSelection(new StructuredSelection(groupingChoices[groupingChoices.length - 1]),true);
  final Combo combo=viewer.getCombo();
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      int pos=combo.getSelectionIndex();
      Object[] choice=groupingChoices[pos];
      groupingColumn=(RuleColumnDescriptor)choice[0];
      redrawTable();
    }
  }
);
  return panel;
}",0.989310009718173
22031,"/** 
 * Method addLabel.
 * @param parent Composite
 * @param desc PropertyDescriptor
 * @return Label
 */
protected Label addLabel(Composite parent,PropertyDescriptor<?> desc){
  Label label=new Label(parent,SWT.NONE);
  label.setText(desc.description());
  return label;
}","/** 
 * Method addLabel.
 * @param parent Composite
 * @param desc PropertyDescriptor
 * @return Label
 */
protected Label addLabel(Composite parent,PropertyDescriptor<?> desc){
  Label label=new Label(parent,SWT.NONE);
  label.setText(desc.description());
  GridData data=new GridData();
  data.horizontalAlignment=SWT.LEFT;
  data.verticalAlignment=SWT.TOP;
  label.setLayoutData(data);
  return label;
}",0.7970588235294118
22032,"public void handleEvent(Event event){
  Double newValue=doubleFrom(text);
  if (newValue.equals(rule.getProperty(dp)))   return;
  rule.setProperty(dp,newValue);
  listener.changed(rule,dp,newValue);
}","public void handleEvent(Event event){
  Double newValue=doubleFrom(text);
  if (newValue == null)   return;
  if (newValue.equals(rule.getProperty(dp)))   return;
  rule.setProperty(dp,newValue);
  listener.changed(rule,dp,newValue);
}",0.9220183486238532
22033,"public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Text text=new Text(parent,SWT.SINGLE);
    Number val=(Number)rule.getProperty(desc);
    text.setText(val == null ? ""String_Node_Str"" : val.toString());
    final DoubleProperty dp=doublePropertyFrom(desc);
    text.addListener(SWT.FocusOut,new Listener(){
      public void handleEvent(      Event event){
        Double newValue=doubleFrom(text);
        if (newValue.equals(rule.getProperty(dp)))         return;
        rule.setProperty(dp,newValue);
        listener.changed(rule,dp,newValue);
      }
    }
);
    return text;
  }
  return null;
}","public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Text text=new Text(parent,SWT.SINGLE);
    Number val=(Number)rule.getProperty(desc);
    text.setText(val == null ? ""String_Node_Str"" : val.toString());
    final DoubleProperty dp=doublePropertyFrom(desc);
    text.addListener(SWT.FocusOut,new Listener(){
      public void handleEvent(      Event event){
        Double newValue=doubleFrom(text);
        if (newValue == null)         return;
        if (newValue.equals(rule.getProperty(dp)))         return;
        rule.setProperty(dp,newValue);
        listener.changed(rule,dp,newValue);
      }
    }
);
    return text;
  }
  return null;
}",0.8476977567886659
22034,"/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Spinner spinner=new Spinner(parent,SWT.SINGLE | SWT.BORDER);
    final IntegerProperty ip=intPropertyFrom(desc);
    int val=((Number)rule.getProperty(desc)).intValue();
    spinner.setMinimum(ip.lowerLimit().intValue());
    spinner.setMaximum(ip.upperLimit().intValue());
    spinner.setSelection(val);
    spinner.addModifyListener(new ModifyListener(){
      public void modifyText(      ModifyEvent event){
        int newValue=spinner.getSelection();
        if (newValue == rule.getProperty(ip))         return;
        rule.setProperty(ip,Integer.valueOf(newValue));
        listener.changed(rule,desc,Integer.valueOf(newValue));
      }
    }
);
    return spinner;
  }
  return null;
}","/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final IntegerProperty ip=intPropertyFrom(desc);
    final Spinner spinner=newSpinner(parent,ip,rule.getProperty(desc));
    spinner.addModifyListener(new ModifyListener(){
      public void modifyText(      ModifyEvent event){
        int newValue=spinner.getSelection();
        if (newValue == rule.getProperty(ip))         return;
        rule.setProperty(ip,Integer.valueOf(newValue));
        listener.changed(rule,desc,Integer.valueOf(newValue));
      }
    }
);
    return spinner;
  }
  return null;
}",0.8543254146122815
22035,"/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @param listener ValueChangeListener
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final MethodPicker picker=new MethodPicker(parent,SWT.SINGLE | SWT.BORDER,unwantedPrefixes);
    picker.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    fillWidget(picker,desc,rule);
    final MethodProperty mp=methodPropertyFrom(desc);
    picker.addSelectionListener(new SelectionAdapter(){
      public void widgetSelected(      SelectionEvent e){
        Method newValue=picker.getMethod();
        if (newValue == null)         return;
        Method existingValue=rule.getProperty(mp);
        if (existingValue == newValue)         return;
        rule.setProperty(mp,newValue);
        fillWidget(picker,desc,rule);
        listener.changed(rule,desc,newValue);
      }
    }
);
    return picker;
  }
  return null;
}","/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @param listener ValueChangeListener
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final MethodPicker picker=new MethodPicker(parent,SWT.SINGLE | SWT.BORDER,UnwantedPrefixes);
    picker.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    fillWidget(picker,desc,rule);
    final MethodProperty mp=methodPropertyFrom(desc);
    picker.addSelectionListener(new SelectionAdapter(){
      public void widgetSelected(      SelectionEvent e){
        Method newValue=picker.getMethod();
        if (newValue == null)         return;
        Method existingValue=rule.getProperty(mp);
        if (existingValue == newValue)         return;
        rule.setProperty(mp,newValue);
        fillWidget(picker,desc,rule);
        listener.changed(rule,desc,newValue);
      }
    }
);
    return picker;
  }
  return null;
}",0.9992217898832684
22036,"public void setMethod(Method method){
  ;
  Class<?> cls=method.getDeclaringClass();
  typeText.setType(cls);
  reviseMethodListFor(cls);
  methodList.select(indexOf(method));
}","public void setMethod(Method method){
  if (method == null) {
    typeText.setType(null);
    return;
  }
  Class<?> cls=method.getDeclaringClass();
  typeText.setType(cls);
  reviseMethodListFor(cls);
  methodList.select(indexOf(method));
}",0.8421052631578947
22037,"private void reviseMethodListFor(Class<?> cls){
  if (cls == null) {
    methodList.removeAll();
    methodList.setEnabled(false);
    return;
  }
  methodList.setEnabled(true);
  methods=cls.getMethods();
  String[] items=new String[methods.length];
  for (int i=0; i < methods.length; i++)   items[i]=Util.signatureFor(methods[i],unwantedPrefixes);
  methodList.setItems(items);
  methodList.select(0);
}","private void reviseMethodListFor(Class<?> cls){
  if (cls == null) {
    methodList.removeAll();
    methodList.setEnabled(false);
    return;
  }
  methodList.setEnabled(true);
  methods=cls.getMethods();
  Arrays.sort(methods,Util.MethodNameComparator);
  String[] items=new String[methods.length];
  for (int i=0; i < methods.length; i++)   items[i]=Util.signatureFor(methods[i],unwantedPrefixes);
  methodList.setItems(items);
  methodList.select(0);
}",0.9419953596287703
22038,"public MethodPicker(Composite parent,int style,String[] theUnwantedPrefixes){
  super(parent,SWT.None);
  unwantedPrefixes=theUnwantedPrefixes == null ? StringUtil.EMPTY_STRINGS : theUnwantedPrefixes;
  GridLayout layout=new GridLayout(2,true);
  layout.verticalSpacing=0;
  layout.horizontalSpacing=0;
  layout.marginHeight=0;
  layout.marginWidth=0;
  this.setLayout(layout);
  typeText=new TypeText(this,style);
  typeText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
  typeText.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      reviseMethodListFor(typeText.getType(true));
    }
  }
);
  methodList=new Combo(this,style);
  methodList.setLayoutData(new GridData(GridData.FILL_BOTH));
}","public MethodPicker(Composite parent,int style,String[] theUnwantedPrefixes){
  super(parent,SWT.None);
  unwantedPrefixes=theUnwantedPrefixes == null ? StringUtil.EMPTY_STRINGS : theUnwantedPrefixes;
  GridLayout layout=new GridLayout(2,true);
  layout.verticalSpacing=0;
  layout.horizontalSpacing=0;
  layout.marginHeight=0;
  layout.marginWidth=0;
  this.setLayout(layout);
  typeText=new TypeText(this,style,false);
  typeText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
  typeText.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      reviseMethodListFor(typeText.getType(true));
    }
  }
);
  methodList=new Combo(this,style);
  methodList.setLayoutData(new GridData(GridData.FILL_BOTH));
}",0.995973154362416
22039,"protected Control addWidget(Composite parent,Object value,PropertyDescriptor<?> desc,Rule rule){
  final Spinner spinner=new Spinner(parent,SWT.SINGLE | SWT.BORDER);
  final NumericPropertyDescriptor<?> ip=numericPropertyFrom(desc);
  spinner.setMinimum(ip.lowerLimit().intValue());
  spinner.setMaximum(ip.upperLimit().intValue());
  setValue(spinner,value);
  return spinner;
}","protected Control addWidget(Composite parent,Object value,PropertyDescriptor<?> desc,Rule rule){
  NumericPropertyDescriptor<?> ip=numericPropertyFrom(desc);
  return IntegerEditorFactory.newSpinner(parent,ip,value);
}",0.3785594639865997
22040,"public void handleEvent(Event event){
  Class<?> newValue=typeText.getType(true);
  if (newValue == null)   return;
  Class<?> existingValue=rule.getProperty(tp);
  if (existingValue == newValue)   return;
  rule.setProperty(tp,newValue);
  fillWidget(typeText,desc,rule);
  listener.changed(rule,desc,newValue);
}","public void handleEvent(Event event){
  Class<?> newValue=typeText.getType(true);
  if (newValue == null)   return;
  Class<?> existingValue=rule.getProperty(tp);
  if (existingValue == newValue)   return;
  rule.setProperty(tp,newValue);
  listener.changed(rule,desc,newValue);
}",0.8720538720538721
22041,"/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @param listener ValueChangeListener
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final TypeText typeText=new TypeText(parent,SWT.SINGLE | SWT.BORDER);
    typeText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    fillWidget(typeText,desc,rule);
    final TypeProperty tp=typePropertyFrom(desc);
    typeText.addListener(SWT.FocusOut,new Listener(){
      public void handleEvent(      Event event){
        Class<?> newValue=typeText.getType(true);
        if (newValue == null)         return;
        Class<?> existingValue=rule.getProperty(tp);
        if (existingValue == newValue)         return;
        rule.setProperty(tp,newValue);
        fillWidget(typeText,desc,rule);
        listener.changed(rule,desc,newValue);
      }
    }
);
    return typeText;
  }
  return null;
}","/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @param listener ValueChangeListener
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener,SizeChangeListener sizeListener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final TypeText typeText=new TypeText(parent,SWT.SINGLE | SWT.BORDER,true);
    typeText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    fillWidget(typeText,desc,rule);
    final TypeProperty tp=typePropertyFrom(desc);
    typeText.addListener(SWT.FocusOut,new Listener(){
      public void handleEvent(      Event event){
        Class<?> newValue=typeText.getType(true);
        if (newValue == null)         return;
        Class<?> existingValue=rule.getProperty(tp);
        if (existingValue == newValue)         return;
        rule.setProperty(tp,newValue);
        listener.changed(rule,desc,newValue);
      }
    }
);
    return typeText;
  }
  return null;
}",0.9819494584837544
22042,"/** 
 * Method setupTreeColumns.
 * @param columnDescs RuleColumnDescriptor[]
 * @param groupingField RuleFieldAccessor
 */
private void setupTreeColumns(RuleColumnDescriptor[] columnDescs,RuleFieldAccessor groupingField){
  Tree ruleTree=cleanupRuleTree();
  for (int i=0; i < columnDescs.length; i++)   columnDescs[i].newTreeColumnFor(ruleTree,i,this,paintListeners);
  ruleTreeViewer.setLabelProvider(new RuleLabelProvider(columnDescs));
  ruleTreeViewer.setContentProvider(new RuleSetTreeItemProvider(groupingField,""String_Node_Str"",Util.comparatorFrom(columnSorter,sortDescending)));
  populateRuleTable();
  TreeColumn[] columns=ruleTree.getColumns();
  for (  TreeColumn column : columns)   column.pack();
}","/** 
 * Method setupTreeColumns.
 * @param columnDescs RuleColumnDescriptor[]
 * @param groupingField RuleFieldAccessor
 */
private void setupTreeColumns(RuleColumnDescriptor[] columnDescs,RuleFieldAccessor groupingField){
  Tree ruleTree=cleanupRuleTree();
  for (int i=0; i < columnDescs.length; i++)   columnDescs[i].newTreeColumnFor(ruleTree,i,this,paintListeners);
  ruleTreeViewer.setLabelProvider(new RuleLabelProvider(columnDescs));
  ruleTreeViewer.setContentProvider(new RuleSetTreeItemProvider(groupingField,""String_Node_Str"",Util.comparatorFrom(columnSorter,sortDescending)));
  TreeColumn[] columns=ruleTree.getColumns();
  for (  TreeColumn column : columns)   column.pack();
}",0.9836298932384342
22043,"public List<Rule> allRules(){
  List<Rule> selections=new ArrayList<Rule>();
  if (ruleItems == null || ruleItems.length == 0) {
    return selections;
  }
  for (  Object ruleItem : ruleItems) {
    if (ruleItem instanceof Rule) {
      selections.add((Rule)ruleItem);
      continue;
    }
 else {
      Rule[] rules=((RuleGroup)ruleItem).rules();
      for (int r=0; r < rules.length; r++)       selections.add(rules[r]);
    }
  }
  return selections;
}","public List<Rule> allRules(){
  List<Rule> selections=new ArrayList<Rule>();
  if (ruleItems == null || ruleItems.length == 0) {
    return selections;
  }
  for (  Object ruleItem : ruleItems) {
    if (ruleItem instanceof Rule) {
      selections.add((Rule)ruleItem);
      continue;
    }
 else {
      Rule[] rules=((RuleGroup)ruleItem).rules();
      for (      Rule rule : rules)       selections.add(rule);
    }
  }
  return selections;
}",0.9368770764119602
22044,"public void changed(RuleSelection selection,PropertyDescriptor<?> desc,Object newValue){
  modified=true;
  for (  Rule rule : selection.allRules())   ruleTreeViewer.update(rule,null);
  for (  RulePropertyManager manager : rulePropertyManagers) {
    manager.validate();
  }
}","public void changed(RuleSelection selection,PropertyDescriptor<?> desc,Object newValue){
  modified=true;
  for (  Rule rule : selection.allRules()) {
    if (newValue != null) {
      ruleTreeViewer.getTree().redraw();
    }
 else {
      ruleTreeViewer.update(rule,null);
    }
  }
  for (  RulePropertyManager manager : rulePropertyManagers) {
    manager.validate();
  }
}",0.8483920367534457
22045,"public void modifyText(ModifyEvent e){
  colourWindow.setBackground(colourManager.colourFor(control.getText()));
  changeListener.changed(rules,null,null);
}","public void modifyText(ModifyEvent e){
  String newText=control.getText();
  colourWindow.setBackground(colourManager.colourFor(newText));
  changed(desc,newText);
}",0.7329192546583851
22046,"private void addListeners(final Text control,final StringProperty desc,final Control colourWindow){
  addTextListeners(control,desc);
  control.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      colourWindow.setBackground(colourManager.colourFor(control.getText()));
      changeListener.changed(rules,null,null);
    }
  }
);
}","private void addListeners(final Text control,final StringProperty desc,final Control colourWindow){
  addTextListeners(control,desc);
  control.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      String newText=control.getText();
      colourWindow.setBackground(colourManager.colourFor(newText));
      changed(desc,newText);
    }
  }
);
}",0.8590425531914894
22047,"/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @param listener ValueChangeListener
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    Composite panel=new Composite(parent,SWT.NONE);
    panel.setLayout(new GridLayout(2,false));
    Text textWidget=new Text(panel,SWT.SINGLE | SWT.BORDER);
    textWidget.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    fillWidget(textWidget,desc,rule);
    configure(textWidget,desc,rule,listener);
    return panel;
  }
  return null;
}","/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @param listener ValueChangeListener
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Text textWidget=new Text(parent,SWT.SINGLE | SWT.BORDER);
    GridData gridData=new GridData();
    gridData.horizontalAlignment=SWT.FILL;
    gridData.grabExcessHorizontalSpace=true;
    textWidget.setLayoutData(gridData);
    fillWidget(textWidget,desc,rule);
    configure(textWidget,desc,rule,listener);
    return textWidget;
  }
  return null;
}",0.7848101265822784
22048,"/** 
 * @param property StringProperty
 * @param newValue String
 */
protected void changed(StringProperty property,String newValue){
  if (currentRule == null)   return;
  String cleanValue=newValue.trim();
  String existingValue=currentRule.getProperty(property);
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  currentRule.setProperty(property,cleanValue);
  changeListener.changed(currentRule,property,cleanValue);
}","/** 
 * @param property StringProperty
 * @param newValue String
 */
protected void changed(StringProperty property,String newValue){
  if (rules == null)   return;
  String cleanValue=newValue.trim();
  String existingValue=rules.commonStringValue(property);
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  rules.setValue(property,cleanValue);
  changeListener.changed(rules,property,cleanValue);
}",0.8794489092996556
22049,"public Control setupOn(Composite parent){
  descriptionBox=buildDescriptionBox(parent);
  descriptionBox.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      if (currentRule == null)       return;
      String cleanValue=descriptionBox.getText().trim();
      String existingValue=currentRule.getDescription();
      if (StringUtil.areSemanticEquals(existingValue,cleanValue))       return;
      currentRule.setDescription(cleanValue);
      changeListener.changed(currentRule,null,cleanValue);
    }
  }
);
  return descriptionBox;
}","public Control setupOn(Composite parent){
  descriptionBox=buildDescriptionBox(parent);
  descriptionBox.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      Rule soleRule=soleRule();
      String cleanValue=descriptionBox.getText().trim();
      String existingValue=soleRule.getDescription();
      if (StringUtil.areSemanticEquals(existingValue,cleanValue))       return;
      soleRule.setDescription(cleanValue);
      changeListener.changed(rules,null,cleanValue);
    }
  }
);
  return descriptionBox;
}",0.8088888888888889
22050,"public void handleEvent(Event event){
  if (currentRule == null)   return;
  String cleanValue=descriptionBox.getText().trim();
  String existingValue=currentRule.getDescription();
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  currentRule.setDescription(cleanValue);
  changeListener.changed(currentRule,null,cleanValue);
}","public void handleEvent(Event event){
  Rule soleRule=soleRule();
  String cleanValue=descriptionBox.getText().trim();
  String existingValue=soleRule.getDescription();
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  soleRule.setDescription(cleanValue);
  changeListener.changed(rules,null,cleanValue);
}",0.8634361233480177
22051,"private void clearChildren(){
  Control[] kids=parent.getChildren();
  for (int i=0; i < kids.length; i++)   kids[i].dispose();
}","public void clearChildren(){
  Control[] kids=parent.getChildren();
  for (int i=0; i < kids.length; i++)   kids[i].dispose();
  parent.pack();
  rule=null;
}",0.8641114982578397
22052,"/** 
 * Fill a properties information structure from a transfer object
 * @param projectProperties a project properties data structure
 * @param to a project properties transfer object
 */
private void fillProjectProperties(IProjectProperties projectProperties,ProjectPropertiesTO to) throws PropertiesException, CoreException {
  if (to == null) {
    log.info(""String_Node_Str"");
  }
 else {
    final IWorkingSetManager workingSetManager=PlatformUI.getWorkbench().getWorkingSetManager();
    projectProperties.setProjectWorkingSet(workingSetManager.getWorkingSet(to.getWorkingSetName()));
    projectProperties.setRuleSetStoredInProject(to.isRuleSetStoredInProject());
    projectProperties.setRuleSetFile(to.getRuleSetFile());
    projectProperties.setPmdEnabled(projectProperties.getProject().hasNature(PMDNature.PMD_NATURE));
    projectProperties.setIncludeDerivedFiles(to.isIncludeDerivedFiles());
    if (to.isRuleSetStoredInProject()) {
      loadRuleSetFromProject(projectProperties);
    }
 else {
      setRuleSetFromProperties(projectProperties,to.getRules());
    }
    log.debug(""String_Node_Str"");
  }
}","/** 
 * Fill a properties information structure from a transfer object
 * @param projectProperties a project properties data structure
 * @param to a project properties transfer object
 */
private void fillProjectProperties(IProjectProperties projectProperties,ProjectPropertiesTO to) throws PropertiesException, CoreException {
  if (to == null) {
    log.info(""String_Node_Str"");
  }
 else {
    final IWorkingSetManager workingSetManager=PlatformUI.getWorkbench().getWorkingSetManager();
    projectProperties.setProjectWorkingSet(workingSetManager.getWorkingSet(to.getWorkingSetName()));
    projectProperties.setRuleSetFile(to.getRuleSetFile());
    projectProperties.setRuleSetStoredInProject(to.isRuleSetStoredInProject());
    projectProperties.setPmdEnabled(projectProperties.getProject().hasNature(PMDNature.PMD_NATURE));
    projectProperties.setIncludeDerivedFiles(to.isIncludeDerivedFiles());
    if (to.isRuleSetStoredInProject()) {
      loadRuleSetFromProject(projectProperties);
    }
 else {
      setRuleSetFromProperties(projectProperties,to.getRules());
    }
    log.debug(""String_Node_Str"");
  }
}",0.9473214285714284
22053,"/** 
 * @param property StringProperty
 * @param newValue String
 */
protected void changed(StringProperty property,String newValue){
  if (currentRule == null)   return;
  String cleanValue=newValue.trim();
  String existingValue=currentRule.getProperty(property);
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  currentRule.setProperty(property,cleanValue);
  changeListener.changed(property,cleanValue);
}","/** 
 * @param property StringProperty
 * @param newValue String
 */
protected void changed(StringProperty property,String newValue){
  if (currentRule == null)   return;
  String cleanValue=newValue.trim();
  String existingValue=currentRule.getProperty(property);
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  currentRule.setProperty(property,cleanValue);
  changeListener.changed(currentRule,property,cleanValue);
}",0.968181818181818
22054,"public void widgetSelected(SelectionEvent event){
  boolean selected=butt.getSelection();
  if (selected == rule.getProperty(bp))   return;
  rule.setProperty(bp,Boolean.valueOf(selected));
  listener.changed(desc,Boolean.valueOf(selected));
}","public void widgetSelected(SelectionEvent event){
  boolean selected=butt.getSelection();
  if (selected == rule.getProperty(bp))   return;
  rule.setProperty(bp,Boolean.valueOf(selected));
  listener.changed(rule,desc,Boolean.valueOf(selected));
}",0.989816700610998
22055,"/** 
 * Method newEditorOn.
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Button butt=new Button(parent,SWT.CHECK);
    butt.setText(""String_Node_Str"");
    final BooleanProperty bp=booleanPropertyFrom(desc);
    boolean set=((Boolean)rule.getProperty(desc)).booleanValue();
    butt.setSelection(set);
    butt.addSelectionListener(new SelectionAdapter(){
      public void widgetSelected(      SelectionEvent event){
        boolean selected=butt.getSelection();
        if (selected == rule.getProperty(bp))         return;
        rule.setProperty(bp,Boolean.valueOf(selected));
        listener.changed(desc,Boolean.valueOf(selected));
      }
    }
);
    return butt;
  }
  return null;
}","/** 
 * Method newEditorOn.
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Button butt=new Button(parent,SWT.CHECK);
    butt.setText(""String_Node_Str"");
    final BooleanProperty bp=booleanPropertyFrom(desc);
    boolean set=((Boolean)rule.getProperty(desc)).booleanValue();
    butt.setSelection(set);
    butt.addSelectionListener(new SelectionAdapter(){
      public void widgetSelected(      SelectionEvent event){
        boolean selected=butt.getSelection();
        if (selected == rule.getProperty(bp))         return;
        rule.setProperty(bp,Boolean.valueOf(selected));
        listener.changed(rule,desc,Boolean.valueOf(selected));
      }
    }
);
    return butt;
  }
  return null;
}",0.9977885891198583
22056,"void addPainterFor(Tree tree,int columnIndex,RuleFieldAccessor getter);","void addPainterFor(Tree tree,int columnIndex,RuleFieldAccessor getter,Map<Integer,List<Listener>> listenersByEventCode);",0.743455497382199
22057,"public void handleEvent(Event event){
  Character newValue=charValueIn(text);
  Character existingValue=rule.getProperty(cp);
  if (existingValue.equals(newValue))   return;
  rule.setProperty(cp,newValue);
  listener.changed(cp,newValue);
}","public void handleEvent(Event event){
  Character newValue=charValueIn(text);
  Character existingValue=rule.getProperty(cp);
  if (existingValue.equals(newValue))   return;
  rule.setProperty(cp,newValue);
  listener.changed(rule,cp,newValue);
}",0.9815195071868584
22058,"public Control newEditorOn(Composite parent,int columnIndex,PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Text text=new Text(parent,SWT.SINGLE | SWT.BORDER);
    fillWidget(text,desc,rule);
    final CharacterProperty cp=characterPropertyFrom(desc);
    text.addListener(SWT.FocusOut,new Listener(){
      public void handleEvent(      Event event){
        Character newValue=charValueIn(text);
        Character existingValue=rule.getProperty(cp);
        if (existingValue.equals(newValue))         return;
        rule.setProperty(cp,newValue);
        listener.changed(cp,newValue);
      }
    }
);
    return text;
  }
  return null;
}","public Control newEditorOn(Composite parent,int columnIndex,PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Text text=new Text(parent,SWT.SINGLE | SWT.BORDER);
    fillWidget(text,desc,rule);
    final CharacterProperty cp=characterPropertyFrom(desc);
    text.addListener(SWT.FocusOut,new Listener(){
      public void handleEvent(      Event event){
        Character newValue=charValueIn(text);
        Character existingValue=rule.getProperty(cp);
        if (existingValue.equals(newValue))         return;
        rule.setProperty(cp,newValue);
        listener.changed(rule,cp,newValue);
      }
    }
);
    return text;
  }
  return null;
}",0.9967553536664504
22059,"public Control setupOn(Composite parent){
  descriptionBox=buildDescriptionBox(parent);
  descriptionBox.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      if (currentRule == null)       return;
      String cleanValue=descriptionBox.getText().trim();
      String existingValue=currentRule.getDescription();
      if (StringUtil.areSemanticEquals(existingValue,cleanValue))       return;
      currentRule.setDescription(cleanValue);
      changeListener.changed(null,cleanValue);
    }
  }
);
  return descriptionBox;
}","public Control setupOn(Composite parent){
  descriptionBox=buildDescriptionBox(parent);
  descriptionBox.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      if (currentRule == null)       return;
      String cleanValue=descriptionBox.getText().trim();
      String existingValue=currentRule.getDescription();
      if (StringUtil.areSemanticEquals(existingValue,cleanValue))       return;
      currentRule.setDescription(cleanValue);
      changeListener.changed(currentRule,null,cleanValue);
    }
  }
);
  return descriptionBox;
}",0.9824253075571178
22060,"public void handleEvent(Event event){
  if (currentRule == null)   return;
  String cleanValue=descriptionBox.getText().trim();
  String existingValue=currentRule.getDescription();
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  currentRule.setDescription(cleanValue);
  changeListener.changed(null,cleanValue);
}","public void handleEvent(Event event){
  if (currentRule == null)   return;
  String cleanValue=descriptionBox.getText().trim();
  String existingValue=currentRule.getDescription();
  if (StringUtil.areSemanticEquals(existingValue,cleanValue))   return;
  currentRule.setDescription(cleanValue);
  changeListener.changed(currentRule,null,cleanValue);
}",0.9710144927536232
22061,"public void modifyText(ModifyEvent event){
  int newValue=spinner.getSelection();
  if (newValue == rule.getProperty(ip))   return;
  rule.setProperty(ip,Integer.valueOf(newValue));
  listener.changed(desc,Integer.valueOf(newValue));
}","public void modifyText(ModifyEvent event){
  int newValue=spinner.getSelection();
  if (newValue == rule.getProperty(ip))   return;
  rule.setProperty(ip,Integer.valueOf(newValue));
  listener.changed(rule,desc,Integer.valueOf(newValue));
}",0.9894736842105264
22062,"/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Spinner spinner=new Spinner(parent,SWT.SINGLE | SWT.BORDER);
    final IntegerProperty ip=intPropertyFrom(desc);
    int val=((Number)rule.getProperty(desc)).intValue();
    spinner.setMinimum(ip.lowerLimit().intValue());
    spinner.setMaximum(ip.upperLimit().intValue());
    spinner.setSelection(val);
    spinner.addModifyListener(new ModifyListener(){
      public void modifyText(      ModifyEvent event){
        int newValue=spinner.getSelection();
        if (newValue == rule.getProperty(ip))         return;
        rule.setProperty(ip,Integer.valueOf(newValue));
        listener.changed(desc,Integer.valueOf(newValue));
      }
    }
);
    return spinner;
  }
  return null;
}","/** 
 * @param parent Composite
 * @param columnIndex int
 * @param desc PropertyDescriptor
 * @param rule Rule
 * @return Control
 * @see net.sourceforge.pmd.ui.preferences.br.EditorFactory#newEditorOn(Composite,int,PropertyDescriptor,Rule)
 */
public Control newEditorOn(Composite parent,int columnIndex,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  if (columnIndex == 0)   return addLabel(parent,desc);
  if (columnIndex == 1) {
    final Spinner spinner=new Spinner(parent,SWT.SINGLE | SWT.BORDER);
    final IntegerProperty ip=intPropertyFrom(desc);
    int val=((Number)rule.getProperty(desc)).intValue();
    spinner.setMinimum(ip.lowerLimit().intValue());
    spinner.setMaximum(ip.upperLimit().intValue());
    spinner.setSelection(val);
    spinner.addModifyListener(new ModifyListener(){
      public void modifyText(      ModifyEvent event){
        int newValue=spinner.getSelection();
        if (newValue == rule.getProperty(ip))         return;
        rule.setProperty(ip,Integer.valueOf(newValue));
        listener.changed(rule,desc,Integer.valueOf(newValue));
      }
    }
);
    return spinner;
  }
  return null;
}",0.997875053123672
22063,"public void handleEvent(Event event){
  Integer[] newValue=currentIntegers(textWidget);
  Integer[] existingValue=rule.getProperty(tmp);
  if (Util.areSemanticEquals(existingValue,newValue))   return;
  rule.setProperty(tmp,newValue);
  fillWidget(textWidget,desc,rule);
  listener.changed(desc,newValue);
}","public void handleEvent(Event event){
  Integer[] newValue=currentIntegers(textWidget);
  Integer[] existingValue=rule.getProperty(tmp);
  if (Util.areSemanticEquals(existingValue,newValue))   return;
  rule.setProperty(tmp,newValue);
  fillWidget(textWidget,desc,rule);
  listener.changed(rule,desc,newValue);
}",0.9919224555735056
22064,"protected void configure(final Text textWidget,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  final IntegerMultiProperty tmp=multiIntegerPropertyFrom(desc);
  textWidget.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      Integer[] newValue=currentIntegers(textWidget);
      Integer[] existingValue=rule.getProperty(tmp);
      if (Util.areSemanticEquals(existingValue,newValue))       return;
      rule.setProperty(tmp,newValue);
      fillWidget(textWidget,desc,rule);
      listener.changed(desc,newValue);
    }
  }
);
}","protected void configure(final Text textWidget,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  final IntegerMultiProperty tmp=multiIntegerPropertyFrom(desc);
  textWidget.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      Integer[] newValue=currentIntegers(textWidget);
      Integer[] existingValue=rule.getProperty(tmp);
      if (Util.areSemanticEquals(existingValue,newValue))       return;
      rule.setProperty(tmp,newValue);
      fillWidget(textWidget,desc,rule);
      listener.changed(rule,desc,newValue);
    }
  }
);
}",0.995904995904996
22065,"public void handleEvent(Event event){
  String[] newValues=textWidgetValues(textWidget);
  String[] existingValues=rule.getProperty(smp);
  if (Util.areSemanticEquals(existingValues,newValues))   return;
  rule.setProperty(smp,newValues);
  fillWidget(textWidget,desc,rule);
  listener.changed(desc,newValues);
}","public void handleEvent(Event event){
  String[] newValues=textWidgetValues(textWidget);
  String[] existingValues=rule.getProperty(smp);
  if (Util.areSemanticEquals(existingValues,newValues))   return;
  rule.setProperty(smp,newValues);
  fillWidget(textWidget,desc,rule);
  listener.changed(rule,desc,newValues);
}",0.9920508744038156
22066,"protected void configure(final Text textWidget,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  final StringMultiProperty smp=multiStringPropertyFrom(desc);
  textWidget.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      String[] newValues=textWidgetValues(textWidget);
      String[] existingValues=rule.getProperty(smp);
      if (Util.areSemanticEquals(existingValues,newValues))       return;
      rule.setProperty(smp,newValues);
      fillWidget(textWidget,desc,rule);
      listener.changed(desc,newValues);
    }
  }
);
}","protected void configure(final Text textWidget,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  final StringMultiProperty smp=multiStringPropertyFrom(desc);
  textWidget.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      String[] newValues=textWidgetValues(textWidget);
      String[] existingValues=rule.getProperty(smp);
      if (Util.areSemanticEquals(existingValues,newValues))       return;
      rule.setProperty(smp,newValues);
      fillWidget(textWidget,desc,rule);
      listener.changed(rule,desc,newValues);
    }
  }
);
}",0.9959250203748982
22067,"public void handleEvent(Event event){
  Class<?>[] newValue=currentTypes(textWidget);
  Class<?>[] existingValue=rule.getProperty(tmp);
  if (Util.areSemanticEquals(existingValue,newValue))   return;
  rule.setProperty(tmp,newValue);
  fillWidget(textWidget,desc,rule);
  listener.changed(desc,newValue);
}","public void handleEvent(Event event){
  Class<?>[] newValue=currentTypes(textWidget);
  Class<?>[] existingValue=rule.getProperty(tmp);
  if (Util.areSemanticEquals(existingValue,newValue))   return;
  rule.setProperty(tmp,newValue);
  fillWidget(textWidget,desc,rule);
  listener.changed(rule,desc,newValue);
}",0.9918962722852512
22068,"protected void configure(final Text textWidget,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  final TypeMultiProperty tmp=multiTypePropertyFrom(desc);
  textWidget.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      Class<?>[] newValue=currentTypes(textWidget);
      Class<?>[] existingValue=rule.getProperty(tmp);
      if (Util.areSemanticEquals(existingValue,newValue))       return;
      rule.setProperty(tmp,newValue);
      fillWidget(textWidget,desc,rule);
      listener.changed(desc,newValue);
    }
  }
);
}","protected void configure(final Text textWidget,final PropertyDescriptor<?> desc,final Rule rule,final ValueChangeListener listener){
  final TypeMultiProperty tmp=multiTypePropertyFrom(desc);
  textWidget.addListener(SWT.FocusOut,new Listener(){
    public void handleEvent(    Event event){
      Class<?>[] newValue=currentTypes(textWidget);
      Class<?>[] existingValue=rule.getProperty(tmp);
      if (Util.areSemanticEquals(existingValue,newValue))       return;
      rule.setProperty(tmp,newValue);
      fillWidget(textWidget,desc,rule);
      listener.changed(rule,desc,newValue);
    }
  }
);
}",0.995857497928749
22069,"/** 
 * This method is called upon plug-in activation
 */
public void start(BundleContext context) throws Exception {
  super.start(context);
  configureLogs();
}","/** 
 * This method is called upon plug-in activation
 */
public void start(BundleContext context) throws Exception {
  super.start(context);
  configureLogs(loadPreferences());
}",0.9501466275659824
22070,"/** 
 * Configure the logging
 */
private void configureLogs(){
  try {
    IPreferences preferences=loadPreferences();
    Layout layout=new PatternLayout(""String_Node_Str"");
    RollingFileAppender appender=new RollingFileAppender(layout,preferences.getLogFileName());
    appender.setName(PMD_ECLIPSE_APPENDER_NAME);
    appender.setMaxBackupIndex(1);
    appender.setMaxFileSize(""String_Node_Str"");
    Logger.getRootLogger().addAppender(new ConsoleAppender(layout));
    Logger.getRootLogger().setLevel(Level.WARN);
    Logger.getRootLogger().setAdditivity(false);
    Logger.getLogger(ROOT_LOG_ID).addAppender(appender);
    Logger.getLogger(ROOT_LOG_ID).setLevel(preferences.getLogLevel());
    Logger.getLogger(ROOT_LOG_ID).setAdditivity(false);
  }
 catch (  IOException e) {
    logError(""String_Node_Str"",e);
  }
}","/** 
 * Configure the logging
 */
private void configureLogs(IPreferences preferences){
  try {
    Layout layout=new PatternLayout(""String_Node_Str"");
    RollingFileAppender appender=new RollingFileAppender(layout,preferences.getLogFileName());
    appender.setName(PMD_ECLIPSE_APPENDER_NAME);
    appender.setMaxBackupIndex(1);
    appender.setMaxFileSize(""String_Node_Str"");
    Logger.getRootLogger().addAppender(new ConsoleAppender(layout));
    Logger.getRootLogger().setLevel(Level.WARN);
    Logger.getRootLogger().setAdditivity(false);
    Logger.getLogger(ROOT_LOG_ID).addAppender(appender);
    Logger.getLogger(ROOT_LOG_ID).setLevel(preferences.getLogLevel());
    Logger.getLogger(ROOT_LOG_ID).setAdditivity(false);
  }
 catch (  IOException e) {
    logError(""String_Node_Str"",e);
  }
}",0.972939729397294
22071,"/** 
 * Apply the log preferencs
 */
public void applyLogPreferences(IPreferences preferences){
  Logger log=Logger.getLogger(ROOT_LOG_ID);
  log.setLevel(preferences.getLogLevel());
  RollingFileAppender appender=(RollingFileAppender)log.getAppender(PMD_ECLIPSE_APPENDER_NAME);
  if (!appender.getFile().equals(preferences.getLogFileName())) {
    appender.setFile(preferences.getLogFileName());
    appender.activateOptions();
  }
}","/** 
 * Apply the log preferencs
 */
public void applyLogPreferences(IPreferences preferences){
  Logger log=Logger.getLogger(ROOT_LOG_ID);
  log.setLevel(preferences.getLogLevel());
  RollingFileAppender appender=(RollingFileAppender)log.getAppender(PMD_ECLIPSE_APPENDER_NAME);
  if (appender == null) {
    configureLogs(preferences);
  }
 else   if (!appender.getFile().equals(preferences.getLogFileName())) {
    appender.setFile(preferences.getLogFileName());
    appender.activateOptions();
  }
}",0.9273504273504274
22072,"/** 
 * @see net.sourceforge.pmd.runtime.properties.IProjectProperties#setProjectWorkingSet(org.eclipse.ui.IWorkingSet)
 */
public void setProjectWorkingSet(final IWorkingSet projectWorkingSet){
  log.debug(""String_Node_Str"" + this.project.getName() + ""String_Node_Str""+ (projectWorkingSet == null ? ""String_Node_Str"" : projectWorkingSet.getName()));
  this.projectWorkingSet=projectWorkingSet;
}","/** 
 * @see net.sourceforge.pmd.runtime.properties.IProjectProperties#setProjectWorkingSet(org.eclipse.ui.IWorkingSet)
 */
public void setProjectWorkingSet(final IWorkingSet projectWorkingSet){
  log.debug(""String_Node_Str"" + this.project.getName() + ""String_Node_Str""+ (projectWorkingSet == null ? ""String_Node_Str"" : projectWorkingSet.getName()));
  this.needRebuild|=(this.projectWorkingSet == null) ? (projectWorkingSet != null) : !this.projectWorkingSet.equals(projectWorkingSet);
  this.projectWorkingSet=projectWorkingSet;
}",0.7780172413793104
22073,"/** 
 * @see net.sourceforge.pmd.runtime.properties.IProjectProperties#setRuleSetStoredInProject(boolean)
 */
public void setRuleSetStoredInProject(final boolean ruleSetStoredInProject) throws PropertiesException {
  log.debug(""String_Node_Str"" + this.project.getName() + ""String_Node_Str""+ ruleSetStoredInProject);
  this.ruleSetStoredInProject=ruleSetStoredInProject;
  if ((this.ruleSetStoredInProject) && (!isRuleSetFileExist())) {
    throw new PropertiesException(""String_Node_Str"" + this.project.getName());
  }
}","/** 
 * @see net.sourceforge.pmd.runtime.properties.IProjectProperties#setRuleSetStoredInProject(boolean)
 */
public void setRuleSetStoredInProject(final boolean ruleSetStoredInProject) throws PropertiesException {
  log.debug(""String_Node_Str"" + this.project.getName() + ""String_Node_Str""+ ruleSetStoredInProject);
  this.needRebuild|=this.ruleSetStoredInProject != ruleSetStoredInProject;
  this.ruleSetStoredInProject=ruleSetStoredInProject;
  if ((this.ruleSetStoredInProject) && (!isRuleSetFileExist())) {
    throw new PropertiesException(""String_Node_Str"" + this.project.getName());
  }
}",0.9327354260089686
22074,"/** 
 * Set the rule set from rule specs found in properties file
 * @param rules array of selected rules
 */
private void setRuleSetFromProperties(IProjectProperties projectProperties,RuleSpecTO[] rules) throws PropertiesException {
  final RuleSet ruleSet=new RuleSet();
  final RuleSet pluginRuleSet=PMDRuntimePlugin.getDefault().getPreferencesManager().getRuleSet();
  for (int i=0; i < rules.length; i++) {
    try {
      final Rule rule=pluginRuleSet.getRuleByName(rules[i].getName());
      ruleSet.addRule(rule);
    }
 catch (    RuntimeException e) {
      log.debug(""String_Node_Str"" + rules[i].getName() + ""String_Node_Str"");
    }
  }
  projectProperties.setProjectRuleSet(ruleSet);
}","/** 
 * Set the rule set from rule specs found in properties file
 * @param rules array of selected rules
 */
private void setRuleSetFromProperties(IProjectProperties projectProperties,RuleSpecTO[] rules) throws PropertiesException {
  final RuleSet ruleSet=new RuleSet();
  final RuleSet pluginRuleSet=PMDRuntimePlugin.getDefault().getPreferencesManager().getRuleSet();
  int n=rules == null ? 0 : rules.length;
  for (int i=0; i < n; i++) {
    try {
      final Rule rule=pluginRuleSet.getRuleByName(rules[i].getName());
      ruleSet.addRule(rule);
    }
 catch (    RuntimeException e) {
      log.debug(""String_Node_Str"" + rules[i].getName() + ""String_Node_Str"");
    }
  }
  projectProperties.setProjectRuleSet(ruleSet);
}",0.9614576033637
22075,"/** 
 * Builds the HitEnum that finds the hits from Lucene.
 */
private List<HitEnum> buildLuceneHitFindingHitEnums() throws IOException {
  Set<String> matchedFields=context.field.fieldOptions().matchedFields();
  if (matchedFields == null) {
    if (!defaultField.canProduceHits()) {
      return Collections.emptyList();
    }
    return Collections.singletonList(defaultField.buildHitEnum());
  }
  List<HitEnum> hitEnums=new ArrayList<HitEnum>(matchedFields.size());
  extraFields=new ArrayList<FieldWrapper>(matchedFields.size());
  for (  String field : matchedFields) {
    FieldWrapper wrapper;
    if (context.fieldName.equals(field)) {
      wrapper=defaultField;
    }
 else {
      wrapper=new FieldWrapper(this,context,weigher,field);
      if (!wrapper.exists()) {
        continue;
      }
    }
    if (wrapper.canProduceHits()) {
      hitEnums.add(wrapper.buildHitEnum());
    }
    extraFields.add(wrapper);
  }
  if (hitEnums.size() == 0) {
    return Collections.emptyList();
  }
  return hitEnums;
}","/** 
 * Builds the HitEnum that finds the hits from Lucene.
 */
private List<HitEnum> buildLuceneHitFindingHitEnums() throws IOException {
  Set<String> matchedFields=context.field.fieldOptions().matchedFields();
  if (matchedFields == null) {
    if (!defaultField.canProduceHits()) {
      return Collections.emptyList();
    }
    return Collections.singletonList(defaultField.buildHitEnum());
  }
  List<HitEnum> hitEnums=new ArrayList<HitEnum>(matchedFields.size());
  extraFields=new ArrayList<FieldWrapper>(matchedFields.size());
  for (  String field : matchedFields) {
    FieldWrapper wrapper;
    if (context.fieldName.equals(field)) {
      wrapper=defaultField;
    }
 else {
      wrapper=new FieldWrapper(this,context,weigher,field);
      if (!wrapper.exists()) {
        continue;
      }
    }
    if (wrapper.canProduceHits()) {
      hitEnums.add(wrapper.buildHitEnum());
    }
    extraFields.add(wrapper);
  }
  if (hitEnums.isEmpty()) {
    return Collections.emptyList();
  }
  return hitEnums;
}",0.990205680705191
22076,"/** 
 * Builds the hit enum including any required wrappers.
 */
private HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitFindingHitEnum();
  e=new OverlapMergingHitEnumWrapper(e);
  if (getOption(OPTION_RETURN_DEBUG_GRAPH,false)) {
    e=new GraphvizHitEnum(e);
  }
  return e;
}","/** 
 * Builds the hit enum including any required wrappers.
 */
private HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitFindingHitEnum();
  e=new OverlapMergingHitEnumWrapper(e);
  if (getOption(OPTION_RETURN_DEBUG_GRAPH,FALSE)) {
    e=new GraphvizHitEnum(e);
  }
  return e;
}",0.9830508474576272
22077,"@SuppressWarnings(""String_Node_Str"") private List<HitEnum> buildRegexHitEnums() throws IOException {
  boolean luceneRegex=isLuceneRegexFlavor();
  if (luceneRegex) {
    cache.automatonHitEnumFactories=new HashMap<>();
  }
  Boolean caseInsensitiveOption=(Boolean)getOption(""String_Node_Str"");
  boolean caseInsensitive=caseInsensitiveOption == null ? false : caseInsensitiveOption;
  List<HitEnum> hitEnums=new ArrayList<>();
  List<String> fieldValues=defaultField.getFieldValues();
  if (fieldValues.size() == 0) {
    return hitEnums;
  }
  for (  String regex : getRegexes()) {
    if (luceneRegex) {
      if (caseInsensitive) {
        regex=regex.toLowerCase(getLocale());
      }
      AutomatonHitEnum.Factory factory=cache.automatonHitEnumFactories.get(regex);
      if (factory == null) {
        factory=buildFactoryForRegex(new RegExp(regex));
        cache.automatonHitEnumFactories.put(regex,factory);
      }
      hitEnums.add(buildLuceneRegexHitEnumForRegex(factory,fieldValues,caseInsensitive));
    }
 else {
      int options=0;
      if (caseInsensitive) {
        options|=Pattern.CASE_INSENSITIVE;
      }
      hitEnums.add(buildJavaRegexHitEnumForRegex(Pattern.compile(regex,options),fieldValues));
    }
  }
  return hitEnums;
}","@SuppressWarnings(""String_Node_Str"") private List<HitEnum> buildRegexHitEnums() throws IOException {
  boolean luceneRegex=isLuceneRegexFlavor();
  if (luceneRegex) {
    cache.automatonHitEnumFactories=new HashMap<>();
  }
  Boolean caseInsensitiveOption=(Boolean)getOption(""String_Node_Str"");
  boolean caseInsensitive=caseInsensitiveOption == null ? false : caseInsensitiveOption;
  List<HitEnum> hitEnums=new ArrayList<>();
  List<String> fieldValues=defaultField.getFieldValues();
  if (fieldValues.isEmpty()) {
    return hitEnums;
  }
  for (  String regex : getRegexes()) {
    if (luceneRegex) {
      if (caseInsensitive) {
        regex=regex.toLowerCase(getLocale());
      }
      AutomatonHitEnum.Factory factory=cache.automatonHitEnumFactories.get(regex);
      if (factory == null) {
        factory=buildFactoryForRegex(new RegExp(regex));
        cache.automatonHitEnumFactories.put(regex,factory);
      }
      hitEnums.add(buildLuceneRegexHitEnumForRegex(factory,fieldValues,caseInsensitive));
    }
 else {
      int options=0;
      if (caseInsensitive) {
        options|=Pattern.CASE_INSENSITIVE;
      }
      hitEnums.add(buildJavaRegexHitEnumForRegex(Pattern.compile(regex,options),fieldValues));
    }
  }
  return hitEnums;
}",0.9920382165605096
22078,"HighlightField highlight() throws IOException {
  if (shouldSkip()) {
    return null;
  }
  ensureWeigher();
  scoreMatters=context.field.fieldOptions().scoreOrdered();
  if (!scoreMatters) {
    Boolean topScoring=(Boolean)getOption(""String_Node_Str"");
    scoreMatters=topScoring != null && topScoring;
  }
  defaultField=new FieldWrapper(this,context,weigher);
  int numberOfSnippets=context.field.fieldOptions().numberOfFragments();
  if (numberOfSnippets == 0) {
    numberOfSnippets=1;
  }
  segmenter=new DelayedSegmenter(defaultField);
  List<Snippet> snippets=buildChooser().choose(segmenter,buildHitEnum(),numberOfSnippets);
  if (snippets.size() != 0) {
    cache.lastMatched=true;
    return new HighlightField(context.fieldName,formatSnippets(snippets));
  }
  cache.lastMatched=false;
  int noMatchSize=context.field.fieldOptions().noMatchSize();
  if (noMatchSize <= 0) {
    return null;
  }
  List<String> fieldValues=defaultField.getFieldValues();
  if (fieldValues.isEmpty()) {
    return null;
  }
  Text fragment=new Text(getSegmenterFactory().extractNoMatchFragment(fieldValues.get(0),noMatchSize));
  return new HighlightField(context.fieldName,new Text[]{fragment});
}","HighlightField highlight() throws IOException {
  if (shouldSkip()) {
    return null;
  }
  ensureWeigher();
  scoreMatters=context.field.fieldOptions().scoreOrdered();
  if (!scoreMatters) {
    Boolean topScoring=(Boolean)getOption(""String_Node_Str"");
    scoreMatters=topScoring != null && topScoring;
  }
  defaultField=new FieldWrapper(this,context,weigher);
  int numberOfSnippets=context.field.fieldOptions().numberOfFragments();
  if (numberOfSnippets == 0) {
    numberOfSnippets=1;
  }
  segmenter=new DelayedSegmenter(defaultField);
  List<Snippet> snippets=buildChooser().choose(segmenter,buildHitEnum(),numberOfSnippets);
  if (!snippets.isEmpty()) {
    cache.lastMatched=true;
    return new HighlightField(context.fieldName,formatSnippets(snippets));
  }
  cache.lastMatched=false;
  int noMatchSize=context.field.fieldOptions().noMatchSize();
  if (noMatchSize <= 0) {
    return null;
  }
  List<String> fieldValues=defaultField.getFieldValues();
  if (fieldValues.isEmpty()) {
    return null;
  }
  Text fragment=new Text(getSegmenterFactory().extractNoMatchFragment(fieldValues.get(0),noMatchSize));
  return new HighlightField(context.fieldName,new Text[]{fragment});
}",0.9844863731656184
22079,"private SnippetChooser buildChooser(){
  HitBuilder hitBuilder=Snippet.DEFAULT_HIT_BUILDER;
  if (getOption(OPTION_RETURN_DEBUG_GRAPH,false)) {
    hitBuilder=GraphvizHit.GRAPHVIZ_HIT_BUILDER;
  }
  if (context.field.fieldOptions().scoreOrdered()) {
    return buildScoreBasedSnippetChooser(true,hitBuilder);
  }
  Boolean topScoring=(Boolean)getOption(""String_Node_Str"");
  if (topScoring != null && topScoring) {
    return buildScoreBasedSnippetChooser(false,hitBuilder);
  }
  return new BasicSourceOrderSnippetChooser(hitBuilder);
}","private SnippetChooser buildChooser(){
  HitBuilder hitBuilder=Snippet.DEFAULT_HIT_BUILDER;
  if (getOption(OPTION_RETURN_DEBUG_GRAPH,FALSE)) {
    hitBuilder=GraphvizHit.GRAPHVIZ_HIT_BUILDER;
  }
  if (context.field.fieldOptions().scoreOrdered()) {
    return buildScoreBasedSnippetChooser(true,hitBuilder);
  }
  Boolean topScoring=(Boolean)getOption(""String_Node_Str"");
  if (topScoring != null && topScoring) {
    return buildScoreBasedSnippetChooser(false,hitBuilder);
  }
  return new BasicSourceOrderSnippetChooser(hitBuilder);
}",0.9906890130353816
22080,"private Text[] formatSnippets(List<Snippet> snippets) throws IOException {
  final SnippetFormatter formatter;
  if (getOption(""String_Node_Str"",false)) {
    formatter=new OffsetSnippetFormatter();
  }
 else   if (getOption(OPTION_RETURN_DEBUG_GRAPH,false)) {
    formatter=new GraphvizSnippetFormatter(defaultField.buildSourceExtracter());
  }
 else   if (getOption(OPTION_RETURN_SNIPPETS_WITH_OFFSET,false)) {
    formatter=new OffsetAugmenterSnippetFormatter(new SnippetFormatter.Default(defaultField.buildSourceExtracter(),context.field.fieldOptions().preTags()[0],context.field.fieldOptions().postTags()[0]));
  }
 else {
    formatter=new SnippetFormatter.Default(defaultField.buildSourceExtracter(),context.field.fieldOptions().preTags()[0],context.field.fieldOptions().postTags()[0]);
  }
  List<FieldWrapper> fetchFields=buildFetchFields();
  if (fetchFields == null) {
    Text[] result=new Text[snippets.size()];
    int i=0;
    for (    Snippet snippet : snippets) {
      result[i++]=new Text(formatter.format(snippet));
    }
    return result;
  }
  int fieldsPerSnippet=1 + fetchFields.size();
  Text[] result=new Text[snippets.size() * fieldsPerSnippet];
  FetchedFieldIndexPicker picker=segmenter.buildFetchedFieldIndexPicker();
  int i=0;
  for (  Snippet snippet : snippets) {
    result[i++]=new Text(formatter.format(snippet));
    int index=picker.index(snippet);
    for (    FieldWrapper fetchField : fetchFields) {
      List<String> values=fetchField.getFieldValues();
      if (index >= 0 && index < values.size()) {
        result[i++]=new Text(values.get(index));
      }
 else {
        result[i++]=EMPTY_STRING;
      }
    }
  }
  return result;
}","private Text[] formatSnippets(List<Snippet> snippets) throws IOException {
  final SnippetFormatter formatter;
  if (getOption(""String_Node_Str"",FALSE)) {
    formatter=new OffsetSnippetFormatter();
  }
 else   if (getOption(OPTION_RETURN_DEBUG_GRAPH,FALSE)) {
    formatter=new GraphvizSnippetFormatter(defaultField.buildSourceExtracter());
  }
 else   if (getOption(OPTION_RETURN_SNIPPETS_WITH_OFFSET,FALSE)) {
    formatter=new OffsetAugmenterSnippetFormatter(new SnippetFormatter.Default(defaultField.buildSourceExtracter(),context.field.fieldOptions().preTags()[0],context.field.fieldOptions().postTags()[0]));
  }
 else {
    formatter=new SnippetFormatter.Default(defaultField.buildSourceExtracter(),context.field.fieldOptions().preTags()[0],context.field.fieldOptions().postTags()[0]);
  }
  List<FieldWrapper> fetchFields=buildFetchFields();
  if (fetchFields == null) {
    Text[] result=new Text[snippets.size()];
    int i=0;
    for (    Snippet snippet : snippets) {
      result[i++]=new Text(formatter.format(snippet));
    }
    return result;
  }
  int fieldsPerSnippet=1 + fetchFields.size();
  Text[] result=new Text[snippets.size() * fieldsPerSnippet];
  FetchedFieldIndexPicker picker=segmenter.buildFetchedFieldIndexPicker();
  int i=0;
  for (  Snippet snippet : snippets) {
    result[i++]=new Text(formatter.format(snippet));
    int index=picker.index(snippet);
    for (    FieldWrapper fetchField : fetchFields) {
      List<String> values=fetchField.getFieldValues();
      if (index >= 0 && index < values.size()) {
        result[i++]=new Text(values.get(index));
      }
 else {
        result[i++]=EMPTY_STRING;
      }
    }
  }
  return result;
}",0.9910820451843044
22081,"private void ensureWeigher(){
  if (weigher != null) {
    return;
  }
  boolean phraseAsTerms=getOption(""String_Node_Str"",false);
  boolean removeHighFrequencyTermsFromCommonTerms=getOption(""String_Node_Str"",true);
  int maxExpandedTerms=getOption(""String_Node_Str"",1024);
  QueryCacheKey key=new QueryCacheKey(context.query,maxExpandedTerms,phraseAsTerms,removeHighFrequencyTermsFromCommonTerms);
  weigher=cache.queryWeighers.get(key);
  if (weigher != null) {
    return;
  }
  BytesRefHashTermInfos infos=new BytesRefHashTermInfos(BigArrays.NON_RECYCLING_INSTANCE);
  weigher=new BasicQueryWeigher(new ElasticsearchQueryFlattener(maxExpandedTerms,phraseAsTerms,removeHighFrequencyTermsFromCommonTerms),infos,context.hitContext.topLevelReader(),context.query);
  cache.queryWeighers.put(key,weigher);
}","private void ensureWeigher(){
  if (weigher != null) {
    return;
  }
  boolean phraseAsTerms=getOption(""String_Node_Str"",FALSE);
  boolean removeHighFrequencyTermsFromCommonTerms=getOption(""String_Node_Str"",TRUE);
  int maxExpandedTerms=getOption(""String_Node_Str"",1024);
  QueryCacheKey key=new QueryCacheKey(context.query,maxExpandedTerms,phraseAsTerms,removeHighFrequencyTermsFromCommonTerms);
  weigher=cache.queryWeighers.get(key);
  if (weigher != null) {
    return;
  }
  BytesRefHashTermInfos infos=new BytesRefHashTermInfos(BigArrays.NON_RECYCLING_INSTANCE);
  weigher=new BasicQueryWeigher(new ElasticsearchQueryFlattener(maxExpandedTerms,phraseAsTerms,removeHighFrequencyTermsFromCommonTerms),infos,context.hitContext.topLevelReader(),context.query);
  cache.queryWeighers.put(key,weigher);
}",0.988833746898263
22082,"private TermWeigher<BytesRef> getQueryWeigher(boolean mightWeighTermsMultipleTimes){
  return weigher;
}","private TermWeigher<BytesRef> getQueryWeigher(){
  return weigher;
}",0.7906976744186046
22083,"public List<String> getFieldValues() throws IOException {
  if (values == null) {
    List<Object> objs=HighlightUtils.loadFieldValues(context.field,context.mapper,context.context,context.hitContext);
    values=new ArrayList<String>(objs.size());
    for (    Object obj : objs) {
      values.add(obj.toString());
    }
  }
  return values;
}","public List<String> getFieldValues() throws IOException {
  if (values == null) {
    List<Object> objs=HighlightUtils.loadFieldValues(context.field,context.mapper,context.context,context.hitContext);
    values=objs.stream().map(Object::toString).collect(toCollection(() -> new ArrayList<>(objs.size())));
  }
  return values;
}",0.7548291233283804
22084,"public HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitEnumForSource();
  e=weigher.wrap(context.fieldName,e);
  FieldOptions options=context.field.fieldOptions();
  if (!options.scoreOrdered()) {
    Boolean topScoring=(Boolean)executionContext.getOption(""String_Node_Str"");
    if (topScoring == null || !topScoring) {
      e=new WeightFilteredHitEnumWrapper(e,0f);
      return e;
    }
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> boostBefore=(Map<String,Object>)executionContext.getOption(""String_Node_Str"");
  if (boostBefore != null) {
    TreeMap<Integer,Float> ordered=new TreeMap<Integer,Float>();
    for (    Map.Entry<String,Object> entry : boostBefore.entrySet()) {
      if (!(entry.getValue() instanceof Number)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ordered.put(Integer.valueOf(entry.getKey()),((Number)entry.getValue()).floatValue());
    }
    PositionBoostingHitEnumWrapper boosting=new PositionBoostingHitEnumWrapper(e);
    e=boosting;
    for (    Map.Entry<Integer,Float> entry : ordered.entrySet()) {
      boosting.add(entry.getKey(),entry.getValue());
    }
  }
  e=new WeightFilteredHitEnumWrapper(e,0f);
  return e;
}","public HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitEnumForSource();
  e=weigher.wrap(context.fieldName,e);
  FieldOptions options=context.field.fieldOptions();
  if (!options.scoreOrdered()) {
    Boolean topScoring=(Boolean)executionContext.getOption(""String_Node_Str"");
    if (topScoring == null || !topScoring) {
      return new WeightFilteredHitEnumWrapper(e,0f);
    }
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> boostBefore=(Map<String,Object>)executionContext.getOption(""String_Node_Str"");
  if (boostBefore != null) {
    TreeMap<Integer,Float> ordered=new TreeMap<Integer,Float>();
    for (    Map.Entry<String,Object> entry : boostBefore.entrySet()) {
      if (!(entry.getValue() instanceof Number)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ordered.put(Integer.valueOf(entry.getKey()),((Number)entry.getValue()).floatValue());
    }
    PositionBoostingHitEnumWrapper boosting=new PositionBoostingHitEnumWrapper(e);
    e=boosting;
    for (    Map.Entry<Integer,Float> entry : ordered.entrySet()) {
      boosting.add(entry.getKey(),entry.getValue());
    }
  }
  return new WeightFilteredHitEnumWrapper(e,0f);
}",0.981023102310231
22085,"private HitEnum buildPostingsHitEnum() throws IOException {
  return PostingsHitEnum.fromPostings(context.hitContext.reader(),context.hitContext.docId(),context.mapper.fieldType().name(),weigher.acceptableTerms(),getQueryWeigher(false),getCorpusWeigher(false),weigher);
}","private HitEnum buildPostingsHitEnum() throws IOException {
  return PostingsHitEnum.fromPostings(context.hitContext.reader(),context.hitContext.docId(),context.mapper.fieldType().name(),weigher.acceptableTerms(),getQueryWeigher(),getCorpusWeigher(false),weigher);
}",0.9906890130353816
22086,"private HitEnum buildTokenStreamHitEnum(Analyzer analyzer,String source) throws IOException {
  TokenStream tokenStream;
  try {
    tokenStream=analyzer.tokenStream(context.fieldName,source);
  }
 catch (  IllegalStateException e) {
    throw new UnsupportedOperationException(""String_Node_Str"",e);
  }
  this.tokenStream=tokenStream;
  return new TokenStreamHitEnum(tokenStream,getQueryWeigher(true),getCorpusWeigher(true),weigher);
}","private HitEnum buildTokenStreamHitEnum(Analyzer analyzer,String source){
  TokenStream tokenStream;
  try {
    tokenStream=analyzer.tokenStream(context.fieldName,source);
  }
 catch (  IllegalStateException e) {
    throw new UnsupportedOperationException(""String_Node_Str"",e);
  }
  this.tokenStream=tokenStream;
  return new TokenStreamHitEnum(tokenStream,getQueryWeigher(),getCorpusWeigher(true),weigher);
}",0.5990566037735849
22087,"private HitEnum buildTermVectorsHitEnum() throws IOException {
  return PostingsHitEnum.fromTermVectors(context.hitContext.reader(),context.hitContext.docId(),context.mapper.fieldType().name(),weigher.acceptableTerms(),getQueryWeigher(false),getCorpusWeigher(false),weigher);
}","private HitEnum buildTermVectorsHitEnum() throws IOException {
  return PostingsHitEnum.fromTermVectors(context.hitContext.reader(),context.hitContext.docId(),context.mapper.fieldType().name(),weigher.acceptableTerms(),getQueryWeigher(),getCorpusWeigher(false),weigher);
}",0.9908925318761383
22088,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + maxEdits;
  result=prime * result + prefixLength;
  result=prime * result + ((term == null) ? 0 : term.hashCode());
  result=prime * result + (transpositions ? 1231 : 1237);
  return result;
}","@Override public int hashCode(){
  return Objects.hash(maxEdits,prefixLength,term,transpositions);
}",0.416452442159383
22089,"private static HitEnum fromTerms(Terms terms,CompiledAutomaton acceptable,IndexReader reader,int docId,TermWeigher<BytesRef> queryWeigher,TermWeigher<BytesRef> corpusWeigher,TermSourceFinder<BytesRef> sourceFinder) throws IOException {
  if (terms == null) {
    return EmptyHitEnum.INSTANCE;
  }
  TermsEnum termsEnum=acceptable.getTermsEnum(terms);
  BytesRef term;
  List<HitEnum> enums=new ArrayList<HitEnum>();
  PostingsEnum dp=null;
  while ((term=termsEnum.next()) != null) {
    dp=termsEnum.postings(dp,PostingsEnum.OFFSETS);
    if (dp == null) {
      continue;
    }
    if (docId < 0) {
      if (dp.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {
        continue;
      }
    }
 else {
      if (dp.advance(docId) != docId) {
        continue;
      }
    }
    HitEnum e=new PostingsHitEnum(dp,queryWeigher.weigh(term),corpusWeigher.weigh(term),sourceFinder.source(term));
    enums.add(e);
    dp=null;
  }
switch (enums.size()) {
case 0:
    return EmptyHitEnum.INSTANCE;
case 1:
  return enums.get(0);
default :
}
return new MergingHitEnum(enums,HitEnum.LessThans.POSITION);
}","private static HitEnum fromTerms(Terms terms,CompiledAutomaton acceptable,int docId,TermWeigher<BytesRef> queryWeigher,TermWeigher<BytesRef> corpusWeigher,TermSourceFinder<BytesRef> sourceFinder) throws IOException {
  if (terms == null) {
    return EmptyHitEnum.INSTANCE;
  }
  TermsEnum termsEnum=acceptable.getTermsEnum(terms);
  BytesRef term;
  List<HitEnum> enums=new ArrayList<HitEnum>();
  PostingsEnum dp=null;
  while ((term=termsEnum.next()) != null) {
    dp=termsEnum.postings(dp,PostingsEnum.OFFSETS);
    if (dp == null) {
      continue;
    }
    if (docId < 0) {
      if (dp.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {
        continue;
      }
    }
 else {
      if (dp.advance(docId) != docId) {
        continue;
      }
    }
    HitEnum e=new PostingsHitEnum(dp,queryWeigher.weigh(term),corpusWeigher.weigh(term),sourceFinder.source(term));
    enums.add(e);
    dp=null;
  }
switch (enums.size()) {
case 0:
    return EmptyHitEnum.INSTANCE;
case 1:
  return enums.get(0);
default :
}
return new MergingHitEnum(enums,HitEnum.LessThans.POSITION);
}",0.9912402028584602
22090,"public static HitEnum fromTermVectors(IndexReader reader,int docId,String fieldName,CompiledAutomaton acceptable,TermWeigher<BytesRef> queryWeigher,TermWeigher<BytesRef> corpusWeigher,TermSourceFinder<BytesRef> sourceFinder) throws IOException {
  Fields vectors=reader.getTermVectors(docId);
  if (vectors == null) {
    return EmptyHitEnum.INSTANCE;
  }
  return fromTerms(vectors.terms(fieldName),acceptable,reader,-1,queryWeigher,corpusWeigher,sourceFinder);
}","public static HitEnum fromTermVectors(IndexReader reader,int docId,String fieldName,CompiledAutomaton acceptable,TermWeigher<BytesRef> queryWeigher,TermWeigher<BytesRef> corpusWeigher,TermSourceFinder<BytesRef> sourceFinder) throws IOException {
  Fields vectors=reader.getTermVectors(docId);
  if (vectors == null) {
    return EmptyHitEnum.INSTANCE;
  }
  return fromTerms(vectors.terms(fieldName),acceptable,-1,queryWeigher,corpusWeigher,sourceFinder);
}",0.992399565689468
22091,"public static HitEnum fromPostings(IndexReader reader,int docId,String fieldName,CompiledAutomaton acceptable,TermWeigher<BytesRef> queryWeigher,TermWeigher<BytesRef> corpusWeigher,TermSourceFinder<BytesRef> sourceFinder) throws IOException {
  List<LeafReaderContext> leaves=reader.getContext().leaves();
  int leaf=ReaderUtil.subIndex(docId,leaves);
  LeafReaderContext subcontext=leaves.get(leaf);
  LeafReader atomicReader=subcontext.reader();
  docId-=subcontext.docBase;
  return fromTerms(atomicReader.terms(fieldName),acceptable,reader,docId,queryWeigher,corpusWeigher,sourceFinder);
}","public static HitEnum fromPostings(IndexReader reader,int docId,String fieldName,CompiledAutomaton acceptable,TermWeigher<BytesRef> queryWeigher,TermWeigher<BytesRef> corpusWeigher,TermSourceFinder<BytesRef> sourceFinder) throws IOException {
  List<LeafReaderContext> leaves=reader.getContext().leaves();
  int leaf=ReaderUtil.subIndex(docId,leaves);
  LeafReaderContext subcontext=leaves.get(leaf);
  LeafReader atomicReader=subcontext.reader();
  docId-=subcontext.docBase;
  return fromTerms(atomicReader.terms(fieldName),acceptable,docId,queryWeigher,corpusWeigher,sourceFinder);
}",0.9940627650551316
22092,"@Override public boolean next(){
  try {
    if (!tokenStream.incrementToken()) {
      return false;
    }
    BytesRef term=termRef.getBytesRef();
    position+=positionIncr.getPositionIncrement();
    queryWeight=queryWeigher.weigh(term);
    corpusWeight=corpusWeigher.weigh(term);
    source=sourceFinder.source(term);
    return true;
  }
 catch (  IOException e) {
    throw new WrappedExceptionFromLucene(e);
  }
}","@Override @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public boolean next(){
  try {
    if (!tokenStream.incrementToken()) {
      return false;
    }
    BytesRef term=termRef.getBytesRef();
    position+=positionIncr.getPositionIncrement();
    queryWeight=queryWeigher.weigh(term);
    corpusWeight=corpusWeigher.weigh(term);
    source=sourceFinder.source(term);
    return true;
  }
 catch (  IOException e) {
    throw new WrappedExceptionFromLucene(e);
  }
}",0.9163952225841476
22093,"@Override public String toString(){
  StringBuilder b=new StringBuilder();
  for (int p=0; p < phrase.length; p++) {
    if (p != 0) {
      b.append(""String_Node_Str"");
    }
    b.append(Arrays.toString(phrase[p]));
  }
  return b.toString();
}","@Override public String toString(){
  StringBuilder b=new StringBuilder();
  for (int p=0; p < phrase.length; p++) {
    if (p != 0) {
      b.append(':');
    }
    b.append(Arrays.toString(phrase[p]));
  }
  return b.toString();
}",0.9581589958158996
22094,"@SuppressWarnings(""String_Node_Str"") public PriorityQueue(int maxSize,boolean prepopulate){
  size=0;
  int heapSize;
  if (0 == maxSize) {
    heapSize=2;
  }
 else {
    if (maxSize > MAX_ARRAY_LENGTH) {
      throw new IllegalArgumentException(""String_Node_Str"" + MAX_ARRAY_LENGTH + ""String_Node_Str""+ maxSize);
    }
 else {
      heapSize=maxSize + 1;
    }
  }
  heap=(T[])new Object[heapSize];
  this.maxSize=maxSize;
  if (prepopulate) {
    T sentinel=getSentinelObject();
    if (sentinel != null) {
      heap[1]=sentinel;
      for (int i=2; i < heap.length; i++) {
        heap[i]=getSentinelObject();
      }
      size=maxSize;
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @SuppressFBWarnings(value={""String_Node_Str"",""String_Node_Str""},justification=""String_Node_Str"") public PriorityQueue(int maxSize,boolean prepopulate){
  size=0;
  int heapSize;
  if (0 == maxSize) {
    heapSize=2;
  }
 else {
    if (maxSize > MAX_ARRAY_LENGTH) {
      throw new IllegalArgumentException(""String_Node_Str"" + MAX_ARRAY_LENGTH + ""String_Node_Str""+ maxSize);
    }
 else {
      heapSize=maxSize + 1;
    }
  }
  heap=(T[])new Object[heapSize];
  this.maxSize=maxSize;
  if (prepopulate) {
    T sentinel=getSentinelObject();
    if (sentinel != null) {
      heap[1]=sentinel;
      for (int i=2; i < heap.length; i++) {
        heap[i]=getSentinelObject();
      }
      size=maxSize;
    }
  }
}",0.9309608540925268
22095,"@Override public String toString(){
  return ""String_Node_Str"" + delegate.toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + delegate;
}",0.9325153374233128
22096,"@Override public String toString(){
  StringBuilder b=new StringBuilder(100).append('[');
  for (int p=0; p < phrase.length; p++) {
    if (p != 0) {
      b.append(""String_Node_Str"");
    }
    b.append(Arrays.toString(phrase[p]));
  }
  return b.append(""String_Node_Str"").append(phraseSlop).append('\u21D2').append(phraseWeight).append('(').append(wrapped).append(')').toString();
}","@Override public String toString(){
  StringBuilder b=new StringBuilder(100).append('[');
  for (int p=0; p < phrase.length; p++) {
    if (p != 0) {
      b.append(':');
    }
    b.append(Arrays.toString(phrase[p]));
  }
  return b.append(""String_Node_Str"").append(phraseSlop).append('\u21D2').append(phraseWeight).append('(').append(wrapped).append(')').toString();
}",0.973474801061008
22097,"@Override public float weigh(List<Hit> hits){
switch (hits.size()) {
case 0:
    return 0;
case 1:
  return base * hits.get(0).weight();
default :
}
Hit[] sorted=new Hit[hits.size()];
for (int i=0; i < hits.size(); i++) {
sorted[i]=hits.get(i);
}
Arrays.sort(sorted,new SourceComparator());
float weight=0;
int lastSource=sorted[0].source();
float sum=sorted[0].weight();
int count=1;
for (int i=1; i < hits.size(); i++) {
Hit current=sorted[i];
if (lastSource != current.source()) {
  weight+=Math.pow(base,count) * sum / count;
  lastSource=current.source();
  sum=current.weight();
  count=1;
  continue;
}
sum+=current.weight();
count++;
}
weight+=Math.pow(base,count) * sum / count;
return weight;
}","@Override @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public float weigh(List<Hit> hits){
switch (hits.size()) {
case 0:
    return 0;
case 1:
  return base * hits.get(0).weight();
default :
}
Hit[] sorted=hits.toArray(new Hit[hits.size()]);
Arrays.sort(sorted,new SourceComparator());
float weight=0;
int lastSource=sorted[0].source();
float sum=sorted[0].weight();
int count=1;
for (int i=1; i < hits.size(); i++) {
Hit current=sorted[i];
if (lastSource != current.source()) {
  weight+=Math.pow(base,count) * sum / count;
  lastSource=current.source();
  sum=current.weight();
  count=1;
  continue;
}
sum+=current.weight();
count++;
}
weight+=Math.pow(base,count) * sum / count;
return weight;
}",0.8913649025069638
22098,"/** 
 * Add a node to the current graph with extra infos
 * @param hitEnum
 * @param params
 * @return the node id
 */
public int addNode(HitEnum hitEnum,Map<String,Object> params){
  int id=getHitEnumId(hitEnum);
  graph.append(""String_Node_Str"").append(id).append(""String_Node_Str"").append(hitEnum.getClass().getSimpleName()).append(""String_Node_Str"").append(""String_Node_Str"").append(hitEnum.position()).append(""String_Node_Str"").append(""String_Node_Str"").append(hitEnum.startOffset()).append(""String_Node_Str"").append(hitEnum.endOffset()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(hitEnum.corpusWeight()).append(""String_Node_Str"").append(hitEnum.queryWeight()).append(""String_Node_Str"");
  appendKeyValue(""String_Node_Str"",hitEnum.source());
  if (!params.isEmpty()) {
    for (    Map.Entry<String,Object> en : params.entrySet()) {
      appendKeyValue(en.getKey(),en.getValue());
    }
  }
  graph.append(""String_Node_Str"");
  return id;
}","/** 
 * Add a node to the current graph with extra infos
 * @param hitEnum
 * @param params
 * @return the node id
 */
public int addNode(HitEnum hitEnum,Map<String,Object> params){
  int id=getHitEnumId(hitEnum);
  graph.append(""String_Node_Str"").append(id).append(""String_Node_Str"").append(hitEnum.getClass().getSimpleName()).append(""String_Node_Str"").append(""String_Node_Str"").append(hitEnum.position()).append(""String_Node_Str"").append('[').append(hitEnum.startOffset()).append(""String_Node_Str"").append(hitEnum.endOffset()).append(']').append(""String_Node_Str"").append(""String_Node_Str"").append(hitEnum.corpusWeight()).append(""String_Node_Str"").append(hitEnum.queryWeight()).append(""String_Node_Str"");
  appendKeyValue(""String_Node_Str"",hitEnum.source());
  if (!params.isEmpty()) {
    for (    Map.Entry<String,Object> en : params.entrySet()) {
      appendKeyValue(en.getKey(),en.getValue());
    }
  }
  graph.append(""String_Node_Str"");
  return id;
}",0.9794661190965092
22099,"/** 
 * @return Generate the Graph of the HitEnum state
 */
public String generateGraph(HitEnum hitEnum){
  graph.setLength(0);
  links.clear();
  graph.append(""String_Node_Str"");
  graph.append(""String_Node_Str"");
  graph.append(""String_Node_Str"");
  hitEnum.toGraph(this);
  graph.append(""String_Node_Str"");
  writeLinks();
  graph.append(""String_Node_Str"");
  return graph.toString();
}","/** 
 * @return Generate the Graph of the HitEnum state
 */
public String generateGraph(HitEnum hitEnum){
  graph.setLength(0);
  links.clear();
  graph.append(""String_Node_Str"");
  graph.append(""String_Node_Str"");
  graph.append(""String_Node_Str"");
  hitEnum.toGraph(this);
  graph.append(""String_Node_Str"");
  writeLinks();
  graph.append('}');
  return graph.toString();
}",0.8952879581151832
22100,"private void writeLinks(){
  for (  Link link : links) {
    graph.append(""String_Node_Str"").append(link.from).append(""String_Node_Str"").append(link.to).append(""String_Node_Str"");
  }
}","private void writeLinks(){
  for (  Link link : links) {
    graph.append(' ').append(link.from).append(""String_Node_Str"").append(link.to).append('\n');
  }
}",0.8862973760932945
22101,"@Override public String format(Snippet snippet){
  StringBuilder b=new StringBuilder();
  for (  Hit hit : snippet.hits()) {
    if (!(hit instanceof GraphvizHit)) {
      throw new IllegalArgumentException(""String_Node_Str"" + GraphvizHit.class + ""String_Node_Str""+ hit.getClass()+ ""String_Node_Str"");
    }
    GraphvizHit hitGraph=(GraphvizHit)hit;
    b.append(extracter.extract(hit.startOffset(),hit.endOffset())).append(""String_Node_Str"").append(hitGraph.getGraph()).append(""String_Node_Str"");
  }
  return b.toString();
}","@Override public String format(Snippet snippet){
  StringBuilder b=new StringBuilder();
  for (  Hit hit : snippet.hits()) {
    if (!(hit instanceof GraphvizHit)) {
      throw new IllegalArgumentException(""String_Node_Str"" + GraphvizHit.class + ""String_Node_Str""+ hit.getClass()+ ""String_Node_Str"");
    }
    GraphvizHit hitGraph=(GraphvizHit)hit;
    b.append(extracter.extract(hit.startOffset(),hit.endOffset())).append(""String_Node_Str"").append(hitGraph.getGraph()).append('\n');
  }
  return b.toString();
}",0.9798270893371758
22102,"/** 
 * Build with a provided cache.
 */
public CachingTermWeigher(Cache<T> cache,TermWeigher<T> next){
  this.cache=cache;
  this.next=next;
}","/** 
 * Build with a provided cache.
 * @param cache the cache backend to use
 * @param next the term weigher to cache
 */
public CachingTermWeigher(Cache<T> cache,TermWeigher<T> next){
  this.cache=cache;
  this.next=next;
}",0.7771739130434783
22103,"@Override public boolean next(){
  if (position == -1) {
    endOffset=itr.next();
  }
 else {
    startOffset=endOffset;
    endOffset=itr.next();
  }
  position++;
  if (endOffset == BreakIterator.DONE) {
    return false;
  }
 else {
    weight=weigher.weight(position,startOffset,endOffset);
    return true;
  }
}","@Override public boolean next(){
  if (position == -1) {
    endOffset=itr.next();
  }
 else {
    startOffset=endOffset;
    endOffset=itr.next();
  }
  position++;
  if (endOffset == BreakIterator.DONE) {
    return false;
  }
 else {
    queryWeight=queryWeigher.weight(position,startOffset,endOffset);
    corpusWeight=corpusWeigher.weight(position,startOffset,endOffset);
    return true;
  }
}",0.8619246861924686
22104,"public BreakIteratorHitEnum(BreakIterator itr,HitWeigher weigher){
  this.itr=itr;
  this.weigher=weigher;
  startOffset=itr.first();
}","public BreakIteratorHitEnum(BreakIterator itr,HitWeigher queryWeigher,HitWeigher corpusWeigher){
  this.itr=itr;
  this.queryWeigher=queryWeigher;
  this.corpusWeigher=corpusWeigher;
  startOffset=itr.first();
}",0.7225433526011561
22105,"/** 
 * Record the current position of e.
 */
public void recordCurrent(HitEnum e){
  record(e.position(),e.startOffset(),e.endOffset(),e.weight(),e.source());
}","/** 
 * Record the current position of e.
 */
public void recordCurrent(HitEnum e){
  record(e.position(),e.startOffset(),e.endOffset(),e.queryWeight(),e.corpusWeight(),e.source());
}",0.9302325581395348
22106,"public Hit(int position,int startOffset,int endOffset,float weight,int source){
  this.position=position;
  this.startOffset=startOffset;
  this.endOffset=endOffset;
  this.weight=weight;
  this.source=source;
}","public Hit(int position,int startOffset,int endOffset,float queryWeight,float corpusWeight,int source){
  this.position=position;
  this.startOffset=startOffset;
  this.endOffset=endOffset;
  this.queryWeight=queryWeight;
  this.corpusWeight=corpusWeight;
  this.source=source;
}",0.8244897959183674
22107,"/** 
 * Record a list of enums.
 * @param positionGap positions between enums
 * @param offsetGap offsets between enums
 */
public void record(Iterator<HitEnumAndLength> enums,int positionGap,int offsetGap){
  int relativePosition=0;
  int relativeOffset=0;
  while (enums.hasNext()) {
    HitEnumAndLength e=enums.next();
    int position=0;
    int endOffset=0;
    while (e.delegate().next()) {
      position=e.delegate().position();
      endOffset=e.delegate().endOffset();
      record(position + relativePosition,e.delegate().startOffset() + relativeOffset,endOffset + relativeOffset,e.delegate().weight(),e.delegate().source());
    }
    relativePosition+=position + positionGap;
    relativeOffset+=e.length + offsetGap;
  }
}","/** 
 * Record a list of enums.
 * @param positionGap positions between enums
 * @param offsetGap offsets between enums
 */
public void record(Iterator<HitEnumAndLength> enums,int positionGap,int offsetGap){
  int relativePosition=0;
  int relativeOffset=0;
  while (enums.hasNext()) {
    HitEnumAndLength e=enums.next();
    int position=0;
    int endOffset=0;
    while (e.delegate().next()) {
      position=e.delegate().position();
      endOffset=e.delegate().endOffset();
      record(position + relativePosition,e.delegate().startOffset() + relativeOffset,endOffset + relativeOffset,e.delegate().queryWeight(),e.delegate().corpusWeight(),e.delegate().source());
    }
    relativePosition+=position + positionGap;
    relativeOffset+=e.length + offsetGap;
  }
}",0.9714664897146648
22108,"@Override public String toString(){
  return String.format(Locale.ENGLISH,""String_Node_Str"",weight,position);
}","@Override public String toString(){
  return String.format(Locale.ENGLISH,""String_Node_Str"",queryWeight * corpusWeight,position);
}",0.9090909090909092
22109,"@Override protected boolean keep(){
  return wrapped().weight() > cutoff;
}","@Override protected boolean keep(){
  return wrapped().queryWeight() * wrapped().corpusWeight() > cutoff;
}",0.8241758241758241
22110,"private PhraseCandidate(){
  matchedPositions=new int[phrase.length];
  matchedPositions[0]=wrapped.position();
  matchedSources=new int[phrase.length];
  matchedSources[0]=wrapped.source();
  phrasePosition=1;
}","private PhraseCandidate(){
  matchedPositions=new int[phrase.length];
  matchedPositions[0]=wrapped.position();
  matchedSources=new int[phrase.length];
  matchedSources[0]=wrapped.source();
  horizon=matchedPositions[0] + phrase.length + phraseSlop - 1;
  phrasePosition=1;
}",0.8073770491803278
22111,"private boolean acceptsCurrent(){
  int index=Arrays.binarySearch(phrase[phrasePosition],wrapped.source());
  if (index >= 0) {
    lastIndex++;
    matchedPositions[lastIndex]=wrapped.position();
    matchedSources[lastIndex]=wrapped.source();
    phrasePosition++;
    return true;
  }
  return wrapped.position() <= matchedPositions[lastIndex] + phraseSlop;
}","private boolean acceptsCurrent(){
  int distanceLeft=horizon - wrapped.position();
  if (distanceLeft < 0) {
    return false;
  }
  int index=Arrays.binarySearch(phrase[phrasePosition],wrapped.source());
  if (index >= 0) {
    lastIndex++;
    matchedPositions[lastIndex]=wrapped.position();
    matchedSources[lastIndex]=wrapped.source();
    phrasePosition++;
    return true;
  }
  return distanceLeft >= 1;
}",0.7731958762886598
22112,"/** 
 * Copies the contents of the queue in heap order. If you need them in any particular order, you should sort them.
 */
public List<ProtoSnippet> contents(){
  List<ProtoSnippet> snippets=new ArrayList<ProtoSnippet>(size());
  Object[] heapArray=getHeapArray();
  for (int i=0; i < heapArray.length; i++) {
    Object o=heapArray[i];
    if (o == null) {
      continue;
    }
    snippets.add((ProtoSnippet)o);
  }
  return snippets;
}","/** 
 * Copies the contents of the queue in heap order. If you need them in any particular order, you should sort them.
 */
public ProtoSnippet[] contents(){
  ProtoSnippet[] snippets=new ProtoSnippet[size()];
  Object[] heapArray=getHeapArray();
  int s=0;
  for (int i=0; i < heapArray.length; i++) {
    Object o=heapArray[i];
    if (o == null) {
      continue;
    }
    snippets[s++]=(ProtoSnippet)o;
  }
  return snippets;
}",0.9380733944954128
22113,"@Override protected List<Snippet> results(State state){
  ProtoSnippet[] protos=state.results.contents().toArray(new ProtoSnippet[state.results.contents().size()]);
  Arrays.sort(protos,ProtoSnippetComparators.OFFSETS);
  int lastSnippetEnd=0;
  for (  ProtoSnippet proto : protos) {
    proto.pickedBounds=proto.memo.pickBounds(lastSnippetEnd,Integer.MAX_VALUE);
    lastSnippetEnd=proto.pickedBounds.endOffset();
  }
  if (scoreOrdered) {
    Arrays.sort(protos,ProtoSnippetComparators.WEIGHT);
  }
  List<Snippet> results=new ArrayList<Snippet>(protos.length);
  for (  ProtoSnippet proto : protos) {
    results.add(new Snippet(proto.pickedBounds.startOffset(),proto.pickedBounds.endOffset(),proto.hits));
  }
  return results;
}","@Override protected List<Snippet> results(State state){
  ProtoSnippet[] protos=state.results.contents();
  Arrays.sort(protos,ProtoSnippetComparators.OFFSETS);
  int lastSnippetEnd=0;
  for (  ProtoSnippet proto : protos) {
    proto.pickedBounds=proto.memo.pickBounds(lastSnippetEnd,Integer.MAX_VALUE);
    lastSnippetEnd=proto.pickedBounds.endOffset();
  }
  if (scoreOrdered) {
    Arrays.sort(protos,ProtoSnippetComparators.WEIGHT);
  }
  List<Snippet> results=new ArrayList<Snippet>(protos.length);
  for (  ProtoSnippet proto : protos) {
    results.add(new Snippet(proto.pickedBounds.startOffset(),proto.pickedBounds.endOffset(),proto.hits));
  }
  return results;
}",0.9580668088130776
22114,"@Test public void moreSlop(){
  slop(3);
  phrase(0,1,2,4,5,2);
  inputs(0,1,2,2,2,4,4,4,4,5,1);
  result(2,2,2,1,1,2,1,1,1,2,1);
}","@Test public void moreSlop(){
  slop(3);
  phrase(0,1,2,4,5,2);
  inputs(0,1,2,2,2,4,4,5,1);
  result(2,2,2,1,1,2,1,2,1);
  slop(4);
  inputs(0,1,2,2,2,4,4,5,1);
  result(2,2,2,1,1,2,1,2,1);
  slop(2);
  inputs(0,1,2,2,2,4,4,5,1);
  result(1,1,1,1,1,1,1,1,1);
}",0.4744897959183674
22115,"public HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitEnumForSource();
  e=weigher.wrap(e);
  FieldOptions options=context.field.fieldOptions();
  if (!options.scoreOrdered()) {
    Boolean topScoring=(Boolean)executionContext.getOption(""String_Node_Str"");
    if (topScoring == null || !topScoring) {
      e=new WeightFilteredHitEnumWrapper(e,0f);
      return e;
    }
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> boostBefore=(Map<String,Object>)executionContext.getOption(""String_Node_Str"");
  if (boostBefore != null) {
    TreeMap<Integer,Float> ordered=new TreeMap<Integer,Float>();
    for (    Map.Entry<String,Object> entry : boostBefore.entrySet()) {
      if (!(entry.getValue() instanceof Number)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ordered.put(Integer.valueOf(entry.getKey()),((Number)entry.getValue()).floatValue());
    }
    PositionBoostingHitEnumWrapper boosting=new PositionBoostingHitEnumWrapper(e);
    e=boosting;
    for (    Map.Entry<Integer,Float> entry : ordered.entrySet()) {
      boosting.add(entry.getKey(),entry.getValue());
    }
  }
  e=new WeightFilteredHitEnumWrapper(e,0f);
  return e;
}","public HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitEnumForSource();
  e=weigher.wrap(context.fieldName,e);
  FieldOptions options=context.field.fieldOptions();
  if (!options.scoreOrdered()) {
    Boolean topScoring=(Boolean)executionContext.getOption(""String_Node_Str"");
    if (topScoring == null || !topScoring) {
      e=new WeightFilteredHitEnumWrapper(e,0f);
      return e;
    }
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> boostBefore=(Map<String,Object>)executionContext.getOption(""String_Node_Str"");
  if (boostBefore != null) {
    TreeMap<Integer,Float> ordered=new TreeMap<Integer,Float>();
    for (    Map.Entry<String,Object> entry : boostBefore.entrySet()) {
      if (!(entry.getValue() instanceof Number)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ordered.put(Integer.valueOf(entry.getKey()),((Number)entry.getValue()).floatValue());
    }
    PositionBoostingHitEnumWrapper boosting=new PositionBoostingHitEnumWrapper(e);
    e=boosting;
    for (    Map.Entry<Integer,Float> entry : ordered.entrySet()) {
      boosting.add(entry.getKey(),entry.getValue());
    }
  }
  e=new WeightFilteredHitEnumWrapper(e,0f);
  return e;
}",0.9925742574257426
22116,"protected void flattenQuery(MultiPhrasePrefixQuery query,float pathBoost,Object sourceOverride,IndexReader reader,Callback callback){
  List<Term[]> termArrays=query.getTermArrays();
  float boost=pathBoost * query.getBoost();
  if (termArrays.isEmpty()) {
    return;
  }
  int sizeMinus1=termArrays.size() - 1;
  if (phraseAsTerms()) {
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),boost,sourceOverride);
      }
    }
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),boost,sourceOverride,callback);
    }
  }
 else {
    callback.startPhrase(termArrays.size());
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      callback.startPhrasePosition(termArray.length);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),0,sourceOverride);
      }
      callback.endPhrasePosition();
    }
    callback.startPhrasePosition(termArrays.get(sizeMinus1).length);
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),0,sourceOverride,callback);
    }
    callback.endPhrasePosition();
    callback.endPhrase(query.getSlop(),boost);
  }
}","protected void flattenQuery(MultiPhrasePrefixQuery query,float pathBoost,Object sourceOverride,IndexReader reader,Callback callback){
  List<Term[]> termArrays=query.getTermArrays();
  float boost=pathBoost * query.getBoost();
  if (termArrays.isEmpty()) {
    return;
  }
  int sizeMinus1=termArrays.size() - 1;
  if (phraseAsTerms()) {
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),boost,sourceOverride);
      }
    }
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),boost,sourceOverride,callback);
    }
  }
 else {
    callback.startPhrase(termArrays.size());
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      callback.startPhrasePosition(termArray.length);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),0,sourceOverride);
      }
      callback.endPhrasePosition();
    }
    callback.startPhrasePosition(termArrays.get(sizeMinus1).length);
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),0,sourceOverride,callback);
    }
    callback.endPhrasePosition();
    callback.endPhrase(query.getField(),query.getSlop(),boost);
  }
}",0.993640104751216
22117,"private void phrasePrefixQueryTestCase(boolean phraseAsTerms){
  MultiPhrasePrefixQuery query=new MultiPhrasePrefixQuery();
  Term foo=new Term(""String_Node_Str"",""String_Node_Str"");
  Term qux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term quux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term bar=new Term(""String_Node_Str"",""String_Node_Str"");
  Term anoth=new Term(""String_Node_Str"",""String_Node_Str"");
  query.add(foo);
  query.add(new Term[]{qux,quux});
  query.add(new Term[]{bar,anoth});
  Callback callback=mock(Callback.class);
  new ElasticsearchQueryFlattener(1,phraseAsTerms).flatten(query,null,callback);
  verify(callback).flattened(foo.bytes(),phraseAsTerms ? 1f : 0,null);
  verify(callback,never()).flattened(eq(bar.bytes()),anyFloat(),isNull(Query.class));
  ArgumentCaptor<Automaton> a=ArgumentCaptor.forClass(Automaton.class);
  verify(callback,times(2)).flattened(a.capture(),phraseAsTerms ? eq(1f) : eq(0f),anyInt());
  assertThat(a.getAllValues().get(0),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  assertThat(a.getAllValues().get(1),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  if (phraseAsTerms) {
    verify(callback,never()).startPhrase(anyInt());
    verify(callback,never()).startPhrasePosition(anyInt());
    verify(callback,never()).endPhrasePosition();
    verify(callback,never()).endPhrase(anyInt(),anyFloat());
  }
 else {
    verify(callback).startPhrase(3);
    verify(callback).startPhrasePosition(1);
    verify(callback,times(2)).startPhrasePosition(2);
    verify(callback,times(3)).endPhrasePosition();
    verify(callback).endPhrase(0,1);
  }
}","private void phrasePrefixQueryTestCase(boolean phraseAsTerms){
  MultiPhrasePrefixQuery query=new MultiPhrasePrefixQuery();
  Term foo=new Term(""String_Node_Str"",""String_Node_Str"");
  Term qux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term quux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term bar=new Term(""String_Node_Str"",""String_Node_Str"");
  Term anoth=new Term(""String_Node_Str"",""String_Node_Str"");
  query.add(foo);
  query.add(new Term[]{qux,quux});
  query.add(new Term[]{bar,anoth});
  Callback callback=mock(Callback.class);
  new ElasticsearchQueryFlattener(1,phraseAsTerms).flatten(query,null,callback);
  verify(callback).flattened(foo.bytes(),phraseAsTerms ? 1f : 0,null);
  verify(callback,never()).flattened(eq(bar.bytes()),anyFloat(),isNull(Query.class));
  ArgumentCaptor<Automaton> a=ArgumentCaptor.forClass(Automaton.class);
  verify(callback,times(2)).flattened(a.capture(),phraseAsTerms ? eq(1f) : eq(0f),anyInt());
  assertThat(a.getAllValues().get(0),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  assertThat(a.getAllValues().get(1),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  if (phraseAsTerms) {
    verify(callback,never()).startPhrase(anyInt());
    verify(callback,never()).startPhrasePosition(anyInt());
    verify(callback,never()).endPhrasePosition();
    verify(callback,never()).endPhrase(anyString(),anyInt(),anyFloat());
  }
 else {
    verify(callback).startPhrase(3);
    verify(callback).startPhrasePosition(1);
    verify(callback,times(2)).startPhrasePosition(2);
    verify(callback,times(3)).endPhrasePosition();
    verify(callback).endPhrase(""String_Node_Str"",0,1);
  }
}",0.9919571045576407
22118,"/** 
 * Called to mark the end of a phrase.
 */
void endPhrase(int slop,float weight);","/** 
 * Called to mark the end of a phrase.
 */
void endPhrase(String field,int slop,float weight);",0.9297297297297298
22119,"private PhraseCandidate(){
  matchedPositions=new int[phrase.length];
  matchedPositions[0]=wrapped.position();
  matchedSources=new int[phrase.length];
  matchedSources[0]=wrapped.source();
  phrasePosition=1;
}","private PhraseCandidate(){
  matchedPositions=new int[phrase.length];
  matchedPositions[0]=wrapped.position();
  matchedSources=new int[phrase.length];
  matchedSources[0]=wrapped.source();
  horizon=matchedPositions[0] + phrase.length + phraseSlop - 1;
  phrasePosition=1;
}",0.8073770491803278
22120,"private boolean acceptsCurrent(){
  int index=Arrays.binarySearch(phrase[phrasePosition],wrapped.source());
  if (index >= 0) {
    lastIndex++;
    matchedPositions[lastIndex]=wrapped.position();
    matchedSources[lastIndex]=wrapped.source();
    phrasePosition++;
    return true;
  }
  return wrapped.position() <= matchedPositions[lastIndex] + phraseSlop;
}","private boolean acceptsCurrent(){
  int distanceLeft=horizon - wrapped.position();
  if (distanceLeft < 0) {
    return false;
  }
  int index=Arrays.binarySearch(phrase[phrasePosition],wrapped.source());
  if (index >= 0) {
    lastIndex++;
    matchedPositions[lastIndex]=wrapped.position();
    matchedSources[lastIndex]=wrapped.source();
    phrasePosition++;
    return true;
  }
  return distanceLeft >= 1;
}",0.7731958762886598
22121,"/** 
 * Copies the contents of the queue in heap order. If you need them in any particular order, you should sort them.
 */
public List<ProtoSnippet> contents(){
  List<ProtoSnippet> snippets=new ArrayList<ProtoSnippet>(size());
  Object[] heapArray=getHeapArray();
  for (int i=0; i < heapArray.length; i++) {
    Object o=heapArray[i];
    if (o == null) {
      continue;
    }
    snippets.add((ProtoSnippet)o);
  }
  return snippets;
}","/** 
 * Copies the contents of the queue in heap order. If you need them in any particular order, you should sort them.
 */
public ProtoSnippet[] contents(){
  ProtoSnippet[] snippets=new ProtoSnippet[size()];
  Object[] heapArray=getHeapArray();
  int s=0;
  for (int i=0; i < heapArray.length; i++) {
    Object o=heapArray[i];
    if (o == null) {
      continue;
    }
    snippets[s++]=(ProtoSnippet)o;
  }
  return snippets;
}",0.9380733944954128
22122,"@Override protected List<Snippet> results(State state){
  ProtoSnippet[] protos=state.results.contents().toArray(new ProtoSnippet[state.results.contents().size()]);
  Arrays.sort(protos,ProtoSnippetComparators.OFFSETS);
  int lastSnippetEnd=0;
  for (  ProtoSnippet proto : protos) {
    proto.pickedBounds=proto.memo.pickBounds(lastSnippetEnd,Integer.MAX_VALUE);
    lastSnippetEnd=proto.pickedBounds.endOffset();
  }
  if (scoreOrdered) {
    Arrays.sort(protos,ProtoSnippetComparators.WEIGHT);
  }
  List<Snippet> results=new ArrayList<Snippet>(protos.length);
  for (  ProtoSnippet proto : protos) {
    results.add(new Snippet(proto.pickedBounds.startOffset(),proto.pickedBounds.endOffset(),proto.hits));
  }
  return results;
}","@Override protected List<Snippet> results(State state){
  ProtoSnippet[] protos=state.results.contents();
  Arrays.sort(protos,ProtoSnippetComparators.OFFSETS);
  int lastSnippetEnd=0;
  for (  ProtoSnippet proto : protos) {
    proto.pickedBounds=proto.memo.pickBounds(lastSnippetEnd,Integer.MAX_VALUE);
    lastSnippetEnd=proto.pickedBounds.endOffset();
  }
  if (scoreOrdered) {
    Arrays.sort(protos,ProtoSnippetComparators.WEIGHT);
  }
  List<Snippet> results=new ArrayList<Snippet>(protos.length);
  for (  ProtoSnippet proto : protos) {
    results.add(new Snippet(proto.pickedBounds.startOffset(),proto.pickedBounds.endOffset(),proto.hits));
  }
  return results;
}",0.9580668088130776
22123,"@Test public void moreSlop(){
  slop(3);
  phrase(0,1,2,4,5,2);
  inputs(0,1,2,2,2,4,4,4,4,5,1);
  result(2,2,2,1,1,2,1,1,1,2,1);
}","@Test public void moreSlop(){
  slop(3);
  phrase(0,1,2,4,5,2);
  inputs(0,1,2,2,2,4,4,5,1);
  result(2,2,2,1,1,2,1,2,1);
  slop(4);
  inputs(0,1,2,2,2,4,4,5,1);
  result(2,2,2,1,1,2,1,2,1);
  slop(2);
  inputs(0,1,2,2,2,4,4,5,1);
  result(1,1,1,1,1,1,1,1,1);
}",0.4744897959183674
22124,"public HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitEnumForSource();
  e=weigher.wrap(e);
  FieldOptions options=context.field.fieldOptions();
  if (!options.scoreOrdered()) {
    Boolean topScoring=(Boolean)executionContext.getOption(""String_Node_Str"");
    if (topScoring == null || !topScoring) {
      e=new WeightFilteredHitEnumWrapper(e,0f);
      return e;
    }
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> boostBefore=(Map<String,Object>)executionContext.getOption(""String_Node_Str"");
  if (boostBefore != null) {
    TreeMap<Integer,Float> ordered=new TreeMap<Integer,Float>();
    for (    Map.Entry<String,Object> entry : boostBefore.entrySet()) {
      if (!(entry.getValue() instanceof Number)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ordered.put(Integer.valueOf(entry.getKey()),((Number)entry.getValue()).floatValue());
    }
    PositionBoostingHitEnumWrapper boosting=new PositionBoostingHitEnumWrapper(e);
    e=boosting;
    for (    Map.Entry<Integer,Float> entry : ordered.entrySet()) {
      boosting.add(entry.getKey(),entry.getValue());
    }
  }
  e=new WeightFilteredHitEnumWrapper(e,0f);
  return e;
}","public HitEnum buildHitEnum() throws IOException {
  HitEnum e=buildHitEnumForSource();
  e=weigher.wrap(context.fieldName,e);
  FieldOptions options=context.field.fieldOptions();
  if (!options.scoreOrdered()) {
    Boolean topScoring=(Boolean)executionContext.getOption(""String_Node_Str"");
    if (topScoring == null || !topScoring) {
      e=new WeightFilteredHitEnumWrapper(e,0f);
      return e;
    }
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> boostBefore=(Map<String,Object>)executionContext.getOption(""String_Node_Str"");
  if (boostBefore != null) {
    TreeMap<Integer,Float> ordered=new TreeMap<Integer,Float>();
    for (    Map.Entry<String,Object> entry : boostBefore.entrySet()) {
      if (!(entry.getValue() instanceof Number)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ordered.put(Integer.valueOf(entry.getKey()),((Number)entry.getValue()).floatValue());
    }
    PositionBoostingHitEnumWrapper boosting=new PositionBoostingHitEnumWrapper(e);
    e=boosting;
    for (    Map.Entry<Integer,Float> entry : ordered.entrySet()) {
      boosting.add(entry.getKey(),entry.getValue());
    }
  }
  e=new WeightFilteredHitEnumWrapper(e,0f);
  return e;
}",0.9925742574257426
22125,"protected void flattenQuery(MultiPhrasePrefixQuery query,float pathBoost,Object sourceOverride,IndexReader reader,Callback callback){
  List<Term[]> termArrays=query.getTermArrays();
  float boost=pathBoost * query.getBoost();
  if (termArrays.isEmpty()) {
    return;
  }
  int sizeMinus1=termArrays.size() - 1;
  if (phraseAsTerms()) {
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),boost,sourceOverride);
      }
    }
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),boost,sourceOverride,callback);
    }
  }
 else {
    callback.startPhrase(termArrays.size());
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      callback.startPhrasePosition(termArray.length);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),0,sourceOverride);
      }
      callback.endPhrasePosition();
    }
    callback.startPhrasePosition(termArrays.get(sizeMinus1).length);
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),0,sourceOverride,callback);
    }
    callback.endPhrasePosition();
    callback.endPhrase(query.getSlop(),boost);
  }
}","protected void flattenQuery(MultiPhrasePrefixQuery query,float pathBoost,Object sourceOverride,IndexReader reader,Callback callback){
  List<Term[]> termArrays=query.getTermArrays();
  float boost=pathBoost * query.getBoost();
  if (termArrays.isEmpty()) {
    return;
  }
  int sizeMinus1=termArrays.size() - 1;
  if (phraseAsTerms()) {
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),boost,sourceOverride);
      }
    }
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),boost,sourceOverride,callback);
    }
  }
 else {
    callback.startPhrase(termArrays.size());
    for (int i=0; i < sizeMinus1; i++) {
      Term[] termArray=termArrays.get(i);
      callback.startPhrasePosition(termArray.length);
      for (int t=0; t < termArray.length; t++) {
        callback.flattened(termArray[t].bytes(),0,sourceOverride);
      }
      callback.endPhrasePosition();
    }
    callback.startPhrasePosition(termArrays.get(sizeMinus1).length);
    for (    Term term : termArrays.get(sizeMinus1)) {
      flattenPrefixQuery(term.bytes(),0,sourceOverride,callback);
    }
    callback.endPhrasePosition();
    callback.endPhrase(query.getField(),query.getSlop(),boost);
  }
}",0.993640104751216
22126,"private void phrasePrefixQueryTestCase(boolean phraseAsTerms){
  MultiPhrasePrefixQuery query=new MultiPhrasePrefixQuery();
  Term foo=new Term(""String_Node_Str"",""String_Node_Str"");
  Term qux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term quux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term bar=new Term(""String_Node_Str"",""String_Node_Str"");
  Term anoth=new Term(""String_Node_Str"",""String_Node_Str"");
  query.add(foo);
  query.add(new Term[]{qux,quux});
  query.add(new Term[]{bar,anoth});
  Callback callback=mock(Callback.class);
  new ElasticsearchQueryFlattener(1,phraseAsTerms).flatten(query,null,callback);
  verify(callback).flattened(foo.bytes(),phraseAsTerms ? 1f : 0,null);
  verify(callback,never()).flattened(eq(bar.bytes()),anyFloat(),isNull(Query.class));
  ArgumentCaptor<Automaton> a=ArgumentCaptor.forClass(Automaton.class);
  verify(callback,times(2)).flattened(a.capture(),phraseAsTerms ? eq(1f) : eq(0f),anyInt());
  assertThat(a.getAllValues().get(0),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  assertThat(a.getAllValues().get(1),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  if (phraseAsTerms) {
    verify(callback,never()).startPhrase(anyInt());
    verify(callback,never()).startPhrasePosition(anyInt());
    verify(callback,never()).endPhrasePosition();
    verify(callback,never()).endPhrase(anyInt(),anyFloat());
  }
 else {
    verify(callback).startPhrase(3);
    verify(callback).startPhrasePosition(1);
    verify(callback,times(2)).startPhrasePosition(2);
    verify(callback,times(3)).endPhrasePosition();
    verify(callback).endPhrase(0,1);
  }
}","private void phrasePrefixQueryTestCase(boolean phraseAsTerms){
  MultiPhrasePrefixQuery query=new MultiPhrasePrefixQuery();
  Term foo=new Term(""String_Node_Str"",""String_Node_Str"");
  Term qux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term quux=new Term(""String_Node_Str"",""String_Node_Str"");
  Term bar=new Term(""String_Node_Str"",""String_Node_Str"");
  Term anoth=new Term(""String_Node_Str"",""String_Node_Str"");
  query.add(foo);
  query.add(new Term[]{qux,quux});
  query.add(new Term[]{bar,anoth});
  Callback callback=mock(Callback.class);
  new ElasticsearchQueryFlattener(1,phraseAsTerms).flatten(query,null,callback);
  verify(callback).flattened(foo.bytes(),phraseAsTerms ? 1f : 0,null);
  verify(callback,never()).flattened(eq(bar.bytes()),anyFloat(),isNull(Query.class));
  ArgumentCaptor<Automaton> a=ArgumentCaptor.forClass(Automaton.class);
  verify(callback,times(2)).flattened(a.capture(),phraseAsTerms ? eq(1f) : eq(0f),anyInt());
  assertThat(a.getAllValues().get(0),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  assertThat(a.getAllValues().get(1),allOf(recognises(""String_Node_Str""),recognises(""String_Node_Str""),recognises(""String_Node_Str""),not(recognises(""String_Node_Str"")),not(recognises(""String_Node_Str""))));
  if (phraseAsTerms) {
    verify(callback,never()).startPhrase(anyInt());
    verify(callback,never()).startPhrasePosition(anyInt());
    verify(callback,never()).endPhrasePosition();
    verify(callback,never()).endPhrase(anyString(),anyInt(),anyFloat());
  }
 else {
    verify(callback).startPhrase(3);
    verify(callback).startPhrasePosition(1);
    verify(callback,times(2)).startPhrasePosition(2);
    verify(callback,times(3)).endPhrasePosition();
    verify(callback).endPhrase(""String_Node_Str"",0,1);
  }
}",0.9919571045576407
22127,"/** 
 * Called to mark the end of a phrase.
 */
void endPhrase(int slop,float weight);","/** 
 * Called to mark the end of a phrase.
 */
void endPhrase(String field,int slop,float weight);",0.9297297297297298
22128,"@Override public boolean next(){
  if (position == -1) {
    endOffset=itr.next();
  }
 else {
    startOffset=endOffset;
    endOffset=itr.next();
  }
  position++;
  if (endOffset == BreakIterator.DONE) {
    return false;
  }
 else {
    weight=weigher.weight(position,startOffset,endOffset);
    return true;
  }
}","@Override public boolean next(){
  if (position == -1) {
    endOffset=itr.next();
  }
 else {
    startOffset=endOffset;
    endOffset=itr.next();
  }
  position++;
  if (endOffset == BreakIterator.DONE) {
    return false;
  }
 else {
    queryWeight=queryWeigher.weight(position,startOffset,endOffset);
    corpusWeight=corpusWeigher.weight(position,startOffset,endOffset);
    return true;
  }
}",0.8619246861924686
22129,"public BreakIteratorHitEnum(BreakIterator itr,HitWeigher weigher){
  this.itr=itr;
  this.weigher=weigher;
  startOffset=itr.first();
}","public BreakIteratorHitEnum(BreakIterator itr,HitWeigher queryWeigher,HitWeigher corpusWeigher){
  this.itr=itr;
  this.queryWeigher=queryWeigher;
  this.corpusWeigher=corpusWeigher;
  startOffset=itr.first();
}",0.7225433526011561
22130,"/** 
 * Record the current position of e.
 */
public void recordCurrent(HitEnum e){
  record(e.position(),e.startOffset(),e.endOffset(),e.weight(),e.source());
}","/** 
 * Record the current position of e.
 */
public void recordCurrent(HitEnum e){
  record(e.position(),e.startOffset(),e.endOffset(),e.queryWeight(),e.corpusWeight(),e.source());
}",0.9302325581395348
22131,"public Hit(int position,int startOffset,int endOffset,float weight,int source){
  this.position=position;
  this.startOffset=startOffset;
  this.endOffset=endOffset;
  this.weight=weight;
  this.source=source;
}","public Hit(int position,int startOffset,int endOffset,float queryWeight,float corpusWeight,int source){
  this.position=position;
  this.startOffset=startOffset;
  this.endOffset=endOffset;
  this.queryWeight=queryWeight;
  this.corpusWeight=corpusWeight;
  this.source=source;
}",0.8244897959183674
22132,"/** 
 * Record a list of enums.
 * @param positionGap positions between enums
 * @param offsetGap offsets between enums
 */
public void record(Iterator<HitEnumAndLength> enums,int positionGap,int offsetGap){
  int relativePosition=0;
  int relativeOffset=0;
  while (enums.hasNext()) {
    HitEnumAndLength e=enums.next();
    int position=0;
    int endOffset=0;
    while (e.delegate().next()) {
      position=e.delegate().position();
      endOffset=e.delegate().endOffset();
      record(position + relativePosition,e.delegate().startOffset() + relativeOffset,endOffset + relativeOffset,e.delegate().weight(),e.delegate().source());
    }
    relativePosition+=position + positionGap;
    relativeOffset+=e.length + offsetGap;
  }
}","/** 
 * Record a list of enums.
 * @param positionGap positions between enums
 * @param offsetGap offsets between enums
 */
public void record(Iterator<HitEnumAndLength> enums,int positionGap,int offsetGap){
  int relativePosition=0;
  int relativeOffset=0;
  while (enums.hasNext()) {
    HitEnumAndLength e=enums.next();
    int position=0;
    int endOffset=0;
    while (e.delegate().next()) {
      position=e.delegate().position();
      endOffset=e.delegate().endOffset();
      record(position + relativePosition,e.delegate().startOffset() + relativeOffset,endOffset + relativeOffset,e.delegate().queryWeight(),e.delegate().corpusWeight(),e.delegate().source());
    }
    relativePosition+=position + positionGap;
    relativeOffset+=e.length + offsetGap;
  }
}",0.9714664897146648
22133,"@Override public String toString(){
  return String.format(Locale.ENGLISH,""String_Node_Str"",weight,position);
}","@Override public String toString(){
  return String.format(Locale.ENGLISH,""String_Node_Str"",queryWeight * corpusWeight,position);
}",0.9090909090909092
22134,"@Override protected boolean keep(){
  return wrapped().weight() > cutoff;
}","@Override protected boolean keep(){
  return wrapped().queryWeight() * wrapped().corpusWeight() > cutoff;
}",0.8241758241758241
22135,"public Hit(int startOffset,int endOffset,float weight){
  this.startOffset=startOffset;
  this.endOffset=endOffset;
  this.weight=weight;
}","public Hit(int startOffset,int endOffset,float weight){
}",0.5816326530612245
22136,"@Override public boolean next(){
  if (delegate == null) {
    return false;
  }
  position=delegate.position();
  startOffset=delegate.startOffset();
  endOffset=delegate.endOffset();
  weight=delegate.weight();
  while (true) {
    if (!delegate.next()) {
      delegate=null;
      break;
    }
    if (delegate.startOffset() >= endOffset) {
      break;
    }
    endOffset=delegate.endOffset();
    weight=Math.max(weight,delegate.weight());
  }
  return true;
}","@Override public boolean next(){
}",0.1357285429141716
22137,"/** 
 * Updates all mutable member variables to point at the segmenter that can segment starting at startOffset.
 * @return did we find a segmenter?
 */
private boolean updateSegmenter(int startOffset){
  if (segmenterIndex == -1) {
    inSegmenterStartOffset=startOffset;
    lastStartOffset=0;
    return findSegmenterForwards();
  }
  inSegmenterStartOffset=startOffset - lastStartOffset;
  if (inSegmenterStartOffset < 0) {
    return findSegmenterBackwards();
  }
  if (inSegmenterStartOffset >= segmenter.length) {
    inSegmenterStartOffset-=segmenter.length + offsetGap;
    lastStartOffset+=segmenter.length + offsetGap;
    return findSegmenterForwards();
  }
  return true;
}","/** 
 * Updates all mutable member variables to point at the segmenter that can segment starting at startOffset.
 * @return did we find a segmenter?
 */
private boolean updateSegmenter(int startOffset){
}",0.4584269662921348
22138,"Text[] highlight() throws IOException {
  return formatSnippets(buildChooser().choose(defaultField.buildSegmenter(),buildHitEnum(),context.field.fieldOptions().numberOfFragments()));
}","HighlightField highlight() throws IOException {
  List<Snippet> snippets=buildChooser().choose(defaultField.buildSegmenter(),buildHitEnum(),context.field.fieldOptions().numberOfFragments());
  if (snippets.size() == 0) {
    return null;
  }
  return new HighlightField(context.fieldName,formatSnippets(snippets));
}",0.648
22139,"private static HitEnum fromTerms(Terms terms,CompiledAutomaton acceptable,IndexReader reader,int docId,TermWeigher<BytesRef> weigher) throws IOException {
  if (terms == null) {
    return EmptyHitEnum.INSTANCE;
  }
  TermsEnum termsEnum=acceptable.getTermsEnum(terms);
  BytesRef term;
  List<HitEnum> enums=new ArrayList<HitEnum>();
  while ((term=termsEnum.next()) != null) {
    DocsAndPositionsEnum dp=termsEnum.docsAndPositions(null,null);
    if (dp == null) {
      continue;
    }
    int advanceResult=docId >= 0 ? dp.advance(docId) : dp.nextDoc();
    if (advanceResult == DocIdSetIterator.NO_MORE_DOCS) {
      continue;
    }
    enums.add(new DocsAndPositionsHitEnum(dp,weigher.weigh(term)));
  }
  return new MergingHitEnum(enums,HitEnum.LessThans.POSITION);
}","private static HitEnum fromTerms(Terms terms,CompiledAutomaton acceptable,IndexReader reader,int docId,TermWeigher<BytesRef> weigher) throws IOException {
  if (terms == null) {
    return EmptyHitEnum.INSTANCE;
  }
  TermsEnum termsEnum=acceptable.getTermsEnum(terms);
  BytesRef term;
  List<HitEnum> enums=new ArrayList<HitEnum>();
  while ((term=termsEnum.next()) != null) {
    DocsAndPositionsEnum dp=termsEnum.docsAndPositions(null,null,DocsAndPositionsEnum.FLAG_OFFSETS);
    if (dp == null) {
      continue;
    }
    if (docId < 0) {
      if (dp.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {
        continue;
      }
    }
 else {
      if (dp.advance(docId) != docId) {
        continue;
      }
    }
    HitEnum e=new DocsAndPositionsHitEnum(dp,weigher.weigh(term));
    enums.add(e);
  }
  return new MergingHitEnum(enums,HitEnum.LessThans.POSITION);
}",0.8321167883211679
22140,"@Override public boolean next(){
  if (current >= freq) {
    return false;
  }
  current++;
  try {
    position=dp.nextPosition();
    return true;
  }
 catch (  IOException e) {
    throw new WrappedExceptionFromLucene(e);
  }
}","@Override public boolean next(){
}",0.2566037735849056
22141,"public static HitEnum fromPostings(IndexReader reader,int docId,String fieldName,CompiledAutomaton acceptable,TermWeigher<BytesRef> weigher) throws IOException {
  List<AtomicReaderContext> leaves=reader.getContext().leaves();
  int leaf=ReaderUtil.subIndex(docId,leaves);
  AtomicReader atomicReader=leaves.get(leaf).reader();
  return fromTerms(atomicReader.terms(fieldName),acceptable,reader,docId,weigher);
}","public static HitEnum fromPostings(IndexReader reader,int docId,String fieldName,CompiledAutomaton acceptable,TermWeigher<BytesRef> weigher) throws IOException {
  List<AtomicReaderContext> leaves=reader.getContext().leaves();
  int leaf=ReaderUtil.subIndex(docId,leaves);
  AtomicReaderContext subcontext=leaves.get(leaf);
  AtomicReader atomicReader=subcontext.reader();
  docId-=subcontext.docBase;
  return fromTerms(atomicReader.terms(fieldName),acceptable,reader,docId,weigher);
}",0.8685968819599109
22142,"@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  super.drawDefaultBackground();
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  int k=(width - xSize) / 2;
  int l=(height - ySize) / 2;
  GL11.glEnable(3042);
  drawTexturedModalRect(k,l,0,0,xSize,ySize);
  int i1;
  i1=tileEntity.getBurnTimeRemainingScaled(14);
  drawTexturedModalRect(k + 58,l + 15 + 14 - i1,176,14 - i1,14,i1);
  GL11.glDisable(3042);
  FluidTank tank=tileEntity.getTank();
  if (tank == null) {
    return;
  }
  FluidStack fluidStack=tank.getFluid();
  if (fluidStack == null) {
    return;
  }
  float fill=fluidStack.amount / (float)tank.getCapacity();
  drawFluid(new FluidStack(FluidHelper.getWaterFluid(),1),(int)(fill * 58.0F),k + 81,l + 14,16,58,false);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 80,l + 13,190,0,18,60);
  fill=Math.min(tileEntity.getPressure(),1F);
  FluidStack stack=new FluidStack(FluidHelper.getWaterFluid(),1);
  if (FluidRegistry.isFluidRegistered(""String_Node_Str"")) {
    stack=new FluidStack(FluidRegistry.getFluid(""String_Node_Str""),1);
  }
  drawFluid(stack,(int)(fill * 58.0F),k + 104,l + 14,16,58,true);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 103,l + 13,190,0,18,60);
  GL11.glDisable(3042);
}","@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  GlStateManager.color(1F,1F,1F,1F);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  int k=(width - xSize) / 2;
  int l=(height - ySize) / 2;
  GlStateManager.enableBlend();
  drawTexturedModalRect(k,l,0,0,xSize,ySize);
  int i1;
  i1=tileEntity.getBurnTimeRemainingScaled(14);
  drawTexturedModalRect(k + 58,l + 15 + 14 - i1,176,14 - i1,14,i1);
  GlStateManager.disableBlend();
  FluidTank tank=tileEntity.getTank();
  if (tank == null) {
    return;
  }
  FluidStack fluidStack=tank.getFluid();
  if (fluidStack == null) {
    return;
  }
  float fill=fluidStack.amount / (float)tank.getCapacity();
  drawFluid(new FluidStack(FluidHelper.getWaterFluid(),1),(int)(fill * 58.0F),k + 81,l + 14,16,58,false);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 80,l + 13,190,0,18,60);
  fill=Math.min(tileEntity.getPressure(),1F);
  FluidStack stack=new FluidStack(FluidHelper.getWaterFluid(),1);
  if (FluidRegistry.isFluidRegistered(""String_Node_Str"")) {
    stack=new FluidStack(FluidRegistry.getFluid(""String_Node_Str""),1);
  }
  drawFluid(stack,(int)(fill * 58.0F),k + 104,l + 14,16,58,true);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 103,l + 13,190,0,18,60);
  GlStateManager.disableBlend();
}",0.9298118668596236
22143,"public BookPageCrafting(String name,IRecipe... recipes){
  super(name);
  output=recipes[0].getRecipeOutput();
  for (  IRecipe recipe : recipes) {
    if (recipe instanceof ShapedOreRecipe) {
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapedOreRecipe)recipe).getInput().length > i && ((ShapedOreRecipe)recipe).getInput()[i] != null) {
          if (((ShapedOreRecipe)recipe).getInput()[i] instanceof Collection) {
            newList.addAll((Collection)((ShapedOreRecipe)recipe).getInput()[i]);
          }
 else {
            newList.add(((ShapedOreRecipe)recipe).getInput()[i]);
          }
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapedRecipes) {
      for (int i=0; i < 10; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapedRecipes)recipe).recipeItems.length > i && ((ShapedRecipes)recipe).recipeItems[i] != null) {
          newList.add(((ShapedRecipes)recipe).recipeItems[i]);
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapelessRecipes) {
      shapeless=true;
      inputs=ArrayUtils.addAll(inputs,((ShapelessRecipes)recipe).recipeItems.toArray(new Object[((ShapelessRecipes)recipe).recipeItems.size()]));
    }
 else     if (recipe instanceof ShapelessOreRecipe) {
      shapeless=true;
      ShapelessOreRecipe shapelessOreRecipe=(ShapelessOreRecipe)recipe;
      NonNullList<Object> recipeInputs=shapelessOreRecipe.getInput();
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (recipeInputs.size() > i) {
          Object inputAtIndex=recipeInputs.get(i);
          if (inputAtIndex instanceof Collection) {
            newList.addAll((Collection)inputAtIndex);
          }
 else {
            newList.add(inputAtIndex);
          }
        }
        inputs[i]=newList;
      }
    }
  }
  recipe=recipes;
}","public BookPageCrafting(String name,IRecipe... recipes){
  super(name);
  output=recipes[0].getRecipeOutput();
  for (  IRecipe recipe : recipes) {
    if (recipe instanceof ShapedRecipeFactory.ShapedRecipe) {
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (recipe.getIngredients().size() > i && recipe.getIngredients().get(i) != Ingredient.EMPTY) {
          newList.addAll(Arrays.asList(recipe.getIngredients().get(i).getMatchingStacks()));
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapelessRecipeFactory.ShapelessRecipe) {
      NonNullList<Ingredient> recipeInputs=recipe.getIngredients();
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (recipeInputs.size() > i) {
          newList.addAll(Arrays.asList(recipeInputs.get(i).getMatchingStacks()));
        }
        inputs[i]=newList;
      }
    }
  }
  recipe=recipes;
}",0.4547517015376859
22144,"@Override public void renderPage(int x,int y,FontRenderer fontRenderer,GuiJournal book,RenderItem renderer,boolean isFirstPage,int mx,int my){
  book.getMC().getTextureManager().bindTexture(craftSquareTexture);
  ((Gui)book).drawTexturedModalRect(x + 45,y + 55,0,0,97,59);
  if (shapeless) {
    ((Gui)book).drawTexturedModalRect(x + 120,y + 60,100,0,17,13);
  }
  int maxX=3;
  int maxY=3;
  if (recipe != null && recipe[0] != null && recipe[0] instanceof ShapedOreRecipe) {
    maxX=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],4);
    maxY=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],5);
  }
  for (int i=0; i < maxY; i++) {
    for (int j=0; j < maxX; j++) {
      int index=(maxX * i) + j;
      if (inputs.length > index) {
        Object val=inputs[index];
        if (val != null) {
          if (val instanceof Item) {
            ItemStack item=new ItemStack((Item)val);
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack) {
            ItemStack item=(ItemStack)val;
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack[]) {
            ItemStack[] item=(ItemStack[])val;
            drawItemStackInPage(getStackFromTicks(item),fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof Collection && !((Collection)val).isEmpty()) {
            ArrayList<ItemStack> list2=new ArrayList<>();
            for (            Object obj : (Iterable)val) {
              if (obj instanceof ItemStack) {
                ItemStack item=(ItemStack)obj;
                if (item.getItemDamage() == OreDictionary.WILDCARD_VALUE) {
                  NonNullList<ItemStack> list=NonNullList.create();
                  item.getItem().getSubItems(item.getItem(),CreativeTabs.SEARCH,list);
                  list2.addAll(list);
                }
 else {
                  list2.add(item);
                }
              }
            }
            ItemStack item=getStackFromTicks(list2.toArray(new ItemStack[list2.size()]));
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
        }
      }
    }
  }
  fontRenderer.setUnicodeFlag(false);
  drawItemStack(output,x + 45 + 76,y + 55 + 23,output.getCount() > 1 ? Integer.toString(output.getCount()) : ""String_Node_Str"",renderer,fontRenderer,false);
  fontRenderer.setUnicodeFlag(true);
  if (shapeless) {
    int ix=x + 120;
    int iy=y + 60;
    if (mx >= ix && mx <= ix + 17 && my >= iy && my <= iy + 13) {
      fontRenderer.setUnicodeFlag(false);
      book.renderText(""String_Node_Str"",mx,my);
      fontRenderer.setUnicodeFlag(true);
    }
  }
}","@Override public void renderPage(int x,int y,FontRenderer fontRenderer,GuiJournal book,RenderItem renderer,boolean isFirstPage,int mx,int my){
  book.getMC().getTextureManager().bindTexture(craftSquareTexture);
  ((Gui)book).drawTexturedModalRect(x + 45,y + 55,0,0,97,59);
  if (shapeless) {
    ((Gui)book).drawTexturedModalRect(x + 120,y + 60,100,0,17,13);
  }
  int maxX=3;
  int maxY=3;
  if (recipe != null && recipe[0] != null && recipe[0] instanceof ShapedOreRecipe) {
    maxX=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],4);
    maxY=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],5);
  }
  for (int i=0; i < maxY; i++) {
    for (int j=0; j < maxX; j++) {
      int index=(maxX * i) + j;
      if (inputs.length > index) {
        Object val=inputs[index];
        if (val != null) {
          if (val instanceof Item) {
            ItemStack item=new ItemStack((Item)val);
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack) {
            ItemStack item=(ItemStack)val;
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack[]) {
            ItemStack[] item=(ItemStack[])val;
            drawItemStackInPage(getStackFromTicks(item),fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof Collection && !((Collection)val).isEmpty()) {
            ArrayList<ItemStack> list2=new ArrayList<>();
            for (            Object obj : (Iterable)val) {
              if (obj instanceof ItemStack) {
                ItemStack item=(ItemStack)obj;
                if (item.getItemDamage() == OreDictionary.WILDCARD_VALUE) {
                  NonNullList<ItemStack> list=NonNullList.create();
                  item.getItem().getSubItems(CreativeTabs.SEARCH,list);
                  list2.addAll(list);
                }
 else {
                  list2.add(item);
                }
              }
            }
            ItemStack item=getStackFromTicks(list2.toArray(new ItemStack[list2.size()]));
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
        }
      }
    }
  }
  fontRenderer.setUnicodeFlag(false);
  drawItemStack(output,x + 45 + 76,y + 55 + 23,output.getCount() > 1 ? Integer.toString(output.getCount()) : ""String_Node_Str"",renderer,fontRenderer,false);
  fontRenderer.setUnicodeFlag(true);
  if (shapeless) {
    int ix=x + 120;
    int iy=y + 60;
    if (mx >= ix && mx <= ix + 17 && my >= iy && my <= iy + 13) {
      fontRenderer.setUnicodeFlag(false);
      book.renderText(""String_Node_Str"",mx,my);
      fontRenderer.setUnicodeFlag(true);
    }
  }
}",0.9972692517749864
22145,"public static void addRecipe(String key,ItemStack output,Object... params){
  ShapedOreRecipe recipe=new ShapedOreRecipe(output,params);
  addRecipe(key,recipe);
}","public static void addRecipe(String key,ItemStack output,Object... params){
  ShapedOreRecipe recipe=new ShapedOreRecipe(null,output,params);
  addRecipe(key,recipe);
}",0.9848942598187312
22146,"@Override public TileEntity createTileEntity(World world,IBlockState state){
  return new TileEntityEngineeringTable();
}","@Override public TileEntity createTileEntity(@Nonnull World world,@Nonnull IBlockState state){
  return new TileEntityEngineeringTable();
}",0.9307692307692308
22147,"@Override public boolean onBlockActivated(World world,BlockPos pos,IBlockState state,EntityPlayer player,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (world.isRemote) {
    return true;
  }
 else {
    TileEntity tileentity=world.getTileEntity(pos);
    if (tileentity instanceof TileEntityEngineeringTable) {
      player.openGui(EsteemedInnovation.instance,2,world,pos.getX(),pos.getY(),pos.getZ());
    }
    return true;
  }
}","@Override public boolean onBlockActivated(World world,BlockPos pos,IBlockState state,EntityPlayer player,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  TileEntity tileentity=world.getTileEntity(pos);
  if (tileentity instanceof TileEntityEngineeringTable) {
    player.openGui(EsteemedInnovation.instance,2,world,pos.getX(),pos.getY(),pos.getZ());
  }
  return true;
}",0.9205219454329776
22148,"public BlockEngineeringTable(){
  super(Material.ROCK);
  setHardness(3.5F);
  setCreativeTab(EsteemedInnovation.tab);
}","BlockEngineeringTable(){
  super(Material.ROCK);
  setHardness(3.5F);
  setCreativeTab(EsteemedInnovation.tab);
}",0.9699570815450644
22149,"@Override public ItemStack transferStackInSlot(EntityPlayer player,int index){
  return null;
}","@Nonnull @Override public ItemStack transferStackInSlot(EntityPlayer player,int index){
  return ItemStack.EMPTY;
}",0.8666666666666667
22150,"private void updateSlots(){
  boolean hasEngineer=false;
  ItemStack stackInSlotZero=tileEntity.getStackInSlot(0);
  if (stackInSlotZero != null) {
    if (stackInSlotZero.getItem() instanceof Engineerable) {
      Engineerable item=(Engineerable)stackInSlotZero.getItem();
      hasEngineer=true;
      int i=1;
      for (      Pair<Integer,Integer> pair : item.engineerCoordinates()) {
        int x=pair.getLeft();
        int y=pair.getRight();
        ((SlotLimitedStackSize)getSlot(i)).setSlotStackLimit(1);
        getSlot(i).xPos=x + 53;
        getSlot(i).yPos=y + 9;
        i++;
      }
    }
  }
  if (!hasEngineer) {
    for (int i=1; i < 10; i++) {
      getSlot(i).xPos=-1000;
      getSlot(i).yPos=-1000;
    }
  }
}","private void updateSlots(){
  ItemStack stackInSlotZero=tileEntity.getStackInSlot(0);
  Item itemInSlotZero=stackInSlotZero.getItem();
  if (itemInSlotZero instanceof Engineerable) {
    Engineerable item=(Engineerable)itemInSlotZero;
    int i=1;
    for (    Pair<Integer,Integer> pair : item.engineerCoordinates()) {
      int x=pair.getLeft();
      int y=pair.getRight();
      ((SlotLimitedStackSize)getSlot(i)).setSlotStackLimit(1);
      getSlot(i).xPos=x + 53;
      getSlot(i).yPos=y + 9;
      i++;
    }
  }
 else {
    for (int i=1; i < 10; i++) {
      getSlot(i).xPos=-1000;
      getSlot(i).yPos=-1000;
    }
  }
}",0.532648569332355
22151,"public ContainerEngineeringTable(InventoryPlayer inventoryPlayer,TileEntityEngineeringTable tileEntityEngineeringTable){
  tileEntity=tileEntityEngineeringTable;
  final InventoryPlayer inv=inventoryPlayer;
  addSlotToContainer(new Slot(tileEntityEngineeringTable,0,30,35));
  for (int i=1; i < 10; i++) {
    addSlotToContainer(new SlotLimitedStackSize(tileEntityEngineeringTable,i,-1000,-1000));
  }
  updateSlots();
  int i;
  for (i=0; i < 3; ++i) {
    for (int j=0; j < 9; ++j) {
      addSlotToContainer(new Slot(inventoryPlayer,j + i * 9 + 9,8 + j * 18,84 + i * 18));
    }
  }
  for (i=0; i < 4; ++i) {
    final EntityEquipmentSlot equipmentSlot=ARMOR_SLOTS[i];
    addSlotToContainer(new Slot(inventoryPlayer,inventoryPlayer.getSizeInventory() - 2 - i,8,8 + i * 18){
      private EntityPlayer player=inv.player;
      @Override public int getSlotStackLimit(){
        return 1;
      }
      @Override public boolean isItemValid(      ItemStack stack){
        return stack != null && stack.getItem().isValidArmor(stack,equipmentSlot,player);
      }
      @SideOnly(Side.CLIENT) public String getSlotTexture(){
        return ItemArmor.EMPTY_SLOT_NAMES[equipmentSlot.getIndex()];
      }
    }
);
  }
  addSlotToContainer(new Slot(inventoryPlayer,40,30,62){
    @SideOnly(Side.CLIENT) public String getSlotTexture(){
      return ""String_Node_Str"";
    }
  }
);
  for (i=0; i < 9; ++i) {
    addSlotToContainer(new Slot(inventoryPlayer,i,8 + i * 18,142));
  }
}","public ContainerEngineeringTable(InventoryPlayer inventoryPlayer,TileEntityEngineeringTable tileEntityEngineeringTable){
  tileEntity=tileEntityEngineeringTable;
  addSlotToContainer(new Slot(tileEntityEngineeringTable,0,30,35));
  for (int i=1; i < 10; i++) {
    addSlotToContainer(new SlotLimitedStackSize(tileEntityEngineeringTable,i,-1000,-1000));
  }
  updateSlots();
  int i;
  for (i=0; i < 3; ++i) {
    for (int j=0; j < 9; ++j) {
      addSlotToContainer(new Slot(inventoryPlayer,j + i * 9 + 9,8 + j * 18,84 + i * 18));
    }
  }
  for (i=0; i < 4; ++i) {
    EntityEquipmentSlot equipmentSlot=ARMOR_SLOTS[i];
    addSlotToContainer(new Slot(inventoryPlayer,inventoryPlayer.getSizeInventory() - 2 - i,8,8 + i * 18){
      private EntityPlayer player=inventoryPlayer.player;
      @Override public int getSlotStackLimit(){
        return 1;
      }
      @Override public boolean isItemValid(      ItemStack stack){
        return stack != null && stack.getItem().isValidArmor(stack,equipmentSlot,player);
      }
      @Override @SideOnly(Side.CLIENT) public String getSlotTexture(){
        return ItemArmor.EMPTY_SLOT_NAMES[equipmentSlot.getIndex()];
      }
    }
);
  }
  addSlotToContainer(new Slot(inventoryPlayer,40,30,62){
    @Override @SideOnly(Side.CLIENT) public String getSlotTexture(){
      return ""String_Node_Str"";
    }
  }
);
  for (i=0; i < 9; ++i) {
    addSlotToContainer(new Slot(inventoryPlayer,i,8 + i * 18,142));
  }
}",0.9716626835097304
22152,"@SideOnly(Side.CLIENT) public String getSlotTexture(){
  return ""String_Node_Str"";
}","@Override @SideOnly(Side.CLIENT) public String getSlotTexture(){
  return ""String_Node_Str"";
}",0.9438202247191012
22153,"@Override public boolean canInteractWith(EntityPlayer par1EntityPlayer){
  return true;
}","@Override public boolean canInteractWith(@Nonnull EntityPlayer player){
  return true;
}",0.8926553672316384
22154,"@Override public ItemStack slotClick(int slotID,int dragType,ClickType clickType,EntityPlayer player){
  ItemStack toReturn=super.slotClick(slotID,dragType,clickType,player);
  updateSlots();
  detectAndSendChanges();
  tileEntity.markForResync();
  return toReturn;
}","@Nonnull @Override public ItemStack slotClick(int slotID,int dragType,ClickType clickType,EntityPlayer player){
  ItemStack toReturn=super.slotClick(slotID,dragType,clickType,player);
  updateSlots();
  detectAndSendChanges();
  tileEntity.markForResync();
  return toReturn;
}",0.98348623853211
22155,"@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  mc.getTextureManager().bindTexture(Constants.ENG_GUI_TEXTURES);
  int k=(width - xSize) / 2;
  int l=(height - ySize) / 2;
  GL11.glEnable(3042);
  drawTexturedModalRect(k,l,0,0,xSize,ySize);
  if (tileEntity.getStackInSlot(0) != null) {
    if (tileEntity.getStackInSlot(0).getItem() instanceof Engineerable) {
      Engineerable item=(Engineerable)tileEntity.getStackInSlot(0).getItem();
      item.drawBackground(this,0,k + 52,l + 8);
      int i=0;
      for (      Pair<Integer,Integer> pair : item.engineerCoordinates()) {
        int x=pair.getLeft();
        int y=pair.getRight();
        item.drawSlot(this,i,k + x + 52,l + y + 8);
        i++;
      }
    }
  }
}","@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  mc.getTextureManager().bindTexture(Constants.ENG_GUI_TEXTURES);
  int k=(width - xSize) / 2;
  int l=(height - ySize) / 2;
  GL11.glEnable(3042);
  drawTexturedModalRect(k,l,0,0,xSize,ySize);
  Item engineeringItem=tileEntity.getStackInSlot(0).getItem();
  if (engineeringItem instanceof Engineerable) {
    Engineerable item=(Engineerable)engineeringItem;
    item.drawBackground(this,0,k + 52,l + 8);
    int i=0;
    for (    Pair<Integer,Integer> pair : item.engineerCoordinates()) {
      int x=pair.getLeft();
      int y=pair.getRight();
      item.drawSlot(this,i,k + x + 52,l + y + 8);
      i++;
    }
  }
}",0.7781309599491417
22156,"public BlockSteamHeater(){
  super();
  setHardness(3.625F);
  setResistance(7.5F);
}","public BlockSteamHeater(){
  setHardness(3.625F);
  setResistance(7.5F);
}",0.9308176100628932
22157,"@Override public IBlockState withMirror(IBlockState state,Mirror mirrorIn){
  return state.withRotation(mirrorIn.toRotation(state.getValue(FACING)));
}","@Nonnull @Override public IBlockState withMirror(@Nonnull IBlockState state,Mirror mirrorIn){
  return state.withRotation(mirrorIn.toRotation(state.getValue(FACING)));
}",0.94375
22158,"@Override public boolean onWrench(ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing facing,IBlockState state,float hitX,float hitY,float hitZ){
  WorldHelper.rotateProperly(FACING,world,state,pos,facing);
  return true;
}","@Override public boolean onWrench(@Nonnull ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing facing,IBlockState state,float hitX,float hitY,float hitZ){
  WorldHelper.rotateProperly(FACING,world,state,pos,facing);
  return true;
}",0.982791586998088
22159,"@Override public IBlockState getStateFromMeta(int meta){
  return getDefaultState().withProperty(FACING,EnumFacing.getFront(meta));
}","@Nonnull @Override public IBlockState getStateFromMeta(int meta){
  return getDefaultState().withProperty(FACING,EnumFacing.getFront(meta));
}",0.9672727272727272
22160,"@Override public IBlockState withRotation(IBlockState state,Rotation rot){
  return state.withProperty(FACING,rot.rotate(state.getValue(FACING)));
}","@Nonnull @Override public IBlockState withRotation(@Nonnull IBlockState state,Rotation rot){
  return state.withProperty(FACING,rot.rotate(state.getValue(FACING)));
}",0.9426751592356688
22161,"@Override public void update(){
  int numHeaters=0;
  for (  EnumFacing dir2 : EnumFacing.VALUES) {
    BlockPos offsetPos=pos.offset(dir2);
    TileEntity tile=world.getTileEntity(offsetPos);
    if (tile != null && tile instanceof TileEntitySteamHeater && ((TileEntitySteamHeater)tile).getSteamShare() > 2 && world.getBlockState(offsetPos).getValue(BlockSteamHeater.FACING) == dir2.getOpposite()) {
      numHeaters++;
    }
  }
  numHeaters=Math.min(4,numHeaters);
  if (numHeaters == 0) {
    TileEntitySteamHeater.replaceWith(this,new TileEntityFurnace());
  }
  int furnaceBurnTime=super.getField(FURNACE_BURN_TIME_ID);
  boolean flag=furnaceBurnTime > 0;
  boolean flag1=false;
  if (furnaceBurnTime > 0) {
    super.setField(FURNACE_BURN_TIME_ID,furnaceBurnTime - 1);
    furnaceBurnTime--;
  }
  if (!world.isRemote) {
    if (furnaceBurnTime == 0 && canSmelt()) {
      ItemStack inSlot1=getStackInSlot(1);
      int currentItemBurnTime=furnaceBurnTime=getItemBurnTime(inSlot1);
      super.setField(CURRENT_ITEM_BURN_TIME_ID,currentItemBurnTime);
      super.setField(FURNACE_BURN_TIME_ID,furnaceBurnTime);
      if (furnaceBurnTime > 0) {
        flag1=true;
        if (inSlot1 != null) {
          ItemStack copy=inSlot1.copy();
          copy.shrink(1);
          setInventorySlotContents(1,copy);
          if (inSlot1.isEmpty()) {
            setInventorySlotContents(1,inSlot1.getItem().getContainerItem(inSlot1));
          }
        }
      }
    }
    int furnaceCookTime;
    if (isBurning() && canSmelt()) {
      furnaceCookTime=super.getField(COOK_TIME_ID);
      ++furnaceCookTime;
      super.setField(COOK_TIME_ID,furnaceCookTime);
      if (furnaceCookTime == 200) {
        furnaceCookTime=0;
        smeltItem();
        super.setField(COOK_TIME_ID,furnaceCookTime);
        flag1=true;
      }
    }
 else {
      furnaceCookTime=0;
      super.setField(COOK_TIME_ID,furnaceCookTime);
    }
    if (flag != furnaceBurnTime > 0) {
      flag1=true;
      BlockFurnace.setState(furnaceBurnTime > 0,world,pos);
    }
  }
  if (flag1) {
    markDirty();
  }
}","@Override public void update(){
  int numHeaters=0;
  for (  EnumFacing dir2 : EnumFacing.VALUES) {
    BlockPos offsetPos=pos.offset(dir2);
    TileEntity tile=world.getTileEntity(offsetPos);
    if (tile instanceof TileEntitySteamHeater && ((TileEntitySteamHeater)tile).getSteamShare() > 2 && world.getBlockState(offsetPos).getValue(BlockSteamHeater.FACING) == dir2.getOpposite()) {
      numHeaters++;
    }
  }
  numHeaters=Math.min(4,numHeaters);
  if (numHeaters == 0) {
    TileEntitySteamHeater.replaceWith(this,new TileEntityFurnace());
  }
  int furnaceBurnTime=getField(FURNACE_BURN_TIME_ID);
  boolean flag=furnaceBurnTime > 0;
  boolean flag1=false;
  if (furnaceBurnTime > 0) {
    setField(FURNACE_BURN_TIME_ID,furnaceBurnTime - 1);
    furnaceBurnTime--;
  }
  if (!world.isRemote) {
    if (furnaceBurnTime == 0 && canSmelt()) {
      ItemStack inSlot1=getStackInSlot(1);
      int currentItemBurnTime=furnaceBurnTime=getItemBurnTime(inSlot1);
      setField(CURRENT_ITEM_BURN_TIME_ID,currentItemBurnTime);
      setField(FURNACE_BURN_TIME_ID,furnaceBurnTime);
      if (furnaceBurnTime > 0) {
        flag1=true;
        ItemStack copy=inSlot1.copy();
        copy.shrink(1);
        setInventorySlotContents(1,copy);
        if (inSlot1.isEmpty()) {
          setInventorySlotContents(1,inSlot1.getItem().getContainerItem(inSlot1));
        }
      }
    }
    int furnaceCookTime;
    if (isBurning() && canSmelt()) {
      furnaceCookTime=getField(COOK_TIME_ID);
      ++furnaceCookTime;
      setField(COOK_TIME_ID,furnaceCookTime);
      if (furnaceCookTime == 200) {
        furnaceCookTime=0;
        smeltItem();
        setField(COOK_TIME_ID,furnaceCookTime);
        flag1=true;
      }
    }
 else {
      furnaceCookTime=0;
      setField(COOK_TIME_ID,furnaceCookTime);
    }
    if (flag != furnaceBurnTime > 0) {
      flag1=true;
      BlockFurnace.setState(furnaceBurnTime > 0,world,pos);
    }
  }
  if (flag1) {
    markDirty();
  }
}",0.9711609563717032
22162,"public boolean canSmelt(){
  ItemStack slot0=getStackInSlot(0);
  if (slot0 == null) {
    return false;
  }
 else {
    ItemStack output=SteamingRegistry.getSteamingResult(slot0);
    if (output == null) {
      return false;
    }
    ItemStack slot2=getStackInSlot(2);
    if (slot2 == null) {
      return true;
    }
    if (!slot2.isItemEqual(output)) {
      return false;
    }
    int result=slot2.getCount() + output.getCount();
    return result <= getInventoryStackLimit() && result <= slot2.getMaxStackSize();
  }
}","public boolean canSmelt(){
  ItemStack slot0=getStackInSlot(0);
  if (slot0.isEmpty()) {
    return false;
  }
 else {
    ItemStack output=SteamingRegistry.getSteamingResult(slot0);
    if (output == null) {
      return false;
    }
    ItemStack slot2=getStackInSlot(2);
    if (slot2.isEmpty()) {
      return true;
    }
    if (!slot2.isItemEqual(output)) {
      return false;
    }
    int result=slot2.getCount() + output.getCount();
    return result <= getInventoryStackLimit() && result <= slot2.getMaxStackSize();
  }
}",0.9660377358490566
22163,"@Override public void readFromNBT(NBTTagCompound nbt){
  super.superReadFromNBT(nbt);
}","@Override public void readFromNBT(NBTTagCompound nbt){
  superReadFromNBT(nbt);
}",0.9642857142857144
22164,"@Override public void safeUpdate(){
  super.superUpdate();
  EnumFacing dir=world.getBlockState(pos).getValue(BlockSteamHeater.FACING);
  ArrayList<TileEntitySteamHeater> secondaryHeaters=new ArrayList<>();
  BlockPos offsetPos=getOffsetPos(dir);
  TileEntity tile=world.getTileEntity(offsetPos);
  if (tile == null || !(tile instanceof TileEntityFurnace)) {
    return;
  }
  TileEntityFurnace furnace=(TileEntityFurnace)tile;
  int numHeaters=0;
  isPrimaryHeater=false;
  for (  EnumFacing dir2 : EnumFacing.VALUES) {
    int x=pos.getX() + dir.getFrontOffsetX() + dir2.getFrontOffsetX();
    int y=pos.getY() + dir.getFrontOffsetY() + dir2.getFrontOffsetY();
    int z=pos.getZ() + dir.getFrontOffsetZ() + dir2.getFrontOffsetZ();
    BlockPos pos2=new BlockPos(x,y,z);
    TileEntity tile2=world.getTileEntity(pos2);
    IBlockState state2=world.getBlockState(pos2);
    if (tile2 != null) {
      if (tile2 instanceof TileEntitySteamHeater) {
        TileEntitySteamHeater heater2=(TileEntitySteamHeater)tile2;
        if (heater2.getSteamShare() >= CONSUMPTION && state2.getValue(BlockSteamHeater.FACING).getOpposite() == dir2) {
          isPrimaryHeater=x == pos.getX() && y == pos.getY() && z == pos.getZ();
          secondaryHeaters.add(heater2);
          numHeaters++;
          if (secondaryHeaters.size() > 4) {
            secondaryHeaters.remove(0);
          }
          numHeaters=Math.min(4,numHeaters);
        }
      }
    }
  }
  if (isPrimaryHeater && numHeaters > 0) {
    if (!(furnace instanceof TileEntitySteamFurnace) && furnace.getClass() == TileEntityFurnace.class) {
      replace(furnace);
    }
    if (!(furnace instanceof TileEntitySteamFurnace)) {
      return;
    }
    int furnaceBurnTime=furnace.getField(FURNACE_BURN_TIME_ID);
    int furnaceCookTime=furnace.getField(COOK_TIME_ID);
    if ((furnaceBurnTime == 1 || furnaceBurnTime == 0) && getSteamShare() >= CONSUMPTION && ((TileEntitySteamFurnace)furnace).canSmelt()) {
      if (furnaceBurnTime == 0) {
        BlockFurnace.setState(true,world,offsetPos);
      }
      for (      TileEntitySteamHeater heater : secondaryHeaters) {
        heater.decrSteam(CONSUMPTION);
      }
      furnace.setField(0,furnaceBurnTime + 3);
      if (numHeaters > 1 && furnaceCookTime > 0) {
        int newCookTime=Math.min(furnaceCookTime + 2 * numHeaters - 1,199);
        furnace.setField(COOK_TIME_ID,newCookTime);
      }
      world.notifyBlockUpdate(offsetPos,world.getBlockState(offsetPos),world.getBlockState(offsetPos),0);
    }
  }
}","@Override public void safeUpdate(){
  superUpdate();
  EnumFacing dir=world.getBlockState(pos).getValue(BlockSteamHeater.FACING);
  List<TileEntitySteamHeater> secondaryHeaters=new ArrayList<>();
  BlockPos offsetPos=getOffsetPos(dir);
  TileEntity tile=world.getTileEntity(offsetPos);
  if (!(tile instanceof TileEntityFurnace)) {
    return;
  }
  TileEntityFurnace furnace=(TileEntityFurnace)tile;
  int numHeaters=0;
  isPrimaryHeater=false;
  for (  EnumFacing dir2 : EnumFacing.VALUES) {
    int x=pos.getX() + dir.getFrontOffsetX() + dir2.getFrontOffsetX();
    int y=pos.getY() + dir.getFrontOffsetY() + dir2.getFrontOffsetY();
    int z=pos.getZ() + dir.getFrontOffsetZ() + dir2.getFrontOffsetZ();
    BlockPos pos2=new BlockPos(x,y,z);
    TileEntity tile2=world.getTileEntity(pos2);
    IBlockState state2=world.getBlockState(pos2);
    if (tile2 != null) {
      if (tile2 instanceof TileEntitySteamHeater) {
        TileEntitySteamHeater heater2=(TileEntitySteamHeater)tile2;
        if (heater2.getSteamShare() >= CONSUMPTION && state2.getValue(BlockSteamHeater.FACING).getOpposite() == dir2) {
          isPrimaryHeater=x == pos.getX() && y == pos.getY() && z == pos.getZ();
          secondaryHeaters.add(heater2);
          numHeaters++;
          if (secondaryHeaters.size() > 4) {
            secondaryHeaters.remove(0);
          }
          numHeaters=Math.min(4,numHeaters);
        }
      }
    }
  }
  if (isPrimaryHeater && numHeaters > 0) {
    if (!(furnace instanceof TileEntitySteamFurnace) && furnace.getClass() == TileEntityFurnace.class) {
      replace(furnace);
    }
    if (!(furnace instanceof TileEntitySteamFurnace)) {
      return;
    }
    int furnaceBurnTime=furnace.getField(FURNACE_BURN_TIME_ID);
    int furnaceCookTime=furnace.getField(COOK_TIME_ID);
    if ((furnaceBurnTime == 1 || furnaceBurnTime == 0) && getSteamShare() >= CONSUMPTION && ((TileEntitySteamFurnace)furnace).canSmelt()) {
      if (furnaceBurnTime == 0) {
        BlockFurnace.setState(true,world,offsetPos);
      }
      for (      TileEntitySteamHeater heater : secondaryHeaters) {
        heater.decrSteam(CONSUMPTION);
      }
      furnace.setField(0,furnaceBurnTime + 3);
      if (numHeaters > 1 && furnaceCookTime > 0) {
        int newCookTime=Math.min(furnaceCookTime + 2 * numHeaters - 1,199);
        furnace.setField(COOK_TIME_ID,newCookTime);
      }
      world.notifyBlockUpdate(offsetPos,world.getBlockState(offsetPos),world.getBlockState(offsetPos),0);
    }
  }
}",0.9946290033817388
22165,"public TileEntitySteamHeater(){
  super();
  addSidesToGaugeBlacklist(EnumFacing.VALUES);
}","public TileEntitySteamHeater(){
  addSidesToGaugeBlacklist(EnumFacing.VALUES);
}",0.935672514619883
22166,"@Override public NBTTagCompound writeToNBT(NBTTagCompound nbt){
  super.superWriteToNBT(nbt);
  return nbt;
}","@Nonnull @Override public NBTTagCompound writeToNBT(NBTTagCompound nbt){
  superWriteToNBT(nbt);
  return nbt;
}",0.9321266968325792
22167,"@Override public BlockStateContainer createBlockState(){
  return new BlockStateContainer(this,VARIANT);
}","@Nonnull @Override public BlockStateContainer createBlockState(){
  return new BlockStateContainer(this,VARIANT);
}",0.9592760180995475
22168,"@Override public IBlockState getStateFromMeta(int meta){
  return getDefaultState().withProperty(VARIANT,OreBlockTypes.byMetadata(meta));
}","@Nonnull @Override public IBlockState getStateFromMeta(int meta){
  return getDefaultState().withProperty(VARIANT,OreBlockTypes.byMetadata(meta));
}",0.9686411149825784
22169,"@Override @SideOnly(Side.CLIENT) public void getSubBlocks(Item item,CreativeTabs tabs,NonNullList<ItemStack> list){
  for (  OreBlockTypes type : OreBlockTypes.LOOKUP) {
    list.add(new ItemStack(this,1,type.getMetadata()));
  }
}","@Override @SideOnly(Side.CLIENT) public void getSubBlocks(@Nonnull Item item,CreativeTabs tabs,NonNullList<ItemStack> list){
  for (  OreBlockTypes type : OreBlockTypes.LOOKUP) {
    list.add(new ItemStack(this,1,type.getMetadata()));
  }
}",0.9808917197452228
22170,"/** 
 * @param state The state to check
 * @return Whether the provided blockstate matches this BiomeDefinition.
 */
public boolean matches(IBlockState state){
  if (state == null || (replaceableBlocksOreDict.isEmpty() && replaceableBlocksAndMeta.isEmpty())) {
    return false;
  }
  Block block=state.getBlock();
  int meta=block.getMetaFromState(state);
  if (replaceableBlocksAndMeta.contains(Pair.of(block,meta)) || replaceableBlocksAndMeta.contains(Pair.of(block,OreDictionary.WILDCARD_VALUE))) {
    return true;
  }
  Item itemBlock=Item.getItemFromBlock(block);
  if (itemBlock == null) {
    return false;
  }
  int[] ids=OreDictionary.getOreIDs(new ItemStack(itemBlock,1,meta));
  for (  int id : ids) {
    if (replaceableBlocksOreDict.contains(OreDictionary.getOreName(id))) {
      return true;
    }
  }
  return false;
}","/** 
 * @param state The state to check
 * @return Whether the provided blockstate matches this BiomeDefinition.
 */
public boolean matches(IBlockState state){
  if (state == null || (replaceableBlocksOreDict.isEmpty() && replaceableBlocksAndMeta.isEmpty())) {
    return false;
  }
  Block block=state.getBlock();
  int meta=block.getMetaFromState(state);
  if (replaceableBlocksAndMeta.contains(Pair.of(block,meta)) || replaceableBlocksAndMeta.contains(Pair.of(block,OreDictionary.WILDCARD_VALUE))) {
    return true;
  }
  Item itemBlock=Item.getItemFromBlock(block);
  if (itemBlock == Items.AIR) {
    return false;
  }
  int[] ids=OreDictionary.getOreIDs(new ItemStack(itemBlock,1,meta));
  for (  int id : ids) {
    if (replaceableBlocksOreDict.contains(OreDictionary.getOreName(id))) {
      return true;
    }
  }
  return false;
}",0.992248062015504
22171,"@Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack me,EntityPlayer player,List<String> list,boolean advanced){
  super.addInformation(me,player,list,advanced);
  list.add(TextFormatting.WHITE + ""String_Node_Str"" + (me.getMaxDamage() - me.getItemDamage()) * steamPerDurability() + ""String_Node_Str"" + me.getMaxDamage() * steamPerDurability() + ""String_Node_Str"");
  ArrayList<ItemStack> upgradeStacks=UtilSteamTool.getUpgradeStacks(me);
  ArrayList<String> upgradeStrings=UtilSteamTool.getInformationFromStacks(upgradeStacks,getRedSlot(),me);
  for (  String string : upgradeStrings) {
    list.add(string);
  }
}","@Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack me,World world,List<String> list,ITooltipFlag tooltipFlag){
  super.addInformation(me,world,list,tooltipFlag);
  list.add(TextFormatting.WHITE + ""String_Node_Str"" + (me.getMaxDamage() - me.getItemDamage()) * steamPerDurability() + ""String_Node_Str"" + me.getMaxDamage() * steamPerDurability() + ""String_Node_Str"");
  ArrayList<ItemStack> upgradeStacks=UtilSteamTool.getUpgradeStacks(me);
  ArrayList<String> upgradeStrings=UtilSteamTool.getInformationFromStacks(upgradeStacks,getRedSlot(),me);
  for (  String string : upgradeStrings) {
    list.add(string);
  }
}",0.9113924050632912
22172,"@Override public ItemStack getRecipeOutput(){
  return null;
}","@Nonnull @Override public ItemStack getRecipeOutput(){
  return ItemStack.EMPTY;
}",0.8055555555555556
22173,"@Override public ItemStack getCraftingResult(InventoryCrafting inv){
  ItemStack toCan=getItemToCan(inv);
  if (toCan != null) {
    if (!toCan.hasTagCompound()) {
      toCan.setTagCompound(new NBTTagCompound());
    }
    toCan.getTagCompound().setInteger(""String_Node_Str"",0);
    toCan.setCount(1);
    return toCan;
  }
  return null;
}","@Nonnull @Override public ItemStack getCraftingResult(@Nonnull InventoryCrafting inv){
  ItemStack toCan=getItemToCan(inv);
  if (toCan != null) {
    if (!toCan.hasTagCompound()) {
      toCan.setTagCompound(new NBTTagCompound());
    }
    toCan.getTagCompound().setInteger(""String_Node_Str"",0);
    toCan.setCount(1);
    return toCan;
  }
  return ItemStack.EMPTY;
}",0.9479606188466948
22174,"@Override public NonNullList<ItemStack> getRemainingItems(InventoryCrafting inv){
  return NonNullList.withSize(inv.getSizeInventory(),ItemStack.EMPTY);
}","@Nonnull @Override public NonNullList<ItemStack> getRemainingItems(@Nonnull InventoryCrafting inv){
  return NonNullList.withSize(inv.getSizeInventory(),ItemStack.EMPTY);
}",0.9447852760736196
22175,"/** 
 * @param inv The crafting inventory
 * @return A copy of the input ItemStack that is going to be canned. Will be null if the input is wrong (i.e.,multiple cans, multiple non-cans, input is already canned).
 */
@Nullable private ItemStack getItemToCan(InventoryCrafting inv){
  ItemStack output=null;
  int cans=0;
  int noncans=0;
  for (int i=0; i < inv.getSizeInventory(); i++) {
    ItemStack itemStack=inv.getStackInSlot(i);
    if (itemStack != null) {
      if (itemStack.getItem() == ITEM_CANISTER) {
        cans++;
      }
 else {
        noncans++;
        if (output == null) {
          output=itemStack.copy();
        }
      }
    }
  }
  if (output != null && output.hasTagCompound() && output.getTagCompound().hasKey(""String_Node_Str"")) {
    return null;
  }
  return cans == 1 && noncans == 1 ? output : null;
}","/** 
 * @param inv The crafting inventory
 * @return A copy of the input ItemStack that is going to be canned. Will be null if the input is wrong (i.e.,multiple cans, multiple non-cans, input is already canned).
 */
@Nullable private ItemStack getItemToCan(InventoryCrafting inv){
  ItemStack output=null;
  int cans=0;
  int noncans=0;
  for (int i=0; i < inv.getSizeInventory(); i++) {
    ItemStack itemStack=inv.getStackInSlot(i);
    if (!itemStack.isEmpty()) {
      if (itemStack.getItem() == ITEM_CANISTER) {
        cans++;
      }
 else {
        noncans++;
        if (output == null) {
          output=itemStack.copy();
        }
      }
    }
  }
  if (output != null && output.hasTagCompound() && output.getTagCompound().hasKey(""String_Node_Str"")) {
    return null;
  }
  return cans == 1 && noncans == 1 ? output : null;
}",0.9886567164179104
22176,"@Override public boolean matches(InventoryCrafting inv,World world){
  ItemStack toCan=getItemToCan(inv);
  return toCan != null;
}","@Override public boolean matches(@Nonnull InventoryCrafting inv,@Nonnull World world){
  ItemStack toCan=getItemToCan(inv);
  return toCan != null;
}",0.9357142857142856
22177,"@Override public boolean isEntityInvulnerable(DamageSource source){
  return true;
}","@Override public boolean isEntityInvulnerable(@Nonnull DamageSource source){
  return true;
}",0.9491525423728814
22178,"@Override public void writeEntityToNBT(NBTTagCompound nbt){
  nbt.setShort(""String_Node_Str"",(short)tilePos.getX());
  nbt.setShort(""String_Node_Str"",(short)tilePos.getY());
  nbt.setShort(""String_Node_Str"",(short)tilePos.getZ());
  nbt.setByte(""String_Node_Str"",(byte)inData);
  nbt.setByte(""String_Node_Str"",(byte)arrowShake);
  nbt.setBoolean(""String_Node_Str"",inGround);
  nbt.setDouble(""String_Node_Str"",damage);
}","@Override public void writeEntityToNBT(@Nonnull NBTTagCompound nbt){
  nbt.setShort(""String_Node_Str"",(short)tilePos.getX());
  nbt.setShort(""String_Node_Str"",(short)tilePos.getY());
  nbt.setShort(""String_Node_Str"",(short)tilePos.getZ());
  nbt.setByte(""String_Node_Str"",(byte)inData);
  nbt.setByte(""String_Node_Str"",(byte)arrowShake);
  nbt.setBoolean(""String_Node_Str"",inGround);
  nbt.setDouble(""String_Node_Str"",damage);
}",0.9893742621015348
22179,"@Override public void readEntityFromNBT(NBTTagCompound nbt){
  int x=nbt.getShort(""String_Node_Str"");
  int y=nbt.getShort(""String_Node_Str"");
  int z=nbt.getShort(""String_Node_Str"");
  tilePos=new BlockPos(x,y,z);
  inData=nbt.getByte(""String_Node_Str"") & 255;
  arrowShake=nbt.getByte(""String_Node_Str"") & 255;
  inGround=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str"")) {
    damage=nbt.getDouble(""String_Node_Str"");
  }
}","@Override public void readEntityFromNBT(@Nonnull NBTTagCompound nbt){
  int x=nbt.getShort(""String_Node_Str"");
  int y=nbt.getShort(""String_Node_Str"");
  int z=nbt.getShort(""String_Node_Str"");
  tilePos=new BlockPos(x,y,z);
  inData=nbt.getByte(""String_Node_Str"") & 255;
  arrowShake=nbt.getByte(""String_Node_Str"") & 255;
  inGround=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str"")) {
    damage=nbt.getDouble(""String_Node_Str"");
  }
}",0.9900552486187846
22180,"@Override @SideOnly(Side.CLIENT) public void setVelocity(double x,double y,double z){
  motionX=x;
  motionY=y;
  motionZ=z;
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var7=MathHelper.sqrt(x * x + z * z);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(x,z) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(y,(double)var7) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch;
    prevRotationYaw=rotationYaw;
    setLocationAndAngles(posX,posY,posZ,rotationYaw,rotationPitch);
    ticksInGround=0;
  }
}","@Override @SideOnly(Side.CLIENT) public void setVelocity(double x,double y,double z){
  motionX=x;
  motionY=y;
  motionZ=z;
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var7=MathHelper.sqrt(x * x + z * z);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(x,z) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(y,var7) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch;
    prevRotationYaw=rotationYaw;
    setLocationAndAngles(posX,posY,posZ,rotationYaw,rotationPitch);
    ticksInGround=0;
  }
}",0.9928952042628776
22181,"public EntityMusketBall(World world,EntityPlayer player,float par3,float par4,float damage,boolean par6){
  super(world);
  this.damage=damage;
  setRenderDistanceWeight(10.0D);
  shootingEntity=player;
  setSize(0.5F,0.5F);
  setLocationAndAngles(player.posX,player.posY + (double)player.getEyeHeight(),player.posZ,player.rotationYaw + ((itemRand.nextFloat() - 0.5F) * par4 * 15F),player.rotationPitch + ((itemRand.nextFloat() - 0.5F) * par4 * 15F));
  posX-=(double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  posY-=0.10000000149011612D;
  posZ-=(double)(MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  setPosition(this.posX,this.posY,this.posZ);
  motionX=(double)(-MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI));
  motionZ=(double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI));
  motionY=(double)(-MathHelper.sin(this.rotationPitch / 180.0F * (float)Math.PI));
  setThrowableHeading(this.motionX,this.motionY,this.motionZ,par3 * 10F,1.0F);
}","public EntityMusketBall(World world,EntityPlayer player,float par3,float par4,float damage,boolean par6){
  super(world);
  this.damage=damage;
  setRenderDistanceWeight(10.0D);
  shootingEntity=player;
  setSize(0.5F,0.5F);
  setLocationAndAngles(player.posX,player.posY + player.getEyeHeight(),player.posZ,player.rotationYaw + ((itemRand.nextFloat() - 0.5F) * par4 * 15F),player.rotationPitch + ((itemRand.nextFloat() - 0.5F) * par4 * 15F));
  posX-=(MathHelper.cos(rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  posY-=0.10000000149011612D;
  posZ-=(MathHelper.sin(rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  setPosition(posX,posY,posZ);
  motionX=(-MathHelper.sin(rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(rotationPitch / 180.0F * (float)Math.PI));
  motionZ=(MathHelper.cos(rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(rotationPitch / 180.0F * (float)Math.PI));
  motionY=(-MathHelper.sin(rotationPitch / 180.0F * (float)Math.PI));
  shoot(motionX,motionY,motionZ,par3 * 10F,1.0F);
}",0.936953520478601
22182,"@Override public void onUpdate(){
  super.onUpdate();
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var1=MathHelper.sqrt(motionX * motionX + motionZ * motionZ);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(motionY,(double)var1) * 180.0D / Math.PI);
  }
  IBlockState state=world.getBlockState(tilePos);
  Block block=state.getBlock();
  if (block != null) {
    if (state.getMaterial() != Material.AIR) {
      AxisAlignedBB aabb=block.getCollisionBoundingBox(state,world,tilePos);
      if (aabb != null && aabb.contains(new Vec3d(posX,posY,posZ))) {
        inGround=true;
      }
    }
  }
  if (arrowShake > 0) {
    --arrowShake;
  }
  if (inGround && block != null) {
    int meta=block.getMetaFromState(state);
    if (block == inTile && meta == inData) {
      ++ticksInGround;
      if (ticksInGround == 1200) {
        setDead();
      }
    }
 else {
      inGround=false;
      motionX*=(double)(rand.nextFloat() * 0.2F);
      motionY*=(double)(rand.nextFloat() * 0.2F);
      motionZ*=(double)(rand.nextFloat() * 0.2F);
      ticksInGround=0;
      ticksInAir=0;
    }
  }
 else {
    ++ticksInAir;
    Vec3d posVec=new Vec3d(posX,posY,posZ);
    Vec3d motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    RayTraceResult rayTraceResult=world.rayTraceBlocks(posVec,motionVec,false,true,false);
    posVec=new Vec3d(posX,posY,posZ);
    motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (rayTraceResult != null) {
      motionVec=rayTraceResult.hitVec;
    }
    Entity entity=null;
    List<Entity> entities=world.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().grow(motionX,motionY,motionZ).expand(1.0D,1.0D,1.0D));
    double d1=0.0D;
    float f1=0.3F;
    for (    Entity entity1 : entities) {
      if (entity1.canBeCollidedWith() && (entity1 != shootingEntity || ticksInAir >= 5)) {
        AxisAlignedBB aabb=entity1.getEntityBoundingBox().expand((double)f1,(double)f1,(double)f1);
        RayTraceResult intercept=aabb.calculateIntercept(posVec,motionVec);
        if (intercept != null) {
          double distanceTo=posVec.distanceTo(intercept.hitVec);
          if (distanceTo < d1 || d1 == 0.0D) {
            entity=entity1;
            d1=distanceTo;
          }
        }
      }
    }
    if (entity != null) {
      rayTraceResult=new RayTraceResult(entity);
    }
    if (rayTraceResult != null) {
      if (rayTraceResult.entityHit != null) {
        int damage=(int)this.damage;
        DamageSource source;
        if (shootingEntity == null || silenced) {
          source=DamageSource.causeThrownDamage(this,this);
        }
 else {
          source=DamageSource.causeThrownDamage(this,shootingEntity);
        }
        if (isBurning() && !(rayTraceResult.entityHit instanceof EntityEnderman)) {
          rayTraceResult.entityHit.setFire(5);
        }
        if (rayTraceResult.entityHit.attackEntityFrom(source,damage)) {
          if (rayTraceResult.entityHit instanceof EntityLiving) {
            EntityLiving entityHit=(EntityLiving)rayTraceResult.entityHit;
            if (!world.isRemote) {
              entityHit.setArrowCountInEntity(entityHit.getArrowCountInEntity() + 1);
            }
          }
          if (!(rayTraceResult.entityHit instanceof EntityEnderman)) {
            setDead();
          }
        }
 else {
          motionX*=-0.10000000149011612D;
          motionY*=-0.10000000149011612D;
          motionZ*=-0.10000000149011612D;
          rotationYaw+=180.0F;
          prevRotationYaw+=180.0F;
          ticksInAir=0;
        }
      }
 else {
        tilePos=rayTraceResult.getBlockPos();
        IBlockState inState=world.getBlockState(tilePos);
        inTile=inState.getBlock();
        inData=inTile.getMetaFromState(inState);
        motionX=(double)((float)(rayTraceResult.hitVec.x - posX));
        motionY=(double)((float)(rayTraceResult.hitVec.y - posY));
        motionZ=(double)((float)(rayTraceResult.hitVec.z - posZ));
        float root=MathHelper.sqrt(motionX * motionX + motionY * motionY + motionZ * motionZ);
        posX-=motionX / (double)root * 0.05000000074505806D;
        posY-=motionY / (double)root * 0.05000000074505806D;
        posZ-=motionZ / (double)root * 0.05000000074505806D;
        inGround=true;
        arrowShake=7;
        if (inTile != null) {
          inTile.onEntityCollidedWithBlock(world,tilePos,inState,this);
        }
      }
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    float f3=0.99F;
    f1=0.05F;
    if (this.isInWater()) {
      double f2=0.25D;
      for (int i=0; i < 4; ++i) {
        world.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f2,posY - motionY * f2,posZ - motionZ * f2,motionX,motionY,motionZ);
      }
      f3=0.8F;
    }
    motionX*=(double)f3;
    motionY*=(double)f3;
    motionZ*=(double)f3;
    motionY-=(double)f1;
    setPosition(posX,posY,posZ);
  }
}","@Override public void onUpdate(){
  super.onUpdate();
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var1=MathHelper.sqrt(motionX * motionX + motionZ * motionZ);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(motionY,var1) * 180.0D / Math.PI);
  }
  IBlockState state=world.getBlockState(tilePos);
  Block block=state.getBlock();
  if (block != null) {
    if (state.getMaterial() != Material.AIR) {
      AxisAlignedBB aabb=block.getCollisionBoundingBox(state,world,tilePos);
      if (aabb != null && aabb.contains(new Vec3d(posX,posY,posZ))) {
        inGround=true;
      }
    }
  }
  if (arrowShake > 0) {
    --arrowShake;
  }
  if (inGround && block != null) {
    int meta=block.getMetaFromState(state);
    if (block == inTile && meta == inData) {
      ++ticksInGround;
      if (ticksInGround == 1200) {
        setDead();
      }
    }
 else {
      inGround=false;
      motionX*=(rand.nextFloat() * 0.2F);
      motionY*=(rand.nextFloat() * 0.2F);
      motionZ*=(rand.nextFloat() * 0.2F);
      ticksInGround=0;
      ticksInAir=0;
    }
  }
 else {
    ++ticksInAir;
    Vec3d posVec=new Vec3d(posX,posY,posZ);
    Vec3d motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    RayTraceResult rayTraceResult=world.rayTraceBlocks(posVec,motionVec,false,true,false);
    posVec=new Vec3d(posX,posY,posZ);
    motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (rayTraceResult != null) {
      motionVec=rayTraceResult.hitVec;
    }
    Entity entity=null;
    List<Entity> entities=world.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().grow(motionX,motionY,motionZ).expand(1.0D,1.0D,1.0D));
    double d1=0.0D;
    float f1=0.3F;
    for (    Entity entity1 : entities) {
      if (entity1.canBeCollidedWith() && (entity1 != shootingEntity || ticksInAir >= 5)) {
        AxisAlignedBB aabb=entity1.getEntityBoundingBox().expand(f1,f1,f1);
        RayTraceResult intercept=aabb.calculateIntercept(posVec,motionVec);
        if (intercept != null) {
          double distanceTo=posVec.distanceTo(intercept.hitVec);
          if (distanceTo < d1 || d1 == 0.0D) {
            entity=entity1;
            d1=distanceTo;
          }
        }
      }
    }
    if (entity != null) {
      rayTraceResult=new RayTraceResult(entity);
    }
    if (rayTraceResult != null) {
      if (rayTraceResult.entityHit != null) {
        int damage=(int)this.damage;
        DamageSource source;
        if (shootingEntity == null || silenced) {
          source=DamageSource.causeThrownDamage(this,this);
        }
 else {
          source=DamageSource.causeThrownDamage(this,shootingEntity);
        }
        if (isBurning() && !(rayTraceResult.entityHit instanceof EntityEnderman)) {
          rayTraceResult.entityHit.setFire(5);
        }
        if (rayTraceResult.entityHit.attackEntityFrom(source,damage)) {
          if (rayTraceResult.entityHit instanceof EntityLiving) {
            EntityLiving entityHit=(EntityLiving)rayTraceResult.entityHit;
            if (!world.isRemote) {
              entityHit.setArrowCountInEntity(entityHit.getArrowCountInEntity() + 1);
            }
          }
          if (!(rayTraceResult.entityHit instanceof EntityEnderman)) {
            setDead();
          }
        }
 else {
          motionX*=-0.10000000149011612D;
          motionY*=-0.10000000149011612D;
          motionZ*=-0.10000000149011612D;
          rotationYaw+=180.0F;
          prevRotationYaw+=180.0F;
          ticksInAir=0;
        }
      }
 else {
        tilePos=rayTraceResult.getBlockPos();
        IBlockState inState=world.getBlockState(tilePos);
        inTile=inState.getBlock();
        inData=inTile.getMetaFromState(inState);
        motionX=((float)(rayTraceResult.hitVec.x - posX));
        motionY=((float)(rayTraceResult.hitVec.y - posY));
        motionZ=((float)(rayTraceResult.hitVec.z - posZ));
        float root=MathHelper.sqrt(motionX * motionX + motionY * motionY + motionZ * motionZ);
        posX-=motionX / root * 0.05000000074505806D;
        posY-=motionY / root * 0.05000000074505806D;
        posZ-=motionZ / root * 0.05000000074505806D;
        inGround=true;
        arrowShake=7;
        if (inTile != null) {
          inTile.onEntityCollidedWithBlock(world,tilePos,inState,this);
        }
      }
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    float f3=0.99F;
    f1=0.05F;
    if (isInWater()) {
      double f2=0.25D;
      for (int i=0; i < 4; ++i) {
        world.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f2,posY - motionY * f2,posZ - motionZ * f2,motionX,motionY,motionZ);
      }
      f3=0.8F;
    }
    motionX*=f3;
    motionY*=f3;
    motionZ*=f3;
    motionY-=f1;
    setPosition(posX,posY,posZ);
  }
}",0.987096183764986
22183,"@Override public void writeEntityToNBT(NBTTagCompound nbt){
  nbt.setShort(""String_Node_Str"",(short)x);
  nbt.setShort(""String_Node_Str"",(short)y);
  nbt.setShort(""String_Node_Str"",(short)z);
  nbt.setByte(""String_Node_Str"",(byte)Block.getIdFromBlock(blockInside));
  nbt.setBoolean(""String_Node_Str"",inGround);
  nbt.setTag(""String_Node_Str"",newDoubleNBTList(motionX,motionY,motionZ));
}","@Override public void writeEntityToNBT(@Nonnull NBTTagCompound nbt){
  nbt.setShort(""String_Node_Str"",(short)x);
  nbt.setShort(""String_Node_Str"",(short)y);
  nbt.setShort(""String_Node_Str"",(short)z);
  nbt.setByte(""String_Node_Str"",(byte)Block.getIdFromBlock(blockInside));
  nbt.setBoolean(""String_Node_Str"",inGround);
  nbt.setTag(""String_Node_Str"",newDoubleNBTList(motionX,motionY,motionZ));
}",0.9885350318471338
22184,"@Override public void readEntityFromNBT(NBTTagCompound nbt){
  x=nbt.getShort(""String_Node_Str"");
  y=nbt.getShort(""String_Node_Str"");
  z=nbt.getShort(""String_Node_Str"");
  blockInside=Block.getBlockById(nbt.getByte(""String_Node_Str"") & 255);
  inGround=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str"",Constants.NBT.TAG_LIST)) {
    NBTTagList nbttaglist=nbt.getTagList(""String_Node_Str"",Constants.NBT.TAG_DOUBLE);
    motionX=nbttaglist.getDoubleAt(0);
    motionY=nbttaglist.getDoubleAt(1);
    motionZ=nbttaglist.getDoubleAt(2);
  }
 else {
    setDead();
  }
}","@Override public void readEntityFromNBT(@Nonnull NBTTagCompound nbt){
  x=nbt.getShort(""String_Node_Str"");
  y=nbt.getShort(""String_Node_Str"");
  z=nbt.getShort(""String_Node_Str"");
  blockInside=Block.getBlockById(nbt.getByte(""String_Node_Str"") & 255);
  inGround=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str"",Constants.NBT.TAG_LIST)) {
    NBTTagList nbttaglist=nbt.getTagList(""String_Node_Str"",Constants.NBT.TAG_DOUBLE);
    motionX=nbttaglist.getDoubleAt(0);
    motionY=nbttaglist.getDoubleAt(1);
    motionZ=nbttaglist.getDoubleAt(2);
  }
 else {
    setDead();
  }
}",0.992392223161454
22185,"@Override public float getBrightness(float partialTicks){
  return 1.0F;
}","@Override public float getBrightness(){
  return 1.0F;
}",0.8615384615384616
22186,"public EntityRocket(World world,EntityPlayer player,float par4,float size){
  super(world);
  inputParam4=par4;
  shootingEntity=player;
  explosionSize=size;
  setSize(0.25F,0.25F);
  setLocationAndAngles(player.posX,player.posY + (double)player.getEyeHeight(),player.posZ,player.rotationYaw + ((itemRand.nextFloat() - 0.5F) * par4 * 15F),player.rotationPitch + ((itemRand.nextFloat() - 0.5F) * par4 * 15F));
  setPosition(this.posX,this.posY,this.posZ);
  posX-=1.0D * (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  posZ-=1.0D * (double)(MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  motionX=motionY=motionZ=0.0D;
  double p_i1760_8_=player.getLookVec().x;
  double p_i1760_10_=player.getLookVec().y;
  double p_i1760_12_=player.getLookVec().z;
  double d6=(double)MathHelper.sqrt(p_i1760_8_ * p_i1760_8_ + p_i1760_10_ * p_i1760_10_ + p_i1760_12_ * p_i1760_12_);
  motionX=p_i1760_8_ / d6 * 1.0D;
  motionY=p_i1760_10_ / d6 * 1.0D;
  motionZ=p_i1760_12_ / d6 * 1.0D;
  displayRotationYaw=rotationYaw;
  float f3=MathHelper.sqrt(motionX * motionX + motionZ * motionZ);
  displayRotationPitch=(float)(Math.atan2(motionY,(double)f3) * 180.0D / Math.PI);
}","public EntityRocket(World world,EntityPlayer player,float par4,float size){
  super(world);
  inputParam4=par4;
  shootingEntity=player;
  explosionSize=size;
  setSize(0.25F,0.25F);
  setLocationAndAngles(player.posX,player.posY + player.getEyeHeight(),player.posZ,player.rotationYaw + ((itemRand.nextFloat() - 0.5F) * par4 * 15F),player.rotationPitch + ((itemRand.nextFloat() - 0.5F) * par4 * 15F));
  setPosition(posX,posY,posZ);
  posX-=1.0D * (MathHelper.cos(rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  posZ-=1.0D * (MathHelper.sin(rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  motionX=motionY=motionZ=0.0D;
  double p_i1760_8_=player.getLookVec().x;
  double p_i1760_10_=player.getLookVec().y;
  double p_i1760_12_=player.getLookVec().z;
  double d6=MathHelper.sqrt(p_i1760_8_ * p_i1760_8_ + p_i1760_10_ * p_i1760_10_ + p_i1760_12_ * p_i1760_12_);
  motionX=p_i1760_8_ / d6 * 1.0D;
  motionY=p_i1760_10_ / d6 * 1.0D;
  motionZ=p_i1760_12_ / d6 * 1.0D;
  displayRotationYaw=rotationYaw;
  float f3=MathHelper.sqrt(motionX * motionX + motionZ * motionZ);
  displayRotationPitch=(float)(Math.atan2(motionY,f3) * 180.0D / Math.PI);
}",0.2424756252649427
22187,"protected void onImpact(){
  if (!this.world.isRemote) {
    newExplosion(world,shootingEntity,posX,posY,posZ,explosionSize,true,world.getGameRules().getBoolean(""String_Node_Str""));
    this.setDead();
  }
}","protected void onImpact(){
  if (!world.isRemote) {
    newExplosion(world,shootingEntity,posX,posY,posZ,explosionSize,true,world.getGameRules().getBoolean(""String_Node_Str""));
    setDead();
  }
}",0.9752475247524752
22188,"@Override public boolean attackEntityFrom(DamageSource source,float amount){
  if (isEntityInvulnerable(source)) {
    return false;
  }
 else {
    setBeenAttacked();
    Entity entity=source.getTrueSource();
    if (entity != null) {
      Vec3d vec3=entity.getLookVec();
      motionX=vec3.x;
      motionY=vec3.y;
      motionZ=vec3.z;
      if (entity instanceof EntityLivingBase) {
        shootingEntity=(EntityLivingBase)entity;
      }
      return true;
    }
 else {
      return false;
    }
  }
}","@Override public boolean attackEntityFrom(@Nonnull DamageSource source,float amount){
  if (isEntityInvulnerable(source)) {
    return false;
  }
 else {
    markVelocityChanged();
    Entity entity=source.getTrueSource();
    if (entity != null) {
      Vec3d vec3=entity.getLookVec();
      motionX=vec3.x;
      motionY=vec3.y;
      motionZ=vec3.z;
      if (entity instanceof EntityLivingBase) {
        shootingEntity=(EntityLivingBase)entity;
      }
      return true;
    }
 else {
      return false;
    }
  }
}",0.9641125121241512
22189,"@Override @SideOnly(Side.CLIENT) public int getBrightnessForRender(float partialTicks){
  return 15728880;
}","@Override @SideOnly(Side.CLIENT) public int getBrightnessForRender(){
  return 15728880;
}",0.9090909090909092
22190,"@Override public void onUpdate(){
  IBlockState state=world.getBlockState(getPosition());
  Block block=world.getBlockState(getPosition()).getBlock();
  if (!world.isRemote && (shootingEntity != null && shootingEntity.isDead || (block.isAir(state,world,getPosition())))) {
    setDead();
  }
 else {
    super.onUpdate();
    if (inGround) {
      if (world.getBlockState(new BlockPos(x,y,z)) == blockInside) {
        ++ticksAlive;
        if (ticksAlive == 200) {
          setDead();
        }
        return;
      }
      ++ticksAlive;
      if (ticksAlive >= 200) {
        setDead();
      }
      motionX=0;
      motionY=0;
      motionZ=0;
      ticksAlive=0;
      ticksInAir=0;
    }
 else {
      ++ticksInAir;
    }
    Vec3d vec3=new Vec3d(posX,posY,posZ);
    Vec3d vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionY);
    RayTraceResult trace=this.world.rayTraceBlocks(vec3,vec31,false,true,false);
    vec3=new Vec3d(posX,posY,posZ);
    vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (trace != null) {
      vec31=trace.hitVec;
    }
    Entity entity=null;
    List<Entity> list=world.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().grow(motionX,motionY,motionZ).expand(0.5D,0.5D,0.5D));
    double d0=0.0D;
    for (    Entity entity1 : list) {
      if (entity1.canBeCollidedWith() && (!entity1.isEntityEqual(shootingEntity) || this.ticksInAir >= 25)) {
        float f=0.3F;
        AxisAlignedBB axisalignedbb=entity1.getEntityBoundingBox().expand((double)f,(double)f,(double)f);
        RayTraceResult trace1=axisalignedbb.calculateIntercept(vec3,vec31);
        if (trace1 != null) {
          double d1=vec3.distanceTo(trace1.hitVec);
          if (d1 < d0 || d0 == 0.0D) {
            entity=entity1;
            d0=d1;
          }
        }
      }
    }
    if (entity != null) {
      trace=new RayTraceResult(entity);
    }
    if (trace != null) {
      this.onImpact();
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionZ,motionX) * 180.0D / Math.PI) + 90.0F;
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    if (isInWater()) {
      for (int j=0; j < 4; ++j) {
        double f3=0.25D;
        world.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f3,posY - motionY * f3,posZ - motionZ * f3,motionX,motionY,motionZ);
      }
    }
    world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 3F,posY - motionY * 3F,posZ - motionZ * 3F,0D,0D,0D);
    world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 1.5F,posY - motionY * 1.5F,posZ - motionZ * 1.5F,0D,0D,0D);
    setPosition(posX,posY,posZ);
  }
}","@Override public void onUpdate(){
  IBlockState state=world.getBlockState(getPosition());
  Block block=world.getBlockState(getPosition()).getBlock();
  if (!world.isRemote && (shootingEntity != null && shootingEntity.isDead || (block.isAir(state,world,getPosition())))) {
    setDead();
  }
 else {
    super.onUpdate();
    if (inGround) {
      if (world.getBlockState(new BlockPos(x,y,z)) == blockInside) {
        ++ticksAlive;
        if (ticksAlive == 200) {
          setDead();
        }
        return;
      }
      ++ticksAlive;
      if (ticksAlive >= 200) {
        setDead();
      }
      motionX=0;
      motionY=0;
      motionZ=0;
      ticksAlive=0;
      ticksInAir=0;
    }
 else {
      ++ticksInAir;
    }
    Vec3d vec3=new Vec3d(posX,posY,posZ);
    Vec3d vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionY);
    RayTraceResult trace=world.rayTraceBlocks(vec3,vec31,false,true,false);
    vec3=new Vec3d(posX,posY,posZ);
    vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (trace != null) {
      vec31=trace.hitVec;
    }
    Entity entity=null;
    List<Entity> list=world.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().grow(motionX,motionY,motionZ).expand(0.5D,0.5D,0.5D));
    double d0=0.0D;
    for (    Entity entity1 : list) {
      if (entity1.canBeCollidedWith() && (!entity1.isEntityEqual(shootingEntity) || ticksInAir >= 25)) {
        float f=0.3F;
        AxisAlignedBB axisalignedbb=entity1.getEntityBoundingBox().expand(f,f,f);
        RayTraceResult trace1=axisalignedbb.calculateIntercept(vec3,vec31);
        if (trace1 != null) {
          double d1=vec3.distanceTo(trace1.hitVec);
          if (d1 < d0 || d0 == 0.0D) {
            entity=entity1;
            d0=d1;
          }
        }
      }
    }
    if (entity != null) {
      trace=new RayTraceResult(entity);
    }
    if (trace != null) {
      onImpact();
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionZ,motionX) * 180.0D / Math.PI) + 90.0F;
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    if (isInWater()) {
      for (int j=0; j < 4; ++j) {
        double f3=0.25D;
        world.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f3,posY - motionY * f3,posZ - motionZ * f3,motionX,motionY,motionZ);
      }
    }
    world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 3F,posY - motionY * 3F,posZ - motionZ * 3F,0D,0D,0D);
    world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 1.5F,posY - motionY * 1.5F,posZ - motionZ * 1.5F,0D,0D,0D);
    setPosition(posX,posY,posZ);
  }
}",0.8772332404523848
22191,"@Override public String getName(){
  return name;
}","@Nonnull @Override public String getName(){
  return name;
}",0.918918918918919
22192,"@Override public IBlockState withMirror(IBlockState state,Mirror mirrorIn){
  return state.withRotation(mirrorIn.toRotation(state.getValue(FACING)));
}","@Nonnull @Override public IBlockState withMirror(@Nonnull IBlockState state,Mirror mirrorIn){
  return state.withRotation(mirrorIn.toRotation(state.getValue(FACING)));
}",0.94375
22193,"@Override @SideOnly(Side.CLIENT) public void randomDisplayTick(IBlockState state,World world,BlockPos pos,Random rand){
  TileEntity tile=world.getTileEntity(pos);
  if (tile == null || !(tile instanceof TileEntityBoiler)) {
    return;
  }
  TileEntityBoiler boiler=(TileEntityBoiler)tile;
  if (boiler.isBurning()) {
    EnumFacing facing=state.getValue(FACING);
    float f=(float)pos.getX() + 0.5F;
    float f1=(float)pos.getY() + 0.0F + rand.nextFloat() * 6.0F / 16.0F;
    float f2=(float)pos.getZ() + 0.5F;
    float f3=0.52F;
    float f4=rand.nextFloat() * 0.6F - 0.3F;
    double xCoord;
    double yCoord=(double)f1;
    double zCoord;
switch (facing) {
case WEST:
{
        xCoord=(double)f - f3;
        zCoord=(double)f2 + f4;
        break;
      }
case EAST:
{
      xCoord=(double)f + f3;
      zCoord=(double)f2 + f4;
      break;
    }
case NORTH:
{
    xCoord=(double)f + f4;
    zCoord=(double)f2 - f3;
    break;
  }
case SOUTH:
{
  xCoord=(double)f + f4;
  zCoord=(double)f2 + f3;
  break;
}
default :
{
return;
}
}
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,xCoord,yCoord,zCoord,0D,0D,0D);
world.spawnParticle(EnumParticleTypes.FLAME,xCoord,yCoord,zCoord,0D,0D,0D);
}
}","@Override @SideOnly(Side.CLIENT) public void randomDisplayTick(IBlockState state,World world,BlockPos pos,Random rand){
  TileEntity tile=world.getTileEntity(pos);
  if (!(tile instanceof TileEntityBoiler)) {
    return;
  }
  TileEntityBoiler boiler=(TileEntityBoiler)tile;
  if (boiler.isBurning()) {
    EnumFacing facing=state.getValue(FACING);
    float f=pos.getX() + 0.5F;
    float f1=pos.getY() + 0.0F + rand.nextFloat() * 6.0F / 16.0F;
    float f2=pos.getZ() + 0.5F;
    float f3=0.52F;
    float f4=rand.nextFloat() * 0.6F - 0.3F;
    double xCoord;
    double zCoord;
switch (facing) {
case WEST:
{
        xCoord=(double)f - f3;
        zCoord=(double)f2 + f4;
        break;
      }
case EAST:
{
      xCoord=(double)f + f3;
      zCoord=(double)f2 + f4;
      break;
    }
case NORTH:
{
    xCoord=(double)f + f4;
    zCoord=(double)f2 - f3;
    break;
  }
case SOUTH:
{
  xCoord=(double)f + f4;
  zCoord=(double)f2 + f3;
  break;
}
default :
{
return;
}
}
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,xCoord,f1,zCoord,0D,0D,0D);
world.spawnParticle(EnumParticleTypes.FLAME,xCoord,f1,zCoord,0D,0D,0D);
}
}",0.9643623872906828
22194,"@Override public IBlockState withRotation(IBlockState state,Rotation rot){
  return state.withProperty(FACING,rot.rotate(state.getValue(FACING)));
}","@Nonnull @Override public IBlockState withRotation(@Nonnull IBlockState state,Rotation rot){
  return state.withProperty(FACING,rot.rotate(state.getValue(FACING)));
}",0.9426751592356688
22195,"@Override public IBlockState getActualState(IBlockState state,IBlockAccess world,BlockPos pos){
  TileEntity tile=WorldHelper.getTileEntitySafely(world,pos);
  if (tile instanceof TileEntityBoiler) {
    TileEntityBoiler boiler=(TileEntityBoiler)tile;
    return getDefaultState().withProperty(FACING,state.getValue(FACING)).withProperty(IS_ON,boiler.isBurning());
  }
  return state;
}","@Nonnull @Override public IBlockState getActualState(@Nonnull IBlockState state,IBlockAccess world,BlockPos pos){
  TileEntity tile=WorldHelper.getTileEntitySafely(world,pos);
  if (tile instanceof TileEntityBoiler) {
    TileEntityBoiler boiler=(TileEntityBoiler)tile;
    return getDefaultState().withProperty(FACING,state.getValue(FACING)).withProperty(IS_ON,boiler.isBurning());
  }
  return state;
}",0.9772151898734176
22196,"@Override public TileEntity createTileEntity(World world,IBlockState state){
  return new TileEntityBoiler();
}","@Override public TileEntity createTileEntity(@Nonnull World world,@Nonnull IBlockState state){
  return new TileEntityBoiler();
}",0.925
22197,"@Override public boolean onWrench(ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing facing,IBlockState state,float hitX,float hitY,float hitZ){
  if (player.isSneaking()) {
    return true;
  }
 else   if (facing != EnumFacing.DOWN && facing != EnumFacing.UP) {
    WorldHelper.rotateProperly(FACING,world,state,pos,facing);
  }
  return false;
}","@Override public boolean onWrench(@Nonnull ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing facing,IBlockState state,float hitX,float hitY,float hitZ){
  if (player.isSneaking()) {
    return true;
  }
  if (facing != EnumFacing.DOWN && facing != EnumFacing.UP) {
    WorldHelper.rotateProperly(FACING,world,state,pos,facing);
  }
  return false;
}",0.9804432855280312
22198,"@Override public BlockStateContainer createBlockState(){
  return new BlockStateContainer(this,FACING,IS_ON);
}","@Nonnull @Override public BlockStateContainer createBlockState(){
  return new BlockStateContainer(this,FACING,IS_ON);
}",0.961038961038961
22199,"@Override public IBlockState getStateFromMeta(int meta){
  return getDefaultState().withProperty(FACING,EnumFacing.getHorizontal(meta));
}","@Nonnull @Override public IBlockState getStateFromMeta(int meta){
  return getDefaultState().withProperty(FACING,EnumFacing.getHorizontal(meta));
}",0.968421052631579
22200,"@Override public void breakBlock(World world,BlockPos pos,IBlockState state){
  TileEntity tileentity=world.getTileEntity(pos);
  if (tileentity != null && tileentity instanceof TileEntityBoiler) {
    InventoryHelper.dropInventoryItems(world,pos,(TileEntityBoiler)tileentity);
    world.updateComparatorOutputLevel(pos,state.getBlock());
  }
  super.breakBlock(world,pos,state);
}","@Override public void breakBlock(World world,BlockPos pos,IBlockState state){
  TileEntity tileentity=world.getTileEntity(pos);
  if (tileentity instanceof TileEntityBoiler) {
    InventoryHelper.dropInventoryItems(world,pos,(IInventory)tileentity);
    world.updateComparatorOutputLevel(pos,state.getBlock());
  }
  super.breakBlock(world,pos,state);
}",0.9346049046321526
22201,"@Override public ItemStack getPickBlock(IBlockState state,RayTraceResult target,World world,BlockPos pos,EntityPlayer player){
  return new ItemStack(BoilerModule.BOILER);
}","@Nonnull @Override public ItemStack getPickBlock(@Nonnull IBlockState state,RayTraceResult target,@Nonnull World world,@Nonnull BlockPos pos,EntityPlayer player){
  return new ItemStack(BoilerModule.BOILER);
}",0.9057591623036648
22202,"@Override public void detectAndSendChanges(){
  super.detectAndSendChanges();
  for (  IContainerListener listener : listeners) {
    if (lastCookTime != tileEntity.furnaceCookTime) {
      listener.sendWindowProperty(this,0,tileEntity.furnaceCookTime);
    }
    if (lastBurnTime != tileEntity.furnaceBurnTime) {
      listener.sendWindowProperty(this,1,tileEntity.furnaceBurnTime);
    }
    if (lastItemBurnTime != tileEntity.currentItemBurnTime) {
      listener.sendWindowProperty(this,2,tileEntity.currentItemBurnTime);
    }
    if (lastPressure != tileEntity.getPressureAsInt()) {
      listener.sendWindowProperty(this,3,tileEntity.getPressureAsInt());
    }
    if (this.lastWater != tileEntity.getTank().getFluidAmount()) {
      listener.sendWindowProperty(this,4,tileEntity.getTank().getFluidAmount());
    }
  }
  lastCookTime=tileEntity.furnaceCookTime;
  lastBurnTime=tileEntity.furnaceBurnTime;
  lastItemBurnTime=tileEntity.currentItemBurnTime;
  lastPressure=tileEntity.getPressureAsInt();
  lastWater=tileEntity.getTank().getFluidAmount();
}","@Override public void detectAndSendChanges(){
  super.detectAndSendChanges();
  for (  IContainerListener listener : listeners) {
    if (lastCookTime != tileEntity.cookTime) {
      listener.sendWindowProperty(this,0,tileEntity.cookTime);
    }
    if (lastBurnTime != tileEntity.burnTime) {
      listener.sendWindowProperty(this,1,tileEntity.burnTime);
    }
    if (lastItemBurnTime != tileEntity.currentItemBurnTime) {
      listener.sendWindowProperty(this,2,tileEntity.currentItemBurnTime);
    }
    if (lastPressure != tileEntity.getPressureAsInt()) {
      listener.sendWindowProperty(this,3,tileEntity.getPressureAsInt());
    }
    if (this.lastWater != tileEntity.getTank().getFluidAmount()) {
      listener.sendWindowProperty(this,4,tileEntity.getTank().getFluidAmount());
    }
  }
  lastCookTime=tileEntity.cookTime;
  lastBurnTime=tileEntity.burnTime;
  lastItemBurnTime=tileEntity.currentItemBurnTime;
  lastPressure=tileEntity.getPressureAsInt();
  lastWater=tileEntity.getTank().getFluidAmount();
}",0.8567307692307692
22203,"@Override public ItemStack transferStackInSlot(EntityPlayer player,int index){
  ItemStack itemstack=null;
  Slot slot=inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (index == 2) {
      return null;
    }
 else     if (index != 1 && index != 0) {
      if (FluidHelper.itemStackIsWaterContainer(itemstack1)) {
        if (!mergeItemStack(itemstack1,0,1,false)) {
          return null;
        }
      }
 else       if (TileEntityFurnace.isItemFuel(itemstack1)) {
        if (!mergeItemStack(itemstack1,1,2,false)) {
          return null;
        }
      }
 else       if (index >= 2 && index < 30) {
        if (!mergeItemStack(itemstack1,30,38,false)) {
          return null;
        }
      }
 else       if (index >= 30 && index < 39 && !mergeItemStack(itemstack1,3,30,false)) {
        return null;
      }
    }
 else     if (!mergeItemStack(itemstack1,3,38,false)) {
      return null;
    }
    if (itemstack1.isEmpty()) {
      slot.putStack(null);
    }
 else {
      slot.onSlotChanged();
    }
    if (itemstack1.getCount() == itemstack.getCount()) {
      return null;
    }
    slot.onTake(player,itemstack1);
  }
  return itemstack;
}","@Nonnull @Override public ItemStack transferStackInSlot(EntityPlayer player,int index){
  ItemStack itemstack=ItemStack.EMPTY;
  Slot slot=inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (index == 2) {
      return ItemStack.EMPTY;
    }
 else     if (index != 1 && index != 0) {
      if (FluidHelper.itemStackIsWaterContainer(itemstack1)) {
        if (!mergeItemStack(itemstack1,0,1,false)) {
          return ItemStack.EMPTY;
        }
      }
 else       if (TileEntityFurnace.isItemFuel(itemstack1)) {
        if (!mergeItemStack(itemstack1,1,2,false)) {
          return ItemStack.EMPTY;
        }
      }
 else       if (index >= 2 && index < 30) {
        if (!mergeItemStack(itemstack1,30,38,false)) {
          return ItemStack.EMPTY;
        }
      }
 else       if (index >= 30 && index < 39 && !mergeItemStack(itemstack1,3,30,false)) {
        return ItemStack.EMPTY;
      }
    }
 else     if (!mergeItemStack(itemstack1,3,38,false)) {
      return ItemStack.EMPTY;
    }
    if (itemstack1.isEmpty()) {
      slot.putStack(ItemStack.EMPTY);
    }
 else {
      slot.onSlotChanged();
    }
    if (itemstack1.getCount() == itemstack.getCount()) {
      return ItemStack.EMPTY;
    }
    slot.onTake(player,itemstack1);
  }
  return itemstack;
}",0.8948170731707317
22204,"@Override public boolean canInteractWith(EntityPlayer par1EntityPlayer){
  return tileEntity.isUsableByPlayer(par1EntityPlayer);
}","@Override public boolean canInteractWith(@Nonnull EntityPlayer par1EntityPlayer){
  return tileEntity.isUsableByPlayer(par1EntityPlayer);
}",0.966542750929368
22205,"@Override public void addListener(IContainerListener listener){
  super.addListener(listener);
  listener.sendWindowProperty(this,0,tileEntity.furnaceCookTime);
  listener.sendWindowProperty(this,1,tileEntity.furnaceBurnTime);
  listener.sendWindowProperty(this,2,TileEntityBoiler.getItemBurnTime(null));
  listener.sendWindowProperty(this,3,(int)Math.floor((double)tileEntity.getPressure() * 1000));
}","@Override public void addListener(IContainerListener listener){
  super.addListener(listener);
  listener.sendWindowProperty(this,0,tileEntity.cookTime);
  listener.sendWindowProperty(this,1,tileEntity.burnTime);
  listener.sendWindowProperty(this,2,TileEntityBoiler.getItemBurnTime(ItemStack.EMPTY));
  listener.sendWindowProperty(this,3,(int)Math.floor((double)tileEntity.getPressure() * 1000));
}",0.7615480649188514
22206,"@SideOnly(Side.CLIENT) @Override public void updateProgressBar(int id,int data){
  if (id == 0) {
    tileEntity.furnaceCookTime=data;
  }
  if (id == 1) {
    tileEntity.furnaceBurnTime=data;
  }
  if (id == 2) {
    tileEntity.currentItemBurnTime=data;
  }
  if (id == 3) {
    tileEntity.setPressure((float)data / 1000F);
  }
  if (id == 4) {
    int current=tileEntity.getTank().getFluidAmount();
    int diff=data - current;
    if (diff > 0) {
      tileEntity.getTank().fill(new FluidStack(FluidHelper.getWaterFluid(),diff),true);
    }
 else {
      tileEntity.getTank().drain(-1 * diff,true);
    }
  }
}","@SideOnly(Side.CLIENT) @Override public void updateProgressBar(int id,int data){
  if (id == 0) {
    tileEntity.cookTime=data;
  }
  if (id == 1) {
    tileEntity.burnTime=data;
  }
  if (id == 2) {
    tileEntity.currentItemBurnTime=data;
  }
  if (id == 3) {
    tileEntity.setPressure((float)data / 1000F);
  }
  if (id == 4) {
    int current=tileEntity.getTank().getFluidAmount();
    int diff=data - current;
    if (diff > 0) {
      tileEntity.getTank().fill(new FluidStack(FluidHelper.getWaterFluid(),diff),true);
    }
 else {
      tileEntity.getTank().drain(-1 * diff,true);
    }
  }
}",0.9867986798679867
22207,"@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  int k=(width - xSize) / 2;
  int l=(height - ySize) / 2;
  GL11.glEnable(3042);
  drawTexturedModalRect(k,l,0,0,xSize,ySize);
  int i1;
  i1=tileEntity.getBurnTimeRemainingScaled(14);
  drawTexturedModalRect(k + 58,l + 15 + 14 - i1,176,14 - i1,14,i1);
  GL11.glDisable(3042);
  FluidTank tank=tileEntity.getTank();
  if (tank == null) {
    return;
  }
  FluidStack fluidStack=tank.getFluid();
  if (fluidStack == null) {
    return;
  }
  float fill=fluidStack.amount / (float)tank.getCapacity();
  drawFluid(new FluidStack(FluidHelper.getWaterFluid(),1),(int)(fill * 58.0F),k + 81,l + 14,16,58,false);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 80,l + 13,190,0,18,60);
  fill=tileEntity.getPressure();
  fill=Math.min(fill,1.0F);
  FluidStack stack=new FluidStack(FluidHelper.getWaterFluid(),1);
  if (FluidRegistry.isFluidRegistered(""String_Node_Str"")) {
    stack=new FluidStack(FluidRegistry.getFluid(""String_Node_Str""),1);
  }
  drawFluid(stack,(int)(fill * 58.0F),k + 104,l + 14,16,58,true);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 103,l + 13,190,0,18,60);
  GL11.glDisable(3042);
}","@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  int k=(width - xSize) / 2;
  int l=(height - ySize) / 2;
  GL11.glEnable(3042);
  drawTexturedModalRect(k,l,0,0,xSize,ySize);
  int i1;
  i1=tileEntity.getBurnTimeRemainingScaled(14);
  drawTexturedModalRect(k + 58,l + 15 + 14 - i1,176,14 - i1,14,i1);
  GL11.glDisable(3042);
  FluidTank tank=tileEntity.getTank();
  if (tank == null) {
    return;
  }
  FluidStack fluidStack=tank.getFluid();
  if (fluidStack == null) {
    return;
  }
  float fill=fluidStack.amount / (float)tank.getCapacity();
  drawFluid(new FluidStack(FluidHelper.getWaterFluid(),1),(int)(fill * 58.0F),k + 81,l + 14,16,58,false);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 80,l + 13,190,0,18,60);
  fill=Math.min(tileEntity.getPressure(),1F);
  FluidStack stack=new FluidStack(FluidHelper.getWaterFluid(),1);
  if (FluidRegistry.isFluidRegistered(""String_Node_Str"")) {
    stack=new FluidStack(FluidRegistry.getFluid(""String_Node_Str""),1);
  }
  drawFluid(stack,(int)(fill * 58.0F),k + 104,l + 14,16,58,true);
  mc.getTextureManager().bindTexture(BOILER_TEXTURES);
  drawTexturedModalRect(k + 103,l + 13,190,0,18,60);
  GL11.glDisable(3042);
}",0.9864020580668872
22208,"private void drawFluid(FluidStack fluid,int level,int x,int y,int width,int height,boolean steam){
  if (fluid == null || fluid.getFluid() == null) {
    return;
  }
  TextureAtlasSprite icon=FluidHelper.getStillTexture(mc,fluid.getFluid());
  if (steam) {
    icon=mc.getTextureMapBlocks().getTextureExtry(STEAM_RL.toString());
  }
  mc.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
  int fullX=width / 16;
  int fullY=height / 16;
  int lastX=width - fullX * 16;
  int lastY=height - fullY * 16;
  int fullLvl=(height - level) / 16;
  int lastLvl=(height - level) - fullLvl * 16;
  for (int i=0; i < fullX; i++) {
    for (int j=0; j < fullY; j++) {
      if (j >= fullLvl) {
        drawCutIcon(icon,x + i * 16,y + j * 16,16,16,j == fullLvl ? lastLvl : 0);
      }
    }
  }
  for (int i=0; i < fullX; i++) {
    drawCutIcon(icon,x + i * 16,y + fullY * 16,16,lastY,fullLvl == fullY ? lastLvl : 0);
  }
  for (int i=0; i < fullY; i++) {
    if (i >= fullLvl) {
      drawCutIcon(icon,x + fullX * 16,y + i * 16,lastX,16,i == fullLvl ? lastLvl : 0);
    }
  }
  drawCutIcon(icon,x + fullX * 16,y + fullY * 16,lastX,lastY,fullLvl == fullY ? lastLvl : 0);
}","private void drawFluid(FluidStack fluid,int level,int x,int y,int width,int height,boolean steam){
  if (fluid == null || fluid.getFluid() == null) {
    return;
  }
  TextureAtlasSprite icon=FluidHelper.getStillTexture(mc,fluid.getFluid());
  if (steam) {
    icon=mc.getTextureMapBlocks().getTextureExtry(STEAM_RL.toString());
  }
  mc.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
  int fullX=width / 16;
  int fullY=height / 16;
  int fullLvl=(height - level) / 16;
  int lastLvl=(height - level) - fullLvl * 16;
  for (int i=0; i < fullX; i++) {
    for (int j=0; j < fullY; j++) {
      if (j >= fullLvl) {
        drawCutIcon(icon,x + i * 16,y + j * 16,16,16,j == fullLvl ? lastLvl : 0);
      }
    }
  }
  int lastY=height - fullY * 16;
  for (int i=0; i < fullX; i++) {
    drawCutIcon(icon,x + i * 16,y + fullY * 16,16,lastY,fullLvl == fullY ? lastLvl : 0);
  }
  int lastX=width - fullX * 16;
  for (int i=0; i < fullY; i++) {
    if (i >= fullLvl) {
      drawCutIcon(icon,x + fullX * 16,y + i * 16,lastX,16,i == fullLvl ? lastLvl : 0);
    }
  }
  drawCutIcon(icon,x + fullX * 16,y + fullY * 16,lastX,lastY,fullLvl == fullY ? lastLvl : 0);
}",0.9444918872758328
22209,"/** 
 * Adds an exosuit plate recipe (2x2 of ingredient), without a melting recipe for the itemstack.
 * @param str The name of the recipe for the book.
 * @param ingredient The ingredient, either an ItemStack or an OreDict string
 * @param plate The output plate.
 */
private static void addExosuitPlateRecipes(String str,Object ingredient,ItemStack plate){
  BookRecipeRegistry.addRecipe(str,new ShapedOreRecipe(plate,""String_Node_Str"",""String_Node_Str"",'x',ingredient));
  if (ingredient instanceof ItemStack) {
    ItemStack stack=((ItemStack)ingredient).copy();
    stack.stackSize=4;
    GameRegistry.addRecipe(new ShapelessOreRecipe(stack,plate));
  }
 else   if (ingredient instanceof String) {
    for (    ItemStack ore : OreDictionary.getOres((String)ingredient)) {
      ItemStack stack=ore.copy();
      stack.stackSize=4;
      GameRegistry.addRecipe(new ShapelessOreRecipe(stack,plate));
    }
  }
}","/** 
 * Adds an exosuit plate recipe (2x2 of ingredient), without a melting recipe for the itemstack.
 * @param str The name of the recipe for the book.
 * @param ingredient The ingredient, either an ItemStack or an OreDict string
 * @param plate The output plate.
 */
private static void addExosuitPlateRecipes(String str,Object ingredient,ItemStack plate){
  BookRecipeRegistry.addRecipe(str,new ShapedOreRecipe(plate,""String_Node_Str"",""String_Node_Str"",'x',ingredient));
  if (ingredient instanceof ItemStack) {
    ItemStack stack=((ItemStack)ingredient).copy();
    stack.setCount(4);
    GameRegistry.addRecipe(new ShapelessOreRecipe(stack,plate));
  }
 else   if (ingredient instanceof String) {
    for (    ItemStack ore : OreDictionary.getOres((String)ingredient)) {
      ItemStack stack=ore.copy();
      stack.setCount(4);
      GameRegistry.addRecipe(new ShapelessOreRecipe(stack,plate));
    }
  }
}",0.7177242888402626
22210,"@SubscribeEvent @SideOnly(Side.CLIENT) public void onPlayerTick(TickEvent.ClientTickEvent event){
  Minecraft mc=Minecraft.getMinecraft();
  if (event.side == Side.CLIENT && mc.thePlayer != null) {
    if (event.phase == TickEvent.Phase.START) {
      return;
    }
    for (    EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
      ItemStack armorStack=mc.thePlayer.getItemStackFromSlot(slot);
      if (armorStack != null && armorType.isAssignableFrom(armorStack.getItem().getClass())) {
        getModel(mc.thePlayer,slot).updateModel(mc.thePlayer,armorStack,slot);
      }
    }
  }
}","@SubscribeEvent @SideOnly(Side.CLIENT) public void onPlayerTick(TickEvent.ClientTickEvent event){
  Minecraft mc=Minecraft.getMinecraft();
  if (event.side == Side.CLIENT && mc.player != null) {
    if (event.phase == TickEvent.Phase.START) {
      return;
    }
    for (    EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
      ItemStack armorStack=mc.player.getItemStackFromSlot(slot);
      if (armorStack != null && armorType.isAssignableFrom(armorStack.getItem().getClass())) {
        getModel(mc.player,slot).updateModel(mc.player,armorStack,slot);
      }
    }
  }
}",0.9831365935919056
22211,"@Override public ItemStack decrStackSize(ItemStack me,int slot,int size){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    ItemStack toBeRemoved=ItemStack.loadItemStackFromNBT(plateNBT.getCompoundTag(""String_Node_Str""));
    me.getTagCompound().removeTag(""String_Node_Str"");
    return toBeRemoved;
  }
  return null;
}","@Override public ItemStack decrStackSize(ItemStack me,int slot,int size){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    ItemStack toBeRemoved=new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
    me.getTagCompound().removeTag(""String_Node_Str"");
    return toBeRemoved;
  }
  return null;
}",0.7204783258594918
22212,"@Override public ItemStack getStackInSlot(ItemStack me,int slot){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    return ItemStack.loadItemStackFromNBT(plateNBT.getCompoundTag(""String_Node_Str""));
  }
  return null;
}","@Override public ItemStack getStackInSlot(ItemStack me,int slot){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    return new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
  }
  return null;
}",0.8693790149892934
22213,"@Override public void damageArmor(EntityLivingBase entity,ItemStack stack,DamageSource source,int damage,int slot){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ExosuitPlate plate=UtilPlates.getPlate(plateNBT.getString(""String_Node_Str""));
    int damageReduction=plate.getDamageReductionAmount(armorType,source);
    if ((entity.worldObj.rand.nextInt(20 - damage) + 1) > damageReduction) {
      if (plateNBT.hasKey(""String_Node_Str"")) {
        plateNBT.setInteger(""String_Node_Str"",plateNBT.getInteger(""String_Node_Str"") - 1);
      }
 else {
        plateNBT.setInteger(""String_Node_Str"",plate.getDamageReductionAmount(armorType,DamageSource.generic));
      }
    }
  }
}","@Override public void damageArmor(EntityLivingBase entity,ItemStack stack,DamageSource source,int damage,int slot){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ExosuitPlate plate=UtilPlates.getPlate(plateNBT.getString(""String_Node_Str""));
    int damageReduction=plate.getDamageReductionAmount(armorType,source);
    if ((entity.world.rand.nextInt(20 - damage) + 1) > damageReduction) {
      if (plateNBT.hasKey(""String_Node_Str"")) {
        plateNBT.setInteger(""String_Node_Str"",plateNBT.getInteger(""String_Node_Str"") - 1);
      }
 else {
        plateNBT.setInteger(""String_Node_Str"",plate.getDamageReductionAmount(armorType,DamageSource.GENERIC));
      }
    }
  }
}",0.9879518072289156
22214,"@Override public void addInformation(ItemStack stack,EntityPlayer playerIn,List<String> tooltip,boolean advanced){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ItemStack plateStack=ItemStack.loadItemStackFromNBT(plateNBT.getCompoundTag(""String_Node_Str""));
    if (plateStack != null) {
      tooltip.add(TextFormatting.BLUE + plateStack.getDisplayName());
    }
  }
  super.addInformation(stack,playerIn,tooltip,advanced);
}","@Override public void addInformation(ItemStack stack,EntityPlayer playerIn,List<String> tooltip,boolean advanced){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ItemStack plateStack=new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
    if (plateStack != null) {
      tooltip.add(TextFormatting.BLUE + plateStack.getDisplayName());
    }
  }
  super.addInformation(stack,playerIn,tooltip,advanced);
}",0.9519553072625698
22215,"@Override public int getArmorDisplay(EntityPlayer player,ItemStack armor,int slot){
  NBTTagCompound plateNBT=getPlateNBT(armor);
  if (plateNBT != null) {
    return UtilPlates.getPlate(plateNBT.getString(""String_Node_Str"")).getDamageReductionAmount(armorType,DamageSource.generic);
  }
  return ArmorMaterial.LEATHER.getDamageReductionAmount(armorType);
}","@Override public int getArmorDisplay(EntityPlayer player,ItemStack armor,int slot){
  NBTTagCompound plateNBT=getPlateNBT(armor);
  if (plateNBT != null) {
    return UtilPlates.getPlate(plateNBT.getString(""String_Node_Str"")).getDamageReductionAmount(armorType,DamageSource.GENERIC);
  }
  return ArmorMaterial.LEATHER.getDamageReductionAmount(armorType);
}",0.9803921568627452
22216,"@Override public boolean hasUpgrade(ItemStack me,Item check){
  NBTTagCompound plateNBT=getPlateNBT(me);
  return plateNBT != null && ItemStack.loadItemStackFromNBT(plateNBT.getCompoundTag(""String_Node_Str"")).getItem() == check;
}","@Override public boolean hasUpgrade(ItemStack me,Item check){
  NBTTagCompound plateNBT=getPlateNBT(me);
  return plateNBT != null && new ItemStack(plateNBT.getCompoundTag(""String_Node_Str"")).getItem() == check;
}",0.9029345372460496
22217,"@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceiling_float_int(event.getOrb().xpValue * 1.125F);
}","@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceil(event.getOrb().xpValue * 1.125F);
}",0.9667519181585678
22218,"@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceiling_float_int(event.getOrb().xpValue * 1.25F);
}","@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceil(event.getOrb().xpValue * 1.25F);
}",0.9665809768637532
22219,"@Override public Multimap<String,AttributeModifier> getAttributeModifiersForExosuit(EntityEquipmentSlot armorSlot,ItemStack armorPieceStack){
  Multimap<String,AttributeModifier> map=HashMultimap.create();
  map.put(SharedMonsterAttributes.KNOCKBACK_RESISTANCE.getAttributeUnlocalizedName(),new AttributeModifier(new UUID(776437,armorSlot.getSlotIndex()),""String_Node_Str"" + armorSlot.getName(),0.25D,0));
  return map;
}","@Override public Multimap<String,AttributeModifier> getAttributeModifiersForExosuit(EntityEquipmentSlot armorSlot,ItemStack armorPieceStack){
  Multimap<String,AttributeModifier> map=HashMultimap.create();
  map.put(SharedMonsterAttributes.KNOCKBACK_RESISTANCE.getName(),new AttributeModifier(new UUID(776437,armorSlot.getSlotIndex()),""String_Node_Str"" + armorSlot.getName(),0.25D,0));
  return map;
}",0.975669099756691
22220,"@Override public void onPlayerHurt(LivingHurtEvent event,EntityPlayer victim,ItemStack armorStack,EntityEquipmentSlot slot){
  EntityLivingBase entity=event.getEntityLiving();
  float amount=event.getAmount();
  if (!INVALID_SOURCES.contains(event.getSource()) && ChargableUtility.hasPower(entity,Config.zincPlateConsumption)) {
    float health=victim.getHealth();
    float maxHealth=victim.getMaxHealth();
    float halfOfMax=maxHealth / 2;
    if (amount >= halfOfMax || health <= halfOfMax) {
      ItemStack zincPlates=new ItemStack(METAL_PLATE,2,ItemMetalPlate.Types.ZINC_PLATE.getMeta());
      World world=victim.worldObj;
      ChargableUtility.drainSteam(victim.getItemStackFromSlot(EntityEquipmentSlot.CHEST),Config.zincPlateConsumption,victim);
      UtilPlates.removePlate(armorStack);
      EntityItem entityItem=new EntityItem(world,victim.posX,victim.posY,victim.posZ,zincPlates);
      world.spawnEntityInWorld(entityItem);
      victim.setHealth(health);
      victim.performHurtAnimation();
      world.playSound(victim.posX,victim.posY,victim.posZ,EsteemedInnovation.SOUND_HISS,SoundCategory.PLAYERS,2F,0.9F,false);
      event.setCanceled(true);
    }
  }
}","@Override public void onPlayerHurt(LivingHurtEvent event,EntityPlayer victim,ItemStack armorStack,EntityEquipmentSlot slot){
  EntityLivingBase entity=event.getEntityLiving();
  float amount=event.getAmount();
  if (!INVALID_SOURCES.contains(event.getSource()) && ChargableUtility.hasPower(entity,Config.zincPlateConsumption)) {
    float health=victim.getHealth();
    float maxHealth=victim.getMaxHealth();
    float halfOfMax=maxHealth / 2;
    if (amount >= halfOfMax || health <= halfOfMax) {
      ItemStack zincPlates=new ItemStack(METAL_PLATE,2,ItemMetalPlate.Types.ZINC_PLATE.getMeta());
      World world=victim.world;
      ChargableUtility.drainSteam(victim.getItemStackFromSlot(EntityEquipmentSlot.CHEST),Config.zincPlateConsumption,victim);
      UtilPlates.removePlate(armorStack);
      EntityItem entityItem=new EntityItem(world,victim.posX,victim.posY,victim.posZ,zincPlates);
      world.spawnEntity(entityItem);
      victim.setHealth(health);
      victim.performHurtAnimation();
      world.playSound(victim.posX,victim.posY,victim.posZ,EsteemedInnovation.SOUND_HISS,SoundCategory.PLAYERS,2F,0.9F,false);
      event.setCanceled(true);
    }
  }
}",0.995741056218058
22221,"@Override @SideOnly(Side.CLIENT) public void getSubItems(Item item,CreativeTabs tabs,List<ItemStack> subItems){
  for (int i=0; i < ArmorModule.MAX_PLATE_META; i++) {
    subItems.add(ArmorModule.plateStack(i));
  }
}","@Override @SideOnly(Side.CLIENT) public void getSubItems(Item item,CreativeTabs tabs,NonNullList<ItemStack> subItems){
  for (int i=0; i < ArmorModule.MAX_PLATE_META; i++) {
    subItems.add(ArmorModule.plateStack(i));
  }
}",0.984126984126984
22222,"@Override public ItemStack decrStackSize(ItemStack me,int var1,int var2){
  if (getStackInSlot(me,var1) != null) {
    ItemStack itemstack;
    if (getStackInSlot(me,var1).stackSize <= var2) {
      itemstack=getStackInSlot(me,var1);
      setInventorySlotContents(me,var1,null);
      hasPlates(me);
      return itemstack;
    }
 else {
      ItemStack stack2=getStackInSlot(me,var1);
      itemstack=stack2.splitStack(var2);
      setInventorySlotContents(me,var1,stack2);
      if (getStackInSlot(me,var1).stackSize == 0) {
        setInventorySlotContents(me,var1,null);
      }
      hasPlates(me);
      return itemstack;
    }
  }
 else {
    return null;
  }
}","@Override public ItemStack decrStackSize(ItemStack me,int var1,int var2){
  if (getStackInSlot(me,var1) != null) {
    ItemStack itemstack;
    if (getStackInSlot(me,var1).getCount() <= var2) {
      itemstack=getStackInSlot(me,var1);
      setInventorySlotContents(me,var1,null);
      hasPlates(me);
      return itemstack;
    }
 else {
      ItemStack stack2=getStackInSlot(me,var1);
      itemstack=stack2.splitStack(var2);
      setInventorySlotContents(me,var1,stack2);
      if (getStackInSlot(me,var1).isEmpty()) {
        setInventorySlotContents(me,var1,null);
      }
      hasPlates(me);
      return itemstack;
    }
  }
 else {
    return null;
  }
}",0.9685157421289357
22223,"@Override public boolean canPutInSlot(ItemStack me,int slotNum,ItemStack upgrade){
  if (slotNum == 0) {
    ItemStack clone=upgrade.copy();
    clone.stackSize=1;
    return UtilPlates.getPlate(clone) != null;
  }
  if (upgrade.getItem() instanceof ExosuitUpgrade) {
    ExosuitUpgrade upgradeItem=(ExosuitUpgrade)upgrade.getItem();
    ExosuitSlot upgradeSlot=upgradeItem.getSlot();
    return (upgradeSlot.getArmorPiece() == armorType && upgradeSlot.getEngineeringSlot() == slotNum) || (upgradeItem.getSlot() == ExosuitSlot.VANITY && upgradeSlot.getEngineeringSlot() == slotNum);
  }
 else   if (slotNum == ExosuitSlot.VANITY.getEngineeringSlot()) {
    int[] ids=OreDictionary.getOreIDs(upgrade);
    for (    int id : ids) {
      String str=OreDictionary.getOreName(id);
      if (str.contains(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean canPutInSlot(ItemStack me,int slotNum,ItemStack upgrade){
  if (slotNum == 0) {
    ItemStack clone=upgrade.copy();
    clone.setCount(1);
    return UtilPlates.getPlate(clone) != null;
  }
  if (upgrade.getItem() instanceof ExosuitUpgrade) {
    ExosuitUpgrade upgradeItem=(ExosuitUpgrade)upgrade.getItem();
    ExosuitSlot upgradeSlot=upgradeItem.getSlot();
    return (upgradeSlot.getArmorPiece() == armorType && upgradeSlot.getEngineeringSlot() == slotNum) || (upgradeItem.getSlot() == ExosuitSlot.VANITY && upgradeSlot.getEngineeringSlot() == slotNum);
  }
 else   if (slotNum == ExosuitSlot.VANITY.getEngineeringSlot()) {
    int[] ids=OreDictionary.getOreIDs(upgrade);
    for (    int id : ids) {
      String str=OreDictionary.getOreName(id);
      if (str.contains(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}",0.989749430523918
22224,"@Override public int getArmorDisplay(EntityPlayer player,ItemStack armor,int slot){
  if (armor.hasTagCompound()) {
    if (armor.getTagCompound().hasKey(""String_Node_Str"")) {
      ExosuitPlate plate=UtilPlates.getPlate(armor.getTagCompound().getString(""String_Node_Str""));
      return plate.getDamageReductionAmount(armorType,DamageSource.generic);
    }
  }
  return ItemArmor.ArmorMaterial.LEATHER.getDamageReductionAmount(armorType);
}","@Override public int getArmorDisplay(EntityPlayer player,ItemStack armor,int slot){
  if (armor.hasTagCompound()) {
    if (armor.getTagCompound().hasKey(""String_Node_Str"")) {
      ExosuitPlate plate=UtilPlates.getPlate(armor.getTagCompound().getString(""String_Node_Str""));
      return plate.getDamageReductionAmount(armorType,DamageSource.GENERIC);
    }
  }
  return ItemArmor.ArmorMaterial.LEATHER.getDamageReductionAmount(armorType);
}",0.7868480725623582
22225,"@Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack me,EntityPlayer player,List<String> list,boolean advanced){
  super.addInformation(me,player,list,advanced);
  if (me.hasTagCompound()) {
    if (hasPlates(me) && !""String_Node_Str"".equals(UtilPlates.getPlate(me.getTagCompound().getString(""String_Node_Str"")).getIdentifier()) && !""String_Node_Str"".equals(UtilPlates.getPlate(me.getTagCompound().getString(""String_Node_Str"")).getIdentifier())) {
      list.add(TextFormatting.BLUE + UtilPlates.getPlate(me.getTagCompound().getString(""String_Node_Str"")).effect());
    }
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      for (int i=3; i < 10; i++) {
        if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
          ItemStack stack=ItemStack.loadItemStackFromNBT(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
          list.add(TextFormatting.RED + stack.getDisplayName());
        }
      }
    }
    if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(""String_Node_Str"")) {
      ItemStack stack=ItemStack.loadItemStackFromNBT(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(""String_Node_Str""));
      if (stack.getItem() == ArmorModule.ENDER_SHROUD) {
        list.add(TextFormatting.DARK_GREEN + I18n.format(""String_Node_Str""));
      }
 else {
        int dye=-1;
        int dyeIndex=ModelSteamExosuit.findDyeIndexFromItemStack(stack);
        if (dyeIndex != -1) {
          dye=dyeIndex;
        }
        if (dye != -1) {
          list.add(TextFormatting.DARK_GREEN + I18n.format(""String_Node_Str"" + ModelSteamExosuit.DYES[dye].toLowerCase()));
        }
 else {
          list.add(TextFormatting.DARK_GREEN + stack.getDisplayName());
        }
      }
    }
  }
  updateSteamNBT(me);
  if (armorType == EntityEquipmentSlot.CHEST) {
    list.add(TextFormatting.WHITE + ""String_Node_Str"" + me.getTagCompound().getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"" + me.getTagCompound().getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"");
  }
}","@Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack me,EntityPlayer player,List<String> list,boolean advanced){
  super.addInformation(me,player,list,advanced);
  if (me.hasTagCompound()) {
    if (hasPlates(me) && !""String_Node_Str"".equals(UtilPlates.getPlate(me.getTagCompound().getString(""String_Node_Str"")).getIdentifier()) && !""String_Node_Str"".equals(UtilPlates.getPlate(me.getTagCompound().getString(""String_Node_Str"")).getIdentifier())) {
      list.add(TextFormatting.BLUE + UtilPlates.getPlate(me.getTagCompound().getString(""String_Node_Str"")).effect());
    }
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      for (int i=3; i < 10; i++) {
        if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
          ItemStack stack=new ItemStack(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
          list.add(TextFormatting.RED + stack.getDisplayName());
        }
      }
    }
    if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(""String_Node_Str"")) {
      ItemStack stack=new ItemStack(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(""String_Node_Str""));
      if (stack.getItem() == ArmorModule.ENDER_SHROUD) {
        list.add(TextFormatting.DARK_GREEN + I18n.format(""String_Node_Str""));
      }
 else {
        int dye=-1;
        int dyeIndex=ModelSteamExosuit.findDyeIndexFromItemStack(stack);
        if (dyeIndex != -1) {
          dye=dyeIndex;
        }
        if (dye != -1) {
          list.add(TextFormatting.DARK_GREEN + I18n.format(""String_Node_Str"" + ModelSteamExosuit.DYES[dye].toLowerCase()));
        }
 else {
          list.add(TextFormatting.DARK_GREEN + stack.getDisplayName());
        }
      }
    }
  }
  updateSteamNBT(me);
  if (armorType == EntityEquipmentSlot.CHEST) {
    list.add(TextFormatting.WHITE + ""String_Node_Str"" + me.getTagCompound().getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"" + me.getTagCompound().getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"");
  }
}",0.9880439980870396
22226,"@Override public ItemStack getStackInSlot(ItemStack me,int var1){
  if (me.hasTagCompound()) {
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(var1))) {
        return ItemStack.loadItemStackFromNBT(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(var1)));
      }
    }
  }
  return null;
}","@Override public ItemStack getStackInSlot(ItemStack me,int var1){
  if (me.hasTagCompound()) {
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(var1))) {
        return new ItemStack(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(var1)));
      }
    }
  }
  return null;
}",0.9699879951980792
22227,"/** 
 * Gets whether the given armor has a tank upgrade.
 * @param me The ItemStack
 */
public boolean hasTank(ItemStack me){
  if (armorType != EntityEquipmentSlot.CHEST) {
    return false;
  }
  if (!me.hasTagCompound()) {
    return false;
  }
  if (!me.getTagCompound().hasKey(""String_Node_Str"")) {
    return false;
  }
  NBTTagCompound inv=me.getTagCompound().getCompoundTag(""String_Node_Str"");
  for (int i=1; i < 10; i++) {
    String s=Integer.toString(i);
    if (inv.hasKey(s)) {
      ItemStack stack=ItemStack.loadItemStackFromNBT(inv.getCompoundTag(s));
      if (stack != null && stack.getItem() != null && stack.getItem() instanceof ExosuitTank) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Gets whether the given armor has a tank upgrade.
 * @param me The ItemStack
 */
public boolean hasTank(ItemStack me){
  if (armorType != EntityEquipmentSlot.CHEST) {
    return false;
  }
  if (!me.hasTagCompound()) {
    return false;
  }
  if (!me.getTagCompound().hasKey(""String_Node_Str"")) {
    return false;
  }
  NBTTagCompound inv=me.getTagCompound().getCompoundTag(""String_Node_Str"");
  for (int i=1; i < 10; i++) {
    String s=Integer.toString(i);
    if (inv.hasKey(s)) {
      ItemStack stack=new ItemStack(inv.getCompoundTag(s));
      if (stack != null && stack.getItem() != null && stack.getItem() instanceof ExosuitTank) {
        return true;
      }
    }
  }
  return false;
}",0.9824561403508772
22228,"public boolean hasPlates(ItemStack me){
  if (getStackInSlot(me,1) != null) {
    if (!me.hasTagCompound()) {
      me.setTagCompound(new NBTTagCompound());
    }
    ItemStack clone=getStackInSlot(me,1).copy();
    clone.stackSize=1;
    if (UtilPlates.getPlate(clone) != null) {
      me.getTagCompound().setString(""String_Node_Str"",UtilPlates.getPlate(clone).getIdentifier());
      return true;
    }
 else {
      UtilPlates.removePlate(me);
      return false;
    }
  }
 else {
    if (!me.hasTagCompound()) {
      me.setTagCompound(new NBTTagCompound());
    }
    UtilPlates.removePlate(me);
    return false;
  }
}","public boolean hasPlates(ItemStack me){
  if (getStackInSlot(me,1) != null) {
    if (!me.hasTagCompound()) {
      me.setTagCompound(new NBTTagCompound());
    }
    ItemStack clone=getStackInSlot(me,1).copy();
    clone.setCount(1);
    if (UtilPlates.getPlate(clone) != null) {
      me.getTagCompound().setString(""String_Node_Str"",UtilPlates.getPlate(clone).getIdentifier());
      return true;
    }
 else {
      UtilPlates.removePlate(me);
      return false;
    }
  }
 else {
    if (!me.hasTagCompound()) {
      me.setTagCompound(new NBTTagCompound());
    }
    UtilPlates.removePlate(me);
    return false;
  }
}",0.9856
22229,"@Override @Nonnull public ExosuitUpgrade[] getUpgrades(ItemStack me){
  ArrayList<ExosuitUpgrade> upgrades=new ArrayList<>();
  if (me.hasTagCompound()) {
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      for (int i=2; i < 10; i++) {
        if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
          ItemStack stack=ItemStack.loadItemStackFromNBT(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
          if (stack.getItem() instanceof ExosuitUpgrade) {
            upgrades.add((ExosuitUpgrade)stack.getItem());
          }
        }
      }
    }
  }
  return upgrades.toArray(new ExosuitUpgrade[0]);
}","@Override @Nonnull public ExosuitUpgrade[] getUpgrades(ItemStack me){
  ArrayList<ExosuitUpgrade> upgrades=new ArrayList<>();
  if (me.hasTagCompound()) {
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      for (int i=2; i < 10; i++) {
        if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
          ItemStack stack=new ItemStack(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
          if (stack.getItem() instanceof ExosuitUpgrade) {
            upgrades.add((ExosuitUpgrade)stack.getItem());
          }
        }
      }
    }
  }
  return upgrades.toArray(new ExosuitUpgrade[0]);
}",0.98197548666186
22230,"@Override public boolean hasUpgrade(ItemStack me,Item check){
  if (me != null && check != null && me.hasTagCompound() && me.getTagCompound().hasKey(""String_Node_Str"")) {
    for (int i=1; i < 10; i++) {
      if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
        ItemStack stack=ItemStack.loadItemStackFromNBT(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
        if (stack.getItem() == check) {
          return true;
        }
      }
    }
  }
  return false;
}","@Override public boolean hasUpgrade(ItemStack me,Item check){
  if (me != null && check != null && me.hasTagCompound() && me.getTagCompound().hasKey(""String_Node_Str"")) {
    for (int i=1; i < 10; i++) {
      if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
        ItemStack stack=new ItemStack(me.getTagCompound().getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
        if (stack.getItem() == check) {
          return true;
        }
      }
    }
  }
  return false;
}",0.9605866177818516
22231,"private void hideCloakedPlayers(EntityLiving entity,EntityLivingBase target){
  if (target == null || !isInstalled(target)) {
    return;
  }
  IAttributeInstance iattributeinstance=entity.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
  double d0=(iattributeinstance == null ? 16.0D : iattributeinstance.getAttributeValue()) / 1.5D;
  List<Entity> list=entity.worldObj.getEntitiesWithinAABB(Entity.class,entity.getEntityBoundingBox().expand(d0,4.0D,d0));
  boolean foundPlayer=false;
  for (  Entity mob : list) {
    if (mob == target) {
      foundPlayer=true;
      break;
    }
  }
  if (!foundPlayer) {
    entity.setAttackTarget(null);
  }
}","private void hideCloakedPlayers(EntityLiving entity,EntityLivingBase target){
  if (target == null || !isInstalled(target)) {
    return;
  }
  IAttributeInstance iattributeinstance=entity.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE);
  double d0=(iattributeinstance == null ? 16.0D : iattributeinstance.getAttributeValue()) / 1.5D;
  List<Entity> list=entity.world.getEntitiesWithinAABB(Entity.class,entity.getEntityBoundingBox().expand(d0,4.0D,d0));
  boolean foundPlayer=false;
  for (  Entity mob : list) {
    if (mob == target) {
      foundPlayer=true;
      break;
    }
  }
  if (!foundPlayer) {
    entity.setAttackTarget(null);
  }
}",0.9977186311787072
22232,"@SideOnly(Side.CLIENT) @SubscribeEvent public void muffleSounds(PlaySoundEvent event){
  if (event.getName().contains(""String_Node_Str"")) {
    float x=event.getSound().getXPosF();
    float y=event.getSound().getYPosF();
    float z=event.getSound().getZPosF();
    List<EntityLivingBase> entities=Minecraft.getMinecraft().thePlayer.worldObj.getEntitiesWithinAABB(EntityLivingBase.class,new AxisAlignedBB(x - 0.5F,y - 0.5F,z - 0.5F,x + 0.5F,y + 0.5F,z + 0.5F));
    for (    EntityLivingBase entity : entities) {
      if (isInstalled(entity)) {
        event.setResultSound(null);
      }
    }
  }
}","@SideOnly(Side.CLIENT) @SubscribeEvent public void muffleSounds(PlaySoundEvent event){
  if (event.getName().contains(""String_Node_Str"")) {
    float x=event.getSound().getXPosF();
    float y=event.getSound().getYPosF();
    float z=event.getSound().getZPosF();
    List<EntityLivingBase> entities=Minecraft.getMinecraft().player.world.getEntitiesWithinAABB(EntityLivingBase.class,new AxisAlignedBB(x - 0.5F,y - 0.5F,z - 0.5F,x + 0.5F,y + 0.5F,z + 0.5F));
    for (    EntityLivingBase entity : entities) {
      if (isInstalled(entity)) {
        event.setResultSound(null);
      }
    }
  }
}",0.993322203672788
22233,"@Override public void onPlayerPickupItem(EntityItemPickupEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  EntityPlayer player=(EntityPlayer)event.getEntityLiving();
  if (player.worldObj.isRemote) {
    return;
  }
  if (ChargableUtility.hasPower(player,10)) {
    ItemStack item=event.getItem().getEntityItem();
    if (item.hasTagCompound() && item.getTagCompound().hasKey(""String_Node_Str"")) {
      return;
    }
    boolean isCannable=OreDictHelper.mapHasItem(OreDictHelper.ingots,item.getItem()) || OreDictHelper.mapHasItem(OreDictHelper.gems,item.getItem()) || OreDictHelper.listHasItem(OreDictHelper.nuggets,item.getItem());
    if (!isCannable) {
      return;
    }
    int numCans=0;
    for (int i=0; i < player.inventory.getSizeInventory(); i++) {
      ItemStack stackInSlot=player.inventory.getStackInSlot(i);
      if (stackInSlot != null && stackInSlot.getItem() == ITEM_CANISTER) {
        numCans+=stackInSlot.stackSize;
      }
    }
    if (numCans >= item.stackSize) {
      if (!item.hasTagCompound()) {
        item.setTagCompound(new NBTTagCompound());
      }
      item.getTagCompound().setInteger(""String_Node_Str"",0);
      for (int i=0; i < item.stackSize; i++) {
        eiteam.esteemedinnovation.api.util.InventoryUtility.consumeInventoryItem(player,ITEM_CANISTER);
        player.inventoryContainer.detectAndSendChanges();
      }
    }
 else     if (numCans != 0) {
      item.stackSize-=numCans;
      event.getItem().setEntityItemStack(item);
      ItemStack item2=item.copy();
      item2.stackSize=numCans;
      if (!item2.hasTagCompound()) {
        item2.setTagCompound(new NBTTagCompound());
      }
      item2.getTagCompound().setInteger(""String_Node_Str"",0);
      for (int i=0; i < numCans; i++) {
        eiteam.esteemedinnovation.api.util.InventoryUtility.consumeInventoryItem(player,ITEM_CANISTER);
        player.inventoryContainer.detectAndSendChanges();
      }
    }
  }
}","@Override public void onPlayerPickupItem(EntityItemPickupEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  EntityPlayer player=(EntityPlayer)event.getEntityLiving();
  if (player.world.isRemote) {
    return;
  }
  if (ChargableUtility.hasPower(player,10)) {
    ItemStack item=event.getItem().getItem();
    if (item.hasTagCompound() && item.getTagCompound().hasKey(""String_Node_Str"")) {
      return;
    }
    boolean isCannable=OreDictHelper.mapHasItem(OreDictHelper.ingots,item.getItem()) || OreDictHelper.mapHasItem(OreDictHelper.gems,item.getItem()) || OreDictHelper.listHasItem(OreDictHelper.nuggets,item.getItem());
    if (!isCannable) {
      return;
    }
    int numCans=0;
    for (int i=0; i < player.inventory.getSizeInventory(); i++) {
      ItemStack stackInSlot=player.inventory.getStackInSlot(i);
      if (stackInSlot != null && stackInSlot.getItem() == ITEM_CANISTER) {
        numCans+=stackInSlot.getCount();
      }
    }
    if (numCans >= item.getCount()) {
      if (!item.hasTagCompound()) {
        item.setTagCompound(new NBTTagCompound());
      }
      item.getTagCompound().setInteger(""String_Node_Str"",0);
      for (int i=0; i < item.getCount(); i++) {
        eiteam.esteemedinnovation.api.util.InventoryUtility.consumeInventoryItem(player,ITEM_CANISTER);
        player.inventoryContainer.detectAndSendChanges();
      }
    }
 else     if (numCans != 0) {
      item.shrink(numCans);
      event.getItem().setItem(item);
      ItemStack item2=item.copy();
      item2.setCount(numCans);
      if (!item2.hasTagCompound()) {
        item2.setTagCompound(new NBTTagCompound());
      }
      item2.getTagCompound().setInteger(""String_Node_Str"",0);
      for (int i=0; i < numCans; i++) {
        eiteam.esteemedinnovation.api.util.InventoryUtility.consumeInventoryItem(player,ITEM_CANISTER);
        player.inventoryContainer.detectAndSendChanges();
      }
    }
  }
}",0.9621369294605808
22234,"@Override public void onPlayerHurt(LivingHurtEvent event,EntityPlayer victim,ItemStack armorStack,EntityEquipmentSlot slot){
  if (event.getSource() == DamageSource.fall) {
    boolean hasPower=ChargableUtility.hasPower(event.getEntityLiving(),(int)(event.getAmount() / Config.fallAssistDivisor));
    if (hasPower) {
      if (event.getAmount() <= 6.0F) {
        event.setAmount(0F);
      }
      event.setAmount(event.getAmount() / 3F);
      ChargableUtility.drainSteam(victim.getItemStackFromSlot(EntityEquipmentSlot.CHEST),(int)(event.getAmount() / Config.fallAssistDivisor),victim);
      if (event.getAmount() == 0.0F) {
        event.setResult(Event.Result.DENY);
        event.setCanceled(true);
      }
    }
  }
}","@Override public void onPlayerHurt(LivingHurtEvent event,EntityPlayer victim,ItemStack armorStack,EntityEquipmentSlot slot){
  if (event.getSource() == DamageSource.FALL) {
    boolean hasPower=ChargableUtility.hasPower(event.getEntityLiving(),(int)(event.getAmount() / Config.fallAssistDivisor));
    if (hasPower) {
      if (event.getAmount() <= 6.0F) {
        event.setAmount(0F);
      }
      event.setAmount(event.getAmount() / 3F);
      ChargableUtility.drainSteam(victim.getItemStackFromSlot(EntityEquipmentSlot.CHEST),(int)(event.getAmount() / Config.fallAssistDivisor),victim);
      if (event.getAmount() == 0.0F) {
        event.setResult(Event.Result.DENY);
        event.setCanceled(true);
      }
    }
  }
}",0.9944903581267218
22235,"/** 
 * Gets the smasher output for the provided ItemStack.
 * @param input The input ItemStack
 * @param world The current world
 * @return The output ItemStacks.
 */
@Nonnull public static List<ItemStack> getOutput(ItemStack input,World world){
  if (input == null) {
    return Collections.emptyList();
  }
  List<ItemStack> output=new ArrayList<>();
  for (  Map.Entry<ItemStack,BiFunction<ItemStack,World,List<ItemStack>>> entry : registry.entrySet()) {
    if (ItemStack.areItemStacksEqual(entry.getKey(),input)) {
      output=entry.getValue().apply(input,world);
      if (!output.isEmpty()) {
        break;
      }
    }
  }
  return output.stream().map(ItemStack::copyItemStack).collect(Collectors.toList());
}","/** 
 * Gets the smasher output for the provided ItemStack.
 * @param input The input ItemStack
 * @param world The current world
 * @return The output ItemStacks.
 */
@Nonnull public static List<ItemStack> getOutput(ItemStack input,World world){
  if (input == null) {
    return Collections.emptyList();
  }
  List<ItemStack> output=new ArrayList<>();
  for (  Map.Entry<ItemStack,BiFunction<ItemStack,World,List<ItemStack>>> entry : registry.entrySet()) {
    if (ItemStack.areItemStacksEqual(entry.getKey(),input)) {
      output=entry.getValue().apply(input,world);
      if (!output.isEmpty()) {
        break;
      }
    }
  }
  return output.stream().map(ItemStack::copy).collect(Collectors.toList());
}",0.9937194696441032
22236,"public int getTicks(ItemStack[] stacks){
  return MathHelper.floor_double((Minecraft.getMinecraft().thePlayer.ticksExisted % (stacks.length * 20D)) / 20D);
}","public int getTicks(ItemStack[] stacks){
  return MathHelper.floor((Minecraft.getMinecraft().player.ticksExisted % (stacks.length * 20D)) / 20D);
}",0.9605263157894736
22237,"@Override public void renderPage(int x,int y,FontRenderer fontRenderer,GuiJournal book,RenderItem renderer,boolean isFirstPage,int mx,int my){
  book.getMC().getTextureManager().bindTexture(craftSquareTexture);
  ((Gui)book).drawTexturedModalRect(x + 45,y + 55,0,0,97,59);
  if (shapeless) {
    ((Gui)book).drawTexturedModalRect(x + 120,y + 60,100,0,17,13);
  }
  int maxX=3;
  int maxY=3;
  if (recipe != null && recipe[0] != null && recipe[0] instanceof ShapedOreRecipe) {
    maxX=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],4);
    maxY=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],5);
  }
  for (int i=0; i < maxY; i++) {
    for (int j=0; j < maxX; j++) {
      int index=(maxX * i) + j;
      if (inputs.length > index) {
        Object val=inputs[index];
        if (val != null) {
          if (val instanceof Item) {
            ItemStack item=new ItemStack((Item)val);
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack) {
            ItemStack item=(ItemStack)val;
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack[]) {
            ItemStack[] item=(ItemStack[])val;
            drawItemStackInPage(getStackFromTicks(item),fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof Collection && !((Collection)val).isEmpty()) {
            ArrayList<ItemStack> list2=new ArrayList<>();
            for (            Object obj : (Iterable)val) {
              if (obj instanceof ItemStack) {
                ItemStack item=(ItemStack)obj;
                if (item.getItemDamage() == OreDictionary.WILDCARD_VALUE) {
                  List<ItemStack> list=new ArrayList<>();
                  item.getItem().getSubItems(item.getItem(),null,list);
                  list2.addAll(list);
                }
 else {
                  list2.add(item);
                }
              }
            }
            ItemStack item=getStackFromTicks(list2.toArray(new ItemStack[list2.size()]));
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
        }
      }
    }
  }
  fontRenderer.setUnicodeFlag(false);
  drawItemStack(output,x + 45 + 76,y + 55 + 23,output.stackSize > 1 ? Integer.toString(output.stackSize) : ""String_Node_Str"",renderer,fontRenderer,false);
  fontRenderer.setUnicodeFlag(true);
  if (shapeless) {
    int ix=x + 120;
    int iy=y + 60;
    if (mx >= ix && mx <= ix + 17 && my >= iy && my <= iy + 13) {
      fontRenderer.setUnicodeFlag(false);
      book.renderText(""String_Node_Str"",mx,my);
      fontRenderer.setUnicodeFlag(true);
    }
  }
}","@Override public void renderPage(int x,int y,FontRenderer fontRenderer,GuiJournal book,RenderItem renderer,boolean isFirstPage,int mx,int my){
  book.getMC().getTextureManager().bindTexture(craftSquareTexture);
  ((Gui)book).drawTexturedModalRect(x + 45,y + 55,0,0,97,59);
  if (shapeless) {
    ((Gui)book).drawTexturedModalRect(x + 120,y + 60,100,0,17,13);
  }
  int maxX=3;
  int maxY=3;
  if (recipe != null && recipe[0] != null && recipe[0] instanceof ShapedOreRecipe) {
    maxX=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],4);
    maxY=ReflectionHelper.getPrivateValue(ShapedOreRecipe.class,(ShapedOreRecipe)recipe[0],5);
  }
  for (int i=0; i < maxY; i++) {
    for (int j=0; j < maxX; j++) {
      int index=(maxX * i) + j;
      if (inputs.length > index) {
        Object val=inputs[index];
        if (val != null) {
          if (val instanceof Item) {
            ItemStack item=new ItemStack((Item)val);
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack) {
            ItemStack item=(ItemStack)val;
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof ItemStack[]) {
            ItemStack[] item=(ItemStack[])val;
            drawItemStackInPage(getStackFromTicks(item),fontRenderer,x,j,y,i,renderer);
          }
          if (val instanceof Collection && !((Collection)val).isEmpty()) {
            ArrayList<ItemStack> list2=new ArrayList<>();
            for (            Object obj : (Iterable)val) {
              if (obj instanceof ItemStack) {
                ItemStack item=(ItemStack)obj;
                if (item.getItemDamage() == OreDictionary.WILDCARD_VALUE) {
                  NonNullList<ItemStack> list=NonNullList.create();
                  item.getItem().getSubItems(item.getItem(),CreativeTabs.SEARCH,list);
                  list2.addAll(list);
                }
 else {
                  list2.add(item);
                }
              }
            }
            ItemStack item=getStackFromTicks(list2.toArray(new ItemStack[list2.size()]));
            drawItemStackInPage(item,fontRenderer,x,j,y,i,renderer);
          }
        }
      }
    }
  }
  fontRenderer.setUnicodeFlag(false);
  drawItemStack(output,x + 45 + 76,y + 55 + 23,output.getCount() > 1 ? Integer.toString(output.getCount()) : ""String_Node_Str"",renderer,fontRenderer,false);
  fontRenderer.setUnicodeFlag(true);
  if (shapeless) {
    int ix=x + 120;
    int iy=y + 60;
    if (mx >= ix && mx <= ix + 17 && my >= iy && my <= iy + 13) {
      fontRenderer.setUnicodeFlag(false);
      book.renderText(""String_Node_Str"",mx,my);
      fontRenderer.setUnicodeFlag(true);
    }
  }
}",0.9585841999635104
22238,"@Override public void renderPage(int x,int y,FontRenderer fontRenderer,GuiJournal book,RenderItem renderer,boolean isFirstPage,int mx,int my){
  book.getMC().getTextureManager().bindTexture(craftSquareTexture);
  ((Gui)book).drawTexturedModalRect(x + 45,y + 65,0,146,97,59);
  fontRenderer.setUnicodeFlag(false);
  int ticks=getTicks(fluidItemRepresentation);
  drawItemStack(fluidItemRepresentation[ticks],x + 40 + 19+ 28,y + 65 + 14,liquidAmount > 1 ? Integer.toString(liquidAmount) : ""String_Node_Str"",renderer,fontRenderer,true);
  drawItemStack(inputItem,x + 43,y + 65 + 14,inputItem.stackSize > 1 ? Integer.toString(liquidAmount) : ""String_Node_Str"",renderer,fontRenderer,true);
  drawItemStack(resultItem,x + 40 + 90,y + 65 + 14,resultItem.stackSize > 1 ? Integer.toString(liquidAmount) : ""String_Node_Str"",renderer,fontRenderer,false);
  fontRenderer.setUnicodeFlag(true);
}","@Override public void renderPage(int x,int y,FontRenderer fontRenderer,GuiJournal book,RenderItem renderer,boolean isFirstPage,int mx,int my){
  book.getMC().getTextureManager().bindTexture(craftSquareTexture);
  ((Gui)book).drawTexturedModalRect(x + 45,y + 65,0,146,97,59);
  fontRenderer.setUnicodeFlag(false);
  int ticks=getTicks(fluidItemRepresentation);
  drawItemStack(fluidItemRepresentation[ticks],x + 40 + 19+ 28,y + 65 + 14,liquidAmount > 1 ? Integer.toString(liquidAmount) : ""String_Node_Str"",renderer,fontRenderer,true);
  drawItemStack(inputItem,x + 43,y + 65 + 14,inputItem.getCount() > 1 ? Integer.toString(liquidAmount) : ""String_Node_Str"",renderer,fontRenderer,true);
  drawItemStack(resultItem,x + 40 + 90,y + 65 + 14,resultItem.getCount() > 1 ? Integer.toString(liquidAmount) : ""String_Node_Str"",renderer,fontRenderer,false);
  fontRenderer.setUnicodeFlag(true);
}",0.9784824462061156
22239,"/** 
 * Registers a Crucible melting recipe for a tool.
 * @param item The input item.
 * @param liquid The output liquid.
 * @param m The amount of liquid.
 */
public static void registerMeltRecipeTool(Item item,CrucibleLiquid liquid,int m){
  for (int i=0; i < item.getMaxDamage(); i++) {
    liquidRecipes.put(Pair.of(item,i),Pair.of(liquid,MathHelper.floor_double(m * ((float)(item.getMaxDamage() - i) / (float)item.getMaxDamage()))));
  }
}","/** 
 * Registers a Crucible melting recipe for a tool.
 * @param item The input item.
 * @param liquid The output liquid.
 * @param m The amount of liquid.
 */
public static void registerMeltRecipeTool(Item item,CrucibleLiquid liquid,int m){
  for (int i=0; i < item.getMaxDamage(); i++) {
    liquidRecipes.put(Pair.of(item,i),Pair.of(liquid,MathHelper.floor(m * ((float)(item.getMaxDamage() - i) / (float)item.getMaxDamage()))));
  }
}",0.9920724801812004
22240,"@Override public void setThrowableHeading(double x,double y,double z,float velocity,float inaccuracy){
  float var9=MathHelper.sqrt_double(x * x + y * y + z * z);
  x/=(double)var9;
  y/=(double)var9;
  z/=(double)var9;
  x+=this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
  y+=this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
  z+=this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
  x*=(double)velocity;
  y*=(double)velocity;
  z*=(double)velocity;
  this.motionX=x;
  this.motionY=y;
  this.motionZ=z;
  float var10=MathHelper.sqrt_double(x * x + z * z);
  this.prevRotationYaw=this.rotationYaw=(float)(Math.atan2(x,z) * 180.0D / Math.PI);
  this.prevRotationPitch=this.rotationPitch=(float)(Math.atan2(y,(double)var10) * 180.0D / Math.PI);
  this.ticksInGround=0;
}","@Override public void setThrowableHeading(double x,double y,double z,float velocity,float inaccuracy){
  float var9=MathHelper.sqrt(x * x + y * y + z * z);
  x/=(double)var9;
  y/=(double)var9;
  z/=(double)var9;
  x+=this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
  y+=this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
  z+=this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
  x*=(double)velocity;
  y*=(double)velocity;
  z*=(double)velocity;
  this.motionX=x;
  this.motionY=y;
  this.motionZ=z;
  float var10=MathHelper.sqrt(x * x + z * z);
  this.prevRotationYaw=this.rotationYaw=(float)(Math.atan2(x,z) * 180.0D / Math.PI);
  this.prevRotationPitch=this.rotationPitch=(float)(Math.atan2(y,(double)var10) * 180.0D / Math.PI);
  this.ticksInGround=0;
}",0.9915458937198068
22241,"@Override @SideOnly(Side.CLIENT) public void setVelocity(double x,double y,double z){
  motionX=x;
  motionY=y;
  motionZ=z;
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var7=MathHelper.sqrt_double(x * x + z * z);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(x,z) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(y,(double)var7) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch;
    prevRotationYaw=rotationYaw;
    setLocationAndAngles(posX,posY,posZ,rotationYaw,rotationPitch);
    ticksInGround=0;
  }
}","@Override @SideOnly(Side.CLIENT) public void setVelocity(double x,double y,double z){
  motionX=x;
  motionY=y;
  motionZ=z;
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var7=MathHelper.sqrt(x * x + z * z);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(x,z) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(y,(double)var7) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch;
    prevRotationYaw=rotationYaw;
    setLocationAndAngles(posX,posY,posZ,rotationYaw,rotationPitch);
    ticksInGround=0;
  }
}",0.5153374233128835
22242,"@Override public void onUpdate(){
  super.onUpdate();
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var1=MathHelper.sqrt_double(motionX * motionX + motionZ * motionZ);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(motionY,(double)var1) * 180.0D / Math.PI);
  }
  IBlockState state=worldObj.getBlockState(tilePos);
  Block block=state.getBlock();
  if (block != null) {
    if (state.getMaterial() != Material.AIR) {
      AxisAlignedBB aabb=block.getCollisionBoundingBox(state,worldObj,tilePos);
      if (aabb != null && aabb.isVecInside(new Vec3d(posX,posY,posZ))) {
        inGround=true;
      }
    }
  }
  if (arrowShake > 0) {
    --arrowShake;
  }
  if (inGround && block != null) {
    int meta=block.getMetaFromState(state);
    if (block == inTile && meta == inData) {
      ++ticksInGround;
      if (ticksInGround == 1200) {
        setDead();
      }
    }
 else {
      inGround=false;
      motionX*=(double)(rand.nextFloat() * 0.2F);
      motionY*=(double)(rand.nextFloat() * 0.2F);
      motionZ*=(double)(rand.nextFloat() * 0.2F);
      ticksInGround=0;
      ticksInAir=0;
    }
  }
 else {
    ++ticksInAir;
    Vec3d posVec=new Vec3d(posX,posY,posZ);
    Vec3d motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    RayTraceResult rayTraceResult=worldObj.rayTraceBlocks(posVec,motionVec,false,true,false);
    posVec=new Vec3d(posX,posY,posZ);
    motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (rayTraceResult != null) {
      motionVec=rayTraceResult.hitVec;
    }
    Entity entity=null;
    List<Entity> entities=worldObj.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().addCoord(motionX,motionY,motionZ).expand(1.0D,1.0D,1.0D));
    double d1=0.0D;
    float f1=0.3F;
    for (    Entity entity1 : entities) {
      if (entity1.canBeCollidedWith() && (entity1 != shootingEntity || ticksInAir >= 5)) {
        AxisAlignedBB aabb=entity1.getEntityBoundingBox().expand((double)f1,(double)f1,(double)f1);
        RayTraceResult intercept=aabb.calculateIntercept(posVec,motionVec);
        if (intercept != null) {
          double distanceTo=posVec.distanceTo(intercept.hitVec);
          if (distanceTo < d1 || d1 == 0.0D) {
            entity=entity1;
            d1=distanceTo;
          }
        }
      }
    }
    if (entity != null) {
      rayTraceResult=new RayTraceResult(entity);
    }
    if (rayTraceResult != null) {
      if (rayTraceResult.entityHit != null) {
        int damage=(int)this.damage;
        DamageSource source;
        if (shootingEntity == null || silenced) {
          source=DamageSource.causeThrownDamage(this,this);
        }
 else {
          source=DamageSource.causeThrownDamage(this,shootingEntity);
        }
        if (isBurning() && !(rayTraceResult.entityHit instanceof EntityEnderman)) {
          rayTraceResult.entityHit.setFire(5);
        }
        if (rayTraceResult.entityHit.attackEntityFrom(source,damage)) {
          if (rayTraceResult.entityHit instanceof EntityLiving) {
            EntityLiving entityHit=(EntityLiving)rayTraceResult.entityHit;
            if (!worldObj.isRemote) {
              entityHit.setArrowCountInEntity(entityHit.getArrowCountInEntity() + 1);
            }
          }
          if (!(rayTraceResult.entityHit instanceof EntityEnderman)) {
            setDead();
          }
        }
 else {
          motionX*=-0.10000000149011612D;
          motionY*=-0.10000000149011612D;
          motionZ*=-0.10000000149011612D;
          rotationYaw+=180.0F;
          prevRotationYaw+=180.0F;
          ticksInAir=0;
        }
      }
 else {
        tilePos=rayTraceResult.getBlockPos();
        IBlockState inState=worldObj.getBlockState(tilePos);
        inTile=inState.getBlock();
        inData=inTile.getMetaFromState(inState);
        motionX=(double)((float)(rayTraceResult.hitVec.xCoord - posX));
        motionY=(double)((float)(rayTraceResult.hitVec.yCoord - posY));
        motionZ=(double)((float)(rayTraceResult.hitVec.zCoord - posZ));
        float root=MathHelper.sqrt_double(motionX * motionX + motionY * motionY + motionZ * motionZ);
        posX-=motionX / (double)root * 0.05000000074505806D;
        posY-=motionY / (double)root * 0.05000000074505806D;
        posZ-=motionZ / (double)root * 0.05000000074505806D;
        inGround=true;
        arrowShake=7;
        if (inTile != null) {
          inTile.onEntityCollidedWithBlock(worldObj,tilePos,inState,this);
        }
      }
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    float f3=0.99F;
    f1=0.05F;
    if (this.isInWater()) {
      double f2=0.25D;
      for (int i=0; i < 4; ++i) {
        worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f2,posY - motionY * f2,posZ - motionZ * f2,motionX,motionY,motionZ);
      }
      f3=0.8F;
    }
    motionX*=(double)f3;
    motionY*=(double)f3;
    motionZ*=(double)f3;
    motionY-=(double)f1;
    setPosition(posX,posY,posZ);
  }
}","@Override public void onUpdate(){
  super.onUpdate();
  if (prevRotationPitch == 0.0F && prevRotationYaw == 0.0F) {
    float var1=MathHelper.sqrt(motionX * motionX + motionZ * motionZ);
    prevRotationYaw=rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    prevRotationPitch=rotationPitch=(float)(Math.atan2(motionY,(double)var1) * 180.0D / Math.PI);
  }
  IBlockState state=world.getBlockState(tilePos);
  Block block=state.getBlock();
  if (block != null) {
    if (state.getMaterial() != Material.AIR) {
      AxisAlignedBB aabb=block.getCollisionBoundingBox(state,world,tilePos);
      if (aabb != null && aabb.contains(new Vec3d(posX,posY,posZ))) {
        inGround=true;
      }
    }
  }
  if (arrowShake > 0) {
    --arrowShake;
  }
  if (inGround && block != null) {
    int meta=block.getMetaFromState(state);
    if (block == inTile && meta == inData) {
      ++ticksInGround;
      if (ticksInGround == 1200) {
        setDead();
      }
    }
 else {
      inGround=false;
      motionX*=(double)(rand.nextFloat() * 0.2F);
      motionY*=(double)(rand.nextFloat() * 0.2F);
      motionZ*=(double)(rand.nextFloat() * 0.2F);
      ticksInGround=0;
      ticksInAir=0;
    }
  }
 else {
    ++ticksInAir;
    Vec3d posVec=new Vec3d(posX,posY,posZ);
    Vec3d motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    RayTraceResult rayTraceResult=world.rayTraceBlocks(posVec,motionVec,false,true,false);
    posVec=new Vec3d(posX,posY,posZ);
    motionVec=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (rayTraceResult != null) {
      motionVec=rayTraceResult.hitVec;
    }
    Entity entity=null;
    List<Entity> entities=world.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().grow(motionX,motionY,motionZ).expand(1.0D,1.0D,1.0D));
    double d1=0.0D;
    float f1=0.3F;
    for (    Entity entity1 : entities) {
      if (entity1.canBeCollidedWith() && (entity1 != shootingEntity || ticksInAir >= 5)) {
        AxisAlignedBB aabb=entity1.getEntityBoundingBox().expand((double)f1,(double)f1,(double)f1);
        RayTraceResult intercept=aabb.calculateIntercept(posVec,motionVec);
        if (intercept != null) {
          double distanceTo=posVec.distanceTo(intercept.hitVec);
          if (distanceTo < d1 || d1 == 0.0D) {
            entity=entity1;
            d1=distanceTo;
          }
        }
      }
    }
    if (entity != null) {
      rayTraceResult=new RayTraceResult(entity);
    }
    if (rayTraceResult != null) {
      if (rayTraceResult.entityHit != null) {
        int damage=(int)this.damage;
        DamageSource source;
        if (shootingEntity == null || silenced) {
          source=DamageSource.causeThrownDamage(this,this);
        }
 else {
          source=DamageSource.causeThrownDamage(this,shootingEntity);
        }
        if (isBurning() && !(rayTraceResult.entityHit instanceof EntityEnderman)) {
          rayTraceResult.entityHit.setFire(5);
        }
        if (rayTraceResult.entityHit.attackEntityFrom(source,damage)) {
          if (rayTraceResult.entityHit instanceof EntityLiving) {
            EntityLiving entityHit=(EntityLiving)rayTraceResult.entityHit;
            if (!world.isRemote) {
              entityHit.setArrowCountInEntity(entityHit.getArrowCountInEntity() + 1);
            }
          }
          if (!(rayTraceResult.entityHit instanceof EntityEnderman)) {
            setDead();
          }
        }
 else {
          motionX*=-0.10000000149011612D;
          motionY*=-0.10000000149011612D;
          motionZ*=-0.10000000149011612D;
          rotationYaw+=180.0F;
          prevRotationYaw+=180.0F;
          ticksInAir=0;
        }
      }
 else {
        tilePos=rayTraceResult.getBlockPos();
        IBlockState inState=world.getBlockState(tilePos);
        inTile=inState.getBlock();
        inData=inTile.getMetaFromState(inState);
        motionX=(double)((float)(rayTraceResult.hitVec.x - posX));
        motionY=(double)((float)(rayTraceResult.hitVec.y - posY));
        motionZ=(double)((float)(rayTraceResult.hitVec.z - posZ));
        float root=MathHelper.sqrt(motionX * motionX + motionY * motionY + motionZ * motionZ);
        posX-=motionX / (double)root * 0.05000000074505806D;
        posY-=motionY / (double)root * 0.05000000074505806D;
        posZ-=motionZ / (double)root * 0.05000000074505806D;
        inGround=true;
        arrowShake=7;
        if (inTile != null) {
          inTile.onEntityCollidedWithBlock(world,tilePos,inState,this);
        }
      }
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionX,motionZ) * 180.0D / Math.PI);
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    float f3=0.99F;
    f1=0.05F;
    if (this.isInWater()) {
      double f2=0.25D;
      for (int i=0; i < 4; ++i) {
        world.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f2,posY - motionY * f2,posZ - motionZ * f2,motionX,motionY,motionZ);
      }
      f3=0.8F;
    }
    motionX*=(double)f3;
    motionY*=(double)f3;
    motionZ*=(double)f3;
    motionY-=(double)f1;
    setPosition(posX,posY,posZ);
  }
}",0.992451473759885
22243,"public EntityRocket(World world,EntityPlayer player,float par4,float size){
  super(world);
  inputParam4=par4;
  shootingEntity=player;
  explosionSize=size;
  setSize(0.25F,0.25F);
  setLocationAndAngles(player.posX,player.posY + (double)player.getEyeHeight(),player.posZ,player.rotationYaw + ((itemRand.nextFloat() - 0.5F) * par4 * 15F),player.rotationPitch + ((itemRand.nextFloat() - 0.5F) * par4 * 15F));
  setPosition(this.posX,this.posY,this.posZ);
  posX-=1.0D * (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  posZ-=1.0D * (double)(MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  motionX=motionY=motionZ=0.0D;
  double p_i1760_8_=player.getLookVec().xCoord;
  double p_i1760_10_=player.getLookVec().yCoord;
  double p_i1760_12_=player.getLookVec().zCoord;
  double d6=(double)MathHelper.sqrt_double(p_i1760_8_ * p_i1760_8_ + p_i1760_10_ * p_i1760_10_ + p_i1760_12_ * p_i1760_12_);
  motionX=p_i1760_8_ / d6 * 1.0D;
  motionY=p_i1760_10_ / d6 * 1.0D;
  motionZ=p_i1760_12_ / d6 * 1.0D;
  displayRotationYaw=rotationYaw;
  float f3=MathHelper.sqrt_double(motionX * motionX + motionZ * motionZ);
  displayRotationPitch=(float)(Math.atan2(motionY,(double)f3) * 180.0D / Math.PI);
}","public EntityRocket(World world,EntityPlayer player,float par4,float size){
  super(world);
  inputParam4=par4;
  shootingEntity=player;
  explosionSize=size;
  setSize(0.25F,0.25F);
  setLocationAndAngles(player.posX,player.posY + (double)player.getEyeHeight(),player.posZ,player.rotationYaw + ((itemRand.nextFloat() - 0.5F) * par4 * 15F),player.rotationPitch + ((itemRand.nextFloat() - 0.5F) * par4 * 15F));
  setPosition(this.posX,this.posY,this.posZ);
  posX-=1.0D * (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  posZ-=1.0D * (double)(MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
  motionX=motionY=motionZ=0.0D;
  double p_i1760_8_=player.getLookVec().x;
  double p_i1760_10_=player.getLookVec().y;
  double p_i1760_12_=player.getLookVec().z;
  double d6=(double)MathHelper.sqrt(p_i1760_8_ * p_i1760_8_ + p_i1760_10_ * p_i1760_10_ + p_i1760_12_ * p_i1760_12_);
  motionX=p_i1760_8_ / d6 * 1.0D;
  motionY=p_i1760_10_ / d6 * 1.0D;
  motionZ=p_i1760_12_ / d6 * 1.0D;
  displayRotationYaw=rotationYaw;
  float f3=MathHelper.sqrt(motionX * motionX + motionZ * motionZ);
  displayRotationPitch=(float)(Math.atan2(motionY,(double)f3) * 180.0D / Math.PI);
}",0.7109661638809621
22244,"protected void onImpact(){
  if (!this.worldObj.isRemote) {
    newExplosion(worldObj,shootingEntity,posX,posY,posZ,explosionSize,true,worldObj.getGameRules().getBoolean(""String_Node_Str""));
    this.setDead();
  }
}","protected void onImpact(){
  if (!this.world.isRemote) {
    newExplosion(world,shootingEntity,posX,posY,posZ,explosionSize,true,world.getGameRules().getBoolean(""String_Node_Str""));
    this.setDead();
  }
}",0.9787234042553192
22245,"@Override public boolean attackEntityFrom(DamageSource source,float amount){
  if (isEntityInvulnerable(source)) {
    return false;
  }
 else {
    setBeenAttacked();
    Entity entity=source.getEntity();
    if (entity != null) {
      Vec3d vec3=entity.getLookVec();
      motionX=vec3.xCoord;
      motionY=vec3.yCoord;
      motionZ=vec3.zCoord;
      if (entity instanceof EntityLivingBase) {
        shootingEntity=(EntityLivingBase)entity;
      }
      return true;
    }
 else {
      return false;
    }
  }
}","@Override public boolean attackEntityFrom(DamageSource source,float amount){
  if (isEntityInvulnerable(source)) {
    return false;
  }
 else {
    setBeenAttacked();
    Entity entity=source.getTrueSource();
    if (entity != null) {
      Vec3d vec3=entity.getLookVec();
      motionX=vec3.x;
      motionY=vec3.y;
      motionZ=vec3.z;
      if (entity instanceof EntityLivingBase) {
        shootingEntity=(EntityLivingBase)entity;
      }
      return true;
    }
 else {
      return false;
    }
  }
}",0.9698736637512148
22246,"@Override public void onUpdate(){
  IBlockState state=worldObj.getBlockState(getPosition());
  Block block=worldObj.getBlockState(getPosition()).getBlock();
  if (!worldObj.isRemote && (shootingEntity != null && shootingEntity.isDead || (block.isAir(state,worldObj,getPosition())))) {
    setDead();
  }
 else {
    super.onUpdate();
    if (inGround) {
      if (worldObj.getBlockState(new BlockPos(x,y,z)) == blockInside) {
        ++ticksAlive;
        if (ticksAlive == 200) {
          setDead();
        }
        return;
      }
      ++ticksAlive;
      if (ticksAlive >= 200) {
        setDead();
      }
      motionX=0;
      motionY=0;
      motionZ=0;
      ticksAlive=0;
      ticksInAir=0;
    }
 else {
      ++ticksInAir;
    }
    Vec3d vec3=new Vec3d(posX,posY,posZ);
    Vec3d vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionY);
    RayTraceResult trace=this.worldObj.rayTraceBlocks(vec3,vec31,false,true,false);
    vec3=new Vec3d(posX,posY,posZ);
    vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (trace != null) {
      vec31=trace.hitVec;
    }
    Entity entity=null;
    List<Entity> list=worldObj.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().addCoord(motionX,motionY,motionZ).expand(0.5D,0.5D,0.5D));
    double d0=0.0D;
    for (    Entity entity1 : list) {
      if (entity1.canBeCollidedWith() && (!entity1.isEntityEqual(shootingEntity) || this.ticksInAir >= 25)) {
        float f=0.3F;
        AxisAlignedBB axisalignedbb=entity1.getEntityBoundingBox().expand((double)f,(double)f,(double)f);
        RayTraceResult trace1=axisalignedbb.calculateIntercept(vec3,vec31);
        if (trace1 != null) {
          double d1=vec3.distanceTo(trace1.hitVec);
          if (d1 < d0 || d0 == 0.0D) {
            entity=entity1;
            d0=d1;
          }
        }
      }
    }
    if (entity != null) {
      trace=new RayTraceResult(entity);
    }
    if (trace != null) {
      this.onImpact();
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionZ,motionX) * 180.0D / Math.PI) + 90.0F;
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    if (isInWater()) {
      for (int j=0; j < 4; ++j) {
        double f3=0.25D;
        worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f3,posY - motionY * f3,posZ - motionZ * f3,motionX,motionY,motionZ);
      }
    }
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 3F,posY - motionY * 3F,posZ - motionZ * 3F,0D,0D,0D);
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 1.5F,posY - motionY * 1.5F,posZ - motionZ * 1.5F,0D,0D,0D);
    setPosition(posX,posY,posZ);
  }
}","@Override public void onUpdate(){
  IBlockState state=world.getBlockState(getPosition());
  Block block=world.getBlockState(getPosition()).getBlock();
  if (!world.isRemote && (shootingEntity != null && shootingEntity.isDead || (block.isAir(state,world,getPosition())))) {
    setDead();
  }
 else {
    super.onUpdate();
    if (inGround) {
      if (world.getBlockState(new BlockPos(x,y,z)) == blockInside) {
        ++ticksAlive;
        if (ticksAlive == 200) {
          setDead();
        }
        return;
      }
      ++ticksAlive;
      if (ticksAlive >= 200) {
        setDead();
      }
      motionX=0;
      motionY=0;
      motionZ=0;
      ticksAlive=0;
      ticksInAir=0;
    }
 else {
      ++ticksInAir;
    }
    Vec3d vec3=new Vec3d(posX,posY,posZ);
    Vec3d vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionY);
    RayTraceResult trace=this.world.rayTraceBlocks(vec3,vec31,false,true,false);
    vec3=new Vec3d(posX,posY,posZ);
    vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (trace != null) {
      vec31=trace.hitVec;
    }
    Entity entity=null;
    List<Entity> list=world.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().grow(motionX,motionY,motionZ).expand(0.5D,0.5D,0.5D));
    double d0=0.0D;
    for (    Entity entity1 : list) {
      if (entity1.canBeCollidedWith() && (!entity1.isEntityEqual(shootingEntity) || this.ticksInAir >= 25)) {
        float f=0.3F;
        AxisAlignedBB axisalignedbb=entity1.getEntityBoundingBox().expand((double)f,(double)f,(double)f);
        RayTraceResult trace1=axisalignedbb.calculateIntercept(vec3,vec31);
        if (trace1 != null) {
          double d1=vec3.distanceTo(trace1.hitVec);
          if (d1 < d0 || d0 == 0.0D) {
            entity=entity1;
            d0=d1;
          }
        }
      }
    }
    if (entity != null) {
      trace=new RayTraceResult(entity);
    }
    if (trace != null) {
      this.onImpact();
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionZ,motionX) * 180.0D / Math.PI) + 90.0F;
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    if (isInWater()) {
      for (int j=0; j < 4; ++j) {
        double f3=0.25D;
        world.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f3,posY - motionY * f3,posZ - motionZ * f3,motionX,motionY,motionZ);
      }
    }
    world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 3F,posY - motionY * 3F,posZ - motionZ * 3F,0D,0D,0D);
    world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 1.5F,posY - motionY * 1.5F,posZ - motionZ * 1.5F,0D,0D,0D);
    setPosition(posX,posY,posZ);
  }
}",0.9931972789115646
22247,"/** 
 * @see ExosuitUpgrade#getAttributeModifiersForExosuit(EntityEquipmentSlot,ItemStack)
 */
public Multimap<String,AttributeModifier> getAttributeModifiersForExosuit(EntityEquipmentSlot armorSlot,ItemStack armorPieceStack){
  return HashMultimap.create();
}","/** 
 * @see ExosuitUpgrade#getAttributeModifiersForExosuit(EntityEquipmentSlot,ItemStack)
 */
public Multimap<String,AttributeModifier> getAttributeModifiersForExosuit(EntityEquipmentSlot armorSlot,@Nonnull ItemStack armorPieceStack){
  return HashMultimap.create();
}",0.9829867674858224
22248,"@Override public boolean getIsRepairable(ItemStack toRepair,ItemStack repair){
  if (repairMaterial instanceof ItemStack) {
    return repair.isItemEqual((ItemStack)repairMaterial) || super.getIsRepairable(toRepair,repair);
  }
  if (repairMaterial instanceof String) {
    return ItemStackUtility.isItemOreDictedAs(repair,(String)repairMaterial) || super.getIsRepairable(toRepair,repair);
  }
  return super.getIsRepairable(toRepair,repair);
}","@Override public boolean getIsRepairable(ItemStack toRepair,@Nullable ItemStack repair){
  if (repairMaterial instanceof ItemStack && repair != null) {
    return repair.isItemEqual((ItemStack)repairMaterial) || super.getIsRepairable(toRepair,repair);
  }
  if (repairMaterial instanceof String) {
    return ItemStackUtility.isItemOreDictedAs(repair,(String)repairMaterial) || super.getIsRepairable(toRepair,repair);
  }
  return super.getIsRepairable(toRepair,repair);
}",0.9694323144104804
22249,"@Override public void updateModel(ModelBiped parentModel,EntityLivingBase entityLivingBase,ItemStack itemStack,ModelExosuitUpgrade modelExosuitUpgrade){
}","@Override public void updateModel(ModelBiped parentModel,EntityLivingBase entityLivingBase,@Nonnull ItemStack itemStack,ModelExosuitUpgrade modelExosuitUpgrade){
}",0.9716088328075708
22250,"@SubscribeEvent @SideOnly(Side.CLIENT) public void onPlayerTick(TickEvent.ClientTickEvent event){
  Minecraft mc=Minecraft.getMinecraft();
  if (event.side == Side.CLIENT && mc.player != null) {
    if (event.phase == TickEvent.Phase.START) {
      return;
    }
    for (    EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
      ItemStack armorStack=mc.player.getItemStackFromSlot(slot);
      if (armorStack != null && armorType.isAssignableFrom(armorStack.getItem().getClass())) {
        getModel(mc.player,slot).updateModel(mc.player,armorStack,slot);
      }
    }
  }
}","@SubscribeEvent @SideOnly(Side.CLIENT) public void onPlayerTick(TickEvent.ClientTickEvent event){
  Minecraft mc=Minecraft.getMinecraft();
  if (event.side == Side.CLIENT && mc.player != null) {
    if (event.phase == TickEvent.Phase.START) {
      return;
    }
    for (    EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
      ItemStack armorStack=mc.player.getItemStackFromSlot(slot);
      if (armorType.isAssignableFrom(armorStack.getItem().getClass())) {
        getModel(mc.player,slot).updateModel(mc.player,armorStack,slot);
      }
    }
  }
}",0.796875
22251,"@Override public ItemStack decrStackSize(ItemStack me,int slot,int size){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    ItemStack toBeRemoved=new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
    me.getTagCompound().removeTag(""String_Node_Str"");
    return toBeRemoved;
  }
  return null;
}","@Nonnull @Override public ItemStack decrStackSize(@Nonnull ItemStack me,int slot,int size){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    ItemStack toBeRemoved=new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
    me.getTagCompound().removeTag(""String_Node_Str"");
    return toBeRemoved;
  }
  return ItemStack.EMPTY;
}",0.945668135095448
22252,"@Override public ArmorProperties getProperties(EntityLivingBase player,ItemStack armor,DamageSource source,double damage,int slot){
  return null;
}","@Override public ArmorProperties getProperties(EntityLivingBase player,@Nonnull ItemStack armor,DamageSource source,double damage,int slot){
  return null;
}",0.9704918032786886
22253,"@Override public ItemStack getStackInSlot(ItemStack me,int slot){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    return new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
  }
  return null;
}","@Nonnull @Override public ItemStack getStackInSlot(@Nonnull ItemStack me,int slot){
  NBTTagCompound plateNBT=getPlateNBT(me);
  if (plateNBT != null) {
    return new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
  }
  return ItemStack.EMPTY;
}",0.9227557411273486
22254,"@Override public void setInventorySlotContents(ItemStack me,int slot,ItemStack stack){
  if (stack == null && me.hasTagCompound()) {
    me.getTagCompound().removeTag(""String_Node_Str"");
    return;
  }
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  ExosuitPlate plate=UtilPlates.getPlate(stack);
  if (plate != null) {
    NBTTagCompound plateNBT=new NBTTagCompound();
    plateNBT.setString(""String_Node_Str"",plate.getIdentifier());
    plateNBT.setTag(""String_Node_Str"",stack.writeToNBT(new NBTTagCompound()));
    me.getTagCompound().setTag(""String_Node_Str"",plateNBT);
  }
}","@Override public void setInventorySlotContents(@Nonnull ItemStack me,int slot,@Nonnull ItemStack stack){
  if (stack.isEmpty() && me.hasTagCompound()) {
    me.getTagCompound().removeTag(""String_Node_Str"");
    return;
  }
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  ExosuitPlate plate=UtilPlates.getPlate(stack);
  if (plate != null) {
    NBTTagCompound plateNBT=new NBTTagCompound();
    plateNBT.setString(""String_Node_Str"",plate.getIdentifier());
    plateNBT.setTag(""String_Node_Str"",stack.writeToNBT(new NBTTagCompound()));
    me.getTagCompound().setTag(""String_Node_Str"",plateNBT);
  }
}",0.971107544141252
22255,"@Override public boolean canPutInSlot(ItemStack me,int slotNum,ItemStack upgrade){
  return UtilPlates.getPlate(upgrade) != null;
}","@Override public boolean canPutInSlot(@Nonnull ItemStack me,int slotNum,@Nonnull ItemStack upgrade){
  return UtilPlates.getPlate(upgrade) != null;
}",0.9357142857142856
22256,"@Nonnull @Override public ExosuitEventHandler[] getInstalledEventHandlers(ItemStack self){
  NBTTagCompound plateNBT=getPlateNBT(self);
  if (plateNBT != null) {
    ExosuitPlate plate=UtilPlates.getPlate(plateNBT.getString(""String_Node_Str""));
    return new ExosuitEventHandler[]{plate};
  }
  return new ExosuitEventHandler[0];
}","@Nonnull @Override public ExosuitEventHandler[] getInstalledEventHandlers(@Nonnull ItemStack self){
  NBTTagCompound plateNBT=getPlateNBT(self);
  if (plateNBT != null) {
    ExosuitPlate plate=UtilPlates.getPlate(plateNBT.getString(""String_Node_Str""));
    return new ExosuitEventHandler[]{plate};
  }
  return new ExosuitEventHandler[0];
}",0.986627043090639
22257,"@Override public void damageArmor(EntityLivingBase entity,ItemStack stack,DamageSource source,int damage,int slot){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ExosuitPlate plate=UtilPlates.getPlate(plateNBT.getString(""String_Node_Str""));
    int damageReduction=plate.getDamageReductionAmount(armorType,source);
    if ((entity.world.rand.nextInt(20 - damage) + 1) > damageReduction) {
      if (plateNBT.hasKey(""String_Node_Str"")) {
        plateNBT.setInteger(""String_Node_Str"",plateNBT.getInteger(""String_Node_Str"") - 1);
      }
 else {
        plateNBT.setInteger(""String_Node_Str"",plate.getDamageReductionAmount(armorType,DamageSource.GENERIC));
      }
    }
  }
}","@Override public void damageArmor(EntityLivingBase entity,@Nonnull ItemStack stack,DamageSource source,int damage,int slot){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ExosuitPlate plate=UtilPlates.getPlate(plateNBT.getString(""String_Node_Str""));
    int damageReduction=plate.getDamageReductionAmount(armorType,source);
    if ((entity.world.rand.nextInt(20 - damage) + 1) > damageReduction) {
      if (plateNBT.hasKey(""String_Node_Str"")) {
        plateNBT.setInteger(""String_Node_Str"",plateNBT.getInteger(""String_Node_Str"") - 1);
      }
 else {
        plateNBT.setInteger(""String_Node_Str"",plate.getDamageReductionAmount(armorType,DamageSource.GENERIC));
      }
    }
  }
}",0.9936485532815807
22258,"@Override public boolean getIsRepairable(ItemStack toRepair,ItemStack repair){
  return false;
}","@Override public boolean getIsRepairable(ItemStack toRepair,@Nullable ItemStack repair){
  return false;
}",0.9504950495049505
22259,"@Override public void addInformation(ItemStack stack,EntityPlayer playerIn,List<String> tooltip,boolean advanced){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ItemStack plateStack=new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
    if (plateStack != null) {
      tooltip.add(TextFormatting.BLUE + plateStack.getDisplayName());
    }
  }
  super.addInformation(stack,playerIn,tooltip,advanced);
}","@Override public void addInformation(ItemStack stack,EntityPlayer playerIn,List<String> tooltip,boolean advanced){
  NBTTagCompound plateNBT=getPlateNBT(stack);
  if (plateNBT != null) {
    ItemStack plateStack=new ItemStack(plateNBT.getCompoundTag(""String_Node_Str""));
    if (!plateStack.isEmpty()) {
      tooltip.add(TextFormatting.BLUE + plateStack.getDisplayName());
    }
  }
  super.addInformation(stack,playerIn,tooltip,advanced);
}",0.9580022701475596
22260,"@Override public int getArmorDisplay(EntityPlayer player,ItemStack armor,int slot){
  NBTTagCompound plateNBT=getPlateNBT(armor);
  if (plateNBT != null) {
    return UtilPlates.getPlate(plateNBT.getString(""String_Node_Str"")).getDamageReductionAmount(armorType,DamageSource.GENERIC);
  }
  return ArmorMaterial.LEATHER.getDamageReductionAmount(armorType);
}","@Override public int getArmorDisplay(EntityPlayer player,@Nonnull ItemStack armor,int slot){
  NBTTagCompound plateNBT=getPlateNBT(armor);
  if (plateNBT != null) {
    return UtilPlates.getPlate(plateNBT.getString(""String_Node_Str"")).getDamageReductionAmount(armorType,DamageSource.GENERIC);
  }
  return ArmorMaterial.LEATHER.getDamageReductionAmount(armorType);
}",0.9875518672199172
22261,"@Nonnull @Override public ExosuitUpgrade[] getUpgrades(ItemStack self){
  return new ExosuitUpgrade[0];
}","@Nonnull @Override public ExosuitUpgrade[] getUpgrades(@Nonnull ItemStack self){
  return new ExosuitUpgrade[0];
}",0.958904109589041
22262,"@Override public boolean hasUpgrade(ItemStack me,Item check){
  NBTTagCompound plateNBT=getPlateNBT(me);
  return plateNBT != null && new ItemStack(plateNBT.getCompoundTag(""String_Node_Str"")).getItem() == check;
}","@Override public boolean hasUpgrade(@Nonnull ItemStack me,Item check){
  NBTTagCompound plateNBT=getPlateNBT(me);
  return plateNBT != null && new ItemStack(plateNBT.getCompoundTag(""String_Node_Str"")).getItem() == check;
}",0.9793103448275862
22263,"@Override public boolean isItemValidForSlot(ItemStack me,int slot,ItemStack var2){
  return true;
}","@Override public boolean isItemValidForSlot(@Nonnull ItemStack me,int slot,@Nonnull ItemStack var2){
  return true;
}",0.9166666666666666
22264,"@Override public ItemOverrideList getOverrides(){
  return LeatherExosuitItemOverrideList.INSTANCE;
}","@Nonnull @Override public ItemOverrideList getOverrides(){
  return LeatherExosuitItemOverrideList.INSTANCE;
}",0.957345971563981
22265,"@Override public IBakedModel handleItemState(IBakedModel originalModel,ItemStack stack,World world,EntityLivingBase entity){
  ItemLeatherExosuitArmor armor=(ItemLeatherExosuitArmor)stack.getItem();
  List<ResourceLocation> locations=new ArrayList<>();
  locations.add(armor.getItemIconResource());
  ExosuitPlate plate=armor.getPlate(stack);
  if (plate != null) {
    locations.add(UtilPlates.getIconFromPlate(plate.getIdentifier(),armor));
  }
  LeatherExosuitItemBakedModel exosuitItemBakedModel=(LeatherExosuitItemBakedModel)originalModel;
  IModel processed=new LeatherExosuitItemModel(locations);
  String cacheKey=String.format(""String_Node_Str"",armor.getRegistryName(),plate);
  IBakedModel bakedModel=processed.bake(new SimpleModelState(exosuitItemBakedModel.getTransforms()),exosuitItemBakedModel.getFormat(),ModelLoader.defaultTextureGetter());
  exosuitItemBakedModel.cacheModel(cacheKey,bakedModel);
  return bakedModel;
}","@Nonnull @Override public IBakedModel handleItemState(@Nonnull IBakedModel originalModel,ItemStack stack,World world,EntityLivingBase entity){
  ItemLeatherExosuitArmor armor=(ItemLeatherExosuitArmor)stack.getItem();
  List<ResourceLocation> locations=new ArrayList<>();
  locations.add(armor.getItemIconResource());
  ExosuitPlate plate=armor.getPlate(stack);
  if (plate != null) {
    locations.add(UtilPlates.getIconFromPlate(plate.getIdentifier(),armor));
  }
  LeatherExosuitItemBakedModel exosuitItemBakedModel=(LeatherExosuitItemBakedModel)originalModel;
  IModel processed=new LeatherExosuitItemModel(locations);
  String cacheKey=String.format(""String_Node_Str"",armor.getRegistryName(),plate);
  IBakedModel bakedModel=processed.bake(new SimpleModelState(exosuitItemBakedModel.getTransforms()),exosuitItemBakedModel.getFormat(),ModelLoader.defaultTextureGetter());
  exosuitItemBakedModel.cacheModel(cacheKey,bakedModel);
  return bakedModel;
}",0.9904761904761904
22266,"@Override public void updateModel(EntityLivingBase entityLivingBase,ItemStack itemStack,EntityEquipmentSlot slot){
  ItemStack stack=((Engineerable)itemStack.getItem()).getStackInSlot(itemStack,0);
  if (stack != null) {
    ExosuitPlate plate=UtilPlates.getPlate(stack);
    if (plate != null) {
      plateOverlay=new ResourceLocation(MODEL_TEXTURE.getResourceDomain(),MODEL_TEXTURE.getResourcePath().replace(""String_Node_Str"",""String_Node_Str"" + plate.getArmorMod() + ""String_Node_Str""));
      return;
    }
  }
  plateOverlay=null;
}","@Override public void updateModel(EntityLivingBase entityLivingBase,ItemStack itemStack,EntityEquipmentSlot slot){
  ItemStack stack=((Engineerable)itemStack.getItem()).getStackInSlot(itemStack,0);
  ExosuitPlate plate=UtilPlates.getPlate(stack);
  if (plate != null) {
    plateOverlay=new ResourceLocation(MODEL_TEXTURE.getResourceDomain(),MODEL_TEXTURE.getResourcePath().replace(""String_Node_Str"",""String_Node_Str"" + plate.getArmorMod() + ""String_Node_Str""));
    return;
  }
  plateOverlay=null;
}",0.8604427333974976
22267,"@Override public void render(Entity entity,float limbSwing,float limbSwingAmount,float ageInTicks,float netHeadYaw,float headPitch,float scale){
  super.render(entity,limbSwing,limbSwingAmount,ageInTicks,netHeadYaw,headPitch,scale);
  if (plateOverlay != null) {
    Minecraft.getMinecraft().renderEngine.bindTexture(plateOverlay);
  }
  GlStateManager.pushMatrix();
  copyRotateAngles(footLeft,bipedLeftLeg);
  copyRotateAngles(footRight,bipedRightLeg);
  copyRotateAngles(pauldronLeft,bipedLeftArm);
  copyRotateAngles(pauldronRight,bipedRightArm);
  copyRotateAngles(breastPlate,bipedBody);
  if (entity.isSneaking()) {
    GlStateManager.translate(0,0.2F,0);
  }
  footLeft.render(scale);
  footRight.render(scale);
  pauldronLeft.render(scale);
  pauldronRight.render(scale);
  breastPlate.render(scale);
  GlStateManager.popMatrix();
}","@Override public void render(@Nullable Entity entity,float limbSwing,float limbSwingAmount,float ageInTicks,float netHeadYaw,float headPitch,float scale){
  super.render(entity,limbSwing,limbSwingAmount,ageInTicks,netHeadYaw,headPitch,scale);
  if (plateOverlay != null) {
    Minecraft.getMinecraft().renderEngine.bindTexture(plateOverlay);
  }
  GlStateManager.pushMatrix();
  copyRotateAngles(footLeft,bipedLeftLeg);
  copyRotateAngles(footRight,bipedRightLeg);
  copyRotateAngles(pauldronLeft,bipedLeftArm);
  copyRotateAngles(pauldronRight,bipedRightArm);
  copyRotateAngles(breastPlate,bipedBody);
  if (entity != null && entity.isSneaking()) {
    GlStateManager.translate(0,0.2F,0);
  }
  footLeft.render(scale);
  footRight.render(scale);
  pauldronLeft.render(scale);
  pauldronRight.render(scale);
  breastPlate.render(scale);
  GlStateManager.popMatrix();
}",0.983625730994152
22268,"@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceil(event.getOrb().xpValue * 1.125F);
}","@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,@Nonnull ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceil(event.getOrb().xpValue * 1.125F);
}",0.9767441860465116
22269,"@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceil(event.getOrb().xpValue * 1.25F);
}","@Override public void onPlayerPickupXP(PlayerPickupXpEvent event,@Nonnull ItemStack armorStack,EntityEquipmentSlot slot){
  event.getOrb().xpValue=MathHelper.ceil(event.getOrb().xpValue * 1.25F);
}",0.9766233766233766
22270,"@Override public Multimap<String,AttributeModifier> getAttributeModifiersForExosuit(EntityEquipmentSlot armorSlot,ItemStack armorPieceStack){
  Multimap<String,AttributeModifier> map=HashMultimap.create();
  map.put(SharedMonsterAttributes.KNOCKBACK_RESISTANCE.getName(),new AttributeModifier(new UUID(776437,armorSlot.getSlotIndex()),""String_Node_Str"" + armorSlot.getName(),0.25D,0));
  return map;
}","@Override public Multimap<String,AttributeModifier> getAttributeModifiersForExosuit(EntityEquipmentSlot armorSlot,@Nonnull ItemStack armorPieceStack){
  Multimap<String,AttributeModifier> map=HashMultimap.create();
  map.put(SharedMonsterAttributes.KNOCKBACK_RESISTANCE.getName(),new AttributeModifier(new UUID(776437,armorSlot.getSlotIndex()),""String_Node_Str"" + armorSlot.getName(),0.25D,0));
  return map;
}",0.9889025893958076
22271,"@Override public void onPlayerHurt(LivingHurtEvent event,EntityPlayer victim,ItemStack armorStack,EntityEquipmentSlot slot){
  EntityLivingBase entity=event.getEntityLiving();
  float amount=event.getAmount();
  if (!INVALID_SOURCES.contains(event.getSource()) && ChargableUtility.hasPower(entity,Config.zincPlateConsumption)) {
    float health=victim.getHealth();
    float maxHealth=victim.getMaxHealth();
    float halfOfMax=maxHealth / 2;
    if (amount >= halfOfMax || health <= halfOfMax) {
      ItemStack zincPlates=new ItemStack(METAL_PLATE,2,ItemMetalPlate.Types.ZINC_PLATE.getMeta());
      World world=victim.world;
      ChargableUtility.drainSteam(victim.getItemStackFromSlot(EntityEquipmentSlot.CHEST),Config.zincPlateConsumption,victim);
      UtilPlates.removePlate(armorStack);
      EntityItem entityItem=new EntityItem(world,victim.posX,victim.posY,victim.posZ,zincPlates);
      world.spawnEntity(entityItem);
      victim.setHealth(health);
      victim.performHurtAnimation();
      world.playSound(victim.posX,victim.posY,victim.posZ,EsteemedInnovation.SOUND_HISS,SoundCategory.PLAYERS,2F,0.9F,false);
      event.setCanceled(true);
    }
  }
}","@Override public void onPlayerHurt(LivingHurtEvent event,EntityPlayer victim,@Nonnull ItemStack armorStack,EntityEquipmentSlot slot){
  EntityLivingBase entity=event.getEntityLiving();
  float amount=event.getAmount();
  if (!INVALID_SOURCES.contains(event.getSource()) && ChargableUtility.hasPower(entity,Config.zincPlateConsumption)) {
    float health=victim.getHealth();
    float maxHealth=victim.getMaxHealth();
    float halfOfMax=maxHealth / 2;
    if (amount >= halfOfMax || health <= halfOfMax) {
      ItemStack zincPlates=new ItemStack(METAL_PLATE,2,ItemMetalPlate.Types.ZINC_PLATE.getMeta());
      World world=victim.world;
      ChargableUtility.drainSteam(victim.getItemStackFromSlot(EntityEquipmentSlot.CHEST),Config.zincPlateConsumption,victim);
      UtilPlates.removePlate(armorStack);
      EntityItem entityItem=new EntityItem(world,victim.posX,victim.posY,victim.posZ,zincPlates);
      world.spawnEntity(entityItem);
      victim.setHealth(health);
      victim.performHurtAnimation();
      world.playSound(victim.posX,victim.posY,victim.posZ,EsteemedInnovation.SOUND_HISS,SoundCategory.PLAYERS,2F,0.9F,false);
      event.setCanceled(true);
    }
  }
}",0.996165317426502
22272,"@Override @SideOnly(Side.CLIENT) public void getSubItems(Item item,CreativeTabs tabs,NonNullList<ItemStack> subItems){
  for (int i=0; i < ArmorModule.MAX_PLATE_META; i++) {
    subItems.add(ArmorModule.plateStack(i));
  }
}","@Override @SideOnly(Side.CLIENT) public void getSubItems(@Nonnull Item item,CreativeTabs tabs,NonNullList<ItemStack> subItems){
  for (int i=0; i < ArmorModule.MAX_PLATE_META; i++) {
    subItems.add(ArmorModule.plateStack(i));
  }
}",0.9803063457330417
22273,"@Override public EnumRarity getRarity(ItemStack stack){
  return EsteemedInnovation.upgrade;
}","@Nonnull @Override public EnumRarity getRarity(ItemStack stack){
  return EsteemedInnovation.upgrade;
}",0.9543147208121828
22274,"@Override public String getUnlocalizedName(ItemStack stack){
  return getUnlocalizedName() + ""String_Node_Str"" + stack.getItemDamage();
}","@Nonnull @Override public String getUnlocalizedName(ItemStack stack){
  return getUnlocalizedName() + ""String_Node_Str"" + stack.getItemDamage();
}",0.9681978798586572
22275,"/** 
 * Helper method for checking if the provided entity has steam in their exosuit, without having to explicitly find the proper armor piece, null check, type check, and check for the power every time.
 * @param entityLiving The entity to check for power. It will check every equipment slot.
 * @param i The amount of power required.
 * @return Whether the player has any {@link ExosuitArmor} piece in their inventory with the required amount of power.It will return as soon as it finds a single piece (so you could have 1 piece with no power, and 1 with {@code i} power, and it will return true as soon as it finds the one with {@code i} power).
 */
public static boolean hasPower(EntityLivingBase entityLiving,int i){
  boolean hasPower=false;
  for (  EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
    ItemStack equipment=entityLiving.getItemStackFromSlot(slot);
    if (equipment != null) {
      Item item=equipment.getItem();
      if (item instanceof SteamChargable && ((SteamChargable)item).canCharge(equipment)) {
        hasPower=((SteamChargable)item).hasPower(equipment,i);
      }
    }
    if (hasPower) {
      break;
    }
  }
  return hasPower;
}","/** 
 * Helper method for checking if the provided entity has steam in their exosuit, without having to explicitly find the proper armor piece, null check, type check, and check for the power every time.
 * @param entityLiving The entity to check for power. It will check every equipment slot.
 * @param i The amount of power required.
 * @return Whether the player has any {@link ExosuitArmor} piece in their inventory with the required amount of power.It will return as soon as it finds a single piece (so you could have 1 piece with no power, and 1 with {@code i} power, and it will return true as soon as it finds the one with {@code i} power).
 */
public static boolean hasPower(EntityLivingBase entityLiving,int i){
  boolean hasPower=false;
  for (  EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
    ItemStack equipment=entityLiving.getItemStackFromSlot(slot);
    Item item=equipment.getItem();
    if (item instanceof SteamChargable && ((SteamChargable)item).canCharge(equipment)) {
      hasPower=((SteamChargable)item).hasPower(equipment,i);
    }
    if (hasPower) {
      break;
    }
  }
  return hasPower;
}",0.969303934284479
22276,"/** 
 * @param elb The entity to check
 * @return The first {@link SteamChargable} item that the entity is wearing. Null if not found.
 */
@Nullable public static ItemStack findFirstChargableArmor(EntityLivingBase elb){
  for (  EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
    ItemStack equipment=elb.getItemStackFromSlot(slot);
    if (equipment != null) {
      Item item=equipment.getItem();
      if (item instanceof SteamChargable && ((SteamChargable)item).canCharge(equipment)) {
        return equipment;
      }
    }
  }
  return null;
}","/** 
 * @param elb The entity to check
 * @return The first {@link SteamChargable} item that the entity is wearing. Null if not found.
 */
@Nullable public static ItemStack findFirstChargableArmor(EntityLivingBase elb){
  for (  EntityEquipmentSlot slot : ItemStackUtility.ARMOR_SLOTS) {
    ItemStack equipment=elb.getItemStackFromSlot(slot);
    Item item=equipment.getItem();
    if (item instanceof SteamChargable && ((SteamChargable)item).canCharge(equipment)) {
      return equipment;
    }
  }
  return null;
}",0.9101019462465244
22277,"/** 
 * Helper method for draining the steam from an exosuit without having to explicitly null check and type check in your own code every time.
 * @param stack The ItemStack that contains the armor piece
 * @param amount The amount of steam to drain.
 * @param entity The entity using the thing.
 * @return Whether it was successfully drained.
 */
public static boolean drainSteam(ItemStack stack,int amount,EntityLivingBase entity){
  return stack != null && stack.getItem() instanceof SteamChargable && ((SteamChargable)stack.getItem()).canCharge(stack) && ((SteamChargable)stack.getItem()).drainSteam(stack,amount,entity);
}","/** 
 * Helper method for draining the steam from an exosuit without having to explicitly null check and type check in your own code every time.
 * @param stack The ItemStack that contains the armor piece
 * @param amount The amount of steam to drain.
 * @param entity The entity using the thing.
 * @return Whether it was successfully drained.
 */
public static boolean drainSteam(@Nonnull ItemStack stack,int amount,EntityLivingBase entity){
  Item item=stack.getItem();
  return item instanceof SteamChargable && ((SteamChargable)item).canCharge(stack) && ((SteamChargable)item).drainSteam(stack,amount,entity);
}",0.8022508038585209
22278,"ItemStack decrStackSize(ItemStack me,int var1,int var2);","@Nonnull ItemStack decrStackSize(@Nonnull ItemStack me,int var1,int var2);",0.8615384615384616
22279,"ItemStack getStackInSlot(ItemStack me,int var1);","@Nonnull ItemStack getStackInSlot(@Nonnull ItemStack me,int var1);",0.8421052631578947
22280,"void setInventorySlotContents(ItemStack me,int var1,ItemStack stack);","void setInventorySlotContents(@Nonnull ItemStack me,int var1,@Nonnull ItemStack stack);",0.8846153846153846
22281,"boolean canPutInSlot(ItemStack me,int slotNum,ItemStack upgrade);","boolean canPutInSlot(@Nonnull ItemStack me,int slotNum,@Nonnull ItemStack upgrade);",0.8783783783783784
22282,"boolean isItemValidForSlot(ItemStack me,int var1,ItemStack var2);","boolean isItemValidForSlot(@Nonnull ItemStack me,int var1,@Nonnull ItemStack var2);",0.8783783783783784
22283,"@Override public List<ItemStack> apply(ItemStack input,World world){
  return out;
}","@Override public List<ItemStack> apply(@Nonnull ItemStack input,World world){
  return out;
}",0.9491525423728814
22284,"/** 
 * Registers a smasher recipe
 * @param input The input ItemStack
 * @param function The function that returns the output.
 */
public static void registerSmashable(ItemStack input,BiFunction<ItemStack,World,List<ItemStack>> function){
  registry.put(input,function);
}","/** 
 * Registers a smasher recipe
 * @param input The input ItemStack
 * @param function The function that returns the output.
 */
public static void registerSmashable(@Nonnull ItemStack input,BiFunction<ItemStack,World,List<ItemStack>> function){
  registry.put(input,function);
}",0.9837837837837838
22285,"/** 
 * Gets all of the input ItemStacks that will produce the provided output. This does not respect stacksize.
 * @param output The desired output
 * @param world The current world
 * @return A list of all ItemStacks that produce the output. Can be null if the output is null. Because the functionmight use randomization (or other such things) to return its outputs, this might not be 100% accurate all of the time.
 */
public static List<ItemStack> getInputs(ItemStack output,World world){
  if (output == null) {
    return null;
  }
  List<ItemStack> inputs=new ArrayList<>();
  for (  Map.Entry<ItemStack,BiFunction<ItemStack,World,List<ItemStack>>> entry : registry.entrySet()) {
    for (    ItemStack out : entry.getValue().apply(entry.getKey(),world)) {
      if (out.isItemEqual(output)) {
        inputs.add(entry.getKey());
      }
    }
  }
  return inputs;
}","/** 
 * Gets all of the input ItemStacks that will produce the provided output. This does not respect stacksize.
 * @param output The desired output
 * @param world The current world
 * @return A list of all ItemStacks that produce the output. Can be null if the output is null. Because the functionmight use randomization (or other such things) to return its outputs, this might not be 100% accurate all of the time.
 */
public static List<ItemStack> getInputs(@Nonnull ItemStack output,World world){
  if (output.isEmpty()) {
    return null;
  }
  List<ItemStack> inputs=new ArrayList<>();
  for (  Map.Entry<ItemStack,BiFunction<ItemStack,World,List<ItemStack>>> entry : registry.entrySet()) {
    for (    ItemStack out : entry.getValue().apply(entry.getKey(),world)) {
      if (out.isItemEqual(output)) {
        inputs.add(entry.getKey());
      }
    }
  }
  return inputs;
}",0.9846328969834944
22286,"/** 
 * Removes a smasher recipe
 * @param input The input ItemStack whose recipe is being removed
 */
public static void removeSmashable(ItemStack input){
  registry.remove(input);
}","/** 
 * Removes a smasher recipe
 * @param input The input ItemStack whose recipe is being removed
 */
public static void removeSmashable(@Nonnull ItemStack input){
  registry.remove(input);
}",0.976
22287,"/** 
 * Gets the smasher output for the provided ItemStack.
 * @param input The input ItemStack
 * @param world The current world
 * @return The output ItemStacks.
 */
@Nonnull public static List<ItemStack> getOutput(ItemStack input,World world){
  if (input == null) {
    return Collections.emptyList();
  }
  List<ItemStack> output=new ArrayList<>();
  for (  Map.Entry<ItemStack,BiFunction<ItemStack,World,List<ItemStack>>> entry : registry.entrySet()) {
    if (ItemStack.areItemStacksEqual(entry.getKey(),input)) {
      output=entry.getValue().apply(input,world);
      if (!output.isEmpty()) {
        break;
      }
    }
  }
  return output.stream().map(ItemStack::copy).collect(Collectors.toList());
}","/** 
 * Gets the smasher output for the provided ItemStack.
 * @param input The input ItemStack
 * @param world The current world
 * @return The output ItemStacks.
 */
@Nonnull public static List<ItemStack> getOutput(@Nonnull ItemStack input,World world){
  if (input.isEmpty()) {
    return Collections.emptyList();
  }
  List<ItemStack> output=new ArrayList<>();
  for (  Map.Entry<ItemStack,BiFunction<ItemStack,World,List<ItemStack>>> entry : registry.entrySet()) {
    if (ItemStack.areItemStacksEqual(entry.getKey(),input)) {
      output=entry.getValue().apply(input,world);
      if (!output.isEmpty()) {
        break;
      }
    }
  }
  return output.stream().map(ItemStack::copy).collect(Collectors.toList());
}",0.981184668989547
22288,"/** 
 * Adds an amount of steam to the item.
 * @param me The ItemStack
 * @param amount How much steam to add.
 * @param entity The entity using the thing.
 * @return Whether it was a successful add.
 */
boolean addSteam(ItemStack me,int amount,EntityLivingBase entity);","/** 
 * Adds an amount of steam to the item.
 * @param me The ItemStack
 * @param amount How much steam to add.
 * @param entity The entity using the thing.
 * @return Whether it was a successful add.
 */
boolean addSteam(@Nonnull ItemStack me,int amount,EntityLivingBase entity);",0.9836660617059892
22289,"/** 
 * Checks whether the ItemStack has the amount of power in its steam storage. The opposite of
 * @param me The ItemStack
 * @param powerNeeded The amount of power needed
 * @return True if it has power, false if it doesn't.
 * @see #needsPower(ItemStack,int)
 */
boolean hasPower(ItemStack me,int powerNeeded);","/** 
 * Checks whether the ItemStack has the amount of power in its steam storage. The opposite of
 * @param me The ItemStack
 * @param powerNeeded The amount of power needed
 * @return True if it has power, false if it doesn't.
 * @see #needsPower(ItemStack,int)
 */
boolean hasPower(@Nonnull ItemStack me,int powerNeeded);",0.9859154929577464
22290,"/** 
 * Checks whether the ItemStack can have the amount of power added to its steam storage.
 * @param me The ItemStack
 * @param powerNeeded The amount of power to add
 * @return True if it will not exceed the limit with this amount of power added to it, false ifit will, or if it is not a chestplate.
 */
boolean needsPower(ItemStack me,int powerNeeded);","/** 
 * Checks whether the ItemStack can have the amount of power added to its steam storage.
 * @param me The ItemStack
 * @param powerNeeded The amount of power to add
 * @return True if it will not exceed the limit with this amount of power added to it, false ifit will, or if it is not a chestplate.
 */
boolean needsPower(@Nonnull ItemStack me,int powerNeeded);",0.9875518672199172
22291,"/** 
 * Called to ensure the item can be charged with steam devices
 * @param me The itemstack of the item
 * @return true if the item can charge
 */
boolean canCharge(ItemStack me);","/** 
 * Called to ensure the item can be charged with steam devices
 * @param me The itemstack of the item
 * @return true if the item can charge
 */
boolean canCharge(@Nonnull ItemStack me);",0.9758713136729222
22292,"/** 
 * Drains the provided amount of steam from the armor.
 * @param me The armor piece to drain from.
 * @param amountToDrain The amount of steam to drain from the armor.
 * @param entity The entity using the thing.
 * @return Whether steam was successfully drained.
 */
boolean drainSteam(ItemStack me,int amountToDrain,EntityLivingBase entity);","/** 
 * Drains the provided amount of steam from the armor.
 * @param me The armor piece to drain from.
 * @param amountToDrain The amount of steam to drain from the armor.
 * @param entity The entity using the thing.
 * @return Whether steam was successfully drained.
 */
boolean drainSteam(@Nonnull ItemStack me,int amountToDrain,EntityLivingBase entity);",0.9872340425531916
22293,"/** 
 * Removes a steaming custom recipe (not a replacement recipe).
 * @param input The input ItemStack.
 */
public static void removeSteamingRecipe(ItemStack input){
  steamingRecipes.remove(input);
}","/** 
 * Removes a steaming custom recipe (not a replacement recipe).
 * @param input The input ItemStack.
 */
public static void removeSteamingRecipe(@Nonnull ItemStack input){
  steamingRecipes.remove(input);
}",0.9782082324455206
22294,"/** 
 * Adds a steaming custom recipe (not a replacement recipe).
 * @param input The input ItemStack
 * @param output The output ItemStack
 */
public static void addSteamingRecipe(ItemStack input,ItemStack output){
  steamingRecipes.put(input,output);
}","/** 
 * Adds a steaming custom recipe (not a replacement recipe).
 * @param input The input ItemStack
 * @param output The output ItemStack
 */
public static void addSteamingRecipe(@Nonnull ItemStack input,@Nonnull ItemStack output){
  steamingRecipes.put(input,output);
}",0.9657794676806084
22295,"protected void drawItemStack(ItemStack stack,int x,int y,String str,RenderItem itemRender,FontRenderer fontRendererObj,boolean canHyperlink){
  GlStateManager.pushMatrix();
  GlStateManager.translate(0,0,32F);
  GlStateManager.enableBlend();
  GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA,GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
  RenderHelper.enableGUIStandardItemLighting();
  GlStateManager.enableRescaleNormal();
  GlStateManager.enableDepth();
  itemRender.zLevel=200.0F;
  FontRenderer font=null;
  if (stack != null && stack.getItem() != null) {
    font=stack.getItem().getFontRenderer(stack);
  }
  if (font == null) {
    font=fontRendererObj;
  }
  itemRender.renderItemAndEffectIntoGUI(stack,x,y);
  itemRender.renderItemOverlayIntoGUI(font,stack,x,y,str);
  itemRender.zLevel=0.0F;
  items.add(new Tuple4<>(x,y,stack,canHyperlink));
  GlStateManager.popMatrix();
}","protected void drawItemStack(@Nonnull ItemStack stack,int x,int y,String str,RenderItem itemRender,FontRenderer fontRendererObj,boolean canHyperlink){
  GlStateManager.pushMatrix();
  GlStateManager.translate(0,0,32F);
  GlStateManager.enableBlend();
  GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA,GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
  RenderHelper.enableGUIStandardItemLighting();
  GlStateManager.enableRescaleNormal();
  GlStateManager.enableDepth();
  itemRender.zLevel=200.0F;
  FontRenderer font=null;
  if (!stack.isEmpty()) {
    font=stack.getItem().getFontRenderer(stack);
  }
  if (font == null) {
    font=fontRendererObj;
  }
  itemRender.renderItemAndEffectIntoGUI(stack,x,y);
  itemRender.renderItemOverlayIntoGUI(font,stack,x,y,str);
  itemRender.zLevel=0.0F;
  items.add(new Tuple4<>(x,y,stack,canHyperlink));
  GlStateManager.popMatrix();
}",0.964824120603015
22296,"private void drawItemStackInPage(ItemStack itemStack,FontRenderer fontRenderer,int x,int j,int y,int i,RenderItem renderer){
  fontRenderer.setUnicodeFlag(false);
  drawItemStack(itemStack,x + 49 + j * 19,y + 59 + i * 19,""String_Node_Str"",renderer,fontRenderer,true);
  fontRenderer.setUnicodeFlag(true);
}","private void drawItemStackInPage(@Nonnull ItemStack itemStack,FontRenderer fontRenderer,int x,int j,int y,int i,RenderItem renderer){
  fontRenderer.setUnicodeFlag(false);
  drawItemStack(itemStack,x + 49 + j * 19,y + 59 + i * 19,""String_Node_Str"",renderer,fontRenderer,true);
  fontRenderer.setUnicodeFlag(true);
}",0.9855072463768116
22297,"public BookPageCrafting(String name,IRecipe... recipes){
  super(name);
  output=recipes[0].getRecipeOutput();
  for (  IRecipe recipe : recipes) {
    if (recipe instanceof ShapedOreRecipe) {
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapedOreRecipe)recipe).getInput().length > i && ((ShapedOreRecipe)recipe).getInput()[i] != null) {
          if (((ShapedOreRecipe)recipe).getInput()[i] instanceof Collection) {
            newList.addAll((Collection)((ShapedOreRecipe)recipe).getInput()[i]);
          }
 else {
            newList.add(((ShapedOreRecipe)recipe).getInput()[i]);
          }
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapedRecipes) {
      for (int i=0; i < 10; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapedRecipes)recipe).recipeItems.length > i && ((ShapedRecipes)recipe).recipeItems[i] != null) {
          newList.add(((ShapedRecipes)recipe).recipeItems[i]);
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapelessRecipes) {
      shapeless=true;
      inputs=ArrayUtils.addAll(inputs,((ShapelessRecipes)recipe).recipeItems.toArray(new Object[((ShapelessRecipes)recipe).recipeItems.size()]));
    }
 else     if (recipe instanceof ShapelessOreRecipe) {
      shapeless=true;
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapelessOreRecipe)recipe).getInput().size() > i && ((ShapelessOreRecipe)recipe).getInput().get(i) != null) {
          if (((ShapelessOreRecipe)recipe).getInput().get(i) instanceof Collection) {
            newList.addAll((Collection)((ShapelessOreRecipe)recipe).getInput().get(i));
          }
 else {
            newList.add(((ShapelessOreRecipe)recipe).getInput().get(i));
          }
        }
        inputs[i]=newList;
      }
    }
  }
  recipe=recipes;
}","public BookPageCrafting(String name,IRecipe... recipes){
  super(name);
  output=recipes[0].getRecipeOutput();
  for (  IRecipe recipe : recipes) {
    if (recipe instanceof ShapedOreRecipe) {
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapedOreRecipe)recipe).getInput().length > i && ((ShapedOreRecipe)recipe).getInput()[i] != null) {
          if (((ShapedOreRecipe)recipe).getInput()[i] instanceof Collection) {
            newList.addAll((Collection)((ShapedOreRecipe)recipe).getInput()[i]);
          }
 else {
            newList.add(((ShapedOreRecipe)recipe).getInput()[i]);
          }
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapedRecipes) {
      for (int i=0; i < 10; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapedRecipes)recipe).recipeItems.length > i && ((ShapedRecipes)recipe).recipeItems[i] != null) {
          newList.add(((ShapedRecipes)recipe).recipeItems[i]);
        }
        inputs[i]=newList;
      }
    }
 else     if (recipe instanceof ShapelessRecipes) {
      shapeless=true;
      inputs=ArrayUtils.addAll(inputs,((ShapelessRecipes)recipe).recipeItems.toArray(new Object[((ShapelessRecipes)recipe).recipeItems.size()]));
    }
 else     if (recipe instanceof ShapelessOreRecipe) {
      shapeless=true;
      for (int i=0; i < 9; i++) {
        Collection<Object> newList=new ArrayList<>();
        if (inputs[i] != null) {
          if (inputs[i] instanceof Collection) {
            newList.addAll((Collection)inputs[i]);
          }
 else {
            newList.add(inputs[i]);
          }
        }
        if (((ShapelessOreRecipe)recipe).getInput().size() > i && !((ItemStack)((ShapelessOreRecipe)recipe).getInput().get(i)).isEmpty()) {
          if (((ShapelessOreRecipe)recipe).getInput().get(i) instanceof Collection) {
            newList.addAll((Collection)((ShapelessOreRecipe)recipe).getInput().get(i));
          }
 else {
            newList.add(((ShapelessOreRecipe)recipe).getInput().get(i));
          }
        }
        inputs[i]=newList;
      }
    }
  }
  recipe=recipes;
}",0.9937888198757764
22298,"/** 
 * Registers a casting recipe.
 * @param inputLiquid The input liquid
 * @param mold The input mold
 * @param out The output
 */
public static void registerMoldingRecipe(CrucibleLiquid inputLiquid,ItemStack mold,ItemStack out){
  moldingRecipes.put(Pair.of(inputLiquid,mold),out);
}","/** 
 * Registers a casting recipe.
 * @param inputLiquid The input liquid
 * @param mold The input mold
 * @param out The output
 */
public static void registerMoldingRecipe(CrucibleLiquid inputLiquid,@Nonnull ItemStack mold,@Nonnull ItemStack out){
  moldingRecipes.put(Pair.of(inputLiquid,mold),out);
}",0.9695945945945946
22299,"/** 
 * @param inputLiquid The input liquid
 * @param mold The input mold
 * @return The output ItemStack
 */
@Nullable public static ItemStack getMoldingOutput(CrucibleLiquid inputLiquid,ItemStack mold){
  for (  Map.Entry<Pair<CrucibleLiquid,ItemStack>,ItemStack> entry : moldingRecipes.entrySet()) {
    Pair<CrucibleLiquid,ItemStack> input=entry.getKey();
    if (ItemStackUtility.compareItemStacks(mold,input.getRight()) && input.getLeft().equals(inputLiquid)) {
      return entry.getValue();
    }
  }
  return null;
}","/** 
 * @param inputLiquid The input liquid
 * @param mold The input mold
 * @return The output ItemStack
 */
@Nonnull public static ItemStack getMoldingOutput(CrucibleLiquid inputLiquid,@Nonnull ItemStack mold){
  for (  Map.Entry<Pair<CrucibleLiquid,ItemStack>,ItemStack> entry : moldingRecipes.entrySet()) {
    Pair<CrucibleLiquid,ItemStack> input=entry.getKey();
    if (ItemStackUtility.compareItemStacks(mold,input.getRight()) && input.getLeft().equals(inputLiquid)) {
      return entry.getValue();
    }
  }
  return ItemStack.EMPTY;
}",0.8774555659494855
22300,"/** 
 * Called after the weapon fires a round and the entity is spawned. This is after the ArrowLooseEvent is sent and after the ItemStack's loaded NBT key is decremented.
 * @param weaponStack The ItemStack for the weapon
 * @param world The world
 * @param player The player firing the round.
 */
default void afterRoundFired(ItemStack weaponStack,World world,EntityPlayer player){
}","/** 
 * Called after the weapon fires a round and the entity is spawned. This is after the ArrowLooseEvent is sent and after the ItemStack's loaded NBT key is decremented.
 * @param weaponStack The ItemStack for the weapon
 * @param world The world
 * @param player The player firing the round.
 */
default void afterRoundFired(@Nonnull ItemStack weaponStack,World world,EntityPlayer player){
}",0.9884467265725289
22301,"/** 
 * Whether this enhancement is valid for the given itemstack.
 * @param stack The ItemStack being upgraded.
 * @return Whether the enhancement can be used on the ItemStack.
 */
boolean canApplyTo(ItemStack stack);","/** 
 * Whether this enhancement is valid for the given itemstack.
 * @param stack The ItemStack being upgraded.
 * @return Whether the enhancement can be used on the ItemStack.
 */
boolean canApplyTo(@Nonnull ItemStack stack);",0.9797752808988764
22302,"@Override default void afterRoundFired(ItemStack weaponStack,World world,EntityPlayer player){
  if (player.capabilities.isFlying && !player.onGround && weaponStack.hasTagCompound()) {
    int timeBetweenFire=weaponStack.getTagCompound().getInteger(""String_Node_Str"");
    weaponStack.getTagCompound().setInteger(""String_Node_Str"",timeBetweenFire + getFireDelayChange(weaponStack));
  }
}","@Override default void afterRoundFired(@Nonnull ItemStack weaponStack,World world,EntityPlayer player){
  if (player.capabilities.isFlying && !player.onGround && weaponStack.hasTagCompound()) {
    int timeBetweenFire=weaponStack.getTagCompound().getInteger(""String_Node_Str"");
    weaponStack.getTagCompound().setInteger(""String_Node_Str"",timeBetweenFire + getFireDelayChange(weaponStack));
  }
}",0.9885350318471338
22303,"@Override public void safeUpdate(){
  if (lastSteam != getSteamShare() > VACUUM_STEAM_CONSUMPTION) {
    markForResync();
  }
  lastSteam=getSteamShare() > VACUUM_STEAM_CONSUMPTION;
  if (!isInitialized) {
    powered=worldObj.isBlockPowered(pos);
    EnumFacing myDir=worldObj.getBlockState(pos).getValue(BlockVacuum.FACING);
    setValidDistributionDirectionsExcluding(myDir,myDir.getOpposite());
    isInitialized=true;
  }
  if (!worldObj.isRemote) {
    if ((getSteamShare() < VACUUM_STEAM_CONSUMPTION) || powered) {
      active=false;
    }
 else {
      active=true;
      decrSteam(VACUUM_STEAM_CONSUMPTION);
    }
  }
  if (active) {
    if (worldObj.isRemote) {
      rotateTicks++;
    }
    EnumFacing dir=worldObj.getBlockState(pos).getValue(BlockVacuum.FACING);
    float[] M={pos.getX() + 0.5F,pos.getY() + 0.5F,pos.getZ() + 0.5F};
    float[] N={pos.getX() + 0.5F + range * dir.getFrontOffsetX(),pos.getY() + 0.5F + range * dir.getFrontOffsetY(),pos.getZ() + 0.5F + range * dir.getFrontOffsetZ()};
    List<Entity> entities=worldObj.getEntitiesWithinAABB(Entity.class,new AxisAlignedBB(pos.getX() - 20,pos.getY() - 20,pos.getZ() - 20,pos.getX() + 20,pos.getY() + 20,pos.getZ() + 20));
    for (int i=0; i < 200; i++) {
      float[] X={(worldObj.rand.nextFloat() * 40.0F) - 20.0F + pos.getX(),(worldObj.rand.nextFloat() * 40.0F) - 20.0F + pos.getY(),(worldObj.rand.nextFloat() * 40.0F) - 20.0F + pos.getZ()};
      if (isLyingInCone(X,M,N,THETA) && worldObj.rayTraceBlocks(new Vec3d(X[0],X[1],X[2]),new Vec3d(pos.getX() + 0.5F + dir.getFrontOffsetX(),pos.getY() + 0.5F + dir.getFrontOffsetY(),pos.getZ() + 0.5F + dir.getFrontOffsetZ())) == null) {
        Vec3d vec=new Vec3d(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
        vec=vec.normalize();
        worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,X[0],X[1],X[2],-vec.xCoord * 0.5F,-vec.yCoord * 0.5F,-vec.zCoord * 0.5F);
      }
    }
    for (    Entity entity : entities) {
      float[] X={(float)entity.posX,(float)entity.posY,(float)entity.posZ};
      if (isLyingInCone(X,M,N,THETA) && worldObj.rayTraceBlocks(new Vec3d(entity.posX,entity.posY,entity.posZ),new Vec3d(pos.getX() + 0.5F + dir.getFrontOffsetX(),pos.getY() + 0.5F + dir.getFrontOffsetY(),pos.getZ() + 0.5F + dir.getFrontOffsetZ())) == null) {
        if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
          Vec3d vec=new Vec3d(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
          vec=vec.normalize();
          double y=vec.yCoord;
          double x=vec.xCoord;
          double z=vec.zCoord;
          y*=1;
          if (entity.isSneaking()) {
            x*=0.25F;
            y*=0.25F;
            z*=0.25F;
          }
          entity.motionX-=x * 0.025F;
          entity.motionY-=y * 0.05F;
          entity.motionZ-=z * 0.025F;
          entity.fallDistance=0.0F;
        }
      }
    }
    List<EntityItem> list=worldObj.getEntitiesWithinAABB(EntityItem.class,new AxisAlignedBB(pos.getX() + dir.getFrontOffsetX() * 0.25F,pos.getY() + dir.getFrontOffsetY() * 0.25F,pos.getZ() + dir.getFrontOffsetZ() * 0.25F,pos.getX() + 1.0D + dir.getFrontOffsetX() * 0.25F,pos.getY() + 1.0D + dir.getFrontOffsetY() * 0.25F,pos.getZ() + 1.0D + dir.getFrontOffsetZ() * 0.25F));
    if (list.size() > 0) {
      EntityItem item=list.get(0);
      BlockPos offsetPos=new BlockPos(pos.getX() - dir.getFrontOffsetX(),pos.getY() - dir.getFrontOffsetY(),pos.getZ() - dir.getFrontOffsetZ());
      TileEntity tile=worldObj.getTileEntity(offsetPos);
      if (tile != null && tile instanceof ISidedInventory) {
        ISidedInventory inv=(ISidedInventory)tile;
        int[] access=inv.getSlotsForFace(dir.getOpposite());
        for (        int slot : access) {
          putInInventory(item,slot,inv);
        }
      }
 else       if (tile != null && tile instanceof IInventory) {
        IInventory inv=(IInventory)tile;
        for (int i=0; i < inv.getSizeInventory(); i++) {
          putInInventory(item,i,inv);
        }
      }
    }
  }
  super.safeUpdate();
}","@Override public void safeUpdate(){
  if (lastSteam != getSteamShare() > VACUUM_STEAM_CONSUMPTION) {
    markForResync();
  }
  lastSteam=getSteamShare() > VACUUM_STEAM_CONSUMPTION;
  if (!isInitialized) {
    powered=worldObj.isBlockPowered(pos);
    EnumFacing myDir=worldObj.getBlockState(pos).getValue(BlockVacuum.FACING);
    setValidDistributionDirectionsExcluding(myDir,myDir.getOpposite());
    isInitialized=true;
  }
  if (!worldObj.isRemote) {
    if ((getSteamShare() < VACUUM_STEAM_CONSUMPTION) || powered) {
      active=false;
    }
 else {
      active=true;
      decrSteam(VACUUM_STEAM_CONSUMPTION);
    }
  }
  if (active) {
    if (worldObj.isRemote) {
      rotateTicks++;
    }
    EnumFacing dir=worldObj.getBlockState(pos).getValue(BlockVacuum.FACING);
    float[] M={pos.getX() + 0.5F,pos.getY() + 0.5F,pos.getZ() + 0.5F};
    float[] N={pos.getX() + 0.5F + range * dir.getFrontOffsetX(),pos.getY() + 0.5F + range * dir.getFrontOffsetY(),pos.getZ() + 0.5F + range * dir.getFrontOffsetZ()};
    List<Entity> entities=worldObj.getEntitiesWithinAABB(Entity.class,new AxisAlignedBB(pos.getX() - 20,pos.getY() - 20,pos.getZ() - 20,pos.getX() + 20,pos.getY() + 20,pos.getZ() + 20));
    for (int i=0; i < 200; i++) {
      float[] X={(worldObj.rand.nextFloat() * 40.0F) - 20.0F + pos.getX(),(worldObj.rand.nextFloat() * 40.0F) - 20.0F + pos.getY(),(worldObj.rand.nextFloat() * 40.0F) - 20.0F + pos.getZ()};
      if (isLyingInCone(X,M,N,THETA) && worldObj.rayTraceBlocks(new Vec3d(X[0],X[1],X[2]),new Vec3d(pos.getX() + 0.5F + dir.getFrontOffsetX(),pos.getY() + 0.5F + dir.getFrontOffsetY(),pos.getZ() + 0.5F + dir.getFrontOffsetZ())) == null) {
        Vec3d vec=new Vec3d(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
        vec=vec.normalize();
        worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,X[0],X[1],X[2],-vec.xCoord * 0.5F,-vec.yCoord * 0.5F,-vec.zCoord * 0.5F);
      }
    }
    for (    Entity entity : entities) {
      float[] X={(float)entity.posX,(float)entity.posY,(float)entity.posZ};
      if (isLyingInCone(X,M,N,THETA) && worldObj.rayTraceBlocks(new Vec3d(entity.posX,entity.posY,entity.posZ),new Vec3d(pos.getX() + 0.5F + dir.getFrontOffsetX(),pos.getY() + 0.5F + dir.getFrontOffsetY(),pos.getZ() + 0.5F + dir.getFrontOffsetZ())) == null) {
        if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
          Vec3d vec=new Vec3d(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
          vec=vec.normalize();
          double y=vec.yCoord;
          double x=vec.xCoord;
          double z=vec.zCoord;
          y*=1;
          if (entity.isSneaking()) {
            x*=0.25F;
            y*=0.25F;
            z*=0.25F;
          }
          entity.motionX-=x * 0.025F;
          entity.motionY-=y * 0.05F;
          entity.motionZ-=z * 0.025F;
          entity.fallDistance=0.0F;
        }
      }
    }
    List<EntityItem> list=worldObj.getEntitiesWithinAABB(EntityItem.class,new AxisAlignedBB(pos.getX() + dir.getFrontOffsetX() * 0.25F,pos.getY() + dir.getFrontOffsetY() * 0.25F,pos.getZ() + dir.getFrontOffsetZ() * 0.25F,pos.getX() + 1.0D + dir.getFrontOffsetX() * 0.25F,pos.getY() + 1.0D + dir.getFrontOffsetY() * 0.25F,pos.getZ() + 1.0D + dir.getFrontOffsetZ() * 0.25F));
    if (!list.isEmpty()) {
      EntityItem item=list.get(0);
      BlockPos offsetPos=new BlockPos(pos.getX() - dir.getFrontOffsetX(),pos.getY() - dir.getFrontOffsetY(),pos.getZ() - dir.getFrontOffsetZ());
      TileEntity tile=worldObj.getTileEntity(offsetPos);
      if (tile instanceof ISidedInventory) {
        ISidedInventory inv=(ISidedInventory)tile;
        int[] access=inv.getSlotsForFace(dir.getOpposite());
        for (        int slot : access) {
          if (putInInventory(item,slot,inv)) {
            break;
          }
        }
      }
 else       if (tile instanceof IInventory) {
        IInventory inv=(IInventory)tile;
        for (int i=0; i < inv.getSizeInventory(); i++) {
          if (putInInventory(item,i,inv)) {
            break;
          }
        }
      }
    }
  }
  super.safeUpdate();
}",0.9788783685360524
22304,"private void putInInventory(EntityItem item,int slot,IInventory inv){
  ItemStack checkStack1=null;
  ItemStack checkStack2=null;
  ItemStack stackInSlot=inv.getStackInSlot(slot);
  if (inv.getStackInSlot(slot) != null) {
    checkStack1=stackInSlot.copy();
    checkStack1.stackSize=1;
    checkStack2=item.getEntityItem().copy();
    checkStack2.stackSize=1;
  }
  if ((stackInSlot == null || (ItemStack.areItemStacksEqual(checkStack1,checkStack2) && stackInSlot.stackSize < stackInSlot.getMaxStackSize())) && inv.isItemValidForSlot(slot,item.getEntityItem())) {
    ItemStack stack=item.getEntityItem().copy();
    boolean setDead=true;
    if (inv.getStackInSlot(slot) != null) {
      if ((stackInSlot.stackSize + stack.stackSize) > stack.getMaxStackSize() && checkStack2 != null) {
        setDead=false;
        int total=stackInSlot.stackSize + stack.stackSize;
        stack.stackSize=stack.getMaxStackSize();
        total-=stack.getMaxStackSize();
        checkStack2.stackSize=total;
        item.setEntityItemStack(checkStack2);
      }
 else {
        stack.stackSize=stackInSlot.stackSize + item.getEntityItem().stackSize;
      }
    }
    inv.setInventorySlotContents(slot,stack);
    if (setDead) {
      item.setDead();
    }
  }
}","/** 
 * @param item The item to put inside the inventory, held in an EntityItem.
 * @param slot The slot in which to put the item in within the inventory.
 * @param inv The inventory to put the item inside of.
 * @return Whether it was added or not.
 */
private boolean putInInventory(EntityItem item,int slot,IInventory inv){
  ItemStack checkStack1=null;
  ItemStack checkStack2=null;
  ItemStack stackInSlot=inv.getStackInSlot(slot);
  if (inv.getStackInSlot(slot) != null) {
    checkStack1=stackInSlot.copy();
    checkStack1.stackSize=1;
    checkStack2=item.getEntityItem().copy();
    checkStack2.stackSize=1;
  }
  if ((stackInSlot == null || (ItemStack.areItemStacksEqual(checkStack1,checkStack2) && stackInSlot.stackSize < stackInSlot.getMaxStackSize())) && inv.isItemValidForSlot(slot,item.getEntityItem())) {
    ItemStack stack=item.getEntityItem().copy();
    boolean setDead=true;
    if (inv.getStackInSlot(slot) != null) {
      if ((stackInSlot.stackSize + stack.stackSize) > stack.getMaxStackSize() && checkStack2 != null) {
        setDead=false;
        int total=stackInSlot.stackSize + stack.stackSize;
        stack.stackSize=stack.getMaxStackSize();
        total-=stack.getMaxStackSize();
        checkStack2.stackSize=total;
        item.setEntityItemStack(checkStack2);
      }
 else {
        stack.stackSize=stackInSlot.stackSize + item.getEntityItem().stackSize;
      }
    }
    inv.setInventorySlotContents(slot,stack);
    if (setDead) {
      item.setDead();
    }
    return true;
  }
  return false;
}",0.8910394265232975
22305,"/** 
 * Depopulates the itemStack's list of stored items and inserts them into the inventory.
 * @param itemStack The ItemStack to depopulate
 * @param inventory The inventory populate
 */
private static void depopulate(ItemStack itemStack,InventoryPlayer inventory){
  NBTTagList list=itemStack.getTagCompound().getTagList(""String_Node_Str"",Constants.NBT.TAG_COMPOUND);
  for (int i=0; i < InventoryPlayer.getHotbarSize(); i++) {
    ItemStack stack=ItemStack.loadItemStackFromNBT(list.getCompoundTagAt(i));
    if (stack != null) {
      inventory.setInventorySlotContents(inventory.getFirstEmptyStack(),stack);
    }
  }
  itemStack.getTagCompound().removeTag(""String_Node_Str"");
}","/** 
 * Depopulates the itemStack's list of stored items and inserts them into the inventory.
 * @param itemStack The ItemStack to depopulate
 * @param inventory The inventory populate
 */
private static void depopulate(ItemStack itemStack,InventoryPlayer inventory){
  NBTTagList list=itemStack.getTagCompound().getTagList(""String_Node_Str"",Constants.NBT.TAG_COMPOUND).copy();
  NBTTagList remainingItems=new NBTTagList();
  for (int i=0; i < list.tagCount(); i++) {
    ItemStack containedStack=ItemStack.loadItemStackFromNBT(list.getCompoundTagAt(i));
    int emptySlotID=inventory.getFirstEmptyStack();
    if (containedStack != null) {
      if (emptySlotID == -1) {
        remainingItems.appendTag(containedStack.serializeNBT());
      }
 else {
        inventory.setInventorySlotContents(emptySlotID,containedStack);
      }
    }
  }
  itemStack.getTagCompound().setTag(""String_Node_Str"",remainingItems);
}",0.7704815509693559
22306,"/** 
 * Opposite of   {@link StringUtility#capitalize(String)}.
 */
public static String decapitalize(String str){
  return str.substring(0,1).toLowerCase() + (str.substring(1));
}","/** 
 * Opposite of   {@link StringUtility#capitalize(String)}.
 */
public static String decapitalize(String str){
  return str.substring(0,1).toLowerCase(Locale.US) + (str.substring(1));
}",0.975609756097561
22307,"/** 
 * Capitalizes the first letter in the provided String.
 * @param str The string to capitalize.
 * @return The string with the first character capitalized. Examples:capitalize(""title"") // => ""Title"" capitalize(""Title"") // => ""Title"" capitalize(""él"") // => ""Él""
 */
public static String capitalize(String str){
  return str.substring(0,1).toUpperCase() + (str.substring(1));
}","/** 
 * Capitalizes the first letter in the provided String.
 * @param str The string to capitalize.
 * @return The string with the first character capitalized. Examples:capitalize(""title"") // => ""Title"" capitalize(""Title"") // => ""Title"" capitalize(""él"") // => ""Él""
 */
public static String capitalize(String str){
  return str.substring(0,1).toUpperCase(Locale.US) + (str.substring(1));
}",0.988296488946684
22308,"@Override public void renderTileEntityAt(TileEntityCrucible crucible,double x,double y,double z,float partialTicks,int destroyStage){
  IBlockState state=crucible.getWorld().getBlockState(crucible.getPos());
  EnumFacing facing=state.getValue(BlockCrucible.FACING);
  float angle=90F;
switch (facing) {
case WEST:
{
      angle=270F;
      break;
    }
case NORTH:
{
    angle=180F;
    break;
  }
case EAST:
{
  angle=90F;
  break;
}
case SOUTH:
{
angle=0F;
break;
}
default :
{
break;
}
}
GlStateManager.pushMatrix();
GlStateManager.enableRescaleNormal();
GlStateManager.color(1F,1F,1F,1F);
GlStateManager.translate(x,y,z);
int ticks=crucible.tipTicks;
Minecraft.getMinecraft().renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
GlStateManager.translate(0.5,0,0.5);
GlStateManager.rotate(angle,0F,1F,0F);
GlStateManager.scale(1F,-1F,-1F);
GlStateManager.translate(0,-0.5,0);
if (ticks > 135) {
ticks=(int)((ticks - 90) / 5.0F * 90);
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 5F,1F,0F,0F);
}
 else if (ticks > 120) {
ticks=(int)((ticks - 90) / 15.0F * 90);
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 15F,1F,0F,0F);
}
 else if (ticks > 90) {
ticks=(int)((ticks - 90) / 30.0F * 90);
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 30F,-1F,0F,0F);
}
 else {
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 75F,1F,0F,0F);
}
GlStateManager.translate(-0.5,0.5,-0.5);
GlStateManager.scale(1F,-1F,-1F);
IBakedModel model=Minecraft.getMinecraft().getBlockRendererDispatcher().getBlockModelShapes().getModelForState(state);
Minecraft.getMinecraft().getBlockRendererDispatcher().getBlockModelRenderer().renderModelBrightness(model,state,1F,false);
int fill=crucible.getFill();
if (fill > 0) {
GlStateManager.disableBlend();
float height=(2F + (fill / 90F) * 11F) / 16F;
GlStateManager.rotate(180F,1F,0F,0F);
GlStateManager.translate(0F,-height,-1F);
renderLiquid(crucible);
GlStateManager.enableBlend();
}
GlStateManager.popMatrix();
frame++;
if (frame == 20) {
frame=0;
}
}","@Override public void renderTileEntityAt(TileEntityCrucible crucible,double x,double y,double z,float partialTicks,int destroyStage){
  IBlockState state=crucible.getWorld().getBlockState(crucible.getPos());
  EnumFacing facing=state.getValue(BlockCrucible.FACING);
  float angle=90F;
switch (facing) {
case WEST:
{
      angle=270F;
      break;
    }
case NORTH:
{
    angle=180F;
    break;
  }
case EAST:
{
  angle=90F;
  break;
}
case SOUTH:
{
angle=0F;
break;
}
default :
{
break;
}
}
GlStateManager.pushMatrix();
GlStateManager.disableBlend();
GlStateManager.enableRescaleNormal();
GlStateManager.color(1F,1F,1F,1F);
GlStateManager.translate(x,y,z);
int ticks=crucible.tipTicks;
Minecraft.getMinecraft().renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
GlStateManager.translate(0.5,0,0.5);
GlStateManager.rotate(angle,0F,1F,0F);
GlStateManager.scale(1F,-1F,-1F);
GlStateManager.translate(0,-0.5,0);
if (ticks > 135) {
ticks=(int)((ticks - 90) / 5.0F * 90);
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 5F,1F,0F,0F);
}
 else if (ticks > 120) {
ticks=(int)((ticks - 90) / 15.0F * 90);
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 15F,1F,0F,0F);
}
 else if (ticks > 90) {
ticks=(int)((ticks - 90) / 30.0F * 90);
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 30F,-1F,0F,0F);
}
 else {
GlStateManager.rotate((MathHelper.sin((float)(Math.PI * (ticks / 90.0F)))) * 75F,1F,0F,0F);
}
GlStateManager.translate(-0.5,0.5,-0.5);
GlStateManager.scale(1F,-1F,-1F);
IBakedModel model=Minecraft.getMinecraft().getBlockRendererDispatcher().getBlockModelShapes().getModelForState(state);
Minecraft.getMinecraft().getBlockRendererDispatcher().getBlockModelRenderer().renderModelBrightness(model,state,1F,false);
int fill=crucible.getFill();
if (fill > 0) {
GlStateManager.disableBlend();
float height=(2F + (fill / 90F) * 11F) / 16F;
GlStateManager.rotate(180F,1F,0F,0F);
GlStateManager.translate(0F,-height,-1F);
renderLiquid(crucible);
GlStateManager.enableBlend();
}
GlStateManager.popMatrix();
frame++;
if (frame == 20) {
frame=0;
}
}",0.9926800472255016
22309,"@Override public void renderTileEntityAt(TileEntityMold mold,double x,double y,double z,float partialTicks,int destroyStage){
  GlStateManager.pushMatrix();
  GlStateManager.color(1,1,1,1);
  GlStateManager.translate(x,y,z);
  GL11.glTranslatef(0.5F,0.5F,0.5F);
  EnumFacing dir=getWorld().getBlockState(mold.getPos()).getValue(BlockMold.FACING);
  if (dir == EnumFacing.SOUTH) {
    GlStateManager.rotate(180F,0,1,0);
  }
 else   if (dir == EnumFacing.EAST) {
    GlStateManager.rotate(270F,0,1,0);
  }
 else   if (dir == EnumFacing.WEST) {
    GlStateManager.rotate(90F,0,1,0);
  }
  GlStateManager.pushMatrix();
  GlStateManager.rotate(180F,1,0,0);
  GlStateManager.translate(-0.5,(3.999F / 16F),-0.5);
  if (mold.mold != null) {
    renderMold(mold.mold.getItem(),true);
  }
  GlStateManager.translate(0,0.001,0);
  GlStateManager.popMatrix();
  GlStateManager.pushMatrix();
  GlStateManager.rotate(180F,0,1,0);
  GlStateManager.translate(0,-4 * PX,-6 * PX);
  float tick=(float)(Math.PI * (mold.changeTicks * 90.0F / 20.0F)) / 180.0F;
  float rotation=mold.isOpen ? 80F + MathHelper.sin(tick) * 100F : MathHelper.sin(tick) * -100F;
  if (mold.isOpen) {
    GlStateManager.rotate(180F,1,0,0);
  }
  GlStateManager.rotate(rotation,1,0,0);
  GlStateManager.translate(-0.5,-0.5,-0.5);
  GlStateManager.translate(0,4 * PX,6 * PX);
  RenderUtility.renderModel(Tessellator.getInstance().getBuffer(),MODEL_RL);
  bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
  Tessellator.getInstance().draw();
  GlStateManager.popMatrix();
  GlStateManager.pushMatrix();
  GlStateManager.rotate(180F,0,1,0);
  GlStateManager.translate(0,-4 * PX,-6 * PX);
  if (mold.isOpen) {
    GlStateManager.rotate(180F,1,0,0);
  }
  GlStateManager.rotate(rotation,1,0,0);
  GlStateManager.translate(-0.5,-0.5,-0.5);
  GlStateManager.translate(0,4 * PX,6 * PX);
  GlStateManager.translate(0,3.999 * PX,0);
  if (mold.mold != null) {
    renderMold(mold.mold.getItem(),true);
  }
  GlStateManager.popMatrix();
  GlStateManager.popMatrix();
}","@Override public void renderTileEntityAt(TileEntityMold mold,double x,double y,double z,float partialTicks,int destroyStage){
  GlStateManager.pushMatrix();
  GlStateManager.disableBlend();
  GlStateManager.color(1,1,1,1);
  GlStateManager.translate(x,y,z);
  GL11.glTranslatef(0.5F,0.5F,0.5F);
  EnumFacing dir=getWorld().getBlockState(mold.getPos()).getValue(BlockMold.FACING);
  if (dir == EnumFacing.SOUTH) {
    GlStateManager.rotate(180F,0,1,0);
  }
 else   if (dir == EnumFacing.EAST) {
    GlStateManager.rotate(270F,0,1,0);
  }
 else   if (dir == EnumFacing.WEST) {
    GlStateManager.rotate(90F,0,1,0);
  }
  GlStateManager.pushMatrix();
  GlStateManager.rotate(180F,1,0,0);
  GlStateManager.translate(-0.5,(3.999F / 16F),-0.5);
  if (mold.mold != null) {
    renderMold(mold.mold.getItem(),true);
  }
  GlStateManager.translate(0,0.001,0);
  GlStateManager.popMatrix();
  GlStateManager.pushMatrix();
  GlStateManager.rotate(180F,0,1,0);
  GlStateManager.translate(0,-4 * PX,-6 * PX);
  float tick=(float)(Math.PI * (mold.changeTicks * 90.0F / 20.0F)) / 180.0F;
  float rotation=mold.isOpen ? 80F + MathHelper.sin(tick) * 100F : MathHelper.sin(tick) * -100F;
  if (mold.isOpen) {
    GlStateManager.rotate(180F,1,0,0);
  }
  GlStateManager.rotate(rotation,1,0,0);
  GlStateManager.translate(-0.5,-0.5,-0.5);
  GlStateManager.translate(0,4 * PX,6 * PX);
  RenderUtility.renderModel(Tessellator.getInstance().getBuffer(),MODEL_RL);
  bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
  Tessellator.getInstance().draw();
  GlStateManager.popMatrix();
  GlStateManager.pushMatrix();
  GlStateManager.rotate(180F,0,1,0);
  GlStateManager.translate(0,-4 * PX,-6 * PX);
  if (mold.isOpen) {
    GlStateManager.rotate(180F,1,0,0);
  }
  GlStateManager.rotate(rotation,1,0,0);
  GlStateManager.translate(-0.5,-0.5,-0.5);
  GlStateManager.translate(0,4 * PX,6 * PX);
  GlStateManager.translate(0,3.999 * PX,0);
  if (mold.mold != null) {
    renderMold(mold.mold.getItem(),true);
  }
  GlStateManager.popMatrix();
  GlStateManager.popMatrix();
}",0.991865910771506
22310,"@Override public void onBlockAdded(World world,BlockPos pos,IBlockState state){
  onNeighborChange(world,pos,null);
}","@Override public void onBlockAdded(World world,BlockPos pos,IBlockState state){
  neighborChanged(state,world,pos,null);
}",0.9623430962343096
22311,"@Override public void neighborChanged(IBlockState state,World world,BlockPos pos,Block neighbor){
  TileEntity tileEntity=world.getTileEntity(pos);
  if (tileEntity != null && tileEntity instanceof TileEntityFan) {
    boolean poweredByRedstone=world.isBlockIndirectlyGettingPowered(pos) > 0;
    TileEntityFan fan=(TileEntityFan)tileEntity;
    fan.updateRedstoneState(poweredByRedstone);
  }
}","@Override public void neighborChanged(IBlockState state,World world,BlockPos pos,Block neighbor){
  TileEntity tileEntity=world.getTileEntity(pos);
  if (tileEntity != null && tileEntity instanceof TileEntityFan) {
    boolean poweredByRedstone=world.isBlockPowered(pos);
    TileEntityFan fan=(TileEntityFan)tileEntity;
    fan.updateRedstoneState(poweredByRedstone);
  }
}",0.9726918075422628
22312,"@Override public void update(){
  if (lastSteam != getSteamShare() >= STEAM_CONSUMPTION) {
    markDirty();
  }
  lastSteam=getSteamShare() > STEAM_CONSUMPTION;
  if (!isInitialized) {
    powered=worldObj.isBlockIndirectlyGettingPowered(pos) > 0;
    setDistributionDirections(new EnumFacing[]{EnumFacing.getFront(getBlockMetadata()).getOpposite()});
    isInitialized=true;
  }
  super.update();
  if (active && worldObj.isRemote) {
    rotateTicks++;
  }
  if (active && worldObj.isRemote || (getSteamShare() >= STEAM_CONSUMPTION && !powered)) {
    if (!worldObj.isRemote) {
      decrSteam(STEAM_CONSUMPTION);
    }
    EnumFacing dir=worldObj.getBlockState(pos).getValue(BlockFan.FACING);
    double[] positions=getSmokePositions(dir);
    double[] speeds=getSmokeSpeeds(dir);
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,positions[0],positions[1],positions[2],speeds[0],speeds[1],speeds[2]);
    int blocksInFront=0;
    boolean blocked=false;
    for (int i=1; i < range; i++) {
      int x=pos.getX() + dir.getFrontOffsetX() * i;
      int y=pos.getY() + dir.getFrontOffsetY() * i;
      int z=pos.getZ() + dir.getFrontOffsetZ() * i;
      BlockPos offsetPos=new BlockPos(x,y,z);
      IBlockState offsetState=worldObj.getBlockState(offsetPos);
      Block offsetBlock=offsetState.getBlock();
      if (!worldObj.isRemote && worldObj.rand.nextInt(20) == 0 && !blocked && offsetBlock != Blocks.AIR && offsetBlock.isReplaceable(worldObj,offsetPos) || offsetBlock instanceof BlockCrops) {
        if (offsetBlock instanceof BlockFluidBase) {
          for (int v=0; v < 5; v++) {
            Steamcraft.proxy.spawnBreakParticles(worldObj,x + 0.5F,y + 0.5F,z + 0.5F,offsetBlock,0F,0F,0F);
          }
        }
        worldObj.setBlockToAir(offsetPos);
      }
      if (!blocked && (offsetBlock.isReplaceable(worldObj,offsetPos) || worldObj.isAirBlock(offsetPos) || offsetBlock instanceof BlockTrapDoor|| offsetState.getCollisionBoundingBox(worldObj,offsetPos) == null)) {
        blocksInFront=i;
        if (i != range - 1) {
          worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,x + getRandomOrSlight(dir.getFrontOffsetX()),y + getRandomOrSlight(dir.getFrontOffsetY()),z + getRandomOrSlight(dir.getFrontOffsetZ()),speeds[0],speeds[1],speeds[2]);
        }
      }
 else {
        blocked=true;
      }
    }
    List<Entity> entities=worldObj.getEntitiesWithinAABB(Entity.class,new AxisAlignedBB(pos.getX() + (dir.getFrontOffsetX() < 0 ? dir.getFrontOffsetX() * blocksInFront : 0),pos.getY() + (dir.getFrontOffsetY() < 0 ? dir.getFrontOffsetY() * blocksInFront : 0),pos.getZ() + (dir.getFrontOffsetZ() < 0 ? dir.getFrontOffsetZ() * blocksInFront : 0),pos.getX() + 1 + (dir.getFrontOffsetX() > 0 ? dir.getFrontOffsetX() * blocksInFront : 0),pos.getY() + 1 + (dir.getFrontOffsetY() > 0 ? dir.getFrontOffsetY() * blocksInFront : 0),pos.getZ() + 1 + (dir.getFrontOffsetZ() > 0 ? dir.getFrontOffsetZ() * blocksInFront : 0)));
    for (    Object obj : entities) {
      Entity entity=(Entity)obj;
      if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
        if (entity instanceof EntityPlayer && entity.isSneaking()) {
          entity.motionX+=dir.getFrontOffsetX() * 0.025F;
          entity.motionY+=dir.getFrontOffsetY() * 0.05F;
          entity.motionZ+=dir.getFrontOffsetZ() * 0.025F;
        }
 else {
          entity.motionX+=dir.getFrontOffsetX() * 0.075F;
          entity.motionY+=dir.getFrontOffsetY() * 0.1F;
          entity.motionZ+=dir.getFrontOffsetZ() * 0.075F;
        }
        entity.fallDistance=0.0F;
      }
    }
  }
}","@Override public void update(){
  if (lastSteam != getSteamShare() >= STEAM_CONSUMPTION) {
    markForResync();
  }
  lastSteam=getSteamShare() > STEAM_CONSUMPTION;
  if (!lastSteam && !worldObj.isRemote && active) {
    markForResync();
  }
  if (!isInitialized) {
    powered=worldObj.isBlockPowered(pos);
    setDistributionDirections(new EnumFacing[]{worldObj.getBlockState(pos).getValue(BlockFan.FACING).getOpposite()});
    isInitialized=true;
  }
  super.update();
  if (active && worldObj.isRemote) {
    rotateTicks++;
  }
  if (active && worldObj.isRemote || (getSteamShare() >= STEAM_CONSUMPTION && !powered)) {
    if (!worldObj.isRemote) {
      decrSteam(STEAM_CONSUMPTION);
    }
    EnumFacing dir=worldObj.getBlockState(pos).getValue(BlockFan.FACING);
    double[] positions=getSmokePositions(dir);
    double[] speeds=getSmokeSpeeds(dir);
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,positions[0],positions[1],positions[2],speeds[0],speeds[1],speeds[2]);
    int blocksInFront=0;
    boolean blocked=false;
    for (int i=1; i < range; i++) {
      int x=pos.getX() + dir.getFrontOffsetX() * i;
      int y=pos.getY() + dir.getFrontOffsetY() * i;
      int z=pos.getZ() + dir.getFrontOffsetZ() * i;
      BlockPos offsetPos=new BlockPos(x,y,z);
      IBlockState offsetState=worldObj.getBlockState(offsetPos);
      Block offsetBlock=offsetState.getBlock();
      if (!worldObj.isRemote && worldObj.rand.nextInt(20) == 0 && !blocked && offsetBlock != Blocks.AIR && offsetBlock.isReplaceable(worldObj,offsetPos) || offsetBlock instanceof BlockCrops) {
        if (offsetBlock instanceof BlockFluidBase) {
          for (int v=0; v < 5; v++) {
            Steamcraft.proxy.spawnBreakParticles(worldObj,x + 0.5F,y + 0.5F,z + 0.5F,offsetBlock,0F,0F,0F);
          }
        }
        worldObj.setBlockToAir(offsetPos);
      }
      if (!blocked && (offsetBlock.isReplaceable(worldObj,offsetPos) || worldObj.isAirBlock(offsetPos) || offsetBlock instanceof BlockTrapDoor|| offsetState.getCollisionBoundingBox(worldObj,offsetPos) == null)) {
        blocksInFront=i;
        if (i != range - 1) {
          worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,x + getRandomOrSlight(dir.getFrontOffsetX()),y + getRandomOrSlight(dir.getFrontOffsetY()),z + getRandomOrSlight(dir.getFrontOffsetZ()),speeds[0],speeds[1],speeds[2]);
        }
      }
 else {
        blocked=true;
      }
    }
    List<Entity> entities=worldObj.getEntitiesWithinAABB(Entity.class,new AxisAlignedBB(pos.getX() + (dir.getFrontOffsetX() < 0 ? dir.getFrontOffsetX() * blocksInFront : 0),pos.getY() + (dir.getFrontOffsetY() < 0 ? dir.getFrontOffsetY() * blocksInFront : 0),pos.getZ() + (dir.getFrontOffsetZ() < 0 ? dir.getFrontOffsetZ() * blocksInFront : 0),pos.getX() + 1 + (dir.getFrontOffsetX() > 0 ? dir.getFrontOffsetX() * blocksInFront : 0),pos.getY() + 1 + (dir.getFrontOffsetY() > 0 ? dir.getFrontOffsetY() * blocksInFront : 0),pos.getZ() + 1 + (dir.getFrontOffsetZ() > 0 ? dir.getFrontOffsetZ() * blocksInFront : 0)));
    for (    Entity entity : entities) {
      if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
        if (entity instanceof EntityPlayer && entity.isSneaking()) {
          entity.motionX+=dir.getFrontOffsetX() * 0.025F;
          entity.motionY+=dir.getFrontOffsetY() * 0.05F;
          entity.motionZ+=dir.getFrontOffsetZ() * 0.025F;
        }
 else {
          entity.motionX+=dir.getFrontOffsetX() * 0.075F;
          entity.motionY+=dir.getFrontOffsetY() * 0.1F;
          entity.motionZ+=dir.getFrontOffsetZ() * 0.075F;
        }
        entity.fallDistance=0.0F;
      }
    }
  }
}",0.9669734704926908
22313,"@Override public AxisAlignedBB getBoundingBox(IBlockState state,IBlockAccess world,BlockPos pos){
  TileEntity te=world.getTileEntity(pos);
  if (te != null && te instanceof TileEntitySteamPipe) {
    TileEntitySteamPipe pipe=(TileEntitySteamPipe)te;
    if (pipe.disguiseBlock == null || pipe.disguiseBlock == Blocks.AIR) {
      float minX=BASE_MIN;
      float maxX=BASE_MAX;
      float minY=BASE_MIN;
      float maxY=BASE_MAX;
      float minZ=BASE_MIN;
      float maxZ=BASE_MAX;
      IBlockState actualState=getActualState(state,world,pos);
      int numDirs=pipe.getMyDirections().size();
      boolean hasNorth=actualState.getValue(NORTH);
      boolean hasSouth=actualState.getValue(SOUTH);
      boolean hasWest=actualState.getValue(WEST);
      boolean hasEast=actualState.getValue(EAST);
      boolean hasDown=actualState.getValue(DOWN);
      boolean hasUp=actualState.getValue(UP);
      if (hasNorth || (hasSouth && numDirs == 1)) {
        minZ=0F;
      }
      if (hasSouth || (hasNorth && numDirs == 1)) {
        maxZ=1F;
      }
      if (hasWest || (hasEast && numDirs == 1)) {
        minX=0F;
      }
      if (hasEast || (hasWest && numDirs == 1)) {
        maxX=1F;
      }
      if (hasDown || (hasUp && numDirs == 1)) {
        minY=0F;
      }
      if (hasUp || (hasDown && numDirs == 1)) {
        maxY=1F;
      }
      return new AxisAlignedBB(minX,minY,minZ,maxX,maxY,maxZ);
    }
  }
  return super.getBoundingBox(state,world,pos);
}","@Override public AxisAlignedBB getBoundingBox(IBlockState state,IBlockAccess world,BlockPos pos){
  TileEntity te=world.getTileEntity(pos);
  if (te != null && te instanceof TileEntitySteamPipe) {
    TileEntitySteamPipe pipe=(TileEntitySteamPipe)te;
    if (pipe.disguiseBlock == null || pipe.disguiseBlock == Blocks.AIR) {
      float minX=BASE_MIN;
      float maxX=BASE_MAX;
      float minY=BASE_MIN;
      float maxY=BASE_MAX;
      float minZ=BASE_MIN;
      float maxZ=BASE_MAX;
      IBlockState actualState=getActualState(state,world,pos);
      int numDirs=pipe.getMyDirections().size();
      boolean hasNorth=actualState.getValue(NORTH);
      boolean hasSouth=actualState.getValue(SOUTH);
      boolean hasWest=actualState.getValue(WEST);
      boolean hasEast=actualState.getValue(EAST);
      boolean hasDown=actualState.getValue(DOWN);
      boolean hasUp=actualState.getValue(UP);
      if (TileEntitySteamPipe.shouldStretchInDirection(hasNorth,hasSouth,numDirs)) {
        minZ=0F;
      }
      if (TileEntitySteamPipe.shouldStretchInDirection(hasSouth,hasNorth,numDirs)) {
        maxZ=1F;
      }
      if (TileEntitySteamPipe.shouldStretchInDirection(hasWest,hasEast,numDirs)) {
        minX=0F;
      }
      if (TileEntitySteamPipe.shouldStretchInDirection(hasEast,hasWest,numDirs)) {
        maxX=1F;
      }
      if (TileEntitySteamPipe.shouldStretchInDirection(hasDown,hasUp,numDirs)) {
        minY=0F;
      }
      if (TileEntitySteamPipe.shouldStretchInDirection(hasUp,hasDown,numDirs)) {
        maxY=1F;
      }
      return new AxisAlignedBB(minX,minY,minZ,maxX,maxY,maxZ);
    }
  }
  return super.getBoundingBox(state,world,pos);
}",0.8375796178343949
22314,"public void addTraceableCuboids(List<IndexedCuboid6> cuboids){
  float min=BlockPipe.BASE_MIN;
  float max=BlockPipe.BASE_MAX;
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  IBlockState actualState=worldObj.getBlockState(pos).getActualState(worldObj,pos);
{
    int connectDown=canConnectSide(EnumFacing.DOWN);
    if (connectDown > 0 || isPipeFacing(actualState,BlockPipe.DOWN,BlockPipe.UP)) {
      float bottom=connectDown == 2 ? -5F / 16F : 0F;
      cuboids.add(new IndexedCuboid6(0,new Cuboid6(x + min,y + bottom,z + min,x + max,y + max,z + max)));
    }
  }
{
    int connectUp=canConnectSide(EnumFacing.UP);
    if (connectUp > 0 || isPipeFacing(actualState,BlockPipe.UP,BlockPipe.DOWN)) {
      float top=connectUp == 2 ? 21F / 16F : 1F;
      cuboids.add(new IndexedCuboid6(1,new Cuboid6(x + min,y + min,z + min,x + max,y + top,z + max)));
    }
  }
{
    int connectNorth=canConnectSide(EnumFacing.NORTH);
    if (connectNorth > 0 || isPipeFacing(actualState,BlockPipe.NORTH,BlockPipe.SOUTH)) {
      float bottom=connectNorth == 2 ? -5F / 16F : 0F;
      cuboids.add(new IndexedCuboid6(2,new Cuboid6(x + min,y + min,z + bottom,x + max,y + max,z + max)));
    }
  }
{
    int connectSouth=canConnectSide(EnumFacing.SOUTH);
    if (connectSouth > 0 || isPipeFacing(actualState,BlockPipe.SOUTH,BlockPipe.NORTH)) {
      float top=connectSouth == 2 ? 21F / 16F : 1F;
      cuboids.add(new IndexedCuboid6(3,new Cuboid6(x + min,y + min,z + min,x + max,y + max,z + top)));
    }
  }
{
    int connectWest=canConnectSide(EnumFacing.WEST);
    if (connectWest > 0 || isPipeFacing(actualState,BlockPipe.WEST,BlockPipe.EAST)) {
      float bottom=connectWest == 2 ? -5F / 16F : 0F;
      cuboids.add(new IndexedCuboid6(4,new Cuboid6(x + bottom,y + min,z + min,x + max,y + max,z + max)));
    }
  }
{
    int connectEast=canConnectSide(EnumFacing.EAST);
    if (connectEast > 0 || isPipeFacing(actualState,BlockPipe.EAST,BlockPipe.WEST)) {
      float top=connectEast == 2 ? 21F / 16F : 1F;
      cuboids.add(new IndexedCuboid6(5,new Cuboid6(x + min,y + min,z + min,x + top,y + max,z + max)));
    }
  }
  cuboids.add(new IndexedCuboid6(6,new Cuboid6(x + min,y + min,z + min,x + 12F / 16F,y + 12F / 16F,z + 12F / 16F)));
}","public void addTraceableCuboids(List<IndexedCuboid6> cuboids){
  float min=BlockPipe.BASE_MIN;
  float max=BlockPipe.BASE_MAX;
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  IBlockState actualState=worldObj.getBlockState(pos).getActualState(worldObj,pos);
  boolean hasDown=actualState.getValue(BlockPipe.DOWN);
  boolean hasUp=actualState.getValue(BlockPipe.UP);
  boolean hasNorth=actualState.getValue(BlockPipe.NORTH);
  boolean hasSouth=actualState.getValue(BlockPipe.SOUTH);
  boolean hasWest=actualState.getValue(BlockPipe.WEST);
  boolean hasEast=actualState.getValue(BlockPipe.EAST);
  int numDirs=getMyDirections().size();
  if (shouldStretchInDirection(hasDown,hasUp,numDirs)) {
    int connectDown=canConnectSide(EnumFacing.DOWN);
    float bottom=connectDown == 2 ? -5F / 16F : 0F;
    cuboids.add(new IndexedCuboid6(0,new Cuboid6(x + min,y + bottom,z + min,x + max,y + max,z + max)));
  }
  if (shouldStretchInDirection(hasUp,hasDown,numDirs)) {
    int connectUp=canConnectSide(EnumFacing.UP);
    float top=connectUp == 2 ? 21F / 16F : 1F;
    cuboids.add(new IndexedCuboid6(1,new Cuboid6(x + min,y + min,z + min,x + max,y + top,z + max)));
  }
  if (shouldStretchInDirection(hasNorth,hasSouth,numDirs)) {
    int connectNorth=canConnectSide(EnumFacing.NORTH);
    float bottom=connectNorth == 2 ? -5F / 16F : 0F;
    cuboids.add(new IndexedCuboid6(2,new Cuboid6(x + min,y + min,z + bottom,x + max,y + max,z + max)));
  }
  if (shouldStretchInDirection(hasSouth,hasNorth,numDirs)) {
    int connectSouth=canConnectSide(EnumFacing.SOUTH);
    float top=connectSouth == 2 ? 21F / 16F : 1F;
    cuboids.add(new IndexedCuboid6(3,new Cuboid6(x + min,y + min,z + min,x + max,y + max,z + top)));
  }
  if (shouldStretchInDirection(hasWest,hasEast,numDirs)) {
    int connectWest=canConnectSide(EnumFacing.WEST);
    float bottom=connectWest == 2 ? -5F / 16F : 0F;
    cuboids.add(new IndexedCuboid6(4,new Cuboid6(x + bottom,y + min,z + min,x + max,y + max,z + max)));
  }
  if (shouldStretchInDirection(hasEast,hasWest,numDirs)) {
    int connectEast=canConnectSide(EnumFacing.EAST);
    float top=connectEast == 2 ? 21F / 16F : 1F;
    cuboids.add(new IndexedCuboid6(5,new Cuboid6(x + min,y + min,z + min,x + top,y + max,z + max)));
  }
  cuboids.add(new IndexedCuboid6(6,new Cuboid6(x + min,y + min,z + min,x + 12F / 16F,y + 12F / 16F,z + 12F / 16F)));
}",0.3370883882149046
22315,"@Mod.EventHandler public void load(FMLInitializationEvent event){
  NetworkRegistry.INSTANCE.registerGuiHandler(this,new SteamcraftGuiHandler());
  MinecraftForge.EVENT_BUS.register(new SteamcraftEventHandler());
  MinecraftForge.EVENT_BUS.register(new PhobicCoatingHandler());
  MinecraftForge.EVENT_BUS.register(new SteamcraftTickHandler());
  MinecraftForge.EVENT_BUS.register(new PhobicCoatingHandler());
  if (event.getSide() == Side.CLIENT) {
    MinecraftForge.EVENT_BUS.register(new ExosuitModelCache());
  }
  proxy.registerRenderers();
  proxy.registerHotkeys();
  for (  BlockCategories category : BlockCategories.values()) {
    category.getCategory().recipes();
  }
  for (  ItemCategories category : ItemCategories.values()) {
    category.getCategory().recipes();
  }
  STEAM_ENGINEER_PROFESSION=new VillagerRegistry.VillagerProfession(""String_Node_Str"",""String_Node_Str"");
  STEAM_ENGINEER_CAREER=new SteamEngineerCareer();
  VillagerRegistry.instance().register(STEAM_ENGINEER_PROFESSION);
  VillagerRegistry.instance().registerVillageCreationHandler(new SteamWorkshopCreationHandler());
  for (  MiscellaneousCategories category : MiscellaneousCategories.values()) {
    if (category.isEnabled()) {
      category.getCategory().init();
    }
  }
}","@Mod.EventHandler public void load(FMLInitializationEvent event){
  NetworkRegistry.INSTANCE.registerGuiHandler(this,new SteamcraftGuiHandler());
  MinecraftForge.EVENT_BUS.register(new SteamcraftEventHandler());
  MinecraftForge.EVENT_BUS.register(new PhobicCoatingHandler());
  MinecraftForge.EVENT_BUS.register(new SteamcraftTickHandler());
  MinecraftForge.EVENT_BUS.register(new PhobicCoatingHandler());
  if (event.getSide() == Side.CLIENT) {
    MinecraftForge.EVENT_BUS.register(new ExosuitModelCache());
  }
  proxy.registerRenderers();
  proxy.registerHotkeys();
  for (  BlockCategories category : BlockCategories.values()) {
    category.getCategory().recipes();
  }
  for (  ItemCategories category : ItemCategories.values()) {
    category.getCategory().recipes();
  }
  STEAM_ENGINEER_PROFESSION=new VillagerRegistry.VillagerProfession(MOD_ID + ""String_Node_Str"",MOD_ID + ""String_Node_Str"");
  STEAM_ENGINEER_CAREER=new SteamEngineerCareer();
  VillagerRegistry.instance().register(STEAM_ENGINEER_PROFESSION);
  VillagerRegistry.instance().registerVillageCreationHandler(new SteamWorkshopCreationHandler());
  for (  MiscellaneousCategories category : MiscellaneousCategories.values()) {
    if (category.isEnabled()) {
      category.getCategory().init();
    }
  }
}",0.9929356357927788
22316,"@Mod.EventHandler public void postInit(FMLPostInitializationEvent event){
  if (Config.enablePipe) {
    MinecraftForge.EVENT_BUS.register(SteamNetworkBlocks.Blocks.PIPE.getBlock());
  }
  ItemSmashedOre iso=(ItemSmashedOre)MetalItems.Items.SMASHED_ORE.getItem();
  iso.registerDusts();
  iso.addSmelting();
  iso.registerDusts();
  SteamcraftBook.registerBookResearch();
  long start=System.currentTimeMillis();
  String[] ores=OreDictionary.getOreNames();
  for (  String s : ores) {
    List<ItemStack> stacks=OreDictionary.getOres(s);
    for (    ItemStack stack : stacks) {
      OreDictHelper.initializeOreDicts(s,stack);
    }
  }
  long end=System.currentTimeMillis();
  int time=(int)(end - start);
  FMLLog.info(""String_Node_Str"",time);
  DrillHeadMaterial.registerDefaults();
  ((ToolUpgradeItems)ItemCategories.TOOL_UPGRADES.getCategory()).postInit();
  SteamcraftBook.registerSteamTools();
  for (  MiscellaneousCategories category : MiscellaneousCategories.values()) {
    if (category.isEnabled()) {
      category.getCategory().postInit();
    }
  }
}","@Mod.EventHandler public void postInit(FMLPostInitializationEvent event){
  if (Config.enablePipe) {
    MinecraftForge.EVENT_BUS.register(SteamNetworkBlocks.Blocks.PIPE.getBlock());
  }
  ItemSmashedOre iso=(ItemSmashedOre)MetalItems.Items.SMASHED_ORE.getItem();
  iso.registerDusts();
  iso.addSmelting();
  iso.registerDusts();
  SteamcraftBook.registerBookResearch();
  long start=System.currentTimeMillis();
  String[] ores=OreDictionary.getOreNames();
  for (  String s : ores) {
    List<ItemStack> stacks=OreDictionary.getOres(s);
    for (    ItemStack stack : stacks) {
      OreDictHelper.initializeOreDicts(s,stack);
    }
  }
  long end=System.currentTimeMillis();
  int time=(int)(end - start);
  FMLLog.info(""String_Node_Str"",time);
  RecipeSorter.register(MOD_ID + ""String_Node_Str"",DrillHeadRecipe.class,RecipeSorter.Category.SHAPED,""String_Node_Str"");
  DrillHeadMaterial.registerDefaults();
  ((ToolUpgradeItems)ItemCategories.TOOL_UPGRADES.getCategory()).postInit();
  SteamcraftBook.registerSteamTools();
  for (  MiscellaneousCategories category : MiscellaneousCategories.values()) {
    if (category.isEnabled()) {
      category.getCategory().postInit();
    }
  }
}",0.9459698848538528
22317,"public static void registerGadgets(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  if (Config.enableWrench) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.wrench)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSpyglass) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.spyglass)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSurvivalist) {
    if (CrossMod.BAUBLES) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.survivalist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
 else {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.survivalist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableCanister) {
    ItemStack output=new ItemStack(Items.DIAMOND_SWORD);
    output.setTagCompound(new NBTTagCompound());
    output.getTagCompound().setInteger(""String_Node_Str"",0);
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.canister)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",true,output,Items.DIAMOND_SWORD,SteamcraftItems.canister));
  }
  if (Config.enableTopHat) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.tophatNoEmerald)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEmeraldHat) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.tophat)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableGoggles) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.goggles),new ItemStack(SteamcraftItems.monacle)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSteamCell) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcellEmpty),new ItemStack(SteamcraftItems.steamcellFull)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSteamCellBauble && CrossMod.BAUBLES) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcellBauble)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
}","public static void registerGadgets(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  if (Config.enableWrench) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(WRENCH.getItem())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSpyglass) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SPYGLASS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSurvivalist) {
    if (CrossMod.BAUBLES) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SURVIVALIST_TOOLKIT.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
 else {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SURVIVALIST_TOOLKIT.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableCanister) {
    ItemStack output=new ItemStack(Items.DIAMOND_SWORD);
    output.setTagCompound(new NBTTagCompound());
    output.getTagCompound().setInteger(""String_Node_Str"",0);
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(ITEM_CANISTER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",true,output,Items.DIAMOND_SWORD,ITEM_CANISTER.getItem()));
  }
  if (Config.enableTopHat) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(TOP_HAT.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEmeraldHat) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(ENTREPRENEUR_TOP_HAT.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableGoggles) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(GOGGLES.getItem()),new ItemStack(MONOCLE.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSteamCell) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_CELL_EMPTY.getItem()),new ItemStack(STEAM_CELL_FULL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSteamCellBauble && CrossMod.BAUBLES) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_CELL_FILLER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
}",0.8315018315018315
22318,"public static void registerSteamPower(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.boiler)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (Config.enableFlashBoiler) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.flashBoiler)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pipe)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  if (Config.enableRuptureDisc) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.ruptureDisc)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHorn) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.horn)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableGauge) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.gauge)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.tank)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(Items.BOWL)));
  SteamcraftRegistry.bookRecipes.put(new ItemStack(SteamcraftBlocks.tank,1,1),MutablePair.of(""String_Node_Str"",0));
  if (Config.enableCharger) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.charger)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableChargingPad && Config.enableCharger) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.chargingPad)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHeater) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.heater)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableMortar && Config.enableAstrolabe) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.itemMortar)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHammer) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.hammer)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enablePump) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pump)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSmasher) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.smasher)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableThumper) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.thumper)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableFan) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.fan)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    if (Config.enableVacuum) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.vacuum)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableFluidSteamConverter) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.fluidSteamConverter)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""));
  }
}","public static void registerSteamPower(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(BOILER.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (Config.enableFlashBoiler) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(FLASH_BOILER.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(PIPE.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  if (Config.enableRuptureDisc) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(RUPTURE_DISC.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHorn) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_WHISTLE.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableGauge) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_GAUGE.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(TANK.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(Items.BOWL)));
  SteamcraftRegistry.bookRecipes.put(new ItemStack(TANK.getBlock(),1,1),MutablePair.of(""String_Node_Str"",0));
  if (Config.enableCharger) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_FILLER.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableChargingPad && Config.enableCharger) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(FILLING_PAD.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHeater) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_HEATER.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableMortar && Config.enableAstrolabe) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(ITEM_MORTAR.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHammer) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_HAMMER.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enablePump) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(ARCHIMEDES_SCREW.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSmasher) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(ROCK_SMASHER.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableThumper) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(THUMPER.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableFan) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(FAN.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    if (Config.enableVacuum) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(VACUUM.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableFluidSteamConverter) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(PRESSURE_CONVERTER.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""));
  }
}",0.9481756130445774
22319,"public static void registerFirearms(){
  if (Config.enableFirearms || Config.enableRL) {
    SteamcraftRegistry.addCategory(""String_Node_Str"");
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcraftCrafting,1,1),new ItemStack(SteamcraftItems.steamcraftCrafting,1,2),new ItemStack(SteamcraftItems.steamcraftCrafting,1,3),new ItemStack(SteamcraftItems.steamcraftCrafting,1,4)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableFirearms) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.musket)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableSpyglass) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.spyglass)));
    }
    if (Config.enableEnhancementAblaze) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementAblaze)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSpeedloader) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementSpeedloader)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.blunderbuss)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEnhancementAblaze) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementAblaze)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSpeedloader) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementSpeedloader)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementRecoil) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementRecoil)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.pistol)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEnhancementRevolver) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementRevolver)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSilencer) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementSilencer)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSpeedy) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementSpeedy)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableRL) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.rocketLauncher)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEnhancementFastRockets) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementFastRockets)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementAmmo) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementAmmo)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementAirStrike) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enhancementAirStrike)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableRocket) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.rocket)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableRocketConcussive) {
      if (Config.enableRocket) {
        SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.rocketConcussive)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
      }
 else {
        SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.rocketConcussive)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      }
    }
    if (Config.enableRocketMining) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.rocketMiner)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
}","public static void registerFirearms(){
  if (Config.enableFirearms || Config.enableRL) {
    SteamcraftRegistry.addCategory(""String_Node_Str"");
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",BLUNDERBUSS_BARREL.createItemStack(),FLINTLOCK.createItemStack(),GUN_STOCK.createItemStack(),IRON_BARREL.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableFirearms) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(MUSKET.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableSpyglass) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SPYGLASS.getItem())));
    }
    if (Config.enableEnhancementAblaze) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BLAZE_BARREL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSpeedloader) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BOLT_ACTION.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(BLUNDERBUSS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEnhancementAblaze) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BLAZE_BARREL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSpeedloader) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BOLT_ACTION.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementRecoil) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(RECOIL_PAD.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(PISTOL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEnhancementRevolver) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(REVOLVER_CHAMBER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSilencer) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(MAKESHIFT_SUPPRESSOR.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementSpeedy) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BREECH.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableRL) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(ROCKET_LAUNCHER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    if (Config.enableEnhancementFastRockets) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(STREAMLINED_BARREL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementAmmo) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(EXTENDED_MAGAZINE.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableEnhancementAirStrike) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(AIR_STRIKE_CONVERSION_KIT.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableRocket) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(ROCKET.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableRocketConcussive) {
      if (Config.enableRocket) {
        SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(CONCUSSIVE_ROCKET.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
      }
 else {
        SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(CONCUSSIVE_ROCKET.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      }
    }
    if (Config.enableRocketMining) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(MINING_ROCKET.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
}",0.3001599025355973
22320,"public static void registerCasting(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  if (Config.enableCrucible) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.crucible)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableHellCrucible) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.hellCrucible)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableMold) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.mold)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.plateMold),new ItemStack(SteamcraftItems.ingotMold),new ItemStack(SteamcraftItems.nuggetMold)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcraftPlate,1,0),new ItemStack(SteamcraftItems.steamcraftPlate,1,1),new ItemStack(SteamcraftItems.steamcraftPlate,1,2),new ItemStack(SteamcraftItems.steamcraftPlate,1,3)));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcraftIngot,1,2)),new BookPageAlloy(""String_Node_Str"",SteamcraftRecipes.liquidBrass,SteamcraftRecipes.liquidBrass.recipe));
  if (Config.enableCrucible) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcraftIngot,1,3)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageDip(""String_Node_Str"",SteamcraftRecipes.liquidGold,1,new ItemStack(Items.IRON_INGOT),new ItemStack(SteamcraftItems.steamcraftIngot,1,3)));
  }
}","public static void registerCasting(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  if (Config.enableCrucible) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(CRUCIBLE.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableHellCrucible) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(NETHER_CRUCIBLE.getBlock())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
  }
  if (Config.enableMold) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(MOLD.getBlock())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(PLATE_MOLD.getItem()),new ItemStack(INGOT_MOLD.getItem()),new ItemStack(NUGGET_MOLD.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",COPPER_PLATE.createItemStack(),ZINC_PLATE.createItemStack(),GOLD_PLATE.createItemStack(),IRON_PLATE.createItemStack(),BRASS_PLATE.createItemStack(),GILDED_IRON_PLATE.createItemStack()));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",BRASS_INGOT.createItemStack()),new BookPageAlloy(""String_Node_Str"",BRASS_LIQUID.getLiquid(),BRASS_LIQUID.getLiquid().recipe));
  if (Config.enableCrucible) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",GILDED_IRON_INGOT.createItemStack()),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageDip(""String_Node_Str"",GOLD_LIQUID.getLiquid(),1,new ItemStack(Items.IRON_INGOT),GILDED_IRON_PLATE.createItemStack()));
  }
}",0.4347826086956521
22321,"public static void registerSteamTools(){
  if (!Config.enableSteamTools) {
    return;
  }
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamDrill),new ItemStack(SteamcraftItems.steamAxe),new ItemStack(SteamcraftItems.steamShovel)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  ArrayList<String> drillMatsArray=new ArrayList<>();
  for (  DrillHeadMaterial material : DrillHeadMaterial.materials.values()) {
    if (I18n.canTranslate(material.locName)) {
      drillMatsArray.add(I18n.translateToLocal(material.locName));
    }
 else {
      drillMatsArray.add(material.materialName);
    }
  }
  StringBuilder drillMats=new StringBuilder();
  String delimiter=I18n.translateToLocal(""String_Node_Str"");
  Iterator iter=drillMatsArray.iterator();
  while (iter.hasNext()) {
    drillMats.append(iter.next());
    if (iter.hasNext()) {
      drillMats.append(delimiter);
    }
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new Object[]{drillMats.toString()},true,new ItemStack(SteamcraftItems.drillHead)),new BookPage(""String_Node_Str""));
  if (Config.enableFortune) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.fortuneUpgrade)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableBigDrill) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.bigDrill)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableBattleDrill) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.battleDrill)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enablePreciseCuttingHead) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.preciseCuttingHead)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableStoneGrinder) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.stoneGrinder)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableThermalDrill) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.thermalDrill)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableChargePlacer) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.chargePlacer)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableInternalProcessingUnit) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.internalProcessingUnit)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableForestFire) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.forestFire)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableTreeFeller) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.treeFeller)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableLeafBlower) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.leafBlower)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableChainsaw) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.chainsaw)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableBackhoe) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.backhoe)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableCultivator) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.cultivator)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableRotaryBlades) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.rotaryBlades)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableSifter) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.sifter)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableOverclocker) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.overclocker)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableAutosmelting) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.autosmelting)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableTheVoid) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.theVoid)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
}","public static void registerSteamTools(){
  if (!Config.enableSteamTools) {
    return;
  }
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(STEAM_DRILL.getItem()),new ItemStack(STEAM_SAW.getItem()),new ItemStack(STEAM_SHOVEL.getItem())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  ArrayList<String> drillMatsArray=new ArrayList<>();
  for (  DrillHeadMaterial material : DrillHeadMaterial.materials.values()) {
    String loc=material.locName;
    String string=I18n.hasKey(loc) ? I18n.format(loc) : material.materialName;
    drillMatsArray.add(string);
  }
  StringBuilder drillMats=new StringBuilder();
  String delimiter=I18n.format(""String_Node_Str"");
  Iterator iter=drillMatsArray.iterator();
  while (iter.hasNext()) {
    drillMats.append(iter.next());
    if (iter.hasNext()) {
      drillMats.append(delimiter);
    }
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new Object[]{drillMats.toString()},true,new ItemStack(DRILL_HEAD.getItem())),new BookPage(""String_Node_Str""));
  if (Config.enableFortune) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(MULTIPLICATIVE_RESONATOR.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableBigDrill) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BIG_DRILL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableBattleDrill) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BATTLE_DRILL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enablePreciseCuttingHead) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(PRECISE_CUTTING_HEAD.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableStoneGrinder) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(STONE_GRINDER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableThermalDrill) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(THERMAL_DRILL.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableChargePlacer) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(CHARGE_PLACER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableInternalProcessingUnit) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(INTERNAL_PROCESSING_UNIT.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableForestFire) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(FOREST_FIRE.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableTreeFeller) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(TIMBER_CHAIN.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableLeafBlower) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(LEAF_BLOWER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableChainsaw) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(CHAINSAW.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableBackhoe) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(BACKHOE.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableCultivator) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(CULTIVATOR.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableRotaryBlades) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(ROTARY_BLADES.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableSifter) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SIFTER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
  if (Config.enableOverclocker) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(OVERCLOCKER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableAutosmelting) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(EXOTHERMIC_PROJECTOR.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableTheVoid) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(THE_VOID.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
}",0.3736798221234019
22322,"public static void registerExosuit(){
  if (Config.enableExosuit && Config.enableEngineering) {
    SteamcraftRegistry.addCategory(""String_Node_Str"");
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exoArmorHead),new ItemStack(SteamcraftItems.exoArmorBody),new ItemStack(SteamcraftItems.exoArmorLegs),new ItemStack(SteamcraftItems.exoArmorFeet)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    ItemStack[] stacks=new ItemStack[4];
    for (int i=0; i < 4; i++) {
      ItemStack stack=new ItemStack(SteamcraftItems.exoArmorBody);
      stack.setTagCompound(new NBTTagCompound());
      ItemStack plate=null;
      Collection<ExosuitPlate> values=SteamcraftRegistry.plates.values();
      Object item=values.toArray(new ExosuitPlate[values.size()])[i].getItem();
      if (item instanceof String) {
        if (OreDictionary.getOres((String)item).size() > 0) {
          plate=OreDictionary.getOres((String)item).get(0);
        }
      }
 else       if (item instanceof ItemStack) {
        plate=(ItemStack)item;
      }
      ((ItemExosuitArmor)stack.getItem()).setInventorySlotContents(stack,1,plate);
      stacks[i]=stack;
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.tank)));
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftBlocks.tank)));
    if (Config.enableReinforcedTank) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.reinforcedTank)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableUberReinforcedTank) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.uberReinforcedTank)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",stacks),new BookPageText(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableCopperPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.exosuitPlate,1,0)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableIronPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.exosuitPlate,1,2)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableBrassPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.exosuitPlate,1,4)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableGoldPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.exosuitPlate,1,3)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableGildedIronPlate) {
      ItemStack is=new ItemStack(SteamcraftItems.exosuitPlate,1,14);
      BookPageItem itemPage=new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,is);
      BookPageCrafting craftingPage=new BookPageCrafting(""String_Node_Str"",""String_Node_Str"");
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",itemPage,craftingPage);
    }
    if (Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.exosuitPlate,1,11)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    ItemStack[] stacks2=new ItemStack[4];
    for (int i=0; i < 4; i++) {
      ItemStack stack=new ItemStack(SteamcraftItems.exoArmorBody);
      stack.setTagCompound(new NBTTagCompound());
      ItemStack dye=new ItemStack(Items.DYE,1,i);
      ((ItemExosuitArmor)stack.getItem()).setInventorySlotContents(stack,2,dye);
      stacks2[i]=stack;
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",stacks2));
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(Items.DYE,1,0),new ItemStack(Items.DYE,1,1),new ItemStack(Items.DYE,1,2),new ItemStack(Items.DYE,1,3)));
    if (Config.enableEnderShroud) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.enderShroud)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableTopHat) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.tophatNoEmerald),new ItemStack(SteamcraftItems.tophat)),new BookPage(""String_Node_Str""));
    }
    if (Config.enableFrequencyShifter) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.frequencyShifter)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableGoggles) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.goggles),new ItemStack(SteamcraftItems.monacle)),new BookPage(""String_Node_Str""));
    }
    if (Config.enableRebreather) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.rebreather)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableDragonRoar) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.dragonRoar)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableJetpack) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.jetpack)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableWings) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.wings)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enablePowerFist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.powerFist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableExtendoFist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.extendoFist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enablePitonDeployer) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.pitonDeployer)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enablePistonPush) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.pistonPush)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableThrusters) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.thrusters)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableCanningMachine) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.canner)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableReloadingHolsters) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.reloadingHolsters)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableRunAssist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.runAssist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableStealthUpgrade) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.stealthUpgrade)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableFallAssist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.fallAssist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableAnchorHeels) {
      boolean lead=Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0 && !Config.enableAnchorAnvilRecipe;
      String research=lead ? ""String_Node_Str"" : ""String_Node_Str"";
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",research,true,new ItemStack(SteamcraftItems.anchorHeels)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableDoubleJump) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.doubleJump)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableHydrophobic) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.coatingsHydrophobic)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enablePyrophobic) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.coatingsPyrophobic)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableJumpAssist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(SteamcraftItems.jumpAssist)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
}","public static void registerExosuit(){
  if (Config.enableExosuit && Config.enableEngineering) {
    SteamcraftRegistry.addCategory(""String_Node_Str"");
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(EXOSUIT_HEADPIECE.getItem()),new ItemStack(EXOSUIT_CHESTPIECE.getItem()),new ItemStack(EXOSUIT_LEGPIECE.getItem()),new ItemStack(EXOSUIT_FOOTPIECE.getItem())),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    ItemStack[] stacks=new ItemStack[4];
    for (int i=0; i < 4; i++) {
      ItemStack stack=new ItemStack(EXOSUIT_CHESTPIECE.getItem());
      stack.setTagCompound(new NBTTagCompound());
      ItemStack plate=null;
      Collection<ExosuitPlate> values=SteamcraftRegistry.plates.values();
      Object item=values.toArray(new ExosuitPlate[values.size()])[i].getItem();
      if (item instanceof String) {
        if (OreDictionary.getOres((String)item).size() > 0) {
          plate=OreDictionary.getOres((String)item).get(0);
        }
      }
 else       if (item instanceof ItemStack) {
        plate=(ItemStack)item;
      }
      ((ItemExosuitArmor)stack.getItem()).setInventorySlotContents(stack,1,plate);
      stacks[i]=stack;
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(TANK.getBlock())));
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(TANK.getBlock())));
    if (Config.enableReinforcedTank) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(REINFORCED_TANK.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableUberReinforcedTank) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(UBER_REINFORCED_TANK.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",stacks),new BookPageText(""String_Node_Str"",""String_Node_Str""));
    if (Config.enableCopperPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,COPPER_EXO.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableIronPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,IRON_EXO.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableBrassPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,BRASS_EXO.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableGoldPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,GOLD_EXO.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableGildedIronPlate) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,GILDED_IRON_EXO.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,LEAD_EXO.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    ItemStack[] stacks2=new ItemStack[4];
    for (int i=0; i < 4; i++) {
      ItemStack stack=new ItemStack(EXOSUIT_CHESTPIECE.getItem());
      stack.setTagCompound(new NBTTagCompound());
      ItemStack dye=new ItemStack(Items.DYE,1,i);
      ((ItemExosuitArmor)stack.getItem()).setInventorySlotContents(stack,2,dye);
      stacks2[i]=stack;
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",stacks2));
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(Items.DYE,1,0),new ItemStack(Items.DYE,1,1),new ItemStack(Items.DYE,1,2),new ItemStack(Items.DYE,1,3)));
    if (Config.enableEnderShroud) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(ENDER_SHROUD.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableTopHat) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(TOP_HAT.getItem()),new ItemStack(ENTREPRENEUR_TOP_HAT.getItem())),new BookPage(""String_Node_Str""));
    }
    if (Config.enableFrequencyShifter) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(FREQUENCY_SHIFTER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableGoggles) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(GOGGLES.getItem()),new ItemStack(MONOCLE.getItem())),new BookPage(""String_Node_Str""));
    }
    if (Config.enableRebreather) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(REBREATHER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableDragonRoar) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(DRAGON_ROAR.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableJetpack) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(JETPACK.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableWings) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(WINGS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enablePowerFist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(POWER_FIST.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableExtendoFist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(EXTENDO_FIST.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enablePitonDeployer) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(PITON_DEPLOYER.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enablePistonPush) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(PISTON_PUSH.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableThrusters) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(THRUSTERS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableCanningMachine) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(CANNING_MACHINE.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableReloadingHolsters) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(RELOADING_HOLSTERS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableRunAssist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(RUN_ASSIST.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableStealthUpgrade) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(STEALTH.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableFallAssist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(FALL_ASSIST.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableAnchorHeels) {
      boolean lead=Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0 && !Config.enableAnchorAnvilRecipe;
      String research=lead ? ""String_Node_Str"" : ""String_Node_Str"";
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",research,true,new ItemStack(ANCHOR_HEELS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"");
    if (Config.enableDoubleJump) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(DOUBLE_JUMP.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableHydrophobic) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(HYDROPHOBIC_COATINGS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enablePyrophobic) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(PYROPHOBIC_COATINGS.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
    }
    if (Config.enableJumpAssist) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",true,new ItemStack(JUMP_ASSIST.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
}",0.8022635148693663
22323,"@Override public boolean onBlockActivated(World world,int par2,int par3,int par4,EntityPlayer par5EntityPlayer,int par6,float par7,float par8,float par9){
  return true;
}","@Override public boolean onBlockActivated(World world,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,ItemStack heldItem,EnumFacing side,float hitX,float hitY,float hitZ){
  return true;
}",0.5978835978835979
22324,"@Override public boolean isAir(IBlockAccess world,int x,int y,int z){
  return true;
}","@Override public boolean isAir(IBlockState state,IBlockAccess world,BlockPos pos){
  return true;
}",0.7567567567567568
22325,"@Override public boolean canHarvestBlock(EntityPlayer player,int meta){
  return false;
}","@Override public boolean canHarvestBlock(IBlockAccess world,BlockPos pos,EntityPlayer player){
  return false;
}",0.7960199004975125
22326,"public BlockDummy(){
  super(Material.iron);
  setHardness(50.0F);
  setLightOpacity(0);
}","public BlockDummy(){
  super(Material.IRON);
  setHardness(50.0F);
  setLightOpacity(0);
}",0.9555555555555556
22327,"@SubscribeEvent public void burstZincPlate(LivingHurtEvent event){
  EntityLivingBase entity=event.getEntityLiving();
  float amount=event.getAmount();
  if (!invalidSources.contains(event.getSource())) {
    if (entity instanceof EntityPlayer && hasPower(entity,ZINC_CONSUMPTION)) {
      EntityPlayer player=(EntityPlayer)entity;
      float health=player.getHealth();
      float maxHealth=player.getMaxHealth();
      float halfOfMax=maxHealth / 2;
      if (amount >= halfOfMax || health <= halfOfMax) {
        ItemStack stackWithPlate=null;
        boolean hasZincPlate=false;
        for (int i=1; i < 5; i++) {
          ItemStack equipment=entity.getItemStackFromSlot(ItemStackUtility.getSlotFromIndex(i));
          if (equipment != null) {
            Item item=equipment.getItem();
            if (item instanceof ItemExosuitArmor) {
              ItemExosuitArmor armor=(ItemExosuitArmor)item;
              if (armor.hasPlates(equipment) && UtilPlates.getPlate(equipment.getTagCompound().getString(""String_Node_Str"")).getIdentifier().equals(""String_Node_Str"")) {
                stackWithPlate=equipment;
                hasZincPlate=true;
                break;
              }
            }
          }
        }
        if (hasZincPlate) {
          ItemStack zincPlates=ExosuitUpgradeItems.PlateItems.ZINC.createItemStack(2);
          World world=player.worldObj;
          drainSteam(player.getItemStackFromSlot(EntityEquipmentSlot.CHEST),ZINC_CONSUMPTION);
          UtilPlates.removePlate(stackWithPlate);
          EntityItem entityItem=new EntityItem(world,player.posX,player.posY,player.posZ,zincPlates);
          world.spawnEntityInWorld(entityItem);
          player.setHealth(health);
          player.performHurtAnimation();
          world.playSound(player.posX,player.posY,player.posZ,Steamcraft.SOUND_HISS,SoundCategory.PLAYERS,2F,0.9F,false);
          event.setCanceled(true);
        }
      }
    }
  }
}","@SubscribeEvent public void burstZincPlate(LivingHurtEvent event){
  EntityLivingBase entity=event.getEntityLiving();
  float amount=event.getAmount();
  if (!invalidSources.contains(event.getSource())) {
    if (entity instanceof EntityPlayer && hasPower(entity,ZINC_CONSUMPTION)) {
      EntityPlayer player=(EntityPlayer)entity;
      float health=player.getHealth();
      float maxHealth=player.getMaxHealth();
      float halfOfMax=maxHealth / 2;
      if (amount >= halfOfMax || health <= halfOfMax) {
        ItemStack stackWithPlate=null;
        boolean hasZincPlate=false;
        for (int i=1; i < 5; i++) {
          ItemStack equipment=entity.getItemStackFromSlot(ItemStackUtility.getSlotFromIndex(i));
          if (equipment != null) {
            Item item=equipment.getItem();
            if (item instanceof ItemExosuitArmor) {
              ItemExosuitArmor armor=(ItemExosuitArmor)item;
              if (armor.hasPlates(equipment) && UtilPlates.getPlate(equipment.getTagCompound().getString(""String_Node_Str"")).getIdentifier().equals(""String_Node_Str"")) {
                stackWithPlate=equipment;
                hasZincPlate=true;
                break;
              }
            }
          }
        }
        if (hasZincPlate) {
          ItemStack zincPlates=ExosuitUpgradeItems.PlateItems.ZINC_EXO.createItemStack(2);
          World world=player.worldObj;
          drainSteam(player.getItemStackFromSlot(EntityEquipmentSlot.CHEST),ZINC_CONSUMPTION);
          UtilPlates.removePlate(stackWithPlate);
          EntityItem entityItem=new EntityItem(world,player.posX,player.posY,player.posZ,zincPlates);
          world.spawnEntityInWorld(entityItem);
          player.setHealth(health);
          player.performHurtAnimation();
          world.playSound(player.posX,player.posY,player.posZ,Steamcraft.SOUND_HISS,SoundCategory.PLAYERS,2F,0.9F,false);
          event.setCanceled(true);
        }
      }
    }
  }
}",0.998971193415638
22328,"@Override public void recipes(){
  for (  Items item : Items.LOOKUP) {
switch (item) {
case JETPACK:
{
        BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'g',SteamNetworkBlocks.Blocks.STEAM_GAUGE.getBlock(),'t',INGOT_BRASS));
        BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'g',SteamNetworkBlocks.Blocks.STEAM_GAUGE.getBlock(),'t',PLATE_BRASS));
        break;
      }
case WINGS:
{
      BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',INGOT_BRASS,'c',PLATE_COPPER));
      BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',PLATE_BRASS,'c',PLATE_COPPER));
      break;
    }
case POWER_FIST:
{
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',NUGGET_IRON,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',NUGGET_BRASS));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',PLATE_IRON,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',NUGGET_BRASS));
    break;
  }
case EXTENDO_FIST:
{
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',INGOT_IRON,'b',NUGGET_BRASS));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',PLATE_IRON,'b',NUGGET_BRASS));
  break;
}
case THRUSTERS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'t',INGOT_BRASS,'n',NUGGET_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'t',PLATE_BRASS,'n',NUGGET_BRASS));
break;
}
case FALL_ASSIST:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',SLIMEBALL_ORE));
break;
}
case JUMP_ASSIST:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',PLATE_BRASS));
break;
}
case RUN_ASSIST:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',PLATE_BRASS));
break;
}
case DOUBLE_JUMP:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",'v',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock(),'s',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",'v',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock(),'s',PLATE_BRASS));
break;
}
case CANNING_MACHINE:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',INGOT_BRASS,'n',NUGGET_IRON,'i',INGOT_IRON));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',PLATE_BRASS,'n',NUGGET_IRON,'i',PLATE_IRON));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',INGOT_BRASS,'n',NUGGET_IRON,'i',INGOT_IRON));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',PLATE_BRASS,'n',NUGGET_IRON,'i',PLATE_IRON));
break;
}
case PITON_DEPLOYER:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'i',NUGGET_IRON));
break;
}
case STEALTH:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'w',WOOL,'s',STRING));
break;
}
case ENDER_SHROUD:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'g',GLASS,'e',ENDER_PEARL));
break;
}
case REINFORCED_TANK:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',SteamNetworkBlocks.Blocks.TANK.getBlock(),'p',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',SteamNetworkBlocks.Blocks.TANK.getBlock(),'p',PLATE_BRASS));
break;
}
case UBER_REINFORCED_TANK:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',Items.REINFORCED_TANK.getItem(),'p',INGOT_BRASS,'b',BLOCK_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',Items.REINFORCED_TANK.getItem(),'p',PLATE_BRASS,'b',BLOCK_BRASS));
break;
}
case REBREATHER:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'p',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock(),'t',SteamNetworkBlocks.Blocks.TANK.getBlock(),'c',new ItemStack(CARPET,1,OreDictionary.WILDCARD_VALUE)));
break;
}
case HYDROPHOBIC_COATINGS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'z',PLATE_ZINC,'b',LEATHER_BOOTS,'h',SteamMachineryBlocks.Blocks.STEAM_HEATER.getBlock(),'s',SLIMEBALL_ORE));
break;
}
case PYROPHOBIC_COATINGS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'c',PLATE_COPPER,'b',LEATHER_BOOTS,'h',SteamMachineryBlocks.Blocks.STEAM_HEATER.getBlock(),'m',MAGMA_CREAM));
break;
}
case ANCHOR_HEELS:
{
if (Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0 && !Config.enableAnchorAnvilRecipe) {
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(item.getItem()),""String_Node_Str"",""String_Node_Str"",'p',PLATE_LEAD,'e',PlateItems.LEAD.createItemStack()));
}
 else {
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(item.getItem()),""String_Node_Str"",""String_Node_Str"",'p',PLATE_IRON,'e',PlateItems.IRON.createItemStack(),'a',ANVIL));
}
break;
}
case PISTON_PUSH:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'n',NUGGET_BRASS,'p',PISTON,'b',CraftingComponentItems.Items.BRASS_PISTON));
break;
}
case RELOADING_HOLSTERS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'b',PLATE_BRASS,'c',FirearmUpgradeItems.Items.REVOLVER_CHAMBER.getItem(),'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack()));
break;
}
case FREQUENCY_SHIFTER:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',REDSTONE_TORCH,'n',NUGGET_BRASS,'p',PLATE_BRASS,'j',JUKEBOX));
break;
}
case DRAGON_ROAR:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'c',PLATE_COPPER,'f',SteamMachineryBlocks.Blocks.FAN.getBlock(),'p',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock()));
break;
}
default :
{
break;
}
}
}
for (PlateItems item : PlateItems.LOOKUP) {
switch (item) {
case IRON:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_IRON,item.createItemStack(),DefaultCrucibleLiquids.Liquids.IRON.getLiquid());
break;
}
case GOLD:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_GOLD,item.createItemStack(),DefaultCrucibleLiquids.Liquids.GOLD.getLiquid());
break;
}
case COPPER:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_COPPER,item.createItemStack(),DefaultCrucibleLiquids.Liquids.COPPER.getLiquid());
break;
}
case ZINC:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_ZINC,item.createItemStack(),DefaultCrucibleLiquids.Liquids.ZINC.getLiquid());
break;
}
case BRASS:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_BRASS,item.createItemStack(),DefaultCrucibleLiquids.Liquids.BRASS.getLiquid());
break;
}
case GILDED_IRON:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_GILDED_IRON,item.createItemStack());
break;
}
case LEAD:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_LEAD,item.createItemStack(),liquidLead);
}
}
}
}","@Override public void recipes(){
  for (  Items item : Items.LOOKUP) {
switch (item) {
case JETPACK:
{
        BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'g',SteamNetworkBlocks.Blocks.STEAM_GAUGE.getBlock(),'t',INGOT_BRASS));
        BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'g',SteamNetworkBlocks.Blocks.STEAM_GAUGE.getBlock(),'t',PLATE_BRASS));
        break;
      }
case WINGS:
{
      BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',INGOT_BRASS,'c',PLATE_COPPER));
      BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',PLATE_BRASS,'c',PLATE_COPPER));
      break;
    }
case POWER_FIST:
{
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',NUGGET_IRON,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',NUGGET_BRASS));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',PLATE_IRON,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',NUGGET_BRASS));
    break;
  }
case EXTENDO_FIST:
{
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',INGOT_IRON,'b',NUGGET_BRASS));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',PLATE_IRON,'b',NUGGET_BRASS));
  break;
}
case THRUSTERS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'t',INGOT_BRASS,'n',NUGGET_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',SteamNetworkBlocks.Blocks.PIPE.getBlock(),'t',PLATE_BRASS,'n',NUGGET_BRASS));
break;
}
case FALL_ASSIST:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',SLIMEBALL_ORE));
break;
}
case JUMP_ASSIST:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',PLATE_BRASS));
break;
}
case RUN_ASSIST:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',LEATHER_BOOTS,'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'s',PLATE_BRASS));
break;
}
case DOUBLE_JUMP:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",'v',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock(),'s',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",'v',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock(),'s',PLATE_BRASS));
break;
}
case CANNING_MACHINE:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',INGOT_BRASS,'n',NUGGET_IRON,'i',INGOT_IRON));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',PLATE_BRASS,'n',NUGGET_IRON,'i',PLATE_IRON));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',INGOT_BRASS,'n',NUGGET_IRON,'i',INGOT_IRON));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack(),'b',PLATE_BRASS,'n',NUGGET_IRON,'i',PLATE_IRON));
break;
}
case PITON_DEPLOYER:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'i',NUGGET_IRON));
break;
}
case STEALTH:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'w',WOOL,'s',STRING));
break;
}
case ENDER_SHROUD:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'g',GLASS,'e',ENDER_PEARL));
break;
}
case REINFORCED_TANK:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',SteamNetworkBlocks.Blocks.TANK.getBlock(),'p',INGOT_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',SteamNetworkBlocks.Blocks.TANK.getBlock(),'p',PLATE_BRASS));
break;
}
case UBER_REINFORCED_TANK:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',Items.REINFORCED_TANK.getItem(),'p',INGOT_BRASS,'b',BLOCK_BRASS));
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',Items.REINFORCED_TANK.getItem(),'p',PLATE_BRASS,'b',BLOCK_BRASS));
break;
}
case REBREATHER:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'p',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock(),'t',SteamNetworkBlocks.Blocks.TANK.getBlock(),'c',new ItemStack(CARPET,1,OreDictionary.WILDCARD_VALUE)));
break;
}
case HYDROPHOBIC_COATINGS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'z',PLATE_ZINC,'b',LEATHER_BOOTS,'h',SteamMachineryBlocks.Blocks.STEAM_HEATER.getBlock(),'s',SLIMEBALL_ORE));
break;
}
case PYROPHOBIC_COATINGS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'c',PLATE_COPPER,'b',LEATHER_BOOTS,'h',SteamMachineryBlocks.Blocks.STEAM_HEATER.getBlock(),'m',MAGMA_CREAM));
break;
}
case ANCHOR_HEELS:
{
if (Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0 && !Config.enableAnchorAnvilRecipe) {
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(item.getItem()),""String_Node_Str"",""String_Node_Str"",'p',PLATE_LEAD,'e',PlateItems.LEAD_EXO.createItemStack()));
}
 else {
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(item.getItem()),""String_Node_Str"",""String_Node_Str"",'p',PLATE_IRON,'e',PlateItems.IRON_EXO.createItemStack(),'a',ANVIL));
}
break;
}
case PISTON_PUSH:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'n',NUGGET_BRASS,'p',PISTON,'b',CraftingComponentItems.Items.BRASS_PISTON));
break;
}
case RELOADING_HOLSTERS:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'l',LEATHER,'b',PLATE_BRASS,'c',FirearmUpgradeItems.Items.REVOLVER_CHAMBER.getItem(),'p',CraftingComponentItems.Items.BRASS_PISTON.createItemStack()));
break;
}
case FREQUENCY_SHIFTER:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'t',REDSTONE_TORCH,'n',NUGGET_BRASS,'p',PLATE_BRASS,'j',JUKEBOX));
break;
}
case DRAGON_ROAR:
{
BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(item.getItem(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'c',PLATE_COPPER,'f',SteamMachineryBlocks.Blocks.FAN.getBlock(),'p',SteamNetworkBlocks.Blocks.VALVE_PIPE.getBlock()));
break;
}
default :
{
break;
}
}
}
for (PlateItems item : PlateItems.LOOKUP) {
switch (item) {
case IRON_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_IRON,item.createItemStack(),DefaultCrucibleLiquids.Liquids.IRON_LIQUID.getLiquid());
break;
}
case GOLD_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_GOLD,item.createItemStack(),DefaultCrucibleLiquids.Liquids.GOLD_LIQUID.getLiquid());
break;
}
case COPPER_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_COPPER,item.createItemStack(),DefaultCrucibleLiquids.Liquids.COPPER_LIQUID.getLiquid());
break;
}
case ZINC_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_ZINC,item.createItemStack(),DefaultCrucibleLiquids.Liquids.ZINC_LIQUID.getLiquid());
break;
}
case BRASS_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_BRASS,item.createItemStack(),DefaultCrucibleLiquids.Liquids.BRASS_LIQUID.getLiquid());
break;
}
case GILDED_IRON_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_GILDED_IRON,item.createItemStack());
break;
}
case LEAD_EXO:
{
addExosuitPlateRecipes(""String_Node_Str"",PLATE_LEAD,item.createItemStack(),liquidLead);
}
}
}
}",0.9965160213945728
22329,"public boolean isEnabled(){
switch (this) {
case IRON:
{
      return Config.enableIronPlate;
    }
case GOLD:
{
    return Config.enableGoldPlate;
  }
case COPPER:
{
  return Config.enableCopperPlate;
}
case ZINC:
{
return Config.enableZincPlate;
}
case BRASS:
{
return Config.enableBrassPlate;
}
case GILDED_IRON:
{
return Config.enableGildedIronPlate;
}
default :
{
return false;
}
}
}","public boolean isEnabled(){
switch (this) {
case IRON_EXO:
{
      return Config.enableIronPlate;
    }
case GOLD_EXO:
{
    return Config.enableGoldPlate;
  }
case COPPER_EXO:
{
  return Config.enableCopperPlate;
}
case ZINC_EXO:
{
return Config.enableZincPlate;
}
case BRASS_EXO:
{
return Config.enableBrassPlate;
}
case GILDED_IRON_EXO:
{
return Config.enableGildedIronPlate;
}
default :
{
return false;
}
}
}",0.97
22330,"@Override public void init(){
  for (  Liquids liquid : Liquids.values()) {
    SteamcraftRegistry.registerLiquid(liquid.getLiquid());
  }
  CrucibleLiquid liquidGold=Liquids.GOLD.getLiquid();
  CrucibleLiquid liquidIron=Liquids.IRON.getLiquid();
  CrucibleLiquid liquidZinc=Liquids.ZINC.getLiquid();
  CrucibleLiquid liquidCopper=Liquids.COPPER.getLiquid();
  CrucibleLiquid liquidBrass=Liquids.BRASS.getLiquid();
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_GOLD,liquidGold,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_IRON,liquidIron,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_ZINC,liquidZinc,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_COPPER,liquidCopper,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_BRASS,liquidBrass,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_GOLD,liquidGold,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_IRON,liquidIron,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_ZINC,liquidZinc,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_COPPER,liquidCopper,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_BRASS,liquidBrass,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_GOLD,liquidGold,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_IRON,liquidIron,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_ZINC,liquidZinc,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_COPPER,liquidCopper,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_BRASS,liquidBrass,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_GOLD,liquidGold,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_IRON,liquidIron,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_ZINC,liquidZinc,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_COPPER,liquidCopper,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_BRASS,liquidBrass,1);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_SWORD,liquidIron,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_PICKAXE,liquidIron,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_AXE,liquidIron,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_HOE,liquidIron,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_SHOVEL,liquidIron,9);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_BOOTS,liquidIron,36);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_CHESTPLATE,liquidIron,72);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_HELMET,liquidIron,45);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_LEGGINGS,liquidIron,63);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_SWORD,liquidGold,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_PICKAXE,liquidGold,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_AXE,liquidGold,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_HOE,liquidGold,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_SHOVEL,liquidGold,9);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_BOOTS,liquidGold,36);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_CHESTPLATE,liquidGold,72);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_HELMET,liquidGold,45);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_LEGGINGS,liquidGold,63);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_SWORD.getItem(),liquidBrass,18);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_PICKAXE.getItem(),liquidBrass,27);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_AXE.getItem(),liquidBrass,27);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_HOE.getItem(),liquidBrass,18);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_SHOVEL.getItem(),liquidBrass,9);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_BOOTS.getItem(),liquidBrass,36);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_CHESTPLATE.getItem(),liquidBrass,72);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_HELMET.getItem(),liquidBrass,45);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_LEGGINGS.getItem(),liquidBrass,63);
  SteamcraftRegistry.registerOreDictDunkRecipe(INGOT_IRON,liquidGold,1,MetalItems.Items.GILDED_IRON_INGOT.createItemStack());
  SteamcraftRegistry.registerOreDictDunkRecipe(PLATE_IRON,liquidGold,1,MetalItems.Items.GILDED_IRON_PLATE.createItemStack());
  SteamcraftRegistry.registerOreDictDunkRecipe(NUGGET_IRON,liquidGold,1,MetalItems.Items.GILDED_IRON_NUGGET.createItemStack());
}","@Override public void init(){
  for (  Liquids liquid : Liquids.values()) {
    SteamcraftRegistry.registerLiquid(liquid.getLiquid());
  }
  CrucibleLiquid liquidGold=Liquids.GOLD_LIQUID.getLiquid();
  CrucibleLiquid liquidIron=Liquids.IRON_LIQUID.getLiquid();
  CrucibleLiquid liquidZinc=Liquids.ZINC_LIQUID.getLiquid();
  CrucibleLiquid liquidCopper=Liquids.COPPER_LIQUID.getLiquid();
  CrucibleLiquid liquidBrass=Liquids.BRASS_LIQUID.getLiquid();
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_GOLD,liquidGold,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_IRON,liquidIron,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_ZINC,liquidZinc,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_COPPER,liquidCopper,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(INGOT_BRASS,liquidBrass,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_GOLD,liquidGold,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_IRON,liquidIron,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_ZINC,liquidZinc,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_COPPER,liquidCopper,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_TINY_BRASS,liquidBrass,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_GOLD,liquidGold,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_IRON,liquidIron,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_ZINC,liquidZinc,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_COPPER,liquidCopper,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(PLATE_BRASS,liquidBrass,6);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_GOLD,liquidGold,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_IRON,liquidIron,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_ZINC,liquidZinc,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_COPPER,liquidCopper,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(NUGGET_BRASS,liquidBrass,1);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_SWORD,liquidIron,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_PICKAXE,liquidIron,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_AXE,liquidIron,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_HOE,liquidIron,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_SHOVEL,liquidIron,9);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_BOOTS,liquidIron,36);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_CHESTPLATE,liquidIron,72);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_HELMET,liquidIron,45);
  SteamcraftRegistry.registerMeltRecipeTool(Items.IRON_LEGGINGS,liquidIron,63);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_SWORD,liquidGold,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_PICKAXE,liquidGold,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_AXE,liquidGold,27);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_HOE,liquidGold,18);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_SHOVEL,liquidGold,9);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_BOOTS,liquidGold,36);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_CHESTPLATE,liquidGold,72);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_HELMET,liquidGold,45);
  SteamcraftRegistry.registerMeltRecipeTool(Items.GOLDEN_LEGGINGS,liquidGold,63);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_SWORD.getItem(),liquidBrass,18);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_PICKAXE.getItem(),liquidBrass,27);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_AXE.getItem(),liquidBrass,27);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_HOE.getItem(),liquidBrass,18);
  SteamcraftRegistry.registerMeltRecipeTool(ToolItems.Items.BRASS_SHOVEL.getItem(),liquidBrass,9);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_BOOTS.getItem(),liquidBrass,36);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_CHESTPLATE.getItem(),liquidBrass,72);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_HELMET.getItem(),liquidBrass,45);
  SteamcraftRegistry.registerMeltRecipeTool(ArmorItems.Items.BRASS_LEGGINGS.getItem(),liquidBrass,63);
  SteamcraftRegistry.registerOreDictDunkRecipe(INGOT_IRON,liquidGold,1,MetalItems.Items.GILDED_IRON_INGOT.createItemStack());
  SteamcraftRegistry.registerOreDictDunkRecipe(PLATE_IRON,liquidGold,1,MetalItems.Items.GILDED_IRON_PLATE.createItemStack());
  SteamcraftRegistry.registerOreDictDunkRecipe(NUGGET_IRON,liquidGold,1,MetalItems.Items.GILDED_IRON_NUGGET.createItemStack());
}",0.996230479267636
22331,"@Override public void postInit(){
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_GOLD,Liquids.GOLD.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_IRON,Liquids.IRON.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_ZINC,Liquids.ZINC.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_COPPER,Liquids.COPPER.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_BRASS,Liquids.BRASS.getLiquid(),9);
}","@Override public void postInit(){
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_GOLD,Liquids.GOLD_LIQUID.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_IRON,Liquids.IRON_LIQUID.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_ZINC,Liquids.ZINC_LIQUID.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_COPPER,Liquids.COPPER_LIQUID.getLiquid(),9);
  SteamcraftRegistry.registerMeltRecipeOreDict(DUST_BRASS,Liquids.BRASS_LIQUID.getLiquid(),9);
}",0.9641760491299898
22332,"public static void postInit(){
  if (Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0) {
    CrucibleLiquid liquidLead=new CrucibleLiquid(""String_Node_Str"",OreDictionary.getOres(""String_Node_Str"").get(0),MetalItems.Items.LEAD_PLATE.createItemStack(),OreDictionary.getOres(""String_Node_Str"").size() > 0 ? OreDictionary.getOres(""String_Node_Str"").get(0) : null,null,118,128,157);
    SteamcraftRegistry.registerLiquid(liquidLead);
    SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidLead,9);
    SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidLead,1);
    SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidLead,6);
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",ExosuitUpgradeItems.PlateItems.LEAD.createItemStack(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",MetalItems.Items.LEAD_PLATE.createItemStack(),liquidLead);
  }
}","public static void postInit(){
  if (Config.enableLeadPlate && OreDictionary.getOres(""String_Node_Str"").size() > 0) {
    CrucibleLiquid liquidLead=new CrucibleLiquid(""String_Node_Str"",OreDictionary.getOres(""String_Node_Str"").get(0),MetalItems.Items.LEAD_PLATE.createItemStack(),OreDictionary.getOres(""String_Node_Str"").size() > 0 ? OreDictionary.getOres(""String_Node_Str"").get(0) : null,null,118,128,157);
    SteamcraftRegistry.registerLiquid(liquidLead);
    SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidLead,9);
    SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidLead,1);
    SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidLead,6);
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",ExosuitUpgradeItems.PlateItems.LEAD_EXO.createItemStack(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",MetalItems.Items.LEAD_PLATE.createItemStack(),liquidLead);
  }
}",0.998069498069498
22333,"public static void registerBookResearch(){
  if (Config.hasAllCrucial) {
    registerRecentCreations();
    registerBasics();
    registerFirearms();
    registerCasting();
    registerGadgets();
    registerSteamPower();
    registerExosuit();
  }
}","public static void registerBookResearch(){
  if (Config.hasAllCrucial) {
    registerBasics();
    registerFirearms();
    registerCasting();
    registerGadgets();
    registerSteamPower();
    registerExosuit();
  }
}",0.9339019189765458
22334,"public static void registerBasics(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.book)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.steamcraftOre,1,0),new ItemStack(SteamcraftBlocks.steamcraftOre,1,1)));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.steamcraftCrafting,1,0),new ItemStack(SteamcraftItems.steamcraftCrafting,1,5)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.boiler,1,0),new ItemStack(SteamcraftBlocks.pipe,1,0)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pipe),new ItemStack(Blocks.STONEBRICK)),new BookPageText(""String_Node_Str"",""String_Node_Str""));
}","public static void registerBasics(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(BOOK.getItem())),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",OVERWORLD_COPPER_ORE.createItemStack(),OVERWORLD_ZINC_ORE.createItemStack()));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",BRASS_PISTON.createItemStack(),BRASS_TURBINE.createItemStack()),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(BOILER.getBlock(),1,0),new ItemStack(PIPE.getBlock(),1,0)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""));
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(PIPE.getBlock()),new ItemStack(Blocks.STONEBRICK)),new BookPageText(""String_Node_Str"",""String_Node_Str""));
}",0.853518574448807
22335,"@Override @SideOnly(Side.CLIENT) public void randomDisplayTick(World world,int x,int y,int z,Random rand){
  TileEntityBoiler boiler=(TileEntityBoiler)world.getTileEntity(x,y,z);
  if (boiler.isBurning()) {
    int l=world.getBlockMetadata(x,y,z);
    float f=(float)x + 0.5F;
    float f1=(float)y + 0.0F + rand.nextFloat() * 6.0F / 16.0F;
    float f2=(float)z + 0.5F;
    float f3=0.52F;
    float f4=rand.nextFloat() * 0.6F - 0.3F;
    if (l == 4) {
      world.spawnParticle(""String_Node_Str"",(double)(f - f3),(double)f1,(double)(f2 + f4),0.0D,0.0D,0.0D);
      world.spawnParticle(""String_Node_Str"",(double)(f - f3),(double)f1,(double)(f2 + f4),0.0D,0.0D,0.0D);
    }
 else     if (l == 5) {
      world.spawnParticle(""String_Node_Str"",(double)(f + f3),(double)f1,(double)(f2 + f4),0.0D,0.0D,0.0D);
      world.spawnParticle(""String_Node_Str"",(double)(f + f3),(double)f1,(double)(f2 + f4),0.0D,0.0D,0.0D);
    }
 else     if (l == 2) {
      world.spawnParticle(""String_Node_Str"",(double)(f + f4),(double)f1,(double)(f2 - f3),0.0D,0.0D,0.0D);
      world.spawnParticle(""String_Node_Str"",(double)(f + f4),(double)f1,(double)(f2 - f3),0.0D,0.0D,0.0D);
    }
 else     if (l == 3) {
      world.spawnParticle(""String_Node_Str"",(double)(f + f4),(double)f1,(double)(f2 + f3),0.0D,0.0D,0.0D);
      world.spawnParticle(""String_Node_Str"",(double)(f + f4),(double)f1,(double)(f2 + f3),0.0D,0.0D,0.0D);
    }
  }
}","@Override @SideOnly(Side.CLIENT) public void randomDisplayTick(IBlockState state,World world,BlockPos pos,Random rand){
  TileEntity tile=world.getTileEntity(pos);
  if (tile == null || !(tile instanceof TileEntityBoiler)) {
    return;
  }
  TileEntityBoiler boiler=(TileEntityBoiler)tile;
  if (boiler.isBurning()) {
    EnumFacing facing=state.getValue(FACING);
    float f=(float)pos.getX() + 0.5F;
    float f1=(float)pos.getY() + 0.0F + rand.nextFloat() * 6.0F / 16.0F;
    float f2=(float)pos.getZ() + 0.5F;
    float f3=0.52F;
    float f4=rand.nextFloat() * 0.6F - 0.3F;
    double xCoord;
    double yCoord=(double)f1;
    double zCoord;
switch (facing) {
case WEST:
{
        xCoord=(double)f - f3;
        zCoord=(double)f2 + f4;
        break;
      }
case EAST:
{
      xCoord=(double)f + f3;
      zCoord=(double)f2 + f4;
      break;
    }
case NORTH:
{
    xCoord=(double)f + f4;
    zCoord=(double)f2 - f3;
    break;
  }
case SOUTH:
{
  xCoord=(double)f + f4;
  zCoord=(double)f2 + f3;
  break;
}
default :
{
return;
}
}
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,xCoord,yCoord,zCoord,0D,0D,0D);
world.spawnParticle(EnumParticleTypes.FLAME,xCoord,yCoord,zCoord,0D,0D,0D);
}
}",0.2778415614236509
22336,"@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int side,float xf,float yf,float zf){
  TileEntityBoiler tileEntity=(TileEntityBoiler)world.getTileEntity(x,y,z);
  boolean isClient=!world.isRemote;
  if (!FluidHelper.playerIsHoldingWaterContainer(player) && isClient && tileEntity != null) {
    player.openGui(Steamcraft.instance,0,world,x,y,z);
  }
 else {
    FluidHelper.fillTankFromHeldItem(player,tileEntity.myTank);
  }
  return true;
}","@Override public boolean onBlockActivated(World world,BlockPos pos,IBlockState state,EntityPlayer player,EnumHand hand,ItemStack heldItem,EnumFacing side,float hitX,float hitY,float hitZ){
  TileEntityBoiler tileEntity=(TileEntityBoiler)world.getTileEntity(pos);
  boolean isClient=!world.isRemote;
  if (tileEntity != null) {
    if (!FluidHelper.playerIsHoldingWaterContainer(player) && isClient) {
      player.openGui(Steamcraft.instance,0,world,pos.getX(),pos.getY(),pos.getZ());
    }
 else {
      FluidHelper.fillTankFromHeldItem(player,tileEntity.myTank);
    }
  }
  return true;
}",0.7105751391465677
22337,"@Override public void onBlockAdded(World world,int x,int y,int z){
  super.onBlockAdded(world,x,y,z);
  this.func_149930_e(world,x,y,z);
}","@Override public void onBlockAdded(World world,BlockPos pos,IBlockState state){
  super.onBlockAdded(world,pos,state);
  setDefaultFacing(world,pos,state);
}",0.6915254237288135
22338,"public BlockBoiler(boolean on){
  super(Material.iron);
  this.field_149932_b=on;
  setHardness(5F);
  setResistance(10F);
}","public BlockBoiler(){
  super(Material.IRON);
  setHardness(5F);
  setResistance(10F);
}",0.7924528301886793
22339,"@Override public boolean onWrench(ItemStack stack,EntityPlayer player,World world,int x,int y,int z,int side,float xO,float yO,float zO){
  int meta=world.getBlockMetadata(x,y,z);
  if (player.isSneaking()) {
    return true;
  }
 else   if (side != 0 && side != 1) {
    world.setBlockMetadataWithNotify(x,y,z,side == meta ? ForgeDirection.getOrientation(side).getOpposite().ordinal() : side,2);
    return true;
  }
  return false;
}","@Override public boolean onWrench(ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing facing,IBlockState state,float hitX,float hitY,float hitZ){
  if (player.isSneaking()) {
    return true;
  }
 else   if (facing != EnumFacing.DOWN && facing != EnumFacing.UP && facing != state.getValue(FACING)) {
    world.setBlockState(pos,state.withProperty(FACING,facing.getOpposite()),2);
  }
  return false;
}",0.3586206896551724
22340,"@Override public void onBlockPlacedBy(World world,int x,int y,int z,EntityLivingBase elb,ItemStack stack){
  int l=MathHelper.floor_double((double)(elb.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3;
  if (l == 0) {
    world.setBlockMetadataWithNotify(x,y,z,2,2);
  }
  if (l == 1) {
    world.setBlockMetadataWithNotify(x,y,z,5,2);
  }
  if (l == 2) {
    world.setBlockMetadataWithNotify(x,y,z,3,2);
  }
  if (l == 3) {
    world.setBlockMetadataWithNotify(x,y,z,4,2);
  }
  if (stack.hasDisplayName()) {
  }
}","@Override public void onBlockPlacedBy(World world,BlockPos pos,IBlockState state,EntityLivingBase elb,ItemStack stack){
  world.setBlockState(pos,state.withProperty(FACING,elb.getHorizontalFacing().getOpposite()));
}",0.2738589211618257
22341,"@Override public void breakBlock(World world,int x,int y,int z,Block block,int meta){
  if (!field_149934_M) {
    TileEntityBoiler tileentityboiler=(TileEntityBoiler)world.getTileEntity(x,y,z);
    if (tileentityboiler != null) {
      for (int i1=0; i1 < tileentityboiler.getSizeInventory(); ++i1) {
        ItemStack itemstack=tileentityboiler.getStackInSlot(i1);
        if (itemstack != null) {
          float f=this.rand.nextFloat() * 0.8F + 0.1F;
          float f1=this.rand.nextFloat() * 0.8F + 0.1F;
          float f2=this.rand.nextFloat() * 0.8F + 0.1F;
          while (itemstack.stackSize > 0) {
            int j1=this.rand.nextInt(21) + 10;
            if (j1 > itemstack.stackSize) {
              j1=itemstack.stackSize;
            }
            itemstack.stackSize-=j1;
            EntityItem entityitem=new EntityItem(world,(double)((float)x + f),(double)((float)y + f1),(double)((float)z + f2),new ItemStack(itemstack.getItem(),j1,itemstack.getItemDamage()));
            if (itemstack.hasTagCompound()) {
              entityitem.getEntityItem().setTagCompound((NBTTagCompound)itemstack.getTagCompound().copy());
            }
            float f3=0.05F;
            entityitem.motionX=(double)((float)this.rand.nextGaussian() * f3);
            entityitem.motionY=(double)((float)this.rand.nextGaussian() * f3 + 0.2F);
            entityitem.motionZ=(double)((float)this.rand.nextGaussian() * f3);
            world.spawnEntityInWorld(entityitem);
          }
        }
      }
      world.func_147453_f(x,y,z,block);
    }
  }
  super.breakBlock(world,x,y,z,block,meta);
}","@Override public void breakBlock(World world,BlockPos pos,IBlockState state){
  TileEntity tileentity=world.getTileEntity(pos);
  if (tileentity != null && tileentity instanceof TileEntityBoiler) {
    InventoryHelper.dropInventoryItems(world,pos,(TileEntityBoiler)tileentity);
    world.updateComparatorOutputLevel(pos,state.getBlock());
  }
  super.breakBlock(world,pos,state);
}",0.0757958564931783
22342,"@Override public ItemStack getPickBlock(MovingObjectPosition target,World world,int x,int y,int z,EntityPlayer player){
  return new ItemStack(SteamcraftBlocks.boiler);
}","@Override public ItemStack getPickBlock(IBlockState state,RayTraceResult target,World world,BlockPos pos,EntityPlayer player){
  return new ItemStack(SteamNetworkBlocks.Blocks.BOILER.getBlock());
}",0.7084468664850136
22343,"@Override public ItemStack onItemRightClick(ItemStack itemStack,World world,EntityPlayer player){
  player.openGui(Steamcraft.instance,1,world,0,0,0);
  return itemStack;
}","@Override public ActionResult<ItemStack> onItemRightClick(ItemStack itemStack,World world,EntityPlayer player,EnumHand hand){
  player.openGui(Steamcraft.instance,1,world,0,0,0);
  return new ActionResult<>(EnumActionResult.SUCCESS,itemStack);
}",0.7817745803357314
22344,"@Override public boolean onItemUse(ItemStack itemStack,EntityPlayer player,World world,int x,int y,int z,int side,float fx,float fy,float fz){
  if (player.isSneaking() && world.isRemote) {
    Block block=world.getBlock(x,y,z);
    ItemStack stack=block.getPickBlock(new MovingObjectPosition(x,y,z,side,Vec3.createVectorHelper(fx,fy,fz)),world,x,y,z,player);
    if (stack != null) {
      for (      ItemStack stack2 : SteamcraftRegistry.bookRecipes.keySet()) {
        if (stack2.getItem() == stack.getItem() && stack2.getItemDamage() == stack.getItemDamage()) {
          GuiSteamcraftBook.openRecipeFor(stack2,player);
          return true;
        }
      }
    }
  }
  return false;
}","@Override public EnumActionResult onItemUse(ItemStack itemStack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (player.isSneaking() && world.isRemote) {
    IBlockState state=world.getBlockState(pos);
    RayTraceResult rtr=new RayTraceResult(new Vec3d(hitX,hitY,hitZ),side,pos);
    ItemStack stack=state.getBlock().getPickBlock(state,rtr,world,pos,player);
    if (stack != null) {
      for (      ItemStack stack2 : SteamcraftRegistry.bookRecipes.keySet()) {
        if (stack2.getItem() == stack.getItem() && stack2.getItemDamage() == stack.getItemDamage()) {
          GuiSteamcraftBook.openRecipeFor(stack2,player);
          return EnumActionResult.SUCCESS;
        }
      }
    }
  }
  return EnumActionResult.FAIL;
}",0.6859448554135844
22345,"@Override public ItemStack onItemRightClick(ItemStack par1ItemStack,World par2World,EntityPlayer par3EntityPlayer){
  par3EntityPlayer.setItemInUse(par1ItemStack,this.getMaxItemUseDuration(par1ItemStack));
  return par1ItemStack;
}","@Override public ActionResult<ItemStack> onItemRightClick(ItemStack stack,World world,EntityPlayer player,EnumHand hand){
  player.setActiveHand(hand);
  return new ActionResult<>(EnumActionResult.SUCCESS,stack);
}",0.3910112359550561
22346,"@Override public boolean canApplyTo(ItemStack stack){
  return stack.getItem() == SteamcraftItems.musket;
}","@Override public boolean canApplyTo(ItemStack stack){
  return stack.getItem() == FirearmItems.Items.MUSKET.getItem();
}",0.8634361233480177
22347,"@Override public EnumRarity getRarity(ItemStack me){
  if (me.hasTagCompound() && me.stackTagCompound.hasKey(""String_Node_Str"")) {
    return EnumRarity.epic;
  }
  return super.getRarity(me);
}","@Override public EnumRarity getRarity(ItemStack me){
  if (me.hasTagCompound() && me.getTagCompound().hasKey(""String_Node_Str"")) {
    return EnumRarity.EPIC;
  }
  return super.getRarity(me);
}",0.9587628865979382
22348,"@Override public String getUnlocalizedName(ItemStack me){
  if (me.hasTagCompound() && me.stackTagCompound.hasKey(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  return super.getUnlocalizedName(me);
}","@Override public String getUnlocalizedName(ItemStack me){
  if (me.hasTagCompound() && me.getTagCompound().hasKey(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  return super.getUnlocalizedName(me);
}",0.9761904761904762
22349,"@Override public boolean getIsRepairable(ItemStack par1ItemStack,ItemStack par2ItemStack){
  return par2ItemStack.isItemEqual(new ItemStack(Items.leather)) ? true : super.getIsRepairable(par1ItemStack,par2ItemStack);
}","@Override public boolean getIsRepairable(ItemStack par1ItemStack,ItemStack par2ItemStack){
  return par2ItemStack.isItemEqual(new ItemStack(Items.LEATHER)) || super.getIsRepairable(par1ItemStack,par2ItemStack);
}",0.9302325581395348
22350,"@Override public void addInformation(ItemStack me,EntityPlayer player,List list,boolean par4){
  super.addInformation(me,player,list,par4);
  if (me.hasTagCompound()) {
    if (me.stackTagCompound.hasKey(""String_Node_Str"")) {
      int level=me.stackTagCompound.getInteger(""String_Node_Str"");
      list.add(EnumChatFormatting.GREEN + StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str""+ level);
    }
  }
}","@Override public void addInformation(ItemStack me,EntityPlayer player,List<String> list,boolean par4){
  super.addInformation(me,player,list,par4);
  if (me.hasTagCompound()) {
    if (me.getTagCompound().hasKey(""String_Node_Str"")) {
      int level=me.getTagCompound().getInteger(""String_Node_Str"");
      list.add(TextFormatting.GREEN + I18n.format(""String_Node_Str"") + ""String_Node_Str""+ level);
    }
  }
}",0.9053892215568864
22351,"@Override @SideOnly(Side.CLIENT) public ModelBiped getArmorModel(EntityLivingBase entityLiving,ItemStack itemStack,int armorSlot){
  if (modelTophat == null)   modelTophat=new ModelTophat();
  if (itemStack.hasTagCompound() && itemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
    modelTophat.level=itemStack.stackTagCompound.getInteger(""String_Node_Str"");
  }
  return modelTophat;
}","@Override @SideOnly(Side.CLIENT) public ModelBiped getArmorModel(EntityLivingBase entityLiving,ItemStack itemStack,int armorSlot){
  if (modelTophat == null)   modelTophat=new ModelTophat();
  if (itemStack.hasTagCompound() && itemStack.getTagCompound().hasKey(""String_Node_Str"")) {
    modelTophat.level=itemStack.getTagCompound().getInteger(""String_Node_Str"");
  }
  return modelTophat;
}",0.9743589743589745
22352,"public void onCreated(ItemStack me,World p_77622_2_,EntityPlayer player){
  if (player.getDisplayName() == ""String_Node_Str"" || player.getDisplayName() == ""String_Node_Str"") {
    me.setTagCompound(new NBTTagCompound());
    me.stackTagCompound.setBoolean(""String_Node_Str"",true);
  }
}","public void onCreated(ItemStack me,World world,EntityPlayer player){
  String name=player.getDisplayName().getFormattedText();
  if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)) {
    me.setTagCompound(new NBTTagCompound());
    me.getTagCompound().setBoolean(""String_Node_Str"",true);
  }
}",0.6130653266331658
22353,"@Override public String getInformation(ItemStack self,ItemStack tool){
  DrillHeadMaterial mat=DrillHeadMaterial.materials.get(getMyMaterial(self));
  String name=mat.locName;
  return StatCollector.canTranslate(name) ? StatCollector.translateToLocal(name) : mat.materialName;
}","@Override public String getInformation(ItemStack self,ItemStack tool){
  DrillHeadMaterial mat=DrillHeadMaterial.materials.get(getMyMaterial(self));
  String name=mat.locName;
  return I18n.hasKey(name) ? I18n.format(name) : mat.materialName;
}",0.8505747126436781
22354,"/** 
 * The same as getInformation(ArrayList, SteamToolSlot), but relies on itemstacks instead of ISteamToolUpgrades
 * @param upgrades The ItemStacks that are being tested against; see #getUpgradeStacks
 * @param redSlot The slot that should be red. See getInformation.
 * @return The strings, or null if the upgrades were null.
 */
public static ArrayList<String> getInformationFromStacks(ArrayList<ItemStack> upgrades,SteamToolSlot redSlot,ItemStack tool){
  if (upgrades == null) {
    return null;
  }
  ArrayList<String> strings=new ArrayList<>();
  for (  ItemStack stack : upgrades) {
    ISteamToolUpgrade upgrade=(ISteamToolUpgrade)stack.getItem();
    EnumChatFormatting format=upgrade.getToolSlot() == redSlot ? EnumChatFormatting.RED : EnumChatFormatting.DARK_GREEN;
    String info=upgrade.getInformation(stack,tool);
    String toAdd=info == null ? stack.getItem().getUnlocalizedName() + ""String_Node_Str"" : info;
    strings.add(format + ""String_Node_Str"" + StatCollector.translateToLocal(toAdd));
  }
  if (strings.isEmpty()) {
    return null;
  }
  return strings;
}","/** 
 * The same as getInformation(ArrayList, SteamToolSlot), but relies on itemstacks instead of ISteamToolUpgrades
 * @param upgrades The ItemStacks that are being tested against; see #getUpgradeStacks
 * @param redSlot The slot that should be red. See getInformation.
 * @return The strings. Will return an empty array if there are no upgrades or strings.
 */
public static ArrayList<String> getInformationFromStacks(ArrayList<ItemStack> upgrades,SteamToolSlot redSlot,ItemStack tool){
  if (upgrades == null) {
    return new ArrayList<>();
  }
  ArrayList<String> strings=new ArrayList<>();
  for (  ItemStack stack : upgrades) {
    ISteamToolUpgrade upgrade=(ISteamToolUpgrade)stack.getItem();
    TextFormatting format=upgrade.getToolSlot() == redSlot ? TextFormatting.RED : TextFormatting.DARK_GREEN;
    String info=upgrade.getInformation(stack,tool);
    String toAdd=info == null ? stack.getItem().getUnlocalizedName() + ""String_Node_Str"" : info;
    strings.add(format + ""String_Node_Str"" + I18n.format(toAdd));
  }
  return strings;
}",0.8588842006563525
22355,"/** 
 * Essentially setInventorySlotContents
 * @param me The ItemStack being edited.
 * @param slot ???
 * @param stack ???Note: The original method was not documented, so I don't know what these params actually are.
 */
public static void setNBTInventory(ItemStack me,int slot,ItemStack stack){
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setTag(""String_Node_Str"",new NBTTagCompound());
  }
  if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(slot))) {
    me.stackTagCompound.getCompoundTag(""String_Node_Str"").removeTag(Integer.toString(slot));
  }
  NBTTagCompound stc=new NBTTagCompound();
  if (stack != null) {
    stack.writeToNBT(stc);
    me.stackTagCompound.getCompoundTag(""String_Node_Str"").setTag(Integer.toString(slot),stc);
  }
}","/** 
 * Essentially setInventorySlotContents
 * @param me The ItemStack being edited.
 * @param slot ???
 * @param stack ???Note: The original method was not documented, so I don't know what these params actually are.
 */
public static void setNBTInventory(ItemStack me,int slot,ItemStack stack){
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  if (!me.getTagCompound().hasKey(""String_Node_Str"")) {
    me.getTagCompound().setTag(""String_Node_Str"",new NBTTagCompound());
  }
  if (me.getTagCompound().getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(slot))) {
    me.getTagCompound().getCompoundTag(""String_Node_Str"").removeTag(Integer.toString(slot));
  }
  NBTTagCompound stc=new NBTTagCompound();
  if (stack != null) {
    stack.writeToNBT(stc);
    me.getTagCompound().getCompoundTag(""String_Node_Str"").setTag(Integer.toString(slot),stc);
  }
}",0.9102132435465768
22356,"@Override public Explosion newExplosion(World world,Entity entity,double x,double y,double z,float explosionSize,boolean doFire,boolean doSmokeAndGrief){
  ExplosionRocket explosion=new ExplosionRocket(world,entity,x,y,z,explosionSize,false);
  explosion.isFlaming=doFire;
  explosion.isSmoking=doSmokeAndGrief;
  explosion.doExplosionA();
  explosion.doExplosionB(true);
  for (  EntityPlayer entityplayer : world.playerEntities) {
    if (entityplayer.getDistanceSq(x,y,z) < 4096.0D) {
      SPacketExplosion packet=new SPacketExplosion(x,y,z,explosionSize,explosion.affectedBlockPositions,(Vec3d)explosion.func_77277_b().get(entityplayer));
      ((EntityPlayerMP)entityplayer).playerNetServerHandler.sendPacket(packet);
    }
  }
  return explosion;
}","@Override public Explosion newExplosion(World world,Entity entity,double x,double y,double z,float explosionSize,boolean doFire,boolean doSmokeAndGrief){
  ExplosionRocket explosion=new ExplosionRocket(world,entity,x,y,z,explosionSize,false,doFire);
  explosion.isFlaming=doFire;
  explosion.isSmoking=doSmokeAndGrief;
  explosion.doExplosionA();
  explosion.doExplosionB(true);
  for (  EntityPlayer entityplayer : world.playerEntities) {
    if (entityplayer.getDistanceSq(x,y,z) < 4096.0D) {
      SPacketExplosion packet=new SPacketExplosion(x,y,z,explosionSize,explosion.affectedBlockPositions,explosion.getPlayerKnockbackMap().get(entityplayer));
      ((EntityPlayerMP)entityplayer).connection.sendPacket(packet);
    }
  }
  return explosion;
}",0.935633709356337
22357,"@Override public Explosion newExplosion(World world,Entity entity,double x,double y,double z,float explosionSize,boolean doFire,boolean doSmokeAndGrief){
  ExplosionRocket explosion=new ExplosionRocket(world,entity,x,y,z,explosionSize,doSmokeAndGrief,true);
  explosion.isFlaming=doFire;
  explosion.isSmoking=doSmokeAndGrief;
  explosion.doExplosionA();
  explosion.doExplosionB(true);
  for (  EntityPlayer entityplayer : world.playerEntities) {
    if (entityplayer.getDistanceSq(x,y,z) < 4096.0D) {
      SPacketExplosion packet=new SPacketExplosion(x,y,z,explosionSize,explosion.affectedBlockPositions,(Vec3d)explosion.func_77277_b().get(entityplayer));
      ((EntityPlayerMP)entityplayer).playerNetServerHandler.sendPacket(packet);
    }
  }
  return explosion;
}","@Override public Explosion newExplosion(World world,Entity entity,double x,double y,double z,float explosionSize,boolean doFire,boolean doSmokeAndGrief){
  ExplosionRocket explosion=new ExplosionRocket(world,entity,x,y,z,explosionSize,doSmokeAndGrief,true);
  explosion.isFlaming=doFire;
  explosion.isSmoking=doSmokeAndGrief;
  explosion.doExplosionA();
  explosion.doExplosionB(true);
  for (  EntityPlayer entityplayer : world.playerEntities) {
    if (entityplayer.getDistanceSq(x,y,z) < 4096.0D) {
      SPacketExplosion packet=new SPacketExplosion(x,y,z,explosionSize,explosion.affectedBlockPositions,explosion.getPlayerKnockbackMap().get(entityplayer));
      ((EntityPlayerMP)entityplayer).connection.sendPacket(packet);
    }
  }
  return explosion;
}",0.9411764705882352
22358,"@Override public boolean attackEntityFrom(DamageSource source,float amount){
  if (isEntityInvulnerable(source)) {
    return false;
  }
 else {
    setBeenAttacked();
    if (source.getEntity() != null) {
      Vec3d vec3=source.getEntity().getLookVec();
      if (vec3 != null) {
        motionX=vec3.xCoord;
        motionY=vec3.yCoord;
        motionZ=vec3.zCoord;
      }
      if (source.getEntity() instanceof EntityLivingBase) {
        shootingEntity=(EntityLivingBase)source.getEntity();
      }
      return true;
    }
 else {
      return false;
    }
  }
}","@Override public boolean attackEntityFrom(DamageSource source,float amount){
  if (isEntityInvulnerable(source)) {
    return false;
  }
 else {
    setBeenAttacked();
    Entity entity=source.getEntity();
    if (entity != null) {
      Vec3d vec3=entity.getLookVec();
      motionX=vec3.xCoord;
      motionY=vec3.yCoord;
      motionZ=vec3.zCoord;
      if (entity instanceof EntityLivingBase) {
        shootingEntity=(EntityLivingBase)entity;
      }
      return true;
    }
 else {
      return false;
    }
  }
}",0.8587155963302753
22359,"public Explosion newExplosion(World world,Entity entity,double x,double y,double z,float explosionSize,boolean doFire,boolean doSmokeAndGrief){
  ExplosionRocket explosion=new ExplosionRocket(world,entity,x,y,z,explosionSize,doSmokeAndGrief);
  explosion.isFlaming=doFire;
  explosion.isSmoking=doSmokeAndGrief;
  explosion.doExplosionA();
  explosion.doExplosionB(true);
  for (  EntityPlayer entityplayer : world.playerEntities) {
    if (entityplayer.getDistanceSq(x,y,z) < 4096.0D) {
      SPacketExplosion packet=new SPacketExplosion(x,y,z,explosionSize,explosion.affectedBlockPositions,(Vec3d)explosion.func_77277_b().get(entityplayer));
      ((EntityPlayerMP)entityplayer).playerNetServerHandler.sendPacket(packet);
    }
  }
  return explosion;
}","public Explosion newExplosion(World world,Entity entity,double x,double y,double z,float explosionSize,boolean doFire,boolean doSmokeAndGrief){
  ExplosionRocket explosion=new ExplosionRocket(world,entity,x,y,z,explosionSize,doFire,doSmokeAndGrief);
  explosion.isFlaming=doFire;
  explosion.isSmoking=doSmokeAndGrief;
  explosion.doExplosionA();
  explosion.doExplosionB(true);
  for (  EntityPlayer entityplayer : world.playerEntities) {
    if (entityplayer.getDistanceSq(x,y,z) < 4096.0D) {
      SPacketExplosion packet=new SPacketExplosion(x,y,z,explosionSize,explosion.affectedBlockPositions,explosion.getPlayerKnockbackMap().get(entityplayer));
      ((EntityPlayerMP)entityplayer).connection.sendPacket(packet);
    }
  }
  return explosion;
}",0.935633709356337
22360,"@Override public void onUpdate(){
  IBlockState state=worldObj.getBlockState(getPosition());
  Block block=worldObj.getBlockState(getPosition()).getBlock();
  if (!worldObj.isRemote && (shootingEntity != null && shootingEntity.isDead || (block == null || block.isAir(state,worldObj,getPosition())))) {
    setDead();
  }
 else {
    super.onUpdate();
    if (inGround) {
      if (worldObj.getBlockState(new BlockPos(x,y,z)) == blockInside) {
        ++ticksAlive;
        if (ticksAlive == 200) {
          setDead();
        }
        return;
      }
      ++ticksAlive;
      if (ticksAlive >= 200) {
        setDead();
      }
      motionX=0;
      motionY=0;
      motionZ=0;
      ticksAlive=0;
      ticksInAir=0;
    }
 else {
      ++ticksInAir;
    }
    Vec3d vec3=new Vec3d(posX,posY,posZ);
    Vec3d vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionY);
    RayTraceResult trace=this.worldObj.rayTraceBlocks(vec3,vec31,false,true,false);
    vec3=new Vec3d(posX,posY,posZ);
    vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (trace != null) {
      vec31=trace.hitVec;
    }
    Entity entity=null;
    List<Entity> list=worldObj.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().addCoord(motionX,motionY,motionZ).expand(0.5D,0.5D,0.5D));
    double d0=0.0D;
    for (    Entity entity1 : list) {
      if (entity1.canBeCollidedWith() && (!entity1.isEntityEqual(shootingEntity) || this.ticksInAir >= 25)) {
        float f=0.3F;
        AxisAlignedBB axisalignedbb=entity1.getEntityBoundingBox().expand((double)f,(double)f,(double)f);
        RayTraceResult trace1=axisalignedbb.calculateIntercept(vec3,vec31);
        if (trace1 != null) {
          double d1=vec3.distanceTo(trace1.hitVec);
          if (d1 < d0 || d0 == 0.0D) {
            entity=entity1;
            d0=d1;
          }
        }
      }
    }
    if (entity != null) {
      trace=new RayTraceResult(entity);
    }
    if (trace != null) {
      this.onImpact();
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionZ,motionX) * 180.0D / Math.PI) + 90.0F;
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    if (isInWater()) {
      for (int j=0; j < 4; ++j) {
        double f3=0.25D;
        worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f3,posY - motionY * f3,posZ - motionZ * f3,motionX,motionY,motionZ);
      }
    }
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 3F,posY - motionY * 3F,posZ - motionZ * 3F,0D,0D,0D);
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 1.5F,posY - motionY * 1.5F,posZ - motionZ * 1.5F,0D,0D,0D);
    setPosition(posX,posY,posZ);
  }
}","@Override public void onUpdate(){
  IBlockState state=worldObj.getBlockState(getPosition());
  Block block=worldObj.getBlockState(getPosition()).getBlock();
  if (!worldObj.isRemote && (shootingEntity != null && shootingEntity.isDead || (block.isAir(state,worldObj,getPosition())))) {
    setDead();
  }
 else {
    super.onUpdate();
    if (inGround) {
      if (worldObj.getBlockState(new BlockPos(x,y,z)) == blockInside) {
        ++ticksAlive;
        if (ticksAlive == 200) {
          setDead();
        }
        return;
      }
      ++ticksAlive;
      if (ticksAlive >= 200) {
        setDead();
      }
      motionX=0;
      motionY=0;
      motionZ=0;
      ticksAlive=0;
      ticksInAir=0;
    }
 else {
      ++ticksInAir;
    }
    Vec3d vec3=new Vec3d(posX,posY,posZ);
    Vec3d vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionY);
    RayTraceResult trace=this.worldObj.rayTraceBlocks(vec3,vec31,false,true,false);
    vec3=new Vec3d(posX,posY,posZ);
    vec31=new Vec3d(posX + motionX,posY + motionY,posZ + motionZ);
    if (trace != null) {
      vec31=trace.hitVec;
    }
    Entity entity=null;
    List<Entity> list=worldObj.getEntitiesWithinAABBExcludingEntity(this,getEntityBoundingBox().addCoord(motionX,motionY,motionZ).expand(0.5D,0.5D,0.5D));
    double d0=0.0D;
    for (    Entity entity1 : list) {
      if (entity1.canBeCollidedWith() && (!entity1.isEntityEqual(shootingEntity) || this.ticksInAir >= 25)) {
        float f=0.3F;
        AxisAlignedBB axisalignedbb=entity1.getEntityBoundingBox().expand((double)f,(double)f,(double)f);
        RayTraceResult trace1=axisalignedbb.calculateIntercept(vec3,vec31);
        if (trace1 != null) {
          double d1=vec3.distanceTo(trace1.hitVec);
          if (d1 < d0 || d0 == 0.0D) {
            entity=entity1;
            d0=d1;
          }
        }
      }
    }
    if (entity != null) {
      trace=new RayTraceResult(entity);
    }
    if (trace != null) {
      this.onImpact();
    }
    posX+=motionX;
    posY+=motionY;
    posZ+=motionZ;
    rotationYaw=(float)(Math.atan2(motionZ,motionX) * 180.0D / Math.PI) + 90.0F;
    while (rotationPitch - prevRotationPitch >= 180.0F) {
      prevRotationPitch+=360.0F;
    }
    while (rotationYaw - prevRotationYaw < -180.0F) {
      prevRotationYaw-=360.0F;
    }
    while (rotationYaw - prevRotationYaw >= 180.0F) {
      prevRotationYaw+=360.0F;
    }
    rotationPitch=prevRotationPitch + (rotationPitch - prevRotationPitch) * 0.2F;
    rotationYaw=prevRotationYaw + (rotationYaw - prevRotationYaw) * 0.2F;
    if (isInWater()) {
      for (int j=0; j < 4; ++j) {
        double f3=0.25D;
        worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE,posX - motionX * f3,posY - motionY * f3,posZ - motionZ * f3,motionX,motionY,motionZ);
      }
    }
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 3F,posY - motionY * 3F,posZ - motionZ * 3F,0D,0D,0D);
    worldObj.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,posX - motionX * 1.5F,posY - motionY * 1.5F,posZ - motionZ * 1.5F,0D,0D,0D);
    setPosition(posX,posY,posZ);
  }
}",0.9972690763052208
22361,"@SubscribeEvent public void walkOnFluid(TickEvent.PlayerTickEvent event){
  EntityPlayer entity=event.player;
  int consumptionHydro=Config.hydrophobicConsumption;
  int consumptionPyro=Config.pyrophobicConsumption;
  IAttributeInstance attributes=entity.getEntityAttribute(SharedMonsterAttributes.movementSpeed);
  AttributeModifier modifierWater=attributes.getModifier(uuid4);
  AttributeModifier modifierLava=attributes.getModifier(uuid5);
  boolean canHydro=canWalkOnFluid(entity,consumptionHydro,SteamcraftItems.coatingsHydrophobic,modifierWater);
  boolean canPyro=canWalkOnFluid(entity,consumptionPyro,SteamcraftItems.coatingsPyrophobic,modifierLava);
  int x=MathHelper.floor_double(entity.posX);
  int y=MathHelper.floor_double(entity.boundingBox.minY - 0.11F);
  int z=MathHelper.floor_double(entity.posZ);
  Block blockUnder=entity.worldObj.getBlock(x,y,z);
  if (canHydro) {
    if (blockUnder == Blocks.water || blockUnder == Blocks.flowing_water) {
      entity.fallDistance=0;
      if (Minecraft.getMinecraft().gameSettings.keyBindJump.isPressed()) {
        entity.motionY=0.5D;
      }
 else {
        entity.motionY=0;
      }
      if (modifierWater == null) {
        attributes.applyModifier(exoWaterBoost);
      }
      SteamcraftEventHandler.drainSteam(entity.getEquipmentInSlot(3),consumptionHydro);
    }
    if (entity.isInWater()) {
      entity.jump();
      entity.fallDistance=0;
    }
  }
 else   if (modifierWater != null) {
    attributes.removeModifier(exoWaterBoost);
  }
  if (canPyro) {
    if (entity.isBurning()) {
      isWalkingInLava=true;
      entity.extinguish();
      entity.motionY=0.5;
    }
    if (blockUnder == Blocks.lava || blockUnder == Blocks.flowing_lava) {
      isWalkingInLava=true;
      if (Minecraft.getMinecraft().gameSettings.keyBindJump.isPressed()) {
        entity.motionY=0.5D;
      }
 else {
        entity.motionY=0;
      }
      if (modifierLava == null) {
        attributes.applyModifier(exoLavaBoost);
      }
      SteamcraftEventHandler.drainSteam(entity.getEquipmentInSlot(3),consumptionPyro);
    }
    if (entity.handleLavaMovement()) {
      isWalkingInLava=true;
      entity.motionY=0.5;
      entity.fallDistance=0;
    }
  }
 else   if (modifierLava != null) {
    attributes.removeModifier(exoLavaBoost);
  }
}","@SubscribeEvent public void walkOnFluid(TickEvent.PlayerTickEvent event){
  EntityPlayer entity=event.player;
  int consumptionHydro=Config.hydrophobicConsumption;
  int consumptionPyro=Config.pyrophobicConsumption;
  IAttributeInstance attributes=entity.getEntityAttribute(SharedMonsterAttributes.movementSpeed);
  AttributeModifier modifierWater=attributes.getModifier(uuid4);
  AttributeModifier modifierLava=attributes.getModifier(uuid5);
  boolean canHydro=canWalkOnFluid(entity,consumptionHydro,SteamcraftItems.coatingsHydrophobic,modifierWater);
  boolean canPyro=canWalkOnFluid(entity,consumptionPyro,SteamcraftItems.coatingsPyrophobic,modifierLava);
  int x=MathHelper.floor_double(entity.posX);
  int y=MathHelper.floor_double(entity.boundingBox.minY - 0.11F);
  int z=MathHelper.floor_double(entity.posZ);
  Block blockUnder=entity.worldObj.getBlock(x,y,z);
  if (event.side == Side.CLIENT) {
    isJumping=Minecraft.getMinecraft().gameSettings.keyBindJump.getIsKeyPressed();
  }
  if (canHydro) {
    if (blockUnder == Blocks.water || blockUnder == Blocks.flowing_water) {
      entity.fallDistance=0;
      if (isJumping) {
        entity.motionY=0.5D;
      }
 else {
        entity.motionY=0;
      }
      if (modifierWater == null) {
        attributes.applyModifier(exoWaterBoost);
      }
      SteamcraftEventHandler.drainSteam(entity.getEquipmentInSlot(3),consumptionHydro);
    }
    if (entity.isInWater()) {
      entity.jump();
      entity.fallDistance=0;
    }
  }
 else   if (modifierWater != null) {
    attributes.removeModifier(exoWaterBoost);
  }
  if (canPyro) {
    if (entity.isBurning()) {
      isWalkingInLava=true;
      entity.extinguish();
      entity.motionY=0.5;
    }
    if (blockUnder == Blocks.lava || blockUnder == Blocks.flowing_lava) {
      isWalkingInLava=true;
      if (Minecraft.getMinecraft().gameSettings.keyBindJump.isPressed()) {
        entity.motionY=0.5D;
      }
 else {
        entity.motionY=0;
      }
      if (modifierLava == null) {
        attributes.applyModifier(exoLavaBoost);
      }
      SteamcraftEventHandler.drainSteam(entity.getEquipmentInSlot(3),consumptionPyro);
    }
    if (entity.handleLavaMovement()) {
      isWalkingInLava=true;
      entity.motionY=0.5;
      entity.fallDistance=0;
    }
  }
 else   if (modifierLava != null) {
    attributes.removeModifier(exoLavaBoost);
  }
}",0.9605995717344754
22362,"@Override public boolean onBlockDestroyed(ItemStack p_150894_1_,World p_150894_2_,Block p_150894_3_,int p_150894_4_,int p_150894_5_,int p_150894_6_,EntityLivingBase p_150894_7_){
  hasBrokenBlock=true;
  return true;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean onBlockDestroyed(ItemStack stack,World p_150894_2_,Block p_150894_3_,int p_150894_4_,int p_150894_5_,int p_150894_6_,EntityLivingBase p_150894_7_){
  NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
  MutablePair<Integer,Integer> pair=ticksSpeed.get(stack);
  nbt.setInteger(""String_Node_Str"",pair.getLeft());
  nbt.setInteger(""String_Node_Str"",pair.getRight());
  hasBrokenBlock=true;
  ticksSpeed.remove(stack);
  return true;
}",0.5357643758765779
22363,"@SuppressWarnings(""String_Node_Str"") @Override public void onUpdate(ItemStack stack,World world,Entity player,int par4,boolean par5){
  if (player instanceof EntityPlayer) {
    NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
    int ticks=nbt.getInteger(""String_Node_Str"");
    int speed=nbt.getInteger(""String_Node_Str"");
    if (hasBrokenBlock) {
      speed-=10;
      hasBrokenBlock=false;
    }
    int addedTicks=Math.min(((Double)Math.floor((double)speed / 1000D * 25D)).intValue(),50);
    ticks+=addedTicks;
    if (speed > 0) {
      speed--;
    }
 else     if (ticks <= 0) {
      ticks=0;
    }
 else {
      ticks--;
    }
    if (ticks <= 50 && speed > 0) {
      world.playSoundAtEntity(player,""String_Node_Str"",1.0F,1.0F);
    }
    ticks=ticks % 100;
    nbt.setInteger(""String_Node_Str"",ticks);
    nbt.setInteger(""String_Node_Str"",speed);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void onUpdate(ItemStack stack,World world,Entity player,int par4,boolean par5){
  if (player instanceof EntityPlayer) {
    NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
    int ticks=nbt.getInteger(""String_Node_Str"");
    int speed=nbt.getInteger(""String_Node_Str"");
    if (hasBrokenBlock) {
      speed-=10;
      hasBrokenBlock=false;
    }
    int addedTicks=Math.min(((Double)Math.floor((double)speed / 1000D * 25D)).intValue(),50);
    ticks+=addedTicks;
    if (speed > 0) {
      speed--;
    }
 else     if (ticks <= 0) {
      ticks=0;
    }
 else {
      ticks--;
    }
    ticks=ticks % 100;
    if (((EntityLivingBase)player).isSwingInProgress) {
      if (ticksSpeed.containsKey(stack)) {
        ticksSpeed.get(stack).setLeft(ticks);
        ticksSpeed.get(stack).setRight(speed);
      }
 else {
        ticksSpeed.put(stack,MutablePair.of(ticks,speed));
      }
    }
 else {
      nbt.setInteger(""String_Node_Str"",ticks);
      nbt.setInteger(""String_Node_Str"",speed);
    }
  }
}",0.7883817427385892
22364,"@Override public boolean onBlockDestroyed(ItemStack stack,World world,Block block,int x,int y,int z,EntityLivingBase entity){
  hasBrokenBlock=true;
  return true;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean onBlockDestroyed(ItemStack stack,World world,Block block,int x,int y,int z,EntityLivingBase entity){
  NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
  MutablePair<Integer,Integer> pair=ticksSpeed.get(stack);
  nbt.setInteger(""String_Node_Str"",pair.getLeft());
  nbt.setInteger(""String_Node_Str"",pair.getRight());
  hasBrokenBlock=true;
  ticksSpeed.remove(stack);
  return true;
}",0.4861337683523654
22365,"@Override public void onUpdate(ItemStack stack,World world,Entity player,int par4,boolean par5){
  if (player instanceof EntityPlayer) {
    NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
    int ticks=nbt.getInteger(""String_Node_Str"");
    int speed=nbt.getInteger(""String_Node_Str"");
    if (hasBrokenBlock) {
      speed-=10;
      hasBrokenBlock=false;
    }
    int addedTicks=Math.min(((Double)Math.floor((double)speed / 1000D * 25D)).intValue(),50);
    ticks+=addedTicks;
    if (isWound(stack)) {
      speed--;
    }
 else     if (ticks <= 0) {
      ticks=0;
    }
 else {
      ticks--;
    }
    ticks=ticks % 100;
    nbt.setInteger(""String_Node_Str"",ticks);
    nbt.setInteger(""String_Node_Str"",speed);
  }
}","@Override public void onUpdate(ItemStack stack,World world,Entity player,int par4,boolean par5){
  if (player instanceof EntityPlayer) {
    NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
    int ticks=nbt.getInteger(""String_Node_Str"");
    int speed=nbt.getInteger(""String_Node_Str"");
    if (hasBrokenBlock) {
      speed-=10;
      hasBrokenBlock=false;
    }
    int addedTicks=Math.min(((Double)Math.floor((double)speed / 1000D * 25D)).intValue(),50);
    ticks+=addedTicks;
    if (isWound(stack)) {
      speed--;
    }
 else     if (ticks <= 0) {
      ticks=0;
    }
 else {
      ticks--;
    }
    ticks=ticks % 100;
    if (((EntityLivingBase)player).isSwingInProgress) {
      if (ticksSpeed.containsKey(stack)) {
        ticksSpeed.get(stack).setLeft(ticks);
        ticksSpeed.get(stack).setRight(speed);
      }
 else {
        ticksSpeed.put(stack,MutablePair.of(ticks,speed));
      }
    }
 else {
      nbt.setInteger(""String_Node_Str"",ticks);
      nbt.setInteger(""String_Node_Str"",speed);
    }
  }
}",0.8296296296296296
22366,"@Override public boolean onBlockDestroyed(ItemStack p_150894_1_,World p_150894_2_,Block p_150894_3_,int p_150894_4_,int p_150894_5_,int p_150894_6_,EntityLivingBase p_150894_7_){
  hasBrokenBlock=true;
  return true;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean onBlockDestroyed(ItemStack stack,World p_150894_2_,Block p_150894_3_,int p_150894_4_,int p_150894_5_,int p_150894_6_,EntityLivingBase p_150894_7_){
  NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
  MutablePair<Integer,Integer> pair=ticksSpeed.get(stack);
  nbt.setInteger(""String_Node_Str"",pair.getLeft());
  nbt.setInteger(""String_Node_Str"",pair.getRight());
  hasBrokenBlock=true;
  ticksSpeed.remove(stack);
  return true;
}",0.5357643758765779
22367,"@SuppressWarnings(""String_Node_Str"") @Override public void onUpdate(ItemStack stack,World world,Entity player,int par4,boolean par5){
  if (player instanceof EntityPlayer) {
    NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
    int ticks=nbt.getInteger(""String_Node_Str"");
    int speed=nbt.getInteger(""String_Node_Str"");
    if (hasBrokenBlock) {
      speed-=10;
      hasBrokenBlock=false;
    }
    int addedTicks=Math.min(((Double)Math.floor((double)speed / 1000D * 25D)).intValue(),50);
    ticks+=addedTicks;
    if (speed > 0) {
      speed--;
    }
 else     if (ticks <= 0) {
      ticks=0;
    }
 else {
      ticks--;
    }
    if (ticks <= 50 && speed > 0) {
      world.playSoundAtEntity(player,""String_Node_Str"",1.0F,1.0F);
    }
    ticks=ticks % 100;
    nbt.setInteger(""String_Node_Str"",ticks);
    nbt.setInteger(""String_Node_Str"",speed);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void onUpdate(ItemStack stack,World world,Entity player,int par4,boolean par5){
  if (player instanceof EntityPlayer) {
    NBTTagCompound nbt=SteamToolHelper.checkNBT(stack);
    int ticks=nbt.getInteger(""String_Node_Str"");
    int speed=nbt.getInteger(""String_Node_Str"");
    if (hasBrokenBlock) {
      speed-=10;
      hasBrokenBlock=false;
    }
    int addedTicks=Math.min(((Double)Math.floor((double)speed / 1000D * 25D)).intValue(),50);
    ticks+=addedTicks;
    if (speed > 0) {
      speed--;
    }
 else     if (ticks <= 0) {
      ticks=0;
    }
 else {
      ticks--;
    }
    ticks=ticks % 100;
    if (((EntityLivingBase)player).isSwingInProgress) {
      if (ticksSpeed.containsKey(stack)) {
        ticksSpeed.get(stack).setLeft(ticks);
        ticksSpeed.get(stack).setRight(speed);
      }
 else {
        ticksSpeed.put(stack,MutablePair.of(ticks,speed));
      }
    }
 else {
      nbt.setInteger(""String_Node_Str"",ticks);
      nbt.setInteger(""String_Node_Str"",speed);
    }
  }
}",0.7883817427385892
22368,"@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int side,float xf,float yf,float zf){
  if (world.getBlockMetadata(x,y,z) <= 0) {
    return false;
  }
  TileEntityFlashBoiler tileEntity=(TileEntityFlashBoiler)world.getTileEntity(x,y,z);
  boolean isClient=!world.isRemote;
  if (!FluidHelper.playerIsHoldingWaterContainer(player) && isClient && tileEntity != null) {
    player.openGui(Steamcraft.instance,0,world,x,y,z);
  }
 else {
    FluidHelper.fillTankFromHeldItem(player,tileEntity.myTank);
  }
  return true;
}","@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int side,float xf,float yf,float zf){
  if (world.getBlockMetadata(x,y,z) <= 0) {
    return false;
  }
  TileEntityFlashBoiler tileEntity=(TileEntityFlashBoiler)world.getTileEntity(x,y,z);
  if (tileEntity == null) {
    return false;
  }
  boolean isClient=!world.isRemote;
  if (!FluidHelper.playerIsHoldingWaterContainer(player) && isClient) {
    player.openGui(Steamcraft.instance,0,world,x,y,z);
  }
 else {
    FluidHelper.fillTankFromHeldItem(player,tileEntity.getTank());
  }
  return true;
}",0.9317199654278306
22369,"@Override public ItemStack decrStackSize(int par1,int par2){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    if (this.furnaceItemStacks[par1] != null) {
      ItemStack itemstack;
      if (this.furnaceItemStacks[par1].stackSize <= par2) {
        itemstack=this.furnaceItemStacks[par1];
        this.furnaceItemStacks[par1]=null;
        return itemstack;
      }
 else {
        itemstack=this.furnaceItemStacks[par1].splitStack(par2);
        if (this.furnaceItemStacks[par1].stackSize == 0) {
          this.furnaceItemStacks[par1]=null;
        }
        return itemstack;
      }
    }
 else {
      return null;
    }
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().decrStackSize(par1,par2) : null;
  }
}","@Override public ItemStack decrStackSize(int par1,int par2){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    if (this.furnaceItemStacks[par1] != null) {
      ItemStack itemstack;
      if (this.furnaceItemStacks[par1].stackSize <= par2) {
        itemstack=this.furnaceItemStacks[par1];
        this.furnaceItemStacks[par1]=null;
        return itemstack;
      }
 else {
        itemstack=this.furnaceItemStacks[par1].splitStack(par2);
        if (this.furnaceItemStacks[par1].stackSize == 0) {
          this.furnaceItemStacks[par1]=null;
        }
        return itemstack;
      }
    }
 else {
      return null;
    }
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().decrStackSize(par1,par2) : null;
  }
}",0.9836683417085428
22370,"@SideOnly(Side.CLIENT) @Override public int getBurnTimeRemainingScaled(int scale){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    if (this.currentItemBurnTime == 0) {
      this.currentItemBurnTime=200;
    }
    return this.furnaceBurnTime * scale / this.currentItemBurnTime;
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().getBurnTimeRemainingScaled(scale) : 0;
  }
}","@SideOnly(Side.CLIENT) @Override public int getBurnTimeRemainingScaled(int scale){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    if (this.currentItemBurnTime == 0) {
      this.currentItemBurnTime=200;
    }
    return this.furnaceBurnTime * scale / this.currentItemBurnTime;
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().getBurnTimeRemainingScaled(scale) : 0;
  }
}",0.9714285714285714
22371,"@Override public void setInventorySlotContents(int par1,ItemStack par2ItemStack){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    this.furnaceItemStacks[par1]=par2ItemStack;
    if (par2ItemStack != null && par2ItemStack.stackSize > this.getInventoryStackLimit()) {
      par2ItemStack.stackSize=this.getInventoryStackLimit();
    }
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    getMasterTileEntity().setInventorySlotContents(par1,par2ItemStack);
  }
}","@Override public void setInventorySlotContents(int par1,ItemStack par2ItemStack){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    this.furnaceItemStacks[par1]=par2ItemStack;
    if (par2ItemStack != null && par2ItemStack.stackSize > this.getInventoryStackLimit()) {
      par2ItemStack.stackSize=this.getInventoryStackLimit();
    }
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    getPrimaryTileEntity().setInventorySlotContents(par1,par2ItemStack);
  }
}",0.986986986986987
22372,"@Override public boolean canExtractItem(int slot,ItemStack stack,int side){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    return stack.getItem() == Items.bucket;
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().canExtractItem(slot,stack,side) : false;
  }
}","@Override public boolean canExtractItem(int slot,ItemStack stack,int side){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    return stack.getItem() == Items.bucket;
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().canExtractItem(slot,stack,side) : false;
  }
}",0.9620991253644317
22373,"@Override public boolean isBurning(){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    return this.furnaceBurnTime > 0;
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    if (getMasterTileEntity() != null) {
      return getMasterTileEntity().isBurning();
    }
 else     return false;
  }
 else   return false;
}","@Override public boolean isBurning(){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    return this.furnaceBurnTime > 0;
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    if (getPrimaryTileEntity() != null) {
      return getPrimaryTileEntity().isBurning();
    }
 else     return false;
  }
 else   return false;
}",0.9633802816901408
22374,"@Override public void insertSteam(int amount,ForgeDirection face){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 && this.getNetwork() != null) {
    this.getNetwork().addSteam(amount);
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    getMasterTileEntity().insertSteam(amount,face);
  }
}","@Override public void insertSteam(int amount,ForgeDirection face){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 && this.getNetwork() != null) {
    this.getNetwork().addSteam(amount);
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    getPrimaryTileEntity().insertSteam(amount,face);
  }
}",0.9800918836140888
22375,"@Override public int fill(ForgeDirection from,FluidStack resource,boolean doFill){
  int meta=worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
  if (meta == 1) {
    return myTank.fill(resource,doFill);
  }
 else   if (meta > 0 && hasMaster()) {
    return getMasterTileEntity().fill(from,resource,doFill);
  }
 else {
    return 0;
  }
}","@Override public int fill(ForgeDirection from,FluidStack resource,boolean doFill){
  int meta=worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
  if (meta == 1) {
    return myTank.fill(resource,doFill);
  }
 else   if (meta > 0 && hasPrimary()) {
    return getPrimaryTileEntity().fill(from,resource,doFill);
  }
 else {
    return 0;
  }
}",0.9616519174041298
22376,"@Override public int getSizeInventory(){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? this.furnaceItemStacks.length : (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().getSizeInventory() : 0);
}","@Override public int getSizeInventory(){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? this.furnaceItemStacks.length : (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().getSizeInventory() : 0);
}",0.94921875
22377,"@Override public ItemStack getStackInSlotOnClosing(int par1){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    if (this.furnaceItemStacks[par1] != null) {
      ItemStack itemstack=this.furnaceItemStacks[par1];
      this.furnaceItemStacks[par1]=null;
      return itemstack;
    }
 else {
      return null;
    }
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().getStackInSlotOnClosing(par1) : null;
  }
}","@Override public ItemStack getStackInSlotOnClosing(int par1){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
    if (this.furnaceItemStacks[par1] != null) {
      ItemStack itemstack=this.furnaceItemStacks[par1];
      this.furnaceItemStacks[par1]=null;
      return itemstack;
    }
 else {
      return null;
    }
  }
 else {
    return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().getStackInSlotOnClosing(par1) : null;
  }
}",0.973469387755102
22378,"@SideOnly(Side.CLIENT) @Override public int getCookProgressScaled(int scale){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? this.furnaceCookTime * scale / 200 : (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().getCookProgressScaled(scale) : 0);
}","@SideOnly(Side.CLIENT) @Override public int getCookProgressScaled(int scale){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? this.furnaceCookTime * scale / 200 : (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().getCookProgressScaled(scale) : 0);
}",0.9577922077922078
22379,"@Override public FluidTank getTank(){
  if (this.getBlockMetadata() > 0) {
    if (this.getBlockMetadata() == 1) {
      return this.myTank;
    }
 else {
      if (this.hasMaster()) {
        return this.getMasterTileEntity().getTank();
      }
    }
  }
  return null;
}","@Override public FluidTank getTank(){
  if (this.getBlockMetadata() > 0) {
    if (this.getBlockMetadata() == 1) {
      return this.myTank;
    }
 else {
      if (this.hasPrimary()) {
        return this.getPrimaryTileEntity().getTank();
      }
    }
  }
  return null;
}",0.8461538461538461
22380,"private boolean canSmelt(){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? myTank.getFluidAmount() > 9 : worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().canSmelt() : false;
}","private boolean canSmelt(){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? myTank.getFluidAmount() > 9 : worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().canSmelt() : false;
}",0.9446808510638298
22381,"@Override public ItemStack getStackInSlot(int slot){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? this.furnaceItemStacks[slot] : (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().getStackInSlot(slot) : null);
}","@Override public ItemStack getStackInSlot(int slot){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? this.furnaceItemStacks[slot] : (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().getStackInSlot(slot) : null);
}",0.9522058823529412
22382,"@Override public void decrSteam(int i){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 && this.getNetwork() != null) {
    this.getNetwork().decrSteam(i);
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    getMasterTileEntity().decrSteam(i);
  }
}","@Override public void decrSteam(int i){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 && this.getNetwork() != null) {
    this.getNetwork().decrSteam(i);
  }
 else   if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0) {
    getPrimaryTileEntity().decrSteam(i);
  }
}",0.9770723104056436
22383,"public boolean getBurning(){
  int meta=getBlockMetadata();
  if (meta > 0) {
    if (meta == 1) {
      return this.burning;
    }
 else {
      if (this.hasMaster()) {
        return this.getMasterTileEntity().isBurning();
      }
    }
  }
  return false;
}","public boolean getBurning(){
  int meta=getBlockMetadata();
  if (meta > 0) {
    if (meta == 1) {
      return this.burning;
    }
 else {
      if (this.hasPrimary()) {
        return this.getPrimaryTileEntity().isBurning();
      }
    }
  }
  return false;
}",0.8390804597701149
22384,"@Override public FluidTankInfo[] getTankInfo(ForgeDirection from){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? new FluidTankInfo[]{new FluidTankInfo(myTank)} : worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? getMasterTileEntity().getTankInfo(from) : new FluidTankInfo[]{new FluidTankInfo(new FluidTank(0))};
}","@Override public FluidTankInfo[] getTankInfo(ForgeDirection from){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1 ? new FluidTankInfo[]{new FluidTankInfo(myTank)} : worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? getPrimaryTileEntity().getTankInfo(from) : new FluidTankInfo[]{new FluidTankInfo(new FluidTank(0))};
}",0.9629629629629628
22385,"@Override public int getCapacity(){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? this.capacity : 0;
}","@Override public int getCapacity(){
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? this.capacity : 0;
}",0.966542750929368
22386,"@Override public boolean canInsertItem(int slot,ItemStack stack,int side){
  int[] accessibleSlots=getAccessibleSlotsFromSide(side);
  boolean isAccessibleSlot=false;
  for (int i=0; i < accessibleSlots.length; i++) {
    if (accessibleSlots[i] == slot)     isAccessibleSlot=true;
  }
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasMaster() ? this.isItemValidForSlot(slot,stack) && isAccessibleSlot : false;
}","@Override public boolean canInsertItem(int slot,ItemStack stack,int side){
  int[] accessibleSlots=getAccessibleSlotsFromSide(side);
  boolean isAccessibleSlot=false;
  for (int i=0; i < accessibleSlots.length; i++) {
    if (accessibleSlots[i] == slot)     isAccessibleSlot=true;
  }
  return worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 0 && hasPrimary() ? this.isItemValidForSlot(slot,stack) && isAccessibleSlot : false;
}",0.9848661233993016
22387,"/** 
 * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
 */
@Override public ItemStack onItemRightClick(ItemStack par1ItemStack,World par2World,EntityPlayer par3EntityPlayer){
  NBTTagCompound nbt=par1ItemStack.getTagCompound();
  boolean crouched=par3EntityPlayer.isSneaking();
  if (!crouched) {
    if (!par1ItemStack.hasTagCompound()) {
      par1ItemStack.setTagCompound(new NBTTagCompound());
      nbt=par1ItemStack.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    if (nbt.getInteger(""String_Node_Str"") > 0 || par3EntityPlayer.capabilities.isCreativeMode) {
      if (!par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"") || par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"") == 0) {
        float enhancementAccuracy=0.0F;
        float enhancementExplosionSize=0.0F;
        int enhancementDelay=0;
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            enhancementAccuracy=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getAccuracyChange(this);
            enhancementExplosionSize=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getExplosionChange(this);
            enhancementDelay=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getFireDelayChange(par1ItemStack);
          }
        }
        float var7=1.0F;
        if (var7 < 0.1D) {
          return par1ItemStack;
        }
        if (var7 > 1.0F) {
          var7=1.0F;
        }
        EntityRocket var8=new EntityRocket(par2World,par3EntityPlayer,((1.0F + accuracy + enhancementAccuracy) - var7),this.explosionSize + enhancementExplosionSize);
        int selectedRocketType=0;
        if (par1ItemStack.hasTagCompound()) {
          if (par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
            selectedRocketType=par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"");
          }
        }
        var8=SteamcraftRegistry.rockets.get(selectedRocketType).changeBullet(var8);
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            var8=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).changeBullet(var8);
          }
        }
        par1ItemStack.damageItem(1,par3EntityPlayer);
        par2World.playSoundAtEntity(par3EntityPlayer,""String_Node_Str"",(1.0F * (2F / 5F)) * (UtilEnhancements.getEnhancementFromItem(par1ItemStack) != null && UtilEnhancements.getEnhancementFromItem(par1ItemStack).getID() == ""String_Node_Str"" ? 0.4F : 1.0F),1.0F / (itemRand.nextFloat() * 0.4F + 1.2F) + var7 * 0.5F);
        if (!par2World.isRemote) {
          par2World.spawnEntityInWorld(var8);
        }
        ArrowLooseEvent event=new ArrowLooseEvent(par3EntityPlayer,par1ItemStack,1);
        MinecraftForge.EVENT_BUS.post(event);
        nbt.setInteger(""String_Node_Str"",nbt.getInteger(""String_Node_Str"") - 1);
        if (par2World.isRemote && !par3EntityPlayer.capabilities.isCreativeMode) {
          boolean crouching=par3EntityPlayer.isSneaking();
        }
        if (!par3EntityPlayer.onGround && !par3EntityPlayer.capabilities.isFlying && UtilEnhancements.hasEnhancement(par1ItemStack)&& UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof ItemEnhancementAirStrike) {
          par1ItemStack.stackTagCompound.setInteger(""String_Node_Str"",this.timeBetweenFire + enhancementDelay);
        }
      }
    }
 else {
      NBTTagCompound nbtt=par1ItemStack.getTagCompound();
      if (par3EntityPlayer.capabilities.isCreativeMode) {
        int enhancementShells=0;
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            enhancementShells=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getClipSizeChange(this);
          }
        }
        nbtt.setInteger(""String_Node_Str"",1);
        nbtt.setInteger(""String_Node_Str"",this.shellCount + enhancementShells);
      }
      par3EntityPlayer.setItemInUse(par1ItemStack,this.getMaxItemUseDuration(par1ItemStack));
    }
  }
 else {
    if (!par1ItemStack.hasTagCompound()) {
      par1ItemStack.setTagCompound(new NBTTagCompound());
      nbt=par1ItemStack.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    int selectedRocketType=0;
    if (par1ItemStack.hasTagCompound()) {
      if (par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
        selectedRocketType=par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"");
      }
    }
    int prevRocketType=selectedRocketType;
    selectedRocketType=(selectedRocketType + 1) % SteamcraftRegistry.rockets.size();
    nbt.setInteger(""String_Node_Str"",selectedRocketType);
    if (selectedRocketType != prevRocketType && par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"") > 0) {
      ItemStack stack=new ItemStack(((Item)SteamcraftRegistry.rockets.get(prevRocketType)),nbt.getInteger(""String_Node_Str""),0);
      if (!par3EntityPlayer.worldObj.isRemote) {
        EntityItem entityItem=new EntityItem(par3EntityPlayer.worldObj,par3EntityPlayer.posX,par3EntityPlayer.posY,par3EntityPlayer.posZ,stack);
        par3EntityPlayer.worldObj.spawnEntityInWorld(entityItem);
      }
      nbt.setInteger(""String_Node_Str"",0);
    }
  }
  return par1ItemStack;
}","/** 
 * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
 */
@Override public ItemStack onItemRightClick(ItemStack self,World world,EntityPlayer player){
  NBTTagCompound nbt=self.getTagCompound();
  boolean crouched=player.isSneaking();
  if (!crouched) {
    if (!self.hasTagCompound()) {
      self.setTagCompound(new NBTTagCompound());
      nbt=self.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    if (nbt.getInteger(""String_Node_Str"") > 0 || player.capabilities.isCreativeMode) {
      if (!self.stackTagCompound.hasKey(""String_Node_Str"") || self.stackTagCompound.getInteger(""String_Node_Str"") == 0) {
        float enhancementAccuracy=0.0F;
        float enhancementExplosionSize=0.0F;
        int enhancementDelay=0;
        if (UtilEnhancements.hasEnhancement(self)) {
          if (UtilEnhancements.getEnhancementFromItem(self) instanceof IEnhancementRocketLauncher) {
            enhancementAccuracy=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(self)).getAccuracyChange(this);
            enhancementExplosionSize=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(self)).getExplosionChange(this);
            enhancementDelay=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(self)).getFireDelayChange(self);
          }
        }
        float var7=1.0F;
        if (var7 < 0.1D) {
          return self;
        }
        if (var7 > 1.0F) {
          var7=1.0F;
        }
        EntityRocket var8=new EntityRocket(world,player,((1.0F + accuracy + enhancementAccuracy) - var7),this.explosionSize + enhancementExplosionSize);
        int selectedRocketType=0;
        if (self.hasTagCompound()) {
          if (self.stackTagCompound.hasKey(""String_Node_Str"")) {
            selectedRocketType=self.stackTagCompound.getInteger(""String_Node_Str"");
          }
        }
        var8=SteamcraftRegistry.rockets.get(selectedRocketType).changeBullet(var8);
        if (UtilEnhancements.hasEnhancement(self)) {
          if (UtilEnhancements.getEnhancementFromItem(self) instanceof IEnhancementRocketLauncher) {
            var8=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(self)).changeBullet(var8);
          }
        }
        self.damageItem(1,player);
        world.playSoundAtEntity(player,""String_Node_Str"",(1.0F * (2F / 5F)) * (UtilEnhancements.getEnhancementFromItem(self) != null && UtilEnhancements.getEnhancementFromItem(self).getID() == ""String_Node_Str"" ? 0.4F : 1.0F),1.0F / (itemRand.nextFloat() * 0.4F + 1.2F) + var7 * 0.5F);
        if (!world.isRemote) {
          world.spawnEntityInWorld(var8);
        }
        ArrowLooseEvent event=new ArrowLooseEvent(player,self,1);
        MinecraftForge.EVENT_BUS.post(event);
        nbt.setInteger(""String_Node_Str"",nbt.getInteger(""String_Node_Str"") - 1);
        if (world.isRemote && !player.capabilities.isCreativeMode) {
          boolean crouching=player.isSneaking();
        }
        if (player.capabilities.isFlying && !(player.onGround && UtilEnhancements.hasEnhancement(self) && UtilEnhancements.getEnhancementFromItem(self) instanceof ItemEnhancementAirStrike)) {
          self.stackTagCompound.setInteger(""String_Node_Str"",this.timeBetweenFire + enhancementDelay);
        }
      }
    }
 else {
      NBTTagCompound nbtt=self.getTagCompound();
      if (player.capabilities.isCreativeMode) {
        int enhancementShells=0;
        if (UtilEnhancements.hasEnhancement(self)) {
          if (UtilEnhancements.getEnhancementFromItem(self) instanceof IEnhancementRocketLauncher) {
            enhancementShells=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(self)).getClipSizeChange(this);
          }
        }
        nbtt.setInteger(""String_Node_Str"",1);
        nbtt.setInteger(""String_Node_Str"",this.shellCount + enhancementShells);
      }
      player.setItemInUse(self,this.getMaxItemUseDuration(self));
    }
  }
 else {
    if (!self.hasTagCompound()) {
      self.setTagCompound(new NBTTagCompound());
      nbt=self.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    int selectedRocketType=0;
    if (self.hasTagCompound()) {
      if (self.stackTagCompound.hasKey(""String_Node_Str"")) {
        selectedRocketType=self.stackTagCompound.getInteger(""String_Node_Str"");
      }
    }
    int prevRocketType=selectedRocketType;
    selectedRocketType=(selectedRocketType + 1) % SteamcraftRegistry.rockets.size();
    nbt.setInteger(""String_Node_Str"",selectedRocketType);
    if (selectedRocketType != prevRocketType && self.stackTagCompound.getInteger(""String_Node_Str"") > 0) {
      ItemStack stack=new ItemStack(((Item)SteamcraftRegistry.rockets.get(prevRocketType)),nbt.getInteger(""String_Node_Str""),0);
      if (!player.worldObj.isRemote) {
        EntityItem entityItem=new EntityItem(player.worldObj,player.posX,player.posY,player.posZ,stack);
        player.worldObj.spawnEntityInWorld(entityItem);
      }
      nbt.setInteger(""String_Node_Str"",0);
    }
  }
  return self;
}",0.7962247191011236
22388,"@SubscribeEvent public void sendToVoid(BlockEvent.HarvestDropsEvent event){
  if (event.harvester == null || event.block == null) {
    return;
  }
  EntityPlayer player=event.harvester;
  World world=event.world;
  ItemStack equipped=player.getCurrentEquippedItem();
  if (!canDoVoidThings(equipped) || player.isSneaking()) {
    return;
  }
  if (equipped.hasTagCompound() && equipped.stackTagCompound.hasKey(""String_Node_Str"")) {
    NBTTagCompound nbt=equipped.stackTagCompound.getCompoundTag(""String_Node_Str"");
    int invX=nbt.getInteger(""String_Node_Str"");
    int invY=nbt.getInteger(""String_Node_Str"");
    int invZ=nbt.getInteger(""String_Node_Str"");
    TileEntity tile=world.getTileEntity(invX,invY,invZ);
    int x=event.x;
    int y=event.y;
    int z=event.z;
    if (tile == null || (invX == x && invY == y && invZ == z)) {
      equipped.getTagCompound().removeTag(""String_Node_Str"");
      indicateVoidSet(world,x,y,z);
      return;
    }
    if (tile instanceof IInventory) {
      addToInventory(event.drops,(IInventory)tile);
    }
    tile.updateEntity();
  }
 else {
    InventoryEnderChest ender=player.getInventoryEnderChest();
    addToInventory(event.drops,ender);
    ender.saveInventoryToNBT();
  }
  event.drops.clear();
}","@SubscribeEvent(priority=EventPriority.LOWEST) public void sendToVoid(BlockEvent.HarvestDropsEvent event){
  if (event.harvester == null || event.block == null) {
    return;
  }
  EntityPlayer player=event.harvester;
  World world=event.world;
  ItemStack equipped=player.getCurrentEquippedItem();
  if (!canDoVoidThings(equipped) || player.isSneaking()) {
    return;
  }
  ArrayList<ItemStack> failures=new ArrayList<>();
  if (equipped.hasTagCompound() && equipped.stackTagCompound.hasKey(""String_Node_Str"")) {
    NBTTagCompound nbt=equipped.stackTagCompound.getCompoundTag(""String_Node_Str"");
    int invX=nbt.getInteger(""String_Node_Str"");
    int invY=nbt.getInteger(""String_Node_Str"");
    int invZ=nbt.getInteger(""String_Node_Str"");
    TileEntity tile=world.getTileEntity(invX,invY,invZ);
    int x=event.x;
    int y=event.y;
    int z=event.z;
    if (tile == null || (invX == x && invY == y && invZ == z)) {
      equipped.getTagCompound().removeTag(""String_Node_Str"");
      indicateVoidSet(world,x,y,z);
      return;
    }
    if (tile instanceof IInventory) {
      failures=addToInventory(event.drops,(IInventory)tile);
    }
    tile.updateEntity();
  }
 else {
    InventoryEnderChest ender=player.getInventoryEnderChest();
    failures=addToInventory(event.drops,ender);
    ender.saveInventoryToNBT();
  }
  event.drops.clear();
  if (!failures.isEmpty()) {
    event.drops.addAll(failures);
  }
}",0.9375233819678264
22389,"/** 
 * Adds the drops to the inventory.
 * @param drops An ArrayList of items to add to the inventory.
 * @param inv   The inventory to add items to.
 */
private void addToInventory(ArrayList<ItemStack> drops,IInventory inv){
  for (  ItemStack drop : drops) {
    if (drop == null) {
      continue;
    }
    for (int i=0; i < inv.getSizeInventory(); i++) {
      ItemStack stackInSlot=inv.getStackInSlot(i);
      if (stackInSlot == null) {
        inv.setInventorySlotContents(i,drop);
        break;
      }
 else       if (stackInSlot.getItem() == drop.getItem() && stackInSlot.getItemDamage() == drop.getItemDamage() && stackInSlot.stackSize + drop.stackSize < stackInSlot.getMaxStackSize()) {
        stackInSlot.stackSize+=drop.stackSize;
        inv.setInventorySlotContents(i,stackInSlot);
        break;
      }
    }
  }
}","/** 
 * Adds the drops to the inventory.
 * @param drops An ArrayList of items to add to the inventory.
 * @param inv   The inventory to add items to.
 * @return The items that did not get added.
 */
private ArrayList<ItemStack> addToInventory(ArrayList<ItemStack> drops,IInventory inv){
  ArrayList<ItemStack> failures=new ArrayList<>();
  for (  ItemStack drop : drops) {
    if (drop == null) {
      continue;
    }
    boolean added=false;
    for (int i=0; i < inv.getSizeInventory(); i++) {
      ItemStack stackInSlot=inv.getStackInSlot(i);
      if (stackInSlot == null) {
        inv.setInventorySlotContents(i,drop);
        added=true;
        break;
      }
 else       if (stackInSlot.getItem() == drop.getItem() && stackInSlot.getItemDamage() == drop.getItemDamage() && stackInSlot.stackSize + drop.stackSize < stackInSlot.getMaxStackSize()) {
        stackInSlot.stackSize+=drop.stackSize;
        inv.setInventorySlotContents(i,stackInSlot);
        added=true;
        break;
      }
    }
    if (!added) {
      failures.add(drop);
    }
  }
  return failures;
}",0.867570385818561
22390,"@SubscribeEvent public void handlePainfulFrequencies(AnimalTradeEvent event){
  EntityLiving entity=event.salesperson;
  NBTTagCompound nbt=entity.getEntityData();
  if (nbt.getInteger(""String_Node_Str"") > nbt.getInteger(""String_Node_Str"")) {
    entity.setAttackTarget(event.customer);
  }
}","@SubscribeEvent @SideOnly(Side.CLIENT) public void handlePainfulFrequencies(AnimalTradeEvent event){
  EntityLiving entity=event.salesperson;
  NBTTagCompound nbt=entity.getEntityData();
  if (nbt.getInteger(""String_Node_Str"") > nbt.getInteger(""String_Node_Str"")) {
    entity.setAttackTarget(event.customer);
  }
}",0.9621087314662272
22391,"@SubscribeEvent @SideOnly(Side.CLIENT) public void handlePainfulFrequencies(AnimalTradeEvent event){
  EntityLiving entity=event.salesperson;
  NBTTagCompound nbt=entity.getEntityData();
  if (nbt.getInteger(""String_Node_Str"") > nbt.getInteger(""String_Node_Str"")) {
    entity.setAttackTarget(event.customer);
  }
}","@SubscribeEvent public void handlePainfulFrequencies(AnimalTradeEvent event){
  EntityLiving entity=event.salesperson;
  NBTTagCompound nbt=entity.getEntityData();
  if (nbt.getInteger(""String_Node_Str"") > nbt.getInteger(""String_Node_Str"")) {
    entity.setAttackTarget(event.customer);
  }
}",0.9621087314662272
22392,"@SubscribeEvent public void ignoreChatMessage(ClientChatReceivedEvent event){
  Minecraft mc=Minecraft.getMinecraft();
  EntityPlayer player=mc.thePlayer;
  World world=mc.theWorld;
  String message=event.message.getUnformattedText();
  Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(message);
  if (matcher.find()) {
    EntityPlayer messager=world.getPlayerEntityByName(matcher.group(0));
    if (messager != null) {
      if (!messager.getDisplayName().equals(player.getDisplayName()) && playerHasFrequencyShifter(messager) && playerHasFrequencyShifter(player)) {
        event.setCanceled(true);
      }
    }
  }
}","@SubscribeEvent @SideOnly(Side.CLIENT) public void ignoreChatMessage(ClientChatReceivedEvent event){
  Minecraft mc=Minecraft.getMinecraft();
  EntityPlayer player=mc.thePlayer;
  World world=mc.theWorld;
  String message=event.message.getUnformattedText();
  Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(message);
  if (matcher.find()) {
    EntityPlayer messager=world.getPlayerEntityByName(matcher.group(0));
    if (messager != null) {
      if (!messager.getDisplayName().equals(player.getDisplayName()) && playerHasFrequencyShifter(messager) && playerHasFrequencyShifter(player)) {
        event.setCanceled(true);
      }
    }
  }
}",0.982101167315175
22393,"@SubscribeEvent public void onPlayerTick(TickEvent.PlayerTickEvent event){
  EntityPlayer player=event.player;
  World world=player.worldObj;
  boolean isServer=event.side == Side.SERVER;
  ItemStack chest=player.getCurrentArmor(2);
  ItemStack boots=player.getCurrentArmor(0);
  if (!isServer) {
    this.isJumping=Minecraft.getMinecraft().gameSettings.keyBindJump.getIsKeyPressed();
  }
  ticksSinceLastCellFill++;
  if (BaublesIntegration.checkForSteamCellFiller(player)) {
    if (ticksSinceLastCellFill >= 10) {
      for (int i=0; i < InventoryPlayer.getHotbarSize(); i++) {
        ItemStack item=player.inventory.getStackInSlot(i);
        if (item != null && item.getItem() instanceof ItemSteamCell && ItemSteamCell.chargeItems(player,false)) {
          player.inventory.decrStackSize(i,1);
          ticksSinceLastCellFill=0;
          break;
        }
      }
    }
  }
 else {
    ticksSinceLastCellFill=-40;
  }
  if (isJumping) {
    if (boots != null && boots.getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor item=(ItemExosuitArmor)boots.getItem();
      if (item.hasUpgrade(boots,SteamcraftItems.doubleJump) && SteamcraftEventHandler.hasPower(player,15)) {
        if (isServer) {
          if (!boots.stackTagCompound.hasKey(""String_Node_Str"")) {
            boots.stackTagCompound.setBoolean(""String_Node_Str"",false);
          }
          if (!boots.stackTagCompound.hasKey(""String_Node_Str"")) {
            boots.stackTagCompound.setBoolean(""String_Node_Str"",false);
          }
        }
        if (!player.onGround && boots.stackTagCompound.getBoolean(""String_Node_Str"") && !boots.stackTagCompound.getBoolean(""String_Node_Str"")&& !player.capabilities.isFlying) {
          if (isServer) {
            boots.stackTagCompound.setBoolean(""String_Node_Str"",true);
            SteamcraftEventHandler.drainSteam(player.getCurrentArmor(2),10);
          }
          player.motionY=0.65D;
          player.fallDistance=0.0F;
        }
        if (isServer) {
          boots.stackTagCompound.setBoolean(""String_Node_Str"",false);
        }
      }
    }
    if (chest != null && chest.getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor item=(ItemExosuitArmor)chest.getItem();
      if (item.hasUpgrade(chest,SteamcraftItems.jetpack) && SteamcraftEventHandler.hasPower(player,5)) {
        if (!player.onGround && !player.capabilities.isFlying) {
          player.motionY+=0.06D;
          player.fallDistance=0.0F;
          if (!isServer) {
            double rotation=Math.toRadians(player.renderYawOffset);
            world.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation + 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation + 0.9F),0.0F,-1.0F,0.0F);
            world.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation - 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation - 0.9F),0.0F,-1.0F,0.0F);
          }
 else {
            SteamcraftEventHandler.drainSteam(chest,Config.jetpackConsumption);
          }
        }
      }
      if (item.hasUpgrade(chest,SteamcraftItems.pitonDeployer) && isServer) {
        if (chest.stackTagCompound.hasKey(""String_Node_Str"") && chest.stackTagCompound.getBoolean(""String_Node_Str"")) {
          chest.stackTagCompound.setBoolean(""String_Node_Str"",false);
        }
      }
    }
  }
 else {
    if (boots != null && boots.getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor item=(ItemExosuitArmor)boots.getItem();
      if (item.hasUpgrade(boots,SteamcraftItems.doubleJump) && !player.onGround && isServer) {
        boots.stackTagCompound.setBoolean(""String_Node_Str"",true);
      }
    }
  }
}","@SubscribeEvent public void onPlayerTick(TickEvent.PlayerTickEvent event){
  EntityPlayer player=event.player;
  World world=player.worldObj;
  boolean isServer=event.side == Side.SERVER;
  ItemStack chest=player.getCurrentArmor(2);
  ItemStack boots=player.getCurrentArmor(0);
  if (!isServer) {
    this.isJumping=Minecraft.getMinecraft().gameSettings.keyBindJump.getIsKeyPressed();
  }
  if (CrossMod.BAUBLES) {
    ticksSinceLastCellFill++;
    if (BaublesIntegration.checkForSteamCellFiller(player)) {
      if (ticksSinceLastCellFill >= 10) {
        for (int i=0; i < InventoryPlayer.getHotbarSize(); i++) {
          ItemStack item=player.inventory.getStackInSlot(i);
          if (item != null && item.getItem() instanceof ItemSteamCell && ItemSteamCell.chargeItems(player,false)) {
            player.inventory.decrStackSize(i,1);
            ticksSinceLastCellFill=0;
            break;
          }
        }
      }
    }
 else {
      ticksSinceLastCellFill=-40;
    }
  }
  if (isJumping) {
    if (boots != null && boots.getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor item=(ItemExosuitArmor)boots.getItem();
      if (item.hasUpgrade(boots,SteamcraftItems.doubleJump) && SteamcraftEventHandler.hasPower(player,15)) {
        if (isServer) {
          if (!boots.stackTagCompound.hasKey(""String_Node_Str"")) {
            boots.stackTagCompound.setBoolean(""String_Node_Str"",false);
          }
          if (!boots.stackTagCompound.hasKey(""String_Node_Str"")) {
            boots.stackTagCompound.setBoolean(""String_Node_Str"",false);
          }
        }
        if (!player.onGround && boots.stackTagCompound.getBoolean(""String_Node_Str"") && !boots.stackTagCompound.getBoolean(""String_Node_Str"")&& !player.capabilities.isFlying) {
          if (isServer) {
            boots.stackTagCompound.setBoolean(""String_Node_Str"",true);
            SteamcraftEventHandler.drainSteam(player.getCurrentArmor(2),10);
          }
          player.motionY=0.65D;
          player.fallDistance=0.0F;
        }
        if (isServer) {
          boots.stackTagCompound.setBoolean(""String_Node_Str"",false);
        }
      }
    }
    if (chest != null && chest.getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor item=(ItemExosuitArmor)chest.getItem();
      if (item.hasUpgrade(chest,SteamcraftItems.jetpack) && SteamcraftEventHandler.hasPower(player,5)) {
        if (!player.onGround && !player.capabilities.isFlying) {
          player.motionY+=0.06D;
          player.fallDistance=0.0F;
          if (!isServer) {
            double rotation=Math.toRadians(player.renderYawOffset);
            world.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation + 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation + 0.9F),0.0F,-1.0F,0.0F);
            world.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation - 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation - 0.9F),0.0F,-1.0F,0.0F);
          }
 else {
            SteamcraftEventHandler.drainSteam(chest,Config.jetpackConsumption);
          }
        }
      }
      if (item.hasUpgrade(chest,SteamcraftItems.pitonDeployer) && isServer) {
        if (chest.stackTagCompound.hasKey(""String_Node_Str"") && chest.stackTagCompound.getBoolean(""String_Node_Str"")) {
          chest.stackTagCompound.setBoolean(""String_Node_Str"",false);
        }
      }
    }
  }
 else {
    if (boots != null && boots.getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor item=(ItemExosuitArmor)boots.getItem();
      if (item.hasUpgrade(boots,SteamcraftItems.doubleJump) && !player.onGround && isServer) {
        boots.stackTagCompound.setBoolean(""String_Node_Str"",true);
      }
    }
  }
}",0.9918633034987796
22394,"@EventHandler public void postInit(FMLPostInitializationEvent event){
  SteamcraftRecipes.registerCasting();
  if (Config.enablePipe) {
    MinecraftForge.EVENT_BUS.register(SteamcraftBlocks.pipe);
  }
  ItemSmashedOre iso=(ItemSmashedOre)SteamcraftItems.smashedOre;
  iso.registerDusts();
  iso.addSmelting();
  iso.registerDusts();
  SteamcraftItems.reregisterPlates();
  SteamcraftRecipes.registerDustLiquids();
  CrossMod.postInit(event);
  SteamcraftBook.registerBookResearch();
  long start=System.nanoTime();
  String[] ores=OreDictionary.getOreNames();
  for (  String s : ores) {
    ArrayList<ItemStack> stacks=OreDictionary.getOres(s);
    for (    ItemStack stack : stacks) {
      OreDictHelper.initializeOreDicts(s,stack);
    }
  }
  long end=System.nanoTime();
  int time=(int)(end - start) / 1000000;
  FMLLog.info(""String_Node_Str"" + ""String_Node_Str"",OreDictHelper.stones.size(),OreDictHelper.nuggets.size(),OreDictHelper.ingots.size(),time);
}","@EventHandler public void postInit(FMLPostInitializationEvent event){
  SteamcraftRecipes.registerCasting();
  if (Config.enablePipe) {
    MinecraftForge.EVENT_BUS.register(SteamcraftBlocks.pipe);
  }
  ItemSmashedOre iso=(ItemSmashedOre)SteamcraftItems.smashedOre;
  iso.registerDusts();
  iso.addSmelting();
  iso.registerDusts();
  SteamcraftItems.reregisterPlates();
  SteamcraftRecipes.registerDustLiquids();
  CrossMod.postInit(event);
  SteamcraftBook.registerBookResearch();
  long start=System.nanoTime();
  String[] ores=OreDictionary.getOreNames();
  for (  String s : ores) {
    ArrayList<ItemStack> stacks=OreDictionary.getOres(s);
    for (    ItemStack stack : stacks) {
      OreDictHelper.initializeOreDicts(s,stack);
    }
  }
  long end=System.nanoTime();
  int time=(int)(end - start) / 1000000;
  FMLLog.info(""String_Node_Str"" + ""String_Node_Str"",OreDictHelper.stones.size(),OreDictHelper.nuggets.size(),OreDictHelper.ingots.size(),OreDictHelper.leaves.size(),time);
}",0.985670419651996
22395,"private void mineExtraBlocks(int[][] coordinateArray,int x,int y,int z,World world){
  for (  int[] aCoordinateArray : coordinateArray) {
    int thisX=x + aCoordinateArray[0];
    int thisY=y + aCoordinateArray[1];
    int thisZ=z + aCoordinateArray[2];
    Block block=world.getBlock(thisX,thisY,thisZ);
    int meta=world.getBlockMetadata(thisX,thisY,thisZ);
    if (block != null && !block.isAir(world,thisX,thisY,thisZ) && block.getHarvestTool(meta).equals(""String_Node_Str"") && ArrayUtils.contains(validMiningMaterials,(block.getMaterial()))) {
      if (block.getHarvestLevel(meta) < 3) {
        List<ItemStack> drops=block.getDrops(world,thisX,thisY,thisZ,meta,0);
        world.setBlockToAir(thisX,thisY,thisZ);
        for (        ItemStack stack : drops) {
          world.spawnEntityInWorld(new EntityItem(world,(double)x,(double)y,(double)z,stack));
        }
      }
    }
  }
}","/** 
 * This mines the extra blocks within the coordinate array.
 * @param coordinateArray The array of arrays containing the coordinates to add to x, y, z.
 * @param x The start X coordinate.
 * @param y The start Y coordinate.
 * @param z The start Z coordinate.
 * @param world The world.
 */
private void mineExtraBlocks(int[][] coordinateArray,int x,int y,int z,World world){
  for (  int[] aCoordinateArray : coordinateArray) {
    int thisX=x + aCoordinateArray[0];
    int thisY=y + aCoordinateArray[1];
    int thisZ=z + aCoordinateArray[2];
    Block block=world.getBlock(thisX,thisY,thisZ);
    int meta=world.getBlockMetadata(thisX,thisY,thisZ);
    if (block != null && !block.isAir(world,thisX,thisY,thisZ) && block.getHarvestTool(meta).equals(""String_Node_Str"") && ArrayUtils.contains(validMiningMaterials,(block.getMaterial()))) {
      if (block.getHarvestLevel(meta) < 3) {
        world.func_147480_a(thisX,thisY,thisZ,true);
      }
    }
  }
}",0.6986006458557589
22396,"@SubscribeEvent public void updateBlockBreakSpeed(PlayerEvent.BreakSpeed event){
  ItemStack equipped=event.entityPlayer.getCurrentEquippedItem();
  if (equipped != null && equipped.getItem() != null && equipped.getItem() instanceof ItemSteamDrill && event.block != null && event.block.getHarvestTool(event.metadata) != null && event.block.getHarvestTool(event.metadata).equals(""String_Node_Str"")) {
    ItemSteamDrill drill=(ItemSteamDrill)equipped.getItem();
    if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.bigDrill) && drill.isWound(event.entityPlayer)) {
      float hardness=event.block.getBlockHardness(event.entityPlayer.worldObj,event.x,event.y,event.z);
      event.newSpeed=event.originalSpeed * ((hardness * 1.5F) / 8);
    }
  }
}","@SubscribeEvent public void updateBlockBreakSpeed(PlayerEvent.BreakSpeed event){
  ItemStack equipped=event.entityPlayer.getCurrentEquippedItem();
  Block block=event.block;
  int meta=event.metadata;
  EntityPlayer player=event.entityPlayer;
  if (equipped != null && equipped.getItem() != null) {
    if (block != null) {
      if (block.getHarvestTool(meta) != null && block.getHarvestTool(meta).equals(""String_Node_Str"")) {
        if (equipped.getItem() instanceof ItemSteamDrill) {
          ItemSteamDrill drill=(ItemSteamDrill)equipped.getItem();
          if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.bigDrill) && drill.isWound(player)) {
            float hardness=block.getBlockHardness(player.worldObj,event.x,event.y,event.z);
            event.newSpeed=event.originalSpeed * ((hardness * 1.5F) / 8);
          }
        }
      }
 else       if (equipped.getItem() instanceof ItemSteamAxe) {
        ItemSteamAxe axe=(ItemSteamAxe)equipped.getItem();
        if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.leafBlower)) {
          event.newSpeed=event.originalSpeed / 5F;
        }
      }
    }
  }
}",0.4301646309081253
22397,"public static void initializeOreDicts(String name,ItemStack stack){
  if (name.equals(""String_Node_Str"")) {
    stones.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
  if (name.equals(""String_Node_Str"")) {
    MutablePair<Item,Integer> pair=MutablePair.of(stack.getItem(),stack.getItemDamage());
    cobblestones.add(pair);
  }
  if (name.startsWith(""String_Node_Str"")) {
    nuggets.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
  if (name.startsWith(""String_Node_Str"")) {
    ingots.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
}","public static void initializeOreDicts(String name,ItemStack stack){
  if (stack.getItemDamage() == OreDictionary.WILDCARD_VALUE) {
    for (int i=0; i < 15; i++) {
      initializeOreDicts(name,new ItemStack(stack.getItem(),1,i));
    }
    return;
  }
  if (name.equals(""String_Node_Str"")) {
    stones.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
  if (name.equals(""String_Node_Str"")) {
    MutablePair<Item,Integer> pair=MutablePair.of(stack.getItem(),stack.getItemDamage());
    cobblestones.add(pair);
  }
  if (name.startsWith(""String_Node_Str"")) {
    nuggets.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
  if (name.startsWith(""String_Node_Str"")) {
    ingots.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
  if (name.startsWith(""String_Node_Str"")) {
    leaves.add(MutablePair.of(stack.getItem(),stack.getItemDamage()));
  }
}",0.7937584803256446
22398,"public static void load(FMLPreInitializationEvent event){
  File configurationDir=event.getModConfigurationDirectory();
  File oldConfigFile=new File(configurationDir,""String_Node_Str"");
  if (oldConfigFile.exists()) {
    try {
      FileUtils.copyFile(new File(configurationDir,""String_Node_Str""),new File(configurationDir,""String_Node_Str""));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    oldConfigFile.delete();
  }
  Configuration config=new Configuration(new File(configurationDir,""String_Node_Str""));
  config.load();
  genCopperOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genZincOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genCopperEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genCopperNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  zincDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  copperDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  genZincExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  genCopperExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  villagerId=config.get(""String_Node_Str"",""String_Node_Str"",694).getInt(694);
  genPoorZincOre=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  workshopLimit=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt(1);
  workshopWeight=config.get(""String_Node_Str"",""String_Node_Str"",7).getInt(7);
  expensiveMusketRecipes=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  disableMainBarrelRecipe=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  enableFirearms=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRL=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocket=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketConcussive=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketMining=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAblaze=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRevolver=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedloader=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSilencer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRecoil=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedy=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementFastRockets=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAmmo=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAirStrike=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  musketDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  pistolDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  blunderbussDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  mortarRadius=config.get(""String_Node_Str"",""String_Node_Str"",2).getInt();
  chance=config.get(""String_Node_Str"",""String_Node_Str"",4).getInt();
  duplicateLogs=config.get(""String_Node_Str"",""String_Node_Str"",6).getInt();
  dropItem=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  config.addCustomCategoryComment(""String_Node_Str"",""String_Node_Str"");
  enableBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFlashBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHorn=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGauge=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRuptureDisc=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFluidSteamConverter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCharger=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableChargingPad=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHellCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEngineering=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFan=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMortar=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHammer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHeater=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMold=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSmasher=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThumper=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVacuum=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBlockPlacer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  hammerConsumption=config.get(""String_Node_Str"",""String_Node_Str"",4000).getInt();
  fanConsumption=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt();
  screwConsumption=config.get(""String_Node_Str"",""String_Node_Str"",100).getInt();
  heaterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",20).getInt();
  vacuumConsumption=config.get(""String_Node_Str"",""String_Node_Str"",3).getInt();
  passiveDrain=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExosuit=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  exoConsumption=config.get(""String_Node_Str"",""String_Node_Str"",EXO_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_DEFAULT).getInt();
  jetpackConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JETPACK_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumptionShiftJump=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_SHIFT_BOOST_DEFAULT).getInt();
  thrusterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",THRUSTER_CONSUMPTION_DEFAULT).getInt();
  runAssistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",RUN_ASSIST_CONSUMPTION_DEFAULT).getInt();
  powerFistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",POWER_FIST_CONSUMPTION_DEFAULT).getInt();
  zincPlateConsumption=config.get(""String_Node_Str"",""String_Node_Str"",ZINC_PLATE_CONSUMPTION_DEFAULT).getInt();
  rebreatherConsumption=config.get(""String_Node_Str"",""String_Node_Str"",REBREATHER_CONSUMPTION_DEFAULT).getInt();
  hydrophobicConsumption=config.get(""String_Node_Str"",""String_Node_Str"",HYDROPHOBIC_CONSUMPTION_DEFAULT).getInt();
  pyrophobicConsumption=config.get(""String_Node_Str"",""String_Node_Str"",PYROPHOBIC_CONSUMPTION_DEFAULT).getInt();
  enableAnchorAnvilRecipe=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  pistonPushConsumption=config.get(""String_Node_Str"",""String_Node_Str"",PISTON_PUSH_CONSUMPTION_DEFAULT).getInt();
  reloadingConsumption=config.get(""String_Node_Str"",""String_Node_Str"",RELOADING_CONSUMPTION_DEFAULT).getInt();
  dragonRoarConsumption=config.get(""String_Node_Str"",""String_Node_Str"",DRAGON_ROAR_CONSUMPTION_DEFAULT).getInt();
  enableFallAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJumpAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableDoubleJump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRunAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableStealthUpgrade=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJetpack=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThrusters=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWings=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePowerFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanningMachine=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExtendoFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePitonDeployer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableUberReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderShroud=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRebreather=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHydrophobic=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePyrophobic=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableAnchorHeels=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePistonPush=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableReloadingHolsters=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFrequencyShifter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableDragonRoar=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCopperPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableZincPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIronPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoldPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBrassPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableLeadPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThaumiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableElementiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTerrasteelPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableYetiPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFieryPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSadistPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVibrantPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGildedIronPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  basicTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",BASIC_TANK_CAPACITY_DEFAULT).getInt();
  reinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  uberReinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",UBER_REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  enableAstrolabe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSpyglass=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSteamTools=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSurvivalist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWrench=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanister=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTopHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEmeraldHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoggles=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  steamToolConsumptionAxe=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionDrill=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionShovel=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  enableBigDrill=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableLeafBlower=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCultivator=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRotaryBlades=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBattleDrill=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSifter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableStoneGrinder=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  battleDrillConsumption=config.get(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",BATTLE_DRILL_CONSUMPTION_DEFAULT).getInt();
  easterEggs=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  wimpMode=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableRedstoneValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  disableParticles=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableThaumcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNitorPoweredCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBotaniaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnchiridionIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTwilightForestIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBloodMagicIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderIOIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThermalFoundationIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIC2Integration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNaturaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTinkersConstruct=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBaublesIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRailcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNEIIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  if (enableBoiler && enableGauge && enableTank&& enablePipe) {
    hasAllCrucial=true;
  }
 else {
    hasAllCrucial=false;
  }
  config.save();
}","public static void load(FMLPreInitializationEvent event){
  File configurationDir=event.getModConfigurationDirectory();
  File oldConfigFile=new File(configurationDir,""String_Node_Str"");
  if (oldConfigFile.exists()) {
    try {
      FileUtils.copyFile(new File(configurationDir,""String_Node_Str""),new File(configurationDir,""String_Node_Str""));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    oldConfigFile.delete();
  }
  Configuration config=new Configuration(new File(configurationDir,""String_Node_Str""));
  config.load();
  genCopperOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genZincOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genCopperEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genCopperNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  zincDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  copperDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  genZincExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  genCopperExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  villagerId=config.get(""String_Node_Str"",""String_Node_Str"",694).getInt(694);
  genPoorZincOre=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  workshopLimit=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt(1);
  workshopWeight=config.get(""String_Node_Str"",""String_Node_Str"",7).getInt(7);
  expensiveMusketRecipes=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  disableMainBarrelRecipe=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  enableFirearms=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRL=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocket=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketConcussive=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketMining=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAblaze=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRevolver=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedloader=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSilencer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRecoil=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedy=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementFastRockets=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAmmo=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAirStrike=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  musketDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  pistolDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  blunderbussDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  mortarRadius=config.get(""String_Node_Str"",""String_Node_Str"",2).getInt();
  chance=config.get(""String_Node_Str"",""String_Node_Str"",4).getInt();
  duplicateLogs=config.get(""String_Node_Str"",""String_Node_Str"",6).getInt();
  dropItem=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  config.addCustomCategoryComment(""String_Node_Str"",""String_Node_Str"");
  enableBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFlashBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHorn=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGauge=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRuptureDisc=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFluidSteamConverter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCharger=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableChargingPad=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHellCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEngineering=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFan=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMortar=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHammer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHeater=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMold=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSmasher=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThumper=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVacuum=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBlockPlacer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  hammerConsumption=config.get(""String_Node_Str"",""String_Node_Str"",4000).getInt();
  fanConsumption=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt();
  screwConsumption=config.get(""String_Node_Str"",""String_Node_Str"",100).getInt();
  heaterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",20).getInt();
  vacuumConsumption=config.get(""String_Node_Str"",""String_Node_Str"",3).getInt();
  passiveDrain=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExosuit=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  exoConsumption=config.get(""String_Node_Str"",""String_Node_Str"",EXO_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_DEFAULT).getInt();
  jetpackConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JETPACK_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumptionShiftJump=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_SHIFT_BOOST_DEFAULT).getInt();
  thrusterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",THRUSTER_CONSUMPTION_DEFAULT).getInt();
  runAssistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",RUN_ASSIST_CONSUMPTION_DEFAULT).getInt();
  powerFistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",POWER_FIST_CONSUMPTION_DEFAULT).getInt();
  zincPlateConsumption=config.get(""String_Node_Str"",""String_Node_Str"",ZINC_PLATE_CONSUMPTION_DEFAULT).getInt();
  rebreatherConsumption=config.get(""String_Node_Str"",""String_Node_Str"",REBREATHER_CONSUMPTION_DEFAULT).getInt();
  hydrophobicConsumption=config.get(""String_Node_Str"",""String_Node_Str"",HYDROPHOBIC_CONSUMPTION_DEFAULT).getInt();
  pyrophobicConsumption=config.get(""String_Node_Str"",""String_Node_Str"",PYROPHOBIC_CONSUMPTION_DEFAULT).getInt();
  enableAnchorAnvilRecipe=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  pistonPushConsumption=config.get(""String_Node_Str"",""String_Node_Str"",PISTON_PUSH_CONSUMPTION_DEFAULT).getInt();
  reloadingConsumption=config.get(""String_Node_Str"",""String_Node_Str"",RELOADING_CONSUMPTION_DEFAULT).getInt();
  dragonRoarConsumption=config.get(""String_Node_Str"",""String_Node_Str"",DRAGON_ROAR_CONSUMPTION_DEFAULT).getInt();
  enableFallAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJumpAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableDoubleJump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRunAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableStealthUpgrade=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJetpack=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThrusters=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWings=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePowerFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanningMachine=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExtendoFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePitonDeployer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableUberReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderShroud=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRebreather=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHydrophobic=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePyrophobic=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableAnchorHeels=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePistonPush=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableReloadingHolsters=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFrequencyShifter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableDragonRoar=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCopperPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableZincPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIronPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoldPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBrassPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableLeadPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThaumiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableElementiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTerrasteelPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableYetiPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFieryPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSadistPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVibrantPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGildedIronPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  basicTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",BASIC_TANK_CAPACITY_DEFAULT).getInt();
  reinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  uberReinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",UBER_REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  enableAstrolabe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSpyglass=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSteamTools=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSurvivalist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWrench=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanister=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTopHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEmeraldHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoggles=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  steamToolConsumptionAxe=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionDrill=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionShovel=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  enableBigDrill=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableLeafBlower=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCultivator=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRotaryBlades=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBattleDrill=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSifter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableStoneGrinder=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGravityDigging=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  gravityDiggingRange=config.get(""String_Node_Str"",""String_Node_Str"",16).getInt();
  battleDrillConsumption=config.get(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",BATTLE_DRILL_CONSUMPTION_DEFAULT).getInt();
  easterEggs=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  wimpMode=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableRedstoneValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  disableParticles=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableThaumcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNitorPoweredCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBotaniaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnchiridionIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTwilightForestIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBloodMagicIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderIOIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThermalFoundationIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIC2Integration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNaturaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTinkersConstruct=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBaublesIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRailcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNEIIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  if (enableBoiler && enableGauge && enableTank&& enablePipe) {
    hasAllCrucial=true;
  }
 else {
    hasAllCrucial=false;
  }
  config.save();
}",0.9944716869163256
22399,"private static void registerSteamToolUpgrades(){
  if (Config.enableBigDrill) {
    bigDrill=new ItemSteamToolUpgrade(SteamToolSlot.drillHead,""String_Node_Str"",""String_Node_Str"",1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(bigDrill,""String_Node_Str"");
  }
  if (Config.enableBattleDrill) {
    battleDrill=new ItemSteamToolUpgrade(SteamToolSlot.drillHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(battleDrill,""String_Node_Str"");
  }
  if (Config.enableStoneGrinder) {
    stoneGrinder=new ItemSteamToolUpgrade(SteamToolSlot.drillHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(stoneGrinder,""String_Node_Str"");
  }
  if (Config.enableLeafBlower) {
    leafBlower=new ItemSteamToolUpgrade(SteamToolSlot.sawHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(leafBlower,""String_Node_Str"");
  }
  if (Config.enableCultivator) {
    cultivator=new ItemSteamToolUpgrade(SteamToolSlot.shovelHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(cultivator,""String_Node_Str"");
  }
  if (Config.enableRotaryBlades) {
    rotaryBlades=new ItemSteamToolUpgrade(SteamToolSlot.shovelHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(rotaryBlades,""String_Node_Str"");
  }
  if (Config.enableSifter) {
    sifter=new ItemSteamToolUpgrade(SteamToolSlot.shovelCore,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(sifter,""String_Node_Str"");
  }
}","private static void registerSteamToolUpgrades(){
  if (Config.enableBigDrill) {
    bigDrill=new ItemSteamToolUpgrade(SteamToolSlot.drillHead,""String_Node_Str"",""String_Node_Str"",1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(bigDrill,""String_Node_Str"");
  }
  if (Config.enableBattleDrill) {
    battleDrill=new ItemSteamToolUpgrade(SteamToolSlot.drillHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(battleDrill,""String_Node_Str"");
  }
  if (Config.enableStoneGrinder) {
    stoneGrinder=new ItemSteamToolUpgrade(SteamToolSlot.drillHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(stoneGrinder,""String_Node_Str"");
  }
  if (Config.enableLeafBlower) {
    leafBlower=new ItemSteamToolUpgrade(SteamToolSlot.sawHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(leafBlower,""String_Node_Str"");
  }
  if (Config.enableCultivator) {
    cultivator=new ItemSteamToolUpgrade(SteamToolSlot.shovelHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(cultivator,""String_Node_Str"");
  }
  if (Config.enableRotaryBlades) {
    rotaryBlades=new ItemSteamToolUpgrade(SteamToolSlot.shovelHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(rotaryBlades,""String_Node_Str"");
  }
  if (Config.enableSifter) {
    sifter=new ItemSteamToolUpgrade(SteamToolSlot.shovelCore,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(sifter,""String_Node_Str"");
  }
  if (Config.enableGravityDigging) {
    gravityDigging=new ItemSteamToolUpgrade(SteamToolSlot.shovelHead,""String_Node_Str"",null,1).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tabTools);
    GameRegistry.registerItem(gravityDigging,""String_Node_Str"");
  }
}",0.9323529411764706
22400,"/** 
 * Gets all of the upgrades (except non-standard ones that do not implement ISteamToolUpgrade) that are installed in the tool
 * @param me The tool ItemStack.
 * @return The ArrayList of all the upgrades, or null.
 */
public static ArrayList<ISteamToolUpgrade> getUpgrades(ItemStack me){
  ArrayList<ISteamToolUpgrade> upgrades=new ArrayList<>();
  for (int i=1; i < 10; i++) {
    if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
      ItemStack stack=ItemStack.loadItemStackFromNBT(me.stackTagCompound.getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
      if (stack != null) {
        Item item=stack.getItem();
        if (item != null && item instanceof ISteamToolUpgrade) {
          upgrades.add((ISteamToolUpgrade)item);
        }
      }
    }
  }
  if (upgrades.isEmpty()) {
    return null;
  }
  return upgrades;
}","/** 
 * Gets all of the upgrades (except non-standard ones that do not implement ISteamToolUpgrade) that are installed in the tool
 * @param me The tool ItemStack.
 * @return The ArrayList of all the upgrades, or null.
 */
public static ArrayList<ISteamToolUpgrade> getUpgrades(ItemStack me){
  ArrayList<ISteamToolUpgrade> upgrades=new ArrayList<>();
  if (me.stackTagCompound == null || !me.stackTagCompound.hasKey(""String_Node_Str"")) {
    return null;
  }
  NBTTagCompound unbt=me.stackTagCompound.getCompoundTag(""String_Node_Str"");
  for (int i=1; i < 10; i++) {
    if (unbt.hasKey(Integer.toString(i))) {
      ItemStack stack=ItemStack.loadItemStackFromNBT(unbt.getCompoundTag(Integer.toString(i)));
      if (stack != null) {
        Item item=stack.getItem();
        if (item != null && item instanceof ISteamToolUpgrade) {
          upgrades.add((ISteamToolUpgrade)item);
        }
      }
    }
  }
  if (upgrades.isEmpty()) {
    return null;
  }
  return upgrades;
}",0.8405333333333334
22401,"@SubscribeEvent public void onBlockBreak(BlockEvent.BreakEvent event){
  EntityPlayer player=event.getPlayer();
  Block block=event.block;
  int meta=event.blockMetadata;
  int x=event.x;
  int y=event.y;
  int z=event.z;
  World world=event.world;
  if (player == null) {
    return;
  }
  ItemStack equipped=player.getCurrentEquippedItem();
  if (equipped == null || equipped.getItem() == null || block == null) {
    return;
  }
  if (equipped.getItem() instanceof ItemSteamDrill) {
    ItemSteamDrill drill=(ItemSteamDrill)equipped.getItem();
    ArrayList<Item> upgrades=UtilSteamTool.getHarvestLevelModifiers(equipped);
    if (upgrades != null && drill.isWound(player)) {
      for (      Item upgrade : upgrades) {
        if (upgrade == null) {
          continue;
        }
        if (RecipeHelper.blockMaterials.get(upgrade).right >= block.getHarvestLevel(meta)) {
          block.harvestBlock(world,player,x,y,z,meta);
          world.setBlockToAir(x,y,z);
        }
        event.setCanceled(true);
      }
    }
    if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.bigDrill) && drill.isWound(player)) {
      mineExtraBlocks(getExtraBlockCoordinates(sideHit),x,y,z,world,drill,equipped,player);
    }
  }
 else   if (equipped.getItem() instanceof ItemSteamShovel) {
    ItemSteamShovel shovel=(ItemSteamShovel)equipped.getItem();
    if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.rotaryBlades) && shovel.isWound(player)) {
      mineExtraBlocks(getExtraBlockCoordinates(sideHit),x,y,z,world,shovel,equipped,player);
    }
  }
}","@SubscribeEvent public void onBlockBreak(BlockEvent.BreakEvent event){
  EntityPlayer player=event.getPlayer();
  Block block=event.block;
  int meta=event.blockMetadata;
  int x=event.x;
  int y=event.y;
  int z=event.z;
  World world=event.world;
  if (player == null) {
    return;
  }
  ItemStack equipped=player.getCurrentEquippedItem();
  if (equipped == null || equipped.getItem() == null || block == null) {
    return;
  }
  if (equipped.getItem() instanceof ItemSteamDrill) {
    ItemSteamDrill drill=(ItemSteamDrill)equipped.getItem();
    ArrayList<Item> upgrades=UtilSteamTool.getHarvestLevelModifiers(equipped);
    if (upgrades != null && drill.isWound(player)) {
      for (      Item upgrade : upgrades) {
        if (upgrade == null) {
          continue;
        }
        if (RecipeHelper.blockMaterials.get(upgrade).right >= block.getHarvestLevel(meta)) {
          block.harvestBlock(world,player,x,y,z,meta);
          world.setBlockToAir(x,y,z);
        }
        event.setCanceled(true);
      }
    }
    if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.bigDrill) && drill.isWound(player)) {
      mineExtraBlocks(getExtraBlockCoordinates(sideHit),x,y,z,world,drill,equipped,player);
    }
  }
 else   if (equipped.getItem() instanceof ItemSteamShovel) {
    ItemSteamShovel shovel=(ItemSteamShovel)equipped.getItem();
    if (!shovel.isWound(player)) {
      return;
    }
    if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.rotaryBlades)) {
      mineExtraBlocks(getExtraBlockCoordinates(sideHit),x,y,z,world,shovel,equipped,player);
    }
 else     if (UtilSteamTool.hasUpgrade(equipped,SteamcraftItems.gravityDigging)) {
      for (int i=y - Config.gravityDiggingRange; i < y + Config.gravityDiggingRange; i++) {
        if (i < 0) {
          continue;
        }
        Block block1=world.getBlock(x,i,z);
        int meta1=world.getBlockMetadata(x,i,z);
        if (!block1.isToolEffective(""String_Node_Str"",meta) || !block1.canHarvestBlock(player,meta)) {
          continue;
        }
        if (Item.getItemFromBlock(block) == Item.getItemFromBlock(block1)) {
          world.setBlockToAir(x,i,z);
          block.harvestBlock(world,player,x,i,z,meta1);
        }
      }
    }
  }
}",0.8077126254622292
22402,"/** 
 * Gets an ArrayList of the Strings that should be put in the item's tooltip.
 * @param upgrades The ISteamToolUpgrades that are being tested against; see #getUpgrades
 * @param redSlot The slot that should be red; drillHead, sawHead, or shovelHead usually.
 * @return The strings, or null if the upgrades were null.
 */
public static ArrayList<String> getInformation(ArrayList<ISteamToolUpgrade> upgrades,SteamToolSlot redSlot){
  if (upgrades == null) {
    return null;
  }
  ArrayList<String> strings=new ArrayList<>();
  for (  ISteamToolUpgrade upgrade : upgrades) {
    String info=upgrade.getInformation();
    if (info == null) {
      info=StatCollector.translateToLocal(((Item)upgrade).getUnlocalizedName());
    }
    if (upgrade.getToolSlot() == redSlot) {
      strings.add(EnumChatFormatting.RED + ""String_Node_Str"" + info);
    }
 else     if (upgrade.getToolSlot() == SteamToolSlot.toolCore) {
      strings.add(EnumChatFormatting.DARK_GREEN + ""String_Node_Str"" + info);
    }
  }
  return strings;
}","/** 
 * Gets an ArrayList of the Strings that should be put in the item's tooltip.
 * @param upgrades The ISteamToolUpgrades that are being tested against; see #getUpgrades
 * @param redSlot The slot that should be red; drillHead, sawHead, or shovelHead usually.
 * @return The strings, or null if the upgrades were null.
 */
public static ArrayList<String> getInformation(ArrayList<ISteamToolUpgrade> upgrades,SteamToolSlot redSlot){
  if (upgrades == null) {
    return null;
  }
  ArrayList<String> strings=new ArrayList<>();
  for (  ISteamToolUpgrade upgrade : upgrades) {
    String info=upgrade.getInformation();
    if (info == null) {
      info=StatCollector.translateToLocal(((Item)upgrade).getUnlocalizedName());
    }
    if (upgrade.getToolSlot() == redSlot) {
      strings.add(EnumChatFormatting.RED + ""String_Node_Str"" + info);
    }
 else     if (upgrade.getToolSlot() == SteamToolSlot.toolCore) {
      strings.add(EnumChatFormatting.DARK_GREEN + ""String_Node_Str"" + info);
    }
  }
  if (strings.isEmpty()) {
    return null;
  }
  return strings;
}",0.9636711281070746
22403,"public static void load(FMLPreInitializationEvent event){
  File configurationDir=event.getModConfigurationDirectory();
  File oldConfigFile=new File(configurationDir,""String_Node_Str"");
  if (oldConfigFile.exists()) {
    try {
      FileUtils.copyFile(new File(configurationDir,""String_Node_Str""),new File(configurationDir,""String_Node_Str""));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    oldConfigFile.delete();
  }
  Configuration config=new Configuration(new File(configurationDir,""String_Node_Str""));
  config.load();
  genCopperOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genZincOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genCopperEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genCopperNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  zincDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  copperDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  genZincExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  genCopperExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  villagerId=config.get(""String_Node_Str"",""String_Node_Str"",694).getInt(694);
  genPoorZincOre=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  workshopLimit=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt(1);
  workshopWeight=config.get(""String_Node_Str"",""String_Node_Str"",7).getInt(7);
  expensiveMusketRecipes=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  disableMainBarrelRecipe=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  enableFirearms=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRL=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocket=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketConcussive=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketMining=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAblaze=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRevolver=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedloader=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSilencer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRecoil=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedy=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementFastRockets=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAmmo=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAirStrike=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  musketDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  pistolDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  blunderbussDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  mortarRadius=config.get(""String_Node_Str"",""String_Node_Str"",2).getInt();
  chance=config.get(""String_Node_Str"",""String_Node_Str"",4).getInt();
  duplicateLogs=config.get(""String_Node_Str"",""String_Node_Str"",6).getInt();
  dropItem=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  config.addCustomCategoryComment(""String_Node_Str"",""String_Node_Str"");
  enableBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFlashBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHorn=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGauge=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRuptureDisc=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFluidSteamConverter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCharger=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableChargingPad=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHellCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEngineering=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFan=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMortar=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHammer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHeater=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMold=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSmasher=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThumper=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVacuum=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBlockPlacer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  hammerConsumption=config.get(""String_Node_Str"",""String_Node_Str"",4000).getInt();
  fanConsumption=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt();
  screwConsumption=config.get(""String_Node_Str"",""String_Node_Str"",100).getInt();
  heaterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",20).getInt();
  vacuumConsumption=config.get(""String_Node_Str"",""String_Node_Str"",3).getInt();
  passiveDrain=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExosuit=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  exoConsumption=config.get(""String_Node_Str"",""String_Node_Str"",EXO_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_DEFAULT).getInt();
  jetpackConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JETPACK_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumptionShiftJump=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_SHIFT_BOOST_DEFAULT).getInt();
  thrusterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",THRUSTER_CONSUMPTION_DEFAULT).getInt();
  runAssistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",RUN_ASSIST_CONSUMPTION_DEFAULT).getInt();
  powerFistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",POWER_FIST_CONSUMPTION_DEFAULT).getInt();
  zincPlateConsumption=config.get(""String_Node_Str"",""String_Node_Str"".ZINC_PLATE_CONSUMPTION_DEFAULT).getInt();
  enableFallAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJumpAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableDoubleJump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRunAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableStealthUpgrade=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJetpack=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThrusters=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWings=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePowerFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanningMachine=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExtendoFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePitonDeployer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableUberReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderShroud=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCopperPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIronPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoldPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBrassPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableLeadPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThaumiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableElementiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTerrasteelPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableYetiPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFieryPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSadistPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVibrantPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  basicTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",BASIC_TANK_CAPACITY_DEFAULT).getInt();
  reinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  uberReinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",UBER_REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  enableAstrolabe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSpyglass=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSteamTools=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSurvivalist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWrench=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanister=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTopHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEmeraldHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoggles=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  steamToolConsumptionAxe=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionDrill=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionShovel=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  easterEggs=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  wimpMode=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableRedstoneValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  disableParticles=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableThaumcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNitorPoweredCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBotaniaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnchiridionIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTwilightForestIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBloodMagicIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderIOIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThermalFoundationIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIC2Integration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNaturaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTinkersConstruct=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBaublesIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRailcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNEIIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  if (enableBoiler && enableGauge && enableTank&& enablePipe) {
    hasAllCrucial=true;
  }
 else {
    hasAllCrucial=false;
  }
  config.save();
}","public static void load(FMLPreInitializationEvent event){
  File configurationDir=event.getModConfigurationDirectory();
  File oldConfigFile=new File(configurationDir,""String_Node_Str"");
  if (oldConfigFile.exists()) {
    try {
      FileUtils.copyFile(new File(configurationDir,""String_Node_Str""),new File(configurationDir,""String_Node_Str""));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    oldConfigFile.delete();
  }
  Configuration config=new Configuration(new File(configurationDir,""String_Node_Str""));
  config.load();
  genCopperOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genZincOverworld=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  genCopperEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincEnd=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genCopperNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  genZincNether=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  zincDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  copperDims=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  genZincExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  genCopperExtras=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean();
  villagerId=config.get(""String_Node_Str"",""String_Node_Str"",694).getInt(694);
  genPoorZincOre=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  workshopLimit=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt(1);
  workshopWeight=config.get(""String_Node_Str"",""String_Node_Str"",7).getInt(7);
  expensiveMusketRecipes=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  disableMainBarrelRecipe=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(true);
  enableFirearms=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRL=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocket=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketConcussive=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRocketMining=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAblaze=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRevolver=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedloader=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSilencer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementRecoil=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementSpeedy=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementFastRockets=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAmmo=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnhancementAirStrike=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  musketDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  pistolDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  blunderbussDamage=config.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").getString();
  mortarRadius=config.get(""String_Node_Str"",""String_Node_Str"",2).getInt();
  chance=config.get(""String_Node_Str"",""String_Node_Str"",4).getInt();
  duplicateLogs=config.get(""String_Node_Str"",""String_Node_Str"",6).getInt();
  dropItem=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  config.addCustomCategoryComment(""String_Node_Str"",""String_Node_Str"");
  enableBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFlashBoiler=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHorn=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGauge=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRuptureDisc=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFluidSteamConverter=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCharger=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableChargingPad=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHellCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEngineering=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFan=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMortar=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHammer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableHeater=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableMold=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSmasher=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThumper=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVacuum=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBlockPlacer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  hammerConsumption=config.get(""String_Node_Str"",""String_Node_Str"",4000).getInt();
  fanConsumption=config.get(""String_Node_Str"",""String_Node_Str"",1).getInt();
  screwConsumption=config.get(""String_Node_Str"",""String_Node_Str"",100).getInt();
  heaterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",20).getInt();
  vacuumConsumption=config.get(""String_Node_Str"",""String_Node_Str"",3).getInt();
  passiveDrain=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExosuit=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  exoConsumption=config.get(""String_Node_Str"",""String_Node_Str"",EXO_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_DEFAULT).getInt();
  jetpackConsumption=config.get(""String_Node_Str"",""String_Node_Str"",JETPACK_CONSUMPTION_DEFAULT).getInt();
  jumpBoostConsumptionShiftJump=config.get(""String_Node_Str"",""String_Node_Str"",JUMP_BOOST_CONSUMPTION_SHIFT_BOOST_DEFAULT).getInt();
  thrusterConsumption=config.get(""String_Node_Str"",""String_Node_Str"",THRUSTER_CONSUMPTION_DEFAULT).getInt();
  runAssistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",RUN_ASSIST_CONSUMPTION_DEFAULT).getInt();
  powerFistConsumption=config.get(""String_Node_Str"",""String_Node_Str"",POWER_FIST_CONSUMPTION_DEFAULT).getInt();
  zincPlateConsumption=config.get(""String_Node_Str"",""String_Node_Str"",ZINC_PLATE_CONSUMPTION_DEFAULT).getInt();
  enableFallAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJumpAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableDoubleJump=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRunAssist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableStealthUpgrade=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableJetpack=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThrusters=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWings=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePowerFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanningMachine=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableExtendoFist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enablePitonDeployer=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableUberReinforcedTank=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderShroud=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCopperPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIronPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoldPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBrassPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableLeadPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThaumiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableElementiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTerrasteelPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableYetiPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableFieryPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSadistPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableVibrantPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderiumPlate=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  basicTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",BASIC_TANK_CAPACITY_DEFAULT).getInt();
  reinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  uberReinforcedTankCapacity=config.get(""String_Node_Str"",""String_Node_Str"",UBER_REINFORCED_TANK_CAPACITY_DEFAULT).getInt();
  enableAstrolabe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSpyglass=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSteamTools=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableSurvivalist=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableWrench=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableCanister=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTopHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEmeraldHat=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableGoggles=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  steamToolConsumptionAxe=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionDrill=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  steamToolConsumptionShovel=config.get(""String_Node_Str"",""String_Node_Str"",STEAM_TOOL_CONSUMPTION_DEFAULT).getInt();
  easterEggs=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  wimpMode=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableRedstoneValvePipe=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  disableParticles=config.get(""String_Node_Str"",""String_Node_Str"",false).getBoolean(false);
  enableThaumcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNitorPoweredCrucible=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBotaniaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnchiridionIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTwilightForestIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBloodMagicIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableEnderIOIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableThermalFoundationIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableIC2Integration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNaturaIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableTinkersConstruct=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableBaublesIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableRailcraftIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  enableNEIIntegration=config.get(""String_Node_Str"",""String_Node_Str"",true).getBoolean(true);
  if (enableBoiler && enableGauge && enableTank&& enablePipe) {
    hasAllCrucial=true;
  }
 else {
    hasAllCrucial=false;
  }
  config.save();
}",0.9999256892323698
22404,"/** 
 * Removes Exosuit Plates from the given Exosuit piece.
 * @param exosuitPiece The Exosuit Piece to remove the plates from.
 * @param identifier The plate type to remove.
 */
public static void removePlate(ItemStack exosuitPiece,String identifier){
  if (exosuitPiece.hasTagCompound() && exosuitPiece.hasTag(""String_Node_Str"")) {
    NBTTagCompound tagCompound=exosuitPiece.stackTagCompound;
    if (getPlate(tagCompound.getString(""String_Node_Str"")) == identifier) {
      tagCompound.removeTag(""String_Node_Str"");
    }
  }
}","/** 
 * Removes Exosuit Plates from the given Exosuit piece.
 * @param exosuitPiece The Exosuit Piece to remove the plates from.
 * @param identifier The plate type to remove.
 */
public static void removePlate(ItemStack exosuitPiece,String identifier){
  if (exosuitPiece.hasTagCompound()) {
    NBTTagCompound tagCompound=exosuitPiece.stackTagCompound;
    if (tagCompound.hasKey(""String_Node_Str"") && getPlate(tagCompound.getString(""String_Node_Str"")).getIdentifier() == identifier) {
      tagCompound.removeTag(""String_Node_Str"");
    }
  }
}",0.6561631139944393
22405,"@SubscribeEvent public void burstZincPlate(LivingHurtEvent event){
}","@SubscribeEvent public void burstZincPlate(LivingHurtEvent event){
  EntityLivingBase entity=event.entityLiving;
  int consumption=Config.zincPlateConsumption;
  if (entity instanceof EntityPlayer && hasPower(entity,consumption)) {
    EntityPlayer player=(EntityPlayer)entity;
    float health=player.getHealth();
    if (event.ammount >= 5.0F || health <= 5.0F) {
      ItemStack stackWithPlate=null;
      for (int i=1; i < 5; i++) {
        ItemStack equipment=player.getEquipmentInSlot(i);
        Item item=equipment.getItem();
        if (item instanceof ItemExosuitArmor) {
          ItemExosuitArmor armor=(ItemExosuitArmor)item;
          if (armor.hasPlates(equipment) && UtilPlates.getPlate(equipment.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() == ""String_Node_Str"") {
            stackWithPlate=equipment;
            break;
          }
        }
      }
      if (stackWithPlate != null) {
        ItemStack zincPlates=new ItemStack(SteamcraftItems.steamcraftPlate,2,1);
        World world=player.worldObj;
        player.setHealth(health + 5.0F);
        drainSteam(player.getEquipmentInSlot(3),consumption);
        UtilPlates.removePlate(stackWithPlate,""String_Node_Str"");
        EntityItem entityItem=new EntityItem(world,player.posX,player.posY,player.posZ,zincPlates);
        world.spawnEntityInWorld(entityItem);
      }
    }
  }
}",0.0942480942480942
22406,"private static void registerExosuitUpgrades(){
  if (Config.enableExosuit) {
    if (Config.enableJetpack) {
      jetpack=new ItemExosuitJetpack().setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(jetpack,""String_Node_Str"");
    }
    if (Config.enableWings) {
      wings=new ItemExosuitWings().setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(wings,""String_Node_Str"");
    }
    if (Config.enablePowerFist) {
      powerFist=new ItemExosuitUpgrade(ExosuitSlot.bodyHand,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(powerFist,""String_Node_Str"");
    }
    if (Config.enableExtendoFist) {
      extendoFist=new ItemExosuitUpgrade(ExosuitSlot.bodyHand,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(extendoFist,""String_Node_Str"");
    }
    if (Config.enableThrusters) {
      thrusters=new ItemExosuitSidepack().setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(thrusters,""String_Node_Str"");
    }
    if (Config.enableFallAssist) {
      fallAssist=new ItemExosuitUpgrade(ExosuitSlot.bootsTop,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(fallAssist,""String_Node_Str"");
    }
    if (Config.enableJumpAssist) {
      jumpAssist=new ItemExosuitUpgrade(ExosuitSlot.bootsTop,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(jumpAssist,""String_Node_Str"");
    }
    if (Config.enableRunAssist) {
      runAssist=new ItemExosuitUpgrade(ExosuitSlot.legsLegs,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(runAssist,""String_Node_Str"");
    }
    if (Config.enableDoubleJump) {
      doubleJump=new ItemExosuitUpgrade(ExosuitSlot.bootsFeet,""String_Node_Str"",null,1).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(doubleJump,""String_Node_Str"");
    }
    if (Config.enableCanningMachine) {
      canner=new ItemExosuitUpgrade(ExosuitSlot.legsHips,""String_Node_Str"",null,1).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(canner,""String_Node_Str"");
    }
    if (Config.enablePitonDeployer) {
      pitonDeployer=new ItemExosuitUpgrade(ExosuitSlot.bodyHand,""String_Node_Str"",null,1).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(pitonDeployer,""String_Node_Str"");
    }
    if (Config.enableStealthUpgrade) {
      stealthUpgrade=new ItemExosuitUpgrade(ExosuitSlot.legsLegs,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(stealthUpgrade,""String_Node_Str"");
    }
    if (Config.enableEnderShroud) {
      enderShroud=new ItemExosuitUpgrade(ExosuitSlot.vanity,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(enderShroud,""String_Node_Str"");
    }
    if (Config.enableReinforcedTank) {
      reinforcedTank=new ItemTank(Config.reinforcedTankCapacity,""String_Node_Str"",""String_Node_Str"").setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(reinforcedTank,""String_Node_Str"");
    }
    if (Config.enableUberReinforcedTank) {
      uberReinforcedTank=new ItemTank(Config.uberReinforcedTankCapacity,""String_Node_Str"",""String_Node_Str"").setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(uberReinforcedTank,""String_Node_Str"");
    }
  }
}","private static void registerExosuitUpgrades(){
  if (Config.enableExosuit) {
    if (Config.enableJetpack) {
      jetpack=new ItemExosuitJetpack().setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(jetpack,""String_Node_Str"");
    }
    if (Config.enableWings) {
      wings=new ItemExosuitWings().setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(wings,""String_Node_Str"");
    }
    if (Config.enablePowerFist) {
      powerFist=new ItemExosuitUpgrade(ExosuitSlot.BODY_HAND,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(powerFist,""String_Node_Str"");
    }
    if (Config.enableExtendoFist) {
      extendoFist=new ItemExosuitUpgrade(ExosuitSlot.BODY_HAND,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(extendoFist,""String_Node_Str"");
    }
    if (Config.enableThrusters) {
      thrusters=new ItemExosuitSidepack().setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(thrusters,""String_Node_Str"");
    }
    if (Config.enableFallAssist) {
      fallAssist=new ItemExosuitUpgrade(ExosuitSlot.BOOTS_TOP,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(fallAssist,""String_Node_Str"");
    }
    if (Config.enableJumpAssist) {
      jumpAssist=new ItemExosuitUpgrade(ExosuitSlot.BOOTS_TOP,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(jumpAssist,""String_Node_Str"");
    }
    if (Config.enableRunAssist) {
      runAssist=new ItemExosuitUpgrade(ExosuitSlot.LEGS_LEGS,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(runAssist,""String_Node_Str"");
    }
    if (Config.enableDoubleJump) {
      doubleJump=new ItemExosuitUpgrade(ExosuitSlot.BOOTS_FEET,""String_Node_Str"",null,1).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(doubleJump,""String_Node_Str"");
    }
    if (Config.enableCanningMachine) {
      canner=new ItemExosuitUpgrade(ExosuitSlot.LEGS_HIPS,""String_Node_Str"",null,1).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(canner,""String_Node_Str"");
    }
    if (Config.enablePitonDeployer) {
      pitonDeployer=new ItemExosuitUpgrade(ExosuitSlot.BODY_HAND,""String_Node_Str"",null,1).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(pitonDeployer,""String_Node_Str"");
    }
    if (Config.enableStealthUpgrade) {
      stealthUpgrade=new ItemExosuitUpgrade(ExosuitSlot.LEGS_LEGS,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(stealthUpgrade,""String_Node_Str"");
    }
    if (Config.enableEnderShroud) {
      enderShroud=new ItemExosuitUpgrade(ExosuitSlot.VANITY,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(enderShroud,""String_Node_Str"");
    }
    if (Config.enableReinforcedTank) {
      reinforcedTank=new ItemTank(Config.reinforcedTankCapacity,""String_Node_Str"",""String_Node_Str"").setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(reinforcedTank,""String_Node_Str"");
    }
    if (Config.enableUberReinforcedTank) {
      uberReinforcedTank=new ItemTank(Config.uberReinforcedTankCapacity,""String_Node_Str"",""String_Node_Str"").setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
      GameRegistry.registerItem(uberReinforcedTank,""String_Node_Str"");
    }
  }
}",0.9827099107243756
22407,int getStorage(ItemStack stack);,"/** 
 * Gets the maximum storage capacity for the tank.
 * @param stack The armor containing the tank.
 * @return The maximum storage that the tank (self) provides.
 */
int getStorage(ItemStack stack);",0.2746781115879828
22408,boolean canFill(ItemStack stack);,"/** 
 * Whether this tank allows the exosuit to be filled or not.
 * @param stack The armor containing the tank.
 * @return Whether this tank in this armor can charge in a charging device.
 */
boolean canFill(ItemStack stack);",0.2548262548262548
22409,"public static void postInit(){
  floralLaurel=new ItemExosuitUpgrade(ExosuitSlot.headHelm,""String_Node_Str"",null,5).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
  GameRegistry.registerItem(floralLaurel,""String_Node_Str"");
  CrucibleLiquid liquidTerrasteel=new CrucibleLiquid(""String_Node_Str"",new ItemStack(ModItems.manaResource,1,4),new ItemStack(SteamcraftItems.steamcraftPlate,1,6),null,null,64,191,13);
  SteamcraftRegistry.registerLiquid(liquidTerrasteel);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidTerrasteel,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidTerrasteel,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidTerrasteel,6);
  if (Config.enableTerrasteelPlate) {
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,6),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,6),liquidTerrasteel);
  }
  CrucibleLiquid liquidElementium=new CrucibleLiquid(""String_Node_Str"",new ItemStack(ModItems.manaResource,1,7),new ItemStack(SteamcraftItems.steamcraftPlate,1,7),null,null,230,66,247);
  SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,7),liquidElementium);
  SteamcraftRegistry.registerLiquid(liquidElementium);
  for (int i=0; i < 16; i++) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"" + i,new ShapedOreRecipe(new ItemStack(floralLaurel),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'f',new ItemStack(ModItems.petal,1,i),'l',new ItemStack(ModItems.manaResource,1,3)));
  }
  SteamcraftRegistry.registerMeltRecipe(ModItems.manaResource,7,liquidElementium,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidElementium,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidElementium,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidElementium,6);
  if (Config.enableElementiumPlate) {
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,7),liquidElementium);
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,7),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
}","public static void postInit(){
  floralLaurel=new ItemExosuitUpgrade(ExosuitSlot.HEAD_HELM,""String_Node_Str"",null,5).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
  GameRegistry.registerItem(floralLaurel,""String_Node_Str"");
  CrucibleLiquid liquidTerrasteel=new CrucibleLiquid(""String_Node_Str"",new ItemStack(ModItems.manaResource,1,4),new ItemStack(SteamcraftItems.steamcraftPlate,1,6),null,null,64,191,13);
  SteamcraftRegistry.registerLiquid(liquidTerrasteel);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidTerrasteel,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidTerrasteel,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidTerrasteel,6);
  if (Config.enableTerrasteelPlate) {
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,6),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,6),liquidTerrasteel);
  }
  CrucibleLiquid liquidElementium=new CrucibleLiquid(""String_Node_Str"",new ItemStack(ModItems.manaResource,1,7),new ItemStack(SteamcraftItems.steamcraftPlate,1,7),null,null,230,66,247);
  SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,7),liquidElementium);
  SteamcraftRegistry.registerLiquid(liquidElementium);
  for (int i=0; i < 16; i++) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"" + i,new ShapedOreRecipe(new ItemStack(floralLaurel),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'f',new ItemStack(ModItems.petal,1,i),'l',new ItemStack(ModItems.manaResource,1,3)));
  }
  SteamcraftRegistry.registerMeltRecipe(ModItems.manaResource,7,liquidElementium,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidElementium,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidElementium,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidElementium,6);
  if (Config.enableElementiumPlate) {
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,7),liquidElementium);
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,7),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
}",0.997031466455571
22410,"@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.bodyTank;
}","@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.BODY_TANK;
}",0.896551724137931
22411,"public static void postInit(){
  CrucibleLiquid liquidThaumium=new CrucibleLiquid(""String_Node_Str"",new ItemStack(ConfigItems.itemResource,1,2),new ItemStack(SteamcraftItems.steamcraftPlate,1,5),new ItemStack(ConfigItems.itemNugget,1,6),null,105,87,163);
  SteamcraftRegistry.registerLiquid(liquidThaumium);
  goggleUpgrade=new ItemExosuitUpgrade(ExosuitSlot.headGoggles,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
  GameRegistry.registerItem(goggleUpgrade,""String_Node_Str"");
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(goggleUpgrade),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'g',ConfigItems.itemGoggles));
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidThaumium,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidThaumium,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidThaumium,6);
  if (Config.enableThaumiumPlate) {
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,5),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,5),liquidThaumium);
  }
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemSwordThaumium,liquidThaumium,18);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemPickThaumium,liquidThaumium,27);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemAxeThaumium,liquidThaumium,27);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemHoeThaumium,liquidThaumium,18);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemShovelThaumium,liquidThaumium,9);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemBootsThaumium,liquidThaumium,36);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemChestThaumium,liquidThaumium,81);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemHelmetThaumium,liquidThaumium,45);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemLegsThaumium,liquidThaumium,63);
  AspectList list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftPlate,1,OreDictionary.WILDCARD_VALUE));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,2);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftPlate,1,OreDictionary.WILDCARD_VALUE),list);
  }
  list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftIngot,1,1));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,3);
    list.add(Aspect.HEAL,1);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftIngot,1,1),list);
  }
  list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftNugget,1,1));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,1);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftNugget,1,1),list);
  }
  list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftNugget,1,3));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,1);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftNugget,1,3),list);
  }
}","public static void postInit(){
  CrucibleLiquid liquidThaumium=new CrucibleLiquid(""String_Node_Str"",new ItemStack(ConfigItems.itemResource,1,2),new ItemStack(SteamcraftItems.steamcraftPlate,1,5),new ItemStack(ConfigItems.itemNugget,1,6),null,105,87,163);
  SteamcraftRegistry.registerLiquid(liquidThaumium);
  goggleUpgrade=new ItemExosuitUpgrade(ExosuitSlot.HEAD_GOGGLES,""String_Node_Str"",null,0).setCreativeTab(Steamcraft.tab).setUnlocalizedName(""String_Node_Str"").setTextureName(""String_Node_Str"");
  GameRegistry.registerItem(goggleUpgrade,""String_Node_Str"");
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(goggleUpgrade),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'g',ConfigItems.itemGoggles));
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidThaumium,9);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidThaumium,1);
  SteamcraftRegistry.registerMeltRecipeOreDict(""String_Node_Str"",liquidThaumium,6);
  if (Config.enableThaumiumPlate) {
    SteamcraftRegistry.addExosuitPlate(new ExosuitPlate(""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,5),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    SteamcraftRecipes.addExosuitPlateRecipes(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftItems.exosuitPlate,1,5),liquidThaumium);
  }
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemSwordThaumium,liquidThaumium,18);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemPickThaumium,liquidThaumium,27);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemAxeThaumium,liquidThaumium,27);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemHoeThaumium,liquidThaumium,18);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemShovelThaumium,liquidThaumium,9);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemBootsThaumium,liquidThaumium,36);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemChestThaumium,liquidThaumium,81);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemHelmetThaumium,liquidThaumium,45);
  SteamcraftRegistry.registerMeltRecipeTool(ConfigItems.itemLegsThaumium,liquidThaumium,63);
  AspectList list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftPlate,1,OreDictionary.WILDCARD_VALUE));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,2);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftPlate,1,OreDictionary.WILDCARD_VALUE),list);
  }
  list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftIngot,1,1));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,3);
    list.add(Aspect.HEAL,1);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftIngot,1,1),list);
  }
  list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftNugget,1,1));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,1);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftNugget,1,1),list);
  }
  list=ThaumcraftApiHelper.getObjectAspects(new ItemStack(SteamcraftItems.steamcraftNugget,1,3));
  if (list == null || list.size() == 0) {
    list=new AspectList();
    list.add(Aspect.METAL,1);
    ThaumcraftApi.registerObjectTag(new ItemStack(SteamcraftItems.steamcraftNugget,1,3),list);
  }
}",0.9970012851635014
22412,"@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.bodyTank;
}","@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.BODY_TANK;
}",0.896551724137931
22413,"public boolean hasPower(ItemStack me,int powerNeeded){
  if (this.slot == 1) {
    if (!me.hasTagCompound()) {
      me.setTagCompound(new NBTTagCompound());
    }
    if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
      me.stackTagCompound.setInteger(""String_Node_Str"",0);
    }
    if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
      me.stackTagCompound.setInteger(""String_Node_Str"",0);
    }
    if (me.stackTagCompound.getInteger(""String_Node_Str"") > powerNeeded) {
      return true;
    }
  }
  return false;
}","/** 
 * Gets whether the exosuit has the given amount of power. Will also set default values for the ItemStack's NBT if it is the chestpiece and does not have them. These values are: steamFill: 0 maxFill: 0
 * @param me The ItemStack to test against.
 * @param powerNeeded The amount of power to check for.
 */
public boolean hasPower(ItemStack me,int powerNeeded){
  if (this.slot == 1) {
    if (!me.hasTagCompound()) {
      me.setTagCompound(new NBTTagCompound());
    }
    if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
      me.stackTagCompound.setInteger(""String_Node_Str"",0);
    }
    if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
      me.stackTagCompound.setInteger(""String_Node_Str"",0);
    }
    return hasTank(me) && me.stackTagCompound.getInteger(""String_Node_Str"") > powerNeeded;
  }
  return false;
}",0.7126099706744868
22414,"@Override public void setInventorySlotContents(ItemStack me,int var1,ItemStack stack){
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setTag(""String_Node_Str"",new NBTTagCompound());
  }
  if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(var1))) {
    me.stackTagCompound.getCompoundTag(""String_Node_Str"").removeTag(Integer.toString(var1));
  }
  NBTTagCompound stc=new NBTTagCompound();
  if (stack != null) {
    stack.writeToNBT(stc);
    me.stackTagCompound.getCompoundTag(""String_Node_Str"").setTag(Integer.toString(var1),stc);
    if (var1 == 5 && slot == 1) {
      me.stackTagCompound.setInteger(""String_Node_Str"",0);
      me.stackTagCompound.setInteger(""String_Node_Str"",((IExosuitTank)stack.getItem()).getStorage(me));
      if (stack.getItem() instanceof BlockTankItem && stack.getItemDamage() == 1) {
        me.stackTagCompound.setInteger(""String_Node_Str"",me.stackTagCompound.getInteger(""String_Node_Str""));
      }
    }
  }
  this.hasPlates(me);
}","@Override public void setInventorySlotContents(ItemStack me,int var1,ItemStack stack){
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setTag(""String_Node_Str"",new NBTTagCompound());
  }
  if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(var1))) {
    me.stackTagCompound.getCompoundTag(""String_Node_Str"").removeTag(Integer.toString(var1));
  }
  NBTTagCompound stc=new NBTTagCompound();
  if (stack != null) {
    stack.writeToNBT(stc);
    me.stackTagCompound.getCompoundTag(""String_Node_Str"").setTag(Integer.toString(var1),stc);
    if (var1 == 5 && slot == 1) {
      if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
        me.stackTagCompound.setInteger(""String_Node_Str"",0);
      }
      me.stackTagCompound.setInteger(""String_Node_Str"",((IExosuitTank)stack.getItem()).getStorage(me));
      if (stack.getItem() instanceof BlockTankItem && stack.getItemDamage() == 1) {
        me.stackTagCompound.setInteger(""String_Node_Str"",me.stackTagCompound.getInteger(""String_Node_Str""));
      }
    }
  }
  this.hasPlates(me);
}",0.969352014010508
22415,"@Override public boolean canPutInSlot(ItemStack me,int slotNum,ItemStack upgrade){
  if (slotNum == 0) {
    ItemStack clone=upgrade.copy();
    clone.stackSize=1;
    return UtilPlates.getPlate(clone) != null;
  }
  if (upgrade.getItem() instanceof IExosuitUpgrade) {
    IExosuitUpgrade upgradeItem=(IExosuitUpgrade)upgrade.getItem();
    return (upgradeItem.getSlot().armor == this.slot && upgradeItem.getSlot().slot == slotNum) || (upgradeItem.getSlot() == ExosuitSlot.vanity && upgradeItem.getSlot().slot == slotNum);
  }
 else   if (slotNum == ExosuitSlot.vanity.slot) {
    int[] ids=OreDictionary.getOreIDs(upgrade);
    for (    int id : ids) {
      String str=OreDictionary.getOreName(id);
      if (str.contains(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean canPutInSlot(ItemStack me,int slotNum,ItemStack upgrade){
  if (slotNum == 0) {
    ItemStack clone=upgrade.copy();
    clone.stackSize=1;
    return UtilPlates.getPlate(clone) != null;
  }
  if (upgrade.getItem() instanceof IExosuitUpgrade) {
    IExosuitUpgrade upgradeItem=(IExosuitUpgrade)upgrade.getItem();
    return (upgradeItem.getSlot().armor == this.slot && upgradeItem.getSlot().slot == slotNum) || (upgradeItem.getSlot() == ExosuitSlot.VANITY && upgradeItem.getSlot().slot == slotNum);
  }
 else   if (slotNum == ExosuitSlot.VANITY.slot) {
    int[] ids=OreDictionary.getOreIDs(upgrade);
    for (    int id : ids) {
      String str=OreDictionary.getOreName(id);
      if (str.contains(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}",0.9850374064837906
22416,"@Override public double getDurabilityForDisplay(ItemStack stack){
  if (!stack.hasTagCompound()) {
    stack.setTagCompound(new NBTTagCompound());
  }
  if (!stack.stackTagCompound.hasKey(""String_Node_Str"")) {
    stack.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  if (!stack.stackTagCompound.hasKey(""String_Node_Str"")) {
    stack.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  return 1.0D - (stack.stackTagCompound.getInteger(""String_Node_Str"") / (double)stack.stackTagCompound.getInteger(""String_Node_Str""));
}","@Override public double getDurabilityForDisplay(ItemStack stack){
  if (!stack.hasTagCompound()) {
    stack.setTagCompound(new NBTTagCompound());
  }
  if (!stack.stackTagCompound.hasKey(""String_Node_Str"")) {
    stack.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  if (!stack.stackTagCompound.hasKey(""String_Node_Str"")) {
    stack.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  int fill=stack.stackTagCompound.getInteger(""String_Node_Str"");
  int max=stack.stackTagCompound.getInteger(""String_Node_Str"");
  return hasTank(stack) ? 1.0D - (fill / (double)max) : 1.0D;
}",0.7522281639928698
22417,"@Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack me,EntityPlayer player,List list,boolean par4){
  super.addInformation(me,player,list,par4);
  if (me.hasTagCompound()) {
    if (hasPlates(me) && UtilPlates.getPlate(me.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() != ""String_Node_Str"" && UtilPlates.getPlate(me.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() != ""String_Node_Str"") {
      list.add(EnumChatFormatting.BLUE + UtilPlates.getPlate(me.stackTagCompound.getString(""String_Node_Str"")).effect());
    }
    if (me.stackTagCompound.hasKey(""String_Node_Str"")) {
      for (int i=3; i < 10; i++) {
        if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
          ItemStack stack=ItemStack.loadItemStackFromNBT(me.stackTagCompound.getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
          list.add(EnumChatFormatting.RED + stack.getDisplayName());
        }
      }
    }
    if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(""String_Node_Str"")) {
      ItemStack stack=ItemStack.loadItemStackFromNBT(me.stackTagCompound.getCompoundTag(""String_Node_Str"").getCompoundTag(""String_Node_Str""));
      if (stack.getItem() != null && stack.getItem() == SteamcraftItems.enderShroud) {
        list.add(EnumChatFormatting.DARK_GREEN + StatCollector.translateToLocal(""String_Node_Str""));
      }
 else {
        int[] ids=OreDictionary.getOreIDs(stack);
        int dye=-1;
        outerloop:         for (        int id : ids) {
          String str=OreDictionary.getOreName(id);
          if (str.contains(""String_Node_Str"")) {
            for (int i=0; i < ModelExosuit.DYES.length; i++) {
              if (ModelExosuit.DYES[i].equals(str.substring(3))) {
                dye=15 - i;
                break outerloop;
              }
            }
          }
        }
        if (dye != -1) {
          list.add(EnumChatFormatting.DARK_GREEN + StatCollector.translateToLocal(""String_Node_Str"" + ModelExosuit.DYES[15 - dye].toLowerCase()));
        }
 else {
          list.add(EnumChatFormatting.DARK_GREEN + stack.getDisplayName());
        }
      }
    }
  }
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  if (slot == 1) {
    list.add(EnumChatFormatting.WHITE + ""String_Node_Str"" + me.stackTagCompound.getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"" + me.stackTagCompound.getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"");
  }
}","@Override @SideOnly(Side.CLIENT) public void addInformation(ItemStack me,EntityPlayer player,List list,boolean par4){
  super.addInformation(me,player,list,par4);
  if (me.hasTagCompound()) {
    if (hasPlates(me) && UtilPlates.getPlate(me.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() != ""String_Node_Str"" && UtilPlates.getPlate(me.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() != ""String_Node_Str"") {
      list.add(EnumChatFormatting.BLUE + UtilPlates.getPlate(me.stackTagCompound.getString(""String_Node_Str"")).effect());
    }
    if (me.stackTagCompound.hasKey(""String_Node_Str"")) {
      for (int i=3; i < 10; i++) {
        if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(Integer.toString(i))) {
          ItemStack stack=ItemStack.loadItemStackFromNBT(me.stackTagCompound.getCompoundTag(""String_Node_Str"").getCompoundTag(Integer.toString(i)));
          list.add(EnumChatFormatting.RED + stack.getDisplayName());
        }
      }
    }
    if (me.stackTagCompound.getCompoundTag(""String_Node_Str"").hasKey(""String_Node_Str"")) {
      ItemStack stack=ItemStack.loadItemStackFromNBT(me.stackTagCompound.getCompoundTag(""String_Node_Str"").getCompoundTag(""String_Node_Str""));
      if (stack.getItem() != null && stack.getItem() == SteamcraftItems.enderShroud) {
        list.add(EnumChatFormatting.DARK_GREEN + StatCollector.translateToLocal(""String_Node_Str""));
      }
 else {
        int[] ids=OreDictionary.getOreIDs(stack);
        int dye=-1;
        outerloop:         for (        int id : ids) {
          String str=OreDictionary.getOreName(id);
          if (str.contains(""String_Node_Str"")) {
            for (int i=0; i < ModelExosuit.DYES.length; i++) {
              if (ModelExosuit.DYES[i].equals(str.substring(3))) {
                dye=15 - i;
                break outerloop;
              }
            }
          }
        }
        if (dye != -1) {
          list.add(EnumChatFormatting.DARK_GREEN + StatCollector.translateToLocal(""String_Node_Str"" + ModelExosuit.DYES[15 - dye].toLowerCase()));
        }
 else {
          list.add(EnumChatFormatting.DARK_GREEN + stack.getDisplayName());
        }
      }
    }
  }
  if (!me.hasTagCompound()) {
    me.setTagCompound(new NBTTagCompound());
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  if (!me.stackTagCompound.hasKey(""String_Node_Str"")) {
    me.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  if (hasTank(me)) {
    list.add(EnumChatFormatting.WHITE + ""String_Node_Str"" + me.stackTagCompound.getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"" + me.stackTagCompound.getInteger(""String_Node_Str"") * 5 + ""String_Node_Str"");
  }
}",0.9963596650891882
22418,"@Override public MutablePair<Integer,Integer>[] engineerCoordinates(){
  if (this.slot == 0) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(39,16),MutablePair.of(59,36)};
  }
  if (this.slot == 2) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(60,12),MutablePair.of(37,40)};
  }
  if (this.slot == 1) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(49,33),MutablePair.of(75,26),MutablePair.of(1,37)};
  }
  if (this.slot == 3) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(60,18),MutablePair.of(28,40)};
  }
  return new MutablePair[]{MutablePair.of(49,26)};
}","@SuppressWarnings(""String_Node_Str"") @Override public MutablePair<Integer,Integer>[] engineerCoordinates(){
  if (this.slot == 0) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(39,16),MutablePair.of(59,36)};
  }
  if (this.slot == 2) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(60,12),MutablePair.of(37,40)};
  }
  if (this.slot == 1) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(49,33),MutablePair.of(75,26),MutablePair.of(1,37)};
  }
  if (this.slot == 3) {
    return new MutablePair[]{MutablePair.of(1,19),MutablePair.of(1,1),MutablePair.of(60,18),MutablePair.of(28,40)};
  }
  return new MutablePair[]{MutablePair.of(49,26)};
}",0.9749492213947192
22419,"public ItemExosuitJetpack(){
  super(ExosuitSlot.bodyFront,""String_Node_Str"",""String_Node_Str"",0);
}","public ItemExosuitJetpack(){
  super(ExosuitSlot.BODY_FRONT,""String_Node_Str"",""String_Node_Str"",0);
}",0.9154228855721394
22420,"public ItemExosuitSidepack(){
  super(ExosuitSlot.legsHips,""String_Node_Str"",""String_Node_Str"",0);
}","public ItemExosuitSidepack(){
  super(ExosuitSlot.LEGS_HIPS,""String_Node_Str"",""String_Node_Str"",0);
}",0.9253731343283582
22421,"public ItemExosuitWings(){
  super(ExosuitSlot.bodyFront,""String_Node_Str"",""String_Node_Str"",0);
}","public ItemExosuitWings(){
  super(ExosuitSlot.BODY_FRONT,""String_Node_Str"",""String_Node_Str"",0);
}",0.9137055837563453
22422,"@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.bodyTank;
}","@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.BODY_TANK;
}",0.896551724137931
22423,"@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.headGoggles;
}","@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.HEAD_GOGGLES;
}",0.8609271523178808
22424,"@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.headHelm;
}","@Override public ExosuitSlot getSlot(){
  return ExosuitSlot.HEAD_HELM;
}",0.896551724137931
22425,"@SubscribeEvent public void openMerchant(EntityInteractEvent event){
  EntityPlayer player=event.entityPlayer;
  Entity target=event.target;
  if (playerHasFrequencyShifter(player) && (target instanceof EntityWolf || target instanceof EntityOcelot)) {
    EntityLiving living=(EntityLiving)target;
    ExtendedPropertiesMerchant nbt=(ExtendedPropertiesMerchant)living.getExtendedProperties(Steamcraft.MERCHANT_PROPERTY_ID);
    if (nbt.totalTrades > nbt.maximumTrades) {
      if (living instanceof EntityWolf) {
        EntityWolf wolf=(EntityWolf)living;
        wolf.setAngry(true);
      }
 else {
        EntityOcelot cat=(EntityOcelot)living;
        living.targetTasks.addTask(3,new EntityAIHurtByTarget(cat,true));
      }
    }
 else {
      if (living.hasCustomNameTag()) {
        nbt.merchantName=living.getCustomNameTag();
      }
      String name=nbt.merchantName;
      FrequencyMerchant merchant=new FrequencyMerchant(living,name);
      merchant.setCustomer(player);
      player.displayGUIMerchant(merchant,name);
      nbt.totalTrades+=1;
    }
  }
}","@SubscribeEvent(priority=EventPriority.LOWEST) public void openMerchant(EntityInteractEvent event){
  EntityPlayer player=event.entityPlayer;
  Entity target=event.target;
  ItemStack held=player.getHeldItem();
  if (playerHasFrequencyShifter(player) && (target instanceof EntityWolf || target instanceof EntityOcelot)) {
    boolean flag=held == null || !(held.getItem() instanceof ItemNameTag);
    if (!flag) {
      return;
    }
    EntityLiving living=(EntityLiving)target;
    ExtendedPropertiesMerchant nbt=(ExtendedPropertiesMerchant)living.getExtendedProperties(Steamcraft.MERCHANT_PROPERTY_ID);
    if (nbt.totalTrades > nbt.maximumTrades) {
      if (living instanceof EntityWolf) {
        EntityWolf wolf=(EntityWolf)living;
        wolf.setAngry(true);
      }
 else {
        EntityOcelot cat=(EntityOcelot)living;
        living.targetTasks.addTask(3,new EntityAIHurtByTarget(cat,true));
      }
    }
 else {
      if (living.hasCustomNameTag()) {
        nbt.merchantName=living.getCustomNameTag();
      }
      String name=nbt.merchantName;
      FrequencyMerchant merchant=new FrequencyMerchant(living,name);
      merchant.setCustomer(player);
      player.displayGUIMerchant(merchant,name);
      nbt.totalTrades+=1;
    }
  }
}",0.9207579672695952
22426,"/** 
 * Checks whether the given player has the Frequency Shifter upgrade, and enough steam in their suit.
 * @param player The player to check.
 * @return
 */
private boolean playerHasFrequencyShifter(EntityPlayer player){
  ItemStack helmet=player.getEquipmentInSlot(4);
  if (helmet != null && hasPower(player,1)) {
    Item helmetItem=helmet.getItem();
    if (helmetItem instanceof ItemExosuitArmor) {
      ItemExosuitArmor helmetArmor=(ItemExosuitArmor)helmetItem;
      if (helmetArmor.hasUpgrade(helmet,SteamcraftItems.frequencyShifter)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Checks whether the given player has the Frequency Shifter upgrade, and enough steam in their suit.
 * @param player The player to check.
 * @return True if the player has the Frequency Shifter upgrade.
 */
private boolean playerHasFrequencyShifter(EntityPlayer player){
  ItemStack helmet=player.getEquipmentInSlot(4);
  if (helmet != null && hasPower(player,1)) {
    Item helmetItem=helmet.getItem();
    if (helmetItem instanceof ItemExosuitArmor) {
      ItemExosuitArmor helmetArmor=(ItemExosuitArmor)helmetItem;
      if (helmetArmor.hasUpgrade(helmet,SteamcraftItems.frequencyShifter)) {
        return true;
      }
    }
  }
  return false;
}",0.9572784810126582
22427,"@Override public void renderTileEntityAt(TileEntity var1,double var2,double var4,double var6,float var8){
  TileEntitySteamCharger charger=(TileEntitySteamCharger)var1;
  GameSettings settings=Minecraft.getMinecraft().gameSettings;
  int meta=charger.getWorldObj().getBlockMetadata(charger.xCoord,charger.yCoord,charger.zCoord);
  if (charger.getStackInSlot(0) != null) {
    GL11.glPushMatrix();
    GL11.glTranslatef((float)var2 + 0.5F,(float)var4 + 0.5F + (1.0F / 16.0F) - 0.02F,(float)var6 + 0.5F);
    GL11.glScalef(2.0F,2.0F,2.0F);
    GL11.glRotatef(0.0F + 90.0F * meta + (meta % 2 == 0 ? 180.0F : 0.0F),0.0F,1.0F,0.0F);
    GL11.glRotatef(90.0F,1.0F,0.0F,0.0F);
    GL11.glTranslatef(0.0F,-(7.0F / 32.0F),0.0F);
    ItemStack is=charger.getStackInSlot(0).copy();
    is.stackSize=1;
    EntityItem item=new EntityItem(var1.getWorldObj(),0.0F,0.0F,0.0F,is);
    item.hoverStart=0.0F;
    boolean fancy=settings.fancyGraphics;
    settings.fancyGraphics=true;
    RenderManager.instance.renderEntityWithPosYaw(item,0.0D,0.0D,0.0D,0.0F,0.0F);
    settings.fancyGraphics=fancy;
    GL11.glPopMatrix();
  }
}","@Override public void renderTileEntityAt(TileEntity var1,double var2,double var4,double var6,float var8){
  TileEntitySteamCharger charger=(TileEntitySteamCharger)var1;
  GameSettings settings=Minecraft.getMinecraft().gameSettings;
  int meta=charger.getWorldObj().getBlockMetadata(charger.xCoord,charger.yCoord,charger.zCoord);
  if (charger.getStackInSlot(0) != null) {
    RenderItem.renderInFrame=true;
    GL11.glPushMatrix();
    GL11.glTranslatef((float)var2 + 0.5F,(float)var4 + 0.5F + (1.0F / 16.0F) - 0.02F,(float)var6 + 0.5F);
    GL11.glScalef(2.0F,2.0F,2.0F);
    GL11.glRotatef(0.0F + 90.0F * meta + (meta % 2 == 0 ? 180.0F : 0.0F),0.0F,1.0F,0.0F);
    GL11.glRotatef(90.0F,1.0F,0.0F,0.0F);
    GL11.glTranslatef(0.0F,-(7.0F / 32.0F),0.0F);
    ItemStack is=charger.getStackInSlot(0).copy();
    is.stackSize=1;
    EntityItem item=new EntityItem(var1.getWorldObj(),0.0F,0.0F,0.0F,is);
    item.hoverStart=0.0F;
    boolean fancy=settings.fancyGraphics;
    settings.fancyGraphics=true;
    RenderManager.instance.renderEntityWithPosYaw(item,0.0D,0.0D,0.0D,0.0F,0.0F);
    settings.fancyGraphics=fancy;
    GL11.glPopMatrix();
    RenderItem.renderInFrame=false;
  }
}",0.9690361971216748
22428,"public static void sendConnectPacket(Entity player,int x,int y,int z,MovingObjectPosition pos){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(4);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
    out.writeInt(x);
    out.writeInt(y);
    out.writeInt(z);
    out.writeInt(pos.subHit);
  }
 catch (  IOException e) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void sendConnectPacket(Entity player,int x,int y,int z,MovingObjectPosition pos){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(4);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
    out.writeInt(x);
    out.writeInt(y);
    out.writeInt(z);
    out.writeInt(pos.subHit);
  }
 catch (  IOException ignored) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9937304075235108
22429,"public static void sendGrapplePacket(EntityPlayer player,int x,int y,int z){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(5);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
    out.writeInt(x);
    out.writeInt(y);
    out.writeInt(z);
    out.writeDouble(player.posX);
    out.writeDouble(player.posY);
    out.writeDouble(player.posZ);
  }
 catch (  IOException e) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void sendGrapplePacket(EntityPlayer player,int x,int y,int z){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(5);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
    out.writeInt(x);
    out.writeInt(y);
    out.writeInt(z);
    out.writeDouble(player.posX);
    out.writeDouble(player.posY);
    out.writeDouble(player.posZ);
  }
 catch (  IOException ignored) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9942112879884226
22430,"public static void sendCamoPacket(Entity player,MovingObjectPosition pos){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(3);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
    out.writeInt(pos.blockX);
    out.writeInt(pos.blockY);
    out.writeInt(pos.blockZ);
  }
 catch (  IOException e) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void sendCamoPacket(Entity player,MovingObjectPosition pos){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(3);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
    out.writeInt(pos.blockX);
    out.writeInt(pos.blockY);
    out.writeInt(pos.blockZ);
  }
 catch (  IOException ignored) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.993485342019544
22431,"public static void sendNoSpacePacket(Entity player){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(2);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
  }
 catch (  IOException e) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void sendNoSpacePacket(Entity player){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(2);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
  }
 catch (  IOException ignored) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9920318725099602
22432,"private void handleExplodePacket(ByteBufInputStream dat,World world){
  try {
    newExplosion(world,null,dat.readDouble(),dat.readDouble(),dat.readDouble(),dat.readFloat(),true,world.getGameRules().getGameRuleBooleanValue(""String_Node_Str""));
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
}","private void handleExplodePacket(ByteBufInputStream dat,World world){
  try {
    newExplosion(world,null,dat.readDouble(),dat.readDouble(),dat.readDouble(),dat.readFloat(),true,world.getGameRules().getGameRuleBooleanValue(""String_Node_Str""));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9805825242718448
22433,"private void handleRocketJumpHackyPacket(ByteBufInputStream dat,World world){
  try {
    int id=dat.readInt();
    EntityPlayer player=(EntityPlayer)world.getEntityByID(id);
    if (player != null) {
      double motionX=dat.readDouble();
      double motionY=dat.readDouble();
      double motionZ=dat.readDouble();
      Minecraft.getMinecraft().thePlayer.motionX+=motionX;
      Minecraft.getMinecraft().thePlayer.motionY+=motionY;
      Minecraft.getMinecraft().thePlayer.motionZ+=motionZ;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
}","private void handleRocketJumpHackyPacket(ByteBufInputStream dat,World world){
  try {
    int id=dat.readInt();
    Entity entity=world.getEntityByID(id);
    if (entity == null || !(entity instanceof EntityPlayer)) {
      return;
    }
    EntityPlayer player=(EntityPlayer)entity;
    double motionX=dat.readDouble();
    double motionY=dat.readDouble();
    double motionZ=dat.readDouble();
    player.motionX+=motionX;
    player.motionY+=motionY;
    player.motionZ+=motionZ;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.7493261455525606
22434,"public static void sendSpacePacket(Entity player){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(0);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
  }
 catch (  IOException e) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void sendSpacePacket(Entity player){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(0);
    out.writeInt(player.worldObj.provider.dimensionId);
    out.writeInt(player.getEntityId());
  }
 catch (  IOException ignored) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.992
22435,"public static void sendItemNamePacket(World worldObj,int x,int y,int z,String s,EntityPlayer player){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(1);
    out.writeInt(worldObj.provider.dimensionId);
    out.writeInt(x);
    out.writeInt(y);
    out.writeInt(z);
    out.writeUTF(s);
    out.writeInt(player.getEntityId());
  }
 catch (  IOException e) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void sendItemNamePacket(World worldObj,int x,int y,int z,String s,EntityPlayer player){
  ByteBuf buf=Unpooled.buffer();
  ByteBufOutputStream out=new ByteBufOutputStream(buf);
  try {
    out.writeByte(1);
    out.writeInt(worldObj.provider.dimensionId);
    out.writeInt(x);
    out.writeInt(y);
    out.writeInt(z);
    out.writeUTF(s);
    out.writeInt(player.getEntityId());
  }
 catch (  IOException ignored) {
  }
  FMLProxyPacket packet=new FMLProxyPacket(buf,""String_Node_Str"");
  Steamcraft.channel.sendToServer(packet);
  try {
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9936305732484076
22436,"@SubscribeEvent public void onClientPacket(ClientCustomPacketEvent event){
  EntityClientPlayerMP player=Minecraft.getMinecraft().thePlayer;
  ByteBufInputStream bbis=new ByteBufInputStream(event.packet.payload());
  byte packetType;
  int dimension;
  byte packetID;
  try {
    packetType=bbis.readByte();
    dimension=bbis.readInt();
    World world=DimensionManager.getWorld(dimension);
    if (packetType == 2) {
      this.handleRocketJumpHackyPacket(bbis,world);
    }
    if (packetType == 3) {
      this.handleExplodePacket(bbis,world);
    }
    bbis.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return;
  }
}","@SubscribeEvent public void onClientPacket(ClientCustomPacketEvent event){
  ByteBufInputStream bbis=new ByteBufInputStream(event.packet.payload());
  byte packetType;
  int dimension;
  try {
    packetType=bbis.readByte();
    dimension=bbis.readInt();
    World world=DimensionManager.getWorld(dimension);
switch (packetType) {
case 2:
{
        this.handleRocketJumpHackyPacket(bbis,world);
      }
case 3:
{
      this.handleExplodePacket(bbis,world);
    }
}
bbis.close();
}
 catch (Exception e) {
e.printStackTrace();
}
}",0.8300597779675492
22437,"/** 
 * Looks for changes made in the container, sends them to every listener.
 */
public void detectAndSendChanges(){
  super.detectAndSendChanges();
  for (int i=0; i < this.crafters.size(); ++i) {
    ICrafting icrafting=(ICrafting)this.crafters.get(i);
    if (this.lastCookTime != this.furnace.furnaceCookTime) {
      icrafting.sendProgressBarUpdate(this,0,this.furnace.furnaceCookTime);
    }
    if (this.lastBurnTime != this.furnace.furnaceBurnTime) {
      icrafting.sendProgressBarUpdate(this,1,this.furnace.furnaceBurnTime);
    }
    if (this.lastItemBurnTime != this.furnace.currentItemBurnTime) {
      icrafting.sendProgressBarUpdate(this,2,this.furnace.currentItemBurnTime);
    }
    if (this.lastPressure != this.furnace.getPressureAsInt()) {
      icrafting.sendProgressBarUpdate(this,3,this.furnace.getPressureAsInt());
    }
    if (this.lastWater != this.furnace.getTank().getFluidAmount()) {
      icrafting.sendProgressBarUpdate(this,4,this.furnace.getTank().getFluidAmount());
    }
  }
  this.lastCookTime=this.furnace.furnaceCookTime;
  this.lastBurnTime=this.furnace.furnaceBurnTime;
  this.lastItemBurnTime=this.furnace.currentItemBurnTime;
  this.lastPressure=this.furnace.getPressureAsInt();
  this.lastWater=this.furnace.getTank().getFluidAmount();
}","/** 
 * Looks for changes made in the container, sends them to every listener.
 */
@Override public void detectAndSendChanges(){
  super.detectAndSendChanges();
  for (int i=0; i < this.crafters.size(); ++i) {
    ICrafting icrafting=(ICrafting)this.crafters.get(i);
    if (this.lastCookTime != this.furnace.furnaceCookTime) {
      icrafting.sendProgressBarUpdate(this,0,this.furnace.furnaceCookTime);
    }
    if (this.lastBurnTime != this.furnace.furnaceBurnTime) {
      icrafting.sendProgressBarUpdate(this,1,this.furnace.furnaceBurnTime);
    }
    if (this.lastItemBurnTime != this.furnace.currentItemBurnTime) {
      icrafting.sendProgressBarUpdate(this,2,this.furnace.currentItemBurnTime);
    }
    if (this.lastPressure != this.furnace.getPressureAsInt()) {
      icrafting.sendProgressBarUpdate(this,3,this.furnace.getPressureAsInt());
    }
    if (this.lastWater != this.furnace.getTank().getFluidAmount()) {
      icrafting.sendProgressBarUpdate(this,4,this.furnace.getTank().getFluidAmount());
    }
  }
  this.lastCookTime=this.furnace.furnaceCookTime;
  this.lastBurnTime=this.furnace.furnaceBurnTime;
  this.lastItemBurnTime=this.furnace.currentItemBurnTime;
  this.lastPressure=this.furnace.getPressureAsInt();
  this.lastWater=this.furnace.getTank().getFluidAmount();
}",0.9961180124223602
22438,"/** 
 * Called when a player shift-clicks on a slot. You must override this or you will crash when someone does that.
 */
public ItemStack transferStackInSlot(EntityPlayer par1EntityPlayer,int par2){
  ItemStack itemstack=null;
  Slot slot=(Slot)this.inventorySlots.get(par2);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (par2 == 2) {
      return null;
    }
 else     if (par2 != 1 && par2 != 0) {
      if (itemstack1.getItem() == Items.water_bucket || (itemstack1.getItem() instanceof IFluidContainerItem && ((IFluidContainerItem)itemstack1.getItem()).getFluid(itemstack1).getFluid() == FluidRegistry.WATER)) {
        if (!this.mergeItemStack(itemstack1,0,1,false)) {
          return null;
        }
      }
 else       if (TileEntityFurnace.isItemFuel(itemstack1)) {
        if (!this.mergeItemStack(itemstack1,1,2,false)) {
          return null;
        }
      }
 else       if (par2 >= 2 && par2 < 30) {
        if (!this.mergeItemStack(itemstack1,30,38,false)) {
          return null;
        }
      }
 else       if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(itemstack1,3,30,false)) {
        return null;
      }
    }
 else     if (!this.mergeItemStack(itemstack1,3,38,false)) {
      return null;
    }
    if (itemstack1.stackSize == 0) {
      slot.putStack(null);
    }
 else {
      slot.onSlotChanged();
    }
    if (itemstack1.stackSize == itemstack.stackSize) {
      return null;
    }
    slot.onPickupFromSlot(par1EntityPlayer,itemstack1);
  }
  return itemstack;
}","/** 
 * Called when a player shift-clicks on a slot. You must override this or you will crash when someone does that.
 */
@Override public ItemStack transferStackInSlot(EntityPlayer par1EntityPlayer,int par2){
  ItemStack itemstack=null;
  Slot slot=(Slot)this.inventorySlots.get(par2);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (par2 == 2) {
      return null;
    }
 else     if (par2 != 1 && par2 != 0) {
      if (itemstack1.getItem() == Items.water_bucket || (itemstack1.getItem() instanceof IFluidContainerItem && ((IFluidContainerItem)itemstack1.getItem()).getFluid(itemstack1).getFluid() == FluidRegistry.WATER)) {
        if (!this.mergeItemStack(itemstack1,0,1,false)) {
          return null;
        }
      }
 else       if (TileEntityFurnace.isItemFuel(itemstack1)) {
        if (!this.mergeItemStack(itemstack1,1,2,false)) {
          return null;
        }
      }
 else       if (par2 >= 2 && par2 < 30) {
        if (!this.mergeItemStack(itemstack1,30,38,false)) {
          return null;
        }
      }
 else       if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(itemstack1,3,30,false)) {
        return null;
      }
    }
 else     if (!this.mergeItemStack(itemstack1,3,38,false)) {
      return null;
    }
    if (itemstack1.stackSize == 0) {
      slot.putStack(null);
    }
 else {
      slot.onSlotChanged();
    }
    if (itemstack1.stackSize == itemstack.stackSize) {
      return null;
    }
    slot.onPickupFromSlot(par1EntityPlayer,itemstack1);
  }
  return itemstack;
}",0.9968494013862634
22439,"public void addCraftingToCrafters(ICrafting par1ICrafting){
  super.addCraftingToCrafters(par1ICrafting);
  par1ICrafting.sendProgressBarUpdate(this,0,this.furnace.furnaceCookTime);
  par1ICrafting.sendProgressBarUpdate(this,1,this.furnace.furnaceBurnTime);
  par1ICrafting.sendProgressBarUpdate(this,2,TileEntityBoiler.getItemBurnTime(null));
  par1ICrafting.sendProgressBarUpdate(this,3,(int)Math.floor((double)this.furnace.getPressure() * 1000));
}","@Override public void addCraftingToCrafters(ICrafting par1ICrafting){
  super.addCraftingToCrafters(par1ICrafting);
  par1ICrafting.sendProgressBarUpdate(this,0,this.furnace.furnaceCookTime);
  par1ICrafting.sendProgressBarUpdate(this,1,this.furnace.furnaceBurnTime);
  par1ICrafting.sendProgressBarUpdate(this,2,TileEntityBoiler.getItemBurnTime(null));
  par1ICrafting.sendProgressBarUpdate(this,3,(int)Math.floor((double)this.furnace.getPressure() * 1000));
}",0.9890350877192984
22440,"@SideOnly(Side.CLIENT) public void updateProgressBar(int par1,int par2){
  if (par1 == 0) {
    this.furnace.furnaceCookTime=par2;
  }
  if (par1 == 1) {
    this.furnace.furnaceBurnTime=par2;
  }
  if (par1 == 2) {
    this.furnace.currentItemBurnTime=par2;
  }
  if (par1 == 3) {
    this.furnace.pressure=(float)par2 / 1000F;
  }
  if (par1 == 4) {
    int current=this.furnace.getTank().getFluidAmount();
    int diff=par2 - current;
    if (diff > 0) {
      this.furnace.getTank().fill(new FluidStack(FluidRegistry.WATER,diff),true);
    }
 else {
      this.furnace.getTank().drain(-1 * diff,true);
    }
  }
}","@SideOnly(Side.CLIENT) @Override public void updateProgressBar(int par1,int par2){
  if (par1 == 0) {
    this.furnace.furnaceCookTime=par2;
  }
  if (par1 == 1) {
    this.furnace.furnaceBurnTime=par2;
  }
  if (par1 == 2) {
    this.furnace.currentItemBurnTime=par2;
  }
  if (par1 == 3) {
    this.furnace.pressure=(float)par2 / 1000F;
  }
  if (par1 == 4) {
    int current=this.furnace.getTank().getFluidAmount();
    int diff=par2 - current;
    if (diff > 0) {
      this.furnace.getTank().fill(new FluidStack(FluidRegistry.WATER,diff),true);
    }
 else {
      this.furnace.getTank().drain(-1 * diff,true);
    }
  }
}",0.9919614147909968
22441,"private static void registerFood(){
  steamedFish=new ItemSteamedFood((ItemFood)Items.cooked_fished).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedFish,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_fished,steamedFish);
  steamedSalmon=new ItemSteamedFood((ItemFood)new ItemStack(Items.cooked_fished,1,1).getItem()).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedSalmon,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(new ItemStack(Items.cooked_fished,1,1).getItem(),steamedSalmon);
  steamedChicken=new ItemSteamedFood((ItemFood)Items.cooked_chicken).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedChicken,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_chicken,steamedChicken);
  steamedBeef=new ItemSteamedFood((ItemFood)Items.cooked_beef).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedBeef,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_beef,steamedBeef);
  steamedPorkchop=new ItemSteamedFood((ItemFood)Items.cooked_porkchop).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedPorkchop,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_porkchop,steamedPorkchop);
}","private static void registerFood(){
  steamedFish=new ItemSteamedFood((ItemFood)Items.cooked_fished).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedFish,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_fished,steamedFish);
  steamedSalmon=new ItemSteamedFood((ItemFood)new ItemStack(Items.cooked_fished,1,1).getItem()).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab).setTextureName(""String_Node_Str"");
  GameRegistry.registerItem(steamedSalmon,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_fished,1,steamedSalmon,-1);
  steamedChicken=new ItemSteamedFood((ItemFood)Items.cooked_chicken).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedChicken,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_chicken,steamedChicken);
  steamedBeef=new ItemSteamedFood((ItemFood)Items.cooked_beef).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedBeef,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_beef,steamedBeef);
  steamedPorkchop=new ItemSteamedFood((ItemFood)Items.cooked_porkchop).setUnlocalizedName(""String_Node_Str"").setCreativeTab(Steamcraft.tab);
  GameRegistry.registerItem(steamedPorkchop,""String_Node_Str"");
  SteamcraftRegistry.addSteamFood(Items.cooked_porkchop,steamedPorkchop);
}",0.969529085872576
22442,"public static void addSteamFood(Item food1,Item food2){
  steamedFoods.put(MutablePair.of(food1,-1),MutablePair.of(food2,-1));
}","/** 
 * Adds a steamed food to the steamedFoods registry without metadata.
 * @param food1 The input food item
 * @param food2 The output food item
 */
public static void addSteamFood(Item food1,Item food2){
  steamedFoods.put(MutablePair.of(food1,-1),MutablePair.of(food2,-1));
}",0.6274509803921569
22443,"@Override public void smeltItem(){
  if (this.canSmelt()) {
    ItemStack itemstack=FurnaceRecipes.smelting().getSmeltingResult(this.getStackInSlot(0));
    if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),-1))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,0,meta);
      }
    }
    if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage()))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,0,meta);
      }
    }
    if (this.getStackInSlot(2) == null) {
      this.setInventorySlotContents(2,itemstack.copy());
    }
 else     if (this.getStackInSlot(2).getItem() == itemstack.getItem()) {
      ItemStack copy=this.getStackInSlot(2).copy();
      copy.stackSize+=itemstack.stackSize;
      this.setInventorySlotContents(2,copy);
    }
    ItemStack copy=this.getStackInSlot(0).copy();
    copy.stackSize--;
    this.setInventorySlotContents(0,copy);
    if (this.getStackInSlot(0).stackSize <= 0) {
      this.setInventorySlotContents(0,null);
    }
  }
}","@Override public void smeltItem(){
  if (this.canSmelt()) {
    ItemStack itemstack=FurnaceRecipes.smelting().getSmeltingResult(this.getStackInSlot(0));
    if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage()))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,1,meta);
      }
    }
 else     if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),-1))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,1,meta);
      }
    }
    if (this.getStackInSlot(2) == null) {
      this.setInventorySlotContents(2,itemstack.copy());
    }
 else     if (this.getStackInSlot(2).getItem() == itemstack.getItem()) {
      ItemStack copy=this.getStackInSlot(2).copy();
      copy.stackSize+=itemstack.stackSize;
      this.setInventorySlotContents(2,copy);
    }
    ItemStack copy=this.getStackInSlot(0).copy();
    copy.stackSize--;
    this.setInventorySlotContents(0,copy);
    if (this.getStackInSlot(0).stackSize <= 0) {
      this.setInventorySlotContents(0,null);
    }
  }
}",0.6771025168815225
22444,"public boolean canSmelt(){
  if (this.getStackInSlot(0) == null) {
    return false;
  }
 else {
    ItemStack itemstack=FurnaceRecipes.smelting().getSmeltingResult(this.getStackInSlot(0));
    if (itemstack == null)     return false;
    if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),-1))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,0,meta);
      }
    }
    if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage()))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,0,meta);
      }
    }
    if (this.getStackInSlot(2) == null)     return true;
    if (!this.getStackInSlot(2).isItemEqual(itemstack))     return false;
    int result=getStackInSlot(2).stackSize + itemstack.stackSize;
    return result <= getInventoryStackLimit() && result <= this.getStackInSlot(2).getMaxStackSize();
  }
}","public boolean canSmelt(){
  if (this.getStackInSlot(0) == null) {
    return false;
  }
 else {
    ItemStack itemstack=FurnaceRecipes.smelting().getSmeltingResult(this.getStackInSlot(0));
    if (itemstack == null)     return false;
    if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage()))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),itemstack.getItemDamage())).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,1,meta);
      }
    }
 else     if (SteamcraftRegistry.steamedFoods.containsKey(MutablePair.of(itemstack.getItem(),-1))) {
      int meta=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).right;
      Item item=SteamcraftRegistry.steamedFoods.get(MutablePair.of(itemstack.getItem(),-1)).left;
      if (meta == -1) {
        itemstack=new ItemStack(item);
      }
 else {
        itemstack=new ItemStack(item,1,meta);
      }
    }
    if (this.getStackInSlot(2) == null)     return true;
    if (!this.getStackInSlot(2).isItemEqual(itemstack))     return false;
    int result=getStackInSlot(2).stackSize + itemstack.stackSize;
    return result <= getInventoryStackLimit() && result <= this.getStackInSlot(2).getMaxStackSize();
  }
}",0.6585034013605442
22445,"@SideOnly(Side.CLIENT) public static void extendRange(Entity entity,float amount){
}","@SideOnly(Side.CLIENT) public static void extendRange(Entity entity,float amount){
  Minecraft mc=Minecraft.getMinecraft();
  if (!(mc.playerController instanceof IExtendedPlayerController)) {
    GameType type=ReflectionHelper.getPrivateValue(PlayerControllerMP.class,mc.playerController,CURRENT_GAME_TYPE);
    NetHandlerPlayClient net=ReflectionHelper.getPrivateValue(PlayerControllerMP.class,mc.playerController,NET_CLIENT_HANDLER);
    SteamcraftPlayerController controller=new SteamcraftPlayerController(mc,net);
    controller.setGameType(type);
    mc.playerController=controller;
  }
  ((IExtendedPlayerController)mc.playerController).setReachDistanceExtension(((IExtendedPlayerController)mc.playerController).getReachDistanceExtension() + amount);
}",0.199288256227758
22446,"public static Multimap addModifiers(Multimap map,ItemStack stack,int armorType){
}","public static Multimap addModifiers(Multimap map,ItemStack stack,int armorType){
  if ((((ItemExosuitArmor)stack.getItem()).hasPlates(stack) && UtilPlates.getPlate(stack.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() == ""String_Node_Str"")) {
    int hp=1;
switch (armorType) {
case 0:
      hp=2;
    break;
case 1:
  hp=4;
break;
case 2:
hp=2;
break;
case 4:
hp=2;
}
map.put(SharedMonsterAttributes.maxHealth.getAttributeUnlocalizedName(),new AttributeModifier(new UUID(171328,armorType),""String_Node_Str"" + armorType,hp,0));
}
return map;
}",0.25625
22447,"@SideOnly(Side.CLIENT) public static void displayThings(MovingObjectPosition pos,RenderGameOverlayEvent.Post event){
  Minecraft mc=Minecraft.getMinecraft();
  Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
  if (block instanceof IWandHUD) {
    ((IWandHUD)block).renderHUD(mc,event.resolution,mc.theWorld,pos.blockX,pos.blockY,pos.blockZ);
  }
}","@SideOnly(Side.CLIENT) public static void displayThings(MovingObjectPosition pos,RenderGameOverlayEvent.Post event){
  Minecraft mc=Minecraft.getMinecraft();
  Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
  if (block instanceof IWandHUD)   ((IWandHUD)block).renderHUD(mc,event.resolution,mc.theWorld,pos.blockX,pos.blockY,pos.blockZ);
}",0.9889807162534436
22448,"@SideOnly(Side.CLIENT) public static void extendRange(Entity entity,float amount){
  Minecraft mc=Minecraft.getMinecraft();
  if (!(mc.playerController instanceof IExtendedPlayerController)) {
    GameType type=ReflectionHelper.getPrivateValue(PlayerControllerMP.class,mc.playerController,CURRENT_GAME_TYPE);
    NetHandlerPlayClient net=ReflectionHelper.getPrivateValue(PlayerControllerMP.class,mc.playerController,NET_CLIENT_HANDLER);
    SteamcraftPlayerController controller=new SteamcraftPlayerController(mc,net);
    controller.setGameType(type);
    mc.playerController=controller;
  }
  ((IExtendedPlayerController)mc.playerController).setReachDistanceExtension(((IExtendedPlayerController)mc.playerController).getReachDistanceExtension() + amount);
}","@SideOnly(Side.CLIENT) public static void extendRange(Entity entity,float amount){
}",0.199288256227758
22449,"public static Multimap addModifiers(Multimap map,ItemStack stack,int armorType){
  if ((((ItemExosuitArmor)stack.getItem()).hasPlates(stack) && UtilPlates.getPlate(stack.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() == ""String_Node_Str"")) {
    int hp=1;
switch (armorType) {
case 0:
      hp=2;
    break;
case 1:
  hp=4;
break;
case 2:
hp=2;
break;
case 4:
hp=2;
}
map.put(SharedMonsterAttributes.maxHealth.getAttributeUnlocalizedName(),new AttributeModifier(new UUID(171328,armorType),""String_Node_Str"" + armorType,hp,0));
}
return map;
}","public static Multimap addModifiers(Multimap map,ItemStack stack,int armorType){
}",0.25625
22450,"@SideOnly(Side.CLIENT) public static void displayThings(MovingObjectPosition pos,RenderGameOverlayEvent.Post event){
  Minecraft mc=Minecraft.getMinecraft();
  Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
  if (block instanceof IWandHUD)   ((IWandHUD)block).renderHUD(mc,event.resolution,mc.theWorld,pos.blockX,pos.blockY,pos.blockZ);
}","@SideOnly(Side.CLIENT) public static void displayThings(MovingObjectPosition pos,RenderGameOverlayEvent.Post event){
  Minecraft mc=Minecraft.getMinecraft();
  Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
  if (block instanceof IWandHUD) {
    ((IWandHUD)block).renderHUD(mc,event.resolution,mc.theWorld,pos.blockX,pos.blockY,pos.blockZ);
  }
}",0.9889807162534436
22451,"@SideOnly(Side.CLIENT) @SubscribeEvent public void onDrawScreen(RenderGameOverlayEvent.Post event){
  if (event.type == ElementType.ALL) {
    Minecraft mc=Minecraft.getMinecraft();
    EntityPlayer player=mc.thePlayer;
    Item equipped=player.getCurrentEquippedItem() != null ? player.getCurrentEquippedItem().getItem() : null;
    MovingObjectPosition pos=mc.objectMouseOver;
    if (pos != null && mc.thePlayer.getCurrentEquippedItem() != null && mc.thePlayer.getCurrentEquippedItem().getItem() instanceof IPipeWrench && ((IPipeWrench)equipped).canWrench(player,pos.blockX,pos.blockY,pos.blockZ)) {
      TileEntity te=mc.theWorld.getTileEntity(pos.blockX,pos.blockY,pos.blockZ);
      if (te instanceof IWrenchDisplay) {
        ((IWrenchDisplay)te).displayWrench(event);
      }
    }
    if (CrossMod.BOTANIA) {
      if (pos != null && player.getEquipmentInSlot(4) != null && player.getEquipmentInSlot(4).getItem() instanceof ItemExosuitArmor && (player.getHeldItem() == null || player.getHeldItem().getItem() != BotaniaIntegration.twigWand())) {
        ItemExosuitArmor chest=(ItemExosuitArmor)player.getEquipmentInSlot(3).getItem();
        if (chest.hasUpgrade(player.getEquipmentInSlot(3),BotaniaIntegration.floralLaurel)) {
          Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
          BotaniaIntegration.displayThings(pos,event);
        }
      }
    }
    if (pos != null && mc.thePlayer.getCurrentEquippedItem() != null && mc.thePlayer.getCurrentEquippedItem().getItem() == SteamcraftItems.book) {
      Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
      ItemStack stack=block.getPickBlock(pos,player.worldObj,pos.blockX,pos.blockY,pos.blockZ,player);
      if (stack != null) {
        for (        ItemStack stack2 : SteamcraftRegistry.bookRecipes.keySet()) {
          if (stack2.getItem() == stack.getItem() && stack2.getItemDamage() == stack.getItemDamage()) {
            GL11.glPushMatrix();
            int x=event.resolution.getScaledWidth() / 2 - 8;
            int y=event.resolution.getScaledHeight() / 2 - 8;
            int color=0x6600FF00;
            RenderItem.getInstance().renderItemIntoGUI(mc.fontRenderer,mc.renderEngine,new ItemStack(SteamcraftItems.book),x,y);
            GL11.glDisable(GL11.GL_LIGHTING);
            mc.fontRenderer.drawStringWithShadow(""String_Node_Str"",x + 15,y + 13,0xC6C6C6);
            GL11.glPopMatrix();
            GL11.glEnable(GL11.GL_BLEND);
          }
        }
      }
    }
  }
}","@SideOnly(Side.CLIENT) @SubscribeEvent public void onDrawScreen(RenderGameOverlayEvent.Post event){
  if (event.type == ElementType.ALL) {
    Minecraft mc=Minecraft.getMinecraft();
    EntityPlayer player=mc.thePlayer;
    Item equipped=player.getCurrentEquippedItem() != null ? player.getCurrentEquippedItem().getItem() : null;
    MovingObjectPosition pos=mc.objectMouseOver;
    if (pos != null && mc.thePlayer.getCurrentEquippedItem() != null && mc.thePlayer.getCurrentEquippedItem().getItem() instanceof IPipeWrench && ((IPipeWrench)equipped).canWrench(player,pos.blockX,pos.blockY,pos.blockZ)) {
      TileEntity te=mc.theWorld.getTileEntity(pos.blockX,pos.blockY,pos.blockZ);
      if (te instanceof IWrenchDisplay) {
        ((IWrenchDisplay)te).displayWrench(event);
      }
    }
    if (CrossMod.BOTANIA) {
      if (pos != null && player.getEquipmentInSlot(4) != null && player.getEquipmentInSlot(4).getItem() instanceof ItemExosuitArmor && (player.getHeldItem() == null || player.getHeldItem().getItem() != BotaniaIntegration.twigWand())) {
        ItemExosuitArmor chest=(ItemExosuitArmor)player.getEquipmentInSlot(3).getItem();
        if (chest.hasUpgrade(player.getEquipmentInSlot(3),BotaniaIntegration.floralLaurel)) {
          Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
          BotaniaIntegration.displayThings(pos,event);
        }
      }
    }
    if (pos != null && mc.thePlayer.getCurrentEquippedItem() != null && mc.thePlayer.getCurrentEquippedItem().getItem() == SteamcraftItems.book) {
      Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
      ItemStack stack=block.getPickBlock(pos,player.worldObj,pos.blockX,pos.blockY,pos.blockZ);
      if (stack != null) {
        for (        ItemStack stack2 : SteamcraftRegistry.bookRecipes.keySet()) {
          if (stack2.getItem() == stack.getItem() && stack2.getItemDamage() == stack.getItemDamage()) {
            GL11.glPushMatrix();
            int x=event.resolution.getScaledWidth() / 2 - 8;
            int y=event.resolution.getScaledHeight() / 2 - 8;
            int color=0x6600FF00;
            RenderItem.getInstance().renderItemIntoGUI(mc.fontRenderer,mc.renderEngine,new ItemStack(SteamcraftItems.book),x,y);
            GL11.glDisable(GL11.GL_LIGHTING);
            mc.fontRenderer.drawStringWithShadow(""String_Node_Str"",x + 15,y + 13,0xC6C6C6);
            GL11.glPopMatrix();
            GL11.glEnable(GL11.GL_BLEND);
          }
        }
      }
    }
  }
}",0.9986008394963022
22452,"@SideOnly(Side.CLIENT) public static void extendRange(Entity entity,float amount){
  Minecraft mc=Minecraft.getMinecraft();
  if (!(mc.playerController instanceof IExtendedPlayerController)) {
    GameType type=ReflectionHelper.getPrivateValue(PlayerControllerMP.class,mc.playerController,CURRENT_GAME_TYPE);
    NetHandlerPlayClient net=ReflectionHelper.getPrivateValue(PlayerControllerMP.class,mc.playerController,NET_CLIENT_HANDLER);
    SteamcraftPlayerController controller=new SteamcraftPlayerController(mc,net);
    controller.setGameType(type);
    mc.playerController=controller;
  }
  ((IExtendedPlayerController)mc.playerController).setReachDistanceExtension(((IExtendedPlayerController)mc.playerController).getReachDistanceExtension() + amount);
}","@SideOnly(Side.CLIENT) public static void extendRange(Entity entity,float amount){
}",0.199288256227758
22453,"public static Multimap addModifiers(Multimap map,ItemStack stack,int armorType){
  if ((((ItemExosuitArmor)stack.getItem()).hasPlates(stack) && UtilPlates.getPlate(stack.stackTagCompound.getString(""String_Node_Str"")).getIdentifier() == ""String_Node_Str"")) {
    int hp=1;
switch (armorType) {
case 0:
      hp=2;
    break;
case 1:
  hp=4;
break;
case 2:
hp=2;
break;
case 4:
hp=2;
}
map.put(SharedMonsterAttributes.maxHealth.getAttributeUnlocalizedName(),new AttributeModifier(new UUID(171328,armorType),""String_Node_Str"" + armorType,hp,0));
}
return map;
}","public static Multimap addModifiers(Multimap map,ItemStack stack,int armorType){
}",0.25625
22454,"@SideOnly(Side.CLIENT) public static void displayThings(MovingObjectPosition pos,RenderGameOverlayEvent.Post event){
  Minecraft mc=Minecraft.getMinecraft();
  Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
  if (block instanceof IWandHUD)   ((IWandHUD)block).renderHUD(mc,event.resolution,mc.theWorld,pos.blockX,pos.blockY,pos.blockZ);
}","@SideOnly(Side.CLIENT) public static void displayThings(MovingObjectPosition pos,RenderGameOverlayEvent.Post event){
  Minecraft mc=Minecraft.getMinecraft();
  Block block=mc.theWorld.getBlock(pos.blockX,pos.blockY,pos.blockZ);
  if (block instanceof IWandHUD) {
    ((IWandHUD)block).renderHUD(mc,event.resolution,mc.theWorld,pos.blockX,pos.blockY,pos.blockZ);
  }
}",0.9889807162534436
22455,"private void spawnItems(int x,int y,int z){
  if (smooshedStack != null) {
    for (    ItemStack stack : smooshedStack) {
      ItemStack output=REGISTRY.getOutput(stack);
      boolean isSmashableOre=output != null;
      if (Block.getBlockFromItem(stack.getItem()) == Blocks.cobblestone && !this.noSmashDrops) {
        output=new ItemStack(Blocks.gravel);
      }
 else       if (Block.getBlockFromItem(stack.getItem()) == Blocks.gravel && !this.noSmashDrops) {
        output=new ItemStack(Blocks.sand);
      }
      if (isSmashableOre && !this.noSmashDrops) {
        if (worldObj.rand.nextInt(Config.chance) == 0)         output.stackSize*=2;
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,output);
        this.worldObj.spawnEntityInWorld(entityItem);
        this.smooshedStack=null;
      }
 else       if (output != null) {
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,output);
        this.worldObj.spawnEntityInWorld(entityItem);
        this.smooshedStack=null;
      }
    }
  }
}","private void spawnItems(int x,int y,int z){
  if (smooshedStack != null) {
    for (    ItemStack stack : smooshedStack) {
      ItemStack output=REGISTRY.getOutput(stack);
      boolean isSmashableOre=output != null;
      if (Block.getBlockFromItem(stack.getItem()) == Blocks.cobblestone && !this.noSmashDrops) {
        output=new ItemStack(Blocks.gravel);
      }
 else       if (Block.getBlockFromItem(stack.getItem()) == Blocks.gravel && !this.noSmashDrops) {
        output=new ItemStack(Blocks.sand);
      }
      if (isSmashableOre && !this.noSmashDrops) {
        if (worldObj.rand.nextInt(Config.chance) == 0)         output.stackSize*=2;
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,output);
        this.worldObj.spawnEntityInWorld(entityItem);
        this.smooshedStack=null;
      }
 else       if (output != null) {
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,output);
        this.worldObj.spawnEntityInWorld(entityItem);
        this.smooshedStack=null;
      }
 else       if (output == null) {
        output=stack;
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,output);
        this.worldObj.spawnEntityInWorld(entityItem);
      }
    }
  }
}",0.909936575052854
22456,"@EventHandler public void preInit(FMLPreInitializationEvent event){
  Config.load(event);
  tab=new SCTab(CreativeTabs.getNextID(),""String_Node_Str"",false).setBackgroundImageName(""String_Node_Str"");
  tabTools=new SCTab(CreativeTabs.getNextID(),""String_Node_Str"",true);
  upgrade=EnumHelper.addRarity(""String_Node_Str"",EnumChatFormatting.RED,""String_Node_Str"");
  SteamcraftBlocks.registerBlocks();
  SteamcraftItems.registerItems();
  GameRegistry.registerWorldGenerator(new SteamcraftOreGen(),1);
  int id=Config.villagerId;
  VillagerRegistry.instance().registerVillagerId(id);
  VillagerRegistry.instance().registerVillageTradeHandler(id,new SteampunkVillagerTradeHandler());
  VillagerRegistry.instance().registerVillageCreationHandler(new SteamWorkshopCreationHandler());
  MapGenStructureIO.func_143031_a(ComponentSteamWorkshop.class,""String_Node_Str"");
  EntityRegistry.registerModEntity(EntityFloatingItem.class,""String_Node_Str"",0,Steamcraft.instance,64,20,true);
  EntityRegistry.registerModEntity(EntityMortarItem.class,""String_Node_Str"",1,Steamcraft.instance,64,20,true);
  EntityRegistry.registerModEntity(EntityCanisterItem.class,""String_Node_Str"",2,Steamcraft.instance,64,20,true);
  EntityRegistry.registerModEntity(EntityRocket.class,""String_Node_Str"",3,Steamcraft.instance,64,20,true);
  GameRegistry.registerTileEntity(TileEntityCrucible.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityMold.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityBoiler.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamPipe.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityValvePipe.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamPiston.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamHeater.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityEngineeringTable.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamCharger.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamTank.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamGauge.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityRuptureDisc.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityCreativeTank.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamHammer.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityItemMortar.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySteamFurnace.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityPump.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityThumper.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntitySmasher.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityDummyBlock.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityFlashBoiler.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityFan.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityVacuum.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityFluidSteamConverter.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityWhistle.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityChargingPad.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityCustomCraftingTable.class,""String_Node_Str"");
  GameRegistry.registerTileEntity(TileEntityCustomFurnace.class,""String_Node_Str"");
}","@EventHandler public void preInit(FMLPreInitializationEvent event){
  Config.load(event);
  tab=new SCTab(CreativeTabs.getNextID(),""String_Node_Str"",false).setBackgroundImageName(""String_Node_Str"");
  tabTools=new SCTab(CreativeTabs.getNextID(),""String_Node_Str"",true);
  upgrade=EnumHelper.addRarity(""String_Node_Str"",EnumChatFormatting.RED,""String_Node_Str"");
  SteamcraftBlocks.registerBlocks();
  SteamcraftItems.registerItems();
  GameRegistry.registerWorldGenerator(new SteamcraftOreGen(),1);
  int id=Config.villagerId;
  VillagerRegistry.instance().registerVillagerId(id);
  VillagerRegistry.instance().registerVillageTradeHandler(id,new SteampunkVillagerTradeHandler());
  VillagerRegistry.instance().registerVillageCreationHandler(new SteamWorkshopCreationHandler());
  MapGenStructureIO.func_143031_a(ComponentSteamWorkshop.class,""String_Node_Str"");
  EntityRegistry.registerModEntity(EntityFloatingItem.class,""String_Node_Str"",0,Steamcraft.instance,64,20,true);
  EntityRegistry.registerModEntity(EntityMortarItem.class,""String_Node_Str"",1,Steamcraft.instance,64,20,true);
  EntityRegistry.registerModEntity(EntityCanisterItem.class,""String_Node_Str"",2,Steamcraft.instance,64,20,true);
  EntityRegistry.registerModEntity(EntityRocket.class,""String_Node_Str"",3,Steamcraft.instance,64,20,true);
  registerTileEntity(TileEntityCrucible.class,""String_Node_Str"");
  registerTileEntity(TileEntityMold.class,""String_Node_Str"");
  registerTileEntity(TileEntityBoiler.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamPipe.class,""String_Node_Str"");
  registerTileEntity(TileEntityValvePipe.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamPiston.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamHeater.class,""String_Node_Str"");
  registerTileEntity(TileEntityEngineeringTable.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamCharger.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamTank.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamGauge.class,""String_Node_Str"");
  registerTileEntity(TileEntityRuptureDisc.class,""String_Node_Str"");
  registerTileEntity(TileEntityCreativeTank.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamHammer.class,""String_Node_Str"");
  registerTileEntity(TileEntityItemMortar.class,""String_Node_Str"");
  registerTileEntity(TileEntitySteamFurnace.class,""String_Node_Str"");
  registerTileEntity(TileEntityPump.class,""String_Node_Str"");
  registerTileEntity(TileEntityThumper.class,""String_Node_Str"");
  registerTileEntity(TileEntitySmasher.class,""String_Node_Str"");
  registerTileEntity(TileEntityDummyBlock.class,""String_Node_Str"");
  registerTileEntity(TileEntityFlashBoiler.class,""String_Node_Str"");
  registerTileEntity(TileEntityFan.class,""String_Node_Str"");
  registerTileEntity(TileEntityVacuum.class,""String_Node_Str"");
  registerTileEntity(TileEntityFluidSteamConverter.class,""String_Node_Str"");
  registerTileEntity(TileEntityWhistle.class,""String_Node_Str"");
  registerTileEntity(TileEntityChargingPad.class,""String_Node_Str"");
  registerTileEntity(TileEntityCustomCraftingTable.class,""String_Node_Str"");
  registerTileEntity(TileEntityCustomFurnace.class,""String_Node_Str"");
}",0.916519174041298
22457,"@SideOnly(Side.CLIENT) public MovingObjectPosition collisionRayTrace(World world,int x,int y,int z,Vec3 start,Vec3 end){
  EntityPlayer player=Minecraft.getMinecraft().thePlayer;
  TileEntity tile=world.getTileEntity(x,y,z);
  if ((tile == null) || (!(tile instanceof TileEntitySteamPipe)) || player.isSneaking()|| !((player.getCurrentEquippedItem() != null) && (player.getCurrentEquippedItem().getItem() instanceof ItemWrench))) {
    return super.collisionRayTrace(world,x,y,z,start,end);
  }
  List<IndexedCuboid6> cuboids=new LinkedList();
  ((TileEntitySteamPipe)tile).addTraceableCuboids(cuboids);
  MovingObjectPosition mop=this.rayTracer.rayTraceCuboids(new Vector3(start),new Vector3(end),cuboids,new BlockCoord(x,y,z),this);
  return mop;
}","@SideOnly(Side.CLIENT) public MovingObjectPosition collisionRayTrace(World world,int x,int y,int z,Vec3 start,Vec3 end){
  EntityPlayer player=Minecraft.getMinecraft().thePlayer;
  TileEntity tile=world.getTileEntity(x,y,z);
  if ((tile == null) || (!(tile instanceof TileEntitySteamPipe)) || player == null || player.isSneaking() || !((player.getCurrentEquippedItem() != null) && (player.getCurrentEquippedItem().getItem() instanceof ItemWrench))) {
    return super.collisionRayTrace(world,x,y,z,start,end);
  }
  List<IndexedCuboid6> cuboids=new LinkedList();
  ((TileEntitySteamPipe)tile).addTraceableCuboids(cuboids);
  MovingObjectPosition mop=this.rayTracer.rayTraceCuboids(new Vector3(start),new Vector3(end),cuboids,new BlockCoord(x,y,z),this);
  return mop;
}",0.9703752468729429
22458,"/** 
 * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
 */
@Override public ItemStack onItemRightClick(ItemStack par1ItemStack,World par2World,EntityPlayer par3EntityPlayer){
  NBTTagCompound nbt=par1ItemStack.getTagCompound();
  boolean crouched=par3EntityPlayer.isSneaking();
  if (!crouched) {
    if (!par1ItemStack.hasTagCompound()) {
      par1ItemStack.setTagCompound(new NBTTagCompound());
      nbt=par1ItemStack.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    if (nbt.getInteger(""String_Node_Str"") > 0 || par3EntityPlayer.capabilities.isCreativeMode) {
      if (!par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"") || par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"") == 0) {
        float enhancementAccuracy=0.0F;
        float enhancementExplosionSize=0.0F;
        int enhancementDelay=0;
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            enhancementAccuracy=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getAccuracyChange(this);
            enhancementExplosionSize=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getExplosionChange(this);
            enhancementDelay=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getFireDelayChange(par1ItemStack);
          }
        }
        float var7=1.0F;
        if (var7 < 0.1D) {
          return par1ItemStack;
        }
        if (var7 > 1.0F) {
          var7=1.0F;
        }
        EntityRocket var8=new EntityRocket(par2World,par3EntityPlayer,((1.0F + accuracy + enhancementAccuracy) - var7),this.explosionSize + enhancementExplosionSize);
        int selectedRocketType=0;
        if (par1ItemStack.hasTagCompound()) {
          if (par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
            selectedRocketType=par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"");
          }
        }
        var8=SteamcraftRegistry.rockets.get(selectedRocketType).changeBullet(var8);
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            var8=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).changeBullet(var8);
          }
        }
        par1ItemStack.damageItem(1,par3EntityPlayer);
        par2World.playSoundAtEntity(par3EntityPlayer,""String_Node_Str"",(1.0F * (2F / 5F)) * (UtilEnhancements.getEnhancementFromItem(par1ItemStack) != null && UtilEnhancements.getEnhancementFromItem(par1ItemStack).getID() == ""String_Node_Str"" ? 0.4F : 1.0F),1.0F / (itemRand.nextFloat() * 0.4F + 1.2F) + var7 * 0.5F);
        if (!par2World.isRemote) {
          par2World.spawnEntityInWorld(var8);
        }
        nbt.setInteger(""String_Node_Str"",nbt.getInteger(""String_Node_Str"") - 1);
        if (par2World.isRemote && !par3EntityPlayer.capabilities.isCreativeMode) {
          boolean crouching=par3EntityPlayer.isSneaking();
        }
        if (!(SteamcraftEventHandler.isJumping(par3EntityPlayer) && !par3EntityPlayer.capabilities.isFlying && UtilEnhancements.hasEnhancement(par1ItemStack)&& UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof ItemEnhancementAirStrike)) {
          par1ItemStack.stackTagCompound.setInteger(""String_Node_Str"",this.timeBetweenFire + enhancementDelay);
        }
      }
    }
 else {
      NBTTagCompound nbtt=par1ItemStack.getTagCompound();
      if (par3EntityPlayer.capabilities.isCreativeMode) {
        int enhancementShells=0;
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            enhancementShells=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getClipSizeChange(this);
          }
        }
        nbtt.setInteger(""String_Node_Str"",1);
        nbtt.setInteger(""String_Node_Str"",this.shellCount + enhancementShells);
      }
      par3EntityPlayer.setItemInUse(par1ItemStack,this.getMaxItemUseDuration(par1ItemStack));
    }
  }
 else {
    if (!par1ItemStack.hasTagCompound()) {
      par1ItemStack.setTagCompound(new NBTTagCompound());
      nbt=par1ItemStack.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    int selectedRocketType=0;
    if (par1ItemStack.hasTagCompound()) {
      if (par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
        selectedRocketType=par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"");
      }
    }
    int prevRocketType=selectedRocketType;
    selectedRocketType=(selectedRocketType + 1) % SteamcraftRegistry.rockets.size();
    nbt.setInteger(""String_Node_Str"",selectedRocketType);
    if (selectedRocketType != prevRocketType && par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"") > 0) {
      ItemStack stack=new ItemStack(((Item)SteamcraftRegistry.rockets.get(prevRocketType)),nbt.getInteger(""String_Node_Str""),0);
      if (!par3EntityPlayer.worldObj.isRemote) {
        EntityItem entityItem=new EntityItem(par3EntityPlayer.worldObj,par3EntityPlayer.posX,par3EntityPlayer.posY,par3EntityPlayer.posZ,stack);
        par3EntityPlayer.worldObj.spawnEntityInWorld(entityItem);
      }
      nbt.setInteger(""String_Node_Str"",0);
    }
  }
  return par1ItemStack;
}","/** 
 * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
 */
@Override public ItemStack onItemRightClick(ItemStack par1ItemStack,World par2World,EntityPlayer par3EntityPlayer){
  System.out.println(""String_Node_Str"" + par3EntityPlayer.worldObj.isRemote);
  NBTTagCompound nbt=par1ItemStack.getTagCompound();
  boolean crouched=par3EntityPlayer.isSneaking();
  if (!crouched) {
    if (!par1ItemStack.hasTagCompound()) {
      par1ItemStack.setTagCompound(new NBTTagCompound());
      nbt=par1ItemStack.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    System.out.println(""String_Node_Str"" + par3EntityPlayer.worldObj.isRemote);
    if (nbt.getInteger(""String_Node_Str"") > 0 || par3EntityPlayer.capabilities.isCreativeMode) {
      System.out.println(""String_Node_Str"" + par3EntityPlayer.worldObj.isRemote);
      if (!par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"") || par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"") == 0) {
        System.out.println(""String_Node_Str"" + par3EntityPlayer.worldObj.isRemote);
        float enhancementAccuracy=0.0F;
        float enhancementExplosionSize=0.0F;
        int enhancementDelay=0;
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            enhancementAccuracy=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getAccuracyChange(this);
            enhancementExplosionSize=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getExplosionChange(this);
            enhancementDelay=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getFireDelayChange(par1ItemStack);
          }
        }
        float var7=1.0F;
        if (var7 < 0.1D) {
          return par1ItemStack;
        }
        if (var7 > 1.0F) {
          var7=1.0F;
        }
        EntityRocket var8=new EntityRocket(par2World,par3EntityPlayer,((1.0F + accuracy + enhancementAccuracy) - var7),this.explosionSize + enhancementExplosionSize);
        int selectedRocketType=0;
        if (par1ItemStack.hasTagCompound()) {
          if (par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
            selectedRocketType=par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"");
          }
        }
        var8=SteamcraftRegistry.rockets.get(selectedRocketType).changeBullet(var8);
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            var8=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).changeBullet(var8);
          }
        }
        par1ItemStack.damageItem(1,par3EntityPlayer);
        par2World.playSoundAtEntity(par3EntityPlayer,""String_Node_Str"",(1.0F * (2F / 5F)) * (UtilEnhancements.getEnhancementFromItem(par1ItemStack) != null && UtilEnhancements.getEnhancementFromItem(par1ItemStack).getID() == ""String_Node_Str"" ? 0.4F : 1.0F),1.0F / (itemRand.nextFloat() * 0.4F + 1.2F) + var7 * 0.5F);
        if (!par2World.isRemote) {
          par2World.spawnEntityInWorld(var8);
        }
        nbt.setInteger(""String_Node_Str"",nbt.getInteger(""String_Node_Str"") - 1);
        if (par2World.isRemote && !par3EntityPlayer.capabilities.isCreativeMode) {
          boolean crouching=par3EntityPlayer.isSneaking();
        }
        if (!(SteamcraftEventHandler.isJumping(par3EntityPlayer) && !par3EntityPlayer.capabilities.isFlying && UtilEnhancements.hasEnhancement(par1ItemStack)&& UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof ItemEnhancementAirStrike)) {
          par1ItemStack.stackTagCompound.setInteger(""String_Node_Str"",this.timeBetweenFire + enhancementDelay);
        }
      }
    }
 else {
      NBTTagCompound nbtt=par1ItemStack.getTagCompound();
      if (par3EntityPlayer.capabilities.isCreativeMode) {
        int enhancementShells=0;
        if (UtilEnhancements.hasEnhancement(par1ItemStack)) {
          if (UtilEnhancements.getEnhancementFromItem(par1ItemStack) instanceof IEnhancementRocketLauncher) {
            enhancementShells=((IEnhancementRocketLauncher)UtilEnhancements.getEnhancementFromItem(par1ItemStack)).getClipSizeChange(this);
          }
        }
        nbtt.setInteger(""String_Node_Str"",1);
        nbtt.setInteger(""String_Node_Str"",this.shellCount + enhancementShells);
      }
      par3EntityPlayer.setItemInUse(par1ItemStack,this.getMaxItemUseDuration(par1ItemStack));
    }
  }
 else {
    if (!par1ItemStack.hasTagCompound()) {
      par1ItemStack.setTagCompound(new NBTTagCompound());
      nbt=par1ItemStack.getTagCompound();
      nbt.setInteger(""String_Node_Str"",0);
      nbt.setBoolean(""String_Node_Str"",false);
      nbt.setInteger(""String_Node_Str"",0);
    }
    int selectedRocketType=0;
    if (par1ItemStack.hasTagCompound()) {
      if (par1ItemStack.stackTagCompound.hasKey(""String_Node_Str"")) {
        selectedRocketType=par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"");
      }
    }
    int prevRocketType=selectedRocketType;
    selectedRocketType=(selectedRocketType + 1) % SteamcraftRegistry.rockets.size();
    nbt.setInteger(""String_Node_Str"",selectedRocketType);
    if (selectedRocketType != prevRocketType && par1ItemStack.stackTagCompound.getInteger(""String_Node_Str"") > 0) {
      ItemStack stack=new ItemStack(((Item)SteamcraftRegistry.rockets.get(prevRocketType)),nbt.getInteger(""String_Node_Str""),0);
      if (!par3EntityPlayer.worldObj.isRemote) {
        EntityItem entityItem=new EntityItem(par3EntityPlayer.worldObj,par3EntityPlayer.posX,par3EntityPlayer.posY,par3EntityPlayer.posZ,stack);
        par3EntityPlayer.worldObj.spawnEntityInWorld(entityItem);
      }
      nbt.setInteger(""String_Node_Str"",0);
    }
  }
  return par1ItemStack;
}",0.9627812552867536
22459,"@Override @SideOnly(Side.CLIENT) public void onUpdate(ItemStack stack,World world,Entity entity,int par4,boolean par5){
  super.onUpdate(stack,world,entity,par4,par5);
  if (stack.hasTagCompound() && (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).getItemInUse() == stack))) {
    if (stack.stackTagCompound.hasKey(""String_Node_Str"")) {
      int delay=stack.stackTagCompound.getInteger(""String_Node_Str"");
      if (delay > 0) {
        delay--;
      }
      stack.stackTagCompound.setInteger(""String_Node_Str"",delay);
    }
  }
}","@Override public void onUpdate(ItemStack stack,World world,Entity entity,int par4,boolean par5){
  super.onUpdate(stack,world,entity,par4,par5);
  if (stack.hasTagCompound()) {
    if (stack.stackTagCompound.hasKey(""String_Node_Str"")) {
      int delay=stack.stackTagCompound.getInteger(""String_Node_Str"");
      if (delay > 0) {
        delay--;
      }
      stack.stackTagCompound.setInteger(""String_Node_Str"",delay);
    }
  }
}",0.5556690500510725
22460,"public static void registerSteamPower(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.boiler)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (Config.enableFlashBoiler) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.flashBoiler)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pipe)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  if (Config.enableRuptureDisc) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.ruptureDisc)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableGauge) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.gauge)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.tank)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (Config.enableCharger) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.charger)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHeater) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.heater)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableMortar && Config.enableAstrolabe) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.itemMortar)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  if (Config.enableHammer) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.hammer)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enablePump) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pump)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSmasher) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.smasher)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableThumper) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.thumper)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableFan) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.fan)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    if (Config.enableVacuum) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.vacuum)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
}","public static void registerSteamPower(){
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.boiler)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (Config.enableFlashBoiler) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.flashBoiler)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pipe)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  if (Config.enableRuptureDisc) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.ruptureDisc)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHorn) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.horn)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableGauge) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.gauge)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.tank)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (Config.enableCharger) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.charger)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableHeater) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.heater)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableMortar && Config.enableAstrolabe) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.itemMortar)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  SteamcraftRegistry.addCategory(""String_Node_Str"");
  if (Config.enableHammer) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.hammer)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enablePump) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.pump)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableSmasher) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.smasher)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableThumper) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.thumper)),new BookPageText(""String_Node_Str"",""String_Node_Str""),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  if (Config.enableFan) {
    SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.fan)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    if (Config.enableVacuum) {
      SteamcraftRegistry.addResearch(""String_Node_Str"",""String_Node_Str"",new BookPageItem(""String_Node_Str"",""String_Node_Str"",new ItemStack(SteamcraftBlocks.vacuum)),new BookPageCrafting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    }
  }
}",0.9717089466541392
22461,"public static void registerMisc(){
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapelessOreRecipe(new ItemStack(SteamcraftItems.book),Items.book,""String_Node_Str"",""String_Node_Str""));
  if (Config.enableSurvivalist) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ItemStack(SteamcraftItems.survivalist),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',Items.leather,'s',Items.string,'b',Items.brick,'w',Items.stick);
  }
  if (Config.enableAstrolabe) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.astrolabe),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'r',Items.redstone));
  }
  if (Config.enableEngineering) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftBlocks.engineering),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'z',""String_Node_Str""));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftBlocks.engineering),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',Blocks.cobblestone,'z',""String_Node_Str""));
  }
  if (Config.enableSpyglass) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.spyglass),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',""String_Node_Str"",'g',Blocks.glass_pane));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.spyglass),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',""String_Node_Str"",'g',Blocks.glass_pane));
  }
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'p',Blocks.piston,'i',SteamcraftBlocks.pipe));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'p',Blocks.piston,'i',SteamcraftBlocks.pipe));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,5),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'n',""String_Node_Str""));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,5),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'n',""String_Node_Str""));
}","public static void registerMisc(){
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapelessOreRecipe(new ItemStack(SteamcraftItems.book),Items.book,""String_Node_Str"",""String_Node_Str""));
  if (Config.enableSurvivalist) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ItemStack(SteamcraftItems.survivalist),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',Items.leather,'s',Items.string,'b',Items.brick,'w',Items.stick);
  }
  if (Config.enableAstrolabe) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.astrolabe),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'r',Items.redstone));
  }
  if (Config.enableEngineering) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftBlocks.engineering),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'z',""String_Node_Str""));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftBlocks.engineering),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',Blocks.cobblestone,'z',""String_Node_Str""));
  }
  if (Config.enableSpyglass) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.spyglass),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',""String_Node_Str"",'g',Blocks.glass_pane));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.spyglass),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'b',""String_Node_Str"",'g',Blocks.glass_pane));
  }
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'p',Blocks.piston,'i',SteamcraftBlocks.pipe));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'p',Blocks.piston,'i',SteamcraftBlocks.pipe));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,5),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'n',""String_Node_Str""));
  BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.steamcraftCrafting,1,5),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'x',""String_Node_Str"",'n',""String_Node_Str""));
  if (Config.enableWrench) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.wrench,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',""String_Node_Str"",'b',""String_Node_Str""));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftItems.wrench,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'i',""String_Node_Str"",'b',""String_Node_Str""));
  }
  if (Config.enableHorn) {
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftBlocks.horn,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'n',""String_Node_Str"",'b',""String_Node_Str"",'p',new ItemStack(SteamcraftBlocks.pipe,1,0)));
    BookRecipeRegistry.addRecipe(""String_Node_Str"",new ShapedOreRecipe(new ItemStack(SteamcraftBlocks.horn,1,0),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'n',""String_Node_Str"",'b',""String_Node_Str"",'p',new ItemStack(SteamcraftBlocks.pipe,1,0)));
  }
}",0.8357771260997068
22462,"protected synchronized void tick(){
  if (Config.wimpMode) {
    if (this.getPressure() > 1.09F) {
      this.steam=(int)Math.floor((double)this.capacity * 1.09D);
    }
  }
 else {
    if (this.transporters != null && this.transporters.keySet() != null) {
      if (this.getPressure() > 1.2F) {
        for (        Coord4 coords : transporters.keySet()) {
          System.out.println(""String_Node_Str"");
          ISteamTransporter trans=transporters.get(coords);
          if (trans == null) {
            transporters.remove(coords);
          }
 else           if (!trans.getWorld().isRemote && shouldExplode(oneInX(this.getPressure(),trans.getPressureResistance()))) {
            trans.explode();
            Coord4 c=trans.getCoords();
            trans.getWorld().createExplosion(null,c.x + 0.5F,c.y + 0.5F,c.z + 0.5F,4.0F,true);
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"" + this.name);
    }
  }
}","protected synchronized void tick(){
  if (Config.wimpMode) {
    if (this.getPressure() > 1.09F) {
      this.steam=(int)Math.floor((double)this.capacity * 1.09D);
    }
  }
 else {
    if (this.transporters != null && this.transporters.keySet() != null) {
      if (this.getPressure() > 1.02F) {
        for (        Coord4 coords : transporters.keySet()) {
          ISteamTransporter trans=transporters.get(coords);
          if (trans == null || ((TileEntity)trans).isInvalid()) {
            transporters.remove(coords);
          }
 else           if (!trans.getWorld().isRemote && shouldExplode(oneInX(this.getPressure(),trans.getPressureResistance()))) {
            trans.explode();
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"" + this.name);
    }
  }
}",0.4681093394077448
22463,"@Override public void explode(){
  UtilSteamTransport.preExplosion(worldObj,xCoord,yCoord,zCoord,this.distributionDirections);
}","@Override public void explode(){
  this.network.decrSteam((int)(this.network.getSteam() * 0.1F));
  this.network.split(this,true);
  this.worldObj.createExplosion(null,xCoord + 0.5F,yCoord + 0.5F,zCoord + 0.5F,4.0F,true);
}",0.4216524216524216
22464,"@Override public void explode(){
  if (worldObj.getBlockMetadata(xCoord,yCoord,zCoord) > 4) {
    if (!isInCluster(xCoord - 1,yCoord,zCoord)) {
      UtilSteamTransport.preExplosion(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.WEST});
    }
    if (!isInCluster(xCoord + 1,yCoord,zCoord)) {
      UtilSteamTransport.preExplosion(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.EAST});
    }
    if (!isInCluster(xCoord,yCoord,zCoord - 1)) {
      UtilSteamTransport.preExplosion(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.NORTH});
    }
    if (!isInCluster(xCoord,yCoord,zCoord + 1)) {
      UtilSteamTransport.preExplosion(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.SOUTH});
    }
    UtilSteamTransport.preExplosion(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.UP});
  }
  TileEntityFlashBoiler boiler=(TileEntityFlashBoiler)worldObj.getTileEntity(xCoord,yCoord,zCoord);
  int[][] cluster=(boiler.getClusterCoords(boiler.getValidClusterFromMetadata()));
  for (int pos=0; pos < cluster.length; pos++) {
    int x=cluster[pos][0], y=cluster[pos][1], z=cluster[pos][2];
    if (!(x == xCoord && y == yCoord && z == zCoord)) {
      TileEntityFlashBoiler otherBoiler=(TileEntityFlashBoiler)worldObj.getTileEntity(x,y,z);
      if (otherBoiler != null)       otherBoiler.secondaryExplosion();
    }
  }
}","@Override public void explode(){
  TileEntityFlashBoiler boiler=(TileEntityFlashBoiler)worldObj.getTileEntity(xCoord,yCoord,zCoord);
  if (boiler != null) {
    int[][] cluster=(boiler.getClusterCoords(boiler.getValidClusterFromMetadata()));
    for (int pos=0; pos < cluster.length; pos++) {
      int x=cluster[pos][0], y=cluster[pos][1], z=cluster[pos][2];
      if (!(x == xCoord && y == yCoord && z == zCoord)) {
        TileEntityFlashBoiler otherBoiler=(TileEntityFlashBoiler)worldObj.getTileEntity(x,y,z);
        if (otherBoiler != null)         otherBoiler.secondaryExplosion();
      }
    }
  }
  super.explode();
}",0.1728880157170923
22465,"public void updateEntity(){
  super.superUpdateOnly();
  if (this.shouldExplode) {
    worldObj.createExplosion(null,xCoord + 0.5F,yCoord + 0.5F,zCoord + 0.5F,4.0F,true);
    return;
  }
  if (waitOneTick)   waitOneTick=false;
 else {
    if (!worldObj.isRemote && worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
      if (this.getStackInSlot(1) != null) {
        if (this.getStackInSlot(1).getItem() == Items.water_bucket || (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)) != null && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)).getFluid() == FluidRegistry.WATER)) {
          if (canDrainItem(this.getStackInSlot(1))) {
            if (this.getStackInSlot(1).getItem() == Items.water_bucket) {
              this.setInventorySlotContents(1,new ItemStack(Items.bucket));
              this.myTank.fill(new FluidStack(FluidRegistry.WATER,1000),true);
            }
            if (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem) {
              int maxDrain=this.getTankInfo(ForgeDirection.UP)[0].capacity - this.getTankInfo(ForgeDirection.UP)[0].fluid.amount;
              this.myTank.fill(new FluidStack(FluidRegistry.WATER,((IFluidContainerItem)this.getStackInSlot(1).getItem()).drain(this.getStackInSlot(1),maxDrain,true).amount),true);
            }
          }
        }
      }
      boolean flag=this.furnaceBurnTime > 0;
      boolean flag1=false;
      int maxThisTick=10;
      if (this.furnaceBurnTime > 0) {
        maxThisTick=Math.min(furnaceBurnTime,10);
        this.furnaceBurnTime-=maxThisTick;
      }
      if (!this.worldObj.isRemote) {
        if (this.furnaceBurnTime == 0 && this.canSmelt()) {
          this.currentItemBurnTime=this.furnaceBurnTime=getItemBurnTime(this.furnaceItemStacks[0]);
          if (this.furnaceBurnTime > 0) {
            flag1=true;
            if (this.furnaceItemStacks[0] != null) {
              --this.furnaceItemStacks[0].stackSize;
              if (this.furnaceItemStacks[0].stackSize == 0) {
                this.furnaceItemStacks[0]=furnaceItemStacks[0].getItem().getContainerItem(furnaceItemStacks[0]);
              }
            }
          }
        }
        if (!this.isBurning() && this.heat > 0) {
          this.heat-=Math.min(this.heat,10);
        }
        if (this.isBurning() && this.heat < 1600) {
          this.heat++;
        }
        if (this.isBurning() && this.canSmelt()) {
          ++this.furnaceCookTime;
          if (this.furnaceCookTime > 0) {
            int i=0;
            int maxSteamThisTick=(int)(((float)maxThisTick) * 0.7F + (maxThisTick * 0.3F * ((float)this.heat / 1600.0F)));
            while (i < maxSteamThisTick && this.isBurning() && this.canSmelt()) {
              this.insertSteam(10);
              this.myTank.drain(2,true);
              i++;
            }
            this.furnaceCookTime=0;
            flag1=true;
          }
        }
 else {
          this.furnaceCookTime=0;
        }
        if (flag != this.furnaceBurnTime > 0) {
          flag1=true;
        }
      }
      if (this.isBurning() != this.wasBurning) {
        this.wasBurning=this.isBurning();
        this.burning=this.isBurning();
        this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
      }
    }
  }
  if (!this.worldObj.isRemote) {
  }
}","public void updateEntity(){
  super.superUpdateOnly();
  if (this.shouldExplode) {
    this.getNetwork().split(this,true);
    worldObj.createExplosion(null,xCoord + 0.5F,yCoord + 0.5F,zCoord + 0.5F,4.0F,true);
    return;
  }
  if (waitOneTick)   waitOneTick=false;
 else {
    if (!worldObj.isRemote && worldObj.getBlockMetadata(xCoord,yCoord,zCoord) == 1) {
      if (this.getStackInSlot(1) != null) {
        if (this.getStackInSlot(1).getItem() == Items.water_bucket || (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)) != null && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)).getFluid() == FluidRegistry.WATER)) {
          if (canDrainItem(this.getStackInSlot(1))) {
            if (this.getStackInSlot(1).getItem() == Items.water_bucket) {
              this.setInventorySlotContents(1,new ItemStack(Items.bucket));
              this.myTank.fill(new FluidStack(FluidRegistry.WATER,1000),true);
            }
            if (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem) {
              int maxDrain=this.getTankInfo(ForgeDirection.UP)[0].capacity - this.getTankInfo(ForgeDirection.UP)[0].fluid.amount;
              this.myTank.fill(new FluidStack(FluidRegistry.WATER,((IFluidContainerItem)this.getStackInSlot(1).getItem()).drain(this.getStackInSlot(1),maxDrain,true).amount),true);
            }
          }
        }
      }
      boolean flag=this.furnaceBurnTime > 0;
      boolean flag1=false;
      int maxThisTick=10;
      if (this.furnaceBurnTime > 0) {
        maxThisTick=Math.min(furnaceBurnTime,10);
        this.furnaceBurnTime-=maxThisTick;
      }
      if (!this.worldObj.isRemote) {
        if (this.furnaceBurnTime == 0 && this.canSmelt()) {
          this.currentItemBurnTime=this.furnaceBurnTime=getItemBurnTime(this.furnaceItemStacks[0]);
          if (this.furnaceBurnTime > 0) {
            flag1=true;
            if (this.furnaceItemStacks[0] != null) {
              --this.furnaceItemStacks[0].stackSize;
              if (this.furnaceItemStacks[0].stackSize == 0) {
                this.furnaceItemStacks[0]=furnaceItemStacks[0].getItem().getContainerItem(furnaceItemStacks[0]);
              }
            }
          }
        }
        if (!this.isBurning() && this.heat > 0) {
          this.heat-=Math.min(this.heat,10);
        }
        if (this.isBurning() && this.heat < 1600) {
          this.heat++;
        }
        if (this.isBurning() && this.canSmelt()) {
          ++this.furnaceCookTime;
          if (this.furnaceCookTime > 0) {
            int i=0;
            int maxSteamThisTick=(int)(((float)maxThisTick) * 0.7F + (maxThisTick * 0.3F * ((float)this.heat / 1600.0F)));
            while (i < maxSteamThisTick && this.isBurning() && this.canSmelt()) {
              this.insertSteam(10);
              this.myTank.drain(2,true);
              i++;
            }
            this.furnaceCookTime=0;
            flag1=true;
          }
        }
 else {
          this.furnaceCookTime=0;
        }
        if (flag != this.furnaceBurnTime > 0) {
          flag1=true;
        }
      }
      if (this.isBurning() != this.wasBurning) {
        this.wasBurning=this.isBurning();
        this.burning=this.isBurning();
        this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
      }
    }
  }
  if (!this.worldObj.isRemote) {
  }
}",0.994191112401975
22466,"protected synchronized void tick(){
  if (Config.wimpMode) {
    if (this.getPressure() > 1.09F) {
      this.steam=(int)Math.floor((double)this.capacity * 1.09D);
    }
  }
 else {
    if (this.transporters != null && this.transporters.keySet() != null) {
      if (this.getPressure() > 1.02F) {
        for (        Coord4 coords : transporters.keySet()) {
          ISteamTransporter trans=transporters.get(coords);
          if (trans == null || ((TileEntity)trans).isInvalid()) {
            transporters.remove(coords);
          }
 else           if (!trans.getWorld().isRemote && shouldExplode(oneInX(this.getPressure(),trans.getPressureResistance()))) {
            trans.explode();
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"" + this.name);
    }
  }
}","protected synchronized void tick(){
  if (Config.wimpMode) {
    if (this.getPressure() > 1.09F) {
      this.steam=(int)Math.floor((double)this.capacity * 1.09D);
    }
  }
 else {
    if (this.transporters != null && this.transporters.keySet() != null) {
      if (this.getPressure() > 1.2F) {
        for (        Coord4 coords : transporters.keySet()) {
          ISteamTransporter trans=transporters.get(coords);
          if ((trans == null || ((TileEntity)trans).isInvalid())) {
            System.out.println(""String_Node_Str"");
            transporters.remove(coords);
          }
 else           if (!trans.getWorld().isRemote && shouldExplode(oneInX(this.getPressure(),trans.getPressureResistance()))) {
            trans.explode();
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"" + this.name);
    }
  }
}",0.6614457831325301
22467,"public void refresh(){
  if (!worldObj.isRemote) {
  }
  if (this.network == null && !worldObj.isRemote) {
    if (SteamNetworkRegistry.getInstance().isInitialized(this.getDimension())) {
      if (this.networkName != null && SteamNetworkRegistry.getInstance().isInitialized(this.getDimension())) {
        this.network=SteamNetworkRegistry.getInstance().getNetwork(this.networkName,this);
        this.network.rejoin(this);
      }
 else {
        SteamNetwork.newOrJoin(this);
      }
      this.isInitialized=true;
      worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
    }
  }
}","public void refresh(){
  if (!worldObj.isRemote) {
  }
  if (this.network == null && !worldObj.isRemote) {
    if (SteamNetworkRegistry.getInstance().isInitialized(this.getDimension())) {
      if (this.networkName != null && SteamNetworkRegistry.getInstance().isInitialized(this.getDimension())) {
        System.out.println(""String_Node_Str"");
        this.network=SteamNetworkRegistry.getInstance().getNetwork(this.networkName,this);
        this.network.rejoin(this);
      }
 else {
        System.out.println(""String_Node_Str"");
        SteamNetwork.newOrJoin(this);
      }
      this.isInitialized=true;
      worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
    }
  }
}",0.9257503949447078
22468,"public void addTransporter(ISteamTransporter trans){
  if (!this.contains(trans)) {
    this.capacity+=trans.getCapacity();
    Coord4 transCoords=trans.getCoords();
    transporters.put(transCoords,trans);
    trans.setNetworkName(this.name);
    trans.setNetwork(this);
    SteamNetworkRegistry.markDirty(this);
  }
}","public void addTransporter(ISteamTransporter trans){
  if (trans != null && !this.contains(trans)) {
    this.capacity+=trans.getCapacity();
    Coord4 transCoords=trans.getCoords();
    transporters.put(transCoords,trans);
    trans.setNetworkName(this.name);
    trans.setNetwork(this);
    SteamNetworkRegistry.markDirty(this);
  }
}",0.9740458015267176
22469,"@Override public void updateEntity(){
  if (lastSteam != this.getSteam() > 0) {
    worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
  lastSteam=this.getSteam() > 0;
  if (!isInitialized) {
    this.setDistributionDirections(new ForgeDirection[]{ForgeDirection.getOrientation(this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord)).getOpposite()});
    isInitialized=true;
  }
  super.updateEntity();
  if (active && this.worldObj.isRemote) {
    rotateTicks++;
  }
  if (active && this.worldObj.isRemote || (this.getSteam() > 0 && !this.powered)) {
    if (!this.worldObj.isRemote) {
      this.decrSteam(1);
    }
    int meta=this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
    ForgeDirection dir=ForgeDirection.getOrientation(meta);
    this.worldObj.spawnParticle(""String_Node_Str"",xCoord + (dir.offsetX == 0 ? Math.random() : 0.5F),yCoord + (dir.offsetY == 0 ? Math.random() : 0.5F),zCoord + (dir.offsetZ == 0 ? Math.random() : 0.5F),dir.offsetX * 0.2F,dir.offsetY * 0.2F,dir.offsetZ * 0.2F);
    int blocksInFront=0;
    boolean blocked=false;
    for (int i=1; i < 9; i++) {
      int x=xCoord + dir.offsetX * i;
      int y=yCoord + dir.offsetY * i;
      int z=zCoord + dir.offsetZ * i;
      if (!this.worldObj.isRemote && this.worldObj.rand.nextInt(20) == 0 && !blocked && this.worldObj.getBlock(x,y,z) != Blocks.air && this.worldObj.getBlock(x,y,z).isReplaceable(worldObj,x,y,z) || this.worldObj.getBlock(x,y,z) instanceof BlockCrops) {
        int tMeta=this.worldObj.getBlockMetadata(x,y,z);
        this.worldObj.getBlock(x,y,z).dropBlockAsItem(worldObj,x,y,z,tMeta,0);
        for (int v=0; v < 5; v++) {
          Steamcraft.instance.proxy.spawnBreakParticles(worldObj,xCoord + dir.offsetX * i + 0.5F,yCoord + dir.offsetY * i + 0.5F,zCoord + dir.offsetZ * i + 0.5F,this.worldObj.getBlock(x,y,z),0.0F,0.0F,0.0F);
        }
        this.worldObj.setBlockToAir(x,y,z);
      }
      if (!blocked && (this.worldObj.getBlock(x,y,z).isReplaceable(worldObj,x,y,z) || this.worldObj.isAirBlock(x,y,z) || this.worldObj.getBlock(x,y,z) instanceof BlockTrapDoor|| this.worldObj.getBlock(x,y,z).getCollisionBoundingBoxFromPool(worldObj,x,y,z) == null || (this.worldObj.getBlock(x,y,z).isSideSolid(worldObj,x,y,z,dir) && this.worldObj.getBlock(x,y,z).isSideSolid(worldObj,x,y,z,dir.getOpposite())))) {
        blocksInFront=i;
        if (i != 8)         this.worldObj.spawnParticle(""String_Node_Str"",xCoord + dir.offsetX * i + (dir.offsetX == 0 ? Math.random() : 0.5F),yCoord + dir.offsetY * i + (dir.offsetY == 0 ? Math.random() : 0.5F),zCoord + dir.offsetZ * i + (dir.offsetZ == 0 ? Math.random() : 0.5F),dir.offsetX * 0.2F,dir.offsetY * 0.2F,dir.offsetZ * 0.2F);
      }
 else {
        blocked=true;
      }
    }
    List entities=worldObj.getEntitiesWithinAABB(Entity.class,AxisAlignedBB.getBoundingBox(xCoord + (dir.offsetX < 0 ? dir.offsetX * blocksInFront : 0),yCoord + (dir.offsetY < 0 ? dir.offsetY * blocksInFront : 0),zCoord + (dir.offsetZ < 0 ? dir.offsetZ * blocksInFront : 0),xCoord + 1 + (dir.offsetX > 0 ? dir.offsetX * blocksInFront : 0),yCoord + 1 + (dir.offsetY > 0 ? dir.offsetY * blocksInFront : 0),zCoord + 1 + (dir.offsetZ > 0 ? dir.offsetZ * blocksInFront : 0)));
    for (    Object obj : entities) {
      Entity entity=(Entity)obj;
      if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
        if (entity instanceof EntityPlayer && ((EntityPlayer)entity).isSneaking()) {
          entity.motionX+=dir.offsetX * 0.025F;
          entity.motionY+=dir.offsetY * 0.05F;
          entity.motionZ+=dir.offsetZ * 0.025F;
        }
 else {
          entity.motionX+=dir.offsetX * 0.075F;
          entity.motionY+=dir.offsetY * 0.1F;
          entity.motionZ+=dir.offsetZ * 0.075F;
        }
        entity.fallDistance=0.0F;
      }
    }
  }
}","@Override public void updateEntity(){
  if (lastSteam != this.getSteam() > 0) {
    worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
  lastSteam=this.getSteam() > 0;
  if (!isInitialized) {
    this.powered=worldObj.isBlockIndirectlyGettingPowered(xCoord,yCoord,zCoord);
    this.setDistributionDirections(new ForgeDirection[]{ForgeDirection.getOrientation(this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord)).getOpposite()});
    isInitialized=true;
  }
  super.updateEntity();
  if (active && this.worldObj.isRemote) {
    rotateTicks++;
  }
  if (active && this.worldObj.isRemote || (this.getSteam() > 0 && !this.powered)) {
    if (!this.worldObj.isRemote) {
      this.decrSteam(1);
    }
    int meta=this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
    ForgeDirection dir=ForgeDirection.getOrientation(meta);
    this.worldObj.spawnParticle(""String_Node_Str"",xCoord + (dir.offsetX == 0 ? Math.random() : 0.5F),yCoord + (dir.offsetY == 0 ? Math.random() : 0.5F),zCoord + (dir.offsetZ == 0 ? Math.random() : 0.5F),dir.offsetX * 0.2F,dir.offsetY * 0.2F,dir.offsetZ * 0.2F);
    int blocksInFront=0;
    boolean blocked=false;
    for (int i=1; i < 9; i++) {
      int x=xCoord + dir.offsetX * i;
      int y=yCoord + dir.offsetY * i;
      int z=zCoord + dir.offsetZ * i;
      if (!this.worldObj.isRemote && this.worldObj.rand.nextInt(20) == 0 && !blocked && this.worldObj.getBlock(x,y,z) != Blocks.air && this.worldObj.getBlock(x,y,z).isReplaceable(worldObj,x,y,z) || this.worldObj.getBlock(x,y,z) instanceof BlockCrops) {
        int tMeta=this.worldObj.getBlockMetadata(x,y,z);
        this.worldObj.getBlock(x,y,z).dropBlockAsItem(worldObj,x,y,z,tMeta,0);
        for (int v=0; v < 5; v++) {
          Steamcraft.instance.proxy.spawnBreakParticles(worldObj,xCoord + dir.offsetX * i + 0.5F,yCoord + dir.offsetY * i + 0.5F,zCoord + dir.offsetZ * i + 0.5F,this.worldObj.getBlock(x,y,z),0.0F,0.0F,0.0F);
        }
        this.worldObj.setBlockToAir(x,y,z);
      }
      if (!blocked && (this.worldObj.getBlock(x,y,z).isReplaceable(worldObj,x,y,z) || this.worldObj.isAirBlock(x,y,z) || this.worldObj.getBlock(x,y,z) instanceof BlockTrapDoor|| this.worldObj.getBlock(x,y,z).getCollisionBoundingBoxFromPool(worldObj,x,y,z) == null || (this.worldObj.getBlock(x,y,z).isSideSolid(worldObj,x,y,z,dir) && this.worldObj.getBlock(x,y,z).isSideSolid(worldObj,x,y,z,dir.getOpposite())))) {
        blocksInFront=i;
        if (i != 8)         this.worldObj.spawnParticle(""String_Node_Str"",xCoord + dir.offsetX * i + (dir.offsetX == 0 ? Math.random() : 0.5F),yCoord + dir.offsetY * i + (dir.offsetY == 0 ? Math.random() : 0.5F),zCoord + dir.offsetZ * i + (dir.offsetZ == 0 ? Math.random() : 0.5F),dir.offsetX * 0.2F,dir.offsetY * 0.2F,dir.offsetZ * 0.2F);
      }
 else {
        blocked=true;
      }
    }
    List entities=worldObj.getEntitiesWithinAABB(Entity.class,AxisAlignedBB.getBoundingBox(xCoord + (dir.offsetX < 0 ? dir.offsetX * blocksInFront : 0),yCoord + (dir.offsetY < 0 ? dir.offsetY * blocksInFront : 0),zCoord + (dir.offsetZ < 0 ? dir.offsetZ * blocksInFront : 0),xCoord + 1 + (dir.offsetX > 0 ? dir.offsetX * blocksInFront : 0),yCoord + 1 + (dir.offsetY > 0 ? dir.offsetY * blocksInFront : 0),zCoord + 1 + (dir.offsetZ > 0 ? dir.offsetZ * blocksInFront : 0)));
    for (    Object obj : entities) {
      Entity entity=(Entity)obj;
      if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
        if (entity instanceof EntityPlayer && ((EntityPlayer)entity).isSneaking()) {
          entity.motionX+=dir.offsetX * 0.025F;
          entity.motionY+=dir.offsetY * 0.05F;
          entity.motionZ+=dir.offsetZ * 0.025F;
        }
 else {
          entity.motionX+=dir.offsetX * 0.075F;
          entity.motionY+=dir.offsetY * 0.1F;
          entity.motionZ+=dir.offsetZ * 0.075F;
        }
        entity.fallDistance=0.0F;
      }
    }
  }
}",0.989667049368542
22470,"@Override public void updateEntity(){
  if (lastSteam != this.getSteam() > steamUsage) {
    worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
  lastSteam=this.getSteam() > steamUsage;
  if (!isInitialized) {
    ForgeDirection myDir=ForgeDirection.getOrientation(this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord));
    ForgeDirection[] directions=new ForgeDirection[5];
    int i=0;
    for (    ForgeDirection direction : ForgeDirection.values()) {
      if (direction != myDir && direction != myDir.getOpposite()) {
        directions[i]=direction;
        i++;
      }
    }
    this.setDistributionDirections(directions);
    isInitialized=true;
  }
  super.updateEntity();
  if (active && this.worldObj.isRemote) {
    rotateTicks++;
  }
  if (active && this.worldObj.isRemote || (this.getSteam() > steamUsage && !this.powered)) {
    if (!this.worldObj.isRemote) {
      this.decrSteam(1);
    }
    int meta=this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
    ForgeDirection dir=ForgeDirection.getOrientation(meta);
    float[] M={this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F};
    float[] N={this.xCoord + 0.5F + 10 * dir.offsetX,this.yCoord + 0.5F + 10 * dir.offsetY,this.zCoord + 0.5F + 10 * dir.offsetZ};
    float theta=(float)Math.PI / 2.0F;
    List entities=worldObj.getEntitiesWithinAABB(Entity.class,AxisAlignedBB.getBoundingBox(xCoord - 20,yCoord - 20,zCoord - 20,xCoord + 20,yCoord + 20,zCoord + 20));
    for (int i=0; i < 200; i++) {
      float[] X={(worldObj.rand.nextFloat() * 40.0F) - 20.0F + xCoord,(worldObj.rand.nextFloat() * 40.0F) - 20.0F + yCoord,(worldObj.rand.nextFloat() * 40.0F) - 20.0F + zCoord};
      if (isLyingInCone(X,M,N,theta) && this.worldObj.rayTraceBlocks(Vec3.createVectorHelper(X[0],X[1],X[2]),Vec3.createVectorHelper(this.xCoord + 0.5F + dir.offsetX,this.yCoord + 0.5F + dir.offsetY,this.zCoord + 0.5F + dir.offsetZ)) == null) {
        Vec3 vec=Vec3.createVectorHelper(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
        vec=vec.normalize();
        this.worldObj.spawnParticle(""String_Node_Str"",X[0],X[1],X[2],-vec.xCoord * 0.5F,-vec.yCoord * 0.5F,-vec.zCoord * 0.5F);
      }
    }
    for (    Object obj : entities) {
      Entity entity=(Entity)obj;
      float[] X={(float)entity.posX,(float)entity.posY,(float)entity.posZ};
      if (isLyingInCone(X,M,N,theta) && this.worldObj.rayTraceBlocks(Vec3.createVectorHelper(entity.posX,entity.posY,entity.posZ),Vec3.createVectorHelper(this.xCoord + 0.5F + dir.offsetX,this.yCoord + 0.5F + dir.offsetY,this.zCoord + 0.5F + dir.offsetZ)) == null) {
        if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
          Vec3 vec=Vec3.createVectorHelper(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
          vec=vec.normalize();
          vec.yCoord*=1;
          if (entity.isSneaking()) {
            vec.xCoord*=0.25F;
            vec.yCoord*=0.25F;
            vec.zCoord*=0.25F;
          }
          entity.motionX-=vec.xCoord * 0.025F;
          entity.motionY-=vec.yCoord * 0.05F;
          entity.motionZ-=vec.zCoord * 0.025F;
          entity.fallDistance=0.0F;
        }
      }
    }
    List list=worldObj.selectEntitiesWithinAABB(EntityItem.class,AxisAlignedBB.getBoundingBox(xCoord + dir.offsetX * 0.25F,yCoord + dir.offsetY * 0.25F,zCoord + dir.offsetZ * 0.25F,xCoord + 1.0D + dir.offsetX * 0.25F,yCoord + 1.0D + dir.offsetY * 0.25F,zCoord + 1.0D + dir.offsetZ * 0.25F),IEntitySelector.selectAnything);
    if (list.size() > 0) {
      EntityItem item=(EntityItem)list.get(0);
      if (this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) != null && this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) instanceof ISidedInventory) {
        ISidedInventory inv=(ISidedInventory)this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ);
        int[] access=inv.getAccessibleSlotsFromSide(dir.getOpposite().flag);
        for (int j=0; j < access.length; j++) {
          int i=access[j];
          ItemStack checkStack1=null;
          ItemStack checkStack2=null;
          if (inv.getStackInSlot(i) != null) {
            checkStack1=inv.getStackInSlot(i).copy();
            checkStack1.stackSize=1;
            checkStack2=item.getEntityItem().copy();
            checkStack2.stackSize=1;
          }
          if ((inv.getStackInSlot(i) == null || (item.getEntityItem().areItemStacksEqual(checkStack1,checkStack2) && inv.getStackInSlot(i).stackSize < inv.getStackInSlot(i).getMaxStackSize())) && inv.isItemValidForSlot(i,item.getEntityItem()) && inv.canInsertItem(i,item.getEntityItem(),dir.getOpposite().flag)) {
            ItemStack stack=item.getEntityItem().copy();
            boolean setDead=true;
            if (inv.getStackInSlot(i) != null) {
              if ((inv.getStackInSlot(i).stackSize + stack.stackSize) > stack.getMaxStackSize()) {
                setDead=false;
                int total=inv.getStackInSlot(i).stackSize + stack.stackSize;
                stack.stackSize=stack.getMaxStackSize();
                total-=stack.getMaxStackSize();
                checkStack2.stackSize=total;
                item.setEntityItemStack(checkStack2);
              }
 else {
                stack.stackSize=inv.getStackInSlot(i).stackSize + item.getEntityItem().stackSize;
              }
            }
            inv.setInventorySlotContents(i,stack);
            if (setDead) {
              item.setDead();
            }
            break;
          }
        }
      }
 else       if (this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) != null && this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) instanceof IInventory) {
        IInventory inv=(IInventory)this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ);
        for (int i=0; i < inv.getSizeInventory(); i++) {
          ItemStack checkStack1=null;
          ItemStack checkStack2=null;
          if (inv.getStackInSlot(i) != null) {
            checkStack1=inv.getStackInSlot(i).copy();
            checkStack1.stackSize=1;
            checkStack2=item.getEntityItem().copy();
            checkStack2.stackSize=1;
          }
          if ((inv.getStackInSlot(i) == null || (item.getEntityItem().areItemStacksEqual(checkStack1,checkStack2) && inv.getStackInSlot(i).stackSize < inv.getStackInSlot(i).getMaxStackSize())) && inv.isItemValidForSlot(i,item.getEntityItem())) {
            ItemStack stack=item.getEntityItem().copy();
            boolean setDead=true;
            if (inv.getStackInSlot(i) != null) {
              if ((inv.getStackInSlot(i).stackSize + stack.stackSize) > stack.getMaxStackSize()) {
                setDead=false;
                int total=inv.getStackInSlot(i).stackSize + stack.stackSize;
                stack.stackSize=stack.getMaxStackSize();
                total-=stack.getMaxStackSize();
                checkStack2.stackSize=total;
                item.setEntityItemStack(checkStack2);
              }
 else {
                stack.stackSize=inv.getStackInSlot(i).stackSize + item.getEntityItem().stackSize;
              }
            }
            inv.setInventorySlotContents(i,stack);
            if (setDead) {
              item.setDead();
            }
            break;
          }
        }
      }
    }
  }
}","@Override public void updateEntity(){
  if (lastSteam != this.getSteam() > steamUsage) {
    worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
  lastSteam=this.getSteam() > steamUsage;
  if (!isInitialized) {
    this.powered=worldObj.isBlockIndirectlyGettingPowered(xCoord,yCoord,zCoord);
    ForgeDirection myDir=ForgeDirection.getOrientation(this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord));
    ForgeDirection[] directions=new ForgeDirection[5];
    int i=0;
    for (    ForgeDirection direction : ForgeDirection.values()) {
      if (direction != myDir && direction != myDir.getOpposite()) {
        directions[i]=direction;
        i++;
      }
    }
    this.setDistributionDirections(directions);
    isInitialized=true;
  }
  super.updateEntity();
  if (active && this.worldObj.isRemote) {
    rotateTicks++;
  }
  if (active && this.worldObj.isRemote || (this.getSteam() > steamUsage && !this.powered)) {
    if (!this.worldObj.isRemote) {
      this.decrSteam(3);
    }
    int meta=this.worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
    ForgeDirection dir=ForgeDirection.getOrientation(meta);
    float[] M={this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F};
    float[] N={this.xCoord + 0.5F + 10 * dir.offsetX,this.yCoord + 0.5F + 10 * dir.offsetY,this.zCoord + 0.5F + 10 * dir.offsetZ};
    float theta=(float)Math.PI / 2.0F;
    List entities=worldObj.getEntitiesWithinAABB(Entity.class,AxisAlignedBB.getBoundingBox(xCoord - 20,yCoord - 20,zCoord - 20,xCoord + 20,yCoord + 20,zCoord + 20));
    for (int i=0; i < 200; i++) {
      float[] X={(worldObj.rand.nextFloat() * 40.0F) - 20.0F + xCoord,(worldObj.rand.nextFloat() * 40.0F) - 20.0F + yCoord,(worldObj.rand.nextFloat() * 40.0F) - 20.0F + zCoord};
      if (isLyingInCone(X,M,N,theta) && this.worldObj.rayTraceBlocks(Vec3.createVectorHelper(X[0],X[1],X[2]),Vec3.createVectorHelper(this.xCoord + 0.5F + dir.offsetX,this.yCoord + 0.5F + dir.offsetY,this.zCoord + 0.5F + dir.offsetZ)) == null) {
        Vec3 vec=Vec3.createVectorHelper(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
        vec=vec.normalize();
        this.worldObj.spawnParticle(""String_Node_Str"",X[0],X[1],X[2],-vec.xCoord * 0.5F,-vec.yCoord * 0.5F,-vec.zCoord * 0.5F);
      }
    }
    for (    Object obj : entities) {
      Entity entity=(Entity)obj;
      float[] X={(float)entity.posX,(float)entity.posY,(float)entity.posZ};
      if (isLyingInCone(X,M,N,theta) && this.worldObj.rayTraceBlocks(Vec3.createVectorHelper(entity.posX,entity.posY,entity.posZ),Vec3.createVectorHelper(this.xCoord + 0.5F + dir.offsetX,this.yCoord + 0.5F + dir.offsetY,this.zCoord + 0.5F + dir.offsetZ)) == null) {
        if (!(entity instanceof EntityPlayer) || !(((EntityPlayer)entity).capabilities.isFlying && ((EntityPlayer)entity).capabilities.isCreativeMode)) {
          Vec3 vec=Vec3.createVectorHelper(X[0] - M[0],X[1] - M[1],X[2] - M[2]);
          vec=vec.normalize();
          vec.yCoord*=1;
          if (entity.isSneaking()) {
            vec.xCoord*=0.25F;
            vec.yCoord*=0.25F;
            vec.zCoord*=0.25F;
          }
          entity.motionX-=vec.xCoord * 0.025F;
          entity.motionY-=vec.yCoord * 0.05F;
          entity.motionZ-=vec.zCoord * 0.025F;
          entity.fallDistance=0.0F;
        }
      }
    }
    List list=worldObj.selectEntitiesWithinAABB(EntityItem.class,AxisAlignedBB.getBoundingBox(xCoord + dir.offsetX * 0.25F,yCoord + dir.offsetY * 0.25F,zCoord + dir.offsetZ * 0.25F,xCoord + 1.0D + dir.offsetX * 0.25F,yCoord + 1.0D + dir.offsetY * 0.25F,zCoord + 1.0D + dir.offsetZ * 0.25F),IEntitySelector.selectAnything);
    if (list.size() > 0) {
      EntityItem item=(EntityItem)list.get(0);
      if (this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) != null && this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) instanceof ISidedInventory) {
        ISidedInventory inv=(ISidedInventory)this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ);
        int[] access=inv.getAccessibleSlotsFromSide(dir.getOpposite().flag);
        for (int j=0; j < access.length; j++) {
          int i=access[j];
          ItemStack checkStack1=null;
          ItemStack checkStack2=null;
          if (inv.getStackInSlot(i) != null) {
            checkStack1=inv.getStackInSlot(i).copy();
            checkStack1.stackSize=1;
            checkStack2=item.getEntityItem().copy();
            checkStack2.stackSize=1;
          }
          if ((inv.getStackInSlot(i) == null || (item.getEntityItem().areItemStacksEqual(checkStack1,checkStack2) && inv.getStackInSlot(i).stackSize < inv.getStackInSlot(i).getMaxStackSize())) && inv.isItemValidForSlot(i,item.getEntityItem()) && inv.canInsertItem(i,item.getEntityItem(),dir.getOpposite().flag)) {
            ItemStack stack=item.getEntityItem().copy();
            boolean setDead=true;
            if (inv.getStackInSlot(i) != null) {
              if ((inv.getStackInSlot(i).stackSize + stack.stackSize) > stack.getMaxStackSize()) {
                setDead=false;
                int total=inv.getStackInSlot(i).stackSize + stack.stackSize;
                stack.stackSize=stack.getMaxStackSize();
                total-=stack.getMaxStackSize();
                checkStack2.stackSize=total;
                item.setEntityItemStack(checkStack2);
              }
 else {
                stack.stackSize=inv.getStackInSlot(i).stackSize + item.getEntityItem().stackSize;
              }
            }
            inv.setInventorySlotContents(i,stack);
            if (setDead) {
              item.setDead();
            }
            break;
          }
        }
      }
 else       if (this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) != null && this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ) instanceof IInventory) {
        IInventory inv=(IInventory)this.worldObj.getTileEntity(xCoord - dir.offsetX,yCoord - dir.offsetY,zCoord - dir.offsetZ);
        for (int i=0; i < inv.getSizeInventory(); i++) {
          ItemStack checkStack1=null;
          ItemStack checkStack2=null;
          if (inv.getStackInSlot(i) != null) {
            checkStack1=inv.getStackInSlot(i).copy();
            checkStack1.stackSize=1;
            checkStack2=item.getEntityItem().copy();
            checkStack2.stackSize=1;
          }
          if ((inv.getStackInSlot(i) == null || (item.getEntityItem().areItemStacksEqual(checkStack1,checkStack2) && inv.getStackInSlot(i).stackSize < inv.getStackInSlot(i).getMaxStackSize())) && inv.isItemValidForSlot(i,item.getEntityItem())) {
            ItemStack stack=item.getEntityItem().copy();
            boolean setDead=true;
            if (inv.getStackInSlot(i) != null) {
              if ((inv.getStackInSlot(i).stackSize + stack.stackSize) > stack.getMaxStackSize()) {
                setDead=false;
                int total=inv.getStackInSlot(i).stackSize + stack.stackSize;
                stack.stackSize=stack.getMaxStackSize();
                total-=stack.getMaxStackSize();
                checkStack2.stackSize=total;
                item.setEntityItemStack(checkStack2);
              }
 else {
                stack.stackSize=inv.getStackInSlot(i).stackSize + item.getEntityItem().stackSize;
              }
            }
            inv.setInventorySlotContents(i,stack);
            if (setDead) {
              item.setDead();
            }
            break;
          }
        }
      }
    }
  }
}",0.9862650122752306
22471,"public boolean getBurning(){
  return this.burning;
}","public boolean getBurning(){
  int meta=getBlockMetadata();
  if (meta > 0) {
    if (meta == 1) {
      return this.burning;
    }
 else {
      if (this.hasMaster()) {
        return this.getMasterTileEntity().isBurning();
      }
    }
  }
  return false;
}",0.3322683706070287
22472,"@SubscribeEvent public void clickLeft(PlayerInteractEvent event){
  if (event.entityPlayer.worldObj.getTileEntity(event.x,event.y,event.z) != null && !event.entityPlayer.worldObj.isRemote) {
    if (event.entityPlayer.worldObj.getTileEntity(event.x,event.y,event.z) instanceof TileEntitySteamHeater) {
    }
  }
}","@SubscribeEvent public void clickLeft(PlayerInteractEvent event){
  if (event.entityPlayer.worldObj.getTileEntity(event.x,event.y,event.z) != null && !event.entityPlayer.worldObj.isRemote) {
    if (event.entityPlayer.worldObj.getTileEntity(event.x,event.y,event.z) instanceof TileEntitySteamHeater) {
    }
    if (event.entityPlayer.worldObj.getTileEntity(event.x,event.y,event.z) instanceof ISteamTransporter) {
      ISteamTransporter trans=(ISteamTransporter)event.entityPlayer.worldObj.getTileEntity(event.x,event.y,event.z);
      if (event.entityPlayer.worldObj.isRemote) {
        System.out.println(""String_Node_Str"");
      }
      System.out.println(trans.getSteam() + ""String_Node_Str"" + trans.getPressure()+ ""String_Node_Str""+ trans.getNetworkName()+ ""String_Node_Str""+ trans.getNetwork());
    }
  }
}",0.5544729849424269
22473,"@Override public boolean onWrench(ItemStack stack,EntityPlayer player,World world,int x,int y,int z,int side,float xO,float yO,float zO){
  MovingObjectPosition hit=RayTracer.retraceBlock(world,player,x,y,z);
  if (hit == null) {
    return false;
  }
  if ((hit.subHit >= 0) && (hit.subHit < 6) && world.getBlock(hit.blockX,hit.blockY,hit.blockZ) instanceof BlockPipe) {
    int sidesConnect=0;
    for (int i=0; i < 6; i++) {
      if (this.doesConnect(ForgeDirection.getOrientation(i))) {
        sidesConnect++;
      }
    }
    if (sidesConnect > 2 && this.doesConnect(ForgeDirection.getOrientation(hit.subHit))) {
      player.swingItem();
      this.blacklistedSides.add(hit.subHit);
      int steam=this.getSteam();
      this.getNetwork().split(this);
      SteamNetwork.newOrJoin(this);
      this.getNetwork().addSteam(steam);
      System.out.println(hit.subHit);
      this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
    }
 else     if (!this.doesConnect(ForgeDirection.getOrientation(hit.subHit))) {
      if (this.blacklistedSides.contains(hit.subHit)) {
        this.blacklistedSides.remove((Integer)hit.subHit);
        player.swingItem();
        int steam=this.getSteam();
        this.getNetwork().split(this);
        SteamNetwork.newOrJoin(this);
        this.getNetwork().addSteam(steam);
        this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean onWrench(ItemStack stack,EntityPlayer player,World world,int x,int y,int z,int side,float xO,float yO,float zO){
  MovingObjectPosition hit=RayTracer.retraceBlock(world,player,x,y,z);
  if (hit == null) {
    return false;
  }
  if ((hit.subHit >= 0) && (hit.subHit < 6) && world.getBlock(hit.blockX,hit.blockY,hit.blockZ) instanceof BlockPipe) {
    int sidesConnect=0;
    for (int i=0; i < 6; i++) {
      if (this.doesConnect(ForgeDirection.getOrientation(i))) {
        sidesConnect++;
      }
    }
    if (sidesConnect > 2 && this.doesConnect(ForgeDirection.getOrientation(hit.subHit))) {
      player.swingItem();
      this.blacklistedSides.add(hit.subHit);
      int steam=this.getSteam();
      this.getNetwork().split(this);
      SteamNetwork.newOrJoin(this);
      this.getNetwork().addSteam(steam);
      System.out.println(hit.subHit);
      System.out.println(this.getNetworkName());
      this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
    }
 else     if (!this.doesConnect(ForgeDirection.getOrientation(hit.subHit))) {
      if (this.blacklistedSides.contains(hit.subHit)) {
        this.blacklistedSides.remove((Integer)hit.subHit);
        player.swingItem();
        int steam=this.getSteam();
        this.getNetwork().split(this);
        SteamNetwork.newOrJoin(this);
        this.getNetwork().addSteam(steam);
        System.out.println(this.getNetworkName());
        this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
      }
    }
    return true;
  }
  return false;
}",0.9663752521856086
22474,"public ItemStack onItemRightClick(ItemStack stack,World par2World,EntityPlayer player){
  this.checkNBT(player);
  if (stack.getItemDamage() < stack.getMaxDamage() - 1) {
    MutablePair info=stuff.get(player.getEntityId());
    int ticks=(Integer)info.left;
    int speed=(Integer)info.right;
    if (speed <= 1000) {
      speed+=Math.min(90,1000 - speed);
      stack.damageItem(3,player);
    }
    stuff.put(player.getEntityId(),MutablePair.of(ticks,speed));
    System.out.println(speed);
  }
  return stack;
}","public ItemStack onItemRightClick(ItemStack stack,World par2World,EntityPlayer player){
  this.checkNBT(player);
  if (stack.getItemDamage() < stack.getMaxDamage() - 1) {
    MutablePair info=stuff.get(player.getEntityId());
    int ticks=(Integer)info.left;
    int speed=(Integer)info.right;
    if (speed <= 1000) {
      speed+=Math.min(90,1000 - speed);
      stack.damageItem(3,player);
    }
    stuff.put(player.getEntityId(),MutablePair.of(ticks,speed));
  }
  return stack;
}",0.9690309690309692
22475,"public ItemStack onItemRightClick(ItemStack stack,World par2World,EntityPlayer player){
  this.checkNBT(player);
  if (stack.getItemDamage() < stack.getMaxDamage() - 1) {
    MutablePair info=stuff.get(player.getEntityId());
    int ticks=(Integer)info.left;
    int speed=(Integer)info.right;
    if (speed <= 1000) {
      speed+=Math.min(90,1000 - speed);
      stack.damageItem(3,player);
    }
    stuff.put(player.getEntityId(),MutablePair.of(ticks,speed));
    System.out.println(speed);
  }
  return stack;
}","public ItemStack onItemRightClick(ItemStack stack,World par2World,EntityPlayer player){
  this.checkNBT(player);
  if (stack.getItemDamage() < stack.getMaxDamage() - 1) {
    MutablePair info=stuff.get(player.getEntityId());
    int ticks=(Integer)info.left;
    int speed=(Integer)info.right;
    if (speed <= 1000) {
      speed+=Math.min(90,1000 - speed);
      stack.damageItem(3,player);
    }
    stuff.put(player.getEntityId(),MutablePair.of(ticks,speed));
  }
  return stack;
}",0.9690309690309692
22476,"public ItemStack onItemRightClick(ItemStack stack,World par2World,EntityPlayer player){
  this.checkNBT(player);
  if (stack.getItemDamage() < stack.getMaxDamage() - 1) {
    MutablePair info=stuff.get(player.getEntityId());
    int ticks=(Integer)info.left;
    int speed=(Integer)info.right;
    if (speed <= 1000) {
      speed+=Math.min(90,1000 - speed);
      stack.damageItem(3,player);
    }
    stuff.put(player.getEntityId(),MutablePair.of(ticks,speed));
    System.out.println(speed);
  }
  return stack;
}","public ItemStack onItemRightClick(ItemStack stack,World par2World,EntityPlayer player){
  this.checkNBT(player);
  if (stack.getItemDamage() < stack.getMaxDamage() - 1) {
    MutablePair info=stuff.get(player.getEntityId());
    int ticks=(Integer)info.left;
    int speed=(Integer)info.right;
    if (speed <= 1000) {
      speed+=Math.min(90,1000 - speed);
      stack.damageItem(3,player);
    }
    stuff.put(player.getEntityId(),MutablePair.of(ticks,speed));
  }
  return stack;
}",0.9690309690309692
22477,"@Override public void readFromNBT(NBTTagCompound access){
  super.readFromNBT(access);
  this.extendedLength=access.getFloat(""String_Node_Str"");
  this.extendedTicks=access.getInteger(""String_Node_Str"");
  this.spinup=access.getInteger(""String_Node_Str"");
  this.smooshingBlock=Block.getBlockById(access.getInteger(""String_Node_Str""));
  this.smooshingMeta=access.getInteger(""String_Node_Str"");
  worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  this.steam=access.getInteger(""String_Node_Str"");
}","@Override public void readFromNBT(NBTTagCompound access){
  super.readFromNBT(access);
  this.extendedLength=access.getFloat(""String_Node_Str"");
  this.extendedTicks=access.getInteger(""String_Node_Str"");
  this.spinup=access.getInteger(""String_Node_Str"");
  this.smooshingBlock=Block.getBlockById(access.getInteger(""String_Node_Str""));
  this.smooshingMeta=access.getInteger(""String_Node_Str"");
  NBTTagList nbttaglist=(NBTTagList)access.getTag(""String_Node_Str"");
  this.smooshedStack=new ArrayList<ItemStack>();
  for (int i=0; i < nbttaglist.tagCount(); ++i) {
    NBTTagCompound nbttagcompound1=(NBTTagCompound)nbttaglist.getCompoundTagAt(i);
    this.smooshedStack.add(ItemStack.loadItemStackFromNBT(nbttagcompound1));
  }
  worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  this.steam=access.getInteger(""String_Node_Str"");
}",0.7501875468867217
22478,"private void spawnItems(int x,int y,int z){
  int id=OreDictionary.getOreID(this.smooshedStack);
  boolean isSmashableOre=false;
  try {
    isSmashableOre=ItemSmashedOre.oreTypesFromOre.containsKey(OreDictionary.getOreName(id));
  }
 catch (  Exception e) {
  }
  if (isSmashableOre) {
    boolean doubleItems=worldObj.rand.nextInt(Config.chance) == 0;
    ItemStack items=new ItemStack(SteamcraftItems.smashedOre,doubleItems ? 2 : 1,ItemSmashedOre.oreTypesFromOre.get(OreDictionary.getOreName(id)));
    EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,items);
    this.worldObj.spawnEntityInWorld(entityItem);
    this.smooshedStack=null;
  }
 else {
    smooshingBlock.dropBlockAsItem(worldObj,x,y,z,this.smooshingMeta,0);
  }
}","private void spawnItems(int x,int y,int z){
  if (smooshedStack != null) {
    for (    ItemStack stack : smooshedStack) {
      int id=OreDictionary.getOreID(stack);
      boolean isSmashableOre=false;
      try {
        isSmashableOre=ItemSmashedOre.oreTypesFromOre.containsKey(OreDictionary.getOreName(id));
      }
 catch (      Exception e) {
      }
      if (isSmashableOre) {
        boolean doubleItems=worldObj.rand.nextInt(Config.chance) == 0;
        ItemStack items=new ItemStack(SteamcraftItems.smashedOre,doubleItems ? 2 : 1,ItemSmashedOre.oreTypesFromOre.get(OreDictionary.getOreName(id)));
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,items);
        this.worldObj.spawnEntityInWorld(entityItem);
        this.smooshedStack=null;
      }
 else {
        EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.1F,z + 0.5F,stack);
        this.worldObj.spawnEntityInWorld(entityItem);
        this.smooshedStack=null;
      }
    }
  }
}",0.7757644394110985
22479,"public void updateEntity(){
  ForgeDirection[] directions=new ForgeDirection[5];
  int i=0;
  for (  ForgeDirection direction : ForgeDirection.values()) {
    if (direction != myDir() && direction != ForgeDirection.UP) {
      directions[i]=direction;
      i++;
    }
  }
  UtilSteamTransport.generalDistributionEvent(worldObj,xCoord,yCoord,zCoord,directions);
  UtilSteamTransport.generalPressureEvent(worldObj,xCoord,yCoord,zCoord,this.getPressure(),this.getCapacity());
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  if (this.spinup == 1) {
    this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,""String_Node_Str"",Block.soundTypeAnvil.getVolume(),0.9F);
  }
  if (extendedTicks > 15) {
    this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,""String_Node_Str"",2.0F,0.9F);
  }
  if (extendedTicks == 5) {
    this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,""String_Node_Str"",0.5F,(float)(0.75F + (Math.random() * 0.1F)));
  }
  if (extendedTicks > 0 && extendedTicks < 6) {
    if (smooshingBlock != null && smooshingBlock.stepSound != null) {
      this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,smooshingBlock.stepSound.getBreakSound(),0.5F,(float)(0.75F + (Math.random() * 0.1F)));
    }
  }
  decodeAndCreateParticles(1);
  if (this.hasBlockUpdate && this.hasPartner() && this.steam > 100) {
    if (this.shouldStop) {
      this.spinup=0;
      this.extendedLength=0;
      this.extendedTicks=0;
      this.isActive=false;
      this.shouldStop=false;
      this.isBreaking=false;
      return;
    }
 else {
    }
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.steam-=100;
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          if (!worldObj.isAirBlock(x,y,z) && worldObj.getTileEntity(x,y,z) == null && worldObj.getBlock(x,y,z).getBlockHardness(worldObj,x,y,z) < 50F) {
            this.spinup++;
            if (this.getBlockMetadata() % 2 == 0)             try {
              this.smooshingBlock=worldObj.getBlock(x,y,z);
              this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
              this.smooshedStack=new ItemStack(Item.getItemFromBlock(smooshingBlock),1,smooshingMeta);
            }
 catch (            Exception e) {
              System.out.println(""String_Node_Str"");
              System.out.println(""String_Node_Str"" + this.getBlockMetadata());
              e.printStackTrace();
            }
            worldObj.setBlock(x,y,z,SteamcraftBlocks.dummy);
          }
 else {
            if (this.hasPartner()) {
              int[] pc=getTarget(2);
              TileEntitySmasher partner=(TileEntitySmasher)worldObj.getTileEntity(pc[0],yCoord,pc[1]);
              if (partner.spinup < 41) {
                this.shouldStop=true;
              }
              if (partner.spinup >= 41) {
                if (partner.shouldStop) {
                  this.shouldStop=true;
                }
              }
              if (shouldStop) {
                this.spinup++;
                return;
              }
            }
          }
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F && !this.shouldStop) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
        if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy) {
          worldObj.setBlockToAir(x,y,z);
        }
      }
    }
  }
 else   if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy && getBlockMetadata() % 2 == 0) {
    worldObj.setBlockToAir(x,y,z);
  }
  this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}","public void updateEntity(){
  ForgeDirection[] directions=new ForgeDirection[5];
  int i=0;
  for (  ForgeDirection direction : ForgeDirection.values()) {
    if (direction != myDir() && direction != ForgeDirection.UP) {
      directions[i]=direction;
      i++;
    }
  }
  UtilSteamTransport.generalDistributionEvent(worldObj,xCoord,yCoord,zCoord,directions);
  UtilSteamTransport.generalPressureEvent(worldObj,xCoord,yCoord,zCoord,this.getPressure(),this.getCapacity());
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  if (this.spinup == 1) {
    this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,""String_Node_Str"",Block.soundTypeAnvil.getVolume(),0.9F);
  }
  if (extendedTicks > 15) {
    this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,""String_Node_Str"",2.0F,0.9F);
  }
  if (extendedTicks == 5) {
    this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,""String_Node_Str"",0.5F,(float)(0.75F + (Math.random() * 0.1F)));
  }
  if (extendedTicks > 0 && extendedTicks < 6) {
    if (smooshingBlock != null && smooshingBlock.stepSound != null) {
      this.worldObj.playSoundEffect(this.xCoord + 0.5F,this.yCoord + 0.5F,this.zCoord + 0.5F,smooshingBlock.stepSound.getBreakSound(),0.5F,(float)(0.75F + (Math.random() * 0.1F)));
    }
  }
  decodeAndCreateParticles(1);
  if (this.hasBlockUpdate && this.hasPartner() && this.steam > 100) {
    if (this.shouldStop) {
      this.spinup=0;
      this.extendedLength=0;
      this.extendedTicks=0;
      this.isActive=false;
      this.shouldStop=false;
      this.isBreaking=false;
      return;
    }
 else {
    }
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.steam-=100;
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          if (!worldObj.isAirBlock(x,y,z) && worldObj.getTileEntity(x,y,z) == null && worldObj.getBlock(x,y,z).getBlockHardness(worldObj,x,y,z) < 50F) {
            this.spinup++;
            if (this.getBlockMetadata() % 2 == 0)             try {
              this.smooshingBlock=worldObj.getBlock(x,y,z);
              this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
              this.smooshedStack=smooshingBlock.getDrops(worldObj,x,y,z,smooshingMeta,0);
            }
 catch (            Exception e) {
              System.out.println(""String_Node_Str"");
              System.out.println(""String_Node_Str"" + this.getBlockMetadata());
              e.printStackTrace();
            }
            worldObj.setBlock(x,y,z,SteamcraftBlocks.dummy);
          }
 else {
            if (this.hasPartner()) {
              int[] pc=getTarget(2);
              TileEntitySmasher partner=(TileEntitySmasher)worldObj.getTileEntity(pc[0],yCoord,pc[1]);
              if (partner.spinup < 41) {
                this.shouldStop=true;
              }
              if (partner.spinup >= 41) {
                if (partner.shouldStop) {
                  this.shouldStop=true;
                }
              }
              if (shouldStop) {
                this.spinup++;
                return;
              }
            }
          }
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F && !this.shouldStop) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
        if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy) {
          worldObj.setBlockToAir(x,y,z);
        }
      }
    }
  }
 else   if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy && getBlockMetadata() % 2 == 0) {
    worldObj.setBlockToAir(x,y,z);
  }
  this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}",0.9300011570056692
22480,"@Override public void writeToNBT(NBTTagCompound access){
  super.writeToNBT(access);
  access.setInteger(""String_Node_Str"",spinup);
  access.setFloat(""String_Node_Str"",extendedLength);
  access.setInteger(""String_Node_Str"",extendedTicks);
  access.setInteger(""String_Node_Str"",Block.getIdFromBlock(smooshingBlock));
  access.setInteger(""String_Node_Str"",smooshingMeta);
  access.setInteger(""String_Node_Str"",steam);
}","@Override public void writeToNBT(NBTTagCompound access){
  super.writeToNBT(access);
  access.setInteger(""String_Node_Str"",spinup);
  access.setFloat(""String_Node_Str"",extendedLength);
  access.setInteger(""String_Node_Str"",extendedTicks);
  access.setInteger(""String_Node_Str"",Block.getIdFromBlock(smooshingBlock));
  access.setInteger(""String_Node_Str"",smooshingMeta);
  access.setInteger(""String_Node_Str"",steam);
  NBTTagList nbttaglist=new NBTTagList();
  if (this.smooshedStack != null) {
    for (int i=0; i < this.smooshedStack.size(); ++i) {
      NBTTagCompound nbttagcompound1=new NBTTagCompound();
      this.smooshedStack.get(i).writeToNBT(nbttagcompound1);
      nbttaglist.appendTag(nbttagcompound1);
    }
  }
  access.setTag(""String_Node_Str"",nbttaglist);
}",0.7008403361344537
22481,"/** 
 * Called to update the entity's position/logic.
 */
public void onUpdate(){
  super.onUpdate();
  if (this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F) {
    float var1=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
    this.prevRotationYaw=this.rotationYaw=(float)(Math.atan2(this.motionX,this.motionZ) * 180.0D / Math.PI);
    this.prevRotationPitch=this.rotationPitch=(float)(Math.atan2(this.motionY,(double)var1) * 180.0D / Math.PI);
  }
  Block var16=this.worldObj.getBlock(this.xTile,this.yTile,this.zTile);
  if (var16 != Blocks.air && var16 != null) {
    var16.setBlockBoundsBasedOnState(this.worldObj,this.xTile,this.yTile,this.zTile);
    AxisAlignedBB var2=var16.getCollisionBoundingBoxFromPool(this.worldObj,this.xTile,this.yTile,this.zTile);
    if (var2 != null && var2.isVecInside(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX,this.posY,this.posZ))) {
      this.inGround=true;
    }
  }
  if (this.arrowShake > 0) {
    --this.arrowShake;
  }
  if (this.inGround) {
    Block var18=this.worldObj.getBlock(this.xTile,this.yTile,this.zTile);
    int var19=this.worldObj.getBlockMetadata(this.xTile,this.yTile,this.zTile);
    if (var18 == this.inTile && var19 == this.inData) {
      ++this.ticksInGround;
      if (this.ticksInGround == 1) {
        this.setDead();
      }
    }
 else {
      this.inGround=false;
      this.motionX*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionY*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionZ*=(double)(this.rand.nextFloat() * 0.2F);
      this.ticksInGround=0;
      this.ticksInAir=0;
    }
  }
 else {
    ++this.ticksInAir;
    Vec3 var17=this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX,this.posY,this.posZ);
    Vec3 var3=this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
    MovingObjectPosition var4=this.worldObj.rayTraceBlocks(var17,var3,false);
    var17=this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX,this.posY,this.posZ);
    var3=this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
    if (var4 != null) {
      var3=this.worldObj.getWorldVec3Pool().getVecFromPool(var4.hitVec.xCoord,var4.hitVec.yCoord,var4.hitVec.zCoord);
    }
    Entity var5=null;
    List var6=this.worldObj.getEntitiesWithinAABBExcludingEntity(this,this.boundingBox.addCoord(this.motionX,this.motionY,this.motionZ).expand(1.0D,1.0D,1.0D));
    double var7=0.0D;
    int var9;
    float var11;
    for (var9=0; var9 < var6.size(); ++var9) {
      Entity var10=(Entity)var6.get(var9);
      if (var10.canBeCollidedWith() && (var10 != this.shootingEntity || this.ticksInAir >= 5)) {
        var11=0.3F;
        AxisAlignedBB var12=var10.boundingBox.expand((double)var11,(double)var11,(double)var11);
        MovingObjectPosition var13=var12.calculateIntercept(var17,var3);
        if (var13 != null) {
          double var14=var17.distanceTo(var13.hitVec);
          if (var14 < var7 || var7 == 0.0D) {
            var5=var10;
            var7=var14;
          }
        }
      }
    }
    if (var5 != null) {
      var4=new MovingObjectPosition(var5);
    }
    float var20;
    float var26;
    if (var4 != null) {
      if (var4.entityHit != null) {
        var20=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
        int var23=(int)this.damage;
        DamageSource var21=null;
        if (this.shootingEntity == null) {
          var21=DamageSource.causeThrownDamage(this,this);
        }
 else {
          var21=DamageSource.causeThrownDamage(this,this.shootingEntity);
        }
        if (this.isBurning() && !(var4.entityHit instanceof EntityEnderman)) {
          var4.entityHit.setFire(5);
        }
        if (var4.entityHit.attackEntityFrom(var21,var23)) {
          if (var4.entityHit instanceof EntityLiving) {
            EntityLiving var24=(EntityLiving)var4.entityHit;
            if (!this.worldObj.isRemote) {
              var24.setArrowCountInEntity(var24.getArrowCountInEntity() + 1);
            }
            if (this.knockbackStrength > 0) {
              var26=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
              if (var26 > 0.0F) {
              }
            }
            if (this.shootingEntity != null) {
            }
            if (this.shootingEntity != null && var4.entityHit != this.shootingEntity && var4.entityHit instanceof EntityPlayer && this.shootingEntity instanceof EntityPlayerMP) {
            }
          }
          if (!(var4.entityHit instanceof EntityEnderman)) {
            this.setDead();
          }
        }
 else {
          this.motionX*=-0.10000000149011612D;
          this.motionY*=-0.10000000149011612D;
          this.motionZ*=-0.10000000149011612D;
          this.rotationYaw+=180.0F;
          this.prevRotationYaw+=180.0F;
          this.ticksInAir=0;
        }
      }
 else {
        this.xTile=var4.blockX;
        this.yTile=var4.blockY;
        this.zTile=var4.blockZ;
        this.inTile=this.worldObj.getBlock(this.xTile,this.yTile,this.zTile);
        this.inData=this.worldObj.getBlockMetadata(this.xTile,this.yTile,this.zTile);
        this.motionX=(double)((float)(var4.hitVec.xCoord - this.posX));
        this.motionY=(double)((float)(var4.hitVec.yCoord - this.posY));
        this.motionZ=(double)((float)(var4.hitVec.zCoord - this.posZ));
        var20=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
        this.posX-=this.motionX / (double)var20 * 0.05000000074505806D;
        this.posY-=this.motionY / (double)var20 * 0.05000000074505806D;
        this.posZ-=this.motionZ / (double)var20 * 0.05000000074505806D;
        this.inGround=true;
        this.arrowShake=7;
        if (this.inTile != null) {
          this.inTile.onEntityCollidedWithBlock(this.worldObj,this.xTile,this.yTile,this.zTile,this);
        }
      }
    }
    this.posX+=this.motionX;
    this.posY+=this.motionY;
    this.posZ+=this.motionZ;
    var20=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
    this.rotationYaw=(float)(Math.atan2(this.motionX,this.motionZ) * 180.0D / Math.PI);
    for (this.rotationPitch=(float)(Math.atan2(this.motionY,(double)var20) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch-=360.0F) {
      ;
    }
    while (this.rotationPitch - this.prevRotationPitch >= 180.0F) {
      this.prevRotationPitch+=360.0F;
    }
    while (this.rotationYaw - this.prevRotationYaw < -180.0F) {
      this.prevRotationYaw-=360.0F;
    }
    while (this.rotationYaw - this.prevRotationYaw >= 180.0F) {
      this.prevRotationYaw+=360.0F;
    }
    this.rotationPitch=this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
    this.rotationYaw=this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
    float var22=0.99F;
    var11=0.05F;
    if (this.isInWater()) {
      for (int var25=0; var25 < 4; ++var25) {
        var26=0.25F;
        this.worldObj.spawnParticle(""String_Node_Str"",this.posX - this.motionX * (double)var26,this.posY - this.motionY * (double)var26,this.posZ - this.motionZ * (double)var26,this.motionX,this.motionY,this.motionZ);
      }
      var22=0.8F;
    }
    this.motionX*=(double)var22;
    this.motionY*=(double)var22;
    this.motionZ*=(double)var22;
    this.motionY-=(double)var11;
    this.setPosition(this.posX,this.posY,this.posZ);
  }
}","/** 
 * Called to update the entity's position/logic.
 */
public void onUpdate(){
  super.onUpdate();
  if (this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F) {
    float var1=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
    this.prevRotationYaw=this.rotationYaw=(float)(Math.atan2(this.motionX,this.motionZ) * 180.0D / Math.PI);
    this.prevRotationPitch=this.rotationPitch=(float)(Math.atan2(this.motionY,(double)var1) * 180.0D / Math.PI);
  }
  Block var16=this.worldObj.getBlock(this.xTile,this.yTile,this.zTile);
  if (var16 != Blocks.air && var16 != null) {
    var16.setBlockBoundsBasedOnState(this.worldObj,this.xTile,this.yTile,this.zTile);
    AxisAlignedBB var2=var16.getCollisionBoundingBoxFromPool(this.worldObj,this.xTile,this.yTile,this.zTile);
    if (var2 != null && var2.isVecInside(Vec3.createVectorHelper(this.posX,this.posY,this.posZ))) {
      this.inGround=true;
    }
  }
  if (this.arrowShake > 0) {
    --this.arrowShake;
  }
  if (this.inGround) {
    Block var18=this.worldObj.getBlock(this.xTile,this.yTile,this.zTile);
    int var19=this.worldObj.getBlockMetadata(this.xTile,this.yTile,this.zTile);
    if (var18 == this.inTile && var19 == this.inData) {
      ++this.ticksInGround;
      if (this.ticksInGround == 1) {
        this.setDead();
      }
    }
 else {
      this.inGround=false;
      this.motionX*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionY*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionZ*=(double)(this.rand.nextFloat() * 0.2F);
      this.ticksInGround=0;
      this.ticksInAir=0;
    }
  }
 else {
    ++this.ticksInAir;
    Vec3 var17=Vec3.createVectorHelper(this.posX,this.posY,this.posZ);
    Vec3 var3=Vec3.createVectorHelper(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
    MovingObjectPosition var4=this.worldObj.rayTraceBlocks(var17,var3,false);
    var17=Vec3.createVectorHelper(this.posX,this.posY,this.posZ);
    var3=Vec3.createVectorHelper(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
    if (var4 != null) {
      var3=Vec3.createVectorHelper(var4.hitVec.xCoord,var4.hitVec.yCoord,var4.hitVec.zCoord);
    }
    Entity var5=null;
    List var6=this.worldObj.getEntitiesWithinAABBExcludingEntity(this,this.boundingBox.addCoord(this.motionX,this.motionY,this.motionZ).expand(1.0D,1.0D,1.0D));
    double var7=0.0D;
    int var9;
    float var11;
    for (var9=0; var9 < var6.size(); ++var9) {
      Entity var10=(Entity)var6.get(var9);
      if (var10.canBeCollidedWith() && (var10 != this.shootingEntity || this.ticksInAir >= 5)) {
        var11=0.3F;
        AxisAlignedBB var12=var10.boundingBox.expand((double)var11,(double)var11,(double)var11);
        MovingObjectPosition var13=var12.calculateIntercept(var17,var3);
        if (var13 != null) {
          double var14=var17.distanceTo(var13.hitVec);
          if (var14 < var7 || var7 == 0.0D) {
            var5=var10;
            var7=var14;
          }
        }
      }
    }
    if (var5 != null) {
      var4=new MovingObjectPosition(var5);
    }
    float var20;
    float var26;
    if (var4 != null) {
      if (var4.entityHit != null) {
        var20=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
        int var23=(int)this.damage;
        DamageSource var21=null;
        if (this.shootingEntity == null) {
          var21=DamageSource.causeThrownDamage(this,this);
        }
 else {
          var21=DamageSource.causeThrownDamage(this,this.shootingEntity);
        }
        if (this.isBurning() && !(var4.entityHit instanceof EntityEnderman)) {
          var4.entityHit.setFire(5);
        }
        if (var4.entityHit.attackEntityFrom(var21,var23)) {
          if (var4.entityHit instanceof EntityLiving) {
            EntityLiving var24=(EntityLiving)var4.entityHit;
            if (!this.worldObj.isRemote) {
              var24.setArrowCountInEntity(var24.getArrowCountInEntity() + 1);
            }
            if (this.knockbackStrength > 0) {
              var26=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
              if (var26 > 0.0F) {
              }
            }
            if (this.shootingEntity != null) {
            }
            if (this.shootingEntity != null && var4.entityHit != this.shootingEntity && var4.entityHit instanceof EntityPlayer && this.shootingEntity instanceof EntityPlayerMP) {
            }
          }
          if (!(var4.entityHit instanceof EntityEnderman)) {
            this.setDead();
          }
        }
 else {
          this.motionX*=-0.10000000149011612D;
          this.motionY*=-0.10000000149011612D;
          this.motionZ*=-0.10000000149011612D;
          this.rotationYaw+=180.0F;
          this.prevRotationYaw+=180.0F;
          this.ticksInAir=0;
        }
      }
 else {
        this.xTile=var4.blockX;
        this.yTile=var4.blockY;
        this.zTile=var4.blockZ;
        this.inTile=this.worldObj.getBlock(this.xTile,this.yTile,this.zTile);
        this.inData=this.worldObj.getBlockMetadata(this.xTile,this.yTile,this.zTile);
        this.motionX=(double)((float)(var4.hitVec.xCoord - this.posX));
        this.motionY=(double)((float)(var4.hitVec.yCoord - this.posY));
        this.motionZ=(double)((float)(var4.hitVec.zCoord - this.posZ));
        var20=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ);
        this.posX-=this.motionX / (double)var20 * 0.05000000074505806D;
        this.posY-=this.motionY / (double)var20 * 0.05000000074505806D;
        this.posZ-=this.motionZ / (double)var20 * 0.05000000074505806D;
        this.inGround=true;
        this.arrowShake=7;
        if (this.inTile != null) {
          this.inTile.onEntityCollidedWithBlock(this.worldObj,this.xTile,this.yTile,this.zTile,this);
        }
      }
    }
    this.posX+=this.motionX;
    this.posY+=this.motionY;
    this.posZ+=this.motionZ;
    var20=MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
    this.rotationYaw=(float)(Math.atan2(this.motionX,this.motionZ) * 180.0D / Math.PI);
    for (this.rotationPitch=(float)(Math.atan2(this.motionY,(double)var20) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch-=360.0F) {
      ;
    }
    while (this.rotationPitch - this.prevRotationPitch >= 180.0F) {
      this.prevRotationPitch+=360.0F;
    }
    while (this.rotationYaw - this.prevRotationYaw < -180.0F) {
      this.prevRotationYaw-=360.0F;
    }
    while (this.rotationYaw - this.prevRotationYaw >= 180.0F) {
      this.prevRotationYaw+=360.0F;
    }
    this.rotationPitch=this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
    this.rotationYaw=this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
    float var22=0.99F;
    var11=0.05F;
    if (this.isInWater()) {
      for (int var25=0; var25 < 4; ++var25) {
        var26=0.25F;
        this.worldObj.spawnParticle(""String_Node_Str"",this.posX - this.motionX * (double)var26,this.posY - this.motionY * (double)var26,this.posZ - this.motionZ * (double)var26,this.motionX,this.motionY,this.motionZ);
      }
      var22=0.8F;
    }
    this.motionX*=(double)var22;
    this.motionY*=(double)var22;
    this.motionZ*=(double)var22;
    this.motionY-=(double)var11;
    this.setPosition(this.posX,this.posY,this.posZ);
  }
}",0.94831223628692
22482,"@SideOnly(Side.CLIENT) public AxisAlignedBB getRenderBoundingBox(){
  return AxisAlignedBB.getAABBPool().getAABB(this.xCoord,this.yCoord,this.zCoord,this.xCoord + 1,this.yCoord + 5,this.zCoord + 1);
}","@SideOnly(Side.CLIENT) public AxisAlignedBB getRenderBoundingBox(){
  return AxisAlignedBB.getBoundingBox(this.xCoord,this.yCoord,this.zCoord,this.xCoord + 1,this.yCoord + 5,this.zCoord + 1);
}",0.9414758269720102
22483,"private void spawnItems(int x,int y,int z){
  int id=OreDictionary.getOreID(new ItemStack(smooshingBlock.getItem(worldObj,x,y,z),1,smooshingMeta));
  if (ItemSmashedOre.oreTypesFromOre.containsKey(OreDictionary.getOreName(id))) {
    boolean doubleItems=worldObj.rand.nextInt(5) == 0;
    ItemStack items=new ItemStack(SteamcraftItems.smashedOre,doubleItems ? 2 : 1,ItemSmashedOre.oreTypesFromOre.get(OreDictionary.getOreName(id)));
    EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.5F,z + 0.5F,items);
    this.worldObj.spawnEntityInWorld(entityItem);
  }
 else {
    smooshingBlock.dropBlockAsItem(worldObj,x,y,z,this.smooshingMeta,0);
  }
}","private void spawnItems(int x,int y,int z){
  int id[]=OreDictionary.getOreIDs(this.smooshedStack);
  if (id.length > 0 && ItemSmashedOre.oreTypesFromOre.containsKey(OreDictionary.getOreName(id[0]))) {
    boolean doubleItems=worldObj.rand.nextInt(3) == 0;
    ItemStack items=new ItemStack(SteamcraftItems.smashedOre,doubleItems ? 2 : 1,ItemSmashedOre.oreTypesFromOre.get(OreDictionary.getOreName(id[0])));
    EntityItem entityItem=new EntityItem(this.worldObj,x + 0.5F,y + 0.5F,z + 0.5F,items);
    this.worldObj.spawnEntityInWorld(entityItem);
    this.smooshedStack=null;
  }
 else {
    smooshingBlock.dropBlockAsItem(worldObj,x,y,z,this.smooshingMeta,0);
  }
}",0.2030075187969924
22484,"public void updateEntity(){
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  if (extendedTicks == 3 && this.worldObj.isRemote) {
    for (int i=0; i < 10; i++) {
    }
  }
  if (this.hasBlockUpdate && this.hasPartner()) {
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
 else   if (this.shouldStop) {
    this.spinup=0;
    this.extendedLength=0;
    this.extendedTicks=0;
    this.isActive=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          this.smooshingBlock=worldObj.getBlock(x,y,z);
          this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
          worldObj.setBlockToAir(x,y,z);
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
      }
    }
    this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
}","public void updateEntity(){
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  if (extendedTicks == 3 && this.worldObj.isRemote) {
    for (int i=0; i < 10; i++) {
    }
  }
  if (this.hasBlockUpdate && this.hasPartner()) {
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
 else   if (this.shouldStop) {
    this.spinup=0;
    this.extendedLength=0;
    this.extendedTicks=0;
    this.isActive=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          this.smooshingBlock=worldObj.getBlock(x,y,z);
          this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
          this.smooshedStack=new ItemStack(smooshingBlock.getItem(worldObj,x,y,z),1,smooshingMeta);
          worldObj.setBlockToAir(x,y,z);
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
      }
    }
    this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
}",0.935064935064935
22485,"private void decodeAndCreateParticles(int flags){
  if (worldObj.isRemote) {
    boolean smash=(flags & 1) == 1;
    boolean smoke1=((flags & 2) >> 1) == 1;
    boolean smoke2=((flags & 4) >> 2) == 1;
    boolean smoke3=((flags & 8) >> 3) == 1;
    int[] tgt=getTarget(1);
    int x=tgt[0], y=yCoord, z=tgt[1];
    if (smash) {
      System.out.println(""String_Node_Str"");
      worldObj.spawnParticle(""String_Node_Str"",x + 0.5D,y + 1D,z + 0.5D,(float)(Math.random() - 0.5F) / 3.0F,(float)(Math.random() - 0.5F) / 3.0F,(float)(Math.random() - 0.5F) / 3.0F);
      worldObj.spawnParticle(""String_Node_Str"",x + 0.5D,y + 1D,z + 0.5D,(float)(Math.random() - 0.5F) / 6.0F,(float)(Math.random() - 0.5F) / 6.0F,(float)(Math.random() - 0.5F) / 6.0F);
      worldObj.spawnParticle(""String_Node_Str"",x + 0.5D,y + 1D,z + 0.5D,(float)(Math.random() - 0.5F) / 12.0F,(float)(Math.random() - 0.5F) / 12.0F,(float)(Math.random() - 0.5F) / 12.0F);
    }
  }
}","private void decodeAndCreateParticles(int flags){
  if (worldObj.isRemote) {
    boolean smash=(flags & 1) == 1;
    boolean smoke1=((flags & 2) >> 1) == 1;
    boolean smoke2=((flags & 4) >> 2) == 1;
    boolean smoke3=((flags & 8) >> 3) == 1;
    int[] tgt=getTarget(1);
    int x=tgt[0], y=yCoord, z=tgt[1];
    if (smash) {
      System.out.println((float)(Math.random() - 0.5F) / 3.0F);
    }
    if (smoke1) {
      float xV=0F, zV=0F;
switch (getBlockMetadata()) {
case 2:
        zV=0.05F;
      break;
case 3:
    zV=-0.05F;
  break;
case 4:
xV=0.05F;
break;
case 5:
xV=-0.05F;
break;
default :
break;
}
worldObj.spawnParticle(""String_Node_Str"",xCoord + 0.5D,y + 1.1D,zCoord + 0.5D,xV,0.05F,zV);
}
}
}",0.4891041162227603
22486,"public void updateEntity(){
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  if (extendedTicks == 3 && this.worldObj.isRemote) {
    for (int i=0; i < 10; i++) {
    }
  }
  if (this.hasBlockUpdate && this.hasPartner()) {
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
 else   if (this.shouldStop) {
    this.spinup=0;
    this.extendedLength=0;
    this.extendedTicks=0;
    this.isActive=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          this.smooshingBlock=worldObj.getBlock(x,y,z);
          this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
          this.smooshedStack=new ItemStack(smooshingBlock.getItem(worldObj,x,y,z),1,smooshingMeta);
          worldObj.setBlockToAir(x,y,z);
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
      }
    }
    this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
}","public void updateEntity(){
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  if (this.hasBlockUpdate && this.hasPartner()) {
    if (this.shouldStop) {
      System.out.println(""String_Node_Str"");
      this.spinup=0;
      this.extendedLength=0;
      this.extendedTicks=0;
      this.isActive=false;
      this.shouldStop=false;
      this.isBreaking=false;
      return;
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          if (!worldObj.isAirBlock(x,y,z)) {
            this.smooshingBlock=worldObj.getBlock(x,y,z);
            this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
            this.smooshedStack=new ItemStack(smooshingBlock.getItem(worldObj,x,y,z),1,smooshingMeta);
            this.spinup++;
            if (this.getBlockMetadata() % 2 == 0)             worldObj.setBlockToAir(x,y,z);
          }
 else {
            if (this.hasPartner()) {
              int[] pc=getTarget(2);
              TileEntitySmasher partner=(TileEntitySmasher)worldObj.getTileEntity(pc[0],yCoord,pc[1]);
              if (partner.spinup == 40 || (partner.spinup == 41 && partner.shouldStop)) {
                this.shouldStop=true;
                this.spinup++;
                return;
              }
            }
          }
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
      }
    }
    this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
}",0.5428350913300746
22487,"private int encodeParticles(){
  int smash=0, smoke1=0, smoke2=0, smoke3=0;
  if (!worldObj.isRemote) {
    if (extendedTicks == 3)     smash=1;
  }
  return smash + smoke1 + smoke2+ smoke3;
}","private int encodeParticles(){
  int smash=0, smoke1=0, smoke2=0, smoke3=0;
  if (!worldObj.isRemote) {
    if (extendedTicks == 3)     smash=1;
    if (extendedTicks >= 8 && extendedTicks <= 16 && (extendedTicks % 4) == 0)     smoke1=2;
  }
  return smash + smoke1 + smoke2+ smoke3;
}",0.8050314465408805
22488,"/** 
 * Draw the background layer for the GuiContainer (everything behind the items)
 */
protected void drawGuiContainerBackgroundLayer(float par1,int par2,int par3){
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  this.mc.getTextureManager().bindTexture(furnaceGuiTextures);
  int k=(this.width - this.xSize) / 2;
  int l=(this.height - this.ySize) / 2;
  GL11.glEnable(3042);
  this.drawTexturedModalRect(k,l,0,0,this.xSize,this.ySize);
  int i1;
  i1=this.furnaceInventory.getBurnTimeRemainingScaled(14);
  this.drawTexturedModalRect(k + 58,l + 15 + 14 - i1,176,14 - i1,14,i1);
  GL11.glDisable(3042);
  float fill=(this.furnaceInventory.getTankInfo(ForgeDirection.UP)[0].fluid.amount / 10000.0F);
  drawFluid(new FluidStack(FluidRegistry.WATER,1),(int)(fill * 58.0F),k + 81,l + 14,16,58);
  this.mc.getTextureManager().bindTexture(furnaceGuiTextures);
  this.drawTexturedModalRect(k + 80,l + 13,190,0,18,60);
  fill=(float)this.furnaceInventory.steam / (float)this.furnaceInventory.getCapacity();
  FluidStack stack=new FluidStack(FluidRegistry.WATER,1);
  if (FluidRegistry.isFluidRegistered(""String_Node_Str"")) {
    stack=new FluidStack(FluidRegistry.getFluid(""String_Node_Str""),1);
  }
  drawFluid(stack,(int)(fill * 58.0F),k + 104,l + 14,16,58);
  this.mc.getTextureManager().bindTexture(furnaceGuiTextures);
  this.drawTexturedModalRect(k + 103,l + 13,190,0,18,60);
  GL11.glDisable(3042);
}","/** 
 * Draw the background layer for the GuiContainer (everything behind the items)
 */
protected void drawGuiContainerBackgroundLayer(float par1,int par2,int par3){
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  this.mc.getTextureManager().bindTexture(furnaceGuiTextures);
  int k=(this.width - this.xSize) / 2;
  int l=(this.height - this.ySize) / 2;
  GL11.glEnable(3042);
  this.drawTexturedModalRect(k,l,0,0,this.xSize,this.ySize);
  int i1;
  i1=this.furnaceInventory.getBurnTimeRemainingScaled(14);
  this.drawTexturedModalRect(k + 58,l + 15 + 14 - i1,176,14 - i1,14,i1);
  GL11.glDisable(3042);
  float fill=(this.furnaceInventory.getTankInfo(ForgeDirection.UP)[0].fluid.amount / 10000.0F);
  drawFluid(new FluidStack(FluidRegistry.WATER,1),(int)(fill * 58.0F),k + 81,l + 14,16,58);
  this.mc.getTextureManager().bindTexture(furnaceGuiTextures);
  this.drawTexturedModalRect(k + 80,l + 13,190,0,18,60);
  fill=(float)this.furnaceInventory.steam / (float)this.furnaceInventory.getCapacity();
  fill=Math.min(fill,1.0F);
  FluidStack stack=new FluidStack(FluidRegistry.WATER,1);
  if (FluidRegistry.isFluidRegistered(""String_Node_Str"")) {
    stack=new FluidStack(FluidRegistry.getFluid(""String_Node_Str""),1);
  }
  drawFluid(stack,(int)(fill * 58.0F),k + 104,l + 14,16,58);
  this.mc.getTextureManager().bindTexture(furnaceGuiTextures);
  this.drawTexturedModalRect(k + 103,l + 13,190,0,18,60);
  GL11.glDisable(3042);
}",0.9900568181818182
22489,"@Override public void readFromNBT(NBTTagCompound par1NBTTagCompound){
  super.readFromNBT(par1NBTTagCompound);
  NBTTagList nbttaglist=(NBTTagList)par1NBTTagCompound.getTag(""String_Node_Str"");
  this.furnaceItemStacks=new ItemStack[this.getSizeInventory()];
  for (int i=0; i < nbttaglist.tagCount(); ++i) {
    NBTTagCompound nbttagcompound1=(NBTTagCompound)nbttaglist.getCompoundTagAt(i);
    byte b0=nbttagcompound1.getByte(""String_Node_Str"");
    if (b0 >= 0 && b0 < this.furnaceItemStacks.length) {
      this.furnaceItemStacks[b0]=ItemStack.loadItemStackFromNBT(nbttagcompound1);
    }
  }
  this.furnaceBurnTime=par1NBTTagCompound.getShort(""String_Node_Str"");
  this.furnaceCookTime=par1NBTTagCompound.getShort(""String_Node_Str"");
  if (par1NBTTagCompound.hasKey(""String_Node_Str"")) {
    this.field_145958_o=par1NBTTagCompound.getString(""String_Node_Str"");
  }
  if (par1NBTTagCompound.hasKey(""String_Node_Str"")) {
    this.myTank.setFluid(new FluidStack(FluidRegistry.WATER,par1NBTTagCompound.getShort(""String_Node_Str"")));
  }
  if (par1NBTTagCompound.hasKey(""String_Node_Str"")) {
    this.steam=par1NBTTagCompound.getShort(""String_Node_Str"");
  }
}","@Override public void readFromNBT(NBTTagCompound par1NBTTagCompound){
  super.readFromNBT(par1NBTTagCompound);
  NBTTagList nbttaglist=(NBTTagList)par1NBTTagCompound.getTag(""String_Node_Str"");
  this.furnaceItemStacks=new ItemStack[this.getSizeInventory()];
  for (int i=0; i < nbttaglist.tagCount(); ++i) {
    NBTTagCompound nbttagcompound1=(NBTTagCompound)nbttaglist.getCompoundTagAt(i);
    byte b0=nbttagcompound1.getByte(""String_Node_Str"");
    if (b0 >= 0 && b0 < this.furnaceItemStacks.length) {
      this.furnaceItemStacks[b0]=ItemStack.loadItemStackFromNBT(nbttagcompound1);
    }
  }
  this.furnaceBurnTime=par1NBTTagCompound.getShort(""String_Node_Str"");
  this.furnaceCookTime=par1NBTTagCompound.getShort(""String_Node_Str"");
  this.currentItemBurnTime=par1NBTTagCompound.getShort(""String_Node_Str"");
  if (par1NBTTagCompound.hasKey(""String_Node_Str"")) {
    this.field_145958_o=par1NBTTagCompound.getString(""String_Node_Str"");
  }
  if (par1NBTTagCompound.hasKey(""String_Node_Str"")) {
    this.myTank.setFluid(new FluidStack(FluidRegistry.WATER,par1NBTTagCompound.getShort(""String_Node_Str"")));
  }
  if (par1NBTTagCompound.hasKey(""String_Node_Str"")) {
    this.steam=par1NBTTagCompound.getShort(""String_Node_Str"");
  }
}",0.9686585875470122
22490,"@Override public Packet getDescriptionPacket(){
  super.getDescriptionPacket();
  NBTTagCompound access=new NBTTagCompound();
  access.setInteger(""String_Node_Str"",steam);
  access.setInteger(""String_Node_Str"",myTank.getFluidAmount());
  access.setShort(""String_Node_Str"",(short)this.furnaceBurnTime);
  access.setShort(""String_Node_Str"",(short)this.furnaceCookTime);
  return new S35PacketUpdateTileEntity(xCoord,yCoord,zCoord,1,access);
}","@Override public Packet getDescriptionPacket(){
  super.getDescriptionPacket();
  NBTTagCompound access=new NBTTagCompound();
  access.setInteger(""String_Node_Str"",steam);
  access.setInteger(""String_Node_Str"",myTank.getFluidAmount());
  access.setShort(""String_Node_Str"",(short)this.furnaceBurnTime);
  access.setShort(""String_Node_Str"",(short)this.furnaceCookTime);
  access.setShort(""String_Node_Str"",(short)this.currentItemBurnTime);
  return new S35PacketUpdateTileEntity(xCoord,yCoord,zCoord,1,access);
}",0.9263157894736842
22491,"@Override public void onDataPacket(NetworkManager net,S35PacketUpdateTileEntity pkt){
  super.onDataPacket(net,pkt);
  NBTTagCompound access=pkt.func_148857_g();
  this.steam=access.getInteger(""String_Node_Str"");
  this.myTank.setFluid(new FluidStack(FluidRegistry.WATER,access.getInteger(""String_Node_Str"")));
  this.furnaceBurnTime=access.getShort(""String_Node_Str"");
  this.furnaceCookTime=access.getShort(""String_Node_Str"");
  worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}","@Override public void onDataPacket(NetworkManager net,S35PacketUpdateTileEntity pkt){
  super.onDataPacket(net,pkt);
  NBTTagCompound access=pkt.func_148857_g();
  this.steam=access.getInteger(""String_Node_Str"");
  this.myTank.setFluid(new FluidStack(FluidRegistry.WATER,access.getInteger(""String_Node_Str"")));
  this.furnaceBurnTime=access.getShort(""String_Node_Str"");
  this.currentItemBurnTime=access.getShort(""String_Node_Str"");
  this.furnaceCookTime=access.getShort(""String_Node_Str"");
  worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}",0.9387755102040816
22492,"@Override public void writeToNBT(NBTTagCompound par1NBTTagCompound){
  super.writeToNBT(par1NBTTagCompound);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.furnaceBurnTime);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)myTank.getFluidAmount());
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.steam);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.furnaceCookTime);
  NBTTagList nbttaglist=new NBTTagList();
  for (int i=0; i < this.furnaceItemStacks.length; ++i) {
    if (this.furnaceItemStacks[i] != null) {
      NBTTagCompound nbttagcompound1=new NBTTagCompound();
      nbttagcompound1.setByte(""String_Node_Str"",(byte)i);
      this.furnaceItemStacks[i].writeToNBT(nbttagcompound1);
      nbttaglist.appendTag(nbttagcompound1);
    }
  }
  par1NBTTagCompound.setTag(""String_Node_Str"",nbttaglist);
  if (this.hasCustomInventoryName()) {
    par1NBTTagCompound.setString(""String_Node_Str"",this.field_145958_o);
  }
}","@Override public void writeToNBT(NBTTagCompound par1NBTTagCompound){
  super.writeToNBT(par1NBTTagCompound);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.furnaceBurnTime);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)myTank.getFluidAmount());
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.steam);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.furnaceCookTime);
  par1NBTTagCompound.setShort(""String_Node_Str"",(short)this.currentItemBurnTime);
  NBTTagList nbttaglist=new NBTTagList();
  for (int i=0; i < this.furnaceItemStacks.length; ++i) {
    if (this.furnaceItemStacks[i] != null) {
      NBTTagCompound nbttagcompound1=new NBTTagCompound();
      nbttagcompound1.setByte(""String_Node_Str"",(byte)i);
      this.furnaceItemStacks[i].writeToNBT(nbttagcompound1);
      nbttaglist.appendTag(nbttagcompound1);
    }
  }
  par1NBTTagCompound.setTag(""String_Node_Str"",nbttaglist);
  if (this.hasCustomInventoryName()) {
    par1NBTTagCompound.setString(""String_Node_Str"",this.field_145958_o);
  }
}",0.9593657086223984
22493,"@Override public void updateEntity(){
  UtilSteamTransport.generalDistributionEvent(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.UP});
  UtilSteamTransport.generalPressureEvent(worldObj,xCoord,yCoord,zCoord,this.getPressure(),this.getCapacity());
  if (this.getStackInSlot(1) != null) {
    if (this.getStackInSlot(1).getItem() == Items.water_bucket || (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)) != null && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)).getFluid() == FluidRegistry.WATER)) {
      if (canDrainItem(this.getStackInSlot(1))) {
        if (this.getStackInSlot(1).getItem() == Items.water_bucket) {
          this.setInventorySlotContents(1,new ItemStack(Items.bucket));
          this.myTank.fill(new FluidStack(FluidRegistry.WATER,1000),true);
        }
        if (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem) {
          int maxDrain=this.getTankInfo(ForgeDirection.UP)[0].capacity - this.getTankInfo(ForgeDirection.UP)[0].fluid.amount;
          this.myTank.fill(new FluidStack(FluidRegistry.WATER,((IFluidContainerItem)this.getStackInSlot(1).getItem()).drain(this.getStackInSlot(1),maxDrain,true).amount),true);
        }
      }
    }
  }
  boolean flag=this.furnaceBurnTime > 0;
  boolean flag1=false;
  if (this.furnaceBurnTime > 0) {
    --this.furnaceBurnTime;
  }
  if (!this.worldObj.isRemote) {
    if (this.furnaceBurnTime == 0 && this.canSmelt()) {
      this.currentItemBurnTime=this.furnaceBurnTime=getItemBurnTime(this.furnaceItemStacks[0]);
      if (this.furnaceBurnTime > 0) {
        flag1=true;
        if (this.furnaceItemStacks[0] != null) {
          --this.furnaceItemStacks[0].stackSize;
          if (this.furnaceItemStacks[0].stackSize == 0) {
            this.furnaceItemStacks[0]=furnaceItemStacks[0].getItem().getContainerItem(furnaceItemStacks[0]);
          }
        }
      }
    }
    if (this.isBurning() && this.canSmelt()) {
      ++this.furnaceCookTime;
      if (this.furnaceCookTime > 0) {
        this.furnaceCookTime=0;
        this.steam+=1;
        this.myTank.drain(2,true);
        flag1=true;
      }
    }
 else {
      this.furnaceCookTime=0;
    }
    if (flag != this.furnaceBurnTime > 0) {
      flag1=true;
      BlockBoiler.updateFurnaceBlockState(this.furnaceBurnTime > 0,this.worldObj,this.xCoord,this.yCoord,this.zCoord);
    }
  }
  if (!this.worldObj.isRemote) {
  }
  this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}","@Override public void updateEntity(){
  UtilSteamTransport.generalDistributionEvent(worldObj,xCoord,yCoord,zCoord,new ForgeDirection[]{ForgeDirection.UP});
  UtilSteamTransport.generalPressureEvent(worldObj,xCoord,yCoord,zCoord,this.getPressure(),this.getCapacity());
  if (this.getStackInSlot(1) != null) {
    if (this.getStackInSlot(1).getItem() == Items.water_bucket || (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)) != null && ((IFluidContainerItem)this.getStackInSlot(1).getItem()).getFluid(this.getStackInSlot(1)).getFluid() == FluidRegistry.WATER)) {
      if (canDrainItem(this.getStackInSlot(1))) {
        if (this.getStackInSlot(1).getItem() == Items.water_bucket) {
          this.setInventorySlotContents(1,new ItemStack(Items.bucket));
          this.myTank.fill(new FluidStack(FluidRegistry.WATER,1000),true);
        }
        if (this.getStackInSlot(1).getItem() instanceof IFluidContainerItem) {
          int maxDrain=this.getTankInfo(ForgeDirection.UP)[0].capacity - this.getTankInfo(ForgeDirection.UP)[0].fluid.amount;
          this.myTank.fill(new FluidStack(FluidRegistry.WATER,((IFluidContainerItem)this.getStackInSlot(1).getItem()).drain(this.getStackInSlot(1),maxDrain,true).amount),true);
        }
      }
    }
  }
  boolean flag=this.furnaceBurnTime > 0;
  boolean flag1=false;
  int maxThisTick=10;
  if (this.furnaceBurnTime > 0) {
    this.furnaceBurnTime-=1;
  }
  if (!this.worldObj.isRemote) {
    if (this.furnaceBurnTime == 0 && this.canSmelt()) {
      this.currentItemBurnTime=this.furnaceBurnTime=getItemBurnTime(this.furnaceItemStacks[0]);
      if (this.furnaceBurnTime > 0) {
        flag1=true;
        if (this.furnaceItemStacks[0] != null) {
          --this.furnaceItemStacks[0].stackSize;
          if (this.furnaceItemStacks[0].stackSize == 0) {
            this.furnaceItemStacks[0]=furnaceItemStacks[0].getItem().getContainerItem(furnaceItemStacks[0]);
          }
        }
      }
    }
    if (this.isBurning() && this.canSmelt()) {
      ++this.furnaceCookTime;
      if (this.furnaceCookTime > 0) {
        this.steam+=1;
        this.myTank.drain(2,true);
        this.furnaceCookTime=0;
        flag1=true;
      }
    }
 else {
      this.furnaceCookTime=0;
    }
    if (flag != this.furnaceBurnTime > 0) {
      flag1=true;
      BlockBoiler.updateFurnaceBlockState(this.furnaceBurnTime > 0,this.worldObj,this.xCoord,this.yCoord,this.zCoord);
    }
  }
  if (!this.worldObj.isRemote) {
  }
  this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}",0.9753015508328546
22494,"@Override public void updateEntity(){
  UtilSteamTransport.generalDistributionEvent(worldObj,xCoord,yCoord,zCoord,ForgeDirection.values());
  UtilSteamTransport.generalPressureEvent(worldObj,xCoord,yCoord,zCoord,this.getPressure(),this.getCapacity());
  ForgeDirection inputDir=this.getOutputDirection().getOpposite();
  int x=this.xCoord + inputDir.offsetX;
  int y=this.yCoord + inputDir.offsetY;
  int z=this.zCoord + inputDir.offsetZ;
  if (this.steam >= 10 && myTank.getFluidAmount() == 0 && this.worldObj.getBlockMetadata(x,y,z) == 0 && FluidRegistry.lookupFluidForBlock(this.worldObj.getBlock(x,y,z)) != null) {
    Fluid fluid=FluidRegistry.lookupFluidForBlock(this.worldObj.getBlock(x,y,z));
    if (myTank.getFluidAmount() < 1000) {
      this.myTank.fill(new FluidStack(fluid,1000),true);
      this.worldObj.setBlockToAir(x,y,z);
      progress=0;
      steam-=10;
    }
  }
  if (myTank.getFluidAmount() > 0 && myTank.getFluid() != null && progress < 100) {
    progress++;
  }
  ForgeDirection outputDir=this.getOutputDirection();
  int x2=this.xCoord + outputDir.offsetX;
  int y2=this.yCoord + outputDir.offsetY;
  int z2=this.zCoord + outputDir.offsetZ;
  if (myTank.getFluidAmount() > 0 && progress == 100 && this.worldObj.getTileEntity(x2,y2,z2) != null && this.worldObj.getTileEntity(x2,y2,z2) instanceof IFluidHandler) {
    IFluidHandler fluidHandler=(IFluidHandler)this.worldObj.getTileEntity(x2,y2,z2);
    if (fluidHandler.canFill(inputDir,myTank.getFluid().getFluid())) {
      int amnt=fluidHandler.fill(inputDir,this.myTank.getFluid(),true);
      this.myTank.drain(amnt,true);
      progress=0;
    }
  }
  this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}","@Override public void updateEntity(){
  UtilSteamTransport.generalDistributionEvent(worldObj,xCoord,yCoord,zCoord,ForgeDirection.values());
  UtilSteamTransport.generalPressureEvent(worldObj,xCoord,yCoord,zCoord,this.getPressure(),this.getCapacity());
  ForgeDirection inputDir=this.getOutputDirection().getOpposite();
  int x=this.xCoord + inputDir.offsetX;
  int y=this.yCoord + inputDir.offsetY;
  int z=this.zCoord + inputDir.offsetZ;
  if (this.steam >= 10 && myTank.getFluidAmount() == 0 && this.worldObj.getBlockMetadata(x,y,z) == 0 && FluidRegistry.lookupFluidForBlock(this.worldObj.getBlock(x,y,z)) != null) {
    Fluid fluid=FluidRegistry.lookupFluidForBlock(this.worldObj.getBlock(x,y,z));
    if (myTank.getFluidAmount() < 1000) {
      this.myTank.fill(new FluidStack(fluid,1000),true);
      this.worldObj.setBlockToAir(x,y,z);
      progress=0;
      steam-=10;
    }
  }
  if (myTank.getFluidAmount() > 0 && myTank.getFluid() != null && progress < 100) {
    progress++;
  }
  ForgeDirection outputDir=this.getOutputDirection();
  int x2=this.xCoord + outputDir.offsetX;
  int y2=this.yCoord + outputDir.offsetY;
  int z2=this.zCoord + outputDir.offsetZ;
  if (myTank.getFluidAmount() > 0 && progress == 100 && this.worldObj.getTileEntity(x2,y2,z2) != null && this.worldObj.getTileEntity(x2,y2,z2) instanceof IFluidHandler) {
    IFluidHandler fluidHandler=(IFluidHandler)this.worldObj.getTileEntity(x2,y2,z2);
    if (fluidHandler.canFill(inputDir,myTank.getFluid().getFluid())) {
      int amnt=fluidHandler.fill(inputDir,this.myTank.getFluid(),true);
      if (amnt > 0) {
        this.myTank.drain(1000,true);
        progress=0;
      }
    }
  }
  this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
}",0.9730994152046784
22495,"public void updateEntity(){
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  decodeAndCreateParticles(1);
  if (this.hasBlockUpdate && this.hasPartner()) {
    if (this.shouldStop) {
      System.out.println(""String_Node_Str"");
      this.spinup=0;
      this.extendedLength=0;
      this.extendedTicks=0;
      this.isActive=false;
      this.shouldStop=false;
      this.isBreaking=false;
      return;
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          if (!worldObj.isAirBlock(x,y,z) && worldObj.getBlock(x,y,z).getBlockHardness(worldObj,x,y,z) < 50F) {
            this.smooshingBlock=worldObj.getBlock(x,y,z);
            this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
            this.smooshedStack=new ItemStack(smooshingBlock.getItem(worldObj,x,y,z),1,smooshingMeta);
            this.spinup++;
            if (this.getBlockMetadata() % 2 == 0)             worldObj.setBlock(x,y,z,SteamcraftBlocks.dummy);
          }
 else {
            System.out.println(""String_Node_Str"");
            if (this.hasPartner()) {
              System.out.println(""String_Node_Str"");
              int[] pc=getTarget(2);
              TileEntitySmasher partner=(TileEntitySmasher)worldObj.getTileEntity(pc[0],yCoord,pc[1]);
              System.out.println(""String_Node_Str"" + partner.spinup);
              if (partner.spinup < 41) {
                System.out.println(""String_Node_Str"");
                this.shouldStop=true;
              }
              if (partner.spinup >= 41) {
                System.out.println(""String_Node_Str"");
                if (partner.shouldStop) {
                  System.out.println(""String_Node_Str"");
                  this.shouldStop=true;
                }
              }
              if (shouldStop) {
                this.spinup++;
                return;
              }
            }
          }
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F && !this.shouldStop) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
        if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy) {
          worldObj.setBlockToAir(x,y,z);
        }
      }
    }
    this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
}","public void updateEntity(){
  int[] target=getTarget(1);
  int x=target[0], y=yCoord, z=target[1];
  decodeAndCreateParticles(1);
  if (this.hasBlockUpdate && this.hasPartner()) {
    if (this.shouldStop) {
      System.out.println(""String_Node_Str"");
      this.spinup=0;
      this.extendedLength=0;
      this.extendedTicks=0;
      this.isActive=false;
      this.shouldStop=false;
      this.isBreaking=false;
      return;
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (this.hasSomethingToSmash() && !this.isActive) {
      this.isActive=true;
      this.isBreaking=true;
    }
    this.hasBlockUpdate=false;
  }
  if (this.isActive) {
    if (this.isBreaking) {
      if (this.spinup < 41) {
        if (this.spinup == 40) {
          if (!worldObj.isAirBlock(x,y,z) && worldObj.getBlock(x,y,z).getBlockHardness(worldObj,x,y,z) < 50F) {
            this.smooshingBlock=worldObj.getBlock(x,y,z);
            this.smooshingMeta=worldObj.getBlockMetadata(x,y,z);
            this.smooshedStack=new ItemStack(smooshingBlock.getItem(worldObj,x,y,z),1,smooshingMeta);
            this.spinup++;
            if (this.getBlockMetadata() % 2 == 0)             worldObj.setBlock(x,y,z,SteamcraftBlocks.dummy);
          }
 else {
            System.out.println(""String_Node_Str"");
            if (this.hasPartner()) {
              System.out.println(""String_Node_Str"");
              int[] pc=getTarget(2);
              TileEntitySmasher partner=(TileEntitySmasher)worldObj.getTileEntity(pc[0],yCoord,pc[1]);
              System.out.println(""String_Node_Str"" + partner.spinup);
              if (partner.spinup < 41) {
                System.out.println(""String_Node_Str"");
                this.shouldStop=true;
              }
              if (partner.spinup >= 41) {
                System.out.println(""String_Node_Str"");
                if (partner.shouldStop) {
                  System.out.println(""String_Node_Str"");
                  this.shouldStop=true;
                }
              }
              if (shouldStop) {
                this.spinup++;
                return;
              }
            }
          }
        }
        this.spinup++;
      }
 else       if (this.extendedLength < 0.5F && !this.shouldStop) {
        this.extendedLength+=0.1F;
        if (this.extendedTicks == 3) {
          if (this.getBlockMetadata() % 2 == 0 && !worldObj.isRemote)           spawnItems(x,y,z);
        }
        this.extendedTicks++;
      }
 else {
        this.isBreaking=false;
        this.spinup=0;
      }
    }
 else {
      if (this.extendedLength > 0.0F) {
        this.extendedLength-=0.025F;
        this.extendedTicks++;
        if (this.extendedLength < 0F)         this.extendedLength=0F;
      }
 else {
        this.isActive=false;
        this.extendedTicks=0;
        if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy) {
          worldObj.setBlockToAir(x,y,z);
        }
      }
    }
    this.worldObj.markBlockForUpdate(xCoord,yCoord,zCoord);
  }
 else   if (worldObj.getBlock(x,y,z) == SteamcraftBlocks.dummy && getBlockMetadata() % 2 == 0) {
    worldObj.setBlockToAir(x,y,z);
  }
}",0.9779292437520286
22496,"@SubscribeEvent @SideOnly(Side.CLIENT) public void tickStart(TickEvent.ClientTickEvent event){
  wasInUse=inUse;
  inUse=false;
  if (event.side == Side.CLIENT && Minecraft.getMinecraft().thePlayer != null) {
    EntityPlayer player=Minecraft.getMinecraft().thePlayer;
    if (SteamcraftEventHandler.hasPower(player,1) && player.getEquipmentInSlot(2) != null && player.getEquipmentInSlot(1).getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor chest=(ItemExosuitArmor)player.getEquipmentInSlot(2).getItem();
      if (player.worldObj.isRemote && chest.hasUpgrade(player.getEquipmentInSlot(2),SteamcraftItems.thrusters)) {
        if (!player.onGround && Math.abs(player.motionX) + Math.abs(player.motionZ) > 0.0F && !player.isInWater() && !(player.capabilities.isFlying)) {
          double rotation=Math.toRadians(player.renderYawOffset + 90.0F);
          double rotation2=Math.toRadians(player.renderYawOffset + 270.0F);
          player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.5 * Math.sin(rotation),player.posY - 1F,player.posZ - 0.5 * Math.cos(rotation),player.motionX * -0.1F,0,player.motionZ * -0.1F);
          player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.5 * Math.sin(rotation2),player.posY - 1F,player.posZ - 0.5 * Math.cos(rotation2),player.motionX * -0.1F,0,player.motionZ * -0.1F);
        }
      }
    }
    if (Minecraft.getMinecraft().gameSettings.keyBindJump.getIsKeyPressed()) {
      SteamcraftClientPacketHandler.sendSpacePacket(player);
      if (player != null) {
        ItemStack armor=player.getCurrentArmor(2);
        if (armor != null && armor.getItem() == SteamcraftItems.exoArmorBody) {
          ItemExosuitArmor item=(ItemExosuitArmor)armor.getItem();
          if (item.hasUpgrade(armor,SteamcraftItems.jetpack) && SteamcraftEventHandler.hasPower(player,5)) {
            if (!player.onGround && !player.capabilities.isFlying) {
              player.motionY=player.motionY + 0.06D;
              double rotation=Math.toRadians(player.renderYawOffset);
              player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation + 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation + 0.9F),0.0F,-1.0F,0.0F);
              player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation - 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation - 0.9F),0.0F,-1.0F,0.0F);
            }
          }
        }
      }
    }
 else {
    }
    ItemStack item=player.inventory.getStackInSlot(player.inventory.currentItem);
    if (item != null && item.getItem() == SteamcraftItems.spyglass) {
      if (Minecraft.getMinecraft().gameSettings.thirdPersonView == 0) {
        inUse=true;
        this.renderTelescopeOverlay();
      }
    }
    if (!wasInUse && item != null && item.getItem() == SteamcraftItems.musket && UtilEnhancements.getEnhancementFromItem(item) == SteamcraftItems.spyglass) {
      boolean isShooting=false;
      if (item.stackTagCompound != null) {
        NBTTagCompound nbt=item.getTagCompound();
        if (nbt.getInteger(""String_Node_Str"") > 0) {
          isShooting=true;
        }
      }
      if (isShooting && Minecraft.getMinecraft().gameSettings.thirdPersonView == 0) {
        inUse=true;
        Minecraft.getMinecraft().gameSettings.fovSetting=-0.85F;
        Minecraft.getMinecraft().gameSettings.mouseSensitivity-=0.3F;
        this.renderTelescopeOverlay();
      }
    }
  }
  if (!inUse && !wasInUse) {
    fov=Minecraft.getMinecraft().gameSettings.fovSetting;
    sensitivity=Minecraft.getMinecraft().gameSettings.mouseSensitivity;
  }
  if (!inUse && wasInUse) {
    Minecraft.getMinecraft().gameSettings.fovSetting=fov;
    Minecraft.getMinecraft().gameSettings.mouseSensitivity=sensitivity;
  }
  if (inUse && !wasInUse) {
    this.zoom=0.0F;
  }
  if (inUse && Minecraft.getMinecraft().gameSettings.keyBindAttack.getIsKeyPressed() && zoom > 0F) {
    this.zoom-=1.0F;
    Minecraft.getMinecraft().gameSettings.fovSetting+=0.05F;
    Minecraft.getMinecraft().gameSettings.mouseSensitivity+=0.01F;
  }
  if (inUse && Minecraft.getMinecraft().gameSettings.keyBindUseItem.getIsKeyPressed() && zoom < 34F) {
    this.zoom+=1.0F;
    Minecraft.getMinecraft().gameSettings.fovSetting-=0.05F;
    Minecraft.getMinecraft().gameSettings.mouseSensitivity-=0.01F;
  }
}","@SubscribeEvent @SideOnly(Side.CLIENT) public void tickStart(TickEvent.ClientTickEvent event){
  wasInUse=inUse;
  inUse=false;
  if (event.side == Side.CLIENT && Minecraft.getMinecraft().thePlayer != null) {
    EntityPlayer player=Minecraft.getMinecraft().thePlayer;
    if (SteamcraftEventHandler.hasPower(player,1) && player.getEquipmentInSlot(2) != null && player.getEquipmentInSlot(2).getItem() instanceof ItemExosuitArmor) {
      ItemExosuitArmor chest=(ItemExosuitArmor)player.getEquipmentInSlot(2).getItem();
      if (player.worldObj.isRemote && chest.hasUpgrade(player.getEquipmentInSlot(2),SteamcraftItems.thrusters)) {
        if (!player.onGround && Math.abs(player.motionX) + Math.abs(player.motionZ) > 0.0F && !player.isInWater() && !(player.capabilities.isFlying)) {
          double rotation=Math.toRadians(player.renderYawOffset + 90.0F);
          double rotation2=Math.toRadians(player.renderYawOffset + 270.0F);
          player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.5 * Math.sin(rotation),player.posY - 1F,player.posZ - 0.5 * Math.cos(rotation),player.motionX * -0.1F,0,player.motionZ * -0.1F);
          player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.5 * Math.sin(rotation2),player.posY - 1F,player.posZ - 0.5 * Math.cos(rotation2),player.motionX * -0.1F,0,player.motionZ * -0.1F);
        }
      }
    }
    if (Minecraft.getMinecraft().gameSettings.keyBindJump.getIsKeyPressed()) {
      SteamcraftClientPacketHandler.sendSpacePacket(player);
      if (player != null) {
        ItemStack armor=player.getCurrentArmor(2);
        if (armor != null && armor.getItem() == SteamcraftItems.exoArmorBody) {
          ItemExosuitArmor item=(ItemExosuitArmor)armor.getItem();
          if (item.hasUpgrade(armor,SteamcraftItems.jetpack) && SteamcraftEventHandler.hasPower(player,5)) {
            if (!player.onGround && !player.capabilities.isFlying) {
              player.motionY=player.motionY + 0.06D;
              double rotation=Math.toRadians(player.renderYawOffset);
              player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation + 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation + 0.9F),0.0F,-1.0F,0.0F);
              player.worldObj.spawnParticle(""String_Node_Str"",player.posX + 0.4 * Math.sin(rotation - 0.9F),player.posY - 1F,player.posZ - 0.4 * Math.cos(rotation - 0.9F),0.0F,-1.0F,0.0F);
            }
          }
        }
      }
    }
 else {
    }
    ItemStack item=player.inventory.getStackInSlot(player.inventory.currentItem);
    if (item != null && item.getItem() == SteamcraftItems.spyglass) {
      if (Minecraft.getMinecraft().gameSettings.thirdPersonView == 0) {
        inUse=true;
        this.renderTelescopeOverlay();
      }
    }
    if (!wasInUse && item != null && item.getItem() == SteamcraftItems.musket && UtilEnhancements.getEnhancementFromItem(item) == SteamcraftItems.spyglass) {
      boolean isShooting=false;
      if (item.stackTagCompound != null) {
        NBTTagCompound nbt=item.getTagCompound();
        if (nbt.getInteger(""String_Node_Str"") > 0) {
          isShooting=true;
        }
      }
      if (isShooting && Minecraft.getMinecraft().gameSettings.thirdPersonView == 0) {
        inUse=true;
        Minecraft.getMinecraft().gameSettings.fovSetting=-0.85F;
        Minecraft.getMinecraft().gameSettings.mouseSensitivity-=0.3F;
        this.renderTelescopeOverlay();
      }
    }
  }
  if (!inUse && !wasInUse) {
    fov=Minecraft.getMinecraft().gameSettings.fovSetting;
    sensitivity=Minecraft.getMinecraft().gameSettings.mouseSensitivity;
  }
  if (!inUse && wasInUse) {
    Minecraft.getMinecraft().gameSettings.fovSetting=fov;
    Minecraft.getMinecraft().gameSettings.mouseSensitivity=sensitivity;
  }
  if (inUse && !wasInUse) {
    this.zoom=0.0F;
  }
  if (inUse && Minecraft.getMinecraft().gameSettings.keyBindAttack.getIsKeyPressed() && zoom > 0F) {
    this.zoom-=1.0F;
    Minecraft.getMinecraft().gameSettings.fovSetting+=0.05F;
    Minecraft.getMinecraft().gameSettings.mouseSensitivity+=0.01F;
  }
  if (inUse && Minecraft.getMinecraft().gameSettings.keyBindUseItem.getIsKeyPressed() && zoom < 34F) {
    this.zoom+=1.0F;
    Minecraft.getMinecraft().gameSettings.fovSetting-=0.05F;
    Minecraft.getMinecraft().gameSettings.mouseSensitivity-=0.01F;
  }
}",0.9997695852534564
22497,"@Override protected void onCreate(Bundle tableSex){
  super.onCreate(tableSex);
  setContentView(R.layout.activity_list_songs);
  songListView=(ListView)findViewById(R.id.activity_list_songs_list);
  Intent intent=getIntent();
  Bundle bundle=intent.getExtras();
  if (bundle == null)   throw new RuntimeException(""String_Node_Str"");
  currentArtist=(String)bundle.get(""String_Node_Str"");
  if (currentArtist == null || currentArtist.isEmpty())   throw new RuntimeException(""String_Node_Str"");
  this.setTitle(currentArtist);
  if ((kMP.musicList != null) && (!kMP.musicList.isEmpty())) {
    items=kMP.songs.getAlbumsByArtist(currentArtist);
    items.add(0,getString(R.string.all_songs));
    final ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,items);
    songListView.setAdapter(adapter);
    songListView.setOnItemClickListener(this);
  }
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
}","@Override protected void onCreate(Bundle tableSex){
  super.onCreate(tableSex);
  setContentView(R.layout.activity_list_songs);
  songListView=(ListView)findViewById(R.id.activity_list_songs_list);
  Intent intent=getIntent();
  Bundle bundle=intent.getExtras();
  if (bundle == null)   throw new RuntimeException(""String_Node_Str"");
  currentArtist=(String)bundle.get(""String_Node_Str"");
  if (currentArtist == null || currentArtist.isEmpty())   throw new RuntimeException(""String_Node_Str"");
  this.setTitle(currentArtist);
  items=kMP.songs.getAlbumsByArtist(currentArtist);
  items.add(0,getString(R.string.all_songs));
  final ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,items);
  songListView.setAdapter(adapter);
  songListView.setOnItemClickListener(this);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
}",0.9536494405966968
22498,"/** 
 * Will be called when the music completes - either when the user presses 'next' or when the music ends or when the user selects another track.
 */
@Override public void onCompletion(MediaPlayer mp){
  serviceState=ServiceState.Playing;
  if (player.getCurrentPosition() <= 0)   return;
  broadcastCurrentState(ServicePlayMusic.BROADCAST_EXTRA_COMPLETED);
  if (repeatMode) {
    playSong();
    return;
  }
  next(false);
  if (kMP.musicService.currentSongPosition == 0) {
    if (kMP.settings.get(""String_Node_Str"",false))     playSong();
 else {
      stopSelf();
      currentSong=null;
    }
    return;
  }
  playSong();
}","/** 
 * Will be called when the music completes - either when the user presses 'next' or when the music ends or when the user selects another track.
 */
@Override public void onCompletion(MediaPlayer mp){
  serviceState=ServiceState.Playing;
  broadcastCurrentState(ServicePlayMusic.BROADCAST_EXTRA_COMPLETED);
  if (repeatMode) {
    playSong();
    return;
  }
  next(false);
  if (kMP.musicService.currentSongPosition == 0) {
    if (kMP.settings.get(""String_Node_Str"",false))     playSong();
 else     destroySelf();
    return;
  }
  playSong();
}",0.8793248945147679
22499,"/** 
 * Jumps to the next song on the list.
 * @note Remember to call `playSong()` to make the MusicPlayeractually play the music.
 */
public void next(){
  scrobbleCurrentSong(false);
  if (shuffleMode) {
    int newSongPosition=currentSongPosition;
    while (newSongPosition == currentSongPosition)     newSongPosition=random.nextInt(songs.size());
    currentSongPosition=newSongPosition;
    return;
  }
  currentSongPosition++;
  if (currentSongPosition >= songs.size())   currentSongPosition=0;
  kMP.nowPlayingIndex=currentSongPosition;
}","/** 
 * Jumps to the next song on the list.
 * @note Remember to call `playSong()` to make the MusicPlayeractually play the music.
 */
public void next(){
  scrobbleCurrentSong(false);
  if (shuffleMode) {
    int newSongPosition=currentSongPosition;
    while (newSongPosition == currentSongPosition)     newSongPosition=random.nextInt(songs.size());
    currentSongPosition=newSongPosition;
    return;
  }
  currentSongPosition++;
  if (currentSongPosition >= songs.size())   currentSongPosition=0;
}",0.9590085795996188
22500,"/** 
 * Let's call this when the user selects a song from the list.
 * @param songIndex FUCK YEAH
 */
public void setSong(int songIndex){
  currentSongPosition=songIndex;
}","/** 
 * Sets a specific song, already within internal Now Playing List.
 * @param songIndex Index of the song inside the Now Playing List.
 */
public void setSong(int songIndex){
  if (songIndex < 0 || songIndex >= songs.size())   currentSongPosition=0;
  currentSongPosition=songIndex;
}",0.4347826086956521
22501,"@Override public boolean onError(MediaPlayer mp,int what,int extra){
  mp.reset();
  return false;
}","/** 
 * If something wrong happens with the MusicPlayer.
 */
@Override public boolean onError(MediaPlayer mp,int what,int extra){
  mp.reset();
  return false;
}",0.7662835249042146
22502,"public void previous(){
  scrobbleCurrentSong(false);
  currentSongPosition--;
  if (currentSongPosition < 0)   currentSongPosition=songs.size() - 1;
  kMP.nowPlayingIndex=currentSongPosition;
  playSong();
}","/** 
 * Jumps to the previous song on the list.
 * @note Remember to call `playSong()` to make the MusicPlayeractually play the music.
 */
public void previous(){
  scrobbleCurrentSong(false);
  currentSongPosition--;
  if (currentSongPosition < 0)   currentSongPosition=songs.size() - 1;
}",0.606425702811245
22503,"/** 
 * When the user selects an item from our list, we'll start playing. We'll play the current list, starting from the song the user just selected.
 */
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  kMP.nowPlayingList=kMP.musicList;
  kMP.nowPlayingIndex=position;
  startActivity(new Intent(this,ActivityNowPlaying.class));
}","/** 
 * When the user selects an item from our list, we'll start playing. We'll play the current list, starting from the song the user just selected.
 */
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  kMP.nowPlayingList=kMP.musicList;
  Intent intent=new Intent(this,ActivityNowPlaying.class);
  intent.putExtra(""String_Node_Str"",position);
  startActivity(intent);
}",0.7305236270753512
22504,"/** 
 * Called when the activity is created for the first time.
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_menu_albums);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
  listView=(ListView)findViewById(R.id.activity_menu_albums_list);
  items=kMP.songs.getAlbums();
  final ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,items);
  listView.setAdapter(adapter);
  listView.setOnItemClickListener(this);
}","/** 
 * Called when the activity is created for the first time.
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_menu_albums);
  ActionBar actionBar=getActionBar();
  if (actionBar != null)   actionBar.setDisplayHomeAsUpEnabled(true);
  listView=(ListView)findViewById(R.id.activity_menu_albums_list);
  items=kMP.songs.getAlbums();
  final ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,items);
  listView.setAdapter(adapter);
  listView.setOnItemClickListener(this);
}",0.979009235936188
22505,"private void endStatefulConnection(){
  try {
    jcoContext.end(destination);
  }
 catch (  JCoException e) {
    throw new HibersapException(""String_Node_Str"",e);
  }
 finally {
    destination=null;
  }
}","private void endStatefulConnection(){
  try {
    jcoContext.end(destination);
  }
 catch (  JCoException e) {
    LOG.warn(""String_Node_Str"",e);
  }
 finally {
    destination=null;
  }
}",0.9215189873417722
22506,"public void close(){
  endStatefulConnection();
}","public void close(){
  if (destination != null) {
    endStatefulConnection();
  }
}",0.7368421052631579
22507,"private void assertConversionExceptionToJava(Object value){
  try {
    converter.convertToJava(value);
    fail();
  }
 catch (  ConversionException e) {
  }
}","private void assertConversionExceptionToJava(String value){
  try {
    converter.convertToJava(value);
    fail();
  }
 catch (  ConversionException e) {
  }
}",0.96875
22508,"@Test public void testConvertToSap(){
  assertEquals(""String_Node_Str"",converter.convertToSap(true));
  assertEquals(""String_Node_Str"",converter.convertToSap(false));
  assertConversionExceptionToSap(null);
  assertConversionExceptionToSap(new Integer(0));
}","@Test public void testConvertToSap(){
  assertEquals(""String_Node_Str"",converter.convertToSap(true));
  assertEquals(""String_Node_Str"",converter.convertToSap(false));
  assertConversionExceptionToSap(null);
}",0.8927038626609443
22509,"private void assertConversionExceptionToSap(Object value){
  try {
    converter.convertToSap(value);
    fail();
  }
 catch (  ConversionException e) {
  }
}","private void assertConversionExceptionToSap(Boolean value){
  try {
    converter.convertToSap(value);
    fail();
  }
 catch (  ConversionException e) {
  }
}",0.9652996845425869
22510,"@Test public void testConvertToJava(){
  assertEquals(true,converter.convertToJava(""String_Node_Str""));
  assertEquals(true,converter.convertToJava(""String_Node_Str""));
  assertEquals(true,converter.convertToJava(""String_Node_Str""));
  assertEquals(false,converter.convertToJava(""String_Node_Str""));
  assertEquals(false,converter.convertToJava(""String_Node_Str""));
  assertConversionExceptionToJava(""String_Node_Str"");
  assertConversionExceptionToJava(null);
  assertConversionExceptionToJava(new Integer(0));
}","@Test public void testConvertToJava(){
  assertEquals(true,converter.convertToJava(""String_Node_Str""));
  assertEquals(true,converter.convertToJava(""String_Node_Str""));
  assertEquals(true,converter.convertToJava(""String_Node_Str""));
  assertEquals(false,converter.convertToJava(""String_Node_Str""));
  assertEquals(false,converter.convertToJava(""String_Node_Str""));
  assertConversionExceptionToJava(""String_Node_Str"");
  assertConversionExceptionToJava(null);
}",0.9476923076923076
22511,"@Test public void testConvertToJava(){
  assertEquals(' ',converter.convertToJava(null));
  assertEquals(' ',converter.convertToJava(""String_Node_Str""));
  assertEquals('A',converter.convertToJava(""String_Node_Str""));
  assertEquals('A',converter.convertToJava(""String_Node_Str""));
}","@Test public void testConvertToJava(){
  assertEquals((Object)' ',converter.convertToJava(null));
  assertEquals((Object)' ',converter.convertToJava(""String_Node_Str""));
  assertEquals((Object)'A',converter.convertToJava(""String_Node_Str""));
  assertEquals((Object)'A',converter.convertToJava(""String_Node_Str""));
}",0.9464882943143812
22512,"private static void activateBeanValidationWithTypeSafeActivator(Set<BapiInterceptor> bapiInterceptors,SessionManagerConfig sessionManagerConfig){
  try {
    Class<?> activator=ReflectionHelper.getClassForName(TYPE_SAFE_ACTIVATOR_CLASS_NAME);
    Method activateBeanValidation=activator.getDeclaredMethod(TYPE_SAFE_ACTIVATOR_METHOD_NAME,Set.class,SessionManagerConfig.class);
    activateBeanValidation.setAccessible(true);
    activateBeanValidation.invoke(null,bapiInterceptors,sessionManagerConfig);
  }
 catch (  ClassNotFoundException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  InvocationTargetException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  NoSuchMethodException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  IllegalAccessException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
}","private static void activateBeanValidationWithTypeSafeActivator(Set<BapiInterceptor> bapiInterceptors,SessionManagerConfig sessionManagerConfig){
  try {
    Class<?> activator=ReflectionHelper.getClassForName(TYPE_SAFE_ACTIVATOR_CLASS_NAME);
    Method activateBeanValidation=activator.getDeclaredMethod(TYPE_SAFE_ACTIVATOR_METHOD_NAME,Set.class,SessionManagerConfig.class);
    activateBeanValidation.invoke(null,bapiInterceptors,sessionManagerConfig);
  }
 catch (  ClassNotFoundException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  InvocationTargetException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  NoSuchMethodException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  IllegalAccessException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
}",0.7512953367875648
22513,"private static void activateBeanValidationWithTypeSafeActivator(Set<BapiInterceptor> bapiInterceptors,SessionManagerConfig sessionManagerConfig){
  try {
    Class<?> activator=ReflectionHelper.getClassForName(TYPE_SAFE_ACTIVATOR_CLASS_NAME);
    Method activateBeanValidation=activator.getDeclaredMethod(TYPE_SAFE_ACTIVATOR_METHOD_NAME,Set.class,SessionManagerConfig.class);
    activateBeanValidation.invoke(null,bapiInterceptors,sessionManagerConfig);
  }
 catch (  ClassNotFoundException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  InvocationTargetException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  NoSuchMethodException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  IllegalAccessException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
}","private static void activateBeanValidationWithTypeSafeActivator(Set<BapiInterceptor> bapiInterceptors,SessionManagerConfig sessionManagerConfig){
  try {
    Class<?> activator=ReflectionHelper.getClassForName(TYPE_SAFE_ACTIVATOR_CLASS_NAME);
    Method activateBeanValidation=activator.getDeclaredMethod(TYPE_SAFE_ACTIVATOR_METHOD_NAME,Set.class,SessionManagerConfig.class);
    activateBeanValidation.setAccessible(true);
    activateBeanValidation.invoke(null,bapiInterceptors,sessionManagerConfig);
  }
 catch (  ClassNotFoundException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  InvocationTargetException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  NoSuchMethodException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
catch (  IllegalAccessException e) {
    throw new HibersapException(""String_Node_Str"" + TYPE_SAFE_ACTIVATOR_METHOD_NAME + ""String_Node_Str""+ TYPE_SAFE_ACTIVATOR_CLASS_NAME,e);
  }
}",0.9792746113989638
22514,"private void unregister(List<AnnotationConfiguration> annotationConfigurations){
  try {
    InitialContext ic=new InitialContext();
    try {
      for (      AnnotationConfiguration annotationConfiguration : annotationConfigurations) {
        ic.unbind(""String_Node_Str"" + annotationConfiguration.getSessionManagerConfig().getName());
      }
    }
  finally {
      ic.close();
    }
  }
 catch (  NamingException e) {
    throw new RuntimeException(e);
  }
}","private void unregister(List<AnnotationConfiguration> annotationConfigurations){
  try {
    InitialContext ic=new InitialContext();
    try {
      for (      AnnotationConfiguration annotationConfiguration : annotationConfigurations) {
        ic.unbind(""String_Node_Str"" + annotationConfiguration.getSessionManagerName());
      }
    }
  finally {
      ic.close();
    }
  }
 catch (  NamingException e) {
    throw new RuntimeException(e);
  }
}",0.986870897155361
22515,"private void register(List<AnnotationConfiguration> annotationConfigurations){
  try {
    InitialContext ic=new InitialContext();
    try {
      ic.lookup(""String_Node_Str"");
    }
 catch (    NameNotFoundException e) {
      ic.createSubcontext(""String_Node_Str"");
    }
    Context context=(Context)ic.lookup(""String_Node_Str"");
    ClassLoader old=Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(cl);
    try {
      for (      AnnotationConfiguration annotationConfig : annotationConfigurations) {
        context.bind(annotationConfig.getSessionManagerConfig().getName(),annotationConfig.buildSessionManager());
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(old);
      ic.close();
    }
  }
 catch (  NamingException e) {
    throw new RuntimeException(e);
  }
}","private void register(List<AnnotationConfiguration> annotationConfigurations){
  try {
    InitialContext ic=new InitialContext();
    try {
      ic.lookup(""String_Node_Str"");
    }
 catch (    NameNotFoundException e) {
      ic.createSubcontext(""String_Node_Str"");
    }
    Context context=(Context)ic.lookup(""String_Node_Str"");
    ClassLoader old=Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(cl);
    try {
      for (      AnnotationConfiguration annotationConfig : annotationConfigurations) {
        SessionManager sessionManager=annotationConfig.buildSessionManager();
        context.bind(sessionManager.getConfig().getName(),sessionManager);
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(old);
      ic.close();
    }
  }
 catch (  NamingException e) {
    throw new RuntimeException(e);
  }
}",0.8826237054085155
22516,"public static Set<ExecutionInterceptor> createExecutionInterceptors(SessionManagerConfig sessionManagerConfig){
  final Set<String> classNames=sessionManagerConfig.getExecutionInterceptorClasses();
  final Set<ExecutionInterceptor> executionInterceptors=new HashSet<ExecutionInterceptor>();
  executionInterceptors.addAll(createInstances(classNames,ExecutionInterceptor.class));
  executionInterceptors.add(new SapErrorInterceptor());
  return executionInterceptors;
}","public static Set<ExecutionInterceptor> createExecutionInterceptors(SessionManagerConfig sessionManagerConfig){
  final List<String> classNames=sessionManagerConfig.getExecutionInterceptorClasses();
  final Set<ExecutionInterceptor> executionInterceptors=new HashSet<ExecutionInterceptor>();
  executionInterceptors.addAll(createInstances(classNames,ExecutionInterceptor.class));
  executionInterceptors.add(new SapErrorInterceptor());
  return executionInterceptors;
}",0.9946638207043756
22517,"public static Set<BapiInterceptor> createBapiInterceptors(SessionManagerConfig sessionManagerConfig){
  final Set<String> classNames=sessionManagerConfig.getBapiInterceptorClasses();
  final Set<BapiInterceptor> bapiInterceptors=new HashSet<BapiInterceptor>();
  bapiInterceptors.addAll(createInstances(classNames,BapiInterceptor.class));
  activateBeanValidation(bapiInterceptors,sessionManagerConfig);
  return bapiInterceptors;
}","public static Set<BapiInterceptor> createBapiInterceptors(SessionManagerConfig sessionManagerConfig){
  final List<String> classNames=sessionManagerConfig.getBapiInterceptorClasses();
  final Set<BapiInterceptor> bapiInterceptors=new HashSet<BapiInterceptor>();
  bapiInterceptors.addAll(createInstances(classNames,BapiInterceptor.class));
  activateBeanValidation(bapiInterceptors,sessionManagerConfig);
  return bapiInterceptors;
}",0.9942196531791908
22518,"@XmlElement(name=""String_Node_Str"",required=true,namespace=HibersapConfig.NAMESPACE) public List<SessionManagerConfig> getSessionManagers(){
  return sessionManagers;
}","public List<SessionManagerConfig> getSessionManagers(){
  return sessionManagers;
}",0.6613545816733067
22519,"@SuppressWarnings(""String_Node_Str"") private void mapFields(Set<? extends ParameterMapping> set,JCoParameterList jcoParams){
  JCoParameterFieldIterator iter=jcoParams.getParameterFieldIterator();
  while (iter.hasNextField()) {
    JCoField field=iter.nextField();
    ParameterMapping param=getParameterMapping(field);
    if (ParameterMapping.ParamType.FIELD == param.getParamType()) {
      ((Set<FieldMapping>)set).add((FieldMapping)param);
    }
 else     if (ParameterMapping.ParamType.STRUCTURE == param.getParamType()) {
      ((Set<StructureMapping>)set).add((StructureMapping)param);
    }
 else     if (ParameterMapping.ParamType.TABLE == param.getParamType()) {
      ((Set<TableMapping>)set).add((TableMapping)param);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void mapFields(Set<? extends ParameterMapping> set,JCoParameterList jcoParams){
  if (jcoParams == null) {
    return;
  }
  JCoParameterFieldIterator iter=jcoParams.getParameterFieldIterator();
  while (iter.hasNextField()) {
    JCoField field=iter.nextField();
    ParameterMapping param=getParameterMapping(field);
    if (ParameterMapping.ParamType.FIELD == param.getParamType()) {
      ((Set<FieldMapping>)set).add((FieldMapping)param);
    }
 else     if (ParameterMapping.ParamType.STRUCTURE == param.getParamType()) {
      ((Set<StructureMapping>)set).add((StructureMapping)param);
    }
 else     if (ParameterMapping.ParamType.TABLE == param.getParamType()) {
      ((Set<TableMapping>)set).add((TableMapping)param);
    }
  }
}",0.97187704381949
22520,"@SuppressWarnings(""String_Node_Str"") static void activateBeanValidation(Set<BapiInterceptor> bapiInterceptors,SessionManagerConfig sessionManagerConfig){
  try {
    ValidatorFactory factory=validatorFactoryFactory.buildValidatorFactory();
    bapiInterceptors.add(new BeanValidationInterceptor(factory));
  }
 catch (  ValidationException e) {
    if (sessionManagerConfig.getValidationMode() == ValidationMode.AUTO) {
      LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",e);
    }
 else {
      throw new HibersapException(""String_Node_Str"",e);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") static void activateBeanValidation(Set<BapiInterceptor> bapiInterceptors,SessionManagerConfig sessionManagerConfig){
  try {
    ValidatorFactory factory=validatorFactoryFactory.buildValidatorFactory();
    bapiInterceptors.add(new BeanValidationInterceptor(factory));
  }
 catch (  ValidationException e) {
    ValidationMode validationMode=sessionManagerConfig.getValidationMode();
    if (validationMode == ValidationMode.AUTO) {
      LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",e);
    }
 else {
      throw new HibersapException(""String_Node_Str"" + validationMode,e);
    }
  }
}",0.8771358828315704
22521,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  Property other=(Property)obj;
  if (name == null) {
    if (other.name != null)     return false;
  }
 else   if (!name.equals(other.name))   return false;
  if (value == null) {
    if (other.value != null)     return false;
  }
 else   if (!value.equals(other.value))   return false;
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final Property other=(Property)obj;
  if (name == null) {
    if (other.name != null) {
      return false;
    }
  }
 else   if (!name.equals(other.name)) {
    return false;
  }
  if (value == null) {
    if (other.value != null) {
      return false;
    }
  }
 else   if (!value.equals(other.value)) {
    return false;
  }
  return true;
}",0.6778656126482213
22522,"@Test public void testEmptyInputRecordCausesError() throws Exception {
  final MappedRecord resultRecord=_service.getFlightList(new MappedRecordImpl(""String_Node_Str""));
  assertNotNull(resultRecord);
  final MappedRecord returnRecord=(MappedRecord)resultRecord.get(BapiConstants.RETURN);
  assertNotNull(returnRecord);
  final String type=(String)returnRecord.get(BapiConstants.TYPE);
  assertEquals(""String_Node_Str"",type);
}","public void testEmptyInputRecordCausesError() throws Exception {
  final MappedRecord resultRecord=_service.getFlightList(new MappedRecordImpl(""String_Node_Str""));
  assertNotNull(resultRecord);
  final MappedRecord returnRecord=(MappedRecord)resultRecord.get(BapiConstants.RETURN);
  assertNotNull(returnRecord);
  final String type=(String)returnRecord.get(BapiConstants.TYPE);
  assertEquals(""String_Node_Str"",type);
}",0.9929245283018868
22523,"@BeforeClass public static void setUp() throws Exception {
  final Context naming=new InitialContext();
  _service=(RAConnectorService)naming.lookup(RAConnectorService.JNDI_NAME);
  assertNotNull(_service);
  naming.close();
}","public static void setUp() throws Exception {
  final Context naming=new InitialContext();
  _service=(RAConnectorService)naming.lookup(RAConnectorService.JNDI_NAME);
  assertNotNull(_service);
  naming.close();
}",0.9703872437357632
22524,"@Test public void testFlightList() throws Exception {
  final MappedRecord resultRecord=_service.getFlightList(createInputRecord());
  assertNotNull(resultRecord);
  final MappedRecord returnRecord=(MappedRecord)resultRecord.get(BapiConstants.RETURN);
  assertNotNull(returnRecord);
  final String type=(String)returnRecord.get(BapiConstants.TYPE);
  assertEquals(returnRecord.toString(),""String_Node_Str"",type);
  final IndexedRecord tableDataRecord=(IndexedRecord)resultRecord.get(FlightListConstants.FLIGHTLIST);
  assertNotNull(tableDataRecord);
  assertEquals(2,tableDataRecord.size());
  MappedRecord rowRecord=(MappedRecord)tableDataRecord.get(0);
  String connid=(String)rowRecord.get(FlightListConstants.CONNID);
  assertEquals(""String_Node_Str"",connid);
  rowRecord=(MappedRecord)tableDataRecord.get(1);
  connid=(String)rowRecord.get(FlightListConstants.CONNID);
  assertEquals(""String_Node_Str"",connid);
}","public void testFlightList() throws Exception {
  final MappedRecord resultRecord=_service.getFlightList(createInputRecord());
  assertNotNull(resultRecord);
  final MappedRecord returnRecord=(MappedRecord)resultRecord.get(BapiConstants.RETURN);
  assertNotNull(returnRecord);
  final String type=(String)returnRecord.get(BapiConstants.TYPE);
  assertEquals(returnRecord.toString(),""String_Node_Str"",type);
  final IndexedRecord tableDataRecord=(IndexedRecord)resultRecord.get(FlightListConstants.FLIGHTLIST);
  assertNotNull(tableDataRecord);
  assertEquals(2,tableDataRecord.size());
  MappedRecord rowRecord=(MappedRecord)tableDataRecord.get(0);
  String connid=(String)rowRecord.get(FlightListConstants.CONNID);
  assertEquals(""String_Node_Str"",connid);
  rowRecord=(MappedRecord)tableDataRecord.get(1);
  connid=(String)rowRecord.get(FlightListConstants.CONNID);
  assertEquals(""String_Node_Str"",connid);
}",0.9967177242888404
22525,"@BeforeClass public static void setUp() throws Exception {
  final Context naming=new InitialContext();
  _service=(SapFlightService)naming.lookup(SapFlightService.JNDI_NAME);
  assertNotNull(_service);
  naming.close();
}","public static void setUp() throws Exception {
  final Context naming=new InitialContext();
  _service=(SapFlightService)naming.lookup(SapFlightService.JNDI_NAME);
  assertNotNull(_service);
  naming.close();
}",0.9698375870069604
22526,"@Test public void testFlightDetails() throws Exception {
  final Date date26Apr2002=new GregorianCalendar(2002,Calendar.APRIL,26).getTime();
  final FlightDetailBapi flightDetail=_service.showFlightDetail(date26Apr2002);
  showResult(flightDetail);
}","public void testFlightDetails() throws Exception {
  final Date date26Apr2002=new GregorianCalendar(2002,Calendar.APRIL,26).getTime();
  final FlightDetailBapi flightDetail=_service.showFlightDetail(date26Apr2002);
  showResult(flightDetail);
}",0.9878542510121456
22527,"@Test public void testFlightList() throws Exception {
  final FlightListBapi flightList=_service.showFlightList();
  showResult(flightList);
}","public void testFlightList() throws Exception {
  final FlightListBapi flightList=_service.showFlightList();
  showResult(flightList);
}",0.9784172661870504
22528,"private Properties convertToProperties(final HiberSap hiberSapConfig){
  final Properties properties=new Properties();
  final SessionFactory sessionFactory=hiberSapConfig.getSessionFactory();
  properties.setProperty(Environment.SESSION_FACTORY_NAME,sessionFactory.getName());
  properties.setProperty(Environment.CONTEXT_CLASS,sessionFactory.getContext());
  final List<String> annotatedClasses=sessionFactory.getClasses();
  final Iterator<String> classesIterator=annotatedClasses.iterator();
  for (int idx=0; idx < annotatedClasses.size(); idx++) {
    properties.setProperty(Environment.BABI_CLASSES_PREFIX + idx,classesIterator.next());
  }
  final List<JCoProperty> jcoProperties=sessionFactory.getJCoProperties();
  for (  final JCoProperty jCoProperty : jcoProperties) {
    properties.setProperty(JCoContext.HIBERSAP_JCO_PREFIX + jCoProperty.getName(),jCoProperty.getValue());
  }
  return properties;
}","private Properties convertToProperties(final HiberSap hiberSapConfig){
  final Properties properties=new Properties();
  final SessionFactory sessionFactory=hiberSapConfig.getSessionFactory();
  properties.setProperty(Environment.SESSION_FACTORY_NAME,sessionFactory.getName());
  properties.setProperty(Environment.CONTEXT_CLASS,sessionFactory.getContext());
  final List<String> annotatedClasses=sessionFactory.getClasses();
  final Iterator<String> classesIterator=annotatedClasses.iterator();
  for (int idx=0; idx < annotatedClasses.size(); idx++) {
    properties.setProperty(Environment.BABI_CLASSES_PREFIX + idx,classesIterator.next());
  }
  final List<JCoProperty> jcoProperties=sessionFactory.getJCoProperties();
  for (  final JCoProperty jCoProperty : jcoProperties) {
    properties.setProperty(JCoContext.HIBERSAP_JCO_PREFIX + ""String_Node_Str"" + jCoProperty.getName(),jCoProperty.getValue());
  }
  return properties;
}",0.9891774891774892
22529,"@Test public void testOK() throws Exception {
  final HiberSapJaxbXmlParser hiberSapJaxbXmlParser=new HiberSapJaxbXmlParser();
  final Properties properties=hiberSapJaxbXmlParser.parseResource(""String_Node_Str"");
  Assert.assertNotNull(properties);
  testForNotNull(properties,Environment.SESSION_FACTORY_NAME);
  testForNotNull(properties,Environment.CONTEXT_CLASS);
  final Set<String> bapiClasses=new HashSet<String>();
  final Set<String> sapProperties=new HashSet<String>();
  for (  final Object keyObject : properties.keySet()) {
    final String key=(String)keyObject;
    if (key.startsWith(Environment.BABI_CLASSES_PREFIX)) {
      bapiClasses.add(properties.getProperty(key));
    }
 else     if (key.startsWith(Environment.SAP_PREFIX)) {
      sapProperties.add(properties.getProperty(key));
    }
  }
  Assert.assertEquals(2,bapiClasses.size());
  Assert.assertEquals(7,sapProperties.size());
}","@Test public void testOK() throws Exception {
  final HiberSapJaxbXmlParser hiberSapJaxbXmlParser=new HiberSapJaxbXmlParser();
  final Properties properties=hiberSapJaxbXmlParser.parseResource(""String_Node_Str"");
  Assert.assertNotNull(properties);
  testForNotNull(properties,Environment.SESSION_FACTORY_NAME);
  testForNotNull(properties,Environment.CONTEXT_CLASS);
  final Set<String> bapiClasses=new HashSet<String>();
  final Set<String> sapProperties=new HashSet<String>();
  for (  final Object keyObject : properties.keySet()) {
    final String key=(String)keyObject;
    if (key.startsWith(Environment.BABI_CLASSES_PREFIX)) {
      bapiClasses.add(properties.getProperty(key));
    }
 else     if (key.startsWith(JCoContext.HIBERSAP_JCO_PREFIX)) {
      sapProperties.add(properties.getProperty(key));
    }
  }
  Assert.assertEquals(2,bapiClasses.size());
  Assert.assertEquals(7,sapProperties.size());
}",0.982436882546652
22530,"public void onCustomerSaved(@Observes(notifyObserver=Reception.IF_EXISTS) CustomerSavedEvent event){
  customerService.storeCustomer(event.getCustomer());
  getView().populateCustomers(customerService.getAllCustomers());
  getView().closeEditor();
}","public void onCustomerSaved(@Observes(notifyObserver=Reception.IF_EXISTS) CustomerSavedEvent event){
  customerService.storeCustomer(event.getCustomer());
  getView().populateCustomers(customerService.getAllCustomers());
  getView().removeTableSelection();
  getView().closeEditor();
}",0.9325842696629212
22531,"@Override protected void init(VaadinRequest request){
  VerticalLayout layout=new VerticalLayout();
  layout.setSizeFull();
  topBar=new HorizontalLayout();
  topBar.setWidth(100,Unit.PERCENTAGE);
  logout=new Button(""String_Node_Str"",logoutClickListener);
  logout.setStyleName(ChameleonTheme.BUTTON_LINK);
  logout.setVisible(false);
  topBar.addComponent(logout);
  topBar.setExpandRatio(logout,1);
  topBar.setComponentAlignment(logout,Alignment.TOP_RIGHT);
  VerticalLayout content=new VerticalLayout();
  content.setSizeFull();
  layout.addComponents(topBar,content);
  layout.setExpandRatio(content,1);
  setContent(layout);
  navigator=new Navigator(this,content);
  navigator.addProvider(viewProvider);
  if (!isLoggedIn()) {
    navigator.navigateTo(""String_Node_Str"");
  }
 else {
    if (navigator.getState().isEmpty()) {
      navigator.navigateTo(""String_Node_Str"");
      logout.setVisible(true);
    }
  }
}","@Override protected void init(VaadinRequest request){
  VerticalLayout layout=new VerticalLayout();
  layout.setSizeFull();
  topBar=new HorizontalLayout();
  topBar.setWidth(100,Unit.PERCENTAGE);
  logout=new Button(""String_Node_Str"",logoutClickListener);
  logout.setStyleName(ChameleonTheme.BUTTON_LINK);
  topBar.addComponent(logout);
  topBar.setExpandRatio(logout,1);
  topBar.setComponentAlignment(logout,Alignment.TOP_RIGHT);
  VerticalLayout content=new VerticalLayout();
  content.setSizeFull();
  layout.addComponents(topBar,content);
  layout.setExpandRatio(content,1);
  setContent(layout);
  navigator=new Navigator(this,content);
  navigator.addProvider(viewProvider);
  if (!isLoggedIn()) {
    navigator.navigateTo(""String_Node_Str"");
    logout.setVisible(false);
  }
 else {
    if (navigator.getState().isEmpty()) {
      navigator.navigateTo(""String_Node_Str"");
      logout.setVisible(true);
    }
  }
}",0.9686147186147186
22532,"public static Marker getMarker(Marker... markers){
  Marker output=MarkerFactory.getMarker(""String_Node_Str"");
  output.remove(output);
  for (  Marker marker : markers) {
    output.add(marker);
  }
  return output;
}","public static Marker getMarker(Marker... markers){
  Marker output=new MultiMarker(markers);
  return output;
}",0.6322188449848024
22533,"@Test public void multiMarkerTest(){
  Marker marker=SecurityMarkers.getMarker(SecurityMarkers.SECURITY_SUCCESS,SecurityMarkers.CONFIDENTIAL);
  LOGGER.info(marker,""String_Node_Str"");
  verify(mockAppender).doAppend(captorLoggingEvent.capture());
  final LoggingEvent loggingEvent=captorLoggingEvent.getValue();
  assertThat(loggingEvent.getLevel(),is(Level.INFO));
  assertThat(loggingEvent.getFormattedMessage(),is(""String_Node_Str""));
  Marker test=loggingEvent.getMarker();
  assertTrue(test.contains(SecurityMarkers.SECURITY_SUCCESS));
  assertTrue(test.contains(SecurityMarkers.CONFIDENTIAL));
}","@Test public void multiMarkerTest(){
  Marker marker=SecurityMarkers.getMarker(SecurityMarkers.SECURITY_SUCCESS,SecurityMarkers.CONFIDENTIAL);
  LOGGER.info(marker,""String_Node_Str"");
  verify(mockAppender).doAppend(captorLoggingEvent.capture());
  final LoggingEvent loggingEvent=captorLoggingEvent.getValue();
  assertThat(loggingEvent.getLevel(),is(Level.INFO));
  assertThat(loggingEvent.getFormattedMessage(),is(""String_Node_Str""));
  Marker test=loggingEvent.getMarker();
  assertTrue(test.contains(SecurityMarkers.SECURITY_SUCCESS));
  assertTrue(test.contains(SecurityMarkers.CONFIDENTIAL));
  assertFalse(test.contains(SecurityMarkers.EVENT_FAILURE));
}",0.9517022961203484
22534,"@Override protected void setup(){
  alsltr329.configure().gain(Gain.values()[sensorGainIndex]).measurementRate(MeasurementRate.LTR329_RATE_50MS).integrationTime(IntegrationTime.LTR329_TIME_50MS).commit();
  alsltr329.illuminance().addRouteAsync(source -> {
    source.stream((data,env) -> {
      final Float lux=data.value(Float.class);
      LineData chartData=chart.getData();
      if (startTime == -1) {
        chartData.addXValue(""String_Node_Str"");
        startTime=System.currentTimeMillis();
      }
 else {
        chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplingPeriod));
      }
      chartData.addEntry(new Entry(lux,sampleCount),0);
      sampleCount++;
    }
);
  }
).continueWith(task -> {
    streamRoute=task.getResult();
    alsltr329.illuminance().start();
    return null;
  }
);
}","@Override protected void setup(){
  alsltr329.configure().gain(Gain.values()[sensorGainIndex]).measurementRate(MeasurementRate.LTR329_RATE_50MS).integrationTime(IntegrationTime.LTR329_TIME_50MS).commit();
  alsltr329.illuminance().addRouteAsync(source -> {
    source.stream((data,env) -> {
      final Float lux=data.value(Float.class);
      LineData chartData=chart.getData();
      if (startTime == -1) {
        chartData.addXValue(""String_Node_Str"");
        startTime=System.currentTimeMillis();
      }
 else {
        chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplingPeriod));
      }
      chartData.addEntry(new Entry(lux,sampleCount),0);
      sampleCount++;
      updateChart();
    }
);
  }
).continueWith(task -> {
    streamRoute=task.getResult();
    alsltr329.illuminance().start();
    return null;
  }
);
}",0.9876543209876544
22535,"@Override protected void setup(){
  barometer.configure().pressureOversampling(OversamplingMode.ULTRA_HIGH).filterCoeff(FilterCoeff.OFF).standbyTime(0.5f).commit();
  barometer.pressure().addRouteAsync(source -> source.stream((data,env) -> {
    LineData chartData=chart.getData();
    if (pressureData.size() >= sampleCount) {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * LIGHT_SAMPLE_PERIOD));
      sampleCount++;
    }
    chartData.addEntry(new Entry(data.value(Float.class),sampleCount),0);
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return barometer.altitude().addRouteAsync(source -> source.stream((data,env) -> {
      LineData chartData=chart.getData();
      if (altitudeData.size() >= sampleCount) {
        chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * LIGHT_SAMPLE_PERIOD));
        sampleCount++;
      }
      chartData.addEntry(new Entry(data.value(Float.class),sampleCount),1);
    }
));
  }
).continueWith(task -> {
    altitudeRoute=task.getResult();
    barometer.altitude().start();
    barometer.pressure().start();
    barometer.start();
    return null;
  }
);
}","@Override protected void setup(){
  barometer.configure().pressureOversampling(OversamplingMode.ULTRA_HIGH).filterCoeff(FilterCoeff.OFF).standbyTime(0.5f).commit();
  barometer.pressure().addRouteAsync(source -> source.stream((data,env) -> {
    LineData chartData=chart.getData();
    if (pressureData.size() >= sampleCount) {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * LIGHT_SAMPLE_PERIOD));
      sampleCount++;
      updateChart();
    }
    chartData.addEntry(new Entry(data.value(Float.class),sampleCount),0);
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return barometer.altitude().addRouteAsync(source -> source.stream((data,env) -> {
      LineData chartData=chart.getData();
      if (altitudeData.size() >= sampleCount) {
        chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * LIGHT_SAMPLE_PERIOD));
        sampleCount++;
        updateChart();
      }
      chartData.addEntry(new Entry(data.value(Float.class),sampleCount),1);
    }
));
  }
).continueWith(task -> {
    altitudeRoute=task.getResult();
    barometer.altitude().start();
    barometer.pressure().start();
    barometer.start();
    return null;
  }
);
}",0.9817427385892116
22536,"@Override protected void setup(){
  ForcedDataProducer colorAdc=colorDetector.adc();
  colorDetector.configure().gain(Gain.values()[rangeIndex]).commit();
  colorAdc.addRouteAsync(source -> source.stream((data,env) -> {
    LineData chartData=chart.getData();
    if (startTime == -1) {
      chartData.addXValue(""String_Node_Str"");
      startTime=System.currentTimeMillis();
    }
 else {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",(sampleCount * COLOR_SAMPLE_PERIOD) / 1000.f));
    }
    ColorAdc adc=data.value(ColorAdc.class);
    chartData.addEntry(new Entry(adc.clear,sampleCount),0);
    chartData.addEntry(new Entry(adc.red,sampleCount),1);
    chartData.addEntry(new Entry(adc.green,sampleCount),2);
    chartData.addEntry(new Entry(adc.blue,sampleCount),3);
    sampleCount++;
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return timerModule.scheduleAsync(COLOR_SAMPLE_PERIOD,false,colorAdc::read);
  }
).continueWith(task -> {
    scheduledTask=task.getResult();
    scheduledTask.start();
    return null;
  }
);
}","@Override protected void setup(){
  ForcedDataProducer colorAdc=colorDetector.adc();
  colorDetector.configure().gain(Gain.values()[rangeIndex]).commit();
  colorAdc.addRouteAsync(source -> source.stream((data,env) -> {
    LineData chartData=chart.getData();
    if (startTime == -1) {
      chartData.addXValue(""String_Node_Str"");
      startTime=System.currentTimeMillis();
    }
 else {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",(sampleCount * COLOR_SAMPLE_PERIOD) / 1000.f));
    }
    ColorAdc adc=data.value(ColorAdc.class);
    chartData.addEntry(new Entry(adc.clear,sampleCount),0);
    chartData.addEntry(new Entry(adc.red,sampleCount),1);
    chartData.addEntry(new Entry(adc.green,sampleCount),2);
    chartData.addEntry(new Entry(adc.blue,sampleCount),3);
    sampleCount++;
    updateChart();
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return timerModule.scheduleAsync(COLOR_SAMPLE_PERIOD,false,colorAdc::read);
  }
).continueWith(task -> {
    scheduledTask=task.getResult();
    scheduledTask.start();
    return null;
  }
);
}",0.9912723932016536
22537,"@Override protected void setup(){
  Range[] values=Range.values();
  gyro.configure().odr(OutputDataRate.ODR_25_HZ).range(values[values.length - rangeIndex - 1]).commit();
  final float period=1 / GYR_ODR;
  final AsyncDataProducer producer=gyro.packedAngularVelocity() == null ? gyro.packedAngularVelocity() : gyro.angularVelocity();
  producer.addRouteAsync(source -> source.stream((data,env) -> {
    final AngularVelocity value=data.value(AngularVelocity.class);
    addChartData(value.x(),value.y(),value.z(),period);
  }
)).continueWith(task -> {
    streamRoute=task.getResult();
    gyro.angularVelocity().start();
    gyro.start();
    return null;
  }
);
}","@Override protected void setup(){
  Range[] values=Range.values();
  gyro.configure().odr(OutputDataRate.ODR_25_HZ).range(values[values.length - rangeIndex - 1]).commit();
  final float period=1 / GYR_ODR;
  final AsyncDataProducer producer=gyro.packedAngularVelocity() == null ? gyro.packedAngularVelocity() : gyro.angularVelocity();
  producer.addRouteAsync(source -> source.stream((data,env) -> {
    final AngularVelocity value=data.value(AngularVelocity.class);
    addChartData(value.x(),value.y(),value.z(),period);
    updateChart();
  }
)).continueWith(task -> {
    streamRoute=task.getResult();
    gyro.angularVelocity().start();
    gyro.start();
    return null;
  }
);
}",0.9859363434492968
22538,"@Override public boolean onOptionsItemSelected(MenuItem item){
  int id=item.getItemId();
switch (id) {
case R.id.action_reset:
    mwBoard.getModule(Debug.class).resetAsync().continueWith(ignored -> {
      attemptReconnect(0);
      return null;
    }
);
  Snackbar.make(findViewById(R.id.drawer_layout),R.string.message_soft_reset,Snackbar.LENGTH_LONG).show();
return true;
case R.id.action_disconnect:
mwBoard.getModule(Settings.class).editBleConnParams().maxConnectionInterval(125f).commit();
mwBoard.disconnectAsync();
finish();
return true;
case R.id.action_manual_dfu:
if (checkLocationPermission()) {
startContentSelectionIntent();
}
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  int id=item.getItemId();
switch (id) {
case R.id.action_reset:
    if (!mwBoard.inMetaBootMode()) {
      mwBoard.getModule(Debug.class).resetAsync().continueWith(ignored -> {
        attemptReconnect(0);
        return null;
      }
);
      Snackbar.make(findViewById(R.id.drawer_layout),R.string.message_soft_reset,Snackbar.LENGTH_LONG).show();
    }
 else {
      Snackbar.make(findViewById(R.id.drawer_layout),R.string.message_no_soft_reset,Snackbar.LENGTH_LONG).show();
    }
  return true;
case R.id.action_disconnect:
if (!mwBoard.inMetaBootMode()) {
  Settings.BleConnectionParametersEditor editor=mwBoard.getModule(Settings.class).editBleConnParams();
  if (editor != null) {
    editor.maxConnectionInterval(125f).commit();
  }
  mwBoard.getModule(Debug.class).disconnectAsync();
}
 else {
  mwBoard.disconnectAsync();
}
finish();
return true;
case R.id.action_manual_dfu:
if (checkLocationPermission()) {
startContentSelectionIntent();
}
break;
}
return super.onOptionsItemSelected(item);
}",0.7105561861520999
22539,"@Override protected void setup(){
  ForcedDataProducer proximityAdc=proximity.adc();
  proximity.configure().transmitterDriveCurrent(TransmitterDriveCurrent.CURRENT_12_5MA).commit();
  proximityAdc.addRouteAsync(source -> source.stream((data,env) -> {
    LineData chartData=chart.getData();
    if (startTime == -1) {
      chartData.addXValue(""String_Node_Str"");
      startTime=System.currentTimeMillis();
    }
 else {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplingPeriod));
    }
    chartData.addEntry(new Entry(data.value(Integer.class),sampleCount),0);
    sampleCount++;
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return timer.scheduleAsync(PROXIMITY_SAMPLE_PERIOD,false,proximityAdc::read);
  }
).continueWith(task -> {
    scheduledTask=task.getResult();
    scheduledTask.start();
    return null;
  }
);
}","@Override protected void setup(){
  ForcedDataProducer proximityAdc=proximity.adc();
  proximity.configure().transmitterDriveCurrent(TransmitterDriveCurrent.CURRENT_12_5MA).commit();
  proximityAdc.addRouteAsync(source -> source.stream((data,env) -> {
    LineData chartData=chart.getData();
    if (startTime == -1) {
      chartData.addXValue(""String_Node_Str"");
      startTime=System.currentTimeMillis();
    }
 else {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplingPeriod));
    }
    chartData.addEntry(new Entry(data.value(Integer.class),sampleCount),0);
    sampleCount++;
    updateChart();
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return timer.scheduleAsync(PROXIMITY_SAMPLE_PERIOD,false,proximityAdc::read);
  }
).continueWith(task -> {
    scheduledTask=task.getResult();
    scheduledTask.start();
    return null;
  }
);
}",0.9894503053858968
22540,"static void setConnInterval(Settings settings){
  Settings.BleConnectionParametersEditor editor=settings.editBleConnParams();
  if (editor != null) {
    editor.maxConnectionInterval(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M ? 11.25f : 7.5f).commit();
  }
}","static void setConnInterval(Settings settings){
  if (settings != null) {
    Settings.BleConnectionParametersEditor editor=settings.editBleConnParams();
    if (editor != null) {
      editor.maxConnectionInterval(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M ? 11.25f : 7.5f).commit();
    }
  }
}",0.6334519572953736
22541,"private void moveViewToLast(){
  chart.setVisibleXRangeMinimum(120);
  chart.setVisibleXRangeMaximum(120);
  chart.moveViewToX(Math.max(0f,chartXValues.size()));
}","private void moveViewToLast(){
  chart.setVisibleXRangeMinimum(120);
  chart.setVisibleXRangeMaximum(120);
  chart.moveViewToX(Math.max(0f,chartXValues.size() - 1));
}",0.987878787878788
22542,"@Override public void onViewCreated(final View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  chart=(LineChart)view.findViewById(R.id.data_chart);
  initializeChart();
  resetData(false);
  chart.invalidate();
  chart.setDescription(null);
  Button clearButton=(Button)view.findViewById(R.id.layout_two_button_left);
  clearButton.setOnClickListener(view1 -> refreshChart(true));
  clearButton.setText(R.string.label_clear);
  ((Switch)view.findViewById(R.id.sample_control)).setOnCheckedChangeListener((compoundButton,b) -> {
    if (b) {
      moveViewToLast();
      setup();
      chartHandler.postDelayed(updateChartTask,UPDATE_PERIOD);
    }
 else {
      chart.setVisibleXRangeMinimum(1);
      chart.setVisibleXRangeMaximum(sampleCount);
      clean();
      if (streamRoute != null) {
        streamRoute.remove();
        streamRoute=null;
      }
      chartHandler.removeCallbacks(updateChartTask);
    }
  }
);
  Button saveButton=(Button)view.findViewById(R.id.layout_two_button_right);
  saveButton.setText(R.string.label_save);
  saveButton.setOnClickListener(view12 -> {
    String filename=saveData();
    if (filename != null) {
      File dataFile=getActivity().getFileStreamPath(filename);
      Uri contentUri=FileProvider.getUriForFile(getActivity(),""String_Node_Str"",dataFile);
      Intent intent=new Intent(Intent.ACTION_SEND);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_SUBJECT,filename);
      intent.putExtra(Intent.EXTRA_STREAM,contentUri);
      startActivity(Intent.createChooser(intent,""String_Node_Str""));
    }
  }
);
}","@Override public void onViewCreated(final View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  chart=(LineChart)view.findViewById(R.id.data_chart);
  initializeChart();
  resetData(false);
  chart.invalidate();
  chart.setDescription(null);
  Button clearButton=(Button)view.findViewById(R.id.layout_two_button_left);
  clearButton.setOnClickListener(view1 -> refreshChart(true));
  clearButton.setText(R.string.label_clear);
  ((Switch)view.findViewById(R.id.sample_control)).setOnCheckedChangeListener((compoundButton,b) -> {
    if (b) {
      moveViewToLast();
      setup();
    }
 else {
      chart.setVisibleXRangeMinimum(1);
      chart.setVisibleXRangeMaximum(sampleCount);
      clean();
      if (streamRoute != null) {
        streamRoute.remove();
        streamRoute=null;
      }
    }
  }
);
  Button saveButton=(Button)view.findViewById(R.id.layout_two_button_right);
  saveButton.setText(R.string.label_save);
  saveButton.setOnClickListener(view12 -> {
    String filename=saveData();
    if (filename != null) {
      File dataFile=getActivity().getFileStreamPath(filename);
      Uri contentUri=FileProvider.getUriForFile(getActivity(),""String_Node_Str"",dataFile);
      Intent intent=new Intent(Intent.ACTION_SEND);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_SUBJECT,filename);
      intent.putExtra(Intent.EXTRA_STREAM,contentUri);
      startActivity(Intent.createChooser(intent,""String_Node_Str""));
    }
  }
);
}",0.9629392971246008
22543,"@Override protected void setup(){
  sensorFusion.configure().mode(Mode.NDOF).accRange(AccRange.AR_16G).gyroRange(GyroRange.GR_2000DPS).commit();
  if (srcIndex == 0) {
    sensorFusion.quaternion().addRouteAsync(source -> source.stream((data,env) -> {
      LineData chartData=chart.getData();
      final Quaternion quaternion=data.value(Quaternion.class);
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * SAMPLING_PERIOD));
      chartData.addEntry(new Entry(quaternion.w(),sampleCount),0);
      chartData.addEntry(new Entry(quaternion.x(),sampleCount),1);
      chartData.addEntry(new Entry(quaternion.y(),sampleCount),2);
      chartData.addEntry(new Entry(quaternion.z(),sampleCount),3);
      sampleCount++;
    }
)).continueWith(task -> {
      streamRoute=task.getResult();
      sensorFusion.quaternion().start();
      sensorFusion.start();
      return null;
    }
);
  }
 else {
    sensorFusion.eulerAngles().addRouteAsync(source -> source.stream((data,env) -> {
      LineData chartData=chart.getData();
      final EulerAngles angles=data.value(EulerAngles.class);
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * SAMPLING_PERIOD));
      chartData.addEntry(new Entry(angles.heading(),sampleCount),0);
      chartData.addEntry(new Entry(angles.pitch(),sampleCount),1);
      chartData.addEntry(new Entry(angles.roll(),sampleCount),2);
      chartData.addEntry(new Entry(angles.yaw(),sampleCount),3);
      sampleCount++;
    }
)).continueWith(task -> {
      streamRoute=task.getResult();
      sensorFusion.eulerAngles().start();
      sensorFusion.start();
      return null;
    }
);
  }
}","@Override protected void setup(){
  sensorFusion.configure().mode(Mode.NDOF).accRange(AccRange.AR_16G).gyroRange(GyroRange.GR_2000DPS).commit();
  if (srcIndex == 0) {
    sensorFusion.quaternion().addRouteAsync(source -> source.stream((data,env) -> {
      LineData chartData=chart.getData();
      final Quaternion quaternion=data.value(Quaternion.class);
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * SAMPLING_PERIOD));
      chartData.addEntry(new Entry(quaternion.w(),sampleCount),0);
      chartData.addEntry(new Entry(quaternion.x(),sampleCount),1);
      chartData.addEntry(new Entry(quaternion.y(),sampleCount),2);
      chartData.addEntry(new Entry(quaternion.z(),sampleCount),3);
      sampleCount++;
      updateChart();
    }
)).continueWith(task -> {
      streamRoute=task.getResult();
      sensorFusion.quaternion().start();
      sensorFusion.start();
      return null;
    }
);
  }
 else {
    sensorFusion.eulerAngles().addRouteAsync(source -> source.stream((data,env) -> {
      LineData chartData=chart.getData();
      final EulerAngles angles=data.value(EulerAngles.class);
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * SAMPLING_PERIOD));
      chartData.addEntry(new Entry(angles.heading(),sampleCount),0);
      chartData.addEntry(new Entry(angles.pitch(),sampleCount),1);
      chartData.addEntry(new Entry(angles.roll(),sampleCount),2);
      chartData.addEntry(new Entry(angles.yaw(),sampleCount),3);
      sampleCount++;
      updateChart();
    }
)).continueWith(task -> {
      streamRoute=task.getResult();
      sensorFusion.eulerAngles().start();
      sensorFusion.start();
      return null;
    }
);
  }
}",0.9876106194690264
22544,"@Override protected void setup(){
  Temperature.Sensor tempSensor=tempModule.sensors()[selectedSourceIndex];
  if (tempSensor.type() == SensorType.EXT_THERMISTOR) {
    ((Temperature.ExternalThermistor)tempModule.sensors()[selectedSourceIndex]).configure(gpioDataPin,gpioPulldownPin,activeHigh);
  }
  tempSensor.addRouteAsync(source -> source.stream((data,env) -> {
    final Float celsius=data.value(Float.class);
    LineData chartData=chart.getData();
    if (startTime == -1) {
      chartData.addXValue(""String_Node_Str"");
      startTime=System.currentTimeMillis();
    }
 else {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplingPeriod));
    }
    chartData.addEntry(new Entry(celsius,sampleCount),0);
    sampleCount++;
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return timerModule.scheduleAsync(TEMP_SAMPLE_PERIOD,false,tempSensor::read);
  }
).continueWithTask(task -> {
    scheduledTask=task.getResult();
    scheduledTask.start();
    return null;
  }
);
}","@Override protected void setup(){
  Temperature.Sensor tempSensor=tempModule.sensors()[selectedSourceIndex];
  if (tempSensor.type() == SensorType.EXT_THERMISTOR) {
    ((Temperature.ExternalThermistor)tempModule.sensors()[selectedSourceIndex]).configure(gpioDataPin,gpioPulldownPin,activeHigh);
  }
  tempSensor.addRouteAsync(source -> source.stream((data,env) -> {
    final Float celsius=data.value(Float.class);
    LineData chartData=chart.getData();
    if (startTime == -1) {
      chartData.addXValue(""String_Node_Str"");
      startTime=System.currentTimeMillis();
    }
 else {
      chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplingPeriod));
    }
    chartData.addEntry(new Entry(celsius,sampleCount),0);
    sampleCount++;
    updateChart();
  }
)).continueWithTask(task -> {
    streamRoute=task.getResult();
    return timerModule.scheduleAsync(TEMP_SAMPLE_PERIOD,false,tempSensor::read);
  }
).continueWithTask(task -> {
    scheduledTask=task.getResult();
    scheduledTask.start();
    return null;
  }
);
}",0.9909480705097664
22545,"protected void addChartData(float x0,float x1,float x2,float samplePeriod){
  LineData chartData=chart.getData();
  chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplePeriod));
  chartData.addEntry(new Entry(x0,sampleCount),0);
  chartData.addEntry(new Entry(x1,sampleCount),1);
  chartData.addEntry(new Entry(x2,sampleCount),2);
  sampleCount++;
}","protected void addChartData(float x0,float x1,float x2,float samplePeriod){
  LineData chartData=chart.getData();
  chartData.addXValue(String.format(Locale.US,""String_Node_Str"",sampleCount * samplePeriod));
  chartData.addEntry(new Entry(x0,sampleCount),0);
  chartData.addEntry(new Entry(x1,sampleCount),1);
  chartData.addEntry(new Entry(x2,sampleCount),2);
  sampleCount++;
  updateChart();
}",0.9780645161290322
22546,"/** 
 * Returns <code>true</code> if the EObject is a Dart class.
 * @param eObject The EObject
 * @return <code>true</code> if the EObject is a Dart class
 */
public boolean isStrictlyClass(EObject eObject){
  return eObject instanceof Class && ""String_Node_Str"".equals(eObject.getClass().getName());
}","/** 
 * Returns <code>true</code> if the EObject is a Dart class.
 * @param eObject The EObject
 * @return <code>true</code> if the EObject is a Dart class
 */
public boolean isStrictlyClass(EObject eObject){
  return eObject instanceof Class && ""String_Node_Str"".equals(eObject.getClass().getSimpleName());
}",0.9901960784313726
22547,"/** 
 * Edit the label of the field with the given label.
 * @param eObject The field to edit
 * @param label The label
 * @return The edited field
 */
public EObject editField(EObject eObject,String label){
  if (eObject instanceof Variable) {
    Variable field=(Variable)eObject;
    int indexOfTypeSeparator=label.indexOf(':');
    int indexOfValueSeparator=label.indexOf('=');
    int firstSeparator=label.length();
    if (indexOfTypeSeparator != -1 && indexOfTypeSeparator < firstSeparator) {
      firstSeparator=indexOfTypeSeparator;
    }
    if (indexOfValueSeparator != -1 && indexOfValueSeparator < firstSeparator) {
      firstSeparator=indexOfValueSeparator;
    }
    if (firstSeparator != -1) {
      String name=label.substring(0,firstSeparator);
      if (name.length() > 0) {
        field.setName(name);
      }
      if (indexOfValueSeparator == -1 || indexOfValueSeparator < indexOfTypeSeparator) {
        String typeName=label.substring(indexOfTypeSeparator + 1);
        Type type=this.findTypeByName(this.allRoots(field),typeName);
        field.setType(type);
      }
 else       if (indexOfValueSeparator > indexOfTypeSeparator) {
        String typeName=label.substring(indexOfTypeSeparator + 1,indexOfValueSeparator);
        Type type=this.findTypeByName(this.allRoots(field),typeName);
        field.setType(type);
      }
      if (indexOfTypeSeparator == -1 || indexOfTypeSeparator < indexOfValueSeparator) {
        String value=label.substring(indexOfValueSeparator + 1);
        field.setValue(value);
      }
 else       if (indexOfTypeSeparator > indexOfValueSeparator) {
        String value=label.substring(indexOfValueSeparator + 1,indexOfTypeSeparator);
        field.setValue(value);
      }
    }
 else     if (label.length() > 0) {
      field.setName(label);
    }
  }
  return eObject;
}","/** 
 * Edit the label of the field with the given label.
 * @param eObject The field to edit
 * @param label The label
 * @return The edited field
 */
public EObject editField(EObject eObject,String label){
  if (eObject instanceof Variable) {
    Variable field=(Variable)eObject;
    int indexOfTypeSeparator=label.indexOf(':');
    int indexOfValueSeparator=label.indexOf('=');
    int firstSeparator=label.length();
    if (indexOfTypeSeparator != -1 && indexOfTypeSeparator < firstSeparator) {
      firstSeparator=indexOfTypeSeparator;
    }
    if (indexOfValueSeparator != -1 && indexOfValueSeparator < firstSeparator) {
      firstSeparator=indexOfValueSeparator;
    }
    if (firstSeparator != -1) {
      String name=label.substring(0,firstSeparator);
      if (name.length() > 0) {
        field.setName(name);
      }
      if (indexOfTypeSeparator != -1 && (indexOfValueSeparator == -1 || indexOfValueSeparator < indexOfTypeSeparator)) {
        String typeName=label.substring(indexOfTypeSeparator + 1);
        Type type=this.findTypeByName(this.allRoots(field),typeName);
        field.setType(type);
      }
 else       if (indexOfTypeSeparator != -1 && indexOfValueSeparator > indexOfTypeSeparator) {
        String typeName=label.substring(indexOfTypeSeparator + 1,indexOfValueSeparator);
        Type type=this.findTypeByName(this.allRoots(field),typeName);
        field.setType(type);
      }
      if (indexOfValueSeparator != -1 && (indexOfTypeSeparator == -1 || indexOfTypeSeparator < indexOfValueSeparator)) {
        String value=label.substring(indexOfValueSeparator + 1);
        field.setValue(value);
      }
 else       if (indexOfValueSeparator != -1 && indexOfTypeSeparator > indexOfValueSeparator) {
        String value=label.substring(indexOfValueSeparator + 1,indexOfTypeSeparator);
        field.setValue(value);
      }
    }
 else     if (label.length() > 0) {
      field.setName(label);
    }
  }
  return eObject;
}",0.950500263296472
22548,"public static void main(String[] arg){
  LwjglApplicationConfiguration config=new LwjglApplicationConfiguration();
  new LwjglApplication(new Bouncy(),config);
}","public static void main(String[] arg){
  LwjglApplicationConfiguration config=new LwjglApplicationConfiguration();
  config.title=""String_Node_Str"";
  config.width=480;
  config.height=800;
  new LwjglApplication(new Bouncy(),config);
}",0.8110831234256927
22549,"public FreeMarkerOnlineView(FreeMarkerOnlineViewResultType resultType,String resultText,String template,String dataModel){
  super(""String_Node_Str"");
  Assert.notNull(resultType);
  this.resultType=resultType;
  this.result=decorateResultText(resultText,resultType);
  this.template=template;
  this.dataModel=dataModel;
}","public FreeMarkerOnlineView(FreeMarkerOnlineViewResultType resultType,String resultText,String template,String dataModel){
  super(""String_Node_Str"",Charset.forName(""String_Node_Str""));
  Assert.notNull(resultType);
  this.resultType=resultType;
  this.result=decorateResultText(resultText,resultType);
  this.template=template;
  this.dataModel=dataModel;
}",0.948604992657856
22550,"@Test public void testResultTruncation(){
  freeMarkerService.setOutputLengthLimit(4);
  FreeMarkerServiceResponse serviceResponse=freeMarkerService.calculateFreeMarkerTemplate(TRUNCATION_TEST_TEMPLATE,Collections.<String,String>emptyMap());
  assertThat(serviceResponse.isSucceed(),is(true));
  assertThat(serviceResponse.isResultTruncated(),is(true));
  assertThat(serviceResponse.getResult(),startsWith(TRUNCATION_TEST_TEMPLATE.substring(0,freeMarkerService.getOutputLengthLimit())));
  assertThat(serviceResponse.getResult().charAt(freeMarkerService.getOutputLengthLimit()),not(equalTo(TRUNCATION_TEST_TEMPLATE.charAt(freeMarkerService.getOutputLengthLimit()))));
}","@Test public void testResultTruncation(){
  freeMarkerService.setOutputLengthLimit(4);
  FreeMarkerServiceResponse serviceResponse=freeMarkerService.calculateFreeMarkerTemplate(TRUNCATION_TEST_TEMPLATE,Collections.<String,String>emptyMap());
  assertThat(serviceResponse.isSucceed(),is(true));
  assertThat(serviceResponse.isResultTruncated(),is(true));
  assertThat(serviceResponse.getResult().substring(0,freeMarkerService.getOutputLengthLimit()),equalTo(TRUNCATION_TEST_TEMPLATE.substring(0,freeMarkerService.getOutputLengthLimit())));
  assertThat(serviceResponse.getResult().charAt(freeMarkerService.getOutputLengthLimit()),not(equalTo(TRUNCATION_TEST_TEMPLATE.charAt(freeMarkerService.getOutputLengthLimit()))));
}",0.9488840892728582
22551,"/** 
 * Unregisters messageListener so that it will no longer receive   {@link QMessage}.
 * @param listener a  {@link QMessagesListener} to be unregistered
 */
public synchronized void removeMessagesListener(final QMessagesListener listener){
  messagesListeners.remove(listener);
}","/** 
 * Unregisters messageListener so that it will no longer receive   {@link QMessage}.
 * @param listener a  {@link QMessagesListener} to be unregistered
 */
public void removeMessagesListener(final QMessagesListener listener){
  messagesListeners.remove(listener);
}",0.976491862567812
22552,"/** 
 * Registers messageListener so that it will receive   {@link QMessage} when data from kdb+ has been received.
 * @param listener a  {@link QMessagesListener} to be registered
 */
public synchronized void addMessagesListener(final QMessagesListener listener){
  messagesListeners.add(listener);
}","/** 
 * Registers messageListener so that it will receive   {@link QMessage} when data from kdb+ has been received.
 * @param listener a  {@link QMessagesListener} to be registered
 */
public void addMessagesListener(final QMessagesListener listener){
  messagesListeners.add(listener);
}",0.9779286926994908
22553,"private static synchronized DateFormat getDateformat(){
  return dateFormat;
}","private static DateFormat getDateformat(){
  return (DateFormat)dateFormat.clone();
}",0.7975460122699386
22554,"private static synchronized DateFormat getDateformat(){
  return dateFormat;
}","private static DateFormat getDateformat(){
  return (DateFormat)dateFormat.clone();
}",0.7975460122699386
22555,"/** 
 * Indicates whether some other object is ""equal to"" this dictionary.   {@link QDictionary} objects are consideredequal if the keys and values lists are equal for both instances.
 * @return <code>true</code> if this object is the same as the obj argument, <code>false</code> otherwise.
 * @see java.lang.Object#equals(java.lang.Object)
 */
@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (!(obj instanceof QDictionary)) {
    return false;
  }
  final QDictionary d=(QDictionary)obj;
  if (areValuesArray) {
    return Utils.deepArraysEquals(keys,d.keys) && Utils.deepArraysEquals(values,d.values);
  }
 else {
    return Utils.deepArraysEquals(keys,d.keys) && ((QTable)values).equals(d.values);
  }
}","/** 
 * Indicates whether some other object is ""equal to"" this dictionary.   {@link QDictionary} objects are consideredequal if the keys and values lists are equal for both instances.
 * @return <code>true</code> if this object is the same as the obj argument, <code>false</code> otherwise.
 * @see java.lang.Object#equals(java.lang.Object)
 */
@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (!(obj instanceof QDictionary)) {
    return false;
  }
  final QDictionary d=(QDictionary)obj;
  if (areValuesArray) {
    return Utils.deepArraysEquals(keys,d.keys) && Utils.deepArraysEquals(values,d.values);
  }
 else {
    return Utils.deepArraysEquals(keys,d.keys) && values.equals(d.values);
  }
}",0.9933422103861518
22556,"private static synchronized DateFormat getDateformat(){
  return dateFormat;
}","private static DateFormat getDateformat(){
  return (DateFormat)dateFormat.clone();
}",0.7975460122699386
22557,"private static synchronized NumberFormat getNanosformat(){
  return nanosFormatter;
}","private static NumberFormat getNanosformat(){
  return (NumberFormat)nanosFormatter.clone();
}",0.8044692737430168
22558,"private static synchronized DateFormat getDateformat(){
  return dateFormat;
}","private static DateFormat getDateformat(){
  return (DateFormat)dateFormat.clone();
}",0.7975460122699386
22559,"/** 
 * Returns a String that represents the current   {@link QTimespan}.
 * @return a String representation of the {@link QTimespan}
 * @see java.lang.Object#toString()
 */
@Override public String toString(){
  final Date dt=toDateTime();
  return dt == null ? NULL_STR : (value < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + (Math.abs(value) / NANOS_PER_DAY) + getDateformat().format(dt)+ nanosFormatter.format(Math.abs(value) % NANOS_PER_SECOND);
}","/** 
 * Returns a String that represents the current   {@link QTimespan}.
 * @return a String representation of the {@link QTimespan}
 * @see java.lang.Object#toString()
 */
@Override public String toString(){
  final Date dt=toDateTime();
  return dt == null ? NULL_STR : (value < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + (Math.abs(value) / NANOS_PER_DAY) + getDateformat().format(dt)+ getNanosformat().format(Math.abs(value) % NANOS_PER_SECOND);
}",0.9668141592920354
22560,"private static synchronized NumberFormat getNanosformat(){
  return nanosFormatter;
}","private static NumberFormat getNanosformat(){
  return (NumberFormat)nanosFormatter.clone();
}",0.8044692737430168
22561,"private static synchronized DateFormat getDateformat(){
  return dateFormat;
}","private static DateFormat getDateformat(){
  return (DateFormat)dateFormat.clone();
}",0.7975460122699386
22562,"/** 
 * Returns a String that represents the current   {@link QTimestamp}.
 * @return a String representation of the {@link QTimestamp}
 * @see java.lang.Object#toString()
 */
@Override public String toString(){
  final Date dt=toDateTime();
  return dt == null ? NULL_STR : getDateformat().format(dt) + nanosFormatter.format(value % NANOS_PER_SECOND);
}","/** 
 * Returns a String that represents the current   {@link QTimestamp}.
 * @return a String representation of the {@link QTimestamp}
 * @see java.lang.Object#toString()
 */
@Override public String toString(){
  final Date dt=toDateTime();
  return dt == null ? NULL_STR : getDateformat().format(dt) + getNanosformat().format(value % NANOS_PER_SECOND);
}",0.9577464788732394
22563,"public void writeLongBigEndian(final long value){
  final byte[] arr=new byte[]{(byte)((value >> 56) & 0xff),(byte)((value >> 48) & 0xff),(byte)((value >> 40) & 0xff),(byte)((value >> 32) & 0xff),(byte)((value >> 24) & 0xff),(byte)((value >> 16) & 0xff),(byte)((value >> 8) & 0xff),(byte)((value >> 0) & 0xff)};
  for (int i=0; i < arr.length; i++) {
    writeByte(arr[i]);
  }
}","public void writeLongBigEndian(final long value){
  final byte[] arr=new byte[]{(byte)((value >> 56) & 0xff),(byte)((value >> 48) & 0xff),(byte)((value >> 40) & 0xff),(byte)((value >> 32) & 0xff),(byte)((value >> 24) & 0xff),(byte)((value >> 16) & 0xff),(byte)((value >> 8) & 0xff),(byte)((value >> 0) & 0xff)};
  for (  byte anArr : arr) {
    writeByte(anArr);
  }
}",0.8728246318607764
22564,"static String arrayToString(final Object list){
  if (list == null || !list.getClass().isArray() || Array.getLength(list) == 0) {
    return ""String_Node_Str"";
  }
 else {
    final int length=Array.getLength(list);
    final StringBuffer buffer=new StringBuffer(""String_Node_Str"");
    Object obj=Array.get(list,0);
    buffer.append(obj == null ? null : obj.getClass().isArray() ? arrayToString(obj) : obj);
    for (int i=1; i < length; i++) {
      obj=Array.get(list,i);
      buffer.append(""String_Node_Str"");
      buffer.append(obj == null ? null : obj.getClass().isArray() ? arrayToString(obj) : obj);
    }
    buffer.append(']');
    return buffer.toString();
  }
}","static String arrayToString(final Object list){
  if (list == null || !list.getClass().isArray() || Array.getLength(list) == 0) {
    return ""String_Node_Str"";
  }
 else {
    final int length=Array.getLength(list);
    final StringBuilder buffer=new StringBuilder(""String_Node_Str"");
    Object obj=Array.get(list,0);
    buffer.append(obj == null ? null : obj.getClass().isArray() ? arrayToString(obj) : obj);
    for (int i=1; i < length; i++) {
      obj=Array.get(list,i);
      buffer.append(""String_Node_Str"");
      buffer.append(obj == null ? null : obj.getClass().isArray() ? arrayToString(obj) : obj);
    }
    buffer.append(']');
    return buffer.toString();
  }
}",0.9926144756277696
22565,"/** 
 * Create a directory and any nonexistent parents. Any portion of the directory tree can exist without error.
 * @param path The directory path to create
 * @param perms The permissions to apply to the created directories.
 * @return true if successful, false otherwise
 * @throws IOException if the path is a child of a file.
 */
@Override public boolean mkdirs(Path path,FsPermission perms) throws IOException {
  path=makeAbsolute(path);
  boolean result=false;
  try {
    ceph.mkdirs(path,(int)perms.toShort());
    result=true;
  }
 catch (  CephFileAlreadyExistsException e) {
    result=true;
  }
  return result;
}","/** 
 * Create a directory and any nonexistent parents. Any portion of the directory tree can exist without error.  Apply umask from conf
 * @param f The directory path to create
 * @return true if successful, false otherwise
 * @throws IOException if the path is a child of a file.
 */
@Override public boolean mkdirs(Path f) throws IOException {
  return mkdirs(f,FsPermission.getDirDefault().applyUMask(FsPermission.getUMask(getConf())));
}",0.6162464985994398
22566,"private String pathString(Path path){
  return path.toUri().getPath();
}","private String pathString(Path path){
  if (null == path) {
    return ""String_Node_Str"";
  }
  return path.toUri().getPath();
}",0.72
22567,"/** 
 * See MAPREDUCE-5902 for context on why this test is critical for ecosystem interoperability.
 */
@org.junit.Test public void testEncodedPaths() throws Exception {
  FileSystem fs2=fs;
  Path encodedFiles=new Path(""String_Node_Str"" + System.currentTimeMillis());
  fs2.mkdirs(encodedFiles);
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  Assert.assertEquals(5,fs2.listStatus(encodedFiles).length);
  fs2.delete(encodedFiles);
}","/** 
 * See MAPREDUCE-5902 for context on why this test is critical for ecosystem interoperability.
 */
@org.junit.Test public void testEncodedPaths() throws Exception {
  FileSystem fs2=fs;
  Path encodedFiles=new Path(""String_Node_Str"" + System.currentTimeMillis());
  fs2.mkdirs(encodedFiles);
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  fs2.create(new Path(encodedFiles,""String_Node_Str""));
  Assert.assertEquals(5,fs2.listStatus(encodedFiles).length);
  fs2.delete(encodedFiles,true);
}",0.9962714392244594
22568,"@Test public void testGlobStatusThrowsExceptionForNonExistentFile() throws Exception {
  try {
    fSys.globStatus(getTestRootPath(fSys,""String_Node_Str""));
  }
 catch (  FileNotFoundException fnfe) {
  }
}","@Test public void testGlobStatusThrowsExceptionForNonExistentFile() throws Exception {
  try {
    fSys.globStatus(getTestRootPath(fSys,""String_Node_Str""));
  }
 catch (  FileNotFoundException fnfe) {
  }
catch (  NullPointerException ne) {
  }
}",0.9070796460176992
22569,"@Test public void testMkdirsFailsForSubdirectoryOfExistingFile() throws Exception {
  Path testDir=getTestRootPath(fSys,""String_Node_Str"");
  Assert.assertFalse(exists(fSys,testDir));
  fSys.mkdirs(testDir);
  Assert.assertTrue(exists(fSys,testDir));
  createFile(getTestRootPath(fSys,""String_Node_Str""));
  Path testSubDir=getTestRootPath(fSys,""String_Node_Str"");
  try {
    Assert.assertFalse(fSys.mkdirs(testSubDir));
  }
 catch (  FileAlreadyExistsException ex) {
  }
  Assert.assertFalse(exists(fSys,testSubDir));
  Path testDeepSubDir=getTestRootPath(fSys,""String_Node_Str"");
  Assert.assertFalse(exists(fSys,testSubDir));
  try {
    Assert.assertFalse(fSys.mkdirs(testDeepSubDir));
  }
 catch (  FileAlreadyExistsException ex) {
  }
  Assert.assertFalse(exists(fSys,testDeepSubDir));
}","@Test public void testMkdirsFailsForSubdirectoryOfExistingFile() throws Exception {
  Path testDir=getTestRootPath(fSys,""String_Node_Str"");
  Assert.assertFalse(exists(fSys,testDir));
  fSys.mkdirs(testDir);
  Assert.assertTrue(exists(fSys,testDir));
  createFile(getTestRootPath(fSys,""String_Node_Str""));
  Path testSubDir=getTestRootPath(fSys,""String_Node_Str"");
  try {
    Assert.assertFalse(fSys.mkdirs(testSubDir));
  }
 catch (  IOException ex) {
  }
  Assert.assertFalse(exists(fSys,testSubDir));
  Path testDeepSubDir=getTestRootPath(fSys,""String_Node_Str"");
  Assert.assertFalse(exists(fSys,testSubDir));
  try {
    Assert.assertFalse(fSys.mkdirs(testDeepSubDir));
  }
 catch (  IOException ex) {
  }
  Assert.assertFalse(exists(fSys,testDeepSubDir));
}",0.8883183568677792
22570,"public ArmorProperties getProperties(EntityLivingBase player,ItemStack armor,DamageSource source,double damage,int slot){
  ArmorProperties prop=new ArmorProperties(0,0.0,0);
  ItemBackpack backpack=(ItemBackpack)armor.getItem();
  prop.Armor=backpack.getArmorDamageReductionAmount(armor);
  prop.Toughness=backpack.getArmorToughness(armor);
  prop.AbsorbRatio=prop.Armor / 25.0;
  prop.AbsorbMax=armor.getMaxDamage() - armor.getItemDamage() + 1;
  return prop;
}","public ArmorProperties getProperties(EntityLivingBase player,ItemStack armor,DamageSource source,double damage,int slot){
  ArmorProperties prop=new ArmorProperties(0,0.0,0);
  ItemBackpack backpack=(ItemBackpack)armor.getItem();
  prop.Armor=backpack.getArmorDamageReductionAmount(armor);
  prop.Toughness=backpack.getArmorToughness(armor);
  prop.AbsorbRatio=prop.Armor / 25.0;
  prop.AbsorbMax=Math.max(1,armor.getMaxDamage() - armor.getItemDamage() + 1);
  return prop;
}",0.9872068230277186
22571,"@Override public void onPlacedInteract(EntityPlayer player,TileEntity tileEntity,IBackpack backpack){
  if (player.world.isRemote)   return;
  new ContainerBackpack(player,backpack){
    @Override public boolean canInteractWith(    EntityPlayer player){
      return (player.isEntityAlive() && !tileEntity.isInvalid() && (player.world.getTileEntity(tileEntity.getPos()) == tileEntity)&& (player.getDistanceSq(tileEntity.getPos()) <= 64));
    }
  }
.open();
}","@Override public void onPlacedInteract(EntityPlayer player,TileEntity tileEntity,IBackpack backpack){
  if (player.world.isRemote)   return;
  new ContainerBackpack(player,backpack){
    @Override public boolean canInteractWith(    EntityPlayer player){
      return player.isEntityAlive() && !tileEntity.isInvalid() && (player.world.getTileEntity(tileEntity.getPos()) == tileEntity)&& (player.getDistanceSq(tileEntity.getPos()) <= 64);
    }
  }
.open();
}",0.9978165938864628
22572,"@Override public void deserializeNBT(NBTTagCompound compound){
  backpack.stack=NbtUtils.readItem(compound.getCompoundTag(TAG_STACK));
  IBackpackType type;
  if (backpack.stack == null) {
    String typeString=compound.getString(TAG_TYPE);
    type=BackpackHelper.getBackpackType((typeString != null) ? Item.getByNameOrId(typeString) : null);
    backpack.lastType=type;
  }
 else   type=BackpackHelper.getBackpackType(backpack.stack);
  if (type == null) {
    WearableBackpacks.LOG.error(""String_Node_Str"");
    return;
  }
  backpack.data=type.createBackpackData();
  NBTBase dataTag=compound.getTag(TAG_DATA);
  if ((backpack.data != null) && (dataTag != null))   backpack.data.deserializeNBT(dataTag);
}","@Override public void deserializeNBT(NBTTagCompound compound){
  backpack.stack=NbtUtils.readItem(compound.getCompoundTag(TAG_STACK));
  IBackpackType type;
  if (backpack.stack == null) {
    if (!compound.hasKey(TAG_TYPE,NbtType.STRING))     return;
    String id=compound.getString(TAG_TYPE);
    backpack.lastType=type=BackpackHelper.getBackpackType(Item.REGISTRY.getObject(new ResourceLocation(id)));
    if (type == null)     return;
  }
 else   type=BackpackHelper.getBackpackType(backpack.stack);
  if (type == null) {
    WearableBackpacks.LOG.error(""String_Node_Str"");
    return;
  }
  backpack.data=type.createBackpackData();
  NBTBase dataTag=compound.getTag(TAG_DATA);
  if ((backpack.data != null) && (dataTag != null))   backpack.data.deserializeNBT(dataTag);
}",0.7792732166890982
22573,"public GroupsActor(){
  receive(ReceiveBuilder.match(Messages.GroupJoin.class,groupJoin -> {
    groups.computeIfAbsent(groupJoin.hubname,k -> new HashMap<>()).computeIfAbsent(groupJoin.groupname,k -> new HashSet<>());
    groups.get(groupJoin.hubname).get(groupJoin.groupname).add(groupJoin.uuid);
    usersInGroup.computeIfAbsent(groupJoin.hubname,k -> new HashMap<>()).computeIfAbsent(groupJoin.uuid,k -> new HashSet<>());
    usersInGroup.get(groupJoin.hubname).get(groupJoin.uuid).add(groupJoin.groupname);
    Logger.debug(groupJoin.uuid + ""String_Node_Str"" + groupJoin.groupname);
  }
).match(Messages.GroupLeave.class,groupLeave -> {
    leaveGroup(groupLeave.hubname,groupLeave.uuid,groupLeave.groupname);
    Logger.debug(groupLeave.uuid + ""String_Node_Str"" + groupLeave.groupname);
  }
).match(Messages.Quit.class,quit -> {
    groups.keySet().stream().forEach(hubname -> groups.get(hubname).keySet().forEach(group -> leaveGroup(hubname,quit.uuid,group)));
  }
).match(Messages.ClientFunctionCall.class,clientFunctionCall -> {
switch (clientFunctionCall.sendType) {
case All:
case Others:
case Caller:
case Clients:
case AllExcept:
      throw new IllegalStateException(""String_Node_Str"" + clientFunctionCall.sendType);
case Group:
    if (groups.containsKey(clientFunctionCall.hubName) && groups.get(clientFunctionCall.hubName).containsKey(clientFunctionCall.groupName)) {
      signalJActor.forward(new Messages.ClientFunctionCall(clientFunctionCall.method,clientFunctionCall.hubName,null,Messages.SendType.Clients,clientFunctionCall.name,clientFunctionCall.args,groups.get(clientFunctionCall.hubName).get(clientFunctionCall.groupName).toArray(new UUID[0]),clientFunctionCall.allExcept,clientFunctionCall.groupName),getContext());
    }
  break;
case InGroupExcept:
final List<UUID> inGroupExcept=Arrays.asList(clientFunctionCall.allExcept);
if (groups.containsKey(clientFunctionCall.hubName) && groups.get(clientFunctionCall.hubName).containsKey(clientFunctionCall.groupName)) {
final List<UUID> sendTo=(groups.get(clientFunctionCall.hubName).get(clientFunctionCall.groupName).stream().filter(uuid -> !inGroupExcept.contains(uuid)).collect(Collectors.toList()));
signalJActor.forward(new Messages.ClientFunctionCall(clientFunctionCall.method,clientFunctionCall.hubName,null,Messages.SendType.Clients,clientFunctionCall.name,clientFunctionCall.args,sendTo.toArray(new UUID[0]),clientFunctionCall.allExcept,clientFunctionCall.groupName),getContext());
}
break;
}
}
).build());
}","public GroupsActor(){
  receive(ReceiveBuilder.match(Messages.GroupJoin.class,groupJoin -> {
    groups.computeIfAbsent(groupJoin.hubname,k -> new HashMap<>()).computeIfAbsent(groupJoin.groupname,k -> new HashSet<>());
    groups.get(groupJoin.hubname).get(groupJoin.groupname).add(groupJoin.uuid);
    usersInGroup.computeIfAbsent(groupJoin.hubname,k -> new HashMap<>()).computeIfAbsent(groupJoin.uuid,k -> new HashSet<>());
    usersInGroup.get(groupJoin.hubname).get(groupJoin.uuid).add(groupJoin.groupname);
    Logger.debug(groupJoin.uuid + ""String_Node_Str"" + groupJoin.groupname);
  }
).match(Messages.GroupLeave.class,groupLeave -> {
    leaveGroup(groupLeave.hubname,groupLeave.uuid,groupLeave.groupname);
    Logger.debug(groupLeave.uuid + ""String_Node_Str"" + groupLeave.groupname);
  }
).match(Messages.Quit.class,quit -> {
    final Set<String> hubs=getKeys(groups.keySet());
    hubs.stream().forEach(hubname -> {
      final Set<String> groupnames=getKeys(groups.get(hubname).keySet());
      groupnames.forEach(group -> leaveGroup(hubname,quit.uuid,group));
    }
);
  }
).match(Messages.ClientFunctionCall.class,clientFunctionCall -> {
switch (clientFunctionCall.sendType) {
case All:
case Others:
case Caller:
case Clients:
case AllExcept:
      throw new IllegalStateException(""String_Node_Str"" + clientFunctionCall.sendType);
case Group:
    if (groups.containsKey(clientFunctionCall.hubName) && groups.get(clientFunctionCall.hubName).containsKey(clientFunctionCall.groupName)) {
      signalJActor.forward(new Messages.ClientFunctionCall(clientFunctionCall.method,clientFunctionCall.hubName,null,Messages.SendType.Clients,clientFunctionCall.name,clientFunctionCall.args,groups.get(clientFunctionCall.hubName).get(clientFunctionCall.groupName).toArray(new UUID[0]),clientFunctionCall.allExcept,clientFunctionCall.groupName),getContext());
    }
  break;
case InGroupExcept:
final List<UUID> inGroupExcept=Arrays.asList(clientFunctionCall.allExcept);
if (groups.containsKey(clientFunctionCall.hubName) && groups.get(clientFunctionCall.hubName).containsKey(clientFunctionCall.groupName)) {
final List<UUID> sendTo=(groups.get(clientFunctionCall.hubName).get(clientFunctionCall.groupName).stream().filter(uuid -> !inGroupExcept.contains(uuid)).collect(Collectors.toList()));
signalJActor.forward(new Messages.ClientFunctionCall(clientFunctionCall.method,clientFunctionCall.hubName,null,Messages.SendType.Clients,clientFunctionCall.name,clientFunctionCall.args,sendTo.toArray(new UUID[0]),clientFunctionCall.allExcept,clientFunctionCall.groupName),getContext());
}
break;
}
}
).build());
}",0.9776207302709068
22574,"private void attemptStopTransport(){
  try {
    transport.tell(PoisonPill.getInstance(),self());
  }
 catch (  Exception e) {
  }
}","private void attemptStopTransport(){
  try {
    if (connected)     transport.tell(PoisonPill.getInstance(),self());
  }
 catch (  Exception e) {
  }
}",0.9328621908127208
22575,"UserActor(ProtectedData protectedData){
  this.protectedData=protectedData;
  receive(ReceiveBuilder.match(Messages.Join.class,join -> {
    transport=context().actorOf(Props.create(WebsocketTransport.class,protectedData,join));
    transport.tell(join,self());
  }
).match(Messages.MethodReturn.class,methodReturn -> {
    final Messages.MethodReturn message=new Messages.MethodReturn(methodReturn.context,methodReturn.returnValue,messageId++);
    messages.put(messageId,message);
    transport.tell(message,self());
  }
).match(Messages.ClientFunctionCall.class,clientFunctionCall -> {
    final Messages.ClientFunctionCall message=new Messages.ClientFunctionCall(clientFunctionCall.method,clientFunctionCall.hubName,clientFunctionCall.context,clientFunctionCall.sendType,clientFunctionCall.name,clientFunctionCall.args,clientFunctionCall.clients,clientFunctionCall.allExcept,clientFunctionCall.groupName,messageId++);
    messages.put(messageId,message);
    transport.tell(message,self());
  }
).match(Messages.ClientCallEnd.class,clientCallEnd -> {
    final Messages.ClientCallEnd message=new Messages.ClientCallEnd(clientCallEnd.context,messageId++);
    messages.put(messageId,message);
    transport.tell(message,self());
  }
).match(Messages.Reconnect.class,reconnect -> {
    attemptStopTransport();
    final Messages.Join join=new Messages.Join(reconnect.out,reconnect.in,reconnect.uuid);
    transport=context().actorOf(Props.create(WebsocketTransport.class,protectedData,join));
    transport.tell(reconnect,self());
    resendMessages();
  }
).match(Messages.Quit.class,quit -> {
    context().setReceiveTimeout(Duration.create(""String_Node_Str""));
  }
).match(ReceiveTimeout.class,r -> {
    context().stop(self());
  }
).match(Messages.Ack.class,ack -> {
    messages.remove(ack.MessageId);
  }
).build());
}","UserActor(ProtectedData protectedData){
  this.protectedData=protectedData;
  receive(ReceiveBuilder.match(Messages.Join.class,join -> {
    transport=context().actorOf(Props.create(WebsocketTransport.class,protectedData,join));
    transport.tell(join,self());
    connected=true;
    context().watch(transport);
  }
).match(Messages.MethodReturn.class,methodReturn -> {
    final Messages.MethodReturn message=new Messages.MethodReturn(methodReturn.context,methodReturn.returnValue,messageId++);
    messages.put(messageId,message);
    transport.tell(message,self());
  }
).match(Messages.ClientFunctionCall.class,clientFunctionCall -> {
    final Messages.ClientFunctionCall message=new Messages.ClientFunctionCall(clientFunctionCall.method,clientFunctionCall.hubName,clientFunctionCall.context,clientFunctionCall.sendType,clientFunctionCall.name,clientFunctionCall.args,clientFunctionCall.clients,clientFunctionCall.allExcept,clientFunctionCall.groupName,messageId++);
    messages.put(messageId,message);
    transport.tell(message,self());
  }
).match(Messages.ClientCallEnd.class,clientCallEnd -> {
    final Messages.ClientCallEnd message=new Messages.ClientCallEnd(clientCallEnd.context,messageId++);
    messages.put(messageId,message);
    transport.tell(message,self());
  }
).match(Messages.Reconnect.class,reconnect -> {
    attemptStopTransport();
    final Messages.Join join=new Messages.Join(reconnect.out,reconnect.in,reconnect.uuid);
    transport=context().actorOf(Props.create(WebsocketTransport.class,protectedData,join));
    transport.tell(reconnect,self());
    connected=true;
    resendMessages();
  }
).match(Messages.Quit.class,quit -> {
    context().setReceiveTimeout(Duration.create(""String_Node_Str""));
  }
).match(ReceiveTimeout.class,r -> {
    context().stop(self());
  }
).match(Messages.Ack.class,ack -> {
    messages.remove(ack.MessageId);
  }
).match(Terminated.class,t -> t.actor().equals(transport),t -> {
    transport=null;
    connected=false;
  }
).build());
}",0.9525547445255474
22576,"/** 
 * Locate the block of a string doing binary search.
 */
protected int locateBlock(CharSequence str){
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  int max=high;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    int cmp;
    if (max == high) {
      cmp=-1;
    }
 else {
      cmp=ByteStringUtil.strcmp(str,data[mid / BLOCK_PER_BUFFER],(int)(blocks.get(mid) - posFirst[mid / BLOCK_PER_BUFFER]));
    }
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}","/** 
 * Locate the block of a string doing binary search.
 */
protected int locateBlock(CharSequence str){
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  int max=high;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    int cmp;
    if (mid == max) {
      cmp=-1;
    }
 else {
      cmp=ByteStringUtil.strcmp(str,data[mid / BLOCK_PER_BUFFER],(int)(blocks.get(mid) - posFirst[mid / BLOCK_PER_BUFFER]));
    }
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}",0.9872773536895676
22577,"protected int locateInBlock(int blockid,CharSequence str){
  ReplazableString tempString=new ReplazableString();
  Mutable<Long> delta=new Mutable<Long>(0L);
  int idInBlock=0;
  int cshared=0;
  byte[] block=data[blockid / BLOCK_PER_BUFFER];
  int pos=(int)(blocks.get(blockid) - posFirst[blockid / BLOCK_PER_BUFFER]);
  int slen=ByteStringUtil.strlen(block,pos);
  tempString.append(block,pos,slen);
  pos+=slen + 1;
  idInBlock++;
  while ((idInBlock < blocksize) && (pos < block.length)) {
    pos+=VByte.decode(block,pos,delta);
    slen=ByteStringUtil.strlen(block,pos);
    tempString.replace(delta.getValue().intValue(),block,pos,slen);
    if (delta.getValue() >= cshared) {
      cshared+=ByteStringUtil.longestCommonPrefix(tempString,str,cshared);
      if ((cshared == str.length()) && (tempString.length() == str.length())) {
        break;
      }
    }
 else {
      idInBlock=0;
      break;
    }
    pos+=slen + 1;
    idInBlock++;
  }
  if (pos == block.length || idInBlock == blocksize) {
    idInBlock=0;
  }
  return idInBlock;
}","protected int locateInBlock(int blockid,CharSequence str){
  ReplazableString tempString=new ReplazableString();
  Mutable<Long> delta=new Mutable<Long>(0L);
  int idInBlock=0;
  int cshared=0;
  byte[] block=data[blockid / BLOCK_PER_BUFFER];
  int pos=(int)(blocks.get(blockid) - posFirst[blockid / BLOCK_PER_BUFFER]);
  int slen=ByteStringUtil.strlen(block,pos);
  tempString.append(block,pos,slen);
  pos+=slen + 1;
  idInBlock++;
  while ((idInBlock < blocksize) && (pos < block.length)) {
    pos+=VByte.decode(block,pos,delta);
    slen=ByteStringUtil.strlen(block,pos);
    tempString.replace(delta.getValue().intValue(),block,pos,slen);
    if (delta.getValue() >= cshared) {
      cshared+=ByteStringUtil.longestCommonPrefix(tempString,str,cshared);
      if ((cshared == str.length()) && (tempString.length() == str.length())) {
        return idInBlock;
      }
    }
 else {
      idInBlock=0;
      break;
    }
    pos+=slen + 1;
    idInBlock++;
  }
  if (pos == block.length || idInBlock == blocksize) {
    idInBlock=0;
  }
  return idInBlock;
}",0.9910080454330336
22578,"private void mapFiles(File f,long base) throws IOException {
  ch=new FileInputStream(f).getChannel();
  long maxSize=base + SequenceLog64.numBytesFor(numbits,numentries);
  int buffer=0;
  long block=0;
  buffers=new ByteBuffer[(int)(1L + numwords / LONGS_PER_BUFFER)];
  while (block < numwords) {
    long current=base + buffer * 8L * LONGS_PER_BUFFER;
    long next=current + 8L * LONGS_PER_BUFFER;
    long length=Math.min(maxSize,next) - current;
    buffers[buffer]=ch.map(MapMode.READ_ONLY,current,length);
    buffers[buffer].order(ByteOrder.LITTLE_ENDIAN);
    block+=LONGS_PER_BUFFER;
    buffer++;
  }
  CountInputStream in=new CountInputStream(new BufferedInputStream(new FileInputStream(f)));
  IOUtil.skip(in,base + ((numwords - 1) * 8L));
  int lastWordUsedBits=SequenceLog64.lastWordNumBits(numbits,numentries);
  lastword=BitUtil.readLowerBitsByteAligned(lastWordUsedBits,in);
  in.close();
}","private void mapFiles(File f,long base) throws IOException {
  ch=FileChannel.open(Paths.get(f.toString()));
  long maxSize=base + SequenceLog64.numBytesFor(numbits,numentries);
  int buffer=0;
  long block=0;
  buffers=new ByteBuffer[(int)(1L + numwords / LONGS_PER_BUFFER)];
  while (block < numwords) {
    long current=base + buffer * 8L * LONGS_PER_BUFFER;
    long next=current + 8L * LONGS_PER_BUFFER;
    long length=Math.min(maxSize,next) - current;
    buffers[buffer]=ch.map(MapMode.READ_ONLY,current,length);
    buffers[buffer].order(ByteOrder.LITTLE_ENDIAN);
    block+=LONGS_PER_BUFFER;
    buffer++;
  }
  CountInputStream in=new CountInputStream(new BufferedInputStream(new FileInputStream(f)));
  IOUtil.skip(in,base + ((numwords - 1) * 8L));
  int lastWordUsedBits=SequenceLog64.lastWordNumBits(numbits,numentries);
  lastword=BitUtil.readLowerBitsByteAligned(lastWordUsedBits,in);
  in.close();
}",0.9671412924424972
22579,"@Override public void close() throws IOException {
  ch.close();
}","@Override public void close() throws IOException {
  buffers=null;
  System.gc();
  ch.close();
}",0.8098159509202454
22580,"public PFCDictionarySectionMap(CountInputStream input,File f) throws IOException {
  this.f=f;
  startOffset=input.getTotalBytes();
  CRCInputStream crcin=new CRCInputStream(input,new CRC8());
  int type=crcin.read();
  if (type != TYPE_INDEX) {
    throw new IllegalFormatException(""String_Node_Str"");
  }
  numstrings=(int)VByte.decode(crcin);
  dataSize=VByte.decode(crcin);
  blocksize=(int)VByte.decode(crcin);
  if (!crcin.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
  blocks=SequenceFactory.createStream(input,f);
  long base=input.getTotalBytes();
  IOUtil.skip(crcin,dataSize + 4);
  endOffset=input.getTotalBytes();
  ch=new FileInputStream(f).getChannel();
  int block=0;
  int buffer=0;
  long numBlocks=blocks.getNumberOfElements();
  long bytePos=0;
  long numBuffers=1 + numBlocks / BLOCKS_PER_BYTEBUFFER;
  buffers=new ByteBuffer[(int)numBuffers];
  posFirst=new long[(int)numBuffers];
  while (block < numBlocks - 1) {
    int nextBlock=(int)Math.min(numBlocks - 1,block + BLOCKS_PER_BYTEBUFFER);
    long nextBytePos=blocks.get(nextBlock);
    buffers[buffer]=ch.map(MapMode.READ_ONLY,base + bytePos,nextBytePos - bytePos);
    buffers[buffer].order(ByteOrder.LITTLE_ENDIAN);
    posFirst[buffer]=bytePos;
    bytePos=nextBytePos;
    block+=BLOCKS_PER_BYTEBUFFER;
    buffer++;
  }
}","public PFCDictionarySectionMap(CountInputStream input,File f) throws IOException {
  this.f=f;
  startOffset=input.getTotalBytes();
  CRCInputStream crcin=new CRCInputStream(input,new CRC8());
  int type=crcin.read();
  if (type != TYPE_INDEX) {
    throw new IllegalFormatException(""String_Node_Str"");
  }
  numstrings=(int)VByte.decode(crcin);
  dataSize=VByte.decode(crcin);
  blocksize=(int)VByte.decode(crcin);
  if (!crcin.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
  blocks=SequenceFactory.createStream(input,f);
  long base=input.getTotalBytes();
  IOUtil.skip(crcin,dataSize + 4);
  endOffset=input.getTotalBytes();
  ch=FileChannel.open(Paths.get(f.toString()));
  int block=0;
  int buffer=0;
  long numBlocks=blocks.getNumberOfElements();
  long bytePos=0;
  long numBuffers=1 + numBlocks / BLOCKS_PER_BYTEBUFFER;
  buffers=new ByteBuffer[(int)numBuffers];
  posFirst=new long[(int)numBuffers];
  while (block < numBlocks - 1) {
    int nextBlock=(int)Math.min(numBlocks - 1,block + BLOCKS_PER_BYTEBUFFER);
    long nextBytePos=blocks.get(nextBlock);
    buffers[buffer]=ch.map(MapMode.READ_ONLY,base + bytePos,nextBytePos - bytePos);
    buffers[buffer].order(ByteOrder.LITTLE_ENDIAN);
    posFirst[buffer]=bytePos;
    bytePos=nextBytePos;
    block+=BLOCKS_PER_BYTEBUFFER;
    buffer++;
  }
}",0.9804951237809452
22581,"@Override public void close() throws IOException {
  ch.close();
}","@Override public void close() throws IOException {
  blocks.close();
  buffers=null;
  System.gc();
  ch.close();
}",0.7292817679558011
22582,"@Override public void loadOrCreateIndex(ProgressListener listener){
  ControlInfo ci=new ControlInformation();
  String indexName=hdtFileName + HDTVersion.get_index_suffix(""String_Node_Str"");
  indexName=indexName.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String versionName=indexName;
  File ff=new File(indexName);
  if (!ff.isFile() || !ff.canRead()) {
    indexName=hdtFileName + (""String_Node_Str"");
    indexName=indexName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    ff=new File(indexName);
  }
  try {
    CountInputStream in=new CountInputStream(new BufferedInputStream(new FileInputStream(ff)));
    ci.load(in);
    if (isMapped) {
      triples.mapIndex(in,new File(indexName),ci,listener);
    }
 else {
      triples.loadIndex(in,ci,listener);
    }
    in.close();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    triples.generateIndex(listener);
    try {
      FileOutputStream out=new FileOutputStream(versionName);
      ci.clear();
      triples.saveIndex(out,ci,listener);
      out.close();
    }
 catch (    IOException e2) {
    }
  }
}","@Override public void loadOrCreateIndex(ProgressListener listener){
  ControlInfo ci=new ControlInformation();
  String indexName=hdtFileName + HDTVersion.get_index_suffix(""String_Node_Str"");
  indexName=indexName.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String versionName=indexName;
  File ff=new File(indexName);
  if (!ff.isFile() || !ff.canRead()) {
    indexName=hdtFileName + (""String_Node_Str"");
    indexName=indexName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    ff=new File(indexName);
  }
  CountInputStream in=null;
  try {
    in=new CountInputStream(new BufferedInputStream(new FileInputStream(ff)));
    ci.load(in);
    if (isMapped) {
      triples.mapIndex(in,new File(indexName),ci,listener);
    }
 else {
      triples.loadIndex(in,ci,listener);
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    triples.generateIndex(listener);
    FileOutputStream out=null;
    try {
      out=new FileOutputStream(versionName);
      ci.clear();
      triples.saveIndex(out,ci,listener);
      out.close();
    }
 catch (    IOException e2) {
    }
 finally {
      IOUtil.closeQuietly(out);
    }
  }
 finally {
    IOUtil.closeQuietly(in);
  }
}",0.625974025974026
22583,"@Override public void close() throws IOException {
  seqY.close();
  seqY=null;
  seqZ.close();
  seqZ=null;
  if (indexZ != null) {
    indexZ.close();
    indexZ=null;
  }
  if (predicateCount != null) {
    predicateCount.close();
    predicateCount=null;
  }
}","@Override public void close() throws IOException {
  seqY.close();
  seqY=null;
  seqZ.close();
  seqZ=null;
  if (indexZ != null) {
    indexZ.close();
    indexZ=null;
  }
  if (predicateCount != null) {
    predicateCount.close();
    predicateCount=null;
  }
  if (predicateIndex != null) {
    predicateIndex.close();
    predicateIndex=null;
  }
}",0.8557536466774717
22584,"/** 
 * Escapes a Unicode string to an all-ASCII character sequence. Any special characters are escaped using backslashes (<tt>""</tt> becomes <tt>\""</tt>, etc.), and non-ascii/non-printable characters are escaped using Unicode escapes (<tt>&#x5C;uxxxx</tt> and <tt>&#x5C;Uxxxxxxxx</tt>).
 * @throws IOException
 */
public static void escapeString(String label,Appendable appendable) throws IOException {
  int first=0;
  int last=label.length();
  if (last > 1 && label.charAt(0) == '<' && label.charAt(last - 1) == '>') {
    first++;
    last--;
  }
 else   if (label.charAt(0) == '""') {
    first=1;
    appendable.append('""');
    for (int i=last - 1; i > 0; i--) {
      char curr=label.charAt(i);
      if (curr == '""') {
        last=i;
        break;
      }
      char prev=label.charAt(i - 1);
      if (curr == '@' && prev == '""') {
        last=i - 2;
        break;
      }
      if (curr == '^' && prev == '^') {
        last=i - 2;
        break;
      }
    }
  }
  for (int i=first; i < last; i++) {
    char c=label.charAt(i);
    int cInt=c;
    if (c == '\\') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '""') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '\n') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '\r') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '\t') {
      appendable.append(""String_Node_Str"");
    }
 else     if (cInt >= 0x0 && cInt <= 0x8 || cInt == 0xB || cInt == 0xC || cInt >= 0xE && cInt <= 0x1F || cInt >= 0x7F && cInt <= 0xFFFF) {
      appendable.append(""String_Node_Str"");
      appendable.append(toHexString(cInt,4));
    }
 else     if (cInt >= 0x10000 && cInt <= 0x10FFFF) {
      appendable.append(""String_Node_Str"");
      appendable.append(toHexString(cInt,8));
    }
 else {
      appendable.append(c);
    }
  }
  appendable.append(label.subSequence(last,label.length()));
}","/** 
 * Escapes a Unicode string to an all-ASCII character sequence. Any special characters are escaped using backslashes (<tt>""</tt> becomes <tt>\""</tt>, etc.), and non-ascii/non-printable characters are escaped using Unicode escapes (<tt>&#x5C;uxxxx</tt> and <tt>&#x5C;Uxxxxxxxx</tt>).
 * @throws IOException
 */
public static void escapeString(String label,Appendable appendable) throws IOException {
  int first=0;
  int last=label.length();
  if (last > 1 && label.charAt(0) == '<' && label.charAt(last - 1) == '>') {
    first++;
    last--;
  }
 else   if (label.charAt(0) == '""') {
    first=1;
    appendable.append('""');
    for (int i=last - 1; i > 0; i--) {
      char curr=label.charAt(i);
      if (curr == '""') {
        last=i - 1;
        break;
      }
      char prev=label.charAt(i - 1);
      if (curr == '@' && prev == '""') {
        last=i - 2;
        break;
      }
      if (curr == '^' && prev == '^') {
        last=i - 3;
        break;
      }
    }
  }
  for (int i=first; i <= last; i++) {
    char c=label.charAt(i);
    int cInt=c;
    if (c == '\\') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '""') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '\n') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '\r') {
      appendable.append(""String_Node_Str"");
    }
 else     if (c == '\t') {
      appendable.append(""String_Node_Str"");
    }
 else     if (cInt >= 0x0 && cInt <= 0x8 || cInt == 0xB || cInt == 0xC || cInt >= 0xE && cInt <= 0x1F || cInt >= 0x7F && cInt <= 0xFFFF) {
      appendable.append(""String_Node_Str"");
      appendable.append(toHexString(cInt,4));
    }
 else     if (cInt >= 0x10000 && cInt <= 0x10FFFF) {
      appendable.append(""String_Node_Str"");
      appendable.append(toHexString(cInt,8));
    }
 else {
      appendable.append(c);
    }
  }
  appendable.append(label.subSequence(last + 1,label.length()));
}",0.9971583570136916
22585,"private static HDTId getID(Node n,NodeDictionary dict,PrefixMapping prefixMapping){
  int id=dict.getIntID(n,prefixMapping,TripleComponentRole.SUBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.SUBJECT,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.PREDICATE);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.PREDICATE,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.OBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.OBJECT,dict);
  }
  return null;
}","private static HDTId getID(Node n,NodeDictionary dict,PrefixMapping prefixMapping){
  int id=dict.getIntID(n,prefixMapping,TripleComponentRole.SUBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.SUBJECT,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.PREDICATE);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.PREDICATE,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.OBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.OBJECT,dict);
  }
  return new HDTId(id,null,dict);
}",0.982648401826484
22586,"@Override public IteratorTripleID search(TripleID pattern){
  TripleID reorderedPat=new TripleID(pattern);
  TripleOrderConvert.swapComponentOrder(reorderedPat,TripleComponentOrder.SPO,order);
  String patternString=reorderedPat.getPatternString();
  if (patternString.equals(""String_Node_Str"")) {
    if (this.predicateIndex != null) {
      return new BitmapTriplesIteratorYFOQ(this,pattern);
    }
 else {
      return new BitmapTriplesIteratorY(this,pattern);
    }
  }
  if (indexZ != null && bitmapIndexZ != null) {
    if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZFOQ(this,pattern);
    }
  }
 else {
    if (patternString.equals(""String_Node_Str"")) {
      return new SequentialSearchIteratorTripleID(pattern,new BitmapTriplesIteratorZ(this,pattern));
    }
    if (patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZ(this,pattern);
    }
  }
  IteratorTripleID bitIt=new BitmapTriplesIterator(this,pattern);
  if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")|| patternString.equals(""String_Node_Str"")) {
    return bitIt;
  }
 else {
    return new SequentialSearchIteratorTripleID(pattern,bitIt);
  }
}","@Override public IteratorTripleID search(TripleID pattern){
  if (getNumberOfElements() == 0) {
    return new EmptyTriplesIterator(order);
  }
  TripleID reorderedPat=new TripleID(pattern);
  TripleOrderConvert.swapComponentOrder(reorderedPat,TripleComponentOrder.SPO,order);
  String patternString=reorderedPat.getPatternString();
  if (patternString.equals(""String_Node_Str"")) {
    if (this.predicateIndex != null) {
      return new BitmapTriplesIteratorYFOQ(this,pattern);
    }
 else {
      return new BitmapTriplesIteratorY(this,pattern);
    }
  }
  if (indexZ != null && bitmapIndexZ != null) {
    if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZFOQ(this,pattern);
    }
  }
 else {
    if (patternString.equals(""String_Node_Str"")) {
      return new SequentialSearchIteratorTripleID(pattern,new BitmapTriplesIteratorZ(this,pattern));
    }
    if (patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZ(this,pattern);
    }
  }
  IteratorTripleID bitIt=new BitmapTriplesIterator(this,pattern);
  if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")|| patternString.equals(""String_Node_Str"")) {
    return bitIt;
  }
 else {
    return new SequentialSearchIteratorTripleID(pattern,bitIt);
  }
}",0.9688888888888888
22587,"@Test public void testCase(){
  List<Iterator<Integer>> list=new ArrayList<>();
  list.add(listA.iterator());
  list.add(listB.iterator());
  list.add(listC.iterator());
  Iterator<Integer> it=new MultiMerge<Integer>(list.iterator(),new IntegerComparator());
  it=new SortedReduceIterator<>(it,new ReducerLeft<Integer>());
  Iterator<Integer> itE=listOutB.iterator();
  while (it.hasNext()) {
    assertEquals(itE.hasNext(),it.hasNext());
    int val=it.next();
    int valE=itE.next();
    System.out.println(val);
    assertEquals(val,valE);
  }
  assertEquals(itE.hasNext(),it.hasNext());
}","@Test public void testCase(){
  List<Iterator<Integer>> list=new ArrayList<>();
  list.add(listA.iterator());
  list.add(listB.iterator());
  list.add(listC.iterator());
  Iterator<Integer> it=new MultiMerge<Integer>(list.iterator(),new IntegerComparator());
  it=new SortedReduceIterator<>(it,new ReducerLeft<Integer>());
  Iterator<Integer> itE=listOutB.iterator();
  while (it.hasNext()) {
    assertEquals(itE.hasNext(),it.hasNext());
    int val=it.next();
    int valE=itE.next();
    assertEquals(val,valE);
  }
  assertEquals(itE.hasNext(),it.hasNext());
}",0.9749351771823682
22588,"public ReorderTransformationHDT(HDTGraph graph){
  this.stats=graph.getStatisticsHandler();
  numTriples=graph.size();
  initializeMatcher();
  Dictionary dict=graph.getHDT().getDictionary();
  TERM_S=dict.getNsubjects() / numTriples;
  TERM_P=dict.getNpredicates() / numTriples;
  TERM_O=dict.getNobjects() / numTriples;
}","public ReorderTransformationHDT(HDTGraph graph){
  this.stats=graph.getStatisticsHandler();
  numTriples=graph.size();
  initializeMatcher();
  Dictionary dict=graph.getHDT().getDictionary();
  TERM_S=dict.getNsubjects() / Math.max(numTriples,1);
  TERM_P=dict.getNpredicates() / Math.max(numTriples,1);
  TERM_O=dict.getNobjects() / Math.max(numTriples,1);
}",0.8592375366568915
22589,"public static Plan getPlan(HDTQueryEngine engine,Query query,DatasetGraph dataset,Binding input,Context context){
  if (query.getAggregators().size() != 1)   return null;
  Aggregator ag=query.getAggregators().get(0).getAggregator();
  if (ag == null || !query.getHavingExprs().isEmpty() || !query.getGroupBy().isEmpty() || query.hasLimit() || query.hasOffset() || !((ag instanceof AggCount) || (ag instanceof AggCountVar) || (ag instanceof AggCountDistinct)|| (ag instanceof AggCountVarDistinct))) {
    return null;
  }
  ElementGroup el=(ElementGroup)query.getQueryPattern();
  List<Element> list=el.getElements();
  if (list.size() != 1) {
    return null;
  }
  Element ele=list.get(0);
  Node graphName=null;
  if (ele instanceof ElementNamedGraph) {
    graphName=((ElementNamedGraph)ele).getGraphNameNode();
    if (graphName.isVariable()) {
      return null;
    }
    ele=((ElementNamedGraph)ele).getElement();
    if (ele instanceof ElementGroup) {
      ElementGroup elGroup=(ElementGroup)ele;
      if (elGroup.getElements().size() != 1) {
        return null;
      }
      ele=elGroup.getElements().get(0);
    }
  }
  if (!(ele instanceof ElementPathBlock)) {
    return null;
  }
  PathBlock pb=((ElementPathBlock)ele).getPattern();
  if (pb.size() != 1) {
    return null;
  }
  TriplePath tp=pb.get(0);
  Triple triple=tp.asTriple();
  if (triple.getSubject().equals(triple.getPredicate()) || triple.getPredicate().equals(triple.getObject()) || triple.getSubject().equals(triple.getObject())) {
    return null;
  }
  if (query.getProjectVars().size() != 1) {
    return null;
  }
  Var varOutput=query.getProjectVars().get(0);
  Graph g=null;
  if (dataset instanceof DatasetGraphOne) {
    g=dataset.getDefaultGraph();
  }
 else   if (dataset instanceof DatasetGraphMapLink) {
    if (graphName != null) {
      g=dataset.getGraph(graphName);
    }
 else {
      g=dataset.getDefaultGraph();
    }
  }
  if ((g == null) || !(g instanceof HDTGraph)) {
    return null;
  }
  HDTGraph hdtg=(HDTGraph)g;
  long count;
  if (ag instanceof AggCountVarDistinct) {
    ExprList exprList=ag.getExprList();
    if (exprList.size() != 1) {
      return null;
    }
    Expr expr=exprList.get(0);
    if (!(expr instanceof ExprVar)) {
      return null;
    }
    Var countVar=expr.asVar();
    if (!triple.getSubject().isVariable() || !triple.getPredicate().isVariable() || !triple.getObject().isVariable()) {
      return null;
    }
    Dictionary dictionary=hdtg.getHDT().getDictionary();
    if (countVar.equals(triple.getSubject())) {
      count=dictionary.getNsubjects();
    }
 else     if (countVar.equals(triple.getPredicate())) {
      count=dictionary.getNpredicates();
    }
 else     if (countVar.equals(triple.getObject())) {
      count=dictionary.getNobjects();
    }
 else {
      return null;
    }
  }
 else {
    if (ag instanceof AggCountVar) {
      ExprList exprList=ag.getExprList();
      if (exprList.size() != 1) {
        return null;
      }
      Expr expr=exprList.get(0);
      if (!(expr instanceof ExprVar)) {
        return null;
      }
      Var countVar=expr.asVar();
      if (!(triple.getSubject().equals(countVar) || triple.getPredicate().equals(countVar) || triple.getObject().equals(countVar))) {
        return null;
      }
    }
    TripleID patternID=hdtg.getNodeDictionary().getTriplePatID(triple);
    if (patternID.isEmpty()) {
      count=hdtg.getHDT().getTriples().getNumberOfElements();
    }
 else {
      IteratorTripleID it=hdtg.getHDT().getTriples().search(patternID);
      if (it.numResultEstimation() == ResultEstimationType.EXACT) {
        count=it.estimatedNumResults();
      }
 else {
        count=0;
        while (it.hasNext()) {
          it.next();
          count++;
        }
      }
    }
  }
  Binding bindingResult=new BindingOne(varOutput,NodeFactory.createLiteral(Long.toString(count)));
  return new PlanOp(new HDTOptimizeddOp(),engine,new QueryIterYieldN(1,bindingResult));
}","public static Plan getPlan(HDTQueryEngine engine,Query query,DatasetGraph dataset,Binding input,Context context){
  if (query.getAggregators().size() != 1)   return null;
  Aggregator ag=query.getAggregators().get(0).getAggregator();
  if (ag == null || !query.getHavingExprs().isEmpty() || !query.getGroupBy().isEmpty() || query.hasLimit() || query.hasOffset() || !((ag instanceof AggCount) || (ag instanceof AggCountVar) || (ag instanceof AggCountDistinct)|| (ag instanceof AggCountVarDistinct))) {
    return null;
  }
  ElementGroup el=(ElementGroup)query.getQueryPattern();
  List<Element> list=el.getElements();
  if (list.size() != 1) {
    return null;
  }
  Element ele=list.get(0);
  Node graphName=null;
  if (ele instanceof ElementNamedGraph) {
    graphName=((ElementNamedGraph)ele).getGraphNameNode();
    if (graphName.isVariable()) {
      return null;
    }
    ele=((ElementNamedGraph)ele).getElement();
    if (ele instanceof ElementGroup) {
      ElementGroup elGroup=(ElementGroup)ele;
      if (elGroup.getElements().size() != 1) {
        return null;
      }
      ele=elGroup.getElements().get(0);
    }
  }
  if (!(ele instanceof ElementPathBlock)) {
    return null;
  }
  PathBlock pb=((ElementPathBlock)ele).getPattern();
  if (pb.size() != 1) {
    return null;
  }
  TriplePath tp=pb.get(0);
  Triple triple=tp.asTriple();
  if (triple == null) {
    return null;
  }
  if (triple.getSubject().equals(triple.getPredicate()) || triple.getPredicate().equals(triple.getObject()) || triple.getSubject().equals(triple.getObject())) {
    return null;
  }
  if (query.getProjectVars().size() != 1) {
    return null;
  }
  Var varOutput=query.getProjectVars().get(0);
  Graph g=null;
  if (dataset instanceof DatasetGraphOne) {
    g=dataset.getDefaultGraph();
  }
 else   if (dataset instanceof DatasetGraphMapLink) {
    if (graphName != null) {
      g=dataset.getGraph(graphName);
    }
 else {
      g=dataset.getDefaultGraph();
    }
  }
  if ((g == null) || !(g instanceof HDTGraph)) {
    return null;
  }
  HDTGraph hdtg=(HDTGraph)g;
  long count;
  if (ag instanceof AggCountVarDistinct) {
    ExprList exprList=ag.getExprList();
    if (exprList.size() != 1) {
      return null;
    }
    Expr expr=exprList.get(0);
    if (!(expr instanceof ExprVar)) {
      return null;
    }
    Var countVar=expr.asVar();
    if (!triple.getSubject().isVariable() || !triple.getPredicate().isVariable() || !triple.getObject().isVariable()) {
      return null;
    }
    Dictionary dictionary=hdtg.getHDT().getDictionary();
    if (countVar.equals(triple.getSubject())) {
      count=dictionary.getNsubjects();
    }
 else     if (countVar.equals(triple.getPredicate())) {
      count=dictionary.getNpredicates();
    }
 else     if (countVar.equals(triple.getObject())) {
      count=dictionary.getNobjects();
    }
 else {
      return null;
    }
  }
 else {
    if (ag instanceof AggCountVar) {
      ExprList exprList=ag.getExprList();
      if (exprList.size() != 1) {
        return null;
      }
      Expr expr=exprList.get(0);
      if (!(expr instanceof ExprVar)) {
        return null;
      }
      Var countVar=expr.asVar();
      if (!(triple.getSubject().equals(countVar) || triple.getPredicate().equals(countVar) || triple.getObject().equals(countVar))) {
        return null;
      }
    }
    TripleID patternID=hdtg.getNodeDictionary().getTriplePatID(triple);
    if (patternID.isEmpty()) {
      count=hdtg.getHDT().getTriples().getNumberOfElements();
    }
 else {
      IteratorTripleID it=hdtg.getHDT().getTriples().search(patternID);
      if (it.numResultEstimation() == ResultEstimationType.EXACT) {
        count=it.estimatedNumResults();
      }
 else {
        count=0;
        while (it.hasNext()) {
          it.next();
          count++;
        }
      }
    }
  }
  Binding bindingResult=new BindingOne(varOutput,NodeFactory.createLiteral(Long.toString(count),XSDDatatype.XSDinteger));
  return new PlanOp(new HDTOptimizeddOp(),engine,new QueryIterYieldN(1,bindingResult));
}",0.9915021244688828
22590,"public static final Var asVar(Node node){
  if (Var.isVar(node))   return Var.alloc(node);
  return null;
}","public static Var asVar(Node node){
  if (Var.isVar(node))   return Var.alloc(node);
  return null;
}",0.971153846153846
22591,"@Override public Node get1(Var var){
  try {
    HDTId id=idBinding.get(var);
    if (id == null)     return null;
    Node n=id.getNode();
    if (n == null) {
      n=id.getDictionary().getNode(id);
      id.setNode(n);
    }
    return n;
  }
 catch (  Exception ex) {
    Log.fatal(this,String.format(""String_Node_Str"",var),ex);
    return null;
  }
}","@Override public Node get1(Var var){
  try {
    HDTId id=idBinding.get(var);
    if (id == null)     return null;
    return id.getNode();
  }
 catch (  Exception ex) {
    Log.fatal(this,String.format(""String_Node_Str"",var),ex);
    return null;
  }
}",0.7828947368421053
22592,"public HDTId(int id,TripleComponentRole role,NodeDictionary dict){
  super();
  this.id=id;
  this.role=role;
  this.node=null;
  this.dict=dict;
}","/** 
 * ""Does not exist"" id.  Guaranteed to be not equal to any other HDTId. 
 */
public HDTId(Node node){
  this(-1,null,null);
  this.node=node;
}",0.3322033898305084
22593,"public Node getNode(){
  return node;
}","public Node getNode(){
  if (node == null) {
    node=dict.getNode(id,role);
  }
  return node;
}",0.5735294117647058
22594,"public static Function<Binding,BindingHDTId> convFromBinding(final NodeDictionary dictionary,final ExecutionContext ctx){
  return new Function<Binding,BindingHDTId>(){
    PrefixMapping mapping=NodeDictionary.getMapping(ctx);
    @Override public BindingHDTId apply(    Binding binding){
      if (binding instanceof BindingHDTNode)       return ((BindingHDTNode)binding).getBindingId();
      BindingHDTId b=new BindingHDTId(binding);
      Iterator<Var> vars=binding.vars();
      for (; vars.hasNext(); ) {
        Var v=vars.next();
        Node n=binding.get(v);
        if (n == null)         continue;
        HDTId id=getID(n,dictionary,mapping);
        b.put(v,id);
      }
      return b;
    }
  }
;
}","/** 
 * Transform from generic Jena bindings to HDTId bindings. 
 */
public static Function<Binding,BindingHDTId> convFromBinding(NodeDictionary dictionary,ExecutionContext ctx){
  return new Function<Binding,BindingHDTId>(){
    PrefixMapping mapping=NodeDictionary.getMapping(ctx);
    @Override public BindingHDTId apply(    Binding binding){
      if (binding instanceof BindingHDTNode)       return ((BindingHDTNode)binding).getBindingId();
      BindingHDTId b=new BindingHDTId(binding);
      Iterator<Var> vars=binding.vars();
      for (; vars.hasNext(); ) {
        Var v=vars.next();
        Node n=binding.get(v);
        if (n == null)         continue;
        HDTId id=getID(n,dictionary,mapping);
        b.put(v,id);
      }
      return b;
    }
  }
;
}",0.9454545454545454
22595,"private static HDTId getID(Node n,NodeDictionary dict,PrefixMapping prefixMapping){
  int id=dict.getIntID(n,prefixMapping,TripleComponentRole.SUBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.SUBJECT,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.PREDICATE);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.PREDICATE,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.OBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.OBJECT,dict);
  }
  return null;
}","private static HDTId getID(Node n,NodeDictionary dict,PrefixMapping prefixMapping){
  int id=dict.getIntID(n,prefixMapping,TripleComponentRole.SUBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.SUBJECT,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.PREDICATE);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.PREDICATE,dict);
  }
  id=dict.getIntID(n,prefixMapping,TripleComponentRole.OBJECT);
  if (id > 0) {
    return new HDTId(id,TripleComponentRole.OBJECT,dict);
  }
  return new HDTId(n);
}",0.9870848708487084
22596,"private static Function<BindingHDTId,Binding> convToBinding(final NodeDictionary dictionary){
  return new Function<BindingHDTId,Binding>(){
    @Override public Binding apply(    BindingHDTId bindingIds){
      return new BindingHDTNode(bindingIds);
    }
  }
;
}","/** 
 * Transform from HDTId bindings to generic Jena bindings. 
 */
public static Binding convToBinding(BindingHDTId binding){
  return new BindingHDTNode(binding);
}",0.4408352668213457
22597,"protected static QueryIterator execute(HDTGraph graph,BasicPattern pattern,QueryIterator input,Predicate<Tuple<HDTId>> filter,ExecutionContext execCxt){
  numBGPs++;
  Iterator<BindingHDTId> chain=Iter.map(input,HDTSolverLib.convFromBinding(graph.getNodeDictionary(),execCxt));
  List<Abortable> killList=new ArrayList<Abortable>();
  Map<Var,VarAppearance> mapVar=new HashMap<Var,VarAppearance>();
  for (  Triple triplePattern : pattern) {
    addVarAppearance(mapVar,triplePattern.getSubject(),TripleComponentRole.SUBJECT);
    addVarAppearance(mapVar,triplePattern.getObject(),TripleComponentRole.OBJECT);
  }
  for (  Triple triplePattern : pattern) {
    chain=solve(graph,triplePattern,chain,filter,mapVar,execCxt);
    chain=IterAbortable.makeAbortable(chain,killList);
  }
  Iterator<Binding> iterBinding=converter.convert(graph.getNodeDictionary(),chain);
  return new QueryIterHDT(iterBinding,killList,input,execCxt);
}","protected static QueryIterator execute(HDTGraph graph,BasicPattern pattern,QueryIterator input,Predicate<Tuple<HDTId>> filter,ExecutionContext execCxt){
  numBGPs++;
  Iterator<BindingHDTId> chain=Iter.map(input,convFromBinding(graph.getNodeDictionary(),execCxt));
  List<Abortable> killList=new ArrayList<Abortable>();
  Map<Var,VarAppearance> mapVar=new HashMap<Var,VarAppearance>();
  for (  Triple triplePattern : pattern) {
    addVarAppearance(mapVar,triplePattern.getSubject(),TripleComponentRole.SUBJECT);
    addVarAppearance(mapVar,triplePattern.getObject(),TripleComponentRole.OBJECT);
  }
  for (  Triple triplePattern : pattern) {
    chain=solve(graph,triplePattern,chain,filter,mapVar,execCxt);
    chain=IterAbortable.makeAbortable(chain,killList);
  }
  Iterator<Binding> iterBinding=Iter.map(chain,HDTSolverLib::convToBinding);
  return new QueryIterHDT(iterBinding,killList,input,execCxt);
}",0.9510869565217392
22598,"@Override public BindingHDTId apply(TripleID triple){
  BindingHDTId output=new BindingHDTId(input);
  if (var[0] != null && !output.containsKey(var[0])) {
    output.put(var[0],new HDTId(triple.getSubject(),TripleComponentRole.SUBJECT,dictionary));
  }
  if (var[1] != null && !output.containsKey(var[1])) {
    output.put(var[1],new HDTId(triple.getPredicate(),TripleComponentRole.PREDICATE,dictionary));
  }
  if (var[2] != null && !output.containsKey(var[2])) {
    output.put(var[2],new HDTId(triple.getObject(),TripleComponentRole.OBJECT,dictionary));
  }
  return output;
}","@Override public BindingHDTId apply(TripleID triple){
  BindingHDTId output=new BindingHDTId(input);
  if (var[0] != null && !insert(var[0],new HDTId(triple.getSubject(),TripleComponentRole.SUBJECT,dictionary),output)) {
    return null;
  }
  if (var[1] != null && !insert(var[1],new HDTId(triple.getPredicate(),TripleComponentRole.PREDICATE,dictionary),output)) {
    return null;
  }
  if (var[2] != null && !insert(var[2],new HDTId(triple.getObject(),TripleComponentRole.OBJECT,dictionary),output)) {
    return null;
  }
  return output;
}",0.8131672597864769
22599,"@Override protected Iterator<BindingHDTId> makeNextStage(final BindingHDTId input){
  numSearches++;
  if (var[0] != null) {
    HDTId id=input.get(var[0]);
    if (id != null) {
      patternID.setSubject(NodeDictionary.translate(dictionary,id,TripleComponentRole.SUBJECT));
    }
  }
  if (var[1] != null) {
    HDTId id=input.get(var[1]);
    if (id != null) {
      patternID.setPredicate(NodeDictionary.translate(dictionary,id,TripleComponentRole.PREDICATE));
    }
  }
  if (var[2] != null) {
    HDTId id=input.get(var[2]);
    if (id != null) {
      patternID.setObject(NodeDictionary.translate(dictionary,id,TripleComponentRole.OBJECT));
    }
  }
  if (patternID.getSubject() == -1 || patternID.getPredicate() == -1 || patternID.getObject() == -1) {
    return Iter.nullIter();
  }
  IteratorTripleID iterTripleIDSearch=triples.search(patternID);
  Iter<TripleID> it=Iter.iter(iterTripleIDSearch);
  if (varIsSO[0] || varIsSO[2]) {
    it=it.filter(new Predicate<TripleID>(){
      @Override public boolean test(      TripleID t){
        if (varIsSO[0] && t.getSubject() > numSharedSO) {
          return false;
        }
        if (varIsSO[2] && t.getObject() > numSharedSO) {
          return false;
        }
        return true;
      }
    }
);
  }
  Function<TripleID,BindingHDTId> binder=new Function<TripleID,BindingHDTId>(){
    @Override public BindingHDTId apply(    TripleID triple){
      BindingHDTId output=new BindingHDTId(input);
      if (var[0] != null && !output.containsKey(var[0])) {
        output.put(var[0],new HDTId(triple.getSubject(),TripleComponentRole.SUBJECT,dictionary));
      }
      if (var[1] != null && !output.containsKey(var[1])) {
        output.put(var[1],new HDTId(triple.getPredicate(),TripleComponentRole.PREDICATE,dictionary));
      }
      if (var[2] != null && !output.containsKey(var[2])) {
        output.put(var[2],new HDTId(triple.getObject(),TripleComponentRole.OBJECT,dictionary));
      }
      return output;
    }
  }
;
  return it.map(binder);
}","@Override protected Iterator<BindingHDTId> makeNextStage(final BindingHDTId input){
  numSearches++;
  if (var[0] != null) {
    HDTId id=input.get(var[0]);
    if (id != null) {
      patternID.setSubject(NodeDictionary.translate(dictionary,id,TripleComponentRole.SUBJECT));
    }
  }
  if (var[1] != null) {
    HDTId id=input.get(var[1]);
    if (id != null) {
      patternID.setPredicate(NodeDictionary.translate(dictionary,id,TripleComponentRole.PREDICATE));
    }
  }
  if (var[2] != null) {
    HDTId id=input.get(var[2]);
    if (id != null) {
      patternID.setObject(NodeDictionary.translate(dictionary,id,TripleComponentRole.OBJECT));
    }
  }
  if (patternID.getSubject() == -1 || patternID.getPredicate() == -1 || patternID.getObject() == -1) {
    return Iter.nullIter();
  }
  IteratorTripleID iterTripleIDSearch=triples.search(patternID);
  Iter<TripleID> it=Iter.iter(iterTripleIDSearch);
  if (varIsSO[0] || varIsSO[2]) {
    it=it.filter(new Predicate<TripleID>(){
      @Override public boolean test(      TripleID t){
        if (varIsSO[0] && t.getSubject() > numSharedSO) {
          return false;
        }
        if (varIsSO[2] && t.getObject() > numSharedSO) {
          return false;
        }
        return true;
      }
    }
);
  }
  Function<TripleID,BindingHDTId> binder=new Function<TripleID,BindingHDTId>(){
    @Override public BindingHDTId apply(    TripleID triple){
      BindingHDTId output=new BindingHDTId(input);
      if (var[0] != null && !insert(var[0],new HDTId(triple.getSubject(),TripleComponentRole.SUBJECT,dictionary),output)) {
        return null;
      }
      if (var[1] != null && !insert(var[1],new HDTId(triple.getPredicate(),TripleComponentRole.PREDICATE,dictionary),output)) {
        return null;
      }
      if (var[2] != null && !insert(var[2],new HDTId(triple.getObject(),TripleComponentRole.OBJECT,dictionary),output)) {
        return null;
      }
      return output;
    }
  }
;
  return it.map(binder).removeNulls();
}",0.9381546134663342
22600,"/** 
 * Check whether all the components of the triple are empty (zero).
 * @return
 */
public boolean isEmpty(){
  return !(subject != 0 || predicate != 0 || object != 0);
}","/** 
 * Check whether all the components of the triple are empty (zero).
 * @return
 */
public boolean isEmpty(){
  return subject == 0 && predicate == 0 && object == 0;
}",0.9507246376811594
22601,"public boolean equals(TripleID other){
  return !(subject != other.subject || predicate != other.predicate || object != other.object);
}","public boolean equals(TripleID other){
  return subject == other.subject && predicate == other.predicate && object == other.object;
}",0.9368029739776952
22602,"@Override public IteratorTripleString search(CharSequence subject,CharSequence predicate,CharSequence object) throws NotFoundException {
  TripleID triple=new TripleID(dictionary.stringToId(subject,TripleComponentRole.SUBJECT),dictionary.stringToId(predicate,TripleComponentRole.PREDICATE),dictionary.stringToId(object,TripleComponentRole.OBJECT));
  if (triple.getSubject() == -1 || triple.getPredicate() == -1 || triple.getObject() == -1) {
    throw new NotFoundException(""String_Node_Str"");
  }
  return new DictionaryTranslateIterator(triples.search(triple),dictionary,subject,predicate,object);
}","@Override public IteratorTripleString search(CharSequence subject,CharSequence predicate,CharSequence object) throws NotFoundException {
  TripleID triple=new TripleID(dictionary.stringToId(subject,TripleComponentRole.SUBJECT),dictionary.stringToId(predicate,TripleComponentRole.PREDICATE),dictionary.stringToId(object,TripleComponentRole.OBJECT));
  if (triple.isNoMatch()) {
    throw new NotFoundException(""String_Node_Str"");
  }
  return new DictionaryTranslateIterator(triples.search(triple),dictionary,subject,predicate,object);
}",0.922671353251318
22603,"@Override public IteratorTripleID search(TripleID pattern){
  if (getNumberOfElements() == 0) {
    return new EmptyTriplesIterator(order);
  }
  TripleID reorderedPat=new TripleID(pattern);
  TripleOrderConvert.swapComponentOrder(reorderedPat,TripleComponentOrder.SPO,order);
  String patternString=reorderedPat.getPatternString();
  if (patternString.equals(""String_Node_Str"")) {
    if (this.predicateIndex != null) {
      return new BitmapTriplesIteratorYFOQ(this,pattern);
    }
 else {
      return new BitmapTriplesIteratorY(this,pattern);
    }
  }
  if (indexZ != null && bitmapIndexZ != null) {
    if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZFOQ(this,pattern);
    }
  }
 else {
    if (patternString.equals(""String_Node_Str"")) {
      return new SequentialSearchIteratorTripleID(pattern,new BitmapTriplesIteratorZ(this,pattern));
    }
    if (patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZ(this,pattern);
    }
  }
  IteratorTripleID bitIt=new BitmapTriplesIterator(this,pattern);
  if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")|| patternString.equals(""String_Node_Str"")) {
    return bitIt;
  }
 else {
    return new SequentialSearchIteratorTripleID(pattern,bitIt);
  }
}","@Override public IteratorTripleID search(TripleID pattern){
  if (getNumberOfElements() == 0 || pattern.isNoMatch()) {
    return new EmptyTriplesIterator(order);
  }
  TripleID reorderedPat=new TripleID(pattern);
  TripleOrderConvert.swapComponentOrder(reorderedPat,TripleComponentOrder.SPO,order);
  String patternString=reorderedPat.getPatternString();
  if (patternString.equals(""String_Node_Str"")) {
    if (this.predicateIndex != null) {
      return new BitmapTriplesIteratorYFOQ(this,pattern);
    }
 else {
      return new BitmapTriplesIteratorY(this,pattern);
    }
  }
  if (indexZ != null && bitmapIndexZ != null) {
    if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZFOQ(this,pattern);
    }
  }
 else {
    if (patternString.equals(""String_Node_Str"")) {
      return new SequentialSearchIteratorTripleID(pattern,new BitmapTriplesIteratorZ(this,pattern));
    }
    if (patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZ(this,pattern);
    }
  }
  IteratorTripleID bitIt=new BitmapTriplesIterator(this,pattern);
  if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")|| patternString.equals(""String_Node_Str"")) {
    return bitIt;
  }
 else {
    return new SequentialSearchIteratorTripleID(pattern,bitIt);
  }
}",0.9918061987887424
22604,"private static Graph toHDT(Graph graph){
  return toHDT(ModelFactory.createModelForGraph(graph)).getGraph();
}","private static HDTGraph toHDT(Graph graph){
  Model model=ModelFactory.createModelForGraph(graph);
  IteratorTripleString tripleIter=new JenaModelIterator(model);
  HDT hdt;
  try {
    hdt=HDTManager.generateHDT(tripleIter,""String_Node_Str"",new HDTSpecification(),null);
  }
 catch (  IOException|ParserException e) {
    throw new RuntimeException(e);
  }
  return new HDTGraph(hdt,true);
}",0.3784860557768924
22605,"@Override protected void format(StringBuffer sbuff,Var var){
  HDTId id=idBinding.get(var);
  String extra=""String_Node_Str"";
  if (id != null)   extra=""String_Node_Str"" + id;
  Node node=get(var);
  sbuff.append(""String_Node_Str"" + var.getVarName() + extra+ ""String_Node_Str""+ node.toString()+ ""String_Node_Str"");
}","@Override protected void format(StringBuffer sbuff,Var var){
  HDTId id=idBinding.get(var);
  String extra=""String_Node_Str"";
  if (id != null)   extra=""String_Node_Str"" + id;
  Node node=get(var);
  sbuff.append(""String_Node_Str"").append(var.getVarName()).append(extra).append(""String_Node_Str"").append(node).append(""String_Node_Str"");
}",0.8318042813455657
22606,"@Override protected Iterator<BindingHDTId> makeNextStage(final BindingHDTId input){
  numSearches++;
  if (var[0] != null) {
    HDTId id=input.get(var[0]);
    if (id != null) {
      patternID.setSubject(NodeDictionary.translate(dictionary,id,TripleComponentRole.SUBJECT));
    }
  }
  if (var[1] != null) {
    HDTId id=input.get(var[1]);
    if (id != null) {
      patternID.setPredicate(NodeDictionary.translate(dictionary,id,TripleComponentRole.PREDICATE));
    }
  }
  if (var[2] != null) {
    HDTId id=input.get(var[2]);
    if (id != null) {
      patternID.setObject(NodeDictionary.translate(dictionary,id,TripleComponentRole.OBJECT));
    }
  }
  if (patternID.getSubject() == -1 || patternID.getPredicate() == -1 || patternID.getObject() == -1) {
    return Iter.nullIter();
  }
  IteratorTripleID iterTripleIDSearch=triples.search(patternID);
  Iter<TripleID> it=Iter.iter(iterTripleIDSearch);
  if (varIsSO[0] || varIsSO[2]) {
    it=it.filter(new Predicate<TripleID>(){
      @Override public boolean test(      TripleID t){
        if (varIsSO[0] && t.getSubject() > numSharedSO) {
          return false;
        }
        if (varIsSO[2] && t.getObject() > numSharedSO) {
          return false;
        }
        return true;
      }
    }
);
  }
  Function<TripleID,BindingHDTId> binder=new Function<TripleID,BindingHDTId>(){
    @Override public BindingHDTId apply(    TripleID triple){
      BindingHDTId output=new BindingHDTId(input);
      if (var[0] != null && !insert(var[0],new HDTId(triple.getSubject(),TripleComponentRole.SUBJECT,dictionary),output)) {
        return null;
      }
      if (var[1] != null && !insert(var[1],new HDTId(triple.getPredicate(),TripleComponentRole.PREDICATE,dictionary),output)) {
        return null;
      }
      if (var[2] != null && !insert(var[2],new HDTId(triple.getObject(),TripleComponentRole.OBJECT,dictionary),output)) {
        return null;
      }
      return output;
    }
  }
;
  return it.map(binder).removeNulls();
}","@Override protected Iterator<BindingHDTId> makeNextStage(final BindingHDTId input){
  numSearches++;
  if (var[0] != null) {
    HDTId id=input.get(var[0]);
    if (id != null) {
      patternID.setSubject(NodeDictionary.translate(dictionary,id,TripleComponentRole.SUBJECT));
    }
  }
  if (var[1] != null) {
    HDTId id=input.get(var[1]);
    if (id != null) {
      patternID.setPredicate(NodeDictionary.translate(dictionary,id,TripleComponentRole.PREDICATE));
    }
  }
  if (var[2] != null) {
    HDTId id=input.get(var[2]);
    if (id != null) {
      patternID.setObject(NodeDictionary.translate(dictionary,id,TripleComponentRole.OBJECT));
    }
  }
  if (patternID.isNoMatch()) {
    return Iter.nullIter();
  }
  IteratorTripleID iterTripleIDSearch=triples.search(patternID);
  Iter<TripleID> it=Iter.iter(iterTripleIDSearch);
  if (varIsSO[0] || varIsSO[2]) {
    it=it.filter(new Predicate<TripleID>(){
      @Override public boolean test(      TripleID t){
        if (varIsSO[0] && t.getSubject() > numSharedSO) {
          return false;
        }
        if (varIsSO[2] && t.getObject() > numSharedSO) {
          return false;
        }
        return true;
      }
    }
);
  }
  Function<TripleID,BindingHDTId> binder=new Function<TripleID,BindingHDTId>(){
    @Override public BindingHDTId apply(    TripleID triple){
      BindingHDTId output=new BindingHDTId(input);
      if (var[0] != null && !insert(var[0],new HDTId(triple.getSubject(),TripleComponentRole.SUBJECT,dictionary),output)) {
        return null;
      }
      if (var[1] != null && !insert(var[1],new HDTId(triple.getPredicate(),TripleComponentRole.PREDICATE,dictionary),output)) {
        return null;
      }
      if (var[2] != null && !insert(var[2],new HDTId(triple.getObject(),TripleComponentRole.OBJECT,dictionary),output)) {
        return null;
      }
      return output;
    }
  }
;
  return it.map(binder).removeNulls();
}",0.9759959141981612
22607,"/** 
 * Read from a line, where each component is separated by space.
 * @param line
 */
public void read(String line) throws ParserException {
  int split, posa, posb;
  this.clear();
  line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
  posa=0;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (line.charAt(posb - 1) == '>')   posb--;
  this.setSubject(line.substring(posa,posb));
  posa=split + 1;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (posb > posa && line.charAt(posb - 1) == '>')   posb--;
  this.setPredicate(line.substring(posa,posb));
  posa=split + 1;
  posb=line.length();
  if (line.charAt(posb - 1) == '.')   posb--;
  if (line.charAt(posb - 1) == ' ')   posb--;
  if (line.charAt(posa) == '<') {
    posa++;
    if (posb > posa && line.charAt(posb - 1) == '>')     posb--;
  }
  this.setObject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
}","/** 
 * Read from a line, where each component is separated by space.
 * @param line
 */
public void read(String line) throws ParserException {
  int split, posa, posb;
  this.clear();
  line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
  posa=0;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (line.charAt(posb - 1) == '>')   posb--;
  this.setSubject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
  posa=split + 1;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (posb > posa && line.charAt(posb - 1) == '>')   posb--;
  this.setPredicate(UnicodeEscape.unescapeString(line.substring(posa,posb)));
  posa=split + 1;
  posb=line.length();
  if (line.charAt(posb - 1) == '.')   posb--;
  if (line.charAt(posb - 1) == ' ')   posb--;
  if (line.charAt(posa) == '<') {
    posa++;
    if (posb > posa && line.charAt(posb - 1) == '>')     posb--;
  }
  this.setObject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
}",0.9558541266794626
22608,"/** 
 * Read from a line, where each component is separated by space.
 * @param line
 */
private static void parseTriplePattern(TripleString dest,String line) throws ParserException {
  int split, posa, posb;
  dest.clear();
  posa=0;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   throw new ParserException(""String_Node_Str"");
  dest.setSubject(line.substring(posa,posb));
  posa=split + 1;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   throw new ParserException(""String_Node_Str"");
  dest.setPredicate(line.substring(posa,posb));
  posa=split + 1;
  posb=line.length();
  if (line.charAt(posb - 1) == '.')   posb--;
  if (line.charAt(posb - 1) == ' ')   posb--;
  dest.setObject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
}","/** 
 * Read from a line, where each component is separated by space.
 * @param line
 */
private static void parseTriplePattern(TripleString dest,String line) throws ParserException {
  int split, posa, posb;
  dest.clear();
  posa=0;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   throw new ParserException(""String_Node_Str"");
  dest.setSubject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
  posa=split + 1;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   throw new ParserException(""String_Node_Str"");
  dest.setPredicate(UnicodeEscape.unescapeString(line.substring(posa,posb)));
  posa=split + 1;
  posb=line.length();
  if (line.charAt(posb - 1) == '.')   posb--;
  if (line.charAt(posb - 1) == ' ')   posb--;
  dest.setObject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
}",0.9469026548672568
22609,"public static String format(Node node){
  if (node.isURI()) {
    return node.getURI();
  }
 else   if (node.isLiteral()) {
    RDFDatatype t=node.getLiteralDatatype();
    if (t == null || XSDDatatype.XSDstring.getURI().equals(t.getURI())) {
      return '""' + node.getLiteralLexicalForm() + '""';
    }
 else     if (RDFLangString.rdfLangString.equals(t)) {
      return '""' + node.getLiteralLexicalForm() + ""String_Node_Str""+ node.getLiteralLanguage();
    }
 else {
      return '""' + node.getLiteralLexicalForm() + ""String_Node_Str""+ t.getURI()+ '>';
    }
  }
 else   if (node.isBlank()) {
    return ""String_Node_Str"" + node.getBlankNodeLabel();
  }
 else {
    throw new IllegalArgumentException(String.valueOf(node));
  }
}","public static String format(Node node){
  if (node.isURI()) {
    return node.getURI();
  }
 else   if (node.isLiteral()) {
    RDFDatatype t=node.getLiteralDatatype();
    if (t == null || XSDDatatype.XSDstring.getURI().equals(t.getURI())) {
      return '""' + node.getLiteralLexicalForm() + '""';
    }
 else     if (RDFLangString.rdfLangString.equals(t)) {
      return '""' + node.getLiteralLexicalForm() + ""String_Node_Str""+ node.getLiteralLanguage().toLowerCase();
    }
 else {
      return '""' + node.getLiteralLexicalForm() + ""String_Node_Str""+ t.getURI()+ '>';
    }
  }
 else   if (node.isBlank()) {
    return ""String_Node_Str"" + node.getBlankNodeLabel();
  }
 else {
    throw new IllegalArgumentException(String.valueOf(node));
  }
}",0.9905149051490516
22610,"@Override public char charAt(int index){
  return (char)buffer[index];
}","@Override public char charAt(int index){
  return (char)(buffer[index] & 0xff);
}",0.9411764705882352
22611,"private void ensureSize(int size){
  if (size > buffer.length) {
    buffer=Arrays.copyOf(buffer,size);
  }
}","private void ensureSize(int size){
  if (size > buffer.length) {
    buffer=Arrays.copyOf(buffer,Math.max(size,buffer.length * 2));
  }
}",0.8861788617886179
22612,"public static String nodeToStr(Node node){
  if (node == null || node.isVariable()) {
    return ""String_Node_Str"";
  }
 else   if (node.isURI()) {
    return node.getURI();
  }
 else   if (node.isLiteral()) {
    RDFDatatype t=node.getLiteralDatatype();
    if (t == null || XSDDatatype.XSDstring.getURI().equals(t.getURI())) {
      return ""String_Node_Str"" + node.getLiteralLexicalForm() + ""String_Node_Str"";
    }
 else     if (RDFLangString.rdfLangString.equals(t)) {
      return ""String_Node_Str"" + node.getLiteralLexicalForm() + ""String_Node_Str""+ node.getLiteralLanguage();
    }
 else {
      return ""String_Node_Str"" + node.getLiteralLexicalForm() + ""String_Node_Str""+ t.getURI()+ ""String_Node_Str"";
    }
  }
 else {
    return node.toString();
  }
}","public static String nodeToStr(Node node){
  if (node == null || node.isVariable()) {
    return ""String_Node_Str"";
  }
 else {
    return JenaNodeFormatter.format(node);
  }
}",0.3368869936034115
22613,"public void doParse(InputStream input,String baseUri,RDFNotation notation,RDFCallback callback) throws ParserException {
  this.callback=callback;
  try {
switch (notation) {
case NTRIPLES:
      LangNTriples langNtriples=RiotReader.createParserNTriples(input,this);
    langNtriples.parse();
  break;
case RDFXML:
LangRDFXML langRdfxml=RiotReader.createParserRDFXML(input,baseUri,this);
langRdfxml.parse();
break;
case N3:
case TURTLE:
LangTurtle langTurtle=RiotReader.createParserTurtle(input,baseUri,this);
langTurtle.parse();
break;
default :
throw new NotImplementedException(""String_Node_Str"" + notation);
}
}
 catch (Exception e) {
e.printStackTrace();
throw new ParserException();
}
}","public void doParse(InputStream input,String baseUri,RDFNotation notation,RDFCallback callback) throws ParserException {
  this.callback=callback;
  try {
switch (notation) {
case NTRIPLES:
      LangNTriples langNtriples=RiotParsers.createParserNTriples(input,this);
    langNtriples.parse();
  break;
case RDFXML:
LangRDFXML langRdfxml=RiotParsers.createParserRDFXML(input,baseUri,this);
langRdfxml.parse();
break;
case N3:
case TURTLE:
LangTurtle langTurtle=RiotParsers.createParserTurtle(input,baseUri,this);
langTurtle.parse();
break;
default :
throw new NotImplementedException(""String_Node_Str"" + notation);
}
}
 catch (Exception e) {
e.printStackTrace();
throw new ParserException();
}
}",0.9718817591925016
22614,"public static Node createLiteral(CharSequence x){
  String str=x.toString();
  int len=str.length();
  String literal=""String_Node_Str"";
  String datatype=""String_Node_Str"";
  String lang=""String_Node_Str"";
  char next='\0';
  for (int i=len - 1; i > 0; i--) {
    char cur=str.charAt(i);
    if (cur == '""') {
      if (next == '@') {
        literal=str.substring(1,i);
        lang=str.substring(i + 2,len);
        return new Node_Literal(LiteralLabelFactory.create(literal,lang));
      }
 else {
        literal=str.substring(1,i);
        return new Node_Literal(LiteralLabelFactory.create(literal,""String_Node_Str"",false));
      }
    }
 else     if (cur == '^' && next == '^' && str.charAt(i - 1) == '""') {
      literal=str.substring(1,i - 1);
      if (str.charAt(i + 2) == '<' && str.charAt(len - 1) == '>') {
        datatype=str.substring(i + 3,len - 1);
      }
 else {
        datatype=str.substring(i + 2,len);
      }
      return new Node_Literal(LiteralLabelFactory.create(literal,""String_Node_Str"",TypeMapper.getInstance().getTypeByName(datatype)));
    }
    next=cur;
  }
  return new Node_Literal(LiteralLabelFactory.create(str.substring(1,len - 2),""String_Node_Str"",false));
}","public static Node createLiteral(CharSequence x){
  String str=x.toString();
  int len=str.length();
  String literal=""String_Node_Str"";
  String datatype=""String_Node_Str"";
  String lang=""String_Node_Str"";
  char next='\0';
  for (int i=len - 1; i > 0; i--) {
    char cur=str.charAt(i);
    if (cur == '""') {
      if (next == '@') {
        literal=str.substring(1,i);
        lang=str.substring(i + 2,len);
        return new Node_Literal(LiteralLabelFactory.create(literal,lang));
      }
 else {
        literal=str.substring(1,i);
        return new Node_Literal(LiteralLabelFactory.create(literal,""String_Node_Str"",false));
      }
    }
 else     if (cur == '^' && next == '^' && str.charAt(i - 1) == '""') {
      literal=str.substring(1,i - 1);
      if (str.charAt(i + 2) == '<' && str.charAt(len - 1) == '>') {
        datatype=str.substring(i + 3,len - 1);
      }
 else {
        datatype=str.substring(i + 2,len);
      }
      RDFDatatype rdfDataType=TypeMapper.getInstance().getTypeByName(datatype);
      if (rdfDataType == null) {
        rdfDataType=new CustomDatatype(datatype);
        TypeMapper.getInstance().registerDatatype(rdfDataType);
      }
      return new Node_Literal(LiteralLabelFactory.create(literal,""String_Node_Str"",rdfDataType));
    }
    next=cur;
  }
  return new Node_Literal(LiteralLabelFactory.create(str.substring(1,len - 2),""String_Node_Str"",false));
}",0.8900845503458877
22615,"private void createIndexObjectMemoryEfficient(){
  StopWatch global=new StopWatch();
  StopWatch st=new StopWatch();
  long maxCount=0;
  long numDifferentObjects=0;
  long numReservedObjects=8192;
  SequenceLog64 objectCount=new SequenceLog64(BitUtil.log2(seqZ.getNumberOfElements()),numReservedObjects);
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long val=seqZ.get(i);
    if (val == 0) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (numReservedObjects < val) {
      while (numReservedObjects < val) {
        numReservedObjects<<=1;
      }
      objectCount.resize(numReservedObjects);
    }
    if (numDifferentObjects < val) {
      numDifferentObjects=val;
    }
    long count=objectCount.get(val - 1) + 1;
    maxCount=count > maxCount ? count : maxCount;
    objectCount.set(val - 1,count);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow() + ""String_Node_Str""+ maxCount);
  st.reset();
  Bitmap375 bitmapIndex=new Bitmap375(seqZ.getNumberOfElements());
  long tmpCount=0;
  for (long i=0; i < numDifferentObjects; i++) {
    tmpCount+=objectCount.get(i);
    bitmapIndex.set(tmpCount - 1,true);
  }
  bitmapIndex.set(seqZ.getNumberOfElements() - 1,true);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectCount=null;
  st.reset();
  SequenceLog64 objectInsertedCount=new SequenceLog64(BitUtil.log2(maxCount),numDifferentObjects);
  objectInsertedCount.resize(numDifferentObjects);
  SequenceLog64 objectArray=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()),seqZ.getNumberOfElements());
  objectArray.resize(seqZ.getNumberOfElements());
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long objectValue=seqZ.get(i);
    long posY=i > 0 ? bitmapZ.rank1(i - 1) : 0;
    long insertBase=objectValue == 1 ? 0 : bitmapIndex.select1(objectValue - 1) + 1;
    long insertOffset=objectInsertedCount.get(objectValue - 1);
    objectInsertedCount.set(objectValue - 1,insertOffset + 1);
    objectArray.set(insertBase + insertOffset,posY);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectInsertedCount=null;
  st.reset();
  long object=1;
  long first=0;
  long last=bitmapIndex.select1(object) + 1;
  do {
    long listLen=last - first;
    if (listLen == 2) {
      long aPos=objectArray.get(first);
      long a=seqY.get(aPos);
      long bPos=objectArray.get(first + 1);
      long b=seqY.get(bPos);
      if (a > b) {
        objectArray.set(first,bPos);
        objectArray.set(first + 1,aPos);
      }
    }
 else     if (listLen > 2) {
class Pair {
        int valueY;
        int positionY;
      }
      ;
      ArrayList<Pair> list=new ArrayList<Pair>((int)listLen);
      for (long i=first; i < last; i++) {
        Pair p=new Pair();
        p.positionY=(int)objectArray.get(i);
        p.valueY=(int)seqY.get(p.positionY);
        list.add(p);
      }
      Collections.sort(list,new Comparator<Pair>(){
        @Override public int compare(        Pair o1,        Pair o2){
          if (o1.valueY == o2.valueY) {
            return o1.positionY - o2.positionY;
          }
          return o1.valueY - o2.valueY;
        }
      }
);
      for (long i=first; i < last; i++) {
        objectArray.set(i,list.get((int)(i - first)).positionY);
      }
    }
    first=last;
    last=bitmapIndex.select1(object) + 1;
    object++;
  }
 while (object <= numDifferentObjects);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  st.reset();
  SequenceLog64 predCount=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()));
  for (long i=0; i < seqY.getNumberOfElements(); i++) {
    long val=seqY.get(i);
    if (predCount.getNumberOfElements() < val) {
      predCount.resize(val);
    }
    predCount.set(val - 1,predCount.get(val - 1) + 1);
  }
  predCount.trimToSize();
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  this.predicateCount=predCount;
  st.reset();
  this.indexZ=objectArray;
  this.bitmapIndexZ=bitmapIndex;
  this.adjIndex=new AdjacencyList(this.indexZ,this.bitmapIndexZ);
  System.out.println(""String_Node_Str"" + global.stopAndShow());
}","private void createIndexObjectMemoryEfficient(){
  StopWatch global=new StopWatch();
  StopWatch st=new StopWatch();
  long maxCount=0;
  long numDifferentObjects=0;
  long numReservedObjects=8192;
  SequenceLog64 objectCount=new SequenceLog64(BitUtil.log2(seqZ.getNumberOfElements()),numReservedObjects,true);
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long val=seqZ.get(i);
    if (val == 0) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (numReservedObjects < val) {
      while (numReservedObjects < val) {
        numReservedObjects<<=1;
      }
      objectCount.resize(numReservedObjects);
    }
    if (numDifferentObjects < val) {
      numDifferentObjects=val;
    }
    long count=objectCount.get(val - 1) + 1;
    maxCount=count > maxCount ? count : maxCount;
    objectCount.set(val - 1,count);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow() + ""String_Node_Str""+ maxCount);
  st.reset();
  Bitmap375 bitmapIndex=new Bitmap375(seqZ.getNumberOfElements());
  long tmpCount=0;
  for (long i=0; i < numDifferentObjects; i++) {
    tmpCount+=objectCount.get(i);
    bitmapIndex.set(tmpCount - 1,true);
  }
  bitmapIndex.set(seqZ.getNumberOfElements() - 1,true);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectCount=null;
  st.reset();
  SequenceLog64 objectInsertedCount=new SequenceLog64(BitUtil.log2(maxCount),numDifferentObjects);
  objectInsertedCount.resize(numDifferentObjects);
  SequenceLog64 objectArray=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()),seqZ.getNumberOfElements());
  objectArray.resize(seqZ.getNumberOfElements());
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long objectValue=seqZ.get(i);
    long posY=i > 0 ? bitmapZ.rank1(i - 1) : 0;
    long insertBase=objectValue == 1 ? 0 : bitmapIndex.select1(objectValue - 1) + 1;
    long insertOffset=objectInsertedCount.get(objectValue - 1);
    objectInsertedCount.set(objectValue - 1,insertOffset + 1);
    objectArray.set(insertBase + insertOffset,posY);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectInsertedCount=null;
  st.reset();
  long object=1;
  long first=0;
  long last=bitmapIndex.select1(object) + 1;
  do {
    long listLen=last - first;
    if (listLen == 2) {
      long aPos=objectArray.get(first);
      long a=seqY.get(aPos);
      long bPos=objectArray.get(first + 1);
      long b=seqY.get(bPos);
      if (a > b) {
        objectArray.set(first,bPos);
        objectArray.set(first + 1,aPos);
      }
    }
 else     if (listLen > 2) {
class Pair {
        int valueY;
        int positionY;
      }
      ;
      ArrayList<Pair> list=new ArrayList<Pair>((int)listLen);
      for (long i=first; i < last; i++) {
        Pair p=new Pair();
        p.positionY=(int)objectArray.get(i);
        p.valueY=(int)seqY.get(p.positionY);
        list.add(p);
      }
      Collections.sort(list,new Comparator<Pair>(){
        @Override public int compare(        Pair o1,        Pair o2){
          if (o1.valueY == o2.valueY) {
            return o1.positionY - o2.positionY;
          }
          return o1.valueY - o2.valueY;
        }
      }
);
      for (long i=first; i < last; i++) {
        objectArray.set(i,list.get((int)(i - first)).positionY);
      }
    }
    first=last;
    last=bitmapIndex.select1(object) + 1;
    object++;
  }
 while (object <= numDifferentObjects);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  st.reset();
  SequenceLog64 predCount=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()));
  for (long i=0; i < seqY.getNumberOfElements(); i++) {
    long val=seqY.get(i);
    if (predCount.getNumberOfElements() < val) {
      predCount.resize(val);
    }
    predCount.set(val - 1,predCount.get(val - 1) + 1);
  }
  predCount.trimToSize();
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  this.predicateCount=predCount;
  st.reset();
  this.indexZ=objectArray;
  this.bitmapIndexZ=bitmapIndex;
  this.adjIndex=new AdjacencyList(this.indexZ,this.bitmapIndexZ);
  System.out.println(""String_Node_Str"" + global.stopAndShow());
}",0.9993923927573216
22616,"@Override public IteratorTripleID search(TripleID pattern){
  TripleID reorderedPat=new TripleID(pattern);
  TripleOrderConvert.swapComponentOrder(reorderedPat,TripleComponentOrder.SPO,order);
  String patternString=reorderedPat.getPatternString();
  if (patternString.equals(""String_Node_Str"")) {
    return new BitmapTriplesIteratorY(this,pattern);
  }
  if (indexZ != null && bitmapIndexZ != null) {
    if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZFOQ(this,pattern);
    }
  }
 else {
    if (patternString.equals(""String_Node_Str"")) {
      return new SequentialSearchIteratorTripleID(pattern,new BitmapTriplesIteratorZ(this,pattern));
    }
    if (patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZ(this,pattern);
    }
  }
  IteratorTripleID bitIt=new BitmapTriplesIterator(this,pattern);
  if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")|| patternString.equals(""String_Node_Str"")) {
    return bitIt;
  }
 else {
    return new SequentialSearchIteratorTripleID(pattern,bitIt);
  }
}","@Override public IteratorTripleID search(TripleID pattern){
  TripleID reorderedPat=new TripleID(pattern);
  TripleOrderConvert.swapComponentOrder(reorderedPat,TripleComponentOrder.SPO,order);
  String patternString=reorderedPat.getPatternString();
  if (patternString.equals(""String_Node_Str"")) {
    if (this.predicateIndex != null) {
      return new BitmapTriplesIteratorYFOQ(this,pattern);
    }
 else {
      return new BitmapTriplesIteratorY(this,pattern);
    }
  }
  if (indexZ != null && bitmapIndexZ != null) {
    if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZFOQ(this,pattern);
    }
  }
 else {
    if (patternString.equals(""String_Node_Str"")) {
      return new SequentialSearchIteratorTripleID(pattern,new BitmapTriplesIteratorZ(this,pattern));
    }
    if (patternString.equals(""String_Node_Str"")) {
      return new BitmapTriplesIteratorZ(this,pattern);
    }
  }
  IteratorTripleID bitIt=new BitmapTriplesIterator(this,pattern);
  if (patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"") || patternString.equals(""String_Node_Str"")|| patternString.equals(""String_Node_Str"")) {
    return bitIt;
  }
 else {
    return new SequentialSearchIteratorTripleID(pattern,bitIt);
  }
}",0.9523428113736484
22617,"@Override public long estimatedNumResults(){
  return adjZ.getNumberOfElements();
}","@Override public long estimatedNumResults(){
  return triples.predicateCount.get(patY - 1);
}",0.7272727272727273
22618,"public static final int strcmp(CharSequence str,ByteBuffer buffer,int offset){
  byte[] buf=null;
  int len;
  if (str instanceof CompactString) {
    buf=((CompactString)str).getData();
    len=buf.length;
  }
 else   if (str instanceof String) {
    buf=((String)str).getBytes(ByteStringUtil.STRING_ENCODING);
    len=buf.length;
  }
 else   if (str instanceof ReplazableString) {
    buf=((ReplazableString)str).buffer;
    len=((ReplazableString)str).used;
  }
 else {
    throw new NotImplementedException();
  }
  int i=0;
  int n=Math.min(len,buffer.capacity() - offset);
  while (i < n) {
    int v1=buf[i] & 0xFF;
    int v2=buffer.get(offset + i) & 0xFF;
    if (v1 != v2) {
      return v1 - v2;
    }
    if (v1 == 0) {
      return 0;
    }
    i++;
  }
  if (buffer.capacity() - offset - i > 0) {
    byte v=buffer.get(offset + i);
    if (v == 0) {
      return 0;
    }
 else {
      return -1;
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","public static final int strcmp(CharSequence str,ByteBuffer buffer,int offset){
  byte[] buf=null;
  int len;
  if (str instanceof DelayedString) {
    str=((DelayedString)str).getInternal();
  }
  if (str instanceof CompactString) {
    buf=((CompactString)str).getData();
    len=buf.length;
  }
 else   if (str instanceof String) {
    buf=((String)str).getBytes(ByteStringUtil.STRING_ENCODING);
    len=buf.length;
  }
 else   if (str instanceof ReplazableString) {
    buf=((ReplazableString)str).buffer;
    len=((ReplazableString)str).used;
  }
 else {
    throw new NotImplementedException();
  }
  int i=0;
  int n=Math.min(len,buffer.capacity() - offset);
  while (i < n) {
    int v1=buf[i] & 0xFF;
    int v2=buffer.get(offset + i) & 0xFF;
    if (v1 != v2) {
      return v1 - v2;
    }
    if (v1 == 0) {
      return 0;
    }
    i++;
  }
  if (buffer.capacity() - offset - i > 0) {
    byte v=buffer.get(offset + i);
    if (v == 0) {
      return 0;
    }
 else {
      return -1;
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9584942084942084
22619,"public static String nodeToStr(Node node){
  if (node == null || node.isVariable()) {
    return ""String_Node_Str"";
  }
 else   if (node.isURI()) {
    return node.getURI();
  }
 else {
    return node.toString();
  }
}","public static String nodeToStr(Node node){
  if (node == null || node.isVariable()) {
    return ""String_Node_Str"";
  }
 else   if (node.isURI()) {
    return node.getURI();
  }
 else   if (node.isLiteral()) {
    RDFDatatype t=node.getLiteralDatatype();
    if (t != null) {
      return ""String_Node_Str"" + node.getLiteralLexicalForm() + ""String_Node_Str""+ t.getURI()+ ""String_Node_Str"";
    }
    return node.toString();
  }
 else {
    return node.toString();
  }
}",0.5348837209302325
22620,"@Override public CharSequence next(){
  if (!buffer.hasRemaining()) {
    buffer=buffers[++bytebufferIndex].duplicate();
    buffer.rewind();
  }
  try {
    if ((id % blocksize) == 0) {
      tempString.replace(buffer,0);
    }
 else {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
    }
    id++;
    return tempString.toString();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public CharSequence next(){
  if (!buffer.hasRemaining()) {
    buffer=buffers[++bytebufferIndex].duplicate();
    buffer.rewind();
  }
  try {
    if ((id % blocksize) == 0) {
      tempString.replace(buffer,0);
    }
 else {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
    }
    id++;
    return new CompactString(tempString);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9730941704035876
22621,"@Override public Iterator<CharSequence> getSortedEntries(){
  return new Iterator<CharSequence>(){
    int id=0;
    ReplazableString tempString=new ReplazableString();
    int bytebufferIndex=0;
    ByteBuffer buffer=buffers[0].duplicate();
    @Override public boolean hasNext(){
      return id < getNumberOfElements();
    }
    @Override public CharSequence next(){
      if (!buffer.hasRemaining()) {
        buffer=buffers[++bytebufferIndex].duplicate();
        buffer.rewind();
      }
      try {
        if ((id % blocksize) == 0) {
          tempString.replace(buffer,0);
        }
 else {
          long delta=VByte.decode(buffer);
          tempString.replace(buffer,(int)delta);
        }
        id++;
        return tempString.toString();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","@Override public Iterator<CharSequence> getSortedEntries(){
  return new Iterator<CharSequence>(){
    int id=0;
    ReplazableString tempString=new ReplazableString();
    int bytebufferIndex=0;
    ByteBuffer buffer=buffers[0].duplicate();
    @Override public boolean hasNext(){
      return id < getNumberOfElements();
    }
    @Override public CharSequence next(){
      if (!buffer.hasRemaining()) {
        buffer=buffers[++bytebufferIndex].duplicate();
        buffer.rewind();
      }
      try {
        if ((id % blocksize) == 0) {
          tempString.replace(buffer,0);
        }
 else {
          long delta=VByte.decode(buffer);
          tempString.replace(buffer,(int)delta);
        }
        id++;
        return new CompactString(tempString);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.9768421052631578
22622,"@Override public int compare(CharSequence s1,CharSequence s2){
  if (s1 == s2) {
    return 0;
  }
  if (s1 instanceof CompactString && s2 instanceof CompactString) {
    CompactString cs1=(CompactString)s1;
    CompactString cs2=(CompactString)s2;
    return cs1.compareTo(cs2);
  }
  if (s1 instanceof String && s2 instanceof String) {
    String rs1=(String)s1;
    String rs2=(String)s2;
    return rs1.compareTo(rs2);
  }
  if (s1 instanceof ReplazableString && s2 instanceof ReplazableString) {
    ReplazableString cs1=(ReplazableString)s1;
    ReplazableString cs2=(ReplazableString)s2;
    return cs1.compareTo(cs2);
  }
  int len1=s1.length();
  int len2=s2.length();
  int n=Math.min(len1,len2);
  int k=0;
  while (k < n) {
    char c1=s1.charAt(k);
    char c2=s2.charAt(k);
    if (c1 != c2) {
      return c2 - c1;
    }
    k++;
  }
  return len2 - len1;
}","@Override public int compare(CharSequence s1,CharSequence s2){
  if (s1 == s2) {
    return 0;
  }
  if (s1 instanceof CompactString && s2 instanceof CompactString) {
    CompactString cs1=(CompactString)s1;
    CompactString cs2=(CompactString)s2;
    return cs1.compareTo(cs2);
  }
  if (s1 instanceof String && s2 instanceof String) {
    String rs1=(String)s1;
    String rs2=(String)s2;
    return rs1.compareTo(rs2);
  }
  if (s1 instanceof ReplazableString && s2 instanceof ReplazableString) {
    ReplazableString cs1=(ReplazableString)s1;
    ReplazableString cs2=(ReplazableString)s2;
    return cs1.compareTo(cs2);
  }
  return s1.toString().compareTo(s2.toString());
}",0.8221649484536082
22623,"public CharSequence subSequence(int start,int end){
  if (start < 0 || end > (this.length()) || (end - start) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(data,start,newdata,0,end - start);
  return new CompactString(newdata);
}","public CharSequence subSequence(int start,int end){
  System.err.println(""String_Node_Str"");
  if (start < 0 || end > (this.length()) || (end - start) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(data,start,newdata,0,end - start);
  return new CompactString(newdata);
}",0.9480354879594424
22624,"@Override public int compareTo(CompactString other){
  int n=Math.min(this.data.length,other.data.length);
  int k=0;
  while (k < n) {
    byte c1=this.data[k];
    byte c2=other.data[k];
    if (c1 != c2) {
      return c1 - c2;
    }
    k++;
  }
  return this.data.length - other.data.length;
}","@Override public int compareTo(CompactString other){
  int n=Math.min(this.data.length,other.data.length);
  int k=0;
  while (k < n) {
    int c1=this.data[k] & 0xFF;
    int c2=other.data[k] & 0xFF;
    if (c1 != c2) {
      return c1 - c2;
    }
    k++;
  }
  return this.data.length - other.data.length;
}",0.9342105263157896
22625,"public char charAt(int index){
  int ix=index;
  if (ix >= data.length) {
    throw new StringIndexOutOfBoundsException(""String_Node_Str"" + index + ""String_Node_Str""+ length());
  }
  return (char)(data[ix] & 0xff);
}","public char charAt(int index){
  System.err.println(""String_Node_Str"");
  int ix=index;
  if (ix >= data.length) {
    throw new StringIndexOutOfBoundsException(""String_Node_Str"" + index + ""String_Node_Str""+ length());
  }
  return (char)(data[ix] & 0xff);
}",0.9136842105263158
22626,"@Override public CharSequence subSequence(int start,int end){
  if (start < 0 || end > (this.length()) || (end - start) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(buffer,start,newdata,0,end - start);
  return new ReplazableString(newdata);
}","@Override public CharSequence subSequence(int start,int end){
  System.err.println(""String_Node_Str"");
  if (start < 0 || end > (this.length()) || (end - start) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(buffer,start,newdata,0,end - start);
  return new ReplazableString(newdata);
}",0.94993894993895
22627,"@Override public int compareTo(ReplazableString other){
  int n=Math.min(used,other.used);
  int k=0;
  while (k < n) {
    byte c1=this.buffer[k];
    byte c2=other.buffer[k];
    if (c1 != c2) {
      return c1 - c2;
    }
    k++;
  }
  return used - other.used;
}","@Override public int compareTo(ReplazableString other){
  int n=Math.min(used,other.used);
  int k=0;
  while (k < n) {
    int c1=this.buffer[k] & 0xFF;
    int c2=other.buffer[k] & 0xFF;
    if (c1 != c2) {
      return c1 - c2;
    }
    k++;
  }
  return used - other.used;
}",0.9267399267399268
22628,"@Override public char charAt(int index){
  return (char)buffer[index];
}","@Override public char charAt(int index){
  System.err.println(""String_Node_Str"");
  return (char)buffer[index];
}",0.7783783783783784
22629,"public void replace2(InputStream in,int pos) throws IOException {
  used=pos;
  while (true) {
    int value=in.read();
    if (value == -1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (value == 0) {
      break;
    }
    if (pos >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[pos++]=(byte)(value & 0xFF);
    used++;
  }
}","public void replace2(InputStream in,int pos) throws IOException {
  used=pos;
  while (true) {
    int value=in.read();
    if (value == -1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (value == 0) {
      break;
    }
    if (used >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[used++]=(byte)(value & 0xFF);
  }
}",0.959493670886076
22630,"public void replace(ByteBuffer in,int pos) throws IOException {
  used=pos;
  int n=in.capacity() - in.position();
  while (n-- != 0) {
    byte value=in.get();
    if (value == 0) {
      return;
    }
    if (pos >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[used++]=value;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","public void replace(ByteBuffer in,int pos) throws IOException {
  used=pos;
  int n=in.capacity() - in.position();
  while (n-- != 0) {
    byte value=in.get();
    if (value == 0) {
      return;
    }
    if (used >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[used++]=value;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}",0.9908735332464146
22631,"public void replace2(InputStream in,int pos) throws IOException {
  used=pos;
  while (true) {
    int value=in.read();
    if (value == -1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (value == 0) {
      break;
    }
    if (pos >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[pos++]=(byte)(value & 0xFF);
    used++;
  }
}","public void replace2(InputStream in,int pos) throws IOException {
  used=pos;
  while (true) {
    int value=in.read();
    if (value == -1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (value == 0) {
      break;
    }
    if (used >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[used++]=(byte)(value & 0xFF);
  }
}",0.959493670886076
22632,"public void replace(ByteBuffer in,int pos) throws IOException {
  used=pos;
  int n=in.capacity() - in.position();
  while (n-- != 0) {
    byte value=in.get();
    if (value == 0) {
      return;
    }
    if (pos >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[used++]=value;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","public void replace(ByteBuffer in,int pos) throws IOException {
  used=pos;
  int n=in.capacity() - in.position();
  while (n-- != 0) {
    byte value=in.get();
    if (value == 0) {
      return;
    }
    if (used >= buffer.length) {
      buffer=Arrays.copyOf(buffer,buffer.length * 2);
    }
    buffer[used++]=value;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}",0.9908735332464146
22633,"@Override public CharSequence next(){
  if (!buffer.hasRemaining()) {
    buffer=buffers[bytebufferIndex].duplicate();
    buffer.rewind();
  }
  try {
    if ((id % blocksize) == 0) {
      tempString.replace(buffer,0);
    }
 else {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
    }
    id++;
    return tempString.toString();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public CharSequence next(){
  if (!buffer.hasRemaining()) {
    buffer=buffers[++bytebufferIndex].duplicate();
    buffer.rewind();
  }
  try {
    if ((id % blocksize) == 0) {
      tempString.replace(buffer,0);
    }
 else {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
    }
    id++;
    return tempString.toString();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9977324263038548
22634,"@Override public Iterator<CharSequence> getSortedEntries(){
  return new Iterator<CharSequence>(){
    int id=0;
    ReplazableString tempString=new ReplazableString();
    int bytebufferIndex=0;
    ByteBuffer buffer=buffers[0].duplicate();
    @Override public boolean hasNext(){
      return id < getNumberOfElements();
    }
    @Override public CharSequence next(){
      if (!buffer.hasRemaining()) {
        buffer=buffers[bytebufferIndex].duplicate();
        buffer.rewind();
      }
      try {
        if ((id % blocksize) == 0) {
          tempString.replace(buffer,0);
        }
 else {
          long delta=VByte.decode(buffer);
          tempString.replace(buffer,(int)delta);
        }
        id++;
        return tempString.toString();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","@Override public Iterator<CharSequence> getSortedEntries(){
  return new Iterator<CharSequence>(){
    int id=0;
    ReplazableString tempString=new ReplazableString();
    int bytebufferIndex=0;
    ByteBuffer buffer=buffers[0].duplicate();
    @Override public boolean hasNext(){
      return id < getNumberOfElements();
    }
    @Override public CharSequence next(){
      if (!buffer.hasRemaining()) {
        buffer=buffers[++bytebufferIndex].duplicate();
        buffer.rewind();
      }
      try {
        if ((id % blocksize) == 0) {
          tempString.replace(buffer,0);
        }
 else {
          long delta=VByte.decode(buffer);
          tempString.replace(buffer,(int)delta);
        }
        id++;
        return tempString.toString();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.9989417989417988
22635,"private void createIndexObjectMemoryEfficient(){
  StopWatch global=new StopWatch();
  StopWatch st=new StopWatch();
  SequenceLog64 objectCount=new SequenceLog64(BitUtil.log2(seqZ.getNumberOfElements()));
  long maxCount=0;
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long val=seqZ.get(i);
    if (val == 0) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (objectCount.getNumberOfElements() < val) {
      objectCount.resize(val);
    }
    long count=objectCount.get(val - 1) + 1;
    maxCount=count > maxCount ? count : maxCount;
    objectCount.set(val - 1,count);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow() + ""String_Node_Str""+ maxCount);
  st.reset();
  Bitmap375 bitmapIndex=new Bitmap375(seqZ.getNumberOfElements());
  long tmpCount=0;
  for (long i=0; i < objectCount.getNumberOfElements(); i++) {
    tmpCount+=objectCount.get(i);
    bitmapIndex.set(tmpCount - 1,true);
  }
  bitmapIndex.set(seqZ.getNumberOfElements() - 1,true);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectCount=null;
  st.reset();
  SequenceLog64 objectInsertedCount=new SequenceLog64(BitUtil.log2(maxCount),bitmapIndex.countOnes());
  objectInsertedCount.resize(bitmapIndex.countOnes());
  SequenceLog64 objectArray=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()),seqZ.getNumberOfElements());
  objectArray.resize(seqZ.getNumberOfElements());
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long objectValue=seqZ.get(i);
    long posY=i > 0 ? bitmapZ.rank1(i - 1) : 0;
    long insertBase=objectValue == 1 ? 0 : bitmapIndex.select1(objectValue - 1) + 1;
    long insertOffset=objectInsertedCount.get(objectValue - 1);
    objectInsertedCount.set(objectValue - 1,insertOffset + 1);
    objectArray.set(insertBase + insertOffset,posY);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectInsertedCount=null;
  st.reset();
  long object=1;
  long first=0;
  long last=bitmapIndex.select1(object) + 1;
  do {
    long listLen=last - first;
    if (listLen == 2) {
      long aPos=objectArray.get(first);
      long a=seqY.get(aPos);
      long bPos=objectArray.get(first + 1);
      long b=seqY.get(bPos);
      if (a > b) {
        objectArray.set(first,bPos);
        objectArray.set(first + 1,aPos);
      }
    }
 else     if (listLen > 2) {
class Pair {
        int valueY;
        int positionY;
      }
      ;
      ArrayList<Pair> list=new ArrayList<Pair>((int)listLen);
      for (long i=first; i < last; i++) {
        Pair p=new Pair();
        p.positionY=(int)objectArray.get(i);
        p.valueY=(int)seqY.get(p.positionY);
        list.add(p);
      }
      Collections.sort(list,new Comparator<Pair>(){
        @Override public int compare(        Pair o1,        Pair o2){
          if (o1.valueY == o2.valueY) {
            return o1.positionY - o2.positionY;
          }
          return o1.valueY - o2.valueY;
        }
      }
);
      for (long i=first; i < last; i++) {
        objectArray.set(i,list.get((int)(i - first)).positionY);
      }
    }
    first=last;
    last=bitmapIndex.select1(object) + 1;
    object++;
  }
 while (object <= bitmapIndex.countOnes());
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  st.reset();
  SequenceLog64 predCount=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()));
  for (long i=0; i < seqY.getNumberOfElements(); i++) {
    long val=seqY.get(i);
    if (predCount.getNumberOfElements() < val) {
      predCount.resize(val);
    }
    predCount.set(val - 1,predCount.get(val - 1) + 1);
  }
  predCount.trimToSize();
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  this.predicateCount=predCount;
  st.reset();
  this.indexZ=objectArray;
  this.bitmapIndexZ=bitmapIndex;
  this.adjIndex=new AdjacencyList(this.indexZ,this.bitmapIndexZ);
  System.out.println(""String_Node_Str"" + global.stopAndShow());
}","private void createIndexObjectMemoryEfficient(){
  StopWatch global=new StopWatch();
  StopWatch st=new StopWatch();
  long maxCount=0;
  long numDifferentObjects=0;
  long numReservedObjects=8192;
  SequenceLog64 objectCount=new SequenceLog64(BitUtil.log2(seqZ.getNumberOfElements()),numReservedObjects);
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long val=seqZ.get(i);
    if (val == 0) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (numReservedObjects < val) {
      while (numReservedObjects < val) {
        numReservedObjects<<=1;
      }
      objectCount.resize(numReservedObjects);
    }
    if (numDifferentObjects < val) {
      numDifferentObjects=val;
    }
    long count=objectCount.get(val - 1) + 1;
    maxCount=count > maxCount ? count : maxCount;
    objectCount.set(val - 1,count);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow() + ""String_Node_Str""+ maxCount);
  st.reset();
  Bitmap375 bitmapIndex=new Bitmap375(seqZ.getNumberOfElements());
  long tmpCount=0;
  for (long i=0; i < numDifferentObjects; i++) {
    tmpCount+=objectCount.get(i);
    bitmapIndex.set(tmpCount - 1,true);
  }
  bitmapIndex.set(seqZ.getNumberOfElements() - 1,true);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectCount=null;
  st.reset();
  SequenceLog64 objectInsertedCount=new SequenceLog64(BitUtil.log2(maxCount),numDifferentObjects);
  objectInsertedCount.resize(numDifferentObjects);
  SequenceLog64 objectArray=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()),seqZ.getNumberOfElements());
  objectArray.resize(seqZ.getNumberOfElements());
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long objectValue=seqZ.get(i);
    long posY=i > 0 ? bitmapZ.rank1(i - 1) : 0;
    long insertBase=objectValue == 1 ? 0 : bitmapIndex.select1(objectValue - 1) + 1;
    long insertOffset=objectInsertedCount.get(objectValue - 1);
    objectInsertedCount.set(objectValue - 1,insertOffset + 1);
    objectArray.set(insertBase + insertOffset,posY);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectInsertedCount=null;
  st.reset();
  long object=1;
  long first=0;
  long last=bitmapIndex.select1(object) + 1;
  do {
    long listLen=last - first;
    if (listLen == 2) {
      long aPos=objectArray.get(first);
      long a=seqY.get(aPos);
      long bPos=objectArray.get(first + 1);
      long b=seqY.get(bPos);
      if (a > b) {
        objectArray.set(first,bPos);
        objectArray.set(first + 1,aPos);
      }
    }
 else     if (listLen > 2) {
class Pair {
        int valueY;
        int positionY;
      }
      ;
      ArrayList<Pair> list=new ArrayList<Pair>((int)listLen);
      for (long i=first; i < last; i++) {
        Pair p=new Pair();
        p.positionY=(int)objectArray.get(i);
        p.valueY=(int)seqY.get(p.positionY);
        list.add(p);
      }
      Collections.sort(list,new Comparator<Pair>(){
        @Override public int compare(        Pair o1,        Pair o2){
          if (o1.valueY == o2.valueY) {
            return o1.positionY - o2.positionY;
          }
          return o1.valueY - o2.valueY;
        }
      }
);
      for (long i=first; i < last; i++) {
        objectArray.set(i,list.get((int)(i - first)).positionY);
      }
    }
    first=last;
    last=bitmapIndex.select1(object) + 1;
    object++;
  }
 while (object <= numDifferentObjects);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  st.reset();
  SequenceLog64 predCount=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()));
  for (long i=0; i < seqY.getNumberOfElements(); i++) {
    long val=seqY.get(i);
    if (predCount.getNumberOfElements() < val) {
      predCount.resize(val);
    }
    predCount.set(val - 1,predCount.get(val - 1) + 1);
  }
  predCount.trimToSize();
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  this.predicateCount=predCount;
  st.reset();
  this.indexZ=objectArray;
  this.bitmapIndexZ=bitmapIndex;
  this.adjIndex=new AdjacencyList(this.indexZ,this.bitmapIndexZ);
  System.out.println(""String_Node_Str"" + global.stopAndShow());
}",0.927626653356626
22636,"@Override public char charAt(int index){
  return (char)buffer[index];
}","@Override public char charAt(int index){
  return (char)(buffer[index] & 0xff);
}",0.9411764705882352
22637,"@Override public TripleID next(){
  if (!goingUp) {
    goingUp=true;
    if (hasPreviousTriples) {
      doFetchNext();
    }
    doFetchNext();
  }
  returnTriple=nextTriple;
  doFetchNext();
  return returnTriple;
}","@Override public TripleID next(){
  if (!goingUp) {
    goingUp=true;
    if (hasPreviousTriples) {
      doFetchNext();
    }
    doFetchNext();
  }
  returnTriple.assign(nextTriple);
  doFetchNext();
  return returnTriple;
}",0.9324324324324323
22638,"@Override public TripleID previous(){
  if (goingUp) {
    goingUp=false;
    if (hasMoreTriples) {
      doFetchPrevious();
    }
    doFetchPrevious();
  }
  returnTriple=previousTriple;
  doFetchPrevious();
  return returnTriple;
}","@Override public TripleID previous(){
  if (goingUp) {
    goingUp=false;
    if (hasMoreTriples) {
      doFetchPrevious();
    }
    doFetchPrevious();
  }
  returnTriple.assign(previousTriple);
  doFetchPrevious();
  return returnTriple;
}",0.9201680672268908
22639,"private void doFetchPrevious(){
  hasPreviousTriples=false;
  while (iterator.hasPrevious()) {
    TripleID previous=iterator.previous();
    if (previous.match(pattern)) {
      hasPreviousTriples=true;
      hasMoreTriples=true;
      previousTriple=previous;
      break;
    }
  }
}","private void doFetchPrevious(){
  hasPreviousTriples=false;
  while (iterator.hasPrevious()) {
    TripleID previous=iterator.previous();
    if (previous.match(pattern)) {
      hasPreviousTriples=true;
      hasMoreTriples=true;
      previousTriple.assign(previous);
      break;
    }
  }
}",0.9551724137931036
22640,"public SequentialSearchIteratorTripleID(TripleID pattern,IteratorTripleID other){
  this.pattern=pattern;
  this.iterator=other;
  hasPreviousTriples=false;
  goingUp=true;
  nextTriple=new TripleID();
  doFetchNext();
}","public SequentialSearchIteratorTripleID(TripleID pattern,IteratorTripleID other){
  this.pattern=pattern;
  this.iterator=other;
  hasPreviousTriples=false;
  goingUp=true;
  nextTriple=new TripleID();
  returnTriple=new TripleID();
  doFetchNext();
}",0.9341825902335456
22641,"@Override public void load(InputStream input,ProgressListener listener) throws IOException {
  CRCInputStream in=new CRCInputStream(input,new CRC8());
  int type=in.read();
  if (type != TYPE_INDEX) {
    throw new IllegalFormatException(""String_Node_Str"");
  }
  numstrings=(int)VByte.decode(in);
  this.size=VByte.decode(in);
  blocksize=(int)VByte.decode(in);
  if (!in.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
  blocks=new SequenceLog64();
  blocks.load(input,listener);
  in.setCRC(new CRC32());
  int block=0;
  int buffer=0;
  long bytePos=0;
  long numBlocks=blocks.getNumberOfElements();
  long numBuffers=1 + numBlocks / BLOCK_PER_BUFFER;
  data=new byte[(int)numBuffers][];
  posFirst=new long[(int)numBuffers];
  while (block < numBlocks - 1) {
    int nextBlock=(int)Math.min(numBlocks - 1,block + BLOCK_PER_BUFFER);
    long nextBytePos=blocks.get(nextBlock);
    data[buffer]=new byte[(int)(nextBytePos - bytePos)];
    int read=in.read(data[buffer]);
    if (read != data[buffer].length) {
      throw new IOException(""String_Node_Str"");
    }
    posFirst[buffer]=bytePos;
    bytePos=nextBytePos;
    block+=BLOCK_PER_BUFFER;
    buffer++;
  }
  if (!in.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
}","@Override public void load(InputStream input,ProgressListener listener) throws IOException {
  CRCInputStream in=new CRCInputStream(input,new CRC8());
  int type=in.read();
  if (type != TYPE_INDEX) {
    throw new IllegalFormatException(""String_Node_Str"");
  }
  numstrings=(int)VByte.decode(in);
  this.size=VByte.decode(in);
  blocksize=(int)VByte.decode(in);
  if (!in.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
  blocks=new SequenceLog64();
  blocks.load(input,listener);
  in.setCRC(new CRC32());
  int block=0;
  int buffer=0;
  long bytePos=0;
  long numBlocks=blocks.getNumberOfElements();
  long numBuffers=1 + numBlocks / BLOCK_PER_BUFFER;
  data=new byte[(int)numBuffers][];
  posFirst=new long[(int)numBuffers];
  while (block < numBlocks - 1) {
    int nextBlock=(int)Math.min(numBlocks - 1,block + BLOCK_PER_BUFFER);
    long nextBytePos=blocks.get(nextBlock);
    data[buffer]=IOUtil.readBuffer(in,(int)(nextBytePos - bytePos),null);
    posFirst[buffer]=bytePos;
    bytePos=nextBytePos;
    block+=BLOCK_PER_BUFFER;
    buffer++;
  }
  if (!in.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
}",0.910655737704918
22642,"@Override public int read(byte[] b,int off,int len) throws IOException {
  int ret=in.read(b,off,len);
  crc.update(b,off,len);
  return ret;
}","@Override public int read(byte[] b,int off,int len) throws IOException {
  int ret=in.read(b,off,len);
  crc.update(b,off,ret);
  return ret;
}",0.986013986013986
22643,"/** 
 * Convert int to byte array, little endian
 */
public static byte[] intToByteArray(int value){
  byte writeBuffer[]=new byte[4];
  writeBuffer[0]=(byte)(value & 0xFF);
  writeBuffer[1]=(byte)((value >> 8) & 0xFF);
  writeBuffer[2]=(byte)((value >> 16) & 0xFF);
  writeBuffer[3]=(byte)((value >> 24) & 0xFF);
  return Arrays.copyOfRange(writeBuffer,0,4);
}","/** 
 * Convert int to byte array, little endian
 */
public static byte[] intToByteArray(int value){
  byte writeBuffer[]=new byte[4];
  writeBuffer[0]=(byte)(value & 0xFF);
  writeBuffer[1]=(byte)((value >> 8) & 0xFF);
  writeBuffer[2]=(byte)((value >> 16) & 0xFF);
  writeBuffer[3]=(byte)((value >> 24) & 0xFF);
  return writeBuffer;
}",0.9340974212034384
22644,"/** 
 * Read long, little endian. Warning: Dont use concurrently!!
 * @param input
 * @return
 * @throws IOException
 */
public static final long readLong(InputStream input) throws IOException {
  int n=0;
  while (n < 8) {
    int count=input.read(readBuffer,0,8);
    if (count < 0)     throw new EOFException();
    n+=count;
  }
  return (((long)readBuffer[7] << 56) + ((long)(readBuffer[6] & 255) << 48) + ((long)(readBuffer[5] & 255) << 40)+ ((long)(readBuffer[4] & 255) << 32)+ ((long)(readBuffer[3] & 255) << 24)+ ((readBuffer[2] & 255) << 16)+ ((readBuffer[1] & 255) << 8)+ ((readBuffer[0] & 255)));
}","/** 
 * Read long, little endian.
 * @param input
 * @return
 * @throws IOException
 */
public static final long readLong(InputStream input) throws IOException {
  int n=0;
  byte readBuffer[]=new byte[8];
  while (n < 8) {
    int count=input.read(readBuffer,n,8 - n);
    if (count < 0)     throw new EOFException();
    n+=count;
  }
  return (((long)readBuffer[7] << 56) + ((long)(readBuffer[6] & 255) << 48) + ((long)(readBuffer[5] & 255) << 40)+ ((long)(readBuffer[4] & 255) << 32)+ ((long)(readBuffer[3] & 255) << 24)+ ((readBuffer[2] & 255) << 16)+ ((readBuffer[1] & 255) << 8)+ ((readBuffer[0] & 255)));
}",0.9411764705882352
22645,"private int locateBlock(CharSequence str){
  if (blocks.getNumberOfElements() == 0) {
    return -1;
  }
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    int cmp=ByteStringUtil.strcmp(str,text,(int)blocks.get(mid));
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}","private int locateBlock(CharSequence str){
  if (blocks.getNumberOfElements() == 0) {
    return -1;
  }
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  int max=high;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    int cmp;
    if (mid == max) {
      cmp=-1;
    }
 else {
      int pos=(int)blocks.get(mid);
      cmp=ByteStringUtil.strcmp(str,text,pos);
    }
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}",0.6214574898785425
22646,"/** 
 * Locate the block of a string doing binary search.
 */
private int locateBlock(CharSequence str){
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    int cmp=ByteStringUtil.strcmp(str,data[mid / BLOCK_PER_BUFFER],(int)(blocks.get(mid) - posFirst[mid / BLOCK_PER_BUFFER]));
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}","/** 
 * Locate the block of a string doing binary search.
 */
private int locateBlock(CharSequence str){
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  int max=high;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    int cmp;
    if (max == high) {
      cmp=-1;
    }
 else {
      cmp=ByteStringUtil.strcmp(str,data[mid / BLOCK_PER_BUFFER],(int)(blocks.get(mid) - posFirst[mid / BLOCK_PER_BUFFER]));
    }
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}",0.9230769230769232
22647,"private int locateBlock(CharSequence str){
  if (blocks.getNumberOfElements() == 0) {
    return -1;
  }
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  while (low <= high) {
    int mid=low + (high - low) / 2;
    ByteBuffer buffer=buffers[mid / BLOCKS_PER_BYTEBUFFER];
    int cmp=ByteStringUtil.strcmp(str,buffer,(int)(blocks.get(mid) - posFirst[mid / BLOCKS_PER_BYTEBUFFER]));
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}","private int locateBlock(CharSequence str){
  if (blocks.getNumberOfElements() == 0) {
    return -1;
  }
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  int max=high;
  while (low <= high) {
    int mid=low + (high - low) / 2;
    int cmp;
    if (mid == max) {
      cmp=-1;
    }
 else {
      ByteBuffer buffer=buffers[mid / BLOCKS_PER_BYTEBUFFER];
      cmp=ByteStringUtil.strcmp(str,buffer,(int)(blocks.get(mid) - posFirst[mid / BLOCKS_PER_BYTEBUFFER]));
    }
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}",0.9233361415332773
22648,"public int locateInBlock(int block,CharSequence str){
  if (block >= blocks.getNumberOfElements()) {
    return 0;
  }
  ReplazableString tempString=new ReplazableString();
  int idInBlock=0;
  int cshared=0;
  ByteBuffer buffer=buffers[block / BLOCKS_PER_BYTEBUFFER].duplicate();
  buffer.position((int)(blocks.get(block) - posFirst[block / BLOCKS_PER_BYTEBUFFER]));
  try {
    if (!buffer.hasRemaining()) {
      return 0;
    }
    tempString.replace(buffer,0);
    idInBlock++;
    while ((idInBlock < blocksize) && buffer.hasRemaining()) {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
      if (delta >= cshared) {
        cshared+=ByteStringUtil.longestCommonPrefix(tempString,str,cshared);
        if ((cshared == str.length()) && (tempString.length() == str.length())) {
          break;
        }
      }
 else {
        idInBlock=0;
        break;
      }
      idInBlock++;
    }
    if (!buffer.hasRemaining() || idInBlock == blocksize) {
      idInBlock=0;
    }
    return idInBlock;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return 0;
  }
}","public int locateInBlock(int block,CharSequence str){
  if (block >= blocks.getNumberOfElements()) {
    return 0;
  }
  ReplazableString tempString=new ReplazableString();
  int idInBlock=0;
  int cshared=0;
  ByteBuffer buffer=buffers[block / BLOCKS_PER_BYTEBUFFER].duplicate();
  buffer.position((int)(blocks.get(block) - posFirst[block / BLOCKS_PER_BYTEBUFFER]));
  try {
    if (!buffer.hasRemaining()) {
      return 0;
    }
    tempString.replace(buffer,0);
    idInBlock++;
    while ((idInBlock < blocksize) && buffer.hasRemaining()) {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
      if (delta >= cshared) {
        cshared+=ByteStringUtil.longestCommonPrefix(tempString,str,cshared);
        if ((cshared == str.length()) && (tempString.length() == str.length())) {
          return idInBlock;
        }
      }
 else {
        return 0;
      }
      idInBlock++;
    }
    return 0;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return 0;
  }
}",0.9256820319849484
22649,"@Override public void processTriple(TripleString triple,long pos){
  this.insert(triple.getSubject(),triple.getPredicate(),triple.getObject());
}","@Override public void processTriple(TripleString triple,long pos){
  triples.add(new TripleString(triple));
}",0.6850393700787402
22650,"public static final int strcmp(CharSequence str,ByteBuffer buffer,int offset){
  byte[] buf=null;
  int len;
  if (str instanceof CompactString) {
    buf=((CompactString)str).getData();
    len=buf.length;
  }
 else   if (str instanceof String) {
    buf=((String)str).getBytes(ByteStringUtil.STRING_ENCODING);
    len=buf.length;
  }
 else   if (str instanceof ReplazableString) {
    buf=((ReplazableString)str).buffer;
    len=((ReplazableString)str).used;
  }
 else {
    throw new NotImplementedException();
  }
  int i=0;
  int n=Math.min(len,buffer.capacity() - offset);
  while (i < n) {
    byte v1=buf[i];
    byte v2=buffer.get(offset + i);
    if (v1 != v2) {
      return v1 - v2;
    }
    if (v1 == 0) {
      return 0;
    }
    i++;
  }
  if (buffer.capacity() - offset - i > 0) {
    byte v=buffer.get(offset + i);
    if (v == 0) {
      return 0;
    }
 else {
      return -1;
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","public static final int strcmp(CharSequence str,ByteBuffer buffer,int offset){
  byte[] buf=null;
  int len;
  if (str instanceof CompactString) {
    buf=((CompactString)str).getData();
    len=buf.length;
  }
 else   if (str instanceof String) {
    buf=((String)str).getBytes(ByteStringUtil.STRING_ENCODING);
    len=buf.length;
  }
 else   if (str instanceof ReplazableString) {
    buf=((ReplazableString)str).buffer;
    len=((ReplazableString)str).used;
  }
 else {
    throw new NotImplementedException();
  }
  int i=0;
  int n=Math.min(len,buffer.capacity() - offset);
  while (i < n) {
    int v1=buf[i] & 0xFF;
    int v2=buffer.get(offset + i) & 0xFF;
    if (v1 != v2) {
      return v1 - v2;
    }
    if (v1 == 0) {
      return 0;
    }
    i++;
  }
  if (buffer.capacity() - offset - i > 0) {
    byte v=buffer.get(offset + i);
    if (v == 0) {
      return 0;
    }
 else {
      return -1;
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9797365754812564
22651,"@Override public void insert(CharSequence subject,CharSequence predicate,long object){
  triples.add(new TripleString(subject,predicate,'""' + Long.toString(object) + '""'));
}","@Override public void insert(CharSequence subject,CharSequence predicate,long object){
  triples.add(new TripleString(HeaderUtil.cleanURI(subject),HeaderUtil.cleanURI(predicate),'""' + Long.toString(object) + '""'));
}",0.8051282051282052
22652,"private void createIndexObjectMemoryEfficient(){
  StopWatch global=new StopWatch();
  StopWatch st=new StopWatch();
  SequenceLog64 objectCount=new SequenceLog64(BitUtil.log2(seqZ.getNumberOfElements()));
  long maxCount=0;
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long val=seqZ.get(i);
    if (val == 0) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (objectCount.getNumberOfElements() < val) {
      objectCount.resize(val);
    }
    long count=objectCount.get(val - 1) + 1;
    maxCount=count > maxCount ? count : maxCount;
    objectCount.set(val - 1,count);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow() + ""String_Node_Str""+ maxCount);
  st.reset();
  Bitmap375 bitmapIndex=new Bitmap375(seqZ.getNumberOfElements());
  long tmpCount=0;
  for (long i=0; i < objectCount.getNumberOfElements(); i++) {
    tmpCount+=objectCount.get(i);
    bitmapIndex.set(tmpCount - 1,true);
  }
  bitmapIndex.set(seqZ.getNumberOfElements() - 1,true);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectCount=null;
  st.reset();
  SequenceLog64 objectInsertedCount=new SequenceLog64(BitUtil.log2(maxCount),bitmapIndex.countOnes());
  objectInsertedCount.resize(bitmapIndex.countOnes());
  SequenceLog64 objectArray=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()),seqZ.getNumberOfElements());
  objectArray.resize(seqZ.getNumberOfElements());
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long objectValue=seqZ.get(i);
    long posY=i > 0 ? bitmapZ.rank1(i - 1) : 0;
    long insertBase=objectValue == 1 ? 0 : bitmapIndex.select1(objectValue - 1) + 1;
    long insertOffset=objectInsertedCount.get(objectValue - 1);
    objectInsertedCount.set(objectValue - 1,insertOffset + 1);
    objectArray.set(insertBase + insertOffset,posY);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectInsertedCount=null;
  st.reset();
  long object=1;
  long first=0;
  long last=bitmapIndex.select1(object) + 1;
  do {
    long listLen=last - first;
    if (listLen == 2) {
      long aPos=objectArray.get(first);
      long a=seqY.get(aPos);
      long bPos=objectArray.get(last);
      long b=seqY.get(bPos);
      if (a > b) {
        objectArray.set(first,bPos);
        objectArray.set(last,aPos);
      }
    }
 else     if (listLen > 2) {
class Pair {
        int valueY;
        int positionY;
      }
      ;
      ArrayList<Pair> list=new ArrayList<Pair>((int)listLen);
      for (long i=first; i < last; i++) {
        Pair p=new Pair();
        p.positionY=(int)objectArray.get(i);
        p.valueY=(int)seqY.get(p.positionY);
        list.add(p);
      }
      Collections.sort(list,new Comparator<Pair>(){
        @Override public int compare(        Pair o1,        Pair o2){
          if (o1.valueY == o2.valueY) {
            return o1.positionY - o2.positionY;
          }
          return o1.valueY - o2.valueY;
        }
      }
);
      for (long i=first; i < last; i++) {
        objectArray.set(i,list.get((int)(i - first)).positionY);
      }
    }
    first=last;
    last=bitmapIndex.select1(object) + 1;
    object++;
  }
 while (object <= bitmapIndex.countOnes());
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  st.reset();
  SequenceLog64 predCount=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()));
  for (long i=0; i < seqY.getNumberOfElements(); i++) {
    long val=seqY.get(i);
    if (predCount.getNumberOfElements() < val) {
      predCount.resize(val);
    }
    predCount.set(val - 1,predCount.get(val - 1) + 1);
  }
  predCount.trimToSize();
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  this.predicateCount=predCount;
  st.reset();
  this.indexZ=objectArray;
  this.bitmapIndexZ=bitmapIndex;
  this.adjIndex=new AdjacencyList(this.indexZ,this.bitmapIndexZ);
  System.out.println(""String_Node_Str"" + global.stopAndShow());
}","private void createIndexObjectMemoryEfficient(){
  StopWatch global=new StopWatch();
  StopWatch st=new StopWatch();
  SequenceLog64 objectCount=new SequenceLog64(BitUtil.log2(seqZ.getNumberOfElements()));
  long maxCount=0;
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long val=seqZ.get(i);
    if (val == 0) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (objectCount.getNumberOfElements() < val) {
      objectCount.resize(val);
    }
    long count=objectCount.get(val - 1) + 1;
    maxCount=count > maxCount ? count : maxCount;
    objectCount.set(val - 1,count);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow() + ""String_Node_Str""+ maxCount);
  st.reset();
  Bitmap375 bitmapIndex=new Bitmap375(seqZ.getNumberOfElements());
  long tmpCount=0;
  for (long i=0; i < objectCount.getNumberOfElements(); i++) {
    tmpCount+=objectCount.get(i);
    bitmapIndex.set(tmpCount - 1,true);
  }
  bitmapIndex.set(seqZ.getNumberOfElements() - 1,true);
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectCount=null;
  st.reset();
  SequenceLog64 objectInsertedCount=new SequenceLog64(BitUtil.log2(maxCount),bitmapIndex.countOnes());
  objectInsertedCount.resize(bitmapIndex.countOnes());
  SequenceLog64 objectArray=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()),seqZ.getNumberOfElements());
  objectArray.resize(seqZ.getNumberOfElements());
  for (long i=0; i < seqZ.getNumberOfElements(); i++) {
    long objectValue=seqZ.get(i);
    long posY=i > 0 ? bitmapZ.rank1(i - 1) : 0;
    long insertBase=objectValue == 1 ? 0 : bitmapIndex.select1(objectValue - 1) + 1;
    long insertOffset=objectInsertedCount.get(objectValue - 1);
    objectInsertedCount.set(objectValue - 1,insertOffset + 1);
    objectArray.set(insertBase + insertOffset,posY);
  }
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  objectInsertedCount=null;
  st.reset();
  long object=1;
  long first=0;
  long last=bitmapIndex.select1(object) + 1;
  do {
    long listLen=last - first;
    if (listLen == 2) {
      long aPos=objectArray.get(first);
      long a=seqY.get(aPos);
      long bPos=objectArray.get(first + 1);
      long b=seqY.get(bPos);
      if (a > b) {
        objectArray.set(first,bPos);
        objectArray.set(first + 1,aPos);
      }
    }
 else     if (listLen > 2) {
class Pair {
        int valueY;
        int positionY;
      }
      ;
      ArrayList<Pair> list=new ArrayList<Pair>((int)listLen);
      for (long i=first; i < last; i++) {
        Pair p=new Pair();
        p.positionY=(int)objectArray.get(i);
        p.valueY=(int)seqY.get(p.positionY);
        list.add(p);
      }
      Collections.sort(list,new Comparator<Pair>(){
        @Override public int compare(        Pair o1,        Pair o2){
          if (o1.valueY == o2.valueY) {
            return o1.positionY - o2.positionY;
          }
          return o1.valueY - o2.valueY;
        }
      }
);
      for (long i=first; i < last; i++) {
        objectArray.set(i,list.get((int)(i - first)).positionY);
      }
    }
    first=last;
    last=bitmapIndex.select1(object) + 1;
    object++;
  }
 while (object <= bitmapIndex.countOnes());
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  st.reset();
  SequenceLog64 predCount=new SequenceLog64(BitUtil.log2(seqY.getNumberOfElements()));
  for (long i=0; i < seqY.getNumberOfElements(); i++) {
    long val=seqY.get(i);
    if (predCount.getNumberOfElements() < val) {
      predCount.resize(val);
    }
    predCount.set(val - 1,predCount.get(val - 1) + 1);
  }
  predCount.trimToSize();
  System.out.println(""String_Node_Str"" + st.stopAndShow());
  this.predicateCount=predCount;
  st.reset();
  this.indexZ=objectArray;
  this.bitmapIndexZ=bitmapIndex;
  this.adjIndex=new AdjacencyList(this.indexZ,this.bitmapIndexZ);
  System.out.println(""String_Node_Str"" + global.stopAndShow());
}",0.9966641005901976
22653,"@Override public void loadFromHDT(String hdtFileName,ProgressListener listener) throws IOException {
  InputStream in;
  if (hdtFileName.endsWith(""String_Node_Str"")) {
    in=new GZIPInputStream(new FileInputStream(hdtFileName));
  }
 else {
    in=new BufferedInputStream(new FileInputStream(hdtFileName));
  }
  loadFromHDT(in,listener);
  in.close();
  this.hdtFileName=hdtFileName;
}","@Override public void loadFromHDT(String hdtFileName,ProgressListener listener) throws IOException {
  InputStream in;
  if (hdtFileName.endsWith(""String_Node_Str"")) {
    in=new BufferedInputStream(new GZIPInputStream(new FileInputStream(hdtFileName)));
  }
 else {
    in=new BufferedInputStream(new FileInputStream(hdtFileName));
  }
  loadFromHDT(in,listener);
  in.close();
  this.hdtFileName=hdtFileName;
}",0.9687108886107636
22654,"public static final int strcmp(ByteBuffer a,ByteBuffer b){
  int n=a.position() + Math.min(a.remaining(),a.remaining());
  for (int i=a.position(), j=b.position(); i < n; i++, j++) {
    byte v1=a.get(i);
    byte v2=b.get(j);
    if (v1 == 0) {
      if (v2 == 0) {
        return 0;
      }
 else {
        return 1;
      }
    }
    if (v2 == 0) {
      if (v1 == 0) {
        return 0;
      }
 else {
        return -1;
      }
    }
    if (v1 == v2)     continue;
    if (v1 < v2)     return -1;
    return +1;
  }
  return a.remaining() - b.remaining();
}","public static final int strcmp(ByteBuffer a,int abase,ByteBuffer b,int bbase){
  int i=0;
  int n=Math.min(a.capacity() - abase,b.capacity() - bbase);
  while (i < n) {
    byte v1=a.get(abase + i);
    byte v2=b.get(bbase + i);
    if (v1 == 0) {
      if (v2 == 0) {
        return 0;
      }
 else {
        return -1;
      }
    }
    if (v2 == 0) {
      return +1;
    }
    if (v1 != v2) {
      if (v1 < v2) {
        return -1;
      }
 else {
        return +1;
      }
    }
    i++;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}",0.1497326203208556
22655,"public static int strlen(ByteBuffer pos){
  pos.mark();
  int len=0;
  while (pos.hasRemaining() && pos.get() != 0) {
    len++;
  }
  pos.reset();
  return len;
}","public static final int strlen(ByteBuffer buf,int base){
  int len=0;
  int n=buf.capacity() - base;
  while (len < n) {
    if (buf.get(base + len) == 0) {
      return len;
    }
    len++;
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}",0.3741007194244604
22656,"public static String asString(ByteBuffer buff){
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  while (buff.hasRemaining()) {
    byte b=buff.get();
    if (b == 0) {
      break;
    }
    out.write(b);
  }
  return new String(out.toByteArray());
}","public static final String asString(ByteBuffer buff,int offset){
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int i=0;
  int n=buff.capacity() - offset;
  while (i < n) {
    byte b=buff.get(offset + i);
    if (b == 0) {
      break;
    }
    out.write(b);
    i++;
  }
  return new String(out.toByteArray(),STRING_ENCODING);
}",0.7993366500829188
22657,"public static int longestCommonPrefix(CharSequence str1,CharSequence str2,int from){
  int len=Math.min(str1.length(),str2.length());
  int delta=from;
  while (delta < len && str1.charAt(delta) == str2.charAt(delta)) {
    delta++;
  }
  return delta - from;
}","public static final int longestCommonPrefix(CharSequence str1,CharSequence str2,int from){
  int len=Math.min(str1.length(),str2.length());
  int delta=from;
  while (delta < len && str1.charAt(delta) == str2.charAt(delta)) {
    delta++;
  }
  return delta - from;
}",0.9886363636363636
22658,"/** 
 * Add numbits of value to buffer at pos
 * @param buffer
 * @param pos Position in bits.
 * @param value Value to be added
 * @param numbits numbits of value to be added.
 */
public static void append(long[] buffer,long pos,long value,int numbits){
  final int W=64;
  int i=(int)(pos / W), j=(int)(pos % W);
  if (numbits > (W - j)) {
    buffer[i]|=value << j >>> j;
    buffer[i + 1]|=(value << (W - j - numbits));
  }
 else {
    buffer[i]|=(value << (W - j - numbits));
  }
}","public static final int append(OutputStream out,CharSequence str,int start) throws IOException {
  byte[] bytes;
  int len;
  if (str instanceof String) {
    bytes=((String)str).getBytes(ByteStringUtil.STRING_ENCODING);
    len=bytes.length;
  }
 else   if (str instanceof CompactString) {
    bytes=((CompactString)str).getData();
    len=bytes.length;
  }
 else   if (str instanceof ReplazableString) {
    bytes=((ReplazableString)str).getBuffer();
    len=((ReplazableString)str).used;
  }
 else {
    throw new NotImplementedException();
  }
  out.write(bytes,start,len - start);
  return len - start;
}",0.0292237442922374
22659,"@Override public int compare(CharSequence s1,CharSequence s2){
  if (s1 instanceof CompactString && s2 instanceof CompactString) {
    CompactString cs1=(CompactString)s1;
    CompactString cs2=(CompactString)s2;
    return cs1.compareTo(cs2);
  }
  int len1=s1.length();
  int len2=s2.length();
  int n=Math.min(len1,len2);
  int k=0;
  while (k < n) {
    char c1=s1.charAt(k);
    char c2=s2.charAt(k);
    if (c1 != c2) {
      return c1 - c2;
    }
    k++;
  }
  return len1 - len2;
}","@Override public int compare(CharSequence s1,CharSequence s2){
  if (s1 instanceof CompactString && s2 instanceof CompactString) {
    CompactString cs1=(CompactString)s1;
    CompactString cs2=(CompactString)s2;
    return cs1.compareTo(cs2);
  }
  int len1=s1.length();
  int len2=s2.length();
  int n=Math.min(len1,len2);
  int k=0;
  while (k < n) {
    char c1=s1.charAt(k);
    char c2=s2.charAt(k);
    if (c1 != c2) {
      return c2 - c1;
    }
    k++;
  }
  return len2 - len1;
}",0.9918367346938776
22660,"private int locateBlock(CharSequence str){
  if (blocks.getNumberOfElements() == 0) {
    return -1;
  }
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    ByteBuffer buffer=cacheBuffers.get()[mid / BLOCKS_PER_BYTEBUFFER];
    buffer.position((int)(blocks.get(mid) - blocks.get(mid - mid % BLOCKS_PER_BYTEBUFFER)));
    int cmp=ByteStringUtil.strcmp(str,buffer);
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}","private int locateBlock(CharSequence str){
  if (blocks.getNumberOfElements() == 0) {
    return -1;
  }
  int low=0;
  int high=(int)blocks.getNumberOfElements() - 1;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    ByteBuffer buffer=cacheBuffers.get()[mid / BLOCKS_PER_BYTEBUFFER];
    buffer.position((int)(blocks.get(mid) - posFirst[mid / BLOCKS_PER_BYTEBUFFER]));
    int cmp=ByteStringUtil.strcmp(str,buffer);
    if (cmp < 0) {
      high=mid - 1;
    }
 else     if (cmp > 0) {
      low=mid + 1;
    }
 else {
      return mid;
    }
  }
  return -(low + 1);
}",0.9674657534246576
22661,"public int locateInBlock(int block,CharSequence str){
  if (block >= blocks.getNumberOfElements()) {
    return 0;
  }
  ReplazableString tempString=new ReplazableString();
  int idInBlock=0;
  int cshared=0;
  ByteBuffer buffer=cacheBuffers.get()[block / BLOCKS_PER_BYTEBUFFER];
  buffer.position((int)(blocks.get(block) - blocks.get(block - block % BLOCKS_PER_BYTEBUFFER)));
  try {
    tempString.replace(buffer,0);
    idInBlock++;
    while ((idInBlock < blocksize) && buffer.hasRemaining()) {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
      if (delta >= cshared) {
        cshared+=ByteStringUtil.longestCommonPrefix(tempString,str,cshared);
        if ((cshared == str.length()) && (tempString.length() == str.length())) {
          break;
        }
      }
 else {
        idInBlock=0;
        break;
      }
      idInBlock++;
    }
    if (!buffer.hasRemaining() || idInBlock == blocksize) {
      idInBlock=0;
    }
    return idInBlock;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return 0;
  }
}","public int locateInBlock(int block,CharSequence str){
  if (block >= blocks.getNumberOfElements()) {
    return 0;
  }
  ReplazableString tempString=new ReplazableString();
  int idInBlock=0;
  int cshared=0;
  ByteBuffer buffer=cacheBuffers.get()[block / BLOCKS_PER_BYTEBUFFER];
  buffer.position((int)(blocks.get(block) - posFirst[block / BLOCKS_PER_BYTEBUFFER]));
  try {
    if (!buffer.hasRemaining()) {
      return 0;
    }
    tempString.replace(buffer,0);
    idInBlock++;
    while ((idInBlock < blocksize) && buffer.hasRemaining()) {
      long delta=VByte.decode(buffer);
      tempString.replace(buffer,(int)delta);
      if (delta >= cshared) {
        cshared+=ByteStringUtil.longestCommonPrefix(tempString,str,cshared);
        if ((cshared == str.length()) && (tempString.length() == str.length())) {
          break;
        }
      }
 else {
        idInBlock=0;
        break;
      }
      idInBlock++;
    }
    if (!buffer.hasRemaining() || idInBlock == blocksize) {
      idInBlock=0;
    }
    return idInBlock;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return 0;
  }
}",0.9540863177226814
22662,"public PFCDictionarySectionMap(CountInputStream input,File f) throws IOException {
  CRCInputStream crcin=new CRCInputStream(input,new CRC8());
  int type=crcin.read();
  if (type != TYPE_INDEX) {
    throw new IllegalFormatException(""String_Node_Str"");
  }
  numstrings=(int)VByte.decode(crcin);
  dataSize=VByte.decode(crcin);
  blocksize=(int)VByte.decode(crcin);
  if (!crcin.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
  blocks=SequenceFactory.createStream(input);
  blocks.load(input,null);
  long base=input.getTotalBytes();
  IOUtil.skip(crcin,dataSize + 4);
  ch=new FileInputStream(f).getChannel();
  int block=0;
  int buffer=0;
  long numBlocks=blocks.getNumberOfElements();
  long bytePos=0;
  buffers=new ByteBuffer[(int)(1 + numBlocks / BLOCKS_PER_BYTEBUFFER)];
  while (block < numBlocks - 1) {
    int nextBlock=(int)Math.min(numBlocks - 1,block + BLOCKS_PER_BYTEBUFFER);
    long nextBytePos=blocks.get(nextBlock);
    buffers[buffer]=ch.map(MapMode.READ_ONLY,base + bytePos,nextBytePos - bytePos);
    buffers[buffer].order(ByteOrder.LITTLE_ENDIAN);
    bytePos=nextBytePos;
    block+=BLOCKS_PER_BYTEBUFFER;
    buffer++;
  }
}","public PFCDictionarySectionMap(CountInputStream input,File f) throws IOException {
  CRCInputStream crcin=new CRCInputStream(input,new CRC8());
  int type=crcin.read();
  if (type != TYPE_INDEX) {
    throw new IllegalFormatException(""String_Node_Str"");
  }
  numstrings=(int)VByte.decode(crcin);
  dataSize=VByte.decode(crcin);
  blocksize=(int)VByte.decode(crcin);
  if (!crcin.readCRCAndCheck()) {
    throw new CRCException(""String_Node_Str"");
  }
  blocks=SequenceFactory.createStream(input);
  blocks.load(input,null);
  long base=input.getTotalBytes();
  IOUtil.skip(crcin,dataSize + 4);
  ch=new FileInputStream(f).getChannel();
  int block=0;
  int buffer=0;
  long numBlocks=blocks.getNumberOfElements();
  long bytePos=0;
  long numBuffers=1 + numBlocks / BLOCKS_PER_BYTEBUFFER;
  buffers=new ByteBuffer[(int)numBuffers];
  posFirst=new long[(int)numBuffers];
  while (block < numBlocks - 1) {
    int nextBlock=(int)Math.min(numBlocks - 1,block + BLOCKS_PER_BYTEBUFFER);
    long nextBytePos=blocks.get(nextBlock);
    buffers[buffer]=ch.map(MapMode.READ_ONLY,base + bytePos,nextBytePos - bytePos);
    buffers[buffer].order(ByteOrder.LITTLE_ENDIAN);
    posFirst[buffer]=bytePos;
    bytePos=nextBytePos;
    block+=BLOCKS_PER_BYTEBUFFER;
    buffer++;
  }
}",0.9362224039247752
22663,"@Override public int read(byte[] b,int off,int len) throws IOException {
  int value=super.read(b,off,len);
  if (value != -1) {
    partial+=value;
    total+=value;
  }
  return value;
}","@Override public int read(byte[] b,int off,int len) throws IOException {
  int value=in.read(b,off,len);
  if (value != -1) {
    partial+=value;
    total+=value;
  }
  return value;
}",0.9812332439678284
22664,"/** 
 * @param parent
 */
public CountInputStream(InputStream parent){
  super(parent);
  total=0;
  partial=0;
}","/** 
 * @param parent
 */
public CountInputStream(InputStream input){
  this.in=input;
  total=0;
  partial=0;
}",0.88
22665,"ParserException(String message){
  super(message);
}","public ParserException(String message){
  super(message);
}",0.9369369369369368
22666,"/** 
 * Read from a line, where each component is separated by space.
 * @param line
 */
public void read(String line){
  int split, posa, posb;
  this.clear();
  posa=0;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (line.charAt(posb - 1) == '>')   posb--;
  this.setSubject(line.substring(posa,posb));
  posa=split + 1;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (posb > posa && line.charAt(posb - 1) == '>')   posb--;
  this.setPredicate(line.substring(posa,posb));
  posa=split + 1;
  posb=line.length();
  if (line.charAt(posb - 1) == '.')   posb--;
  if (line.charAt(posb - 1) == ' ')   posb--;
  if (line.charAt(posa) == '<') {
    posa++;
    if (posb > posa && line.charAt(posb - 1) == '>')     posb--;
  }
  this.setObject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
}","/** 
 * Read from a line, where each component is separated by space.
 * @param line
 */
public void read(String line) throws ParserException {
  int split, posa, posb;
  this.clear();
  posa=0;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (line.charAt(posb - 1) == '>')   posb--;
  this.setSubject(line.substring(posa,posb));
  posa=split + 1;
  posb=split=line.indexOf(' ',posa);
  if (posb == -1)   return;
  if (line.charAt(posa) == '<')   posa++;
  if (posb > posa && line.charAt(posb - 1) == '>')   posb--;
  this.setPredicate(line.substring(posa,posb));
  posa=split + 1;
  posb=line.length();
  if (line.charAt(posb - 1) == '.')   posb--;
  if (line.charAt(posb - 1) == ' ')   posb--;
  if (line.charAt(posa) == '<') {
    posa++;
    if (posb > posa && line.charAt(posb - 1) == '>')     posb--;
  }
  this.setObject(UnicodeEscape.unescapeString(line.substring(posa,posb)));
}",0.987220447284345
22667,"public void execute() throws ParserException, IOException {
  HDT hdt=HDTManager.loadIndexedHDT(hdtInput,this);
  BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
  TripleString cmd=new TripleString();
  while (true) {
    System.out.print(""String_Node_Str"");
    System.out.flush();
    String line=in.readLine();
    if (line == null || line.equals(""String_Node_Str"") || line.equals(""String_Node_Str"")) {
      break;
    }
    if (line.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      continue;
    }
    cmd.read(line);
    System.out.println(""String_Node_Str"" + cmd.getSubject() + ""String_Node_Str""+ cmd.getPredicate()+ ""String_Node_Str""+ cmd.getObject()+ ""String_Node_Str"");
    iterate(hdt,cmd.getSubject(),cmd.getPredicate(),cmd.getObject());
  }
  in.close();
}","public void execute() throws IOException {
  HDT hdt=HDTManager.loadIndexedHDT(hdtInput,this);
  BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
  TripleString triplePattern=new TripleString();
  while (true) {
    System.out.print(""String_Node_Str"");
    System.out.flush();
    String line=in.readLine();
    if (line == null || line.equals(""String_Node_Str"") || line.equals(""String_Node_Str"")) {
      break;
    }
    if (line.equals(""String_Node_Str"")) {
      help();
      continue;
    }
    try {
      parseTriplePattern(triplePattern,line);
      System.out.println(""String_Node_Str"" + triplePattern.getSubject() + ""String_Node_Str""+ triplePattern.getPredicate()+ ""String_Node_Str""+ triplePattern.getObject()+ ""String_Node_Str"");
      iterate(hdt,triplePattern.getSubject(),triplePattern.getPredicate(),triplePattern.getObject());
    }
 catch (    ParserException e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      help();
    }
catch (    NotFoundException e) {
      System.err.println(""String_Node_Str"");
    }
  }
  in.close();
}",0.6699171136031205
22668,"protected static void iterate(HDT hdt,CharSequence subject,CharSequence predicate,CharSequence object){
  StopWatch iterateTime=new StopWatch();
  try {
    int count=0;
    subject=subject.length() == 1 && subject.charAt(0) == '?' ? ""String_Node_Str"" : subject;
    predicate=predicate.length() == 1 && predicate.charAt(0) == '?' ? ""String_Node_Str"" : predicate;
    object=object.length() == 1 && object.charAt(0) == '?' ? ""String_Node_Str"" : object;
    IteratorTripleString it=hdt.search(subject,predicate,object);
    count=0;
    while (it.hasNext()) {
      TripleString triple=it.next();
      System.out.println(triple);
      count++;
    }
    System.out.println(""String_Node_Str"" + count + ""String_Node_Str""+ iterateTime.stopAndShow());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","protected static void iterate(HDT hdt,CharSequence subject,CharSequence predicate,CharSequence object) throws NotFoundException {
  StopWatch iterateTime=new StopWatch();
  int count=0;
  subject=subject.length() == 1 && subject.charAt(0) == '?' ? ""String_Node_Str"" : subject;
  predicate=predicate.length() == 1 && predicate.charAt(0) == '?' ? ""String_Node_Str"" : predicate;
  object=object.length() == 1 && object.charAt(0) == '?' ? ""String_Node_Str"" : object;
  IteratorTripleString it=hdt.search(subject,predicate,object);
  count=0;
  while (it.hasNext()) {
    TripleString triple=it.next();
    System.out.println(triple);
    count++;
  }
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str""+ iterateTime.stopAndShow());
}",0.9252577319587628
22669,"@Override public void save(OutputStream output,ControlInfo ci,ProgressListener listener) throws IOException {
  ByteArrayOutputStream headerData=new ByteArrayOutputStream();
  IteratorTripleString iterator=this.search(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  while (iterator.hasNext()) {
    TripleString next=iterator.next();
    IOUtil.writeString(headerData,next.asNtriple().toString());
  }
  ci.clear();
  ci.setFormat(HDTVocabulary.HEADER_NTRIPLES);
  ci.setInt(""String_Node_Str"",headerData.size());
  ci.save(output);
  output.write(headerData.toByteArray());
}","@Override public void save(OutputStream output,ControlInfo ci,ProgressListener listener) throws IOException {
  ByteArrayOutputStream headerData=new ByteArrayOutputStream();
  IteratorTripleString iterator=this.search(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  while (iterator.hasNext()) {
    TripleString next=iterator.next();
    IOUtil.writeString(headerData,next.asNtriple().toString());
  }
  ci.clear();
  ci.setType(ControlInfo.Type.HEADER);
  ci.setFormat(HDTVocabulary.HEADER_NTRIPLES);
  ci.setInt(""String_Node_Str"",headerData.size());
  ci.save(output);
  output.write(headerData.toByteArray());
}",0.967741935483871
22670,"@Override public boolean readAndCheck(InputStream in) throws IOException {
  short readCRC=IOUtil.readShort(in);
  return (readCRC == crc16);
}","@Override public boolean readAndCheck(InputStream in) throws IOException {
  int readCRC=IOUtil.readShort(in) & 0xFFFF;
  return (readCRC == crc16);
}",0.9488054607508531
22671,"@Override public void writeCRC(OutputStream out) throws IOException {
  IOUtil.writeShort(out,crc16);
}","@Override public void writeCRC(OutputStream out) throws IOException {
  IOUtil.writeShort(out,(short)crc16);
}",0.9671361502347418
22672,"@Override public void update(byte data){
  int tbl_idx=(crc16 ^ data) & 0xff;
  crc16=(short)((crc16_table[tbl_idx] ^ (crc16 >>> 8)) & 0xffff);
}","@Override public void update(byte data){
  int tbl_idx=(crc16 ^ data) & 0xff;
  crc16=(crc16_table[tbl_idx] ^ crc16 >>> 8) & 0xFFFF;
}",0.931899641577061
22673,"@Override public void remove(){
  throw new NotImplementedException();
}","@Override public void remove(){
  iterator.remove();
}",0.7142857142857143
22674,"@Override public void goToStart(){
  prevY=-1;
  posY=adjY.findNextAppearance(0,patY);
  nextY=adjY.findNextAppearance(posY + 1,patY);
  posZ=prevZ=adjZ.find(posY);
  nextZ=adjZ.last(posY);
  x=(int)adjY.findListIndex(posY) + 1;
  y=(int)adjY.get(posY);
  z=(int)adjY.get(posZ);
}","@Override public void goToStart(){
  prevY=-1;
  posY=adjY.findNextAppearance(0,patY);
  nextY=adjY.findNextAppearance(posY + 1,patY);
  posZ=prevZ=adjZ.find(posY);
  nextZ=adjZ.last(posY);
  x=(int)adjY.findListIndex(posY) + 1;
  y=(int)adjY.get(posY);
  z=(int)adjZ.get(posZ);
}",0.9964285714285714
22675,"@Override public CharSequence subSequence(int start,int end){
  if (start < 0 || end >= (this.length())) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start + 1];
  System.arraycopy(buffer,start,newdata,0,end - start + 1);
  return new ReplazableString(newdata);
}","@Override public CharSequence subSequence(int start,int end){
  if (start < 0 || end > (this.length()) || (end - start) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(buffer,start,newdata,0,end - start);
  return new ReplazableString(newdata);
}",0.9608355091383812
22676,"/** 
 * @param din
 * @param bytes
 * @param listener
 * @return
 */
public static final byte[] readBuffer(DataInputStream input,int length,ProgressListener listener) throws IOException {
  byte[] buffer=new byte[length];
  input.read(buffer,0,length);
  return buffer;
}","/** 
 * @param din
 * @param bytes
 * @param listener
 * @return
 */
public static final byte[] readBuffer(InputStream input,int length,ProgressListener listener) throws IOException {
  int nRead;
  int pos=0;
  byte[] data=new byte[length];
  while ((nRead=input.read(data,pos,length - pos)) > 0) {
    pos+=nRead;
  }
  if (pos != length) {
    throw new IOException(""String_Node_Str"");
  }
  return data;
}",0.6676470588235294
22677,"public static String readChars(DataInputStream in,int numChars) throws IOException {
  StringBuilder out=new StringBuilder();
  for (int i=0; i < numChars; i++) {
    char c=(char)in.readByte();
    out.append(c);
  }
  return out.toString();
}","public static String readChars(DataInput in,int numChars) throws IOException {
  StringBuilder out=new StringBuilder();
  for (int i=0; i < numChars; i++) {
    char c=(char)in.readByte();
    out.append(c);
  }
  return out.toString();
}",0.9875518672199172
22678,"public static void writeLine(DataOutputStream out,String line) throws IOException {
  for (int i=0; i < line.length(); i++) {
    byte charByte=(byte)line.charAt(i);
    out.writeByte(charByte);
  }
}","public static void writeLine(DataOutput out,String line) throws IOException {
  for (int i=0; i < line.length(); i++) {
    byte charByte=(byte)line.charAt(i);
    out.writeByte(charByte);
  }
}",0.9847715736040608
22679,"public static String readLine(DataInputStream in,char character) throws IOException {
  StringBuilder out=new StringBuilder();
  while (true) {
    char c=(char)in.readByte();
    if (c == character) {
      break;
    }
    out.append(c);
  }
  return out.toString();
}","public static String readLine(DataInput in,char character) throws IOException {
  StringBuilder out=new StringBuilder();
  while (true) {
    char c=(char)in.readByte();
    if (c == character) {
      break;
    }
    out.append(c);
  }
  return out.toString();
}",0.9887640449438202
22680,"public CharSequence subSequence(int start,int end){
  if (start < 0 || end >= (this.length())) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(data,start,newdata,0,end - start);
  return new CompactString(newdata);
}","public CharSequence subSequence(int start,int end){
  if (start < 0 || end >= (this.length())) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start + 1];
  System.arraycopy(data,start,newdata,0,end - start + 1);
  return new CompactString(newdata);
}",0.988826815642458
22681,"@Override public CharSequence subSequence(int start,int end){
  if (start < 0 || end >= (this.length())) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start];
  System.arraycopy(buffer,start,newdata,0,end - start);
  return new ReplazableString(newdata);
}","@Override public CharSequence subSequence(int start,int end){
  if (start < 0 || end >= (this.length())) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ length());
  }
  byte[] newdata=new byte[end - start + 1];
  System.arraycopy(buffer,start,newdata,0,end - start + 1);
  return new ReplazableString(newdata);
}",0.9892761394101875
22682,"public void append(byte[] data,int offset,int len){
  this.replace(used,data,offset,len);
}","public void append(CharSequence other){
  ensureSize(this.used + other.length());
  for (int i=0; i < other.length(); i++) {
    buffer[this.used + i]=(byte)other.charAt(i);
  }
  used+=other.length();
}",0.1700680272108843
22683,"/** 
 * Get derivatives features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale
 * @param xOrder x-order of differentiation
 * @param yOrder y-order of differentiation
 * @param zOrder z-order of differentiation
 * @return filter image after specific order derivatives
 */
public Callable<ArrayList<ImagePlus>> getDerivatives(final ImagePlus originalImage,final double sigma,final int xOrder,final int yOrder,final int zOrder){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=scaleFactor[0];
        c.pixelHeight=scaleFactor[1];
        c.pixelDepth=scaleFactor[2];
        final ImagePlus ip=ImageScience.computeDifferentialImage(sigma,xOrder,yOrder,zOrder,channel);
        if (xOrder + yOrder + zOrder == 0)         ip.setTitle(availableFeatures[GAUSSIAN] + ""String_Node_Str"" + sigma);
 else         ip.setTitle(availableFeatures[DERIVATIVES] + ""String_Node_Str"" + xOrder+ ""String_Node_Str""+ yOrder+ ""String_Node_Str""+ zOrder+ ""String_Node_Str""+ sigma);
        ip.getImageStack().deleteLastSlice();
        ip.getImageStack().deleteSlice(1);
        results[ch].add(ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get derivatives features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale
 * @param xOrder x-order of differentiation
 * @param yOrder y-order of differentiation
 * @param zOrder z-order of differentiation
 * @return filter image after specific order derivatives
 */
public Callable<ArrayList<ImagePlus>> getDerivatives(final ImagePlus originalImage,final double sigma,final int xOrder,final int yOrder,final int zOrder){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=1.0 / scaleFactor[0];
        c.pixelHeight=1.0 / scaleFactor[1];
        c.pixelDepth=1.0 / scaleFactor[2];
        final ImagePlus ip=ImageScience.computeDifferentialImage(sigma,xOrder,yOrder,zOrder,channel);
        if (xOrder + yOrder + zOrder == 0)         ip.setTitle(availableFeatures[GAUSSIAN] + ""String_Node_Str"" + sigma);
 else         ip.setTitle(availableFeatures[DERIVATIVES] + ""String_Node_Str"" + xOrder+ ""String_Node_Str""+ yOrder+ ""String_Node_Str""+ zOrder+ ""String_Node_Str""+ sigma);
        ip.getImageStack().deleteLastSlice();
        ip.getImageStack().deleteSlice(1);
        results[ch].add(ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.9953100573215216
22684,"/** 
 * Get Laplacian features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @return filter Laplacian filter image
 */
public Callable<ArrayList<ImagePlus>> getLaplacian(final ImagePlus originalImage,final double sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=scaleFactor[0];
        c.pixelHeight=scaleFactor[1];
        c.pixelDepth=scaleFactor[2];
        final ImagePlus ip=ImageScience.computeLaplacianImage(sigma,channel);
        ip.setTitle(availableFeatures[LAPLACIAN] + ""String_Node_Str"" + sigma);
        ip.getImageStack().deleteLastSlice();
        ip.getImageStack().deleteSlice(1);
        results[ch].add(ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get Laplacian features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @return filter Laplacian filter image
 */
public Callable<ArrayList<ImagePlus>> getLaplacian(final ImagePlus originalImage,final double sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=1.0 / scaleFactor[0];
        c.pixelHeight=1.0 / scaleFactor[1];
        c.pixelDepth=1.0 / scaleFactor[2];
        final ImagePlus ip=ImageScience.computeLaplacianImage(sigma,channel);
        ip.setTitle(availableFeatures[LAPLACIAN] + ""String_Node_Str"" + sigma);
        ip.getImageStack().deleteLastSlice();
        ip.getImageStack().deleteSlice(1);
        results[ch].add(ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.9939312204989884
22685,"public ArrayList<ImagePlus> call(){
  ImagePlus[] channels=extractChannels(originalImage);
  ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
  for (int ch=0; ch < channels.length; ch++) {
    results[ch]=new ArrayList<ImagePlus>();
    final ImagePlus channel=channels[ch].duplicate();
    channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
    channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
    Calibration c=channel.getCalibration();
    c.pixelWidth=scaleFactor[0];
    c.pixelHeight=scaleFactor[1];
    c.pixelDepth=scaleFactor[2];
    final ArrayList<ImagePlus> result=ImageScience.computeEigenimages(sigma,integrationScale,channel);
    final ImageStack largest=result.get(0).getImageStack();
    final ImageStack middle=result.get(1).getImageStack();
    final ImageStack smallest=result.get(2).getImageStack();
    smallest.deleteLastSlice();
    smallest.deleteSlice(1);
    middle.deleteLastSlice();
    middle.deleteSlice(1);
    largest.deleteLastSlice();
    largest.deleteSlice(1);
    results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,largest));
    results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,middle));
    results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,smallest));
  }
  return mergeResultChannels(results);
}","public ArrayList<ImagePlus> call(){
  ImagePlus[] channels=extractChannels(originalImage);
  ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
  for (int ch=0; ch < channels.length; ch++) {
    results[ch]=new ArrayList<ImagePlus>();
    final ImagePlus channel=channels[ch].duplicate();
    channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
    channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
    Calibration c=channel.getCalibration();
    c.pixelWidth=1.0 / scaleFactor[0];
    c.pixelHeight=1.0 / scaleFactor[1];
    c.pixelDepth=1.0 / scaleFactor[2];
    final ArrayList<ImagePlus> result=ImageScience.computeEigenimages(sigma,integrationScale,channel);
    final ImageStack largest=result.get(0).getImageStack();
    final ImageStack middle=result.get(1).getImageStack();
    final ImageStack smallest=result.get(2).getImageStack();
    smallest.deleteLastSlice();
    smallest.deleteSlice(1);
    middle.deleteLastSlice();
    middle.deleteSlice(1);
    largest.deleteLastSlice();
    largest.deleteSlice(1);
    results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,largest));
    results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,middle));
    results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,smallest));
  }
  return mergeResultChannels(results);
}",0.9944168734491317
22686,"/** 
 * Get structure tensor features (to be submitted in an ExecutorService). It computes, for all pixels in the input image, the eigenvalues of the so-called structure tensor.
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @param integrationScale integration scale (standard deviation of the Gaussian kernel used for smoothing the elements of the structure tensor, must be larger than zero)
 * @return filter structure tensor filter image
 */
public Callable<ArrayList<ImagePlus>> getStructure(final ImagePlus originalImage,final double sigma,final double integrationScale){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=scaleFactor[0];
        c.pixelHeight=scaleFactor[1];
        c.pixelDepth=scaleFactor[2];
        final ArrayList<ImagePlus> result=ImageScience.computeEigenimages(sigma,integrationScale,channel);
        final ImageStack largest=result.get(0).getImageStack();
        final ImageStack middle=result.get(1).getImageStack();
        final ImageStack smallest=result.get(2).getImageStack();
        smallest.deleteLastSlice();
        smallest.deleteSlice(1);
        middle.deleteLastSlice();
        middle.deleteSlice(1);
        largest.deleteLastSlice();
        largest.deleteSlice(1);
        results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,largest));
        results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,middle));
        results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,smallest));
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get structure tensor features (to be submitted in an ExecutorService). It computes, for all pixels in the input image, the eigenvalues of the so-called structure tensor.
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @param integrationScale integration scale (standard deviation of the Gaussian kernel used for smoothing the elements of the structure tensor, must be larger than zero)
 * @return filter structure tensor filter image
 */
public Callable<ArrayList<ImagePlus>> getStructure(final ImagePlus originalImage,final double sigma,final double integrationScale){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=1.0 / scaleFactor[0];
        c.pixelHeight=1.0 / scaleFactor[1];
        c.pixelDepth=1.0 / scaleFactor[2];
        final ArrayList<ImagePlus> result=ImageScience.computeEigenimages(sigma,integrationScale,channel);
        final ImageStack largest=result.get(0).getImageStack();
        final ImageStack middle=result.get(1).getImageStack();
        final ImageStack smallest=result.get(2).getImageStack();
        smallest.deleteLastSlice();
        smallest.deleteSlice(1);
        middle.deleteLastSlice();
        middle.deleteSlice(1);
        largest.deleteLastSlice();
        largest.deleteSlice(1);
        results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,largest));
        results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,middle));
        results[ch].add(new ImagePlus(availableFeatures[STRUCTURE] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ integrationScale,smallest));
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.9963295269168028
22687,"/** 
 * Get Hessian features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @return filter Hessian filter images
 */
public Callable<ArrayList<ImagePlus>> getHessian(final ImagePlus originalImage,final double sigma,final boolean absolute){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=scaleFactor[0];
        c.pixelHeight=scaleFactor[1];
        c.pixelDepth=scaleFactor[2];
        final ArrayList<ImagePlus> result=ImageScience.computeHessianImages(sigma,absolute,channel);
        final ImageStack smallest=result.get(0).getImageStack();
        final ImageStack middle=result.get(1).getImageStack();
        final ImageStack largest=result.get(2).getImageStack();
        smallest.deleteLastSlice();
        smallest.deleteSlice(1);
        middle.deleteLastSlice();
        middle.deleteSlice(1);
        largest.deleteLastSlice();
        largest.deleteSlice(1);
        results[ch].add(new ImagePlus(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ absolute,smallest));
        results[ch].add(new ImagePlus(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ absolute,middle));
        results[ch].add(new ImagePlus(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ absolute,largest));
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get Hessian features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @return filter Hessian filter images
 */
public Callable<ArrayList<ImagePlus>> getHessian(final ImagePlus originalImage,final double sigma,final boolean absolute){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=1.0 / scaleFactor[0];
        c.pixelHeight=1.0 / scaleFactor[1];
        c.pixelDepth=1.0 / scaleFactor[2];
        final ArrayList<ImagePlus> result=ImageScience.computeHessianImages(sigma,absolute,channel);
        final ImageStack smallest=result.get(0).getImageStack();
        final ImageStack middle=result.get(1).getImageStack();
        final ImageStack largest=result.get(2).getImageStack();
        smallest.deleteLastSlice();
        smallest.deleteSlice(1);
        middle.deleteLastSlice();
        middle.deleteSlice(1);
        largest.deleteLastSlice();
        largest.deleteSlice(1);
        results[ch].add(new ImagePlus(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ absolute,smallest));
        results[ch].add(new ImagePlus(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ absolute,middle));
        results[ch].add(new ImagePlus(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma+ ""String_Node_Str""+ absolute,largest));
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.9957527135441244
22688,"/** 
 * Get Edges features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @return filter Edges filter image
 */
public Callable<ArrayList<ImagePlus>> getEdges(final ImagePlus originalImage,final double sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=scaleFactor[0];
        c.pixelHeight=scaleFactor[1];
        c.pixelDepth=scaleFactor[2];
        final ImagePlus ip=ImageScience.computeEdgesImage(sigma,channel);
        ip.setTitle(availableFeatures[EDGES] + ""String_Node_Str"" + sigma);
        ip.getImageStack().deleteLastSlice();
        ip.getImageStack().deleteSlice(1);
        results[ch].add(ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get Edges features (to be submitted in an ExecutorService)
 * @param originalImage input image
 * @param sigma isotropic smoothing scale	
 * @return filter Edges filter image
 */
public Callable<ArrayList<ImagePlus>> getEdges(final ImagePlus originalImage,final double sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ArrayList<ImagePlus>>(){
    public ArrayList<ImagePlus> call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ArrayList<ImagePlus>[] results=new ArrayList[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        results[ch]=new ArrayList<ImagePlus>();
        final ImagePlus channel=channels[ch].duplicate();
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(channels[ch].getImageStackSize()));
        channel.getImageStack().addSlice(""String_Node_Str"",channels[ch].getImageStack().getProcessor(1),1);
        Calibration c=channel.getCalibration();
        c.pixelWidth=1.0 / scaleFactor[0];
        c.pixelHeight=1.0 / scaleFactor[1];
        c.pixelDepth=1.0 / scaleFactor[2];
        final ImagePlus ip=ImageScience.computeEdgesImage(sigma,channel);
        ip.setTitle(availableFeatures[EDGES] + ""String_Node_Str"" + sigma);
        ip.getImageStack().deleteLastSlice();
        ip.getImageStack().deleteSlice(1);
        results[ch].add(ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.9938482570061518
22689,"/** 
 * Display the current probability maps
 */
public static void getProbability(){
  final ImageWindow iw=WindowManager.getCurrentImage().getWindow();
  if (iw instanceof CustomWindow) {
    final CustomWindow win=(CustomWindow)iw;
    final WekaSegmentation wekaSegmentation=win.getWekaSegmentation();
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    win.setButtonsEnabled(false);
    wekaSegmentation.applyClassifier(true);
    final ImagePlus probImage=wekaSegmentation.getClassifiedImage();
    if (null != probImage) {
      probImage.setOpenAsHyperStack(true);
      probImage.show();
    }
    win.updateButtonsEnabling();
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
  }
}","/** 
 * Display the current probability maps
 */
public static void getProbability(){
  final ImageWindow iw=WindowManager.getCurrentImage().getWindow();
  if (iw instanceof CustomWindow) {
    final CustomWindow win=(CustomWindow)iw;
    final WekaSegmentation wekaSegmentation=win.getWekaSegmentation();
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    win.setButtonsEnabled(false);
    wekaSegmentation.applyClassifier(true);
    final ImagePlus probImage=wekaSegmentation.getClassifiedImage();
    if (null != probImage) {
      probImage.setDimensions(wekaSegmentation.getNumOfClasses(),win.getTrainingImage().getNSlices(),win.getTrainingImage().getNFrames());
      if (win.getTrainingImage().getNSlices() * win.getTrainingImage().getNFrames() > 1)       probImage.setOpenAsHyperStack(true);
      probImage.show();
    }
    win.updateButtonsEnabling();
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
  }
}",0.8650887573964497
22690,"/** 
 * Show advanced settings dialog
 * @return false when canceled
 */
public boolean showSettingsDialog(){
  GenericDialogPlus gd=new GenericDialogPlus(""String_Node_Str"");
  final boolean[] oldEnableFeatures=wekaSegmentation.getEnabledFeatures();
  final String[] availableFeatures=isProcessing3D ? FeatureStack3D.availableFeatures : FeatureStack.availableFeatures;
  gd.addMessage(""String_Node_Str"");
  final int rows=(int)Math.round(availableFeatures.length / 2.0);
  gd.addCheckboxGroup(rows,2,availableFeatures,oldEnableFeatures);
  disableMissingFeatures(gd);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final Vector<Checkbox> v=gd.getCheckboxes();
    for (    Checkbox c : v)     c.setEnabled(false);
    gd.addMessage(""String_Node_Str"");
  }
  if (!isProcessing3D) {
    gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembraneThickness(),0);
    gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembranePatchSize(),0);
  }
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMinimumSigma(),1);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMaximumSigma(),1);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    for (int i=0; i < 4; i++)     ((TextField)gd.getNumericFields().get(i)).setEnabled(false);
  }
  gd.addMessage(""String_Node_Str"");
  GenericObjectEditor m_ClassifierEditor=new GenericObjectEditor();
  PropertyPanel m_CEPanel=new PropertyPanel(m_ClassifierEditor);
  m_ClassifierEditor.setClassType(Classifier.class);
  m_ClassifierEditor.setValue(wekaSegmentation.getClassifier());
  gd.addComponent(m_CEPanel,GridBagConstraints.HORIZONTAL,1);
  Object c=(Object)m_ClassifierEditor.getValue();
  String originalOptions=""String_Node_Str"";
  String originalClassifierName=c.getClass().getName();
  if (c instanceof OptionHandler) {
    originalOptions=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  gd.addMessage(""String_Node_Str"");
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)   gd.addStringField(""String_Node_Str"" + (i + 1),wekaSegmentation.getClassLabel(i),15);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",wekaSegmentation.doClassBalance());
  gd.addButton(""String_Node_Str"",new SaveFeatureStackButtonListener(""String_Node_Str"",wekaSegmentation));
  gd.addSlider(""String_Node_Str"",0,100,win.overlayOpacity);
  gd.addHelp(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return false;
  final int numOfFeatures=availableFeatures.length;
  final boolean[] newEnableFeatures=new boolean[numOfFeatures];
  boolean featuresChanged=false;
  for (int i=0; i < numOfFeatures; i++) {
    newEnableFeatures[i]=gd.getNextBoolean();
    if (newEnableFeatures[i] != oldEnableFeatures[i]) {
      featuresChanged=true;
      final String featureName=availableFeatures[i];
      record(SET_FEATURE,new String[]{featureName + ""String_Node_Str"" + newEnableFeatures[i]});
    }
  }
  if (featuresChanged) {
    wekaSegmentation.setEnabledFeatures(newEnableFeatures);
  }
  if (!isProcessing3D) {
    final int newThickness=(int)gd.getNextNumber();
    if (newThickness != wekaSegmentation.getMembraneThickness()) {
      featuresChanged=true;
      wekaSegmentation.setMembraneThickness(newThickness);
      record(SET_MEMBRANE_THICKNESS,new String[]{Integer.toString(newThickness)});
    }
    final int newPatch=(int)gd.getNextNumber();
    if (newPatch != wekaSegmentation.getMembranePatchSize()) {
      featuresChanged=true;
      record(SET_MEMBRANE_PATCH,new String[]{Integer.toString(newPatch)});
      wekaSegmentation.setMembranePatchSize(newPatch);
    }
  }
  final float newMinSigma=(float)gd.getNextNumber();
  if (newMinSigma != wekaSegmentation.getMinimumSigma() && newMinSigma > 0) {
    featuresChanged=true;
    record(SET_MINIMUM_SIGMA,new String[]{Float.toString(newMinSigma)});
    wekaSegmentation.setMinimumSigma(newMinSigma);
  }
  final float newMaxSigma=(float)gd.getNextNumber();
  if (newMaxSigma != wekaSegmentation.getMaximumSigma() && newMaxSigma >= wekaSegmentation.getMinimumSigma()) {
    featuresChanged=true;
    record(SET_MAXIMUM_SIGMA,new String[]{Float.toString(newMaxSigma)});
    wekaSegmentation.setMaximumSigma(newMaxSigma);
  }
  if (wekaSegmentation.getMinimumSigma() > wekaSegmentation.getMaximumSigma()) {
    IJ.error(""String_Node_Str"");
    wekaSegmentation.setMinimumSigma(0f);
    wekaSegmentation.setMaximumSigma(16f);
  }
  c=(Object)m_ClassifierEditor.getValue();
  String options=""String_Node_Str"";
  final String[] optionsArray=((OptionHandler)c).getOptions();
  if (c instanceof OptionHandler) {
    options=Utils.joinOptions(optionsArray);
  }
  if (!originalClassifierName.equals(c.getClass().getName()) || !originalOptions.equals(options)) {
    AbstractClassifier cls;
    try {
      cls=(AbstractClassifier)(c.getClass().newInstance());
      cls.setOptions(optionsArray);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      return false;
    }
    wekaSegmentation.setClassifier(cls);
    win.trainingComplete=false;
    record(SET_CLASSIFIER,new String[]{c.getClass().getName(),options});
    IJ.log(""String_Node_Str"" + c.getClass().getName() + ""String_Node_Str""+ options);
  }
  boolean classNameChanged=false;
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
    String s=gd.getNextString();
    if (null == s || 0 == s.length()) {
      IJ.log(""String_Node_Str"" + (i + 1));
      continue;
    }
    s=s.trim();
    if (!s.equals(wekaSegmentation.getClassLabel(i))) {
      if (0 == s.toLowerCase().indexOf(""String_Node_Str""))       s=s.substring(7);
      wekaSegmentation.setClassLabel(i,s);
      classNameChanged=true;
      addExampleButton[i].setText(""String_Node_Str"" + s);
      record(CHANGE_CLASS_NAME,new String[]{Integer.toString(i),s});
    }
  }
  final boolean balanceClasses=gd.getNextBoolean();
  if (wekaSegmentation.doClassBalance() != balanceClasses) {
    wekaSegmentation.setClassBalance(balanceClasses);
    record(SET_BALANCE,new String[]{Boolean.toString(balanceClasses)});
  }
  final int newOpacity=(int)gd.getNextNumber();
  if (newOpacity != win.overlayOpacity) {
    win.overlayOpacity=newOpacity;
    win.overlayAlpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,win.overlayOpacity / 100f);
    win.resultOverlay.setComposite(win.overlayAlpha);
    record(SET_OPACITY,new String[]{Integer.toString(win.overlayOpacity)});
    if (showColorOverlay)     displayImage.updateAndDraw();
  }
  if (classNameChanged) {
    win.pack();
  }
  if (featuresChanged) {
    wekaSegmentation.setFeaturesDirty();
  }
 else   if (!wekaSegmentation.getFeatureStackArray().isEmpty() && wekaSegmentation.getFeatureStackArray().getReferenceSliceIndex() != -1)   wekaSegmentation.setUpdateFeatures(false);
  return true;
}","/** 
 * Show advanced settings dialog
 * @return false when canceled
 */
public boolean showSettingsDialog(){
  GenericDialogPlus gd=new GenericDialogPlus(""String_Node_Str"");
  final boolean[] oldEnableFeatures=wekaSegmentation.getEnabledFeatures();
  final String[] availableFeatures=isProcessing3D ? FeatureStack3D.availableFeatures : FeatureStack.availableFeatures;
  gd.addMessage(""String_Node_Str"");
  final int rows=(int)Math.round(availableFeatures.length / 2.0);
  gd.addCheckboxGroup(rows,2,availableFeatures,oldEnableFeatures);
  disableMissingFeatures(gd);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final Vector<Checkbox> v=gd.getCheckboxes();
    for (    Checkbox c : v)     c.setEnabled(false);
    gd.addMessage(""String_Node_Str"");
  }
  if (!isProcessing3D) {
    gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembraneThickness(),0);
    gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembranePatchSize(),0);
  }
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMinimumSigma(),1);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMaximumSigma(),1);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final int nNumericFields=isProcessing3D ? 2 : 4;
    for (int i=0; i < nNumericFields; i++)     ((TextField)gd.getNumericFields().get(i)).setEnabled(false);
  }
  gd.addMessage(""String_Node_Str"");
  GenericObjectEditor m_ClassifierEditor=new GenericObjectEditor();
  PropertyPanel m_CEPanel=new PropertyPanel(m_ClassifierEditor);
  m_ClassifierEditor.setClassType(Classifier.class);
  m_ClassifierEditor.setValue(wekaSegmentation.getClassifier());
  gd.addComponent(m_CEPanel,GridBagConstraints.HORIZONTAL,1);
  Object c=(Object)m_ClassifierEditor.getValue();
  String originalOptions=""String_Node_Str"";
  String originalClassifierName=c.getClass().getName();
  if (c instanceof OptionHandler) {
    originalOptions=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  gd.addMessage(""String_Node_Str"");
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)   gd.addStringField(""String_Node_Str"" + (i + 1),wekaSegmentation.getClassLabel(i),15);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",wekaSegmentation.doClassBalance());
  gd.addButton(""String_Node_Str"",new SaveFeatureStackButtonListener(""String_Node_Str"",wekaSegmentation));
  gd.addSlider(""String_Node_Str"",0,100,win.overlayOpacity);
  gd.addHelp(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return false;
  final int numOfFeatures=availableFeatures.length;
  final boolean[] newEnableFeatures=new boolean[numOfFeatures];
  boolean featuresChanged=false;
  for (int i=0; i < numOfFeatures; i++) {
    newEnableFeatures[i]=gd.getNextBoolean();
    if (newEnableFeatures[i] != oldEnableFeatures[i]) {
      featuresChanged=true;
      final String featureName=availableFeatures[i];
      record(SET_FEATURE,new String[]{featureName + ""String_Node_Str"" + newEnableFeatures[i]});
    }
  }
  if (featuresChanged) {
    wekaSegmentation.setEnabledFeatures(newEnableFeatures);
  }
  if (!isProcessing3D) {
    final int newThickness=(int)gd.getNextNumber();
    if (newThickness != wekaSegmentation.getMembraneThickness()) {
      featuresChanged=true;
      wekaSegmentation.setMembraneThickness(newThickness);
      record(SET_MEMBRANE_THICKNESS,new String[]{Integer.toString(newThickness)});
    }
    final int newPatch=(int)gd.getNextNumber();
    if (newPatch != wekaSegmentation.getMembranePatchSize()) {
      featuresChanged=true;
      record(SET_MEMBRANE_PATCH,new String[]{Integer.toString(newPatch)});
      wekaSegmentation.setMembranePatchSize(newPatch);
    }
  }
  final float newMinSigma=(float)gd.getNextNumber();
  if (newMinSigma != wekaSegmentation.getMinimumSigma() && newMinSigma > 0) {
    featuresChanged=true;
    record(SET_MINIMUM_SIGMA,new String[]{Float.toString(newMinSigma)});
    wekaSegmentation.setMinimumSigma(newMinSigma);
  }
  final float newMaxSigma=(float)gd.getNextNumber();
  if (newMaxSigma != wekaSegmentation.getMaximumSigma() && newMaxSigma >= wekaSegmentation.getMinimumSigma()) {
    featuresChanged=true;
    record(SET_MAXIMUM_SIGMA,new String[]{Float.toString(newMaxSigma)});
    wekaSegmentation.setMaximumSigma(newMaxSigma);
  }
  if (wekaSegmentation.getMinimumSigma() > wekaSegmentation.getMaximumSigma()) {
    IJ.error(""String_Node_Str"");
    wekaSegmentation.setMinimumSigma(0f);
    wekaSegmentation.setMaximumSigma(16f);
  }
  c=(Object)m_ClassifierEditor.getValue();
  String options=""String_Node_Str"";
  final String[] optionsArray=((OptionHandler)c).getOptions();
  if (c instanceof OptionHandler) {
    options=Utils.joinOptions(optionsArray);
  }
  if (!originalClassifierName.equals(c.getClass().getName()) || !originalOptions.equals(options)) {
    AbstractClassifier cls;
    try {
      cls=(AbstractClassifier)(c.getClass().newInstance());
      cls.setOptions(optionsArray);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      return false;
    }
    wekaSegmentation.setClassifier(cls);
    win.trainingComplete=false;
    record(SET_CLASSIFIER,new String[]{c.getClass().getName(),options});
    IJ.log(""String_Node_Str"" + c.getClass().getName() + ""String_Node_Str""+ options);
  }
  boolean classNameChanged=false;
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
    String s=gd.getNextString();
    if (null == s || 0 == s.length()) {
      IJ.log(""String_Node_Str"" + (i + 1));
      continue;
    }
    s=s.trim();
    if (!s.equals(wekaSegmentation.getClassLabel(i))) {
      if (0 == s.toLowerCase().indexOf(""String_Node_Str""))       s=s.substring(7);
      wekaSegmentation.setClassLabel(i,s);
      classNameChanged=true;
      addExampleButton[i].setText(""String_Node_Str"" + s);
      record(CHANGE_CLASS_NAME,new String[]{Integer.toString(i),s});
    }
  }
  final boolean balanceClasses=gd.getNextBoolean();
  if (wekaSegmentation.doClassBalance() != balanceClasses) {
    wekaSegmentation.setClassBalance(balanceClasses);
    record(SET_BALANCE,new String[]{Boolean.toString(balanceClasses)});
  }
  final int newOpacity=(int)gd.getNextNumber();
  if (newOpacity != win.overlayOpacity) {
    win.overlayOpacity=newOpacity;
    win.overlayAlpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,win.overlayOpacity / 100f);
    win.resultOverlay.setComposite(win.overlayAlpha);
    record(SET_OPACITY,new String[]{Integer.toString(win.overlayOpacity)});
    if (showColorOverlay)     displayImage.updateAndDraw();
  }
  if (classNameChanged) {
    win.pack();
  }
  if (featuresChanged) {
    wekaSegmentation.setFeaturesDirty();
  }
 else   if (!wekaSegmentation.getFeatureStackArray().isEmpty() && wekaSegmentation.getFeatureStackArray().getReferenceSliceIndex() != -1)   wekaSegmentation.setUpdateFeatures(false);
  return true;
}",0.995008075172515
22691,"/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final String[] availableFeatures=isProcessing3D ? FeatureStack3D.availableFeatures : FeatureStack.availableFeatures;
  final int numFeatures=availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(availableFeatures[i])) {
        usedFeatures[i]=true;
        String[] tokens;
        float sigma;
        if (!isProcessing3D) {
switch (i) {
case FeatureStack.MEMBRANE:
            int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
        final int patchSize=Integer.parseInt(a.name().substring(index,index2));
      if (patchSize != membranePatchSize) {
        membranePatchSize=patchSize;
        if (null != featureStackArray)         featureStackArray.setMembranePatchSize(patchSize);
        featuresChanged=true;
      }
    index=a.name().lastIndexOf(""String_Node_Str"");
  final int thickness=Integer.parseInt(a.name().substring(index + 1));
if (thickness != membraneThickness) {
  membraneThickness=thickness;
  if (null != featureStackArray)   featureStackArray.setMembraneSize(thickness);
  featuresChanged=true;
}
break;
case FeatureStack.KUWAHARA:
tokens=a.name().split(""String_Node_Str"");
membranePatchSize=Integer.parseInt(tokens[1]);
break;
case FeatureStack.NEIGHBORS:
case FeatureStack.ENTROPY:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[1]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.GABOR:
case FeatureStack.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.ANISOTROPIC_DIFFUSION:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[3]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.BILATERAL:
case FeatureStack.LIPSCHITZ:
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
 else {
switch (i) {
case FeatureStack3D.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
}
}
}
IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
if (!isProcessing3D) IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
if (minSigma != this.minimumSigma && minSigma != 0) {
this.minimumSigma=minSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMinimumSigma(minSigma);
if (isProcessing3D) this.fs3d.setMinimumSigma(minSigma);
}
if (maxSigma != this.maximumSigma) {
this.maximumSigma=maxSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMaximumSigma(maxSigma);
if (isProcessing3D) this.fs3d.setMaximumSigma(maxSigma);
}
Attribute classAttribute=data.classAttribute();
Enumeration<Object> classValues=classAttribute.enumerateValues();
loadedClassNames=new ArrayList<String>();
int j=0;
setNumOfClasses(0);
while (classValues.hasMoreElements()) {
final String className=((String)classValues.nextElement()).trim();
loadedClassNames.add(className);
}
for (String className : loadedClassNames) {
IJ.log(""String_Node_Str"" + className);
setClassLabel(j,className);
addClass();
j++;
}
if (null != featureStackArray) {
final boolean[] oldEnableFeatures=isProcessing3D ? fs3d.getEnabledFeatures() : this.featureStackArray.getEnabledFeatures();
for (int i=0; i < numFeatures; i++) {
if (usedFeatures[i] != oldEnableFeatures[i]) featuresChanged=true;
}
}
 else featuresChanged=true;
if (featuresChanged) {
this.setEnabledFeatures(usedFeatures);
updateFeatures=true;
}
return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final String[] availableFeatures=isProcessing3D ? FeatureStack3D.availableFeatures : FeatureStack.availableFeatures;
  final int numFeatures=availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(availableFeatures[i])) {
        usedFeatures[i]=true;
        String[] tokens;
        float sigma;
        if (!isProcessing3D) {
switch (i) {
case FeatureStack.MEMBRANE:
            int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
        final int patchSize=Integer.parseInt(a.name().substring(index,index2));
      if (patchSize != membranePatchSize) {
        membranePatchSize=patchSize;
        if (null != featureStackArray)         featureStackArray.setMembranePatchSize(patchSize);
        featuresChanged=true;
      }
    index=a.name().lastIndexOf(""String_Node_Str"");
  final int thickness=Integer.parseInt(a.name().substring(index + 1));
if (thickness != membraneThickness) {
  membraneThickness=thickness;
  if (null != featureStackArray)   featureStackArray.setMembraneSize(thickness);
  featuresChanged=true;
}
break;
case FeatureStack.KUWAHARA:
tokens=a.name().split(""String_Node_Str"");
membranePatchSize=Integer.parseInt(tokens[1]);
break;
case FeatureStack.NEIGHBORS:
case FeatureStack.ENTROPY:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[1]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.GABOR:
case FeatureStack.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.ANISOTROPIC_DIFFUSION:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[3]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.BILATERAL:
case FeatureStack.LIPSCHITZ:
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
 else {
switch (i) {
case FeatureStack3D.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
}
}
}
IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
if (!isProcessing3D) IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
if (minSigma != this.minimumSigma && minSigma != 0) {
this.minimumSigma=minSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMinimumSigma(minSigma);
if (isProcessing3D && null != fs3d) this.fs3d.setMinimumSigma(minSigma);
}
if (maxSigma != this.maximumSigma) {
this.maximumSigma=maxSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMaximumSigma(maxSigma);
if (isProcessing3D && null != fs3d) this.fs3d.setMaximumSigma(maxSigma);
}
Attribute classAttribute=data.classAttribute();
Enumeration<Object> classValues=classAttribute.enumerateValues();
loadedClassNames=new ArrayList<String>();
int j=0;
setNumOfClasses(0);
while (classValues.hasMoreElements()) {
final String className=((String)classValues.nextElement()).trim();
loadedClassNames.add(className);
}
for (String className : loadedClassNames) {
IJ.log(""String_Node_Str"" + className);
setClassLabel(j,className);
addClass();
j++;
}
if (null != featureStackArray) {
final boolean[] oldEnableFeatures=isProcessing3D ? fs3d.getEnabledFeatures() : this.featureStackArray.getEnabledFeatures();
for (int i=0; i < numFeatures; i++) {
if (usedFeatures[i] != oldEnableFeatures[i]) featuresChanged=true;
}
}
 else featuresChanged=true;
if (featuresChanged) {
this.setEnabledFeatures(usedFeatures);
updateFeatures=true;
}
return true;
}",0.996662494785148
22692,"/** 
 * Parses a given list of options. <p/> <!-- options-start --> Valid options are: <p/> <pre> -I &lt;number of trees&gt; Number of trees to build.</pre> <pre> -K &lt;number of features&gt; Number of features to consider (&lt;1=int(logM+1)).</pre> <pre> -S Seed for random number generator. (default 1)</pre> <pre> -D If set, classifier is run in debug mode and may output additional info to the console</pre> <!-- options-end -->
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
public void setOptions(String[] options) throws Exception {
  String tmpStr;
  tmpStr=Utils.getOption('I',options);
  if (tmpStr.length() != 0) {
    this.numTrees=Integer.parseInt(tmpStr);
  }
 else {
    this.numTrees=100;
  }
  tmpStr=Utils.getOption('K',options);
  if (tmpStr.length() != 0) {
    this.numFeatures=Integer.parseInt(tmpStr);
  }
 else {
    this.numFeatures=0;
  }
  tmpStr=Utils.getOption('S',options);
  if (tmpStr.length() != 0) {
    setSeed(Integer.parseInt(tmpStr));
  }
 else {
    setSeed(1);
  }
  super.setOptions(options);
  Utils.checkForRemainingOptions(options);
}","/** 
 * Parses a given list of options. <!-- options-start --> <p> Valid options are: </p> <pre> -I &lt;number of trees&gt; Number of trees to build.</pre> <pre> -K &lt;number of features&gt; Number of features to consider (&lt;1=int(logM+1)).</pre> <pre> -S Seed for random number generator. (default 1)</pre> <pre> -D If set, classifier is run in debug mode and may output additional info to the console</pre> <!-- options-end -->
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
public void setOptions(String[] options) throws Exception {
  String tmpStr;
  tmpStr=Utils.getOption('I',options);
  if (tmpStr.length() != 0) {
    this.numTrees=Integer.parseInt(tmpStr);
  }
 else {
    this.numTrees=100;
  }
  tmpStr=Utils.getOption('K',options);
  if (tmpStr.length() != 0) {
    this.numFeatures=Integer.parseInt(tmpStr);
  }
 else {
    this.numFeatures=0;
  }
  tmpStr=Utils.getOption('S',options);
  if (tmpStr.length() != 0) {
    setSeed(Integer.parseInt(tmpStr));
  }
 else {
    setSeed(1);
  }
  super.setOptions(options);
  Utils.checkForRemainingOptions(options);
}",0.9586056644880174
22693,"/** 
 * Parses a given list of options. <p/> <p/> <!-- options-start --> Valid options are: <p/> <p/> <pre> -I &lt;number of trees&gt; Number of trees to build.</pre> <p/> <pre> -K &lt;number of features&gt; Number of features to consider (&lt;1=int(logM+1)).</pre> <p/> <pre> -S Seed for random number generator. (default 1)</pre> <p/> <pre> -depth &lt;num&gt; The maximum depth of the trees, 0 for unlimited. (default 0)</pre> <p/> <pre> -threads Number of simultaneous threads to use. (default 0 = autodetect number of available cores)</pre> <p/> <pre> -import Compute and output RF feature importances (slow).</pre> <p/> <pre> -D If set, classifier is run in debug mode and may output additional info to the console</pre> <p/> <!-- options-end -->
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
public void setOptions(String[] options) throws Exception {
  String tmpStr;
  tmpStr=Utils.getOption('I',options);
  if (tmpStr.length() != 0) {
    m_numTrees=Integer.parseInt(tmpStr);
  }
 else {
    m_numTrees=10;
  }
  tmpStr=Utils.getOption('K',options);
  if (tmpStr.length() != 0) {
    m_numFeatures=Integer.parseInt(tmpStr);
  }
 else {
    m_numFeatures=0;
  }
  tmpStr=Utils.getOption('S',options);
  if (tmpStr.length() != 0) {
    setSeed(Integer.parseInt(tmpStr));
  }
 else {
    setSeed(1);
  }
  tmpStr=Utils.getOption(""String_Node_Str"",options);
  if (tmpStr.length() != 0) {
    setMaxDepth(Integer.parseInt(tmpStr));
  }
 else {
    setMaxDepth(0);
  }
  tmpStr=Utils.getOption(""String_Node_Str"",options);
  if (tmpStr.length() != 0) {
    setNumThreads(Integer.parseInt(tmpStr));
  }
 else {
    setNumThreads(0);
  }
  setComputeImportances(Utils.getFlag(""String_Node_Str"",options));
  super.setOptions(options);
  Utils.checkForRemainingOptions(options);
}","/** 
 * Parses a given list of options. <!-- options-start --> <p> Valid options are: </p> <pre> -I &lt;number of trees&gt; Number of trees to build.</pre> <pre> -K &lt;number of features&gt; Number of features to consider (&lt;1=int(logM+1)).</pre> <pre> -S Seed for random number generator. (default 1)</pre> <pre> -depth &lt;num&gt; The maximum depth of the trees, 0 for unlimited. (default 0)</pre> <pre> -threads Number of simultaneous threads to use. (default 0 = autodetect number of available cores)</pre> <pre> -import Compute and output RF feature importances (slow).</pre> <pre> -D If set, classifier is run in debug mode and may output additional info to the console</pre> <!-- options-end -->
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
public void setOptions(String[] options) throws Exception {
  String tmpStr;
  tmpStr=Utils.getOption('I',options);
  if (tmpStr.length() != 0) {
    m_numTrees=Integer.parseInt(tmpStr);
  }
 else {
    m_numTrees=10;
  }
  tmpStr=Utils.getOption('K',options);
  if (tmpStr.length() != 0) {
    m_numFeatures=Integer.parseInt(tmpStr);
  }
 else {
    m_numFeatures=0;
  }
  tmpStr=Utils.getOption('S',options);
  if (tmpStr.length() != 0) {
    setSeed(Integer.parseInt(tmpStr));
  }
 else {
    setSeed(1);
  }
  tmpStr=Utils.getOption(""String_Node_Str"",options);
  if (tmpStr.length() != 0) {
    setMaxDepth(Integer.parseInt(tmpStr));
  }
 else {
    setMaxDepth(0);
  }
  tmpStr=Utils.getOption(""String_Node_Str"",options);
  if (tmpStr.length() != 0) {
    setNumThreads(Integer.parseInt(tmpStr));
  }
 else {
    setNumThreads(0);
  }
  setComputeImportances(Utils.getFlag(""String_Node_Str"",options));
  super.setOptions(options);
  Utils.checkForRemainingOptions(options);
}",0.9846575342465752
22694,"/** 
 * Parses a given list of options. <p/> <p/> <!-- options-start --> Valid options are: <p/> <p/> <pre> -P Size of each bag, as a percentage of the training set size. (default 100)</pre> <p/> <pre> -O Calculate the out of bag error.</pre> <p/> <pre> -S &lt;num&gt; Random number seed. (default 1)</pre> <p/> <pre> -I &lt;num&gt; Number of iterations. (default 10)</pre> <p/> <pre> -D If set, classifier is run in debug mode and may output additional info to the console</pre> <p/> <pre> -W Full name of base classifier. (default: fastRandomForest.classifiers.FastRandomTree)</pre> <p/> <!-- options-end --> <p/> Options after -- are passed to the designated classifier.<p>
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
@Override public void setOptions(String[] options) throws Exception {
  String bagSize=Utils.getOption('P',options);
  if (bagSize.length() != 0) {
    setBagSizePercent(Integer.parseInt(bagSize));
  }
 else {
    setBagSizePercent(100);
  }
  setCalcOutOfBag(Utils.getFlag('O',options));
  super.setOptions(options);
}","/** 
 * Parses a given list of options. <!-- options-start --> <p> Valid options are: </p> <pre> -P Size of each bag, as a percentage of the training set size. (default 100)</pre> <pre> -O Calculate the out of bag error.</pre> <pre> -S &lt;num&gt; Random number seed. (default 1)</pre> <pre> -I &lt;num&gt; Number of iterations. (default 10)</pre> <pre> -D If set, classifier is run in debug mode and may output additional info to the console</pre> <pre> -W Full name of base classifier. (default: fastRandomForest.classifiers.FastRandomTree)</pre> <!-- options-end --> <p> Options after -- are passed to the designated classifier. </p>
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
@Override public void setOptions(String[] options) throws Exception {
  String bagSize=Utils.getOption('P',options);
  if (bagSize.length() != 0) {
    setBagSizePercent(Integer.parseInt(bagSize));
  }
 else {
    setBagSizePercent(100);
  }
  setCalcOutOfBag(Utils.getFlag('O',options));
  super.setOptions(options);
}",0.7362637362637363
22695,"/** 
 * Normalizes the doubles in the array using the given value. <p/> If supplied an array full of zeroes, does not modify the array.
 * @param doubles the array of double
 * @param sum     the value by which the doubles are to be normalized
 * @throws IllegalArgumentException if sum is zero or NaN
 */
private static void normalize(double[] doubles,double sum){
  if (Double.isNaN(sum)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sum == 0) {
    return;
  }
  for (int i=0; i < doubles.length; i++) {
    doubles[i]/=sum;
  }
}","/** 
 * Normalizes the doubles in the array using the given value. <p> If supplied an array full of zeroes, does not modify the array. </p>
 * @param doubles the array of double
 * @param sum     the value by which the doubles are to be normalized
 * @throws IllegalArgumentException if sum is zero or NaN
 */
private static void normalize(double[] doubles,double sum){
  if (Double.isNaN(sum)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sum == 0) {
    return;
  }
  for (int i=0; i < doubles.length; i++) {
    doubles[i]/=sum;
  }
}",0.9946524064171124
22696,"/** 
 * Produces a random permutation of the values of an attribute in a dataset using Knuth shuffle. <p/> Copies back the current values of the previously scrambled attribute and uses the given permutation to scramble the values of the new attribute all by copying from the original dataset.
 * @param src      the source dataset
 * @param dst      the scrambled dataset
 * @param attIndex the attribute index
 * @param perm     the random permutation
 * @return fluent
 */
public static Instances scramble(Instances src,Instances dst,final int attIndex,int[] perm){
  for (int i=0; i < src.numInstances(); i++) {
    Instance scrambled=dst.instance(i);
    if (attIndex > 0)     scrambled.setValue(attIndex - 1,src.instance(i).value(attIndex - 1));
    scrambled.setValue(attIndex,src.instance(perm[i]).value(attIndex));
  }
  return dst;
}","/** 
 * Produces a random permutation of the values of an attribute in a dataset using Knuth shuffle. <p> Copies back the current values of the previously scrambled attribute and uses the given permutation to scramble the values of the new attribute all by copying from the original dataset. </p>
 * @param src      the source dataset
 * @param dst      the scrambled dataset
 * @param attIndex the attribute index
 * @param perm     the random permutation
 * @return fluent
 */
public static Instances scramble(Instances src,Instances dst,final int attIndex,int[] perm){
  for (int i=0; i < src.numInstances(); i++) {
    Instance scrambled=dst.instance(i);
    if (attIndex > 0)     scrambled.setValue(attIndex - 1,src.instance(i).value(attIndex - 1));
    scrambled.setValue(attIndex,src.instance(perm[i]).value(attIndex));
  }
  return dst;
}",0.7772511848341233
22697,"/** 
 * Get a specific label of the reference stack
 * @param index slice index (>=1)
 * @return label name
 */
public String getLabel(int index){
  if (referenceStackIndex == -1)   return null;
  return featureStackArray[referenceStackIndex].getSliceLabel(index);
}","/** 
 * Get a specific label of the reference stack
 * @param index slice index (&gt;=1)
 * @return label name
 */
public String getLabel(int index){
  if (referenceStackIndex == -1)   return null;
  return featureStackArray[referenceStackIndex].getSliceLabel(index);
}",0.9906542056074766
22698,"/** 
 * Get n-th stack in the array (remember n>=0)
 * @param n position of the stack to get
 * @return feature stack of the corresponding slice
 */
public FeatureStack get(int n){
  return featureStackArray[n];
}","/** 
 * Get n-th stack in the array (remember n&gt;=0)
 * @param n position of the stack to get
 * @return feature stack of the corresponding slice
 */
public FeatureStack get(int n){
  return featureStackArray[n];
}",0.9883449883449884
22699,"/** 
 * Set the current number of classes. Should not be used to create new classes. Use <link>addClass<\link> instead.
 * @param numOfClasses the new number of classes
 */
public void setNumOfClasses(int numOfClasses){
  this.numOfClasses=numOfClasses;
}","/** 
 * Set the current number of classes. Should not be used to create new classes. Use   {@link #addClass} instead.
 * @param numOfClasses the new number of classes
 */
public void setNumOfClasses(int numOfClasses){
  this.numOfClasses=numOfClasses;
}",0.937007874015748
22700,"/** 
 * Get current feature stack
 * @param i number of feature stack slice (>=1)
 * @return feature stack of the corresponding slice
 */
public FeatureStack getFeatureStack(int i){
  return this.featureStackArray.get(i - 1);
}","/** 
 * Get current feature stack
 * @param i number of feature stack slice (&gt;=1)
 * @return feature stack of the corresponding slice
 */
public FeatureStack getFeatureStack(int i){
  return this.featureStackArray.get(i - 1);
}",0.9890590809628008
22701,"/** 
 * Computes topological numbers for the central point of an image patch. These numbers can be used as the basis of a topological classification. T_4 and T_8 are used when IM is a 2d image patch of size 3x3 defined on p. 172 of Bertrand & Malandain, Patt. Recog. Lett. 15, 169-75 (1994).
 * @param im input image
 * @param adjacency number of neighbors
 * @return number of components in the patch excluding the center pixel
 */
public int topo(final ImagePlus im,final int adjacency){
  ImageProcessor components=null;
  final ImagePlus im2=new ImagePlus(""String_Node_Str"",im.getProcessor().duplicate());
switch (adjacency) {
case 4:
    if (im.getStack().getSize() > 1) {
      IJ.error(""String_Node_Str"");
      return -1;
    }
  if (im.getProcessor().getWidth() > 3 || im.getProcessor().getHeight() > 3) {
    IJ.error(""String_Node_Str"");
    return -1;
  }
im2.getProcessor().set(1,1,0);
components=Utils.connectedComponents(im2,adjacency).allRegions.getProcessor();
components.set(0,0,0);
components.set(0,2,0);
components.set(1,1,0);
components.set(2,0,0);
components.set(2,2,0);
break;
case 8:
if (im.getStack().getSize() > 1) {
IJ.error(""String_Node_Str"");
return -1;
}
if (im.getProcessor().getWidth() > 3 || im.getProcessor().getHeight() > 3) {
IJ.error(""String_Node_Str"");
return -1;
}
im2.getProcessor().set(1,1,0);
components=Utils.connectedComponents(im2,adjacency).allRegions.getProcessor();
break;
default :
IJ.error(""String_Node_Str"");
return -1;
}
if (null == components) return -1;
int t=0;
ArrayList<Integer> uniqueId=new ArrayList<Integer>();
for (int i=0; i < 3; i++) for (int j=0; j < 3; j++) {
if ((t=components.get(i,j)) != 0 && !uniqueId.contains(t)) {
uniqueId.add(t);
}
}
return uniqueId.size();
}","/** 
 * Computes topological numbers for the central point of an image patch. These numbers can be used as the basis of a topological classification. T_4 and T_8 are used when IM is a 2d image patch of size 3x3 defined on p. 172 of Bertrand &amp; Malandain, Patt. Recog. Lett. 15, 169-75 (1994).
 * @param im input image
 * @param adjacency number of neighbors
 * @return number of components in the patch excluding the center pixel
 */
public int topo(final ImagePlus im,final int adjacency){
  ImageProcessor components=null;
  final ImagePlus im2=new ImagePlus(""String_Node_Str"",im.getProcessor().duplicate());
switch (adjacency) {
case 4:
    if (im.getStack().getSize() > 1) {
      IJ.error(""String_Node_Str"");
      return -1;
    }
  if (im.getProcessor().getWidth() > 3 || im.getProcessor().getHeight() > 3) {
    IJ.error(""String_Node_Str"");
    return -1;
  }
im2.getProcessor().set(1,1,0);
components=Utils.connectedComponents(im2,adjacency).allRegions.getProcessor();
components.set(0,0,0);
components.set(0,2,0);
components.set(1,1,0);
components.set(2,0,0);
components.set(2,2,0);
break;
case 8:
if (im.getStack().getSize() > 1) {
IJ.error(""String_Node_Str"");
return -1;
}
if (im.getProcessor().getWidth() > 3 || im.getProcessor().getHeight() > 3) {
IJ.error(""String_Node_Str"");
return -1;
}
im2.getProcessor().set(1,1,0);
components=Utils.connectedComponents(im2,adjacency).allRegions.getProcessor();
break;
default :
IJ.error(""String_Node_Str"");
return -1;
}
if (null == components) return -1;
int t=0;
ArrayList<Integer> uniqueId=new ArrayList<Integer>();
for (int i=0; i < 3; i++) for (int j=0; j < 3; j++) {
if ((t=components.get(i,j)) != 0 && !uniqueId.contains(t)) {
uniqueId.add(t);
}
}
return uniqueId.size();
}",0.9988459319099828
22702,"/** 
 * Extract pixel values from input image such that they have value h, hMin <= h <= hMax.
 * @param inputImage input image
 * @param hMin minimum grayscale height value
 * @param hMax maximum grayscale height value
 * @return list of input pixel values
 */
public ArrayList<PixelRecord> extractPixelValues(final ImageProcessor inputImage,final double hMin,final double hMax){
  final int size1=inputImage.getWidth();
  final int size2=inputImage.getHeight();
  final ArrayList<PixelRecord> list=new ArrayList<PixelRecord>();
  for (int x=0; x < size1; ++x)   for (int y=0; y < size2; ++y) {
    final double h=inputImage.getf(x,y);
    if (h >= hMin && h <= hMax)     list.add(new PixelRecord(x,y,h));
  }
  return list;
}","/** 
 * Extract pixel values from input image such that they have value h, hMin &lt;= h &lt;= hMax.
 * @param inputImage input image
 * @param hMin minimum grayscale height value
 * @param hMax maximum grayscale height value
 * @return list of input pixel values
 */
public ArrayList<PixelRecord> extractPixelValues(final ImageProcessor inputImage,final double hMin,final double hMax){
  final int size1=inputImage.getWidth();
  final int size2=inputImage.getHeight();
  final ArrayList<PixelRecord> list=new ArrayList<PixelRecord>();
  for (int x=0; x < size1; ++x)   for (int y=0; y < size2; ++y) {
    final double h=inputImage.getf(x,y);
    if (h >= hMin && h <= hMax)     list.add(new PixelRecord(x,y,h));
  }
  return list;
}",0.9876543209876544
22703,"/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final String[] availableFeatures=isProcessing3D ? FeatureStack3D.availableFeatures : FeatureStack.availableFeatures;
  final int numFeatures=availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(availableFeatures[i])) {
        usedFeatures[i]=true;
        String[] tokens;
        float sigma;
        if (!isProcessing3D) {
switch (i) {
case FeatureStack.MEMBRANE:
            int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
        final int patchSize=Integer.parseInt(a.name().substring(index,index2));
      if (patchSize != membranePatchSize) {
        membranePatchSize=patchSize;
        if (null != featureStackArray)         featureStackArray.setMembranePatchSize(patchSize);
        featuresChanged=true;
      }
    index=a.name().lastIndexOf(""String_Node_Str"");
  final int thickness=Integer.parseInt(a.name().substring(index + 1));
if (thickness != membraneThickness) {
  membraneThickness=thickness;
  if (null != featureStackArray)   featureStackArray.setMembraneSize(thickness);
  featuresChanged=true;
}
break;
case FeatureStack.KUWAHARA:
tokens=a.name().split(""String_Node_Str"");
membranePatchSize=Integer.parseInt(tokens[1]);
break;
case FeatureStack.NEIGHBORS:
case FeatureStack.ENTROPY:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[1]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.ANISOTROPIC_DIFFUSION:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[3]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.BILATERAL:
case FeatureStack.LIPSCHITZ:
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
 else {
switch (i) {
case FeatureStack3D.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
}
}
}
IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
if (!isProcessing3D) IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
if (minSigma != this.minimumSigma && minSigma != 0) {
this.minimumSigma=minSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMinimumSigma(minSigma);
if (isProcessing3D) this.fs3d.setMinimumSigma(minSigma);
}
if (maxSigma != this.maximumSigma) {
this.maximumSigma=maxSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMaximumSigma(maxSigma);
if (isProcessing3D) this.fs3d.setMaximumSigma(maxSigma);
}
Attribute classAttribute=data.classAttribute();
Enumeration<Object> classValues=classAttribute.enumerateValues();
loadedClassNames=new ArrayList<String>();
int j=0;
setNumOfClasses(0);
while (classValues.hasMoreElements()) {
final String className=((String)classValues.nextElement()).trim();
loadedClassNames.add(className);
}
for (String className : loadedClassNames) {
IJ.log(""String_Node_Str"" + className);
setClassLabel(j,className);
addClass();
j++;
}
if (null != featureStackArray) {
final boolean[] oldEnableFeatures=isProcessing3D ? fs3d.getEnabledFeatures() : this.featureStackArray.getEnabledFeatures();
for (int i=0; i < numFeatures; i++) {
if (usedFeatures[i] != oldEnableFeatures[i]) featuresChanged=true;
}
}
 else featuresChanged=true;
if (featuresChanged) {
this.setEnabledFeatures(usedFeatures);
updateFeatures=true;
}
return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final String[] availableFeatures=isProcessing3D ? FeatureStack3D.availableFeatures : FeatureStack.availableFeatures;
  final int numFeatures=availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(availableFeatures[i])) {
        usedFeatures[i]=true;
        String[] tokens;
        float sigma;
        if (!isProcessing3D) {
switch (i) {
case FeatureStack.MEMBRANE:
            int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
        final int patchSize=Integer.parseInt(a.name().substring(index,index2));
      if (patchSize != membranePatchSize) {
        membranePatchSize=patchSize;
        if (null != featureStackArray)         featureStackArray.setMembranePatchSize(patchSize);
        featuresChanged=true;
      }
    index=a.name().lastIndexOf(""String_Node_Str"");
  final int thickness=Integer.parseInt(a.name().substring(index + 1));
if (thickness != membraneThickness) {
  membraneThickness=thickness;
  if (null != featureStackArray)   featureStackArray.setMembraneSize(thickness);
  featuresChanged=true;
}
break;
case FeatureStack.KUWAHARA:
tokens=a.name().split(""String_Node_Str"");
membranePatchSize=Integer.parseInt(tokens[1]);
break;
case FeatureStack.NEIGHBORS:
case FeatureStack.ENTROPY:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[1]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.GABOR:
case FeatureStack.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.ANISOTROPIC_DIFFUSION:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[3]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.BILATERAL:
case FeatureStack.LIPSCHITZ:
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
 else {
switch (i) {
case FeatureStack3D.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
}
}
}
IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
if (!isProcessing3D) IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
if (minSigma != this.minimumSigma && minSigma != 0) {
this.minimumSigma=minSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMinimumSigma(minSigma);
if (isProcessing3D) this.fs3d.setMinimumSigma(minSigma);
}
if (maxSigma != this.maximumSigma) {
this.maximumSigma=maxSigma;
featuresChanged=true;
if (null != featureStackArray) featureStackArray.setMaximumSigma(maxSigma);
if (isProcessing3D) this.fs3d.setMaximumSigma(maxSigma);
}
Attribute classAttribute=data.classAttribute();
Enumeration<Object> classValues=classAttribute.enumerateValues();
loadedClassNames=new ArrayList<String>();
int j=0;
setNumOfClasses(0);
while (classValues.hasMoreElements()) {
final String className=((String)classValues.nextElement()).trim();
loadedClassNames.add(className);
}
for (String className : loadedClassNames) {
IJ.log(""String_Node_Str"" + className);
setClassLabel(j,className);
addClass();
j++;
}
if (null != featureStackArray) {
final boolean[] oldEnableFeatures=isProcessing3D ? fs3d.getEnabledFeatures() : this.featureStackArray.getEnabledFeatures();
for (int i=0; i < numFeatures; i++) {
if (usedFeatures[i] != oldEnableFeatures[i]) featuresChanged=true;
}
}
 else featuresChanged=true;
if (featuresChanged) {
this.setEnabledFeatures(usedFeatures);
updateFeatures=true;
}
return true;
}",0.9973769803798131
22704,"/** 
 * Add training samples from a ShapeRoi
 * @param trainingData set of instances to add to
 * @param classIndex class index value
 * @param sliceNum number of 2d slice being processed
 * @param r shape roi
 * @return number of instances added
 */
private int addShapeRoiInstances(final Instances trainingData,int classIndex,int sliceNum,Roi r){
  int numInstances=0;
  final ShapeRoi shapeRoi=new ShapeRoi(r);
  final Rectangle rect=shapeRoi.getBounds();
  final int lastX=rect.x + rect.width;
  final int lastY=rect.y + rect.height;
  final FeatureStack fs=featureStackArray.get(sliceNum - 1);
  for (int x=rect.x; x < lastX; x++)   for (int y=rect.y; y < lastY; y++)   if (shapeRoi.contains(x,y)) {
    trainingData.add(fs.createInstance(x,y,classIndex));
    numInstances++;
  }
  return numInstances;
}","/** 
 * Add training samples from a ShapeRoi
 * @param trainingData set of instances to add to
 * @param classIndex class index value
 * @param sliceNum number of 2d slice being processed
 * @param r shape roi
 * @return number of instances added
 */
private int addShapeRoiInstances(final Instances trainingData,int classIndex,int sliceNum,Roi r){
  int numInstances=0;
  final ShapeRoi shapeRoi=new ShapeRoi(r);
  final Rectangle rect=shapeRoi.getBounds();
  int lastX=rect.x + rect.width;
  if (lastX >= trainingImage.getWidth())   lastX=trainingImage.getWidth() - 1;
  int lastY=rect.y + rect.height;
  if (lastY >= trainingImage.getHeight())   lastY=trainingImage.getHeight() - 1;
  int firstX=Math.max(rect.x,0);
  int firstY=Math.max(rect.y,0);
  final FeatureStack fs=featureStackArray.get(sliceNum - 1);
  for (int x=firstX; x < lastX; x++)   for (int y=firstY; y < lastY; y++)   if (shapeRoi.contains(x,y)) {
    trainingData.add(fs.createInstance(x,y,classIndex));
    numInstances++;
  }
  return numInstances;
}",0.8582333696837514
22705,"/** 
 * Apply classifier to test data. As it is implemented right now,  it will use one thread per input image and slice. 
 */
public void applyClassifierToTestData(){
  File[] imageFiles;
  String storeDir=""String_Node_Str"";
  String dir=OpenDialog.getLastDirectory();
  if (null == dir)   dir=OpenDialog.getDefaultDirectory();
  JFileChooser fileChooser=new JFileChooser(dir);
  fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  fileChooser.setMultiSelectionEnabled(true);
  int returnVal=fileChooser.showOpenDialog(null);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    imageFiles=fileChooser.getSelectedFiles();
    OpenDialog.setLastDirectory(imageFiles[0].getParent());
  }
 else {
    return;
  }
  boolean showResults=true;
  boolean storeResults=false;
  if (imageFiles.length >= 3) {
    int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
    if (decision == JOptionPane.YES_OPTION) {
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setMultiSelectionEnabled(false);
      returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        storeDir=fileChooser.getSelectedFile().getPath();
      }
 else {
        return;
      }
      showResults=false;
      storeResults=true;
    }
  }
  final boolean probabilityMaps;
  int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
  if (decision == JOptionPane.YES_OPTION)   probabilityMaps=true;
 else   probabilityMaps=false;
  final int numProcessors=Prefs.getThreads();
  final int numThreads=Math.min(imageFiles.length,numProcessors);
  final int numFurtherThreads=(int)Math.ceil((double)(numProcessors - numThreads) / imageFiles.length) + 1;
  IJ.log(""String_Node_Str"" + imageFiles.length + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  win.setButtonsEnabled(false);
  Thread[] threads=new Thread[numThreads];
class ImageProcessingThread extends Thread {
    private final int numThread;
    private final int numThreads;
    private final File[] imageFiles;
    private final boolean storeResults;
    private final boolean showResults;
    private final String storeDir;
    public ImageProcessingThread(    int numThread,    int numThreads,    File[] imageFiles,    boolean storeResults,    boolean showResults,    String storeDir){
      this.numThread=numThread;
      this.numThreads=numThreads;
      this.imageFiles=imageFiles;
      this.storeResults=storeResults;
      this.showResults=showResults;
      this.storeDir=storeDir;
    }
    public void run(){
      for (int i=numThread; i < imageFiles.length; i+=numThreads) {
        File file=imageFiles[i];
        ImagePlus testImage=IJ.openImage(file.getPath());
        if (null == testImage) {
          IJ.log(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
          IJ.error(""String_Node_Str"",""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
          return;
        }
        IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ numThread);
        ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,numFurtherThreads,probabilityMaps);
        if (showResults && null != segmentation) {
          if (!probabilityMaps) {
            convertTo8bitNoScaling(segmentation);
            segmentation.getProcessor().setColorModel(overlayLUT);
            segmentation.getImageStack().setColorModel(overlayLUT);
            segmentation.updateAndDraw();
          }
          segmentation.show();
          testImage.show();
        }
        if (storeResults) {
          String filename=storeDir + File.separator + file.getName();
          IJ.log(""String_Node_Str"" + filename);
          IJ.save(segmentation,filename);
          segmentation.close();
          testImage.close();
        }
      }
    }
  }
  for (int i=0; i < numThreads; i++) {
    threads[i]=new ImageProcessingThread(i,numThreads,imageFiles,storeResults,showResults,storeDir);
    String[] arg=new String[]{imageFiles[i].getParent(),imageFiles[i].getName(),""String_Node_Str"" + showResults,""String_Node_Str"" + storeResults,""String_Node_Str"" + probabilityMaps,storeDir};
    record(APPLY_CLASSIFIER,arg);
    threads[i].start();
  }
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  win.updateButtonsEnabling();
}","/** 
 * Apply classifier to test data. As it is implemented right now,  it will use one thread per input image and slice. 
 */
public void applyClassifierToTestData(){
  File[] imageFiles;
  String storeDir=""String_Node_Str"";
  String dir=OpenDialog.getLastDirectory();
  if (null == dir)   dir=OpenDialog.getDefaultDirectory();
  JFileChooser fileChooser=new JFileChooser(dir);
  fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  fileChooser.setMultiSelectionEnabled(true);
  int returnVal=fileChooser.showOpenDialog(null);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    imageFiles=fileChooser.getSelectedFiles();
    OpenDialog.setLastDirectory(imageFiles[0].getParent());
  }
 else {
    return;
  }
  boolean showResults=true;
  boolean storeResults=false;
  if (imageFiles.length >= 3) {
    int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
    if (decision == JOptionPane.YES_OPTION) {
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setMultiSelectionEnabled(false);
      returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        storeDir=fileChooser.getSelectedFile().getPath();
      }
 else {
        return;
      }
      showResults=false;
      storeResults=true;
    }
  }
  final boolean probabilityMaps;
  int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
  if (decision == JOptionPane.YES_OPTION)   probabilityMaps=true;
 else   probabilityMaps=false;
  final int numProcessors=Prefs.getThreads();
  final int numThreads=Math.min(imageFiles.length,numProcessors);
  final int numFurtherThreads=(int)Math.ceil((double)(numProcessors - numThreads) / imageFiles.length) + 1;
  IJ.log(""String_Node_Str"" + imageFiles.length + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  win.setButtonsEnabled(false);
  Thread[] threads=new Thread[numThreads];
class ImageProcessingThread extends Thread {
    private final int numThread;
    private final int numThreads;
    private final File[] imageFiles;
    private final boolean storeResults;
    private final boolean showResults;
    private final String storeDir;
    public ImageProcessingThread(    int numThread,    int numThreads,    File[] imageFiles,    boolean storeResults,    boolean showResults,    String storeDir){
      this.numThread=numThread;
      this.numThreads=numThreads;
      this.imageFiles=imageFiles;
      this.storeResults=storeResults;
      this.showResults=showResults;
      this.storeDir=storeDir;
    }
    public void run(){
      for (int i=numThread; i < imageFiles.length; i+=numThreads) {
        File file=imageFiles[i];
        ImagePlus testImage=IJ.openImage(file.getPath());
        if (null == testImage) {
          IJ.log(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
          IJ.error(""String_Node_Str"",""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
          return;
        }
        IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ numThread);
        final ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,numFurtherThreads,probabilityMaps);
        if (null == segmentation) {
          IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ ""String_Node_Str"");
          return;
        }
        if (!probabilityMaps) {
          convertTo8bitNoScaling(segmentation);
          segmentation.getProcessor().setColorModel(overlayLUT);
          segmentation.getImageStack().setColorModel(overlayLUT);
          segmentation.updateAndDraw();
        }
        if (showResults) {
          segmentation.show();
          testImage.show();
        }
 else         if (storeResults) {
          String filename=storeDir + File.separator + file.getName();
          IJ.log(""String_Node_Str"" + filename);
          IJ.save(segmentation,filename);
          segmentation.close();
          testImage.close();
        }
      }
    }
  }
  for (int i=0; i < numThreads; i++) {
    threads[i]=new ImageProcessingThread(i,numThreads,imageFiles,storeResults,showResults,storeDir);
    String[] arg=new String[]{imageFiles[i].getParent(),imageFiles[i].getName(),""String_Node_Str"" + showResults,""String_Node_Str"" + storeResults,""String_Node_Str"" + probabilityMaps,storeDir};
    record(APPLY_CLASSIFIER,arg);
    threads[i].start();
  }
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  win.updateButtonsEnabling();
}",0.9752175349708118
22706,"/** 
 * Update buttons enabling depending on the current status of the plugin
 */
protected void updateButtonsEnabling(){
  if (trainingFlag) {
    setButtonsEnabled(false);
    trainButton.setEnabled(true);
  }
 else {
    final boolean classifierExists=null != wekaSegmentation.getClassifier();
    trainButton.setEnabled(classifierExists);
    applyButton.setEnabled(win.trainingComplete);
    final boolean resultExists=null != classifiedImage && null != classifiedImage.getProcessor();
    saveClassifierButton.setEnabled(win.trainingComplete);
    overlayButton.setEnabled(resultExists);
    resultButton.setEnabled(win.trainingComplete);
    plotButton.setEnabled(win.trainingComplete);
    probabilityButton.setEnabled(win.trainingComplete);
    loadClassifierButton.setEnabled(true);
    loadDataButton.setEnabled(true);
    addClassButton.setEnabled(wekaSegmentation.getNumOfClasses() < WekaSegmentation.MAX_NUM_CLASSES);
    settingsButton.setEnabled(true);
    wekaButton.setEnabled(true);
    boolean examplesEmpty=true;
    for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)     if (exampleList[i].getItemCount() > 0) {
      examplesEmpty=false;
      break;
    }
    boolean loadedTrainingData=null != wekaSegmentation.getLoadedTrainingData();
    saveDataButton.setEnabled(!examplesEmpty || loadedTrainingData);
    for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
      exampleList[i].setEnabled(true);
      addExampleButton[i].setEnabled(true);
    }
    setSliceSelectorEnabled(true);
  }
}","/** 
 * Update buttons enabling depending on the current status of the plugin
 */
protected void updateButtonsEnabling(){
  if (trainingFlag) {
    setButtonsEnabled(false);
    trainButton.setEnabled(true);
  }
 else {
    final boolean classifierExists=null != wekaSegmentation.getClassifier();
    trainButton.setEnabled(classifierExists);
    applyButton.setEnabled(win.trainingComplete);
    final boolean resultExists=null != classifiedImage && null != classifiedImage.getProcessor();
    saveClassifierButton.setEnabled(win.trainingComplete);
    overlayButton.setEnabled(resultExists);
    resultButton.setEnabled(win.trainingComplete);
    plotButton.setEnabled(win.trainingComplete);
    probabilityButton.setEnabled(win.trainingComplete);
    loadClassifierButton.setEnabled(true);
    loadDataButton.setEnabled(true);
    addClassButton.setEnabled(wekaSegmentation.getNumOfClasses() < WekaSegmentation.MAX_NUM_CLASSES);
    settingsButton.setEnabled(true);
    wekaButton.setEnabled(true);
    boolean examplesEmpty=true;
    for (int n=1; n <= displayImage.getImageStackSize(); n++)     for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)     if (wekaSegmentation.getExamples(i,n).size() > 0) {
      examplesEmpty=false;
      break;
    }
    boolean loadedTrainingData=null != wekaSegmentation.getLoadedTrainingData();
    saveDataButton.setEnabled(!examplesEmpty || loadedTrainingData);
    for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
      exampleList[i].setEnabled(true);
      addExampleButton[i].setEnabled(true);
    }
    setSliceSelectorEnabled(true);
  }
}",0.9633407714376792
22707,"/** 
 * Apply current classifier to specific image (2D or stack)
 * @param dir input image directory path
 * @param fileName input image name
 * @param showResultsFlag string containing the boolean flag to display results
 * @param storeResultsFlag string containing the boolean flag to store result in a directory
 * @param probabilityMapsFlag string containing the boolean flag to calculate probabilities instead of a binary result
 * @param storeDir directory to store the results
 */
public static void applyClassifier(String dir,String fileName,String showResultsFlag,String storeResultsFlag,String probabilityMapsFlag,String storeDir){
  final ImageWindow iw=WindowManager.getCurrentImage().getWindow();
  if (iw instanceof CustomWindow) {
    final CustomWindow win=(CustomWindow)iw;
    final WekaSegmentation wekaSegmentation=win.getWekaSegmentation();
    ImagePlus testImage=IJ.openImage(dir + File.separator + fileName);
    if (null == testImage) {
      IJ.log(""String_Node_Str"" + dir + File.separator+ fileName+ ""String_Node_Str"");
      return;
    }
    boolean probabilityMaps=probabilityMapsFlag.contains(""String_Node_Str"");
    boolean storeResults=storeResultsFlag.contains(""String_Node_Str"");
    boolean showResults=showResultsFlag.contains(""String_Node_Str"");
    IJ.log(""String_Node_Str"" + dir + File.separator+ fileName);
    ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,0,probabilityMaps);
    convertTo8bitNoScaling(segmentation);
    segmentation.getProcessor().setColorModel(win.getOverlayLUT());
    segmentation.getImageStack().setColorModel(win.getOverlayLUT());
    segmentation.updateAndDraw();
    if (showResults) {
      segmentation.show();
      testImage.show();
    }
    if (storeResults) {
      String filename=storeDir + File.separator + fileName;
      IJ.log(""String_Node_Str"" + filename);
      IJ.save(segmentation,filename);
      segmentation.close();
      testImage.close();
    }
  }
}","/** 
 * Apply current classifier to specific image (2D or stack)
 * @param dir input image directory path
 * @param fileName input image name
 * @param showResultsFlag string containing the boolean flag to display results
 * @param storeResultsFlag string containing the boolean flag to store result in a directory
 * @param probabilityMapsFlag string containing the boolean flag to calculate probabilities instead of a binary result
 * @param storeDir directory to store the results
 */
public static void applyClassifier(String dir,String fileName,String showResultsFlag,String storeResultsFlag,String probabilityMapsFlag,String storeDir){
  final ImageWindow iw=WindowManager.getCurrentImage().getWindow();
  if (iw instanceof CustomWindow) {
    final CustomWindow win=(CustomWindow)iw;
    final WekaSegmentation wekaSegmentation=win.getWekaSegmentation();
    ImagePlus testImage=IJ.openImage(dir + File.separator + fileName);
    if (null == testImage) {
      IJ.log(""String_Node_Str"" + dir + File.separator+ fileName+ ""String_Node_Str"");
      return;
    }
    boolean probabilityMaps=probabilityMapsFlag.contains(""String_Node_Str"");
    boolean storeResults=storeResultsFlag.contains(""String_Node_Str"");
    boolean showResults=showResultsFlag.contains(""String_Node_Str"");
    IJ.log(""String_Node_Str"" + dir + File.separator+ fileName);
    ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,0,probabilityMaps);
    if (!probabilityMaps) {
      convertTo8bitNoScaling(segmentation);
      segmentation.getProcessor().setColorModel(win.getOverlayLUT());
      segmentation.getImageStack().setColorModel(win.getOverlayLUT());
      segmentation.updateAndDraw();
    }
    if (showResults) {
      segmentation.show();
      testImage.show();
    }
    if (storeResults) {
      String filename=storeDir + File.separator + fileName;
      IJ.log(""String_Node_Str"" + filename);
      IJ.save(segmentation,filename);
      segmentation.close();
      testImage.close();
    }
  }
}",0.989404641775984
22708,"/** 
 * Train classifier with the current instances
 */
public boolean trainClassifier(){
  if (Thread.currentThread().isInterrupted()) {
    IJ.log(""String_Node_Str"");
    return false;
  }
  int nonEmpty=0;
  int sliceWithTraces=-1;
  for (int i=0; i < numOfClasses; i++)   for (int j=0; j < trainingImage.getImageStackSize(); j++)   if (examples[j].get(i).size() > 0) {
    nonEmpty++;
    sliceWithTraces=i + 1;
    break;
  }
  if (nonEmpty < 2 && null == loadedTrainingData) {
    IJ.showMessage(""String_Node_Str"");
    return false;
  }
  if (nonEmpty > 1 && featureStackArray.isEmpty() || updateFeatures) {
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    long start=System.currentTimeMillis();
    featureStackArray.setReference(sliceWithTraces);
    if (false == featureStackArray.updateFeaturesMT(featureStackToUpdateTrain)) {
      IJ.log(""String_Node_Str"");
      IJ.showStatus(""String_Node_Str"");
      return false;
    }
    Arrays.fill(featureStackToUpdateTrain,false);
    filterFeatureStackByList();
    updateFeatures=false;
    long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + featureStackArray.getSize() + ""String_Node_Str""+ featureStackArray.getNumOfFeatures()+ ""String_Node_Str""+ (end - start)+ ""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  Instances data=null;
  if (nonEmpty < 1)   IJ.log(""String_Node_Str"");
 else {
    final long start=System.currentTimeMillis();
    traceTrainingData=data=createTrainingInstances();
    final long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  if (loadedTrainingData != null && data != null) {
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++)     data.add(loadedTrainingData.instance(i));
    IJ.log(""String_Node_Str"" + data.numInstances());
  }
 else   if (data == null) {
    data=loadedTrainingData;
    IJ.log(""String_Node_Str"");
  }
  if (null == data) {
    IJ.log(""String_Node_Str"");
  }
  this.trainHeader=new Instances(data,0);
  if (homogenizeClasses) {
    final long start=System.currentTimeMillis();
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    data=homogenizeTrainingData(data);
    final long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  if (Thread.currentThread().isInterrupted()) {
    IJ.log(""String_Node_Str"");
    return false;
  }
  final long start=System.currentTimeMillis();
  try {
    classifier.buildClassifier(data);
  }
 catch (  InterruptedException ie) {
    IJ.log(""String_Node_Str"");
    return false;
  }
catch (  Exception e) {
    IJ.showMessage(e.getMessage());
    e.printStackTrace();
    return false;
  }
  IJ.log(this.classifier.toString());
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return true;
}","/** 
 * Train classifier with the current instances
 */
public boolean trainClassifier(){
  if (Thread.currentThread().isInterrupted()) {
    IJ.log(""String_Node_Str"");
    return false;
  }
  int nonEmpty=0;
  int sliceWithTraces=-1;
  for (int i=0; i < numOfClasses; i++)   for (int j=0; j < trainingImage.getImageStackSize(); j++)   if (examples[j].get(i).size() > 0) {
    nonEmpty++;
    sliceWithTraces=j;
    break;
  }
  if (nonEmpty < 2 && null == loadedTrainingData) {
    IJ.showMessage(""String_Node_Str"");
    return false;
  }
  if (nonEmpty > 1 && featureStackArray.isEmpty() || updateFeatures) {
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    long start=System.currentTimeMillis();
    featureStackArray.setReference(sliceWithTraces);
    if (false == featureStackArray.updateFeaturesMT(featureStackToUpdateTrain)) {
      IJ.log(""String_Node_Str"");
      IJ.showStatus(""String_Node_Str"");
      return false;
    }
    Arrays.fill(featureStackToUpdateTrain,false);
    filterFeatureStackByList();
    updateFeatures=false;
    long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + featureStackArray.getSize() + ""String_Node_Str""+ featureStackArray.getNumOfFeatures()+ ""String_Node_Str""+ (end - start)+ ""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  Instances data=null;
  if (nonEmpty < 1)   IJ.log(""String_Node_Str"");
 else {
    final long start=System.currentTimeMillis();
    traceTrainingData=data=createTrainingInstances();
    final long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  if (loadedTrainingData != null && data != null) {
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++)     data.add(loadedTrainingData.instance(i));
    IJ.log(""String_Node_Str"" + data.numInstances());
  }
 else   if (data == null) {
    data=loadedTrainingData;
    IJ.log(""String_Node_Str"");
  }
  if (null == data) {
    IJ.log(""String_Node_Str"");
  }
  this.trainHeader=new Instances(data,0);
  if (homogenizeClasses) {
    final long start=System.currentTimeMillis();
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    data=homogenizeTrainingData(data);
    final long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  if (Thread.currentThread().isInterrupted()) {
    IJ.log(""String_Node_Str"");
    return false;
  }
  final long start=System.currentTimeMillis();
  try {
    classifier.buildClassifier(data);
  }
 catch (  InterruptedException ie) {
    IJ.log(""String_Node_Str"");
    return false;
  }
catch (  Exception e) {
    IJ.showMessage(e.getMessage());
    e.printStackTrace();
    return false;
  }
  IJ.log(this.classifier.toString());
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return true;
}",0.9989953114534494
22709,"/** 
 * Get the minimum foreground-restricted metric value over a set of thresholds 
 * @param minThreshold minimum threshold value to binarize the input images
 * @param maxThreshold maximum threshold value to binarize the input images
 * @param stepThreshold threshold step value to use during binarization
 * @return minimum foreground-restricted value of the metric
 */
public double getMinimumForegroundRestrictedMetricValue(double minThreshold,double maxThreshold,double stepThreshold){
  double min=1.0;
  double bestTh=minThreshold;
  for (double th=minThreshold; th <= maxThreshold; th+=stepThreshold) {
    if (verbose)     IJ.log(""String_Node_Str"" + String.format(""String_Node_Str"",th) + ""String_Node_Str"");
    double error=getForegroundRestrictedMetricValue(th);
    if (min > error) {
      min=error;
      ;
      bestTh=th;
    }
    if (verbose)     IJ.log(""String_Node_Str"" + error);
  }
  if (verbose)   IJ.log(""String_Node_Str"" + min + ""String_Node_Str""+ bestTh+ ""String_Node_Str"");
  return min;
}","/** 
 * Get the minimum foreground-restricted metric value over a set of thresholds 
 * @param minThreshold minimum threshold value to binarize the input images
 * @param maxThreshold maximum threshold value to binarize the input images
 * @param stepThreshold threshold step value to use during binarization
 * @return minimum foreground-restricted value of the metric
 */
public double getMinimumForegroundRestrictedMetricValue(double minThreshold,double maxThreshold,double stepThreshold){
  double min=Double.MAX_VALUE;
  double bestTh=minThreshold;
  for (double th=minThreshold; th <= maxThreshold; th+=stepThreshold) {
    if (verbose)     IJ.log(""String_Node_Str"" + String.format(""String_Node_Str"",th) + ""String_Node_Str"");
    double error=getForegroundRestrictedMetricValue(th);
    if (min > error) {
      min=error;
      ;
      bestTh=th;
    }
    if (verbose)     IJ.log(""String_Node_Str"" + error);
  }
  if (verbose)   IJ.log(""String_Node_Str"" + min + ""String_Node_Str""+ bestTh+ ""String_Node_Str"");
  return min;
}",0.9917113603120428
22710,"/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        String[] tokens;
        float sigma;
switch (i) {
case FeatureStack.MEMBRANE:
          int index=a.name().indexOf(""String_Node_Str"") + 4;
        int index2=a.name().indexOf(""String_Node_Str"",index + 1);
      final int patchSize=Integer.parseInt(a.name().substring(index,index2));
    if (patchSize != membranePatchSize) {
      membranePatchSize=patchSize;
      this.featureStackArray.setMembranePatchSize(patchSize);
      featuresChanged=true;
    }
  index=a.name().lastIndexOf(""String_Node_Str"");
final int thickness=Integer.parseInt(a.name().substring(index + 1));
if (thickness != membraneThickness) {
membraneThickness=thickness;
this.featureStackArray.setMembraneSize(thickness);
featuresChanged=true;
}
break;
case FeatureStack.NEIGHBORS:
case FeatureStack.ENTROPY:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[1]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.ANISOTROPIC_DIFFUSION:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[3]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
}
}
IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
if (minSigma != this.minimumSigma && minSigma != 0) {
this.minimumSigma=minSigma;
featuresChanged=true;
this.featureStackArray.setMinimumSigma(minSigma);
}
if (maxSigma != this.maximumSigma) {
this.maximumSigma=maxSigma;
featuresChanged=true;
this.featureStackArray.setMaximumSigma(maxSigma);
}
Attribute classAttribute=data.classAttribute();
Enumeration<String> classValues=classAttribute.enumerateValues();
loadedClassNames=new ArrayList<String>();
int j=0;
setNumOfClasses(0);
while (classValues.hasMoreElements()) {
final String className=classValues.nextElement().trim();
loadedClassNames.add(className);
}
for (String className : loadedClassNames) {
IJ.log(""String_Node_Str"" + className);
setClassLabel(j,className);
addClass();
j++;
}
final boolean[] oldEnableFeatures=this.featureStackArray.getEnabledFeatures();
for (int i=0; i < numFeatures; i++) {
if (usedFeatures[i] != oldEnableFeatures[i]) featuresChanged=true;
}
if (featuresChanged) {
this.setEnabledFeatures(usedFeatures);
updateFeatures=true;
}
return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        String[] tokens;
        float sigma;
switch (i) {
case FeatureStack.MEMBRANE:
          int index=a.name().indexOf(""String_Node_Str"") + 4;
        int index2=a.name().indexOf(""String_Node_Str"",index + 1);
      final int patchSize=Integer.parseInt(a.name().substring(index,index2));
    if (patchSize != membranePatchSize) {
      membranePatchSize=patchSize;
      this.featureStackArray.setMembranePatchSize(patchSize);
      featuresChanged=true;
    }
  index=a.name().lastIndexOf(""String_Node_Str"");
final int thickness=Integer.parseInt(a.name().substring(index + 1));
if (thickness != membraneThickness) {
membraneThickness=thickness;
this.featureStackArray.setMembraneSize(thickness);
featuresChanged=true;
}
break;
case FeatureStack.KUWAHARA:
tokens=a.name().split(""String_Node_Str"");
membranePatchSize=Integer.parseInt(tokens[1]);
break;
case FeatureStack.NEIGHBORS:
case FeatureStack.ENTROPY:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[1]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.STRUCTURE:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[2]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.ANISOTROPIC_DIFFUSION:
tokens=a.name().split(""String_Node_Str"");
sigma=Float.parseFloat(tokens[3]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
break;
case FeatureStack.BILATERAL:
case FeatureStack.LIPSCHITZ:
break;
default :
tokens=a.name().split(""String_Node_Str"");
for (int j=0; j < tokens.length; j++) if (tokens[j].indexOf(""String_Node_Str"") != -1) {
sigma=Float.parseFloat(tokens[j]);
if (sigma < minSigma) minSigma=sigma;
if (sigma > maxSigma) maxSigma=sigma;
}
}
}
}
}
IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
if (minSigma != this.minimumSigma && minSigma != 0) {
this.minimumSigma=minSigma;
featuresChanged=true;
this.featureStackArray.setMinimumSigma(minSigma);
}
if (maxSigma != this.maximumSigma) {
this.maximumSigma=maxSigma;
featuresChanged=true;
this.featureStackArray.setMaximumSigma(maxSigma);
}
Attribute classAttribute=data.classAttribute();
Enumeration<String> classValues=classAttribute.enumerateValues();
loadedClassNames=new ArrayList<String>();
int j=0;
setNumOfClasses(0);
while (classValues.hasMoreElements()) {
final String className=classValues.nextElement().trim();
loadedClassNames.add(className);
}
for (String className : loadedClassNames) {
IJ.log(""String_Node_Str"" + className);
setClassLabel(j,className);
addClass();
j++;
}
final boolean[] oldEnableFeatures=this.featureStackArray.getEnabledFeatures();
for (int i=0; i < numFeatures; i++) {
if (usedFeatures[i] != oldEnableFeatures[i]) featuresChanged=true;
}
if (featuresChanged) {
this.setEnabledFeatures(usedFeatures);
updateFeatures=true;
}
return true;
}",0.9742541888026156
22711,"/** 
 * Show advanced settings dialog
 * @return false when canceled
 */
public boolean showSettingsDialog(){
  GenericDialogPlus gd=new GenericDialogPlus(""String_Node_Str"");
  final boolean[] oldEnableFeatures=wekaSegmentation.getEnabledFeatures();
  gd.addMessage(""String_Node_Str"");
  final int rows=(int)Math.round(FeatureStack.availableFeatures.length / 2.0);
  gd.addCheckboxGroup(rows,2,FeatureStack.availableFeatures,oldEnableFeatures);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final Vector<Checkbox> v=gd.getCheckboxes();
    for (    Checkbox c : v)     c.setEnabled(false);
    gd.addMessage(""String_Node_Str"");
  }
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembraneThickness(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembranePatchSize(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMinimumSigma(),1);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMaximumSigma(),1);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    for (int i=0; i < 4; i++)     ((TextField)gd.getNumericFields().get(i)).setEnabled(false);
  }
  gd.addMessage(""String_Node_Str"");
  GenericObjectEditor m_ClassifierEditor=new GenericObjectEditor();
  PropertyPanel m_CEPanel=new PropertyPanel(m_ClassifierEditor);
  m_ClassifierEditor.setClassType(Classifier.class);
  m_ClassifierEditor.setValue(wekaSegmentation.getClassifier());
  gd.addComponent(m_CEPanel,GridBagConstraints.HORIZONTAL,1);
  Object c=(Object)m_ClassifierEditor.getValue();
  String originalOptions=""String_Node_Str"";
  String originalClassifierName=c.getClass().getName();
  if (c instanceof OptionHandler) {
    originalOptions=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  gd.addMessage(""String_Node_Str"");
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)   gd.addStringField(""String_Node_Str"" + (i + 1),wekaSegmentation.getClassLabel(i),15);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",wekaSegmentation.doHomogenizeClasses());
  gd.addButton(""String_Node_Str"",new SaveFeatureStackButtonListener(""String_Node_Str"",wekaSegmentation.getFeatureStackArray()));
  gd.addSlider(""String_Node_Str"",0,100,win.overlayOpacity);
  gd.addHelp(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return false;
  final int numOfFeatures=FeatureStack.availableFeatures.length;
  final boolean[] newEnableFeatures=new boolean[numOfFeatures];
  boolean featuresChanged=false;
  for (int i=0; i < numOfFeatures; i++) {
    newEnableFeatures[i]=gd.getNextBoolean();
    if (newEnableFeatures[i] != oldEnableFeatures[i]) {
      featuresChanged=true;
      record(SET_FEATURE,new String[]{FeatureStack.availableFeatures[i] + ""String_Node_Str"" + newEnableFeatures[i]});
    }
  }
  if (featuresChanged) {
    wekaSegmentation.setEnabledFeatures(newEnableFeatures);
  }
  final int newThickness=(int)gd.getNextNumber();
  if (newThickness != wekaSegmentation.getMembraneThickness()) {
    featuresChanged=true;
    wekaSegmentation.setMembraneThickness(newThickness);
    record(SET_MEMBRANE_THICKNESS,new String[]{Integer.toString(newThickness)});
  }
  final int newPatch=(int)gd.getNextNumber();
  if (newPatch != wekaSegmentation.getMembranePatchSize()) {
    featuresChanged=true;
    record(SET_MEMBRANE_PATCH,new String[]{Integer.toString(newPatch)});
    wekaSegmentation.setMembranePatchSize(newPatch);
  }
  final float newMinSigma=(float)gd.getNextNumber();
  if (newMinSigma != wekaSegmentation.getMinimumSigma() && newMinSigma > 0) {
    featuresChanged=true;
    record(SET_MINIMUM_SIGMA,new String[]{Float.toString(newMinSigma)});
    wekaSegmentation.setMinimumSigma(newMinSigma);
  }
  final float newMaxSigma=(float)gd.getNextNumber();
  if (newMaxSigma != wekaSegmentation.getMaximumSigma() && newMaxSigma >= wekaSegmentation.getMinimumSigma()) {
    featuresChanged=true;
    record(SET_MAXIMUM_SIGMA,new String[]{Float.toString(newMaxSigma)});
    wekaSegmentation.setMaximumSigma(newMaxSigma);
  }
  if (wekaSegmentation.getMinimumSigma() > wekaSegmentation.getMaximumSigma()) {
    IJ.error(""String_Node_Str"");
    wekaSegmentation.setMinimumSigma(0f);
    wekaSegmentation.setMaximumSigma(16f);
  }
  c=(Object)m_ClassifierEditor.getValue();
  String options=""String_Node_Str"";
  final String[] optionsArray=((OptionHandler)c).getOptions();
  if (c instanceof OptionHandler) {
    options=Utils.joinOptions(optionsArray);
  }
  if (originalClassifierName.equals(c.getClass().getName()) == false || originalOptions.equals(options) == false) {
    AbstractClassifier cls;
    try {
      cls=(AbstractClassifier)(c.getClass().newInstance());
      cls.setOptions(optionsArray);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      return false;
    }
    wekaSegmentation.setClassifier(cls);
    record(SET_CLASSIFIER,new String[]{c.getClass().getName(),options});
    IJ.log(""String_Node_Str"" + c.getClass().getName() + ""String_Node_Str""+ options);
  }
  boolean classNameChanged=false;
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
    String s=gd.getNextString();
    if (null == s || 0 == s.length()) {
      IJ.log(""String_Node_Str"" + (i + 1));
      continue;
    }
    s=s.trim();
    if (!s.equals(wekaSegmentation.getClassLabel(i))) {
      if (0 == s.toLowerCase().indexOf(""String_Node_Str""))       s=s.substring(7);
      wekaSegmentation.setClassLabel(i,s);
      classNameChanged=true;
      addExampleButton[i].setText(""String_Node_Str"" + s);
      record(CHANGE_CLASS_NAME,new String[]{Integer.toString(i),s});
    }
  }
  final boolean homogenizeClasses=gd.getNextBoolean();
  if (wekaSegmentation.doHomogenizeClasses() != homogenizeClasses) {
    wekaSegmentation.setDoHomogenizeClasses(homogenizeClasses);
    record(SET_HOMOGENIZATION,new String[]{Boolean.toString(homogenizeClasses)});
  }
  final int newOpacity=(int)gd.getNextNumber();
  if (newOpacity != win.overlayOpacity) {
    win.overlayOpacity=newOpacity;
    win.overlayAlpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,win.overlayOpacity / 100f);
    win.resultOverlay.setComposite(win.overlayAlpha);
    record(SET_OPACITY,new String[]{Integer.toString(win.overlayOpacity)});
    if (showColorOverlay)     displayImage.updateAndDraw();
  }
  if (classNameChanged) {
    win.pack();
  }
  if (featuresChanged) {
    wekaSegmentation.setFeaturesDirty();
  }
 else   if (wekaSegmentation.getFeatureStackArray().isEmpty() == false && wekaSegmentation.getFeatureStackArray().getReferenceSliceIndex() != -1)   wekaSegmentation.setUpdateFeatures(false);
  return true;
}","/** 
 * Show advanced settings dialog
 * @return false when canceled
 */
public boolean showSettingsDialog(){
  GenericDialogPlus gd=new GenericDialogPlus(""String_Node_Str"");
  final boolean[] oldEnableFeatures=wekaSegmentation.getEnabledFeatures();
  gd.addMessage(""String_Node_Str"");
  final int rows=(int)Math.round(FeatureStack.availableFeatures.length / 2.0);
  gd.addCheckboxGroup(rows,2,FeatureStack.availableFeatures,oldEnableFeatures);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final Vector<Checkbox> v=gd.getCheckboxes();
    for (    Checkbox c : v)     c.setEnabled(false);
    gd.addMessage(""String_Node_Str"");
  }
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembraneThickness(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembranePatchSize(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMinimumSigma(),1);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMaximumSigma(),1);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    for (int i=0; i < 4; i++)     ((TextField)gd.getNumericFields().get(i)).setEnabled(false);
  }
  gd.addMessage(""String_Node_Str"");
  GenericObjectEditor m_ClassifierEditor=new GenericObjectEditor();
  PropertyPanel m_CEPanel=new PropertyPanel(m_ClassifierEditor);
  m_ClassifierEditor.setClassType(Classifier.class);
  m_ClassifierEditor.setValue(wekaSegmentation.getClassifier());
  gd.addComponent(m_CEPanel,GridBagConstraints.HORIZONTAL,1);
  Object c=(Object)m_ClassifierEditor.getValue();
  String originalOptions=""String_Node_Str"";
  String originalClassifierName=c.getClass().getName();
  if (c instanceof OptionHandler) {
    originalOptions=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  gd.addMessage(""String_Node_Str"");
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)   gd.addStringField(""String_Node_Str"" + (i + 1),wekaSegmentation.getClassLabel(i),15);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",wekaSegmentation.doHomogenizeClasses());
  gd.addButton(""String_Node_Str"",new SaveFeatureStackButtonListener(""String_Node_Str"",wekaSegmentation.getFeatureStackArray()));
  gd.addSlider(""String_Node_Str"",0,100,win.overlayOpacity);
  gd.addHelp(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return false;
  final int numOfFeatures=FeatureStack.availableFeatures.length;
  final boolean[] newEnableFeatures=new boolean[numOfFeatures];
  boolean featuresChanged=false;
  for (int i=0; i < numOfFeatures; i++) {
    newEnableFeatures[i]=gd.getNextBoolean();
    if (newEnableFeatures[i] != oldEnableFeatures[i]) {
      featuresChanged=true;
      record(SET_FEATURE,new String[]{FeatureStack.availableFeatures[i] + ""String_Node_Str"" + newEnableFeatures[i]});
    }
  }
  if (featuresChanged) {
    wekaSegmentation.setEnabledFeatures(newEnableFeatures);
  }
  final int newThickness=(int)gd.getNextNumber();
  if (newThickness != wekaSegmentation.getMembraneThickness()) {
    featuresChanged=true;
    wekaSegmentation.setMembraneThickness(newThickness);
    record(SET_MEMBRANE_THICKNESS,new String[]{Integer.toString(newThickness)});
  }
  final int newPatch=(int)gd.getNextNumber();
  if (newPatch != wekaSegmentation.getMembranePatchSize()) {
    featuresChanged=true;
    record(SET_MEMBRANE_PATCH,new String[]{Integer.toString(newPatch)});
    wekaSegmentation.setMembranePatchSize(newPatch);
  }
  final float newMinSigma=(float)gd.getNextNumber();
  if (newMinSigma != wekaSegmentation.getMinimumSigma() && newMinSigma > 0) {
    featuresChanged=true;
    record(SET_MINIMUM_SIGMA,new String[]{Float.toString(newMinSigma)});
    wekaSegmentation.setMinimumSigma(newMinSigma);
  }
  final float newMaxSigma=(float)gd.getNextNumber();
  if (newMaxSigma != wekaSegmentation.getMaximumSigma() && newMaxSigma >= wekaSegmentation.getMinimumSigma()) {
    featuresChanged=true;
    record(SET_MAXIMUM_SIGMA,new String[]{Float.toString(newMaxSigma)});
    wekaSegmentation.setMaximumSigma(newMaxSigma);
  }
  if (wekaSegmentation.getMinimumSigma() > wekaSegmentation.getMaximumSigma()) {
    IJ.error(""String_Node_Str"");
    wekaSegmentation.setMinimumSigma(0f);
    wekaSegmentation.setMaximumSigma(16f);
  }
  c=(Object)m_ClassifierEditor.getValue();
  String options=""String_Node_Str"";
  final String[] optionsArray=((OptionHandler)c).getOptions();
  if (c instanceof OptionHandler) {
    options=Utils.joinOptions(optionsArray);
  }
  if (originalClassifierName.equals(c.getClass().getName()) == false || originalOptions.equals(options) == false) {
    AbstractClassifier cls;
    try {
      cls=(AbstractClassifier)(c.getClass().newInstance());
      cls.setOptions(optionsArray);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      return false;
    }
    wekaSegmentation.setClassifier(cls);
    win.trainingComplete=false;
    record(SET_CLASSIFIER,new String[]{c.getClass().getName(),options});
    IJ.log(""String_Node_Str"" + c.getClass().getName() + ""String_Node_Str""+ options);
  }
  boolean classNameChanged=false;
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
    String s=gd.getNextString();
    if (null == s || 0 == s.length()) {
      IJ.log(""String_Node_Str"" + (i + 1));
      continue;
    }
    s=s.trim();
    if (!s.equals(wekaSegmentation.getClassLabel(i))) {
      if (0 == s.toLowerCase().indexOf(""String_Node_Str""))       s=s.substring(7);
      wekaSegmentation.setClassLabel(i,s);
      classNameChanged=true;
      addExampleButton[i].setText(""String_Node_Str"" + s);
      record(CHANGE_CLASS_NAME,new String[]{Integer.toString(i),s});
    }
  }
  final boolean homogenizeClasses=gd.getNextBoolean();
  if (wekaSegmentation.doHomogenizeClasses() != homogenizeClasses) {
    wekaSegmentation.setDoHomogenizeClasses(homogenizeClasses);
    record(SET_HOMOGENIZATION,new String[]{Boolean.toString(homogenizeClasses)});
  }
  final int newOpacity=(int)gd.getNextNumber();
  if (newOpacity != win.overlayOpacity) {
    win.overlayOpacity=newOpacity;
    win.overlayAlpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,win.overlayOpacity / 100f);
    win.resultOverlay.setComposite(win.overlayAlpha);
    record(SET_OPACITY,new String[]{Integer.toString(win.overlayOpacity)});
    if (showColorOverlay)     displayImage.updateAndDraw();
  }
  if (classNameChanged) {
    win.pack();
  }
  if (featuresChanged) {
    wekaSegmentation.setFeaturesDirty();
  }
 else   if (wekaSegmentation.getFeatureStackArray().isEmpty() == false && wekaSegmentation.getFeatureStackArray().getReferenceSliceIndex() != -1)   wekaSegmentation.setUpdateFeatures(false);
  return true;
}",0.9975823511634936
22712,"/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value and prediction statistics
 */
public static ClassificationStatistics adaptedRandIndexStats3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  IJ.log(""String_Node_Str"");
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  double tp=0;
  double fp=0;
  double tn=0;
  double fn=0;
  for (int slice=1; slice <= nSlices; slice++) {
    IJ.log(""String_Node_Str"" + slice + ""String_Node_Str"");
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1) / 2;
    double nPairsTotal=n * (n - 1) / 2;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1) / 2;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1) / 2;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    IJ.log(""String_Node_Str"" + (truePositives + trueNegatives));
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
    double falsePositives=nPosActual - truePositives;
    double nNegActual=nPairsTotal - nPosActual;
    double falseNegatives=nNegActual - trueNegatives;
    tp+=truePositives;
    tn+=trueNegatives;
    fp+=falsePositives;
    fn+=falseNegatives;
  }
  double randIndex=agreements / nPairsStack;
  return new ClassificationStatistics(tp,tn,fp,fn,randIndex);
}","/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value and prediction statistics
 */
public static ClassificationStatistics adaptedRandIndexStats3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  IJ.log(""String_Node_Str"");
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  double tp=0;
  double fp=0;
  double tn=0;
  double fn=0;
  for (int slice=1; slice <= nSlices; slice++) {
    IJ.log(""String_Node_Str"" + slice + ""String_Node_Str"");
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
    double nPairsTotal=n * (n - 1.0) / 2.0;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    IJ.log(""String_Node_Str"" + (truePositives + trueNegatives));
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
    double falsePositives=nPosActual - truePositives;
    double nNegActual=nPairsTotal - nPosActual;
    double falseNegatives=nNegActual - trueNegatives;
    tp+=truePositives;
    tn+=trueNegatives;
    fp+=falsePositives;
    fn+=falseNegatives;
  }
  double randIndex=agreements / nPairsStack;
  return new ClassificationStatistics(tp,tn,fp,fn,randIndex);
}",0.9978712080894092
22713,"/** 
 * No-image constructor. If you use this constructor, the image has to be set using setTrainingImage().
 */
public WekaSegmentation(){
  for (int i=0; i < MAX_NUM_CLASSES; i++)   this.classLabels[i]=new String(""String_Node_Str"" + i);
  rf=new FastRandomForest();
  rf.setNumTrees(numOfTrees);
  rf.setNumFeatures(randomFeatures);
  rf.setSeed((new Random()).nextInt());
  rf.setNumThreads(Prefs.getThreads());
  classifier=rf;
  addClass();
  addClass();
}","/** 
 * No-image constructor. If you use this constructor, the image has to be set using setTrainingImage().
 */
public WekaSegmentation(){
  for (int i=0; i < MAX_NUM_CLASSES; i++)   this.classLabels[i]=new String(""String_Node_Str"" + (i + 1));
  rf=new FastRandomForest();
  rf.setNumTrees(numOfTrees);
  rf.setNumFeatures(randomFeatures);
  rf.setSeed((new Random()).nextInt());
  rf.setNumThreads(Prefs.getThreads());
  classifier=rf;
  addClass();
  addClass();
}",0.9913793103448276
22714,"/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value
 */
public static double adaptedRandIndex3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return -1;
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1) / 2;
    double nPairsTotal=n * (n - 1) / 2;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1) / 2;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1) / 2;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
  }
  return agreements / nPairsStack;
}","/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value
 */
public static double adaptedRandIndex3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return -1;
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
    double nPairsTotal=n * (n - 1.0) / 2.0;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
  }
  return agreements / nPairsStack;
}",0.9974779319041616
22715,"/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value and prediction statistics
 */
public static ClassificationStatistics adaptedRandIndexStats3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  IJ.log(""String_Node_Str"");
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  double tp=0;
  double fp=0;
  double tn=0;
  double fn=0;
  for (int slice=1; slice <= nSlices; slice++) {
    IJ.log(""String_Node_Str"" + slice + ""String_Node_Str"");
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
    double nPairsTotal=n * (n - 1.0) / 2.0;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    IJ.log(""String_Node_Str"" + (truePositives + trueNegatives));
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
    double falsePositives=nPosActual - truePositives;
    double nNegActual=nPairsTotal - nPosActual;
    double falseNegatives=nNegActual - trueNegatives;
    tp+=truePositives;
    tn+=trueNegatives;
    fp+=falsePositives;
    fn+=falseNegatives;
  }
  double randIndex=agreements / nPairsStack;
  return new ClassificationStatistics(tp,tn,fp,fn,randIndex);
}","/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value and prediction statistics
 */
public static ClassificationStatistics adaptedRandIndexStats3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  IJ.log(""String_Node_Str"");
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  double tp=0;
  double fp=0;
  double tn=0;
  double fn=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
    double nPairsTotal=n * (n - 1.0) / 2.0;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
    double falsePositives=nPosActual - truePositives;
    double nNegActual=nPairsTotal - nPosActual;
    double falseNegatives=nNegActual - trueNegatives;
    tp+=truePositives;
    tn+=trueNegatives;
    fp+=falsePositives;
    fn+=falseNegatives;
  }
  double randIndex=agreements / nPairsStack;
  return new ClassificationStatistics(tp,tn,fp,fn,randIndex);
}",0.8674406047516199
22716,"/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStackArray.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStackArray.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i < FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
  if (minSigma != this.minimumSigma && minSigma != 0) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStackArray.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStackArray.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  setNumOfClasses(0);
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    setClassLabel(j,className);
    addClass();
    j++;
  }
  final boolean[] oldEnableFeatures=this.featureStackArray.getEnabledFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.setEnabledFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStackArray.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStackArray.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i < FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
 else {
          String[] tokens=a.name().split(""String_Node_Str"");
          final float sigma=Float.parseFloat(tokens[3]);
          if (sigma < minSigma)           minSigma=sigma;
          if (sigma > maxSigma)           maxSigma=sigma;
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
  if (minSigma != this.minimumSigma && minSigma != 0) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStackArray.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStackArray.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  setNumOfClasses(0);
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    setClassLabel(j,className);
    addClass();
    j++;
  }
  final boolean[] oldEnableFeatures=this.featureStackArray.getEnabledFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.setEnabledFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}",0.9636153624025412
22717,"/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. Note: this method is based on the N_choose_2 normalization. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value
 */
public static double adaptedRandIndex3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return -1;
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
    double nPairsTotal=n * (n - 1.0) / 2.0;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
  }
  return agreements / nPairsStack;
}","/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. Note: this method is based on the N_choose_2 normalization. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value
 */
public static double adaptedRandIndex3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return -1;
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double nPairsStack=0;
  double agreements=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    double n=0;
    int[][] cont=new int[maxIDGroundTruth + 1][maxIDProposal + 1];
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i] & 0xffff][pixels2[i] & 0xffff]++;
      if (pixels1[i] > 0)       n++;
    }
    double[] ni=new double[cont.length];
    for (int i=1; i < cont.length; i++)     for (int j=0; j < cont[0].length; j++) {
      ni[i]+=cont[i][j];
    }
    double[] nj=new double[cont[0].length];
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++) {
      nj[j]+=cont[i][j];
    }
    double truePositives=0;
    for (int j=1; j < cont[0].length; j++)     for (int i=1; i < cont.length; i++)     truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
    double nPairsTotal=n * (n - 1.0) / 2.0;
    double nPosTrue=0;
    for (int k=0; k < ni.length; k++)     nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
    double nPosActual=0;
    for (int k=0; k < nj.length; k++)     nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
    double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
    agreements+=truePositives + trueNegatives;
    nPairsStack+=nPairsTotal;
  }
  return agreements / nPairsStack;
}",0.9907663896583564
22718,"/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. Note: this method is based on the N_choose_2 normalization. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value and prediction statistics
 */
public static ClassificationStatistics adaptedRandIndexStats3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double agreements=0;
  long[][] cont=new long[maxIDGroundTruth + 1][maxIDProposal + 1];
  double[] ni=new double[cont.length];
  double[] nj=new double[cont[0].length];
  double n=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i]][pixels2[i]]++;
      if (pixels1[i] > 0)       n++;
    }
  }
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1.0);
  double nPairsTotal=n * (n - 1.0);
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1.0);
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1.0);
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  agreements+=truePositives + trueNegatives;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - trueNegatives;
  truePositives/=2.0;
  trueNegatives/=2.0;
  falsePositives/=2.0;
  falseNegatives/=2.0;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}","/** 
 * Calculate the Rand index between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. Note: this method is based on the N_choose_2 normalization. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param originalLabels ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param proposedLabels prediction, 3D segmented image (objects are labeled with different numbers)
 * @return adapted Rand index value and prediction statistics
 */
public static ClassificationStatistics adaptedRandIndexStats3D(ImagePlus originalLabels,ImagePlus proposedLabels){
  if (originalLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false || proposedLabels.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  int nSlices=originalLabels.getImageStackSize();
  int maxIDGroundTruth=0;
  int maxIDProposal=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=originalLabels.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (maxIDGroundTruth < gt.getMax())     maxIDGroundTruth=(int)gt.getMax();
    ImageProcessor proposal=proposedLabels.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (maxIDProposal < proposal.getMax())     maxIDProposal=(int)proposal.getMax();
  }
  double agreements=0;
  long[][] cont=new long[maxIDGroundTruth + 1][maxIDProposal + 1];
  double[] ni=new double[cont.length];
  double[] nj=new double[cont[0].length];
  double n=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)originalLabels.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)proposedLabels.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    for (int i=0; i < nPixels; i++) {
      cont[pixels1[i] & 0xffff][pixels2[i] & 0xffff]++;
      if (pixels1[i] > 0)       n++;
    }
  }
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1.0);
  double nPairsTotal=n * (n - 1.0);
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1.0);
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1.0);
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  agreements+=truePositives + trueNegatives;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - trueNegatives;
  truePositives/=2.0;
  trueNegatives/=2.0;
  falsePositives/=2.0;
  falseNegatives/=2.0;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}",0.9974518686296716
22719,"/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}. Note that this version of the Rand index treats the zero component (background) as another  object. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public double classicRandIndex(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double n=pixels1.length;
  int[][] cont=new int[(int)cluster1.getMax()][(int)cluster2.getMax()];
  for (int i=0; i < n; i++)   cont[pixels1[i]][pixels2[i]]++;
  double t2=0;
  double[] ni=new double[cont.length];
  for (int i=0; i < cont.length; i++)   for (int j=0; j < cont[i].length; j++)   ni[i]+=cont[i][j];
  double nis=0;
  for (int k=0; k < ni.length; k++)   nis+=ni[k] * ni[k];
  double[] nj=new double[cont.length];
  for (int j=0; j < cont[0].length; j++)   for (int i=0; i < cont.length; i++) {
    nj[j]+=cont[i][j];
    t2+=cont[i][j] * cont[i][j];
  }
  double njs=0;
  for (int k=0; k < nj.length; k++)   njs+=nj[k] * nj[k];
  double t1=n * (n - 1) / 2;
  double t3=0.5 * (nis + njs);
  double agreements=t1 + t2 - t3;
  return agreements / t1;
}","/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}. Note that this version of the Rand index treats the zero component (background) as another  object. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public double classicRandIndex(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double n=pixels1.length;
  int[][] cont=new int[(int)cluster1.getMax()][(int)cluster2.getMax()];
  for (int i=0; i < n; i++)   cont[pixels1[i] & 0xffff][pixels2[i] & 0xffff]++;
  double t2=0;
  double[] ni=new double[cont.length];
  for (int i=0; i < cont.length; i++)   for (int j=0; j < cont[i].length; j++)   ni[i]+=cont[i][j];
  double nis=0;
  for (int k=0; k < ni.length; k++)   nis+=ni[k] * ni[k];
  double[] nj=new double[cont.length];
  for (int j=0; j < cont[0].length; j++)   for (int i=0; i < cont.length; i++) {
    nj[j]+=cont[i][j];
    t2+=cont[i][j] * cont[i][j];
  }
  double njs=0;
  for (int k=0; k < nj.length; k++)   njs+=nj[k] * nj[k];
  double t1=n * (n - 1) / 2;
  double t3=0.5 * (nis + njs);
  double agreements=t1 + t2 - t3;
  return agreements / t1;
}",0.9946492271105828
22720,"/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 ground truth, 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 prediction, 2D segmented image (objects are labeled with different numbers)
 * @return Rand index value and prediction statistics
 */
public ClassificationStatistics getRandIndexStats(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  }
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - trueNegatives;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}","/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 ground truth, 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 prediction, 2D segmented image (objects are labeled with different numbers)
 * @return Rand index value and prediction statistics
 */
public ClassificationStatistics getRandIndexStats(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i] & 0xffff][pixels2[i] & 0xffff]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  }
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - trueNegatives;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}",0.9962624584717608
22721,"/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component in  the ground truth (cluster 1). BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 ground truth, 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 prediction, 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public double randIndex(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  double nPairsTotal=n * (n - 1.0) / 2.0;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return randIndex;
}","/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component in  the ground truth (cluster 1). BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 ground truth, 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 prediction, 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public double randIndex(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i] & 0xffff][pixels2[i] & 0xffff]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  double nPairsTotal=n * (n - 1.0) / 2.0;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1.0) / 2.0;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1.0) / 2.0;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return randIndex;
}",0.9956999522216914
22722,"/** 
 * Calculate the Rand index stats between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. Note: this method is based on the N^2 normalization. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param segA ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param segB prediction, 3D segmented image (objects are labeled with different numbers)
 * @return [ precision, recall, Rand index with n^2 normalization ]
 */
public static double[] adaptedRandIndexStats3DN2(ImagePlus segA,ImagePlus segB){
  if (segA.getImageStack().getProcessor(1) instanceof ShortProcessor == false || segB.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  int nSlices=segA.getImageStackSize();
  int nLabelsA=0;
  int nLabelsB=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=segA.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (nLabelsA < gt.getMax())     nLabelsA=(int)gt.getMax();
    ImageProcessor proposal=segB.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (nLabelsB < proposal.getMax())     nLabelsB=(int)proposal.getMax();
  }
  long[][] pij=new long[nLabelsA + 1][nLabelsB + 1];
  double n=segA.getImageStackSize() * segA.getWidth() * segA.getHeight();
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)segA.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)segB.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    for (int i=0; i < nPixels; i++)     pij[pixels1[i]][pixels2[i]]++;
  }
  double[] ai=new double[pij.length];
  for (int i=1; i < pij.length; i++)   for (int j=0; j < pij[0].length; j++) {
    ai[i]+=pij[i][j];
  }
  double[] bj=new double[pij[0].length];
  for (int j=1; j < pij[0].length; j++)   for (int i=1; i < pij.length; i++) {
    bj[j]+=pij[i][j];
  }
  double[] pi0=new double[pij.length];
  double aux=0;
  for (int i=1; i < pij.length; i++) {
    pi0[i]=pij[i][0];
    aux+=pi0[i];
  }
  double sumA=0;
  for (int i=0; i < ai.length; i++)   sumA+=ai[i] * ai[i];
  double sumB=0;
  for (int j=0; j < bj.length; j++)   sumB+=bj[j] * bj[j];
  sumB+=aux / n;
  double sumAB=0;
  for (int i=1; i < pij.length; i++)   for (int j=1; j < pij[0].length; j++)   sumAB+=pij[i][j] * pij[i][j];
  sumAB+=aux / n;
  return new double[]{sumAB / sumB,sumAB / sumA,1.0 - (sumA + sumB - 2.0 * sumAB) / (n * n)};
}","/** 
 * Calculate the Rand index stats between to 3D clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. The input images  must be 16-bit. Note: this method is based on the N^2 normalization. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param segA ground truth, 3D segmented image (objects are labeled with different numbers) 
 * @param segB prediction, 3D segmented image (objects are labeled with different numbers)
 * @return [ precision, recall, Rand index with n^2 normalization ]
 */
public static double[] adaptedRandIndexStats3DN2(ImagePlus segA,ImagePlus segB){
  if (segA.getImageStack().getProcessor(1) instanceof ShortProcessor == false || segB.getImageStack().getProcessor(1) instanceof ShortProcessor == false)   return null;
  int nSlices=segA.getImageStackSize();
  int nLabelsA=0;
  int nLabelsB=0;
  for (int slice=1; slice <= nSlices; slice++) {
    ImageProcessor gt=segA.getImageStack().getProcessor(slice);
    gt.resetMinAndMax();
    if (nLabelsA < gt.getMax())     nLabelsA=(int)gt.getMax();
    ImageProcessor proposal=segB.getImageStack().getProcessor(slice);
    proposal.resetMinAndMax();
    if (nLabelsB < proposal.getMax())     nLabelsB=(int)proposal.getMax();
  }
  long[][] pij=new long[nLabelsA + 1][nLabelsB + 1];
  double n=segA.getImageStackSize() * segA.getWidth() * segA.getHeight();
  for (int slice=1; slice <= nSlices; slice++) {
    ShortProcessor cluster1=(ShortProcessor)segA.getImageStack().getProcessor(slice);
    ShortProcessor cluster2=(ShortProcessor)segB.getImageStack().getProcessor(slice);
    final short[] pixels1=(short[])cluster1.getPixels();
    final short[] pixels2=(short[])cluster2.getPixels();
    double nPixels=pixels1.length;
    for (int i=0; i < nPixels; i++)     pij[pixels1[i] & 0xffff][pixels2[i] & 0xffff]++;
  }
  double[] ai=new double[pij.length];
  for (int i=1; i < pij.length; i++)   for (int j=0; j < pij[0].length; j++) {
    ai[i]+=pij[i][j];
  }
  double[] bj=new double[pij[0].length];
  for (int j=1; j < pij[0].length; j++)   for (int i=1; i < pij.length; i++) {
    bj[j]+=pij[i][j];
  }
  double[] pi0=new double[pij.length];
  double aux=0;
  for (int i=1; i < pij.length; i++) {
    pi0[i]=pij[i][0];
    aux+=pi0[i];
  }
  double sumA=0;
  for (int i=0; i < ai.length; i++)   sumA+=ai[i] * ai[i];
  double sumB=0;
  for (int j=0; j < bj.length; j++)   sumB+=bj[j] * bj[j];
  sumB+=aux / n;
  double sumAB=0;
  for (int i=1; i < pij.length; i++)   for (int j=1; j < pij[0].length; j++)   sumAB+=pij[i][j] * pij[i][j];
  sumAB+=aux / n;
  return new double[]{sumAB / sumB,sumAB / sumA,1.0 - (sumA + sumB - 2.0 * sumAB) / (n * n)};
}",0.9956565319077848
22723,"/** 
 * Create training instances out of the user markings
 * @return set of instances (feature vectors in Weka format)
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStackArray.getNumOfFeatures(); i++) {
    String attString=featureStackArray.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes;
  int numOfInstances=0;
  int numOfUsedClasses=0;
  if (null == this.loadedTrainingData) {
    classes=new ArrayList<String>();
    for (int i=0; i < numOfClasses; i++) {
      for (int n=0; n < trainingImage.getImageStackSize(); n++) {
        if (examples[n].get(i).size() > 0) {
          if (classes.contains(getClassLabels()[i]) == false)           classes.add(getClassLabels()[i]);
          numOfUsedClasses++;
        }
        numOfInstances+=examples[n].get(i).size();
      }
    }
  }
 else {
    classes=this.loadedClassNames;
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  final boolean colorFeatures=this.trainingImage.getType() == ImagePlus.COLOR_RGB;
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int sliceNum=1; sliceNum <= trainingImage.getImageStackSize(); sliceNum++)     for (int j=0; j < examples[sliceNum - 1].get(l).size(); j++) {
      Roi r=examples[sliceNum - 1].get(l).get(j);
      if (r instanceof PolygonRoi && r.getType() == Roi.FREELINE) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
            for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)             values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStackArray.getNumOfFeatures()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStackArray.get(sliceNum - 1).getWidth() && y >= 0 && y < featureStackArray.get(sliceNum - 1).getHeight()) {
                double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
                if (colorFeatures)                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getInterpolatedPixel(x,y);
 else                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getInterpolatedValue(x,y);
                values[featureStackArray.getNumOfFeatures()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
          for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)           values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x,y);
          values[featureStackArray.getNumOfFeatures()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + getClassLabels()[l] + ""String_Node_Str""+ nl);
  }
  if (trainingData.numInstances() == 0)   return null;
  trainingData.setClassIndex(featureStackArray.getNumOfFeatures());
  return trainingData;
}","/** 
 * Create training instances out of the user markings
 * @return set of instances (feature vectors in Weka format)
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStackArray.getNumOfFeatures(); i++) {
    String attString=featureStackArray.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes;
  int numOfInstances=0;
  int numOfUsedClasses=0;
  if (null == this.loadedTrainingData) {
    classes=new ArrayList<String>();
    for (int i=0; i < numOfClasses; i++) {
      for (int n=0; n < trainingImage.getImageStackSize(); n++) {
        if (examples[n].get(i).size() > 0) {
          numOfUsedClasses++;
        }
        numOfInstances+=examples[n].get(i).size();
        if (classes.contains(getClassLabels()[i]) == false)         classes.add(getClassLabels()[i]);
      }
    }
  }
 else {
    classes=this.loadedClassNames;
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  final boolean colorFeatures=this.trainingImage.getType() == ImagePlus.COLOR_RGB;
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int sliceNum=1; sliceNum <= trainingImage.getImageStackSize(); sliceNum++)     for (int j=0; j < examples[sliceNum - 1].get(l).size(); j++) {
      Roi r=examples[sliceNum - 1].get(l).get(j);
      if (r instanceof PolygonRoi && r.getType() == Roi.FREELINE) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
            for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)             values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStackArray.getNumOfFeatures()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStackArray.get(sliceNum - 1).getWidth() && y >= 0 && y < featureStackArray.get(sliceNum - 1).getHeight()) {
                double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
                if (colorFeatures)                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getInterpolatedPixel(x,y);
 else                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getInterpolatedValue(x,y);
                values[featureStackArray.getNumOfFeatures()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
          for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)           values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x,y);
          values[featureStackArray.getNumOfFeatures()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + getClassLabels()[l] + ""String_Node_Str""+ nl);
  }
  if (trainingData.numInstances() == 0)   return null;
  trainingData.setClassIndex(featureStackArray.getNumOfFeatures());
  return trainingData;
}",0.978463449989646
22724,"/** 
 * Apply current classifier to a set of feature vectors (given in a feature stack array)
 * @param fsa feature stack array
 * @param numThreads The number of threads to use. Set to zero for auto-detection.
 * @param probabilityMaps probability flag. Tue: probability maps are calculated, false: binary classification 
 * @return result image containing the probability maps or the binary classification
 */
public ImagePlus applyClassifier(final FeatureStackArray fsa,int numThreads,boolean probabilityMaps){
  if (numThreads == 0)   numThreads=Prefs.getThreads();
  ArrayList<String> classNames=null;
  if (null != loadedClassNames)   classNames=loadedClassNames;
 else {
    classNames=new ArrayList<String>();
    for (int j=0; j < trainingImage.getImageStackSize(); j++)     for (int i=0; i < numOfClasses; i++)     if (examples[j].get(i).size() > 0)     if (false == classNames.contains(getClassLabels()[i]))     classNames.add(getClassLabels()[i]);
  }
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= fsa.getNumOfFeatures(); i++) {
    String attString=fsa.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  if (fsa.useNeighborhood())   for (int i=0; i < 8; i++) {
    IJ.log(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    attributes.add(new Attribute(new String(""String_Node_Str"" + (i + 1))));
  }
  attributes.add(new Attribute(""String_Node_Str"",classNames));
  Instances dataInfo=new Instances(""String_Node_Str"",attributes,1);
  dataInfo.setClassIndex(dataInfo.numAttributes() - 1);
  final int numClasses=classNames.size();
  final int numInstances=fsa.getSize() * trainingImage.getWidth() * trainingImage.getHeight();
  final int numChannels=(probabilityMaps ? numClasses : 1);
  final int numSlices=(numChannels * numInstances) / (trainingImage.getWidth() * trainingImage.getHeight());
  IJ.showStatus(""String_Node_Str"");
  final long start=System.currentTimeMillis();
  exe=Executors.newFixedThreadPool(numThreads);
  final double[][][] results=new double[numThreads][][];
  final int partialSize=numInstances / numThreads;
  Future<double[][]> fu[]=new Future[numThreads];
  final AtomicInteger counter=new AtomicInteger();
  for (int i=0; i < numThreads; i++) {
    if (Thread.currentThread().isInterrupted())     return null;
    int first=i * partialSize;
    int size=(i == numThreads - 1) ? numInstances - i * partialSize : partialSize;
    AbstractClassifier classifierCopy=null;
    try {
      if (classifier instanceof FastRandomForest || classifier instanceof RandomForest)       classifierCopy=classifier;
 else       classifierCopy=(AbstractClassifier)(AbstractClassifier.makeCopy(classifier));
    }
 catch (    Exception e) {
      IJ.log(""String_Node_Str"");
      e.printStackTrace();
    }
    fu[i]=exe.submit(classifyInstances(fsa,dataInfo,first,size,classifierCopy,counter,probabilityMaps));
  }
  ScheduledExecutorService monitor=Executors.newScheduledThreadPool(1);
  ScheduledFuture task=monitor.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      IJ.showProgress(counter.get(),numInstances);
    }
  }
,0,1,TimeUnit.SECONDS);
  for (int i=0; i < numThreads; i++) {
    try {
      results[i]=fu[i].get();
    }
 catch (    InterruptedException e) {
      return null;
    }
catch (    ExecutionException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      exe.shutdown();
      task.cancel(true);
      monitor.shutdownNow();
      IJ.showProgress(1);
    }
  }
  exe.shutdown();
  double[][] classificationResult=new double[numChannels][numInstances];
  for (int i=0; i < numThreads; i++)   for (int c=0; c < numChannels; c++)   System.arraycopy(results[i][c],0,classificationResult[c],i * partialSize,results[i][c].length);
  IJ.showProgress(1.0);
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  double[] classifiedSlice=new double[trainingImage.getWidth() * trainingImage.getHeight()];
  final ImageStack classStack=new ImageStack(trainingImage.getWidth(),trainingImage.getHeight());
  for (int i=0; i < numSlices / numChannels; i++) {
    for (int c=0; c < numChannels; c++) {
      System.arraycopy(classificationResult[c],i * (trainingImage.getWidth() * trainingImage.getHeight()),classifiedSlice,0,trainingImage.getWidth() * trainingImage.getHeight());
      ImageProcessor classifiedSliceProcessor=new FloatProcessor(trainingImage.getWidth(),trainingImage.getHeight(),classifiedSlice);
      classStack.addSlice(probabilityMaps ? getClassLabels()[c] : ""String_Node_Str"",classifiedSliceProcessor);
    }
  }
  ImagePlus classImg=new ImagePlus(probabilityMaps ? ""String_Node_Str"" : ""String_Node_Str"",classStack);
  return classImg;
}","/** 
 * Apply current classifier to a set of feature vectors (given in a feature stack array)
 * @param fsa feature stack array
 * @param numThreads The number of threads to use. Set to zero for auto-detection.
 * @param probabilityMaps probability flag. Tue: probability maps are calculated, false: binary classification 
 * @return result image containing the probability maps or the binary classification
 */
public ImagePlus applyClassifier(final FeatureStackArray fsa,int numThreads,boolean probabilityMaps){
  if (numThreads == 0)   numThreads=Prefs.getThreads();
  ArrayList<String> classNames=null;
  if (null != loadedClassNames)   classNames=loadedClassNames;
 else {
    classNames=new ArrayList<String>();
    for (int i=0; i < numOfClasses; i++)     if (false == classNames.contains(getClassLabels()[i]))     classNames.add(getClassLabels()[i]);
  }
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= fsa.getNumOfFeatures(); i++) {
    String attString=fsa.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  if (fsa.useNeighborhood())   for (int i=0; i < 8; i++) {
    IJ.log(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    attributes.add(new Attribute(new String(""String_Node_Str"" + (i + 1))));
  }
  attributes.add(new Attribute(""String_Node_Str"",classNames));
  Instances dataInfo=new Instances(""String_Node_Str"",attributes,1);
  dataInfo.setClassIndex(dataInfo.numAttributes() - 1);
  final int numClasses=classNames.size();
  final int numInstances=fsa.getSize() * trainingImage.getWidth() * trainingImage.getHeight();
  final int numChannels=(probabilityMaps ? numClasses : 1);
  final int numSlices=(numChannels * numInstances) / (trainingImage.getWidth() * trainingImage.getHeight());
  IJ.showStatus(""String_Node_Str"");
  final long start=System.currentTimeMillis();
  exe=Executors.newFixedThreadPool(numThreads);
  final double[][][] results=new double[numThreads][][];
  final int partialSize=numInstances / numThreads;
  Future<double[][]> fu[]=new Future[numThreads];
  final AtomicInteger counter=new AtomicInteger();
  for (int i=0; i < numThreads; i++) {
    if (Thread.currentThread().isInterrupted())     return null;
    int first=i * partialSize;
    int size=(i == numThreads - 1) ? numInstances - i * partialSize : partialSize;
    AbstractClassifier classifierCopy=null;
    try {
      if (classifier instanceof FastRandomForest || classifier instanceof RandomForest)       classifierCopy=classifier;
 else       classifierCopy=(AbstractClassifier)(AbstractClassifier.makeCopy(classifier));
    }
 catch (    Exception e) {
      IJ.log(""String_Node_Str"");
      e.printStackTrace();
    }
    fu[i]=exe.submit(classifyInstances(fsa,dataInfo,first,size,classifierCopy,counter,probabilityMaps));
  }
  ScheduledExecutorService monitor=Executors.newScheduledThreadPool(1);
  ScheduledFuture task=monitor.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      IJ.showProgress(counter.get(),numInstances);
    }
  }
,0,1,TimeUnit.SECONDS);
  for (int i=0; i < numThreads; i++) {
    try {
      results[i]=fu[i].get();
    }
 catch (    InterruptedException e) {
      return null;
    }
catch (    ExecutionException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      exe.shutdown();
      task.cancel(true);
      monitor.shutdownNow();
      IJ.showProgress(1);
    }
  }
  exe.shutdown();
  double[][] classificationResult=new double[numChannels][numInstances];
  for (int i=0; i < numThreads; i++)   for (int c=0; c < numChannels; c++)   System.arraycopy(results[i][c],0,classificationResult[c],i * partialSize,results[i][c].length);
  IJ.showProgress(1.0);
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  double[] classifiedSlice=new double[trainingImage.getWidth() * trainingImage.getHeight()];
  final ImageStack classStack=new ImageStack(trainingImage.getWidth(),trainingImage.getHeight());
  for (int i=0; i < numSlices / numChannels; i++) {
    for (int c=0; c < numChannels; c++) {
      System.arraycopy(classificationResult[c],i * (trainingImage.getWidth() * trainingImage.getHeight()),classifiedSlice,0,trainingImage.getWidth() * trainingImage.getHeight());
      ImageProcessor classifiedSliceProcessor=new FloatProcessor(trainingImage.getWidth(),trainingImage.getHeight(),classifiedSlice);
      classStack.addSlice(probabilityMaps ? getClassLabels()[c] : ""String_Node_Str"",classifiedSliceProcessor);
    }
  }
  ImagePlus classImg=new ImagePlus(probabilityMaps ? ""String_Node_Str"" : ""String_Node_Str"",classStack);
  return classImg;
}",0.9856030713447798
22725,"/** 
 * Calculate the pixel error and derived statistics between some 2D original labels  and the corresponding proposed labels. Both image are binarized.	 
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param mask 2D image representing the binary mask
 * @param binaryThreshold threshold value to binarize the input images
 * @return classification statistics
 */
public ClassificationStatistics precisionRecallStats(ImageProcessor label,ImageProcessor proposal,ImageProcessor mask,double binaryThreshold){
  float[] labelPix=(float[])label.getPixels();
  float[] proposalPix=(float[])proposal.getPixels();
  float[] maskPixels=(float[])mask.getPixels();
  double truePositives=0;
  double trueNegatives=0;
  double falsePositives=0;
  double falseNegatives=0;
  double pixelError=0;
  double n=0;
  for (int i=0; i < labelPix.length; i++) {
    int pix1=(labelPix[i] > binaryThreshold) ? 1 : 0;
    int pix2=(proposalPix[i] > binaryThreshold) ? 1 : 0;
    int pixMask=maskPixels[i] > 0 ? 1 : 0;
    if (pixMask == 0)     continue;
    if (pix1 == 1) {
      if (pix2 == 1)       truePositives++;
 else       falsePositives++;
    }
 else {
      if (pix2 == 1)       falseNegatives++;
 else       trueNegatives++;
    }
    pixelError+=(pix1 - pix2) * (pix1 - pix2);
    n++;
  }
  if (n > 0)   pixelError/=n;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,pixelError);
}","/** 
 * Calculate the pixel error and derived statistics between some 2D original labels  and the corresponding proposed labels. Both image are binarized.	 
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param mask 2D image representing the binary mask
 * @param binaryThreshold threshold value to binarize the input images
 * @return classification statistics
 */
public ClassificationStatistics precisionRecallStats(ImageProcessor label,ImageProcessor proposal,ImageProcessor mask,double binaryThreshold){
  float[] labelPix=(float[])label.getPixels();
  float[] proposalPix=(float[])proposal.getPixels();
  float[] maskPixels=(float[])mask.getPixels();
  double truePositives=0;
  double trueNegatives=0;
  double falsePositives=0;
  double falseNegatives=0;
  double pixelError=0;
  double n=0;
  for (int i=0; i < labelPix.length; i++) {
    int pix1=(labelPix[i] > 0) ? 1 : 0;
    int pix2=(proposalPix[i] > binaryThreshold) ? 1 : 0;
    int pixMask=maskPixels[i] > 0 ? 1 : 0;
    if (pixMask == 0)     continue;
    if (pix1 == 1) {
      if (pix2 == 1)       truePositives++;
 else       falsePositives++;
    }
 else {
      if (pix2 == 1)       falseNegatives++;
 else       trueNegatives++;
    }
    pixelError+=(pix1 - pix2) * (pix1 - pix2);
    n++;
  }
  if (n > 0)   pixelError/=n;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,pixelError);
}",0.9661016949152542
22726,"/** 
 * Calculate the pixel error and derived statistics between some 2D original labels  and the corresponding proposed labels. Both image are binarized.	 
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param mask 2D image representing the binary mask
 * @param binaryThreshold threshold value to binarize the input images
 * @return classification statistics
 */
public ClassificationStatistics precisionRecallStats(ImageProcessor label,ImageProcessor proposal,ImageProcessor mask,double binaryThreshold){
  float[] labelPix=(float[])label.getPixels();
  float[] proposalPix=(float[])proposal.getPixels();
  float[] maskPixels=(float[])mask.getPixels();
  double truePositives=0;
  double trueNegatives=0;
  double falsePositives=0;
  double falseNegatives=0;
  double pixelError=0;
  double n=0;
  for (int i=0; i < labelPix.length; i++) {
    int pix1=(labelPix[i] > 0) ? 1 : 0;
    int pix2=(proposalPix[i] > binaryThreshold) ? 1 : 0;
    int pixMask=maskPixels[i] > 0 ? 1 : 0;
    if (pixMask == 0)     continue;
    if (pix1 == 1) {
      if (pix2 == 1)       truePositives++;
 else       falsePositives++;
    }
 else {
      if (pix2 == 1)       falseNegatives++;
 else       trueNegatives++;
    }
    pixelError+=(pix1 - pix2) * (pix1 - pix2);
    n++;
  }
  if (n > 0)   pixelError/=n;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,pixelError);
}","/** 
 * Calculate the pixel error and derived statistics between some 2D original labels  and the corresponding proposed labels. Both image are binarized.	 
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param mask 2D image representing the binary mask
 * @param binaryThreshold threshold value to binarize the input images
 * @return classification statistics
 */
public ClassificationStatistics precisionRecallStats(ImageProcessor label,ImageProcessor proposal,ImageProcessor mask,double binaryThreshold){
  float[] labelPix=(float[])label.getPixels();
  float[] proposalPix=(float[])proposal.getPixels();
  float[] maskPixels=(float[])mask.getPixels();
  double truePositives=0;
  double trueNegatives=0;
  double falsePositives=0;
  double falseNegatives=0;
  double pixelError=0;
  double n=0;
  for (int i=0; i < labelPix.length; i++) {
    int pix1=(labelPix[i] > 0) ? 1 : 0;
    int pix2=(proposalPix[i] > binaryThreshold) ? 1 : 0;
    int pixMask=maskPixels[i] > 0 ? 1 : 0;
    if (pixMask == 0)     continue;
    if (pix2 == 1) {
      if (pix1 == 1)       truePositives++;
 else       falsePositives++;
    }
 else {
      if (pix1 == 1)       falseNegatives++;
 else       trueNegatives++;
    }
    pixelError+=(pix1 - pix2) * (pix1 - pix2);
    n++;
  }
  if (n > 0)   pixelError/=n;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,pixelError);
}",0.98433242506812
22727,"/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStackArray.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStackArray.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i < FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
  if (minSigma != this.minimumSigma && minSigma != 0) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStackArray.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStackArray.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  setNumOfClasses(0);
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    setClassLabel(j,className);
    addClass();
    j++;
  }
  final boolean[] oldEnableFeatures=this.featureStackArray.getEnabledFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.featureStackArray.setEnabledFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStackArray.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStackArray.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i < FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
  if (minSigma != this.minimumSigma && minSigma != 0) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStackArray.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStackArray.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  setNumOfClasses(0);
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    setClassLabel(j,className);
    addClass();
    j++;
  }
  final boolean[] oldEnableFeatures=this.featureStackArray.getEnabledFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.setEnabledFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}",0.9973102211595936
22728,"/** 
 * Add Hessian features from original image (single thread version). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue, 2nd eigenvalue, orientation, gamma-normalized square eigenvalue difference and the square of Gamma-normalized eigenvalue difference
 * @param sigma radius of the Gaussian filter to use
 */
public void addHessian(float sigma){
  float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
  float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
  Convolver c=new Convolver();
  GaussianBlur gs=new GaussianBlur();
  ImagePlus[] channels=extractChannels(originalImage);
  ImagePlus[] results=new ImagePlus[channels.length];
  for (int ch=0; ch < channels.length; ch++) {
    ImageProcessor ip_x=channels[ch].getProcessor().convertToFloat();
    gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
    c.convolveFloat(ip_x,sobelFilter_x,3,3);
    ImageProcessor ip_y=channels[ch].getProcessor().convertToFloat();
    gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
    c=new Convolver();
    c.convolveFloat(ip_y,sobelFilter_y,3,3);
    ImageProcessor ip_xx=ip_x.duplicate();
    c.convolveFloat(ip_xx,sobelFilter_x,3,3);
    ImageProcessor ip_xy=ip_x.duplicate();
    c.convolveFloat(ip_xy,sobelFilter_y,3,3);
    ImageProcessor ip_yy=ip_y.duplicate();
    c.convolveFloat(ip_yy,sobelFilter_y,3,3);
    ImageProcessor ip=new FloatProcessor(width,height);
    ImageProcessor ipTr=new FloatProcessor(width,height);
    ImageProcessor ipDet=new FloatProcessor(width,height);
    ImageProcessor ipEig1=new FloatProcessor(width,height);
    ImageProcessor ipEig2=new FloatProcessor(width,height);
    ImageProcessor ipOri=new FloatProcessor(width,height);
    ImageProcessor ipSed=new FloatProcessor(width,height);
    ImageProcessor ipNed=new FloatProcessor(width,height);
    final double t=Math.pow(1,0.75);
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        float s_xx=ip_xx.getf(x,y);
        float s_xy=ip_xy.getf(x,y);
        float s_yy=ip_yy.getf(x,y);
        ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
        final float trace=(float)s_xx + s_yy;
        ipTr.setf(x,y,trace);
        final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
        ipDet.setf(x,y,determinant);
        ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
        ipTr.setf(x,y,(float)s_xx + s_yy);
        ipDet.setf(x,y,(float)s_xx * s_yy - s_xy * s_xy);
        ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
        ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
        if (s_xy < 0.0) {
          float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
          if (Float.isNaN(orientation))           orientation=0;
          ipOri.setf(x,y,orientation);
        }
 else {
          float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
          if (Float.isNaN(orientation))           orientation=0;
          ipOri.setf(x,y,orientation);
        }
        ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
        ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
      }
    }
    ImageStack hessianStack=new ImageStack(width,height);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
    results[ch]=new ImagePlus(""String_Node_Str"",hessianStack);
  }
  ImagePlus merged=mergeResultChannels(results);
  for (int i=1; i <= merged.getImageStackSize(); i++)   wholeStack.addSlice(merged.getImageStack().getSliceLabel(i),merged.getImageStack().getPixels(i));
}","/** 
 * Add Hessian features from original image (single thread version). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue, 2nd eigenvalue, orientation, gamma-normalized square eigenvalue difference and the square of Gamma-normalized eigenvalue difference
 * @param sigma radius of the Gaussian filter to use
 */
public void addHessian(float sigma){
  float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
  float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
  Convolver c=new Convolver();
  GaussianBlur gs=new GaussianBlur();
  ImagePlus[] channels=extractChannels(originalImage);
  ImagePlus[] results=new ImagePlus[channels.length];
  for (int ch=0; ch < channels.length; ch++) {
    ImageProcessor ip_x=channels[ch].getProcessor().duplicate().convertToFloat();
    gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
    c.convolveFloat(ip_x,sobelFilter_x,3,3);
    ImageProcessor ip_y=channels[ch].getProcessor().duplicate().convertToFloat();
    gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
    c=new Convolver();
    c.convolveFloat(ip_y,sobelFilter_y,3,3);
    ImageProcessor ip_xx=ip_x.duplicate();
    c.convolveFloat(ip_xx,sobelFilter_x,3,3);
    ImageProcessor ip_xy=ip_x.duplicate();
    c.convolveFloat(ip_xy,sobelFilter_y,3,3);
    ImageProcessor ip_yy=ip_y.duplicate();
    c.convolveFloat(ip_yy,sobelFilter_y,3,3);
    ImageProcessor ip=new FloatProcessor(width,height);
    ImageProcessor ipTr=new FloatProcessor(width,height);
    ImageProcessor ipDet=new FloatProcessor(width,height);
    ImageProcessor ipEig1=new FloatProcessor(width,height);
    ImageProcessor ipEig2=new FloatProcessor(width,height);
    ImageProcessor ipOri=new FloatProcessor(width,height);
    ImageProcessor ipSed=new FloatProcessor(width,height);
    ImageProcessor ipNed=new FloatProcessor(width,height);
    final double t=Math.pow(1,0.75);
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        float s_xx=ip_xx.getf(x,y);
        float s_xy=ip_xy.getf(x,y);
        float s_yy=ip_yy.getf(x,y);
        ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
        final float trace=(float)s_xx + s_yy;
        ipTr.setf(x,y,trace);
        final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
        ipDet.setf(x,y,determinant);
        ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
        ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
        if (s_xy < 0.0) {
          float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
          if (Float.isNaN(orientation))           orientation=0;
          ipOri.setf(x,y,orientation);
        }
 else {
          float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
          if (Float.isNaN(orientation))           orientation=0;
          ipOri.setf(x,y,orientation);
        }
        ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
        ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
      }
    }
    ImageStack hessianStack=new ImageStack(width,height);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
    hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
    results[ch]=new ImagePlus(""String_Node_Str"",hessianStack);
  }
  ImagePlus merged=mergeResultChannels(results);
  for (int i=1; i <= merged.getImageStackSize(); i++)   wholeStack.addSlice(merged.getImageStack().getSliceLabel(i),merged.getImageStack().getPixels(i));
}",0.9769688799011348
22729,"/** 
 * Get Sobel filter version of the original image (to be called from an ExecutorService)
 * @param originalImage input image
 * @param sigma radius of the Gaussian blur applied previous to the Sobel filtering
 * @return filtered image
 */
public Callable<ImagePlus> getGradient(final ImagePlus originalImage,final float sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ImagePlus[] results=new ImagePlus[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        GaussianBlur gs=new GaussianBlur();
        ImageProcessor ip_x=channels[ch].getProcessor().convertToFloat();
        gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
        Convolver c=new Convolver();
        float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
        c.convolveFloat(ip_x,sobelFilter_x,3,3);
        ImageProcessor ip_y=channels[ch].getProcessor().convertToFloat();
        gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
        c=new Convolver();
        float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
        c.convolveFloat(ip_y,sobelFilter_y,3,3);
        ImageProcessor ip=new FloatProcessor(width,height);
        for (int x=0; x < width; x++) {
          for (int y=0; y < height; y++) {
            float s_x=ip_x.getf(x,y);
            float s_y=ip_y.getf(x,y);
            ip.setf(x,y,(float)Math.sqrt(s_x * s_x + s_y * s_y));
          }
        }
        results[ch]=new ImagePlus(availableFeatures[SOBEL] + ""String_Node_Str"" + sigma,ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get Sobel filter version of the original image (to be called from an ExecutorService)
 * @param originalImage input image
 * @param sigma radius of the Gaussian blur applied previous to the Sobel filtering
 * @return filtered image
 */
public Callable<ImagePlus> getGradient(final ImagePlus originalImage,final float sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      ImagePlus[] channels=extractChannels(originalImage);
      ImagePlus[] results=new ImagePlus[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        GaussianBlur gs=new GaussianBlur();
        ImageProcessor ip_x=channels[ch].getProcessor().duplicate().convertToFloat();
        gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
        Convolver c=new Convolver();
        float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
        c.convolveFloat(ip_x,sobelFilter_x,3,3);
        ImageProcessor ip_y=channels[ch].getProcessor().duplicate().convertToFloat();
        gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
        c=new Convolver();
        float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
        c.convolveFloat(ip_y,sobelFilter_y,3,3);
        ImageProcessor ip=new FloatProcessor(width,height);
        for (int x=0; x < width; x++) {
          for (int y=0; y < height; y++) {
            float s_x=ip_x.getf(x,y);
            float s_y=ip_y.getf(x,y);
            ip.setf(x,y,(float)Math.sqrt(s_x * s_x + s_y * s_y));
          }
        }
        results[ch]=new ImagePlus(availableFeatures[SOBEL] + ""String_Node_Str"" + sigma,ip);
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.992966002344666
22730,"/** 
 * Add Sobel filter version of the original image
 * @param sigma radius of the Gaussian blue applied previous to the Sobel filtering
 */
public void addGradient(float sigma){
  ImagePlus[] channels=extractChannels(originalImage);
  ImagePlus[] results=new ImagePlus[channels.length];
  for (int ch=0; ch < channels.length; ch++) {
    GaussianBlur gs=new GaussianBlur();
    ImageProcessor ip_x=channels[ch].getProcessor().convertToFloat();
    gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
    Convolver c=new Convolver();
    float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
    c.convolveFloat(ip_x,sobelFilter_x,3,3);
    ImageProcessor ip_y=channels[ch].getProcessor().convertToFloat();
    gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
    c=new Convolver();
    float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
    c.convolveFloat(ip_y,sobelFilter_y,3,3);
    ImageProcessor ip=new FloatProcessor(width,height);
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        float s_x=ip_x.getf(x,y);
        float s_y=ip_y.getf(x,y);
        ip.setf(x,y,(float)Math.sqrt(s_x * s_x + s_y * s_y));
      }
    }
    results[ch]=new ImagePlus(availableFeatures[SOBEL] + ""String_Node_Str"" + sigma,ip);
  }
  ImagePlus merged=mergeResultChannels(results);
  wholeStack.addSlice(merged.getTitle(),merged.getImageStack().getProcessor(1));
}","/** 
 * Add Sobel filter version of the original image
 * @param sigma radius of the Gaussian blue applied previous to the Sobel filtering
 */
public void addGradient(float sigma){
  ImagePlus[] channels=extractChannels(originalImage);
  ImagePlus[] results=new ImagePlus[channels.length];
  for (int ch=0; ch < channels.length; ch++) {
    GaussianBlur gs=new GaussianBlur();
    ImageProcessor ip_x=channels[ch].getProcessor().duplicate().convertToFloat();
    gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
    Convolver c=new Convolver();
    float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
    c.convolveFloat(ip_x,sobelFilter_x,3,3);
    ImageProcessor ip_y=channels[ch].getProcessor().duplicate().convertToFloat();
    gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
    c=new Convolver();
    float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
    c.convolveFloat(ip_y,sobelFilter_y,3,3);
    ImageProcessor ip=new FloatProcessor(width,height);
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        float s_x=ip_x.getf(x,y);
        float s_y=ip_y.getf(x,y);
        ip.setf(x,y,(float)Math.sqrt(s_x * s_x + s_y * s_y));
      }
    }
    results[ch]=new ImagePlus(availableFeatures[SOBEL] + ""String_Node_Str"" + sigma,ip);
  }
  ImagePlus merged=mergeResultChannels(results);
  wholeStack.addSlice(merged.getTitle(),merged.getImageStack().getProcessor(1));
}",0.9914712153518124
22731,"/** 
 * Get Hessian features from original image (to be submitted in an ExecutorService). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue, 2nd eigenvalue, orientation, gamma-normalized square eigenvalue difference and the square of Gamma-normalized eigenvalue difference
 * @param originalImage input image
 * @param sigma radius of the Gaussian filter to use
 * @return filtered image (stack: hessian, trace, determinant, 1st eigenvalue and 2nd eigenvalue) 
 */
public Callable<ImagePlus> getHessian(final ImagePlus originalImage,final float sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      final int width=originalImage.getWidth();
      final int height=originalImage.getHeight();
      float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
      float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
      Convolver c=new Convolver();
      GaussianBlur gs=new GaussianBlur();
      ImagePlus[] channels=extractChannels(originalImage);
      ImagePlus[] results=new ImagePlus[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        ImageProcessor ip_x=channels[ch].getProcessor().convertToFloat();
        gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
        c.convolveFloat(ip_x,sobelFilter_x,3,3);
        ImageProcessor ip_y=channels[ch].getProcessor().convertToFloat();
        gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
        c=new Convolver();
        c.convolveFloat(ip_y,sobelFilter_y,3,3);
        ImageProcessor ip_xx=ip_x.duplicate();
        c.convolveFloat(ip_xx,sobelFilter_x,3,3);
        ImageProcessor ip_xy=ip_x.duplicate();
        c.convolveFloat(ip_xy,sobelFilter_y,3,3);
        ImageProcessor ip_yy=ip_y.duplicate();
        c.convolveFloat(ip_yy,sobelFilter_y,3,3);
        ImageProcessor ip=new FloatProcessor(width,height);
        ImageProcessor ipTr=new FloatProcessor(width,height);
        ImageProcessor ipDet=new FloatProcessor(width,height);
        ImageProcessor ipEig1=new FloatProcessor(width,height);
        ImageProcessor ipEig2=new FloatProcessor(width,height);
        ImageProcessor ipOri=new FloatProcessor(width,height);
        ImageProcessor ipSed=new FloatProcessor(width,height);
        ImageProcessor ipNed=new FloatProcessor(width,height);
        final double t=Math.pow(1,0.75);
        for (int x=0; x < width; x++) {
          for (int y=0; y < height; y++) {
            float s_xx=ip_xx.getf(x,y);
            float s_xy=ip_xy.getf(x,y);
            float s_yy=ip_yy.getf(x,y);
            ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
            final float trace=(float)s_xx + s_yy;
            ipTr.setf(x,y,trace);
            final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
            ipDet.setf(x,y,determinant);
            ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
            ipTr.setf(x,y,(float)s_xx + s_yy);
            ipDet.setf(x,y,(float)s_xx * s_yy - s_xy * s_xy);
            ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
            ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
            if (s_xy < 0.0) {
              float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
              if (Float.isNaN(orientation))               orientation=0;
              ipOri.setf(x,y,orientation);
            }
 else {
              float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
              if (Float.isNaN(orientation))               orientation=0;
              ipOri.setf(x,y,orientation);
            }
            ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
            ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
          }
        }
        ImageStack hessianStack=new ImageStack(width,height);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
        results[ch]=new ImagePlus(""String_Node_Str"",hessianStack);
      }
      return mergeResultChannels(results);
    }
  }
;
}","/** 
 * Get Hessian features from original image (to be submitted in an ExecutorService). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue, 2nd eigenvalue, orientation, gamma-normalized square eigenvalue difference and the square of Gamma-normalized eigenvalue difference
 * @param originalImage input image
 * @param sigma radius of the Gaussian filter to use
 * @return filtered image (stack: hessian, trace, determinant, 1st eigenvalue and 2nd eigenvalue) 
 */
public Callable<ImagePlus> getHessian(final ImagePlus originalImage,final float sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      final int width=originalImage.getWidth();
      final int height=originalImage.getHeight();
      float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
      float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
      Convolver c=new Convolver();
      GaussianBlur gs=new GaussianBlur();
      ImagePlus[] channels=extractChannels(originalImage);
      ImagePlus[] results=new ImagePlus[channels.length];
      for (int ch=0; ch < channels.length; ch++) {
        ImageProcessor ip_x=channels[ch].getProcessor().duplicate().convertToFloat();
        gs.blurGaussian(ip_x,0.4 * sigma,0.4 * sigma,0.0002);
        c.convolveFloat(ip_x,sobelFilter_x,3,3);
        ImageProcessor ip_y=channels[ch].getProcessor().duplicate().convertToFloat();
        gs.blurGaussian(ip_y,0.4 * sigma,0.4 * sigma,0.0002);
        c=new Convolver();
        c.convolveFloat(ip_y,sobelFilter_y,3,3);
        ImageProcessor ip_xx=ip_x.duplicate();
        c.convolveFloat(ip_xx,sobelFilter_x,3,3);
        ImageProcessor ip_xy=ip_x.duplicate();
        c.convolveFloat(ip_xy,sobelFilter_y,3,3);
        ImageProcessor ip_yy=ip_y.duplicate();
        c.convolveFloat(ip_yy,sobelFilter_y,3,3);
        ImageProcessor ip=new FloatProcessor(width,height);
        ImageProcessor ipTr=new FloatProcessor(width,height);
        ImageProcessor ipDet=new FloatProcessor(width,height);
        ImageProcessor ipEig1=new FloatProcessor(width,height);
        ImageProcessor ipEig2=new FloatProcessor(width,height);
        ImageProcessor ipOri=new FloatProcessor(width,height);
        ImageProcessor ipSed=new FloatProcessor(width,height);
        ImageProcessor ipNed=new FloatProcessor(width,height);
        final double t=Math.pow(1,0.75);
        for (int x=0; x < width; x++) {
          for (int y=0; y < height; y++) {
            float s_xx=ip_xx.getf(x,y);
            float s_xy=ip_xy.getf(x,y);
            float s_yy=ip_yy.getf(x,y);
            ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
            final float trace=(float)s_xx + s_yy;
            ipTr.setf(x,y,trace);
            final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
            ipDet.setf(x,y,determinant);
            ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
            ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
            if (s_xy < 0.0) {
              float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
              if (Float.isNaN(orientation))               orientation=0;
              ipOri.setf(x,y,orientation);
            }
 else {
              float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
              if (Float.isNaN(orientation))               orientation=0;
              ipOri.setf(x,y,orientation);
            }
            ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
            ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
          }
        }
        ImageStack hessianStack=new ImageStack(width,height);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
        hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
        results[ch]=new ImagePlus(""String_Node_Str"",hessianStack);
      }
      return mergeResultChannels(results);
    }
  }
;
}",0.9783108445777112
22732,"/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component. Otherwise the Rand index gets symmetric. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public ClassificationStatistics getRandIndexStats(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  }
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double nNegCorrect=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double trueNegatives=nNegCorrect;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - nNegCorrect;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}","/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component of the ground truth, which leads to an asymmetric index. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 ground truth, 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 prediction, 2D segmented image (objects are labeled with different numbers)
 * @return Rand index value and prediction statistics
 */
public ClassificationStatistics getRandIndexStats(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  }
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - trueNegatives;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}",0.8089131805759933
22733,"/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component. Otherwise the Rand index gets symmetric. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public double randIndex(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1) / 2;
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return randIndex;
}","/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component in  the ground truth (cluster 1). BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 ground truth, 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 prediction, 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public double randIndex(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1) / 2;
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double trueNegatives=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return randIndex;
}",0.941871921182266
22734,"/** 
 * Calculate the pixel error and derived statistics between some 2D original labels  and the corresponding proposed labels. Both image are binarized.	 
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param mask 2D image representing the binary mask
 * @param binaryThreshold threshold value to binarize the input images
 * @return classification statistics
 */
public ClassificationStatistics precisionRecallStats(ImageProcessor label,ImageProcessor proposal,ImageProcessor mask,double binaryThreshold){
  float[] labelPix=(float[])label.getPixels();
  float[] proposalPix=(float[])proposal.getPixels();
  float[] maskPixels=(float[])mask.getPixels();
  double truePositives=0;
  double trueNegatives=0;
  double falsePositives=0;
  double falseNegatives=0;
  double pixelError=0;
  double n=0;
  for (int i=0; i < labelPix.length; i++) {
    int pix1=(labelPix[i] > 0) ? 1 : 0;
    int pix2=(proposalPix[i] > binaryThreshold) ? 1 : 0;
    if (maskPixels[i] > 0)     continue;
    if (pix2 == 1) {
      if (pix1 == 1)       truePositives++;
 else       falsePositives++;
    }
 else {
      if (pix1 == 1)       falseNegatives++;
 else       trueNegatives++;
    }
    pixelError+=(pix1 - pix2) * (pix1 - pix2);
    n++;
  }
  if (n > 0)   pixelError/=n;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,pixelError);
}","/** 
 * Calculate the pixel error and derived statistics between some 2D original labels  and the corresponding proposed labels. Both image are binarized.	 
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param mask 2D image representing the binary mask
 * @param binaryThreshold threshold value to binarize the input images
 * @return classification statistics
 */
public ClassificationStatistics precisionRecallStats(ImageProcessor label,ImageProcessor proposal,ImageProcessor mask,double binaryThreshold){
  float[] labelPix=(float[])label.getPixels();
  float[] proposalPix=(float[])proposal.getPixels();
  float[] maskPixels=(float[])mask.getPixels();
  double truePositives=0;
  double trueNegatives=0;
  double falsePositives=0;
  double falseNegatives=0;
  double pixelError=0;
  double n=0;
  for (int i=0; i < labelPix.length; i++) {
    int pix1=(labelPix[i] > 0) ? 1 : 0;
    int pix2=(proposalPix[i] > binaryThreshold) ? 1 : 0;
    if (maskPixels[i] > 0) {
      if (pix2 == 1) {
        if (pix1 == 1)         truePositives++;
 else         falsePositives++;
      }
 else {
        if (pix1 == 1)         falseNegatives++;
 else         trueNegatives++;
      }
      pixelError+=(pix1 - pix2) * (pix1 - pix2);
      n++;
    }
  }
  if (n > 0)   pixelError/=n;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,pixelError);
}",0.9847009735744088
22735,"/** 
 * Filter small objects and holes at a specific threshold value
 * @param probabilityMap probability image
 * @param thresholdValue threshold to use
 * @param minSize minimum size of the objects (in pixels)
 */
public static void filterSmallObjectsAndHoles(FloatProcessor probabilityMap,double thresholdValue,int minSize){
  ByteProcessor thresholded=threshold(probabilityMap,thresholdValue);
  Results res=connectedComponents(new ImagePlus(""String_Node_Str"",thresholded),4,minSize);
  ByteProcessor th=threshold(res.allRegions.getProcessor(),0.5);
  ByteProcessor th2=(ByteProcessor)th.duplicate();
  th2.copyBits(thresholded,0,0,Blitter.DIFFERENCE);
  for (int x=0; x < th2.getWidth(); x++)   for (int y=0; y < th2.getHeight(); y++) {
    if (th2.getPixelValue(x,y) > 0)     probabilityMap.putPixelValue(x,y,0);
  }
  fill(th,255,0);
  th2=(ByteProcessor)th.duplicate();
  th2.copyBits(thresholded,0,0,Blitter.DIFFERENCE);
  for (int x=0; x < th2.getWidth(); x++)   for (int y=0; y < th2.getHeight(); y++) {
    if (th2.getPixelValue(x,y) > 0)     probabilityMap.putPixelValue(x,y,1);
  }
}","/** 
 * Filter small objects and holes at a specific threshold value
 * @param probabilityMap probability image
 * @param thresholdValue threshold to use
 * @param minSize minimum size of the objects (in pixels)
 */
public static void filterSmallObjectsAndHoles(FloatProcessor probabilityMap,double thresholdValue,int minSize){
  ByteProcessor thresholded=threshold(probabilityMap,thresholdValue);
  Results res=connectedComponents(new ImagePlus(""String_Node_Str"",thresholded),4,minSize);
  ByteProcessor th=threshold(res.allRegions.getProcessor(),0.5);
  ByteProcessor th2=(ByteProcessor)th.duplicate();
  th2.copyBits(thresholded,0,0,Blitter.DIFFERENCE);
  byte[] th2pixels=(byte[])th2.getPixels();
  final float[] probPixels=(float[])probabilityMap.getPixels();
  for (int i=0; i < th2pixels.length; i++) {
    if (th2pixels[i] != 0)     probPixels[i]=0;
  }
  th2=(ByteProcessor)th.duplicate();
  fill(th2,255,0);
  th2.copyBits(th,0,0,Blitter.DIFFERENCE);
  th2pixels=(byte[])th2.getPixels();
  for (int i=0; i < th2pixels.length; i++) {
    if (th2pixels[i] != 0)     probPixels[i]=1;
  }
}",0.6885544915640675
22736,"/** 
 * Get the binary class coordinates from a label image (2D image or stack)
 * @param labelImage labels (they can be in any format, black = 0)
 * @param mask binary mask to select the pixels to be extracted
 * @return array with the two lists (black and white) of sample coordinates
 */
public static ArrayList<Point3f>[] getClassCoordinates(ImagePlus labelImage,ImagePlus mask){
  final ArrayList<Point3f>[] classPoints=new ArrayList[2];
  classPoints[0]=new ArrayList<Point3f>();
  classPoints[1]=new ArrayList<Point3f>();
  final int width=labelImage.getWidth();
  final int height=labelImage.getHeight();
  final int size=labelImage.getImageStackSize();
  final boolean useMask=null != mask;
  for (int slice=1; slice <= size; slice++) {
    final float[] labelsPix=(float[])labelImage.getImageStack().getProcessor(slice).convertToFloat().getPixels();
    final float[] maskPix=useMask ? (float[])mask.getImageStack().getProcessor(slice).convertToFloat().getPixels() : null;
    for (int x=0; x < width; x++)     for (int y=0; y < height; y++)     if (useMask && maskPix[x + y * width] > 0) {
      if (labelsPix[x + y * width] != 0)       classPoints[1].add(new Point3f(new float[]{x,y,slice - 1}));
 else       classPoints[0].add(new Point3f(new float[]{x,y,slice - 1}));
    }
  }
  return classPoints;
}","/** 
 * Get the binary class coordinates from a label image (2D image or stack)
 * @param labelImage labels (they can be in any format, black = 0)
 * @param mask binary mask to select the pixels to be extracted
 * @return array with the two lists (black and white) of sample coordinates
 */
public static ArrayList<Point3f>[] getClassCoordinates(ImagePlus labelImage,ImagePlus mask){
  final ArrayList<Point3f>[] classPoints=new ArrayList[2];
  classPoints[0]=new ArrayList<Point3f>();
  classPoints[1]=new ArrayList<Point3f>();
  final int width=labelImage.getWidth();
  final int height=labelImage.getHeight();
  final int size=labelImage.getImageStackSize();
  if (null != mask) {
    for (int slice=1; slice <= size; slice++) {
      final float[] labelsPix=(float[])labelImage.getImageStack().getProcessor(slice).convertToFloat().getPixels();
      final float[] maskPix=(float[])mask.getImageStack().getProcessor(slice).convertToFloat().getPixels();
      for (int x=0; x < width; x++)       for (int y=0; y < height; y++)       if (maskPix[x + y * width] > 0) {
        if (labelsPix[x + y * width] != 0)         classPoints[1].add(new Point3f(new float[]{x,y,slice - 1}));
 else         classPoints[0].add(new Point3f(new float[]{x,y,slice - 1}));
      }
    }
  }
 else {
    for (int slice=1; slice <= size; slice++) {
      final float[] labelsPix=(float[])labelImage.getImageStack().getProcessor(slice).convertToFloat().getPixels();
      for (int x=0; x < width; x++)       for (int y=0; y < height; y++)       if (labelsPix[x + y * width] != 0)       classPoints[1].add(new Point3f(new float[]{x,y,slice - 1}));
 else       classPoints[0].add(new Point3f(new float[]{x,y,slice - 1}));
    }
  }
  return classPoints;
}",0.8038057742782152
22737,"/** 
 * Calculate the pixel error and its derived statistics in 2D between  some original labels and the corresponding proposed labels. Both images  are binarized. 
 * @param binaryThreshold threshold value to binarize proposal (larger than 0 and smaller than 1)
 * @param mask mask image
 * @return pixel error value and derived statistics
 */
public ClassificationStatistics getPrecisionRecallStats(double binaryThreshold,ImagePlus mask){
  final ImageStack labelSlices=originalLabels.getImageStack();
  final ImageStack proposalSlices=proposedLabels.getImageStack();
  double pixelError=0;
  double tp=0;
  double tn=0;
  double fp=0;
  double fn=0;
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<ClassificationStatistics>> futures=new ArrayList<Future<ClassificationStatistics>>();
  try {
    for (int i=1; i <= labelSlices.getSize(); i++) {
      futures.add(exe.submit(getPrecisionRecallStatsConcurrent(labelSlices.getProcessor(i).convertToFloat(),proposalSlices.getProcessor(i).convertToFloat(),(null != mask) ? mask.getImageStack().getProcessor(i) : null,binaryThreshold)));
    }
    for (    Future<ClassificationStatistics> f : futures) {
      ClassificationStatistics cs=f.get();
      pixelError+=cs.metricValue;
      tp+=cs.truePositives;
      tn+=cs.trueNegatives;
      fp+=cs.falsePositives;
      fn+=cs.falseNegatives;
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return new ClassificationStatistics(tp,tn,fp,fn,pixelError / labelSlices.getSize());
}","/** 
 * Calculate the pixel error and its derived statistics in 2D between  some original labels and the corresponding proposed labels. Both images  are binarized. 
 * @param binaryThreshold threshold value to binarize proposal (larger than 0 and smaller than 1)
 * @param mask mask image
 * @return pixel error value and derived statistics
 */
public ClassificationStatistics getPrecisionRecallStats(double binaryThreshold,ImagePlus mask){
  final ImageStack labelSlices=originalLabels.getImageStack();
  final ImageStack proposalSlices=proposedLabels.getImageStack();
  double pixelError=0;
  double tp=0;
  double tn=0;
  double fp=0;
  double fn=0;
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<ClassificationStatistics>> futures=new ArrayList<Future<ClassificationStatistics>>();
  try {
    for (int i=1; i <= labelSlices.getSize(); i++) {
      futures.add(exe.submit(getPrecisionRecallStatsConcurrent(labelSlices.getProcessor(i).convertToFloat(),proposalSlices.getProcessor(i).convertToFloat(),(null != mask) ? mask.getImageStack().getProcessor(i).convertToFloat() : null,binaryThreshold)));
    }
    for (    Future<ClassificationStatistics> f : futures) {
      ClassificationStatistics cs=f.get();
      pixelError+=cs.metricValue;
      tp+=cs.truePositives;
      tn+=cs.trueNegatives;
      fp+=cs.falsePositives;
      fn+=cs.falseNegatives;
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return new ClassificationStatistics(tp,tn,fp,fn,pixelError / labelSlices.getSize());
}",0.9948500454407756
22738,"/** 
 * Get the binary class coordinates from a label image (2D image or stack)
 * @param labelImage labels (they can be in any format, black = 0)
 * @param mask binary mask to select the pixels to be extracted
 * @return array with the two lists (black and white) of sample coordinates
 */
public static ArrayList<Point3f>[] getClassCoordinates(ImagePlus labelImage,ImagePlus mask){
  final ArrayList<Point3f>[] classPoints=new ArrayList[2];
  classPoints[0]=new ArrayList<Point3f>();
  classPoints[1]=new ArrayList<Point3f>();
  final int width=labelImage.getWidth();
  final int height=labelImage.getHeight();
  final int size=labelImage.getImageStackSize();
  final boolean useMask=null != mask;
  for (int slice=1; slice <= size; slice++) {
    final float[] labelsPix=(float[])labelImage.getImageStack().getProcessor(slice).convertToFloat().getPixels();
    final float[] maskPix=useMask ? (float[])labelImage.getImageStack().getProcessor(slice).convertToFloat().getPixels() : null;
    for (int x=0; x < width; x++)     for (int y=0; y < height; y++)     if (useMask && maskPix[x + y * width] > 0) {
      if (labelsPix[x + y * width] > 0)       classPoints[1].add(new Point3f(new float[]{x,y,slice - 1}));
 else       classPoints[0].add(new Point3f(new float[]{x,y,slice - 1}));
    }
  }
  return classPoints;
}","/** 
 * Get the binary class coordinates from a label image (2D image or stack)
 * @param labelImage labels (they can be in any format, black = 0)
 * @param mask binary mask to select the pixels to be extracted
 * @return array with the two lists (black and white) of sample coordinates
 */
public static ArrayList<Point3f>[] getClassCoordinates(ImagePlus labelImage,ImagePlus mask){
  final ArrayList<Point3f>[] classPoints=new ArrayList[2];
  classPoints[0]=new ArrayList<Point3f>();
  classPoints[1]=new ArrayList<Point3f>();
  final int width=labelImage.getWidth();
  final int height=labelImage.getHeight();
  final int size=labelImage.getImageStackSize();
  final boolean useMask=null != mask;
  for (int slice=1; slice <= size; slice++) {
    final float[] labelsPix=(float[])labelImage.getImageStack().getProcessor(slice).convertToFloat().getPixels();
    final float[] maskPix=useMask ? (float[])mask.getImageStack().getProcessor(slice).convertToFloat().getPixels() : null;
    for (int x=0; x < width; x++)     for (int y=0; y < height; y++)     if (useMask && maskPix[x + y * width] > 0) {
      if (labelsPix[x + y * width] != 0)       classPoints[1].add(new Point3f(new float[]{x,y,slice - 1}));
 else       classPoints[0].add(new Point3f(new float[]{x,y,slice - 1}));
    }
  }
  return classPoints;
}",0.9935483870967742
22739,"/** 
 * Update features with current list in a multi-thread fashion
 * @return true if the features are correctly updated 
 */
public boolean updateFeaturesMT(){
  if (Thread.currentThread().isInterrupted())   return false;
  exe=Executors.newFixedThreadPool(Prefs.getThreads());
  wholeStack=new ImageStack(width,height);
  if (originalImage.getType() == ImagePlus.COLOR_RGB)   wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate());
 else   wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate().convertToFloat());
  int finalIndex=0;
  for (int i=0; i < enableFeatures.length; i++)   if (enableFeatures[i])   finalIndex++;
  final ArrayList<Future<ImagePlus>> futures=new ArrayList<Future<ImagePlus>>();
  int currentIndex=0;
  IJ.showStatus(""String_Node_Str"");
  try {
    if (enableFeatures[ANISOTROPIC_DIFFUSION]) {
      for (float i=minimumSigma; i <= maximumSigma; i*=2)       for (float j=0.10f; j < 0.5f; j+=0.25f) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getAnisotropicDiffusion(originalImage,20,20,(int)i,j,0.9f,(float)membraneSize)));
      }
    }
    if (originalImage.getType() == ImagePlus.COLOR_RGB)     futures.add(exe.submit(getHSB(originalImage)));
    if (enableFeatures[BILATERAL]) {
      for (double i=5; i < 20; i*=2)       for (double j=50; j <= 100; j*=2) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getBilateralFilter(originalImage,i,j)));
      }
    }
    if (enableFeatures[LIPSCHITZ]) {
      for (double i=5; i < 30; i+=5) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getLipschitzFilter(originalImage,true,true,i)));
      }
    }
    if (enableFeatures[KUWAHARA]) {
      for (int i=0; i < 3; i++) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getKuwaharaFeatures(originalImage,membranePatchSize,nAngles,i)));
      }
    }
    if (enableFeatures[GABOR]) {
      for (int i=0; i < 2; i++)       for (double gamma=1; gamma >= 0.25; gamma/=2)       for (int frequency=2; frequency < 3; frequency++) {
        if (Thread.currentThread().isInterrupted())         return false;
        final double psi=Math.PI / 2 * i;
        futures.add(exe.submit(getGabor(originalImage,1.0,gamma,psi,frequency,nAngles)));
      }
      for (int i=0; i < 2; i++)       for (double sigma=2.0; sigma <= 4.0; sigma*=2)       for (double gamma=1.0; gamma <= 2.0; gamma*=2)       for (int frequency=2; frequency <= 3; frequency++) {
        if (Thread.currentThread().isInterrupted())         return false;
        final double psi=Math.PI / 2 * i;
        futures.add(exe.submit(getGabor(originalImage,sigma,gamma,psi,frequency,nAngles)));
      }
    }
    if (enableFeatures[SOBEL]) {
      if (Thread.currentThread().isInterrupted())       return false;
      futures.add(exe.submit(getGradient(originalImage,0)));
    }
    if (enableFeatures[HESSIAN]) {
      if (Thread.currentThread().isInterrupted())       return false;
      futures.add(exe.submit(getHessian(originalImage,0)));
    }
    for (float i=minimumSigma; i <= maximumSigma; i*=2) {
      if (Thread.currentThread().isInterrupted())       return false;
      if (enableFeatures[GAUSSIAN]) {
        futures.add(exe.submit(getGaussianBlur(originalImage,i)));
      }
      if (enableFeatures[SOBEL]) {
        futures.add(exe.submit(getGradient(originalImage,i)));
      }
      if (enableFeatures[HESSIAN]) {
        futures.add(exe.submit(getHessian(originalImage,i)));
      }
      if (enableFeatures[DOG]) {
        for (float j=minimumSigma; j < i; j*=2) {
          futures.add(exe.submit(getDoG(originalImage,i,j)));
        }
      }
      if (enableFeatures[VARIANCE]) {
        futures.add(exe.submit(getVariance(originalImage,i)));
      }
      if (enableFeatures[MEAN]) {
        futures.add(exe.submit(getMean(originalImage,i)));
      }
      if (enableFeatures[MINIMUM]) {
        futures.add(exe.submit(getMin(originalImage,i)));
      }
      if (enableFeatures[MAXIMUM]) {
        futures.add(exe.submit(getMax(originalImage,i)));
      }
      if (enableFeatures[MEDIAN]) {
        futures.add(exe.submit(getMedian(originalImage,i)));
      }
      if (enableFeatures[DERIVATIVES]) {
        for (int order=minDerivativeOrder; order <= maxDerivativeOrder; order++)         futures.add(exe.submit(getDerivatives(originalImage,i,order,order)));
      }
      if (enableFeatures[LAPLACIAN]) {
        futures.add(exe.submit(getLaplacian(originalImage,i)));
      }
      if (enableFeatures[STRUCTURE]) {
        for (int integrationScale=1; integrationScale <= 3; integrationScale+=2)         futures.add(exe.submit(getStructure(originalImage,i,integrationScale)));
      }
      if (enableFeatures[ENTROPY]) {
        for (int nBins=32; nBins <= 256; nBins*=2)         futures.add(exe.submit(getEntropy(originalImage,(int)i,nBins)));
      }
    }
    if (enableFeatures[MEMBRANE]) {
      if (Thread.currentThread().isInterrupted())       return false;
      futures.add(exe.submit(getMembraneFeatures(originalImage,membranePatchSize,membraneSize)));
    }
    for (    Future<ImagePlus> f : futures) {
      final ImagePlus res=f.get();
      currentIndex++;
      IJ.showStatus(""String_Node_Str"");
      IJ.showProgress(currentIndex,finalIndex);
      if (res.getImageStackSize() == 1) {
        this.wholeStack.addSlice(res.getTitle(),res.getProcessor());
      }
 else {
        final ImageStack slices=res.getImageStack();
        for (int i=1; i <= slices.getSize(); i++)         this.wholeStack.addSlice(slices.getSliceLabel(i),slices.getProcessor(i));
      }
    }
  }
 catch (  InterruptedException ie) {
    IJ.log(""String_Node_Str"");
    return false;
  }
catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
    return false;
  }
 finally {
    exe.shutdownNow();
  }
  IJ.showProgress(1.0);
  IJ.showStatus(""String_Node_Str"");
  return true;
}","/** 
 * Update features with current list in a multi-thread fashion
 * @return true if the features are correctly updated 
 */
public boolean updateFeaturesMT(){
  if (Thread.currentThread().isInterrupted())   return false;
  exe=Executors.newFixedThreadPool(Prefs.getThreads());
  wholeStack=new ImageStack(width,height);
  if (originalImage.getType() == ImagePlus.COLOR_RGB)   wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate());
 else   wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate().convertToFloat());
  int finalIndex=0;
  for (int i=0; i < enableFeatures.length; i++)   if (enableFeatures[i])   finalIndex++;
  final ArrayList<Future<ImagePlus>> futures=new ArrayList<Future<ImagePlus>>();
  int currentIndex=0;
  IJ.showStatus(""String_Node_Str"");
  try {
    if (enableFeatures[ANISOTROPIC_DIFFUSION]) {
      for (float i=minimumSigma; i <= maximumSigma; i*=2)       for (float j=0.10f; j < 0.5f; j+=0.25f) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getAnisotropicDiffusion(originalImage,20,20,(int)i,j,0.9f,(float)membraneSize)));
      }
    }
    if (originalImage.getType() == ImagePlus.COLOR_RGB)     futures.add(exe.submit(getHSB(originalImage)));
    if (enableFeatures[BILATERAL]) {
      for (double i=5; i < 20; i*=2)       for (double j=50; j <= 100; j*=2) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getBilateralFilter(originalImage,i,j)));
      }
    }
    if (enableFeatures[LIPSCHITZ]) {
      for (double i=5; i < 30; i+=5) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getLipschitzFilter(originalImage,true,true,i)));
      }
    }
    if (enableFeatures[KUWAHARA]) {
      for (int i=0; i < 3; i++) {
        if (Thread.currentThread().isInterrupted())         return false;
        futures.add(exe.submit(getKuwaharaFeatures(originalImage,membranePatchSize,nAngles,i)));
      }
    }
    if (enableFeatures[GABOR]) {
      for (int i=0; i < 2; i++)       for (double gamma=1; gamma >= 0.25; gamma/=2)       for (int frequency=2; frequency < 3; frequency++) {
        if (Thread.currentThread().isInterrupted())         return false;
        final double psi=Math.PI / 2 * i;
        futures.add(exe.submit(getGabor(originalImage,1.0,gamma,psi,frequency,nAngles)));
      }
      for (int i=0; i < 2; i++)       for (double sigma=2.0; sigma <= 4.0; sigma*=2)       for (double gamma=1.0; gamma <= 2.0; gamma*=2)       for (int frequency=2; frequency <= 3; frequency++) {
        if (Thread.currentThread().isInterrupted())         return false;
        final double psi=Math.PI / 2 * i;
        futures.add(exe.submit(getGabor(originalImage,sigma,gamma,psi,frequency,nAngles)));
      }
    }
    if (enableFeatures[SOBEL] && minimumSigma < 2) {
      if (Thread.currentThread().isInterrupted())       return false;
      futures.add(exe.submit(getGradient(originalImage,0)));
    }
    if (enableFeatures[HESSIAN] && minimumSigma < 2) {
      if (Thread.currentThread().isInterrupted())       return false;
      futures.add(exe.submit(getHessian(originalImage,0)));
    }
    for (float i=minimumSigma; i <= maximumSigma; i*=2) {
      if (Thread.currentThread().isInterrupted())       return false;
      if (enableFeatures[GAUSSIAN]) {
        futures.add(exe.submit(getGaussianBlur(originalImage,i)));
      }
      if (enableFeatures[SOBEL]) {
        futures.add(exe.submit(getGradient(originalImage,i)));
      }
      if (enableFeatures[HESSIAN]) {
        futures.add(exe.submit(getHessian(originalImage,i)));
      }
      if (enableFeatures[DOG]) {
        for (float j=minimumSigma; j < i; j*=2) {
          futures.add(exe.submit(getDoG(originalImage,i,j)));
        }
      }
      if (enableFeatures[VARIANCE]) {
        futures.add(exe.submit(getVariance(originalImage,i)));
      }
      if (enableFeatures[MEAN]) {
        futures.add(exe.submit(getMean(originalImage,i)));
      }
      if (enableFeatures[MINIMUM]) {
        futures.add(exe.submit(getMin(originalImage,i)));
      }
      if (enableFeatures[MAXIMUM]) {
        futures.add(exe.submit(getMax(originalImage,i)));
      }
      if (enableFeatures[MEDIAN]) {
        futures.add(exe.submit(getMedian(originalImage,i)));
      }
      if (enableFeatures[DERIVATIVES]) {
        for (int order=minDerivativeOrder; order <= maxDerivativeOrder; order++)         futures.add(exe.submit(getDerivatives(originalImage,i,order,order)));
      }
      if (enableFeatures[LAPLACIAN]) {
        futures.add(exe.submit(getLaplacian(originalImage,i)));
      }
      if (enableFeatures[STRUCTURE]) {
        for (int integrationScale=1; integrationScale <= 3; integrationScale+=2)         futures.add(exe.submit(getStructure(originalImage,i,integrationScale)));
      }
      if (enableFeatures[ENTROPY]) {
        for (int nBins=32; nBins <= 256; nBins*=2)         futures.add(exe.submit(getEntropy(originalImage,(int)i,nBins)));
      }
    }
    if (enableFeatures[MEMBRANE]) {
      if (Thread.currentThread().isInterrupted())       return false;
      futures.add(exe.submit(getMembraneFeatures(originalImage,membranePatchSize,membraneSize)));
    }
    for (    Future<ImagePlus> f : futures) {
      final ImagePlus res=f.get();
      currentIndex++;
      IJ.showStatus(""String_Node_Str"");
      IJ.showProgress(currentIndex,finalIndex);
      if (res.getImageStackSize() == 1) {
        this.wholeStack.addSlice(res.getTitle(),res.getProcessor());
      }
 else {
        final ImageStack slices=res.getImageStack();
        for (int i=1; i <= slices.getSize(); i++)         this.wholeStack.addSlice(slices.getSliceLabel(i),slices.getProcessor(i));
      }
    }
  }
 catch (  InterruptedException ie) {
    IJ.log(""String_Node_Str"");
    return false;
  }
catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
    return false;
  }
 finally {
    exe.shutdownNow();
  }
  IJ.showProgress(1.0);
  IJ.showStatus(""String_Node_Str"");
  return true;
}",0.9967266775777414
22740,"/** 
 * Apply current classifier to a set of feature vectors (given in a feature stack array)
 * @param fsa feature stack array
 * @param numThreads The number of threads to use. Set to zero for auto-detection.
 * @param probabilityMaps probability flag. Tue: probability maps are calculated, false: binary classification 
 * @return result image containing the probability maps or the binary classification
 */
public ImagePlus applyClassifier(final FeatureStackArray fsa,int numThreads,boolean probabilityMaps){
  if (numThreads == 0)   numThreads=Prefs.getThreads();
  ArrayList<String> classNames=null;
  if (null != loadedClassNames)   classNames=loadedClassNames;
 else {
    classNames=new ArrayList<String>();
    for (int j=0; j < trainingImage.getImageStackSize(); j++)     for (int i=0; i < numOfClasses; i++)     if (examples[j].get(i).size() > 0)     if (false == classNames.contains(getClassLabels()[i]))     classNames.add(getClassLabels()[i]);
  }
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= fsa.getNumOfFeatures(); i++) {
    String attString=fsa.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  if (fsa.useNeighborhood())   for (int i=0; i < 8; i++) {
    IJ.log(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    attributes.add(new Attribute(new String(""String_Node_Str"" + (i + 1))));
  }
  attributes.add(new Attribute(""String_Node_Str"",classNames));
  Instances dataInfo=new Instances(""String_Node_Str"",attributes,1);
  dataInfo.setClassIndex(dataInfo.numAttributes() - 1);
  final int numClasses=classNames.size();
  final int numInstances=fsa.getSize() * trainingImage.getWidth() * trainingImage.getHeight();
  final int numChannels=(probabilityMaps ? numClasses : 1);
  final int numSlices=(numChannels * numInstances) / (trainingImage.getWidth() * trainingImage.getHeight());
  IJ.showStatus(""String_Node_Str"");
  final long start=System.currentTimeMillis();
  exe=Executors.newFixedThreadPool(numThreads);
  final double[][][] results=new double[numThreads][][];
  final int partialSize=numInstances / numThreads;
  Future<double[][]> fu[]=new Future[numThreads];
  final AtomicInteger counter=new AtomicInteger();
  for (int i=0; i < numThreads; i++) {
    if (Thread.currentThread().isInterrupted())     return null;
    int first=i * partialSize;
    int size=(i == numThreads - 1) ? numInstances - i * partialSize : partialSize;
    AbstractClassifier classifierCopy=null;
    try {
      if (classifier instanceof FastRandomForest || classifier instanceof RandomForest)       classifierCopy=classifier;
 else       classifierCopy=(AbstractClassifier)(AbstractClassifier.makeCopy(classifier));
    }
 catch (    Exception e) {
      IJ.log(""String_Node_Str"");
      e.printStackTrace();
    }
    fu[i]=exe.submit(classifyInstances(fsa,dataInfo,first,size,classifierCopy,counter,probabilityMaps));
  }
  ScheduledExecutorService monitor=Executors.newScheduledThreadPool(1);
  ScheduledFuture task=monitor.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      IJ.showProgress(counter.get(),numInstances);
    }
  }
,0,1,TimeUnit.SECONDS);
  for (int i=0; i < numThreads; i++) {
    try {
      results[i]=fu[i].get();
    }
 catch (    InterruptedException e) {
      return null;
    }
catch (    ExecutionException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      exe.shutdown();
      task.cancel(true);
      monitor.shutdownNow();
      IJ.showProgress(1);
    }
  }
  exe.shutdown();
  double[][] classificationResult=new double[numChannels][numInstances];
  for (int i=0; i < numThreads; i++)   for (int c=0; c < numChannels; c++)   System.arraycopy(results[i][c],0,classificationResult[c],i * partialSize,results[i][c].length);
  IJ.showProgress(1.0);
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  double[] classifiedSlice=new double[trainingImage.getWidth() * trainingImage.getHeight()];
  final ImageStack classStack=new ImageStack(trainingImage.getWidth(),trainingImage.getHeight());
  for (int i=0; i < numSlices / numChannels; i++) {
    for (int c=0; c < numChannels; c++) {
      System.arraycopy(classificationResult[c],i * (trainingImage.getWidth() * trainingImage.getHeight()),classifiedSlice,0,trainingImage.getWidth() * trainingImage.getHeight());
      ImageProcessor classifiedSliceProcessor=new FloatProcessor(trainingImage.getWidth(),trainingImage.getHeight(),classifiedSlice);
      classStack.addSlice(probabilityMaps ? getClassLabels()[c] : ""String_Node_Str"",classifiedSliceProcessor);
    }
  }
  ImagePlus classImg=new ImagePlus(probabilityMaps ? ""String_Node_Str"" : ""String_Node_Str"",classStack);
  return classImg;
}","/** 
 * Apply current classifier to a set of feature vectors (given in a feature stack array)
 * @param fsa feature stack array
 * @param numThreads The number of threads to use. Set to zero for auto-detection.
 * @param probabilityMaps probability flag. Tue: probability maps are calculated, false: binary classification 
 * @return result image containing the probability maps or the binary classification
 */
public ImagePlus applyClassifier(final FeatureStackArray fsa,int numThreads,boolean probabilityMaps){
  if (numThreads == 0)   numThreads=Prefs.getThreads();
  ArrayList<String> classNames=null;
  if (null != loadedClassNames)   classNames=loadedClassNames;
 else {
    classNames=new ArrayList<String>();
    for (int j=0; j < trainingImage.getImageStackSize(); j++)     for (int i=0; i < numOfClasses; i++)     if (examples[j].get(i).size() > 0)     if (false == classNames.contains(getClassLabels()[i]))     classNames.add(getClassLabels()[i]);
  }
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= fsa.getNumOfFeatures(); i++) {
    String attString=fsa.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  if (fsa.useNeighborhood())   for (int i=0; i < 8; i++) {
    IJ.log(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    attributes.add(new Attribute(new String(""String_Node_Str"" + (i + 1))));
  }
  attributes.add(new Attribute(""String_Node_Str"",classNames));
  Instances dataInfo=new Instances(""String_Node_Str"",attributes,1);
  dataInfo.setClassIndex(dataInfo.numAttributes() - 1);
  final int numClasses=classNames.size();
  final int numInstances=fsa.getSize() * trainingImage.getWidth() * trainingImage.getHeight();
  final int numChannels=(probabilityMaps ? numClasses : 1);
  final int numSlices=(numChannels * numInstances) / (trainingImage.getWidth() * trainingImage.getHeight());
  IJ.showStatus(""String_Node_Str"");
  final long start=System.currentTimeMillis();
  exe=Executors.newFixedThreadPool(numThreads);
  final double[][][] results=new double[numThreads][][];
  final int partialSize=numInstances / numThreads;
  Future<double[][]> fu[]=new Future[numThreads];
  final AtomicInteger counter=new AtomicInteger();
  for (int i=0; i < numThreads; i++) {
    if (Thread.currentThread().isInterrupted())     return null;
    int first=i * partialSize;
    int size=(i == numThreads - 1) ? numInstances - i * partialSize : partialSize;
    AbstractClassifier classifierCopy=null;
    try {
      classifierCopy=(AbstractClassifier)(AbstractClassifier.makeCopy(classifier));
    }
 catch (    Exception e) {
      IJ.log(""String_Node_Str"");
      e.printStackTrace();
    }
    fu[i]=exe.submit(classifyInstances(fsa,dataInfo,first,size,classifierCopy,counter,probabilityMaps));
  }
  ScheduledExecutorService monitor=Executors.newScheduledThreadPool(1);
  ScheduledFuture task=monitor.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      IJ.showProgress(counter.get(),numInstances);
    }
  }
,0,1,TimeUnit.SECONDS);
  for (int i=0; i < numThreads; i++) {
    try {
      results[i]=fu[i].get();
    }
 catch (    InterruptedException e) {
      return null;
    }
catch (    ExecutionException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      exe.shutdown();
      task.cancel(true);
      monitor.shutdownNow();
      IJ.showProgress(1);
    }
  }
  exe.shutdown();
  double[][] classificationResult=new double[numChannels][numInstances];
  for (int i=0; i < numThreads; i++)   for (int c=0; c < numChannels; c++)   System.arraycopy(results[i][c],0,classificationResult[c],i * partialSize,results[i][c].length);
  IJ.showProgress(1.0);
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  double[] classifiedSlice=new double[trainingImage.getWidth() * trainingImage.getHeight()];
  final ImageStack classStack=new ImageStack(trainingImage.getWidth(),trainingImage.getHeight());
  for (int i=0; i < numSlices / numChannels; i++) {
    for (int c=0; c < numChannels; c++) {
      System.arraycopy(classificationResult[c],i * (trainingImage.getWidth() * trainingImage.getHeight()),classifiedSlice,0,trainingImage.getWidth() * trainingImage.getHeight());
      ImageProcessor classifiedSliceProcessor=new FloatProcessor(trainingImage.getWidth(),trainingImage.getHeight(),classifiedSlice);
      classStack.addSlice(probabilityMaps ? getClassLabels()[c] : ""String_Node_Str"",classifiedSliceProcessor);
    }
  }
  ImagePlus classImg=new ImagePlus(probabilityMaps ? ""String_Node_Str"" : ""String_Node_Str"",classStack);
  return classImg;
}",0.9864185648593732
22741,"/** 
 * Create training instances out of the user markings
 * @return set of instances (feature vectors in Weka format)
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStackArray.getNumOfFeatures(); i++) {
    String attString=featureStackArray.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes;
  int numOfInstances=0;
  int numOfUsedClasses=0;
  if (null == this.loadedTrainingData) {
    classes=new ArrayList<String>();
    for (int i=0; i < numOfClasses; i++) {
      for (int n=0; n < trainingImage.getImageStackSize(); n++) {
        if (examples[n].get(i).size() > 0) {
          if (classes.contains(getClassLabels()[i]) == false)           classes.add(getClassLabels()[i]);
          numOfUsedClasses++;
        }
        numOfInstances+=examples[n].get(i).size();
      }
    }
  }
 else {
    classes=this.loadedClassNames;
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  final boolean colorFeatures=this.trainingImage.getType() == ImagePlus.COLOR_RGB;
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int sliceNum=1; sliceNum <= trainingImage.getImageStackSize(); sliceNum++)     for (int j=0; j < examples[sliceNum - 1].get(l).size(); j++) {
      Roi r=examples[sliceNum - 1].get(l).get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
            if (colorFeatures)             for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)             values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixel(x[i],y[i]);
 else             for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)             values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStackArray.getNumOfFeatures()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStackArray.get(sliceNum - 1).getWidth() && y >= 0 && y < featureStackArray.get(sliceNum - 1).getHeight()) {
                double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
                if (colorFeatures)                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelInterpolated(x,y);
 else                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getInterpolatedValue(x,y);
                values[featureStackArray.getNumOfFeatures()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
          if (colorFeatures)           for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)           values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixel(x,y);
 else           for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)           values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x,y);
          values[featureStackArray.getNumOfFeatures()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + getClassLabels()[l] + ""String_Node_Str""+ nl);
  }
  if (trainingData.numInstances() == 0)   return null;
  trainingData.setClassIndex(featureStackArray.getNumOfFeatures());
  return trainingData;
}","/** 
 * Create training instances out of the user markings
 * @return set of instances (feature vectors in Weka format)
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStackArray.getNumOfFeatures(); i++) {
    String attString=featureStackArray.getLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes;
  int numOfInstances=0;
  int numOfUsedClasses=0;
  if (null == this.loadedTrainingData) {
    classes=new ArrayList<String>();
    for (int i=0; i < numOfClasses; i++) {
      for (int n=0; n < trainingImage.getImageStackSize(); n++) {
        if (examples[n].get(i).size() > 0) {
          if (classes.contains(getClassLabels()[i]) == false)           classes.add(getClassLabels()[i]);
          numOfUsedClasses++;
        }
        numOfInstances+=examples[n].get(i).size();
      }
    }
  }
 else {
    classes=this.loadedClassNames;
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  final boolean colorFeatures=this.trainingImage.getType() == ImagePlus.COLOR_RGB;
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int sliceNum=1; sliceNum <= trainingImage.getImageStackSize(); sliceNum++)     for (int j=0; j < examples[sliceNum - 1].get(l).size(); j++) {
      Roi r=examples[sliceNum - 1].get(l).get(j);
      if (r instanceof PolygonRoi && r.getType() == Roi.FREELINE) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
            if (colorFeatures)             for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)             values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixel(x[i],y[i]);
 else             for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)             values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStackArray.getNumOfFeatures()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStackArray.get(sliceNum - 1).getWidth() && y >= 0 && y < featureStackArray.get(sliceNum - 1).getHeight()) {
                double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
                if (colorFeatures)                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelInterpolated(x,y);
 else                 for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)                 values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getInterpolatedValue(x,y);
                values[featureStackArray.getNumOfFeatures()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStackArray.getNumOfFeatures() + 1];
          if (colorFeatures)           for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)           values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixel(x,y);
 else           for (int z=1; z <= featureStackArray.getNumOfFeatures(); z++)           values[z - 1]=featureStackArray.get(sliceNum - 1).getProcessor(z).getPixelValue(x,y);
          values[featureStackArray.getNumOfFeatures()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + getClassLabels()[l] + ""String_Node_Str""+ nl);
  }
  if (trainingData.numInstances() == 0)   return null;
  trainingData.setClassIndex(featureStackArray.getNumOfFeatures());
  return trainingData;
}",0.9993318698100602
22742,"/** 
 * Get the image with the classified mismatches
 * @param wr warping results
 * @param radius radius in pixels to use while classifying pixels
 * @return image with classified mismatches
 */
public ImagePlus getMismatchImage(WarpingResults wr,int radius){
  int[] mismatchesLabels=classifyMismatches2d(wr.warpedSource,wr.mismatches,radius);
  ByteProcessor bp=new ByteProcessor(wr.warpedSource.getWidth(),wr.warpedSource.getHeight());
  for (int i=0; i < wr.mismatches.size(); i++) {
    Point3f p=wr.mismatches.get(i);
    bp.set((int)p.x,(int)p.y,mismatchesLabels[i]);
  }
  return new ImagePlus(""String_Node_Str"",bp);
}","/** 
 * Get the image with the classified mismatches
 * @param wr warping results
 * @param mismatchesLabels labels of the warping mismatches
 * @return image with classified mismatches
 */
public ImagePlus getMismatchImage(WarpingResults wr,int[] mismatchesLabels,int flags){
  ByteProcessor bp=new ByteProcessor(wr.warpedSource.getWidth(),wr.warpedSource.getHeight());
  for (int i=0; i < wr.mismatches.size(); i++) {
    Point3f p=wr.mismatches.get(i);
    bp.set((int)p.x,(int)p.y,mismatchesLabels[i] & flags);
  }
  return new ImagePlus(""String_Node_Str"",bp);
}",0.7812238055322716
22743,"/** 
 * Use simple point relaxation to warp 2D labels into the 2D proposal. Source is only modified at nonzero locations in the mask (multi-thread version)
 * @param binaryThreshold binarization threshold
 * @param calculateMismatchImage boolean flag to calculate mismatch image
 * @param radius radius in pixels to use while classifying mismatches
 * @return warping results for each slice of the source
 */
public WarpingResults[] simplePointWarp2dMT(double binaryThreshold,boolean calculateMismatchImage,int radius){
  final ImageStack sourceSlices=originalLabels.getImageStack();
  final ImageStack targetSlices=proposedLabels.getImageStack();
  final ImageStack maskSlices=(null != mask) ? mask.getImageStack() : null;
  final WarpingResults[] wrs=new WarpingResults[originalLabels.getImageStackSize()];
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<WarpingResults>> futures=new ArrayList<Future<WarpingResults>>();
  try {
    for (int i=1; i <= sourceSlices.getSize(); i++) {
      futures.add(exe.submit(simplePointWarp2DConcurrent(sourceSlices.getProcessor(i).convertToFloat(),targetSlices.getProcessor(i).convertToFloat(),null != maskSlices ? maskSlices.getProcessor(i) : null,binaryThreshold,calculateMismatchImage,radius)));
    }
    int i=0;
    for (    Future<WarpingResults> f : futures) {
      wrs[i]=f.get();
      i++;
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return wrs;
}","/** 
 * Use simple point relaxation to warp 2D labels into the 2D proposal. Source is only modified at nonzero locations in the mask (multi-thread version)
 * @param binaryThreshold binarization threshold
 * @param clusterByError if false, cluster mismatches by type, otherwise cluster them by error and type
 * @param calculateMismatchImage boolean flag to calculate mismatch image
 * @param radius radius in pixels to use while classifying mismatches
 * @return warping results for each slice of the source
 */
public WarpingResults[] simplePointWarp2dMT(double binaryThreshold,boolean clusterByError,boolean calculateMismatchImage,int radius){
  final ImageStack sourceSlices=originalLabels.getImageStack();
  final ImageStack targetSlices=proposedLabels.getImageStack();
  final ImageStack maskSlices=(null != mask) ? mask.getImageStack() : null;
  final WarpingResults[] wrs=new WarpingResults[originalLabels.getImageStackSize()];
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<WarpingResults>> futures=new ArrayList<Future<WarpingResults>>();
  try {
    for (int i=1; i <= sourceSlices.getSize(); i++) {
      futures.add(exe.submit(getWarpingResultsConcurrent(sourceSlices.getProcessor(i).convertToFloat(),targetSlices.getProcessor(i).convertToFloat(),null != maskSlices ? maskSlices.getProcessor(i) : null,binaryThreshold,clusterByError,radius,flags,calculateMismatchImage)));
    }
    int i=0;
    for (    Future<WarpingResults> f : futures) {
      wrs[i]=f.get();
      i++;
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return wrs;
}",0.9433617539585872
22744,"/** 
 * Cluster the result mismatches from the warping so pixels by types of errors.
 * @param mismatchClassification array of classified mismatches
 * @return number of warping mismatches after clustering by type
 */
public ClusteredWarpingMismatches clusterMismatchesByType(int[] mismatchClassification){
  int numOfObjectAdditions=0;
  int numOfHoleDeletions=0;
  int numOfMergers=0;
  int numOfHoleAdditions=0;
  int numOfObjectDeletions=0;
  int numOfSplits=0;
  for (int i=0; i < mismatchClassification.length; i++) {
switch (mismatchClassification[i]) {
case OBJECT_ADDITION:
      numOfObjectAdditions++;
    break;
case HOLE_DELETION:
  numOfHoleDeletions++;
break;
case MERGE:
numOfMergers++;
break;
case HOLE_ADDITION:
numOfHoleAdditions++;
break;
case OBJECT_DELETION:
numOfObjectDeletions++;
break;
case SPLIT:
numOfSplits++;
break;
default :
IJ.log(""String_Node_Str"");
}
}
return new ClusteredWarpingMismatches(numOfObjectAdditions,numOfHoleDeletions,numOfMergers,numOfHoleAdditions,numOfObjectDeletions,numOfSplits);
}","/** 
 * Cluster the result mismatches from the warping by types of errors.
 * @param mismatchClassification array of classified mismatches
 * @return number of warping mismatches after clustering by type
 */
public ClusteredWarpingMismatches clusterMismatchesByType(int[] mismatchClassification){
  int numOfObjectAdditions=0;
  int numOfHoleDeletions=0;
  int numOfMergers=0;
  int numOfHoleAdditions=0;
  int numOfObjectDeletions=0;
  int numOfSplits=0;
  for (int i=0; i < mismatchClassification.length; i++) {
switch (mismatchClassification[i]) {
case OBJECT_ADDITION:
      numOfObjectAdditions++;
    break;
case HOLE_DELETION:
  numOfHoleDeletions++;
break;
case MERGE:
numOfMergers++;
break;
case HOLE_ADDITION:
numOfHoleAdditions++;
break;
case OBJECT_DELETION:
numOfObjectDeletions++;
break;
case SPLIT:
numOfSplits++;
break;
default :
IJ.log(""String_Node_Str"");
}
}
return new ClusteredWarpingMismatches(numOfObjectAdditions,numOfHoleDeletions,numOfMergers,numOfHoleAdditions,numOfObjectDeletions,numOfSplits);
}",0.995136186770428
22745,"public ClusteredWarpingMismatches call(){
  WarpingResults wr=simplePointWarp2d(source,target,mask,binaryThreshold);
  int[] mismatchesLabels=classifyMismatches2d(wr.warpedSource,wr.mismatches,radius);
  if (clusterByError)   return clusterMismatchesByError(wr.warpedSource,wr.mismatches,mismatchesLabels);
 else   return clusterMismatchesByType(mismatchesLabels);
}","public WarpingResults call(){
  WarpingResults wr=simplePointWarp2d(source,target,mask,binaryThreshold);
  int[] mismatchesLabels=classifyMismatches2d(wr.warpedSource,wr.mismatches,radius);
  if (calculateMismatchImage)   wr.classifiedMismatches=getMismatchImage(wr,mismatchesLabels,flags);
  ClusteredWarpingMismatches cwm=null;
  if (clusterByError)   cwm=clusterMismatchesByError(wr.warpedSource,wr.mismatches,mismatchesLabels);
 else   cwm=clusterMismatchesByType(mismatchesLabels);
  double error=0;
  double count=source.getWidth() * source.getHeight();
  if ((flags & HOLE_ADDITION) != 0)   error+=cwm.numOfHoleAdditions;
  if ((flags & HOLE_DELETION) != 0)   error+=cwm.numOfHoleDeletions;
  if ((flags & MERGE) != 0)   error+=cwm.numOfMergers;
  if ((flags & OBJECT_ADDITION) != 0)   error+=cwm.numOfObjectAdditions;
  if ((flags & OBJECT_DELETION) != 0)   error+=cwm.numOfObjectDeletions;
  if ((flags & SPLIT) != 0)   error+=cwm.numOfSplits;
  wr.warpingError=error / count;
  return wr;
}",0.4890190336749634
22746,"/** 
 * Calculate warping error and return the related result images and values.
 * @param binaryThreshold threshold value to binarize proposal (larger than 0 and smaller than 1)
 * @param calculateMismatchImage flag to calculate mismatch image
 * @param radius radius in pixels to use when classifiying mismatches
 * @return total warping error (it counts all type of mismatches as errors)
 */
public WarpingResults getWarpingResults(double binaryThreshold,boolean calculateMismatchImage,int radius){
  if (verbose)   IJ.log(""String_Node_Str"");
  WarpingResults[] wrs=simplePointWarp2dMT(binaryThreshold,calculateMismatchImage,radius);
  if (null == wrs)   return null;
  WarpingResults result=new WarpingResults();
  result.warpingError=0;
  ImageStack is=new ImageStack(originalLabels.getWidth(),originalLabels.getHeight());
  ImageStack is2=calculateMismatchImage ? new ImageStack(originalLabels.getWidth(),originalLabels.getHeight()) : null;
  for (int i=0; i < wrs.length; i++) {
    result.warpingError+=wrs[i].warpingError;
    is.addSlice(""String_Node_Str"" + (i + 1),wrs[i].warpedSource.getProcessor());
    if (calculateMismatchImage)     is2.addSlice(""String_Node_Str"" + (i + 1),wrs[i].classifiedMismatches.getProcessor());
  }
  result.warpedSource=new ImagePlus(""String_Node_Str"",is);
  if (calculateMismatchImage)   result.classifiedMismatches=new ImagePlus(""String_Node_Str"",is2);
  if (wrs.length != 0)   result.warpingError/=wrs.length;
  return result;
}","/** 
 * Calculate warping error and return the related result images and values.
 * @param binaryThreshold threshold value to binarize proposal (larger than 0 and smaller than 1)
 * @param clusterByError if false, cluster topology errors by type, otherwise cluster by type and mistake
 * @param calculateMismatchImage flag to calculate mismatch image
 * @param radius radius in pixels to use when classifiying mismatches
 * @return total warping error (it counts all type of mismatches as errors)
 */
public WarpingResults getWarpingResults(double binaryThreshold,boolean clusterByError,boolean calculateMismatchImage,int radius){
  if (verbose)   IJ.log(""String_Node_Str"");
  WarpingResults[] wrs=simplePointWarp2dMT(binaryThreshold,clusterByError,calculateMismatchImage,radius);
  if (null == wrs)   return null;
  WarpingResults result=new WarpingResults();
  result.warpingError=0;
  ImageStack is=new ImageStack(originalLabels.getWidth(),originalLabels.getHeight());
  ImageStack is2=calculateMismatchImage ? new ImageStack(originalLabels.getWidth(),originalLabels.getHeight()) : null;
  for (int i=0; i < wrs.length; i++) {
    result.warpingError+=wrs[i].warpingError;
    is.addSlice(""String_Node_Str"" + (i + 1),wrs[i].warpedSource.getProcessor());
    if (calculateMismatchImage)     is2.addSlice(""String_Node_Str"" + (i + 1),wrs[i].classifiedMismatches.getProcessor());
  }
  result.warpedSource=new ImagePlus(""String_Node_Str"",is);
  if (calculateMismatchImage)   result.classifiedMismatches=new ImagePlus(""String_Node_Str"",is2);
  if (wrs.length != 0)   result.warpingError/=wrs.length;
  return result;
}",0.9533678756476685
22747,"/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component. Otherwise the Rand index gets symmetric. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public ClassificationStatistics getRandIndexStats(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++)   truePositives+=cont[i][j] * (cont[i][j] - 1) / 2;
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double nNegCorrect=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double trueNegatives=nNegCorrect;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - nNegCorrect;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}","/** 
 * Calculate the Rand index between to clusters, as described by William M. Rand \cite{Rand71}, but pruning out the zero component. Otherwise the Rand index gets symmetric. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846--850}, doi       = {10.2307/2284239) } </pre>
 * @param cluster1 2D segmented image (objects are labeled with different numbers) 
 * @param cluster2 2D segmented image (objects are labeled with different numbers)
 * @return Rand index
 */
public ClassificationStatistics getRandIndexStats(ShortProcessor cluster1,ShortProcessor cluster2){
  final short[] pixels1=(short[])cluster1.getPixels();
  final short[] pixels2=(short[])cluster2.getPixels();
  double nPixels=pixels1.length;
  double n=0;
  cluster1.resetMinAndMax();
  cluster2.resetMinAndMax();
  int[][] cont=new int[(int)cluster1.getMax() + 1][(int)cluster2.getMax() + 1];
  for (int i=0; i < nPixels; i++) {
    cont[pixels1[i]][pixels2[i]]++;
    if (pixels1[i] > 0)     n++;
  }
  double[] ni=new double[cont.length];
  for (int i=1; i < cont.length; i++)   for (int j=0; j < cont[0].length; j++) {
    ni[i]+=cont[i][j];
  }
  double[] nj=new double[cont[0].length];
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    nj[j]+=cont[i][j];
  }
  double truePositives=0;
  for (int j=1; j < cont[0].length; j++)   for (int i=1; i < cont.length; i++) {
    truePositives+=cont[i][j] * (cont[i][j] - 1.0) / 2.0;
  }
  double nPairsTotal=n * (n - 1) / 2;
  double nPosTrue=0;
  for (int k=0; k < ni.length; k++)   nPosTrue+=ni[k] * (ni[k] - 1) / 2;
  double nPosActual=0;
  for (int k=0; k < nj.length; k++)   nPosActual+=nj[k] * (nj[k] - 1) / 2;
  double nNegCorrect=nPairsTotal + truePositives - nPosTrue - nPosActual;
  double trueNegatives=nNegCorrect;
  double falsePositives=nPosActual - truePositives;
  double nNegActual=nPairsTotal - nPosActual;
  double falseNegatives=nNegActual - nNegCorrect;
  double agreements=truePositives + trueNegatives;
  double randIndex=agreements / nPairsTotal;
  return new ClassificationStatistics(truePositives,trueNegatives,falsePositives,falseNegatives,randIndex);
}",0.96771416272062
22748,"/** 
 * Get pixel error between two image in a concurrent way  (to be submitted to an Executor Service). 
 * @param image1 first image
 * @param image2 second image
 * @return pixel error
 */
public static Callable<Double> getPixelErrorConcurrent(final ImageProcessor image1,final ImageProcessor image2){
  return new Callable<Double>(){
    public Double call(){
      double pixelError=0;
      for (int x=0; x < image1.getWidth(); x++)       for (int y=0; y < image2.getWidth(); y++) {
        double pix1=image1.getPixelValue(x,y);
        double pix2=image2.getPixelValue(x,y);
        pixelError+=(pix1 - pix2) * (pix1 - pix2);
      }
      return Math.sqrt(pixelError);
    }
  }
;
}","/** 
 * Get pixel error between two image in a concurrent way  (to be submitted to an Executor Service). 
 * @param image1 first image
 * @param image2 second image
 * @return pixel error
 */
public static Callable<Double> getPixelErrorConcurrent(final ImageProcessor image1,final ImageProcessor image2){
  return new Callable<Double>(){
    public Double call(){
      double pixelError=0;
      for (int x=0; x < image1.getWidth(); x++) {
        for (int y=0; y < image1.getHeight(); y++) {
          double pix1=image1.getPixelValue(x,y);
          double pix2=image2.getPixelValue(x,y);
          pixelError+=(pix1 - pix2) * (pix1 - pix2);
        }
      }
      return Math.sqrt(pixelError / (image1.getWidth() * image1.getHeight()));
    }
  }
;
}",0.9488243430152145
22749,"/** 
 * Calculate the pixel error in 2D between some original labels  and the corresponding proposed labels.
 * @param label original labels (single 2D image or stack)
 * @param proposal proposed new labels (single 2D image or stack of the same as as the original labels)
 * @return pixel error
 */
public static double pixelError(ImagePlus label,ImagePlus proposal){
  if (label.getWidth() != proposal.getWidth() || label.getHeight() != proposal.getHeight() || label.getImageStackSize() != proposal.getImageStackSize()) {
    IJ.log(""String_Node_Str"");
    return -1;
  }
  final ImageStack labelSlices=label.getImageStack();
  final ImageStack proposalSlices=proposal.getImageStack();
  double pixelError=0;
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<Double>> futures=new ArrayList<Future<Double>>();
  try {
    for (int i=1; i <= labelSlices.getSize(); i++) {
      futures.add(exe.submit(getPixelErrorConcurrent(labelSlices.getProcessor(i).convertToFloat(),proposalSlices.getProcessor(i).convertToFloat())));
    }
    for (    Future<Double> f : futures) {
      pixelError+=f.get();
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  final double numPixels=label.getWidth() * label.getHeight() * label.getImageStackSize();
  return pixelError / numPixels;
}","/** 
 * Calculate the pixel error in 2D between some original labels  and the corresponding proposed labels.
 * @param label original labels (single 2D image or stack)
 * @param proposal proposed new labels (single 2D image or stack of the same as as the original labels)
 * @return pixel error
 */
public static double pixelError(ImagePlus label,ImagePlus proposal){
  if (label.getWidth() != proposal.getWidth() || label.getHeight() != proposal.getHeight() || label.getImageStackSize() != proposal.getImageStackSize()) {
    IJ.log(""String_Node_Str"");
    return -1;
  }
  final ImageStack labelSlices=label.getImageStack();
  final ImageStack proposalSlices=proposal.getImageStack();
  double pixelError=0;
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<Double>> futures=new ArrayList<Future<Double>>();
  try {
    for (int i=1; i <= labelSlices.getSize(); i++) {
      futures.add(exe.submit(getPixelErrorConcurrent(labelSlices.getProcessor(i).convertToFloat(),proposalSlices.getProcessor(i).convertToFloat())));
    }
    for (    Future<Double> f : futures) {
      pixelError+=f.get();
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return pixelError;
}",0.9626676332004348
22750,"/** 
 * Get pixel error between two image in a concurrent way  (to be submitted to an Executor Service). 
 * @param image1 first image
 * @param image2 second image
 * @return pixel error
 */
public static Callable<Double> getPixelErrorConcurrent(final ImageProcessor image1,final ImageProcessor image2){
  return new Callable<Double>(){
    public Double call(){
      double pixelError=0;
      for (int x=0; x < image1.getWidth(); x++) {
        for (int y=0; y < image1.getHeight(); y++) {
          double pix1=image1.getPixelValue(x,y);
          double pix2=image2.getPixelValue(x,y);
          pixelError+=(pix1 - pix2) * (pix1 - pix2);
        }
      }
      return Math.sqrt(pixelError / (image1.getWidth() * image1.getHeight()));
    }
  }
;
}","/** 
 * Get pixel error between two image in a concurrent way  (to be submitted to an Executor Service). 
 * @param image1 first image
 * @param image2 second image
 * @return pixel error
 */
public static Callable<Double> getPixelErrorConcurrent(final ImageProcessor image1,final ImageProcessor image2){
  return new Callable<Double>(){
    public Double call(){
      double pixelError=0;
      for (int x=0; x < image1.getWidth(); x++) {
        for (int y=0; y < image1.getHeight(); y++) {
          double pix1=image1.getPixelValue(x,y);
          double pix2=image2.getPixelValue(x,y);
          pixelError+=(pix1 - pix2) * (pix1 - pix2);
        }
      }
      return pixelError / (image1.getWidth() * image1.getHeight());
    }
  }
;
}",0.9299533022014675
22751,"/** 
 * Calculate the pixel error in 2D between some original labels  and the corresponding proposed labels.
 * @param label original labels (single 2D image or stack)
 * @param proposal proposed new labels (single 2D image or stack of the same as as the original labels)
 * @return pixel error
 */
public static double pixelError(ImagePlus label,ImagePlus proposal){
  if (label.getWidth() != proposal.getWidth() || label.getHeight() != proposal.getHeight() || label.getImageStackSize() != proposal.getImageStackSize()) {
    IJ.log(""String_Node_Str"");
    return -1;
  }
  final ImageStack labelSlices=label.getImageStack();
  final ImageStack proposalSlices=proposal.getImageStack();
  double pixelError=0;
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<Double>> futures=new ArrayList<Future<Double>>();
  try {
    for (int i=1; i <= labelSlices.getSize(); i++) {
      futures.add(exe.submit(getPixelErrorConcurrent(labelSlices.getProcessor(i).convertToFloat(),proposalSlices.getProcessor(i).convertToFloat())));
    }
    for (    Future<Double> f : futures) {
      pixelError+=f.get();
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return pixelError;
}","/** 
 * Calculate the pixel error in 2D between some original labels  and the corresponding proposed labels.
 * @param label original labels (single 2D image or stack)
 * @param proposal proposed new labels (single 2D image or stack of the same as as the original labels)
 * @return pixel error
 */
public static double pixelError(ImagePlus label,ImagePlus proposal){
  if (label.getWidth() != proposal.getWidth() || label.getHeight() != proposal.getHeight() || label.getImageStackSize() != proposal.getImageStackSize()) {
    IJ.log(""String_Node_Str"");
    return -1;
  }
  final ImageStack labelSlices=label.getImageStack();
  final ImageStack proposalSlices=proposal.getImageStack();
  double pixelError=0;
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<Double>> futures=new ArrayList<Future<Double>>();
  try {
    for (int i=1; i <= labelSlices.getSize(); i++) {
      futures.add(exe.submit(getPixelErrorConcurrent(labelSlices.getProcessor(i).convertToFloat(),proposalSlices.getProcessor(i).convertToFloat())));
    }
    for (    Future<Double> f : futures) {
      pixelError+=f.get();
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return pixelError / labelSlices.getSize();
}",0.991044776119403
22752,"/** 
 * Calculate the adjusted Rand error between some 2D original labels  and the corresponding proposed labels. Both image are binarized. The adjusted Rand error is defined as the 1 - adjusted Rand index,  as described by William M. Rand \cite{Rand71}. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846–850}, doi       = {10.2307/2284239) } </pre>
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param binaryThreshold threshold value to binarize the input images
 * @return adjusted Rand error
 */
public static double adjustedRandError(ImageProcessor label,ImageProcessor proposal,double binaryThreshold){
  ByteProcessor binaryLabel=new ByteProcessor(label.getWidth(),label.getHeight());
  ByteProcessor binaryProposal=new ByteProcessor(label.getWidth(),label.getHeight());
  for (int x=0; x < label.getWidth(); x++)   for (int y=0; y < label.getHeight(); y++) {
    binaryLabel.set(x,y,label.get(x,y) > 0 ? 255 : 0);
    binaryProposal.set(x,y,proposal.get(x,y) > 0 ? 255 : 0);
  }
  ShortProcessor components1=(ShortProcessor)connectedComponents(new ImagePlus(""String_Node_Str"",binaryLabel),4).allRegions.getProcessor();
  ShortProcessor components2=(ShortProcessor)connectedComponents(new ImagePlus(""String_Node_Str"",binaryProposal),4).allRegions.getProcessor();
  return 1 - adjustedRandIndex(components1,components2);
}","/** 
 * Calculate the adjusted Rand error between some 2D original labels  and the corresponding proposed labels. Both image are binarized. The adjusted Rand error is defined as the 1 - adjusted Rand index,  as described by William M. Rand \cite{Rand71}. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846–850}, doi       = {10.2307/2284239) } </pre>
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param binaryThreshold threshold value to binarize the input images
 * @return adjusted Rand error
 */
public static double adjustedRandError(ImageProcessor label,ImageProcessor proposal,double binaryThreshold){
  ByteProcessor binaryLabel=new ByteProcessor(label.getWidth(),label.getHeight());
  ByteProcessor binaryProposal=new ByteProcessor(proposal.getWidth(),proposal.getHeight());
  for (int x=0; x < label.getWidth(); x++)   for (int y=0; y < label.getHeight(); y++) {
    binaryLabel.set(x,y,label.getPixelValue(x,y) > binaryThreshold ? 255 : 0);
    binaryProposal.set(x,y,proposal.getPixelValue(x,y) > binaryThreshold ? 255 : 0);
  }
  final ImagePlus im1=new ImagePlus(""String_Node_Str"",binaryLabel);
  ShortProcessor components1=(ShortProcessor)connectedComponents(im1,4).allRegions.getProcessor();
  final ImagePlus im2=new ImagePlus(""String_Node_Str"",binaryProposal);
  ShortProcessor components2=(ShortProcessor)connectedComponents(im2,4).allRegions.getProcessor();
  return 1 - adjustedRandIndex(components1,components2);
}",0.8873576992210904
22753,"/** 
 * Calculate the Rand error between some 2D original labels  and the corresponding proposed labels. Both image are binarized. The Rand error is defined as the 1 - Rand index, as described by William M. Rand \cite{Rand71}. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846–850}, doi       = {10.2307/2284239) } </pre>
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param binaryThreshold threshold value to binarize the input images
 * @return Rand error
 */
public static double randError(ImageProcessor label,ImageProcessor proposal,double binaryThreshold){
  ByteProcessor binaryLabel=new ByteProcessor(label.getWidth(),label.getHeight());
  ByteProcessor binaryProposal=new ByteProcessor(label.getWidth(),label.getHeight());
  for (int x=0; x < label.getWidth(); x++)   for (int y=0; y < label.getHeight(); y++) {
    binaryLabel.set(x,y,label.get(x,y) > 0 ? 255 : 0);
    binaryProposal.set(x,y,proposal.get(x,y) > 0 ? 255 : 0);
  }
  ShortProcessor components1=(ShortProcessor)connectedComponents(new ImagePlus(""String_Node_Str"",binaryLabel),4).allRegions.getProcessor();
  ShortProcessor components2=(ShortProcessor)connectedComponents(new ImagePlus(""String_Node_Str"",binaryProposal),4).allRegions.getProcessor();
  return 1 - randIndex(components1,components2);
}","/** 
 * Calculate the Rand error between some 2D original labels  and the corresponding proposed labels. Both image are binarized. The Rand error is defined as the 1 - Rand index, as described by William M. Rand \cite{Rand71}. BibTeX: <pre> &#64;article{Rand71, author    = {William M. Rand}, title     = {Objective criteria for the evaluation of clustering methods}, journal   = {Journal of the American Statistical Association}, year      = {1971}, volume    = {66}, number    = {336}, pages     = {846–850}, doi       = {10.2307/2284239) } </pre>
 * @param label 2D image with the original labels
 * @param proposal 2D image with the proposed labels
 * @param binaryThreshold threshold value to binarize the input images
 * @return Rand error
 */
public static double randError(ImageProcessor label,ImageProcessor proposal,double binaryThreshold){
  ByteProcessor binaryLabel=new ByteProcessor(label.getWidth(),label.getHeight());
  ByteProcessor binaryProposal=new ByteProcessor(label.getWidth(),label.getHeight());
  for (int x=0; x < label.getWidth(); x++)   for (int y=0; y < label.getHeight(); y++) {
    binaryLabel.set(x,y,label.getPixelValue(x,y) > binaryThreshold ? 255 : 0);
    binaryProposal.set(x,y,proposal.getPixelValue(x,y) > binaryThreshold ? 255 : 0);
  }
  ShortProcessor components1=(ShortProcessor)connectedComponents(new ImagePlus(""String_Node_Str"",binaryLabel),4).allRegions.getProcessor();
  ShortProcessor components2=(ShortProcessor)connectedComponents(new ImagePlus(""String_Node_Str"",binaryProposal),4).allRegions.getProcessor();
  return 1 - randIndex(components1,components2);
}",0.9823455233291298
22754,"/** 
 * Merge three image stack into a color stack (doing scaling)
 * @param redChannel image stack representing the red channel 
 * @param greenChannel image stack representing the green channel
 * @param blueChannel image stack representing the blue channel
 * @return RGB merged stack
 */
ImageStack mergeStacks(ImageStack redChannel,ImageStack greenChannel,ImageStack blueChannel){
  final ImageStack colorStack=new ImageStack(redChannel.getWidth(),redChannel.getHeight());
  for (int n=1; n <= redChannel.getSize(); n++) {
    final ByteProcessor red=create8BitImage((FloatProcessor)(redChannel.getProcessor(n)));
    final ByteProcessor green=create8BitImage((FloatProcessor)(greenChannel.getProcessor(n)));
    final ByteProcessor blue=create8BitImage((FloatProcessor)(blueChannel.getProcessor(n)));
    final ColorProcessor cp=new ColorProcessor(redChannel.getWidth(),redChannel.getHeight());
    cp.setRGB((byte[])red.getPixels(),(byte[])green.getPixels(),(byte[])blue.getPixels());
    colorStack.addSlice(redChannel.getSliceLabel(n),cp);
  }
  return colorStack;
}","/** 
 * Merge three image stack into a color stack (no scaling)
 * @param redChannel image stack representing the red channel 
 * @param greenChannel image stack representing the green channel
 * @param blueChannel image stack representing the blue channel
 * @return RGB merged stack
 */
ImageStack mergeStacks(ImageStack redChannel,ImageStack greenChannel,ImageStack blueChannel){
  final ImageStack colorStack=new ImageStack(redChannel.getWidth(),redChannel.getHeight());
  for (int n=1; n <= redChannel.getSize(); n++) {
    final ByteProcessor red=(ByteProcessor)redChannel.getProcessor(n).convertToByte(false);
    final ByteProcessor green=(ByteProcessor)greenChannel.getProcessor(n).convertToByte(false);
    final ByteProcessor blue=(ByteProcessor)blueChannel.getProcessor(n).convertToByte(false);
    final ColorProcessor cp=new ColorProcessor(redChannel.getWidth(),redChannel.getHeight());
    cp.setRGB((byte[])red.getPixels(),(byte[])green.getPixels(),(byte[])blue.getPixels());
    colorStack.addSlice(redChannel.getSliceLabel(n),cp);
  }
  return colorStack;
}",0.8530232558139534
22755,"/** 
 * Calculate the classic topology-preserving warping error in 2D between some original labels and the corresponding proposed labels. Both, original and proposed labels are expected to have float values between 0 and 1.  Otherwise, they will be converted.
 * @param label original labels (single 2D image or stack)
 * @param proposal proposed new labels (single 2D image or stack of the same as as the original labels)
 * @param mask image mask containing in white the areas where warping is allowed (null for not geometrical constraints)
 * @param binaryThreshold threshold value to binarize proposal (larger than 0 and smaller than 1)
 * @return total warping error (it counts all type of mismatches as errors)
 */
public static double warpingError(ImagePlus label,ImagePlus proposal,ImagePlus mask,double binaryThreshold){
  IJ.log(""String_Node_Str"");
  WarpingResults[] wrs=WekaSegmentation.simplePointWarp2dMT(label,proposal,mask,binaryThreshold);
  if (null == wrs)   return -1;
  double error=0;
  double count=label.getWidth() * label.getHeight() * label.getImageStackSize();
  for (int j=0; j < wrs.length; j++)   error+=wrs[j].mismatches.size();
  if (count != 0)   return error / count;
 else   return -1;
}","/** 
 * Calculate the classic topology-preserving warping error in 2D between some original labels and the corresponding proposed labels. Both, original and proposed labels are expected to have float values between 0 and 1.  Otherwise, they will be converted.
 * @param label original labels (single 2D image or stack)
 * @param proposal proposed new labels (single 2D image or stack of the same as as the original labels)
 * @param mask image mask containing in white the areas where warping is allowed (null for not geometrical constraints)
 * @param binaryThreshold threshold value to binarize proposal (larger than 0 and smaller than 1)
 * @return total warping error (it counts all type of mismatches as errors)
 */
public static double warpingError(ImagePlus label,ImagePlus proposal,ImagePlus mask,double binaryThreshold){
  IJ.log(""String_Node_Str"");
  WarpingResults[] wrs=WekaSegmentation.simplePointWarp2dMT(label,proposal,mask,binaryThreshold);
  if (null == wrs)   return -1;
  double error=0;
  double count=label.getWidth() * label.getHeight() * label.getImageStackSize();
  for (int j=0; j < wrs.length; j++)   error+=wrs[j].warpingError;
  if (count != 0)   return error / wrs.length;
 else   return -1;
}",0.9819967266775778
22756,"/** 
 * Use simple point relaxation to warp 2D source into 2D target. Source is only modified at nonzero locations in the mask
 * @param source input 2D image to be relaxed
 * @param target target 2D image
 * @param mask 2D image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image and warping error
 */
public static WarpingResults simplePointWarp2d(final ImageProcessor source,final ImageProcessor target,final ImageProcessor mask,double binaryThreshold){
  if (binaryThreshold < 0 || binaryThreshold > 1)   binaryThreshold=0.5;
  final ImagePlus targetReal;
  final ImagePlus targetBin;
  final ImagePlus sourceReal;
  final ImagePlus maskReal;
  final int width=target.getWidth();
  final int height=target.getHeight();
  ImageProcessor ip=target.createProcessor(width + 2,height + 2);
  ip.insert(target,1,1);
  targetReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  targetBin=new ImagePlus(""String_Node_Str"",ip.duplicate());
  ip=target.createProcessor(width + 2,height + 2);
  ip.insert(source,1,1);
  sourceReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  if (null != mask) {
    ip=target.createProcessor(width + 2,height + 2);
    ip.insert(mask,1,1);
    maskReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  }
 else {
    maskReal=null;
  }
  final float[] sourceRealPix=(float[])sourceReal.getProcessor().getPixels();
  for (int i=0; i < sourceRealPix.length; i++)   if (sourceRealPix[i] > 0)   sourceRealPix[i]=1.0f;
  final float[] targetBinPix=(float[])targetBin.getProcessor().getPixels();
  for (int i=0; i < targetBinPix.length; i++)   targetBinPix[i]=(targetBinPix[i] > binaryThreshold) ? 1.0f : 0.0f;
  double diff=Double.MIN_VALUE;
  double diff_before=0;
  final WarpingResults result=new WarpingResults();
  while (true) {
    ImageProcessor missclass_points_image=sourceReal.getProcessor().duplicate();
    missclass_points_image.copyBits(targetBin.getProcessor(),0,0,Blitter.DIFFERENCE);
    diff_before=diff;
    float pixels[]=(float[])missclass_points_image.getPixels();
    float mask_pixels[]=(null != maskReal) ? (float[])maskReal.getProcessor().getPixels() : new float[pixels.length];
    if (null == maskReal)     Arrays.fill(mask_pixels,1f);
    diff=0;
    for (int k=0; k < pixels.length; k++)     if (pixels[k] != 0 && mask_pixels[k] != 0)     diff++;
    if (diff == diff_before || diff == 0)     break;
    final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
    final float[] realTargetPix=(float[])targetReal.getProcessor().getPixels();
    for (int x=1; x < width + 1; x++)     for (int y=1; y < height + 1; y++) {
      if (pixels[x + y * (width + 2)] != 0 && mask_pixels[x + y * (width + 2)] != 0)       mismatches.add(new Point3f(x,y,(float)Math.abs(realTargetPix[x + y * (width + 2)] - binaryThreshold)));
    }
    Collections.sort(mismatches,new Comparator<Point3f>(){
      public int compare(      Point3f o1,      Point3f o2){
        return (int)((o2.z - o1.z) * 10000);
      }
    }
);
    for (    final Point3f p : mismatches) {
      final int x=(int)p.x;
      final int y=(int)p.y;
      if (p.z < SIMPLE_POINT_THRESHOLD)       continue;
      double[] val=new double[]{sourceRealPix[(x - 1) + (y - 1) * (width + 2)],sourceRealPix[(x) + (y - 1) * (width + 2)],sourceRealPix[(x + 1) + (y - 1) * (width + 2)],sourceRealPix[(x - 1) + (y) * (width + 2)],sourceRealPix[(x) + (y) * (width + 2)],sourceRealPix[(x + 1) + (y) * (width + 2)],sourceRealPix[(x - 1) + (y + 1) * (width + 2)],sourceRealPix[(x) + (y + 1) * (width + 2)],sourceRealPix[(x + 1) + (y + 1) * (width + 2)]};
      final double pix=val[4];
      final ImagePlus patch=new ImagePlus(""String_Node_Str"",new FloatProcessor(3,3,val));
      if (simple2D(patch,4)) {
        sourceRealPix[x + y * (width + 2)]=pix > 0.0 ? 0.0f : 1.0f;
      }
    }
    result.mismatches=mismatches;
  }
  ip=source.createProcessor(width,height);
  ip.insert(sourceReal.getProcessor(),-1,-1);
  sourceReal.setProcessor(ip.duplicate());
  final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
  for (  Point3f p : result.mismatches) {
    mismatches.add(new Point3f(p.x - 1,p.y - 1,p.z));
  }
  result.mismatches=mismatches;
  result.warpedSource=sourceReal;
  result.warpingError=diff / (width * height);
  return result;
}","/** 
 * Use simple point relaxation to warp 2D source into 2D target. Source is only modified at nonzero locations in the mask
 * @param source input 2D image to be relaxed
 * @param target target 2D image
 * @param mask 2D image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image and warping error
 */
public static WarpingResults simplePointWarp2d(final ImageProcessor source,final ImageProcessor target,final ImageProcessor mask,double binaryThreshold){
  if (binaryThreshold < 0 || binaryThreshold > 1)   binaryThreshold=0.5;
  final ImagePlus targetReal;
  final ImagePlus targetBin;
  final ImagePlus sourceReal;
  final ImagePlus maskReal;
  final int width=target.getWidth();
  final int height=target.getHeight();
  ImageProcessor ip=target.createProcessor(width + 2,height + 2);
  ip.insert(target,1,1);
  targetReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  targetBin=new ImagePlus(""String_Node_Str"",ip.duplicate());
  ip=target.createProcessor(width + 2,height + 2);
  ip.insert(source,1,1);
  sourceReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  if (null != mask) {
    ip=target.createProcessor(width + 2,height + 2);
    ip.insert(mask,1,1);
    maskReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  }
 else {
    maskReal=null;
  }
  final float[] sourceRealPix=(float[])sourceReal.getProcessor().getPixels();
  for (int i=0; i < sourceRealPix.length; i++)   if (sourceRealPix[i] > 0)   sourceRealPix[i]=1.0f;
  final float[] targetBinPix=(float[])targetBin.getProcessor().getPixels();
  for (int i=0; i < targetBinPix.length; i++)   targetBinPix[i]=(targetBinPix[i] > binaryThreshold) ? 1.0f : 0.0f;
  double diff=Double.MIN_VALUE;
  double diff_before=0;
  final WarpingResults result=new WarpingResults();
  while (true) {
    ImageProcessor missclass_points_image=sourceReal.getProcessor().duplicate();
    missclass_points_image.copyBits(targetBin.getProcessor(),0,0,Blitter.DIFFERENCE);
    diff_before=diff;
    float pixels[]=(float[])missclass_points_image.getPixels();
    float mask_pixels[]=(null != maskReal) ? (float[])maskReal.getProcessor().getPixels() : new float[pixels.length];
    if (null == maskReal)     Arrays.fill(mask_pixels,1f);
    diff=0;
    for (int k=0; k < pixels.length; k++)     if (pixels[k] != 0 && mask_pixels[k] != 0)     diff++;
    if (diff == 0) {
      result.mismatches=new ArrayList<Point3f>();
      break;
    }
    if (diff == diff_before)     break;
    final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
    final float[] realTargetPix=(float[])targetReal.getProcessor().getPixels();
    for (int x=1; x < width + 1; x++)     for (int y=1; y < height + 1; y++) {
      if (pixels[x + y * (width + 2)] != 0 && mask_pixels[x + y * (width + 2)] != 0)       mismatches.add(new Point3f(x,y,(float)Math.abs(realTargetPix[x + y * (width + 2)] - binaryThreshold)));
    }
    Collections.sort(mismatches,new Comparator<Point3f>(){
      public int compare(      Point3f o1,      Point3f o2){
        return (int)((o2.z - o1.z) * 10000);
      }
    }
);
    for (    final Point3f p : mismatches) {
      final int x=(int)p.x;
      final int y=(int)p.y;
      if (p.z < SIMPLE_POINT_THRESHOLD)       continue;
      double[] val=new double[]{sourceRealPix[(x - 1) + (y - 1) * (width + 2)],sourceRealPix[(x) + (y - 1) * (width + 2)],sourceRealPix[(x + 1) + (y - 1) * (width + 2)],sourceRealPix[(x - 1) + (y) * (width + 2)],sourceRealPix[(x) + (y) * (width + 2)],sourceRealPix[(x + 1) + (y) * (width + 2)],sourceRealPix[(x - 1) + (y + 1) * (width + 2)],sourceRealPix[(x) + (y + 1) * (width + 2)],sourceRealPix[(x + 1) + (y + 1) * (width + 2)]};
      final double pix=val[4];
      final ImagePlus patch=new ImagePlus(""String_Node_Str"",new FloatProcessor(3,3,val));
      if (simple2D(patch,4)) {
        sourceRealPix[x + y * (width + 2)]=pix > 0.0 ? 0.0f : 1.0f;
      }
    }
    result.mismatches=mismatches;
  }
  ip=source.createProcessor(width,height);
  ip.insert(sourceReal.getProcessor(),-1,-1);
  sourceReal.setProcessor(ip.duplicate());
  final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
  for (  Point3f p : result.mismatches) {
    mismatches.add(new Point3f(p.x - 1,p.y - 1,p.z));
  }
  result.mismatches=mismatches;
  result.warpedSource=sourceReal;
  result.warpingError=diff / (width * height);
  return result;
}",0.9881103543806996
22757,"/** 
 * Apply current classifier to set of instances
 * @param data set of instances
 * @param w image width
 * @param h image height
 * @param numThreads The number of threads to use. Set to zero forauto-detection.
 * @return result image
 */
public ImagePlus applyClassifier(final Instances data,int w,int h,int numThreads,boolean probabilityMaps){
  if (numThreads == 0)   numThreads=Runtime.getRuntime().availableProcessors();
  final int numClasses=data.numClasses();
  final int numInstances=data.numInstances();
  final int numChannels=(probabilityMaps ? numClasses : 1);
  final int numSlices=(numChannels * numInstances) / (w * h);
  IJ.showStatus(""String_Node_Str"");
  final long start=System.currentTimeMillis();
  exe=Executors.newFixedThreadPool(numThreads);
  final double[][][] results=new double[numThreads][][];
  final Instances[] partialData=new Instances[numThreads];
  final int partialSize=numInstances / numThreads;
  Future<double[][]> fu[]=new Future[numThreads];
  final AtomicInteger counter=new AtomicInteger();
  for (int i=0; i < numThreads; i++) {
    if (Thread.currentThread().isInterrupted())     return null;
    if (i == numThreads - 1)     partialData[i]=new Instances(data,i * partialSize,numInstances - i * partialSize);
 else     partialData[i]=new Instances(data,i * partialSize,partialSize);
    fu[i]=exe.submit(classifyInstances(partialData[i],classifier,counter,probabilityMaps));
  }
  ScheduledExecutorService monitor=Executors.newScheduledThreadPool(1);
  ScheduledFuture task=monitor.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      IJ.showProgress(counter.get(),numInstances);
    }
  }
,0,1,TimeUnit.SECONDS);
  for (int i=0; i < numThreads; i++) {
    try {
      results[i]=fu[i].get();
    }
 catch (    InterruptedException e) {
      return null;
    }
catch (    ExecutionException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      exe.shutdown();
      task.cancel(true);
      monitor.shutdownNow();
      IJ.showProgress(1);
    }
  }
  exe.shutdown();
  double[][] classificationResult;
  classificationResult=new double[numChannels][numInstances];
  for (int i=0; i < numThreads; i++)   for (int c=0; c < numChannels; c++)   System.arraycopy(results[i][c],0,classificationResult[c],i * partialSize,results[i][c].length);
  IJ.showProgress(1.0);
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  double[] classifiedSlice=new double[w * h];
  final ImageStack classStack=new ImageStack(w,h);
  for (int i=0; i < numSlices / numChannels; i++) {
    for (int c=0; c < numChannels; c++) {
      System.arraycopy(classificationResult[c],i * (w * h),classifiedSlice,0,w * h);
      ImageProcessor classifiedSliceProcessor=new FloatProcessor(w,h,classifiedSlice);
      classStack.addSlice(probabilityMaps ? classLabels[c] : ""String_Node_Str"",classifiedSliceProcessor);
    }
  }
  ImagePlus classImg=new ImagePlus(probabilityMaps ? ""String_Node_Str"" : ""String_Node_Str"",classStack);
  return classImg;
}","/** 
 * Apply current classifier to set of instances
 * @param data set of instances
 * @param w image width
 * @param h image height
 * @param numThreads The number of threads to use. Set to zero forauto-detection.
 * @return result image
 */
public ImagePlus applyClassifier(final Instances data,int w,int h,int numThreads,boolean probabilityMaps){
  if (numThreads == 0)   numThreads=Runtime.getRuntime().availableProcessors();
  final int numClasses=data.numClasses();
  final int numInstances=data.numInstances();
  final int numChannels=(probabilityMaps ? numClasses : 1);
  final int numSlices=(numChannels * numInstances) / (w * h);
  IJ.showStatus(""String_Node_Str"");
  final long start=System.currentTimeMillis();
  exe=Executors.newFixedThreadPool(numThreads);
  final double[][][] results=new double[numThreads][][];
  final Instances[] partialData=new Instances[numThreads];
  final int partialSize=numInstances / numThreads;
  Future<double[][]> fu[]=new Future[numThreads];
  final AtomicInteger counter=new AtomicInteger();
  for (int i=0; i < numThreads; i++) {
    if (Thread.currentThread().isInterrupted())     return null;
    if (i == numThreads - 1)     partialData[i]=new Instances(data,i * partialSize,numInstances - i * partialSize);
 else     partialData[i]=new Instances(data,i * partialSize,partialSize);
    AbstractClassifier classifierCopy=null;
    try {
      classifierCopy=(AbstractClassifier)(AbstractClassifier.makeCopy(classifier));
    }
 catch (    Exception e) {
      IJ.log(""String_Node_Str"");
      e.printStackTrace();
    }
    fu[i]=exe.submit(classifyInstances(partialData[i],classifierCopy,counter,probabilityMaps));
  }
  ScheduledExecutorService monitor=Executors.newScheduledThreadPool(1);
  ScheduledFuture task=monitor.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      IJ.showProgress(counter.get(),numInstances);
    }
  }
,0,1,TimeUnit.SECONDS);
  for (int i=0; i < numThreads; i++) {
    try {
      results[i]=fu[i].get();
    }
 catch (    InterruptedException e) {
      return null;
    }
catch (    ExecutionException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      exe.shutdown();
      task.cancel(true);
      monitor.shutdownNow();
      IJ.showProgress(1);
    }
  }
  exe.shutdown();
  double[][] classificationResult;
  classificationResult=new double[numChannels][numInstances];
  for (int i=0; i < numThreads; i++)   for (int c=0; c < numChannels; c++)   System.arraycopy(results[i][c],0,classificationResult[c],i * partialSize,results[i][c].length);
  IJ.showProgress(1.0);
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  double[] classifiedSlice=new double[w * h];
  final ImageStack classStack=new ImageStack(w,h);
  for (int i=0; i < numSlices / numChannels; i++) {
    for (int c=0; c < numChannels; c++) {
      System.arraycopy(classificationResult[c],i * (w * h),classifiedSlice,0,w * h);
      ImageProcessor classifiedSliceProcessor=new FloatProcessor(w,h,classifiedSlice);
      classStack.addSlice(probabilityMaps ? classLabels[c] : ""String_Node_Str"",classifiedSliceProcessor);
    }
  }
  ImagePlus classImg=new ImagePlus(probabilityMaps ? ""String_Node_Str"" : ""String_Node_Str"",classStack);
  return classImg;
}",0.9621485786084498
22758,"/** 
 * Classify instance concurrently
 * @param data set of instances to classify
 * @param classifier current classifier
 * @param probabilityMaps return a probability map for each class instead of aclassified image
 * @return classification result
 */
private static Callable<double[][]> classifyInstances(final Instances data,final AbstractClassifier classifier,final AtomicInteger counter,final boolean probabilityMaps){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<double[][]>(){
    public double[][] call(){
      final int numInstances=data.numInstances();
      final int numClasses=data.numClasses();
      final double[][] classificationResult;
      if (probabilityMaps)       classificationResult=new double[numClasses][numInstances];
 else       classificationResult=new double[1][numInstances];
      for (int i=0; i < numInstances; i++) {
        try {
          if (0 == i % 4000) {
            if (Thread.currentThread().isInterrupted())             return null;
            counter.addAndGet(4000);
          }
          if (probabilityMaps) {
            double[] prob=classifier.distributionForInstance(data.get(i));
            for (int k=0; k < numClasses; k++)             classificationResult[k][i]=prob[k];
          }
 else {
            if (null == data.get(i))             IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
 else             classificationResult[0][i]=classifier.classifyInstance(data.get(i));
          }
        }
 catch (        Exception e) {
          IJ.showMessage(""String_Node_Str"");
          e.printStackTrace();
          return null;
        }
      }
      return classificationResult;
    }
  }
;
}","/** 
 * Classify instance concurrently
 * @param data set of instances to classify
 * @param classifier current classifier
 * @param probabilityMaps return a probability map for each class instead of aclassified image
 * @return classification result
 */
private static Callable<double[][]> classifyInstances(final Instances data,final AbstractClassifier classifier,final AtomicInteger counter,final boolean probabilityMaps){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<double[][]>(){
    public double[][] call(){
      final int numInstances=data.numInstances();
      final int numClasses=data.numClasses();
      final double[][] classificationResult;
      if (probabilityMaps)       classificationResult=new double[numClasses][numInstances];
 else       classificationResult=new double[1][numInstances];
      for (int i=0; i < numInstances; i++) {
        try {
          if (0 == i % 4000) {
            if (Thread.currentThread().isInterrupted())             return null;
            counter.addAndGet(4000);
          }
          if (probabilityMaps) {
            double[] prob=classifier.distributionForInstance(data.get(i));
            for (int k=0; k < numClasses; k++)             classificationResult[k][i]=prob[k];
          }
 else {
            classificationResult[0][i]=classifier.classifyInstance(data.get(i));
          }
        }
 catch (        Exception e) {
          IJ.showMessage(""String_Node_Str"");
          e.printStackTrace();
          return null;
        }
      }
      return classificationResult;
    }
  }
;
}",0.8953771289537713
22759,"public double[][] call(){
  final int numInstances=data.numInstances();
  final int numClasses=data.numClasses();
  final double[][] classificationResult;
  if (probabilityMaps)   classificationResult=new double[numClasses][numInstances];
 else   classificationResult=new double[1][numInstances];
  for (int i=0; i < numInstances; i++) {
    try {
      if (0 == i % 4000) {
        if (Thread.currentThread().isInterrupted())         return null;
        counter.addAndGet(4000);
      }
      if (probabilityMaps) {
        double[] prob=classifier.distributionForInstance(data.get(i));
        for (int k=0; k < numClasses; k++)         classificationResult[k][i]=prob[k];
      }
 else {
        if (null == data.get(i))         IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
 else         classificationResult[0][i]=classifier.classifyInstance(data.get(i));
      }
    }
 catch (    Exception e) {
      IJ.showMessage(""String_Node_Str"");
      e.printStackTrace();
      return null;
    }
  }
  return classificationResult;
}","public double[][] call(){
  final int numInstances=data.numInstances();
  final int numClasses=data.numClasses();
  final double[][] classificationResult;
  if (probabilityMaps)   classificationResult=new double[numClasses][numInstances];
 else   classificationResult=new double[1][numInstances];
  for (int i=0; i < numInstances; i++) {
    try {
      if (0 == i % 4000) {
        if (Thread.currentThread().isInterrupted())         return null;
        counter.addAndGet(4000);
      }
      if (probabilityMaps) {
        double[] prob=classifier.distributionForInstance(data.get(i));
        for (int k=0; k < numClasses; k++)         classificationResult[k][i]=prob[k];
      }
 else {
        classificationResult[0][i]=classifier.classifyInstance(data.get(i));
      }
    }
 catch (    Exception e) {
      IJ.showMessage(""String_Node_Str"");
      e.printStackTrace();
      return null;
    }
  }
  return classificationResult;
}",0.8410931174089069
22760,"/** 
 * Show advanced settings dialog
 * @return false when canceled
 */
public boolean showSettingsDialog(){
  GenericDialogPlus gd=new GenericDialogPlus(""String_Node_Str"");
  final boolean[] oldEnableFeatures=wekaSegmentation.getEnabledFeatures();
  gd.addMessage(""String_Node_Str"");
  final int rows=(int)Math.round(FeatureStack.availableFeatures.length / 2.0);
  gd.addCheckboxGroup(rows,2,FeatureStack.availableFeatures,oldEnableFeatures);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final Vector<Checkbox> v=gd.getCheckboxes();
    for (    Checkbox c : v)     c.setEnabled(false);
    gd.addMessage(""String_Node_Str"");
  }
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembraneThickness(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembranePatchSize(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMinimumSigma(),1);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMaximumSigma(),1);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    for (int i=0; i < 4; i++)     ((TextField)gd.getNumericFields().get(i)).setEnabled(false);
  }
  gd.addMessage(""String_Node_Str"");
  GenericObjectEditor m_ClassifierEditor=new GenericObjectEditor();
  PropertyPanel m_CEPanel=new PropertyPanel(m_ClassifierEditor);
  m_ClassifierEditor.setClassType(Classifier.class);
  m_ClassifierEditor.setValue(wekaSegmentation.getClassifier());
  gd.addComponent(m_CEPanel,GridBagConstraints.HORIZONTAL,1);
  Object c=(Object)m_ClassifierEditor.getValue();
  String originalOptions=""String_Node_Str"";
  String originalClassifierName=c.getClass().getName();
  if (c instanceof OptionHandler) {
    originalOptions=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  gd.addMessage(""String_Node_Str"");
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)   gd.addStringField(""String_Node_Str"" + (i + 1),wekaSegmentation.getClassLabel(i),15);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",wekaSegmentation.doHomogenizeClasses());
  gd.addButton(""String_Node_Str"",new SaveFeatureStackButtonListener(""String_Node_Str"",wekaSegmentation.getFeatureStackArray()));
  gd.addSlider(""String_Node_Str"",0,100,win.overlayOpacity);
  gd.addHelp(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return false;
  final int numOfFeatures=FeatureStack.availableFeatures.length;
  final boolean[] newEnableFeatures=new boolean[numOfFeatures];
  boolean featuresChanged=false;
  for (int i=0; i < numOfFeatures; i++) {
    newEnableFeatures[i]=gd.getNextBoolean();
    if (newEnableFeatures[i] != oldEnableFeatures[i]) {
      featuresChanged=true;
      record(SET_FEATURE,new String[]{FeatureStack.availableFeatures[i] + ""String_Node_Str"" + newEnableFeatures[i]});
    }
  }
  if (featuresChanged) {
    wekaSegmentation.setEnabledFeatures(newEnableFeatures);
  }
  final int newThickness=(int)gd.getNextNumber();
  if (newThickness != wekaSegmentation.getMembraneThickness()) {
    featuresChanged=true;
    wekaSegmentation.setMembraneThickness(newThickness);
    record(SET_MEMBRANE_THICKNESS,new String[]{Integer.toString(newThickness)});
  }
  final int newPatch=(int)gd.getNextNumber();
  if (newPatch != wekaSegmentation.getMembranePatchSize()) {
    featuresChanged=true;
    record(SET_MEMBRANE_PATCH,new String[]{Integer.toString(newPatch)});
    wekaSegmentation.setMembranePatchSize(newPatch);
  }
  final float newMinSigma=(float)gd.getNextNumber();
  if (newMinSigma != wekaSegmentation.getMinimumSigma() && newMinSigma > 0) {
    featuresChanged=true;
    record(SET_MINIMUM_SIGMA,new String[]{Float.toString(newMinSigma)});
    wekaSegmentation.setMinimumSigma(newMinSigma);
  }
  final float newMaxSigma=(float)gd.getNextNumber();
  if (newMaxSigma != wekaSegmentation.getMaximumSigma() && newMaxSigma > wekaSegmentation.getMinimumSigma()) {
    featuresChanged=true;
    record(SET_MAXIMUM_SIGMA,new String[]{Float.toString(newMaxSigma)});
    wekaSegmentation.setMaximumSigma(newMaxSigma);
  }
  if (wekaSegmentation.getMinimumSigma() >= wekaSegmentation.getMaximumSigma()) {
    IJ.error(""String_Node_Str"");
    wekaSegmentation.setMinimumSigma(0f);
    wekaSegmentation.setMaximumSigma(16f);
  }
  c=(Object)m_ClassifierEditor.getValue();
  String options=""String_Node_Str"";
  if (c instanceof OptionHandler) {
    options=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  if (originalClassifierName.equals(c.getClass().getName()) == false || originalOptions.equals(options) == false) {
    AbstractClassifier cls;
    try {
      cls=(AbstractClassifier)(c.getClass().newInstance());
      cls.setOptions(options.split(""String_Node_Str""));
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      return false;
    }
    wekaSegmentation.setClassifier(cls);
    record(SET_CLASSIFIER,new String[]{c.getClass().getName(),options});
    IJ.log(""String_Node_Str"" + c.getClass().getName() + ""String_Node_Str""+ options);
  }
  boolean classNameChanged=false;
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
    String s=gd.getNextString();
    if (null == s || 0 == s.length()) {
      IJ.log(""String_Node_Str"" + (i + 1));
      continue;
    }
    s=s.trim();
    if (!s.equals(wekaSegmentation.getClassLabel(i))) {
      if (0 == s.toLowerCase().indexOf(""String_Node_Str""))       s=s.substring(7);
      wekaSegmentation.setClassLabel(i,s);
      classNameChanged=true;
      addExampleButton[i].setText(""String_Node_Str"" + s);
      record(CHANGE_CLASS_NAME,new String[]{Integer.toString(i),s});
    }
  }
  final boolean homogenizeClasses=gd.getNextBoolean();
  if (wekaSegmentation.doHomogenizeClasses() != homogenizeClasses) {
    wekaSegmentation.setDoHomogenizeClasses(homogenizeClasses);
    record(SET_HOMOGENIZATION,new String[]{Boolean.toString(homogenizeClasses)});
  }
  final int newOpacity=(int)gd.getNextNumber();
  if (newOpacity != win.overlayOpacity) {
    win.overlayOpacity=newOpacity;
    win.overlayAlpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,win.overlayOpacity / 100f);
    win.resultOverlay.setComposite(win.overlayAlpha);
    record(SET_OPACITY,new String[]{Integer.toString(win.overlayOpacity)});
    if (showColorOverlay)     displayImage.updateAndDraw();
  }
  if (classNameChanged) {
    win.pack();
  }
  if (featuresChanged) {
    wekaSegmentation.setFeaturesDirty();
  }
  return true;
}","/** 
 * Show advanced settings dialog
 * @return false when canceled
 */
public boolean showSettingsDialog(){
  GenericDialogPlus gd=new GenericDialogPlus(""String_Node_Str"");
  final boolean[] oldEnableFeatures=wekaSegmentation.getEnabledFeatures();
  gd.addMessage(""String_Node_Str"");
  final int rows=(int)Math.round(FeatureStack.availableFeatures.length / 2.0);
  gd.addCheckboxGroup(rows,2,FeatureStack.availableFeatures,oldEnableFeatures);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    final Vector<Checkbox> v=gd.getCheckboxes();
    for (    Checkbox c : v)     c.setEnabled(false);
    gd.addMessage(""String_Node_Str"");
  }
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembraneThickness(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMembranePatchSize(),0);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMinimumSigma(),1);
  gd.addNumericField(""String_Node_Str"",wekaSegmentation.getMaximumSigma(),1);
  if (wekaSegmentation.getLoadedTrainingData() != null) {
    for (int i=0; i < 4; i++)     ((TextField)gd.getNumericFields().get(i)).setEnabled(false);
  }
  gd.addMessage(""String_Node_Str"");
  GenericObjectEditor m_ClassifierEditor=new GenericObjectEditor();
  PropertyPanel m_CEPanel=new PropertyPanel(m_ClassifierEditor);
  m_ClassifierEditor.setClassType(Classifier.class);
  m_ClassifierEditor.setValue(wekaSegmentation.getClassifier());
  gd.addComponent(m_CEPanel,GridBagConstraints.HORIZONTAL,1);
  Object c=(Object)m_ClassifierEditor.getValue();
  String originalOptions=""String_Node_Str"";
  String originalClassifierName=c.getClass().getName();
  if (c instanceof OptionHandler) {
    originalOptions=Utils.joinOptions(((OptionHandler)c).getOptions());
  }
  gd.addMessage(""String_Node_Str"");
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++)   gd.addStringField(""String_Node_Str"" + (i + 1),wekaSegmentation.getClassLabel(i),15);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",wekaSegmentation.doHomogenizeClasses());
  gd.addButton(""String_Node_Str"",new SaveFeatureStackButtonListener(""String_Node_Str"",wekaSegmentation.getFeatureStackArray()));
  gd.addSlider(""String_Node_Str"",0,100,win.overlayOpacity);
  gd.addHelp(""String_Node_Str"");
  gd.showDialog();
  if (gd.wasCanceled())   return false;
  final int numOfFeatures=FeatureStack.availableFeatures.length;
  final boolean[] newEnableFeatures=new boolean[numOfFeatures];
  boolean featuresChanged=false;
  for (int i=0; i < numOfFeatures; i++) {
    newEnableFeatures[i]=gd.getNextBoolean();
    if (newEnableFeatures[i] != oldEnableFeatures[i]) {
      featuresChanged=true;
      record(SET_FEATURE,new String[]{FeatureStack.availableFeatures[i] + ""String_Node_Str"" + newEnableFeatures[i]});
    }
  }
  if (featuresChanged) {
    wekaSegmentation.setEnabledFeatures(newEnableFeatures);
  }
  final int newThickness=(int)gd.getNextNumber();
  if (newThickness != wekaSegmentation.getMembraneThickness()) {
    featuresChanged=true;
    wekaSegmentation.setMembraneThickness(newThickness);
    record(SET_MEMBRANE_THICKNESS,new String[]{Integer.toString(newThickness)});
  }
  final int newPatch=(int)gd.getNextNumber();
  if (newPatch != wekaSegmentation.getMembranePatchSize()) {
    featuresChanged=true;
    record(SET_MEMBRANE_PATCH,new String[]{Integer.toString(newPatch)});
    wekaSegmentation.setMembranePatchSize(newPatch);
  }
  final float newMinSigma=(float)gd.getNextNumber();
  if (newMinSigma != wekaSegmentation.getMinimumSigma() && newMinSigma > 0) {
    featuresChanged=true;
    record(SET_MINIMUM_SIGMA,new String[]{Float.toString(newMinSigma)});
    wekaSegmentation.setMinimumSigma(newMinSigma);
  }
  final float newMaxSigma=(float)gd.getNextNumber();
  if (newMaxSigma != wekaSegmentation.getMaximumSigma() && newMaxSigma > wekaSegmentation.getMinimumSigma()) {
    featuresChanged=true;
    record(SET_MAXIMUM_SIGMA,new String[]{Float.toString(newMaxSigma)});
    wekaSegmentation.setMaximumSigma(newMaxSigma);
  }
  if (wekaSegmentation.getMinimumSigma() >= wekaSegmentation.getMaximumSigma()) {
    IJ.error(""String_Node_Str"");
    wekaSegmentation.setMinimumSigma(0f);
    wekaSegmentation.setMaximumSigma(16f);
  }
  c=(Object)m_ClassifierEditor.getValue();
  String options=""String_Node_Str"";
  final String[] optionsArray=((OptionHandler)c).getOptions();
  if (c instanceof OptionHandler) {
    options=Utils.joinOptions(optionsArray);
  }
  if (originalClassifierName.equals(c.getClass().getName()) == false || originalOptions.equals(options) == false) {
    AbstractClassifier cls;
    try {
      cls=(AbstractClassifier)(c.getClass().newInstance());
      cls.setOptions(optionsArray);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      return false;
    }
    wekaSegmentation.setClassifier(cls);
    record(SET_CLASSIFIER,new String[]{c.getClass().getName(),options});
    IJ.log(""String_Node_Str"" + c.getClass().getName() + ""String_Node_Str""+ options);
  }
  boolean classNameChanged=false;
  for (int i=0; i < wekaSegmentation.getNumOfClasses(); i++) {
    String s=gd.getNextString();
    if (null == s || 0 == s.length()) {
      IJ.log(""String_Node_Str"" + (i + 1));
      continue;
    }
    s=s.trim();
    if (!s.equals(wekaSegmentation.getClassLabel(i))) {
      if (0 == s.toLowerCase().indexOf(""String_Node_Str""))       s=s.substring(7);
      wekaSegmentation.setClassLabel(i,s);
      classNameChanged=true;
      addExampleButton[i].setText(""String_Node_Str"" + s);
      record(CHANGE_CLASS_NAME,new String[]{Integer.toString(i),s});
    }
  }
  final boolean homogenizeClasses=gd.getNextBoolean();
  if (wekaSegmentation.doHomogenizeClasses() != homogenizeClasses) {
    wekaSegmentation.setDoHomogenizeClasses(homogenizeClasses);
    record(SET_HOMOGENIZATION,new String[]{Boolean.toString(homogenizeClasses)});
  }
  final int newOpacity=(int)gd.getNextNumber();
  if (newOpacity != win.overlayOpacity) {
    win.overlayOpacity=newOpacity;
    win.overlayAlpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,win.overlayOpacity / 100f);
    win.resultOverlay.setComposite(win.overlayAlpha);
    record(SET_OPACITY,new String[]{Integer.toString(win.overlayOpacity)});
    if (showColorOverlay)     displayImage.updateAndDraw();
  }
  if (classNameChanged) {
    win.pack();
  }
  if (featuresChanged) {
    wekaSegmentation.setFeaturesDirty();
  }
  return true;
}",0.951554930457884
22761,"public void addHessian(float sigma){
  float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
  float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
  Convolver c=new Convolver();
  GaussianBlur gs=new GaussianBlur();
  ImageProcessor ip_x=originalImage.getProcessor().duplicate();
  gs.blur(ip_x,sigma);
  c.convolveFloat(ip_x,sobelFilter_x,3,3);
  ImageProcessor ip_y=originalImage.getProcessor().duplicate();
  gs.blur(ip_y,sigma);
  c=new Convolver();
  c.convolveFloat(ip_y,sobelFilter_y,3,3);
  ImageProcessor ip_xx=ip_x.duplicate();
  c.convolveFloat(ip_xx,sobelFilter_x,3,3);
  ImageProcessor ip_xy=ip_x.duplicate();
  c.convolveFloat(ip_xy,sobelFilter_y,3,3);
  ImageProcessor ip_yy=ip_y.duplicate();
  c.convolveFloat(ip_yy,sobelFilter_y,3,3);
  ImageProcessor ip=new FloatProcessor(width,height);
  ImageProcessor ipTr=new FloatProcessor(width,height);
  ImageProcessor ipDet=new FloatProcessor(width,height);
  ImageProcessor ipEig1=new FloatProcessor(width,height);
  ImageProcessor ipEig2=new FloatProcessor(width,height);
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      float s_xx=ip_xx.getf(x,y);
      float s_xy=ip_xy.getf(x,y);
      float s_yy=ip_yy.getf(x,y);
      ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
      ipTr.setf(x,y,(float)s_xx + s_yy);
      ipDet.setf(x,y,(float)s_xx * s_yy - s_xy * s_xy);
      ipEig1.setf(x,y,(float)((s_xx + s_yy) / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
      ipEig2.setf(x,y,(float)((s_xx + s_yy) / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
    }
  }
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
}","/** 
 * Add Hessian features from original image (single thread version). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue, 2nd eigenvalue, orientation, gamma-normalized square eigenvalue difference and the square of Gamma-normalized eigenvalue difference
 * @param sigma radius of the Gaussian filter to use
 */
public void addHessian(float sigma){
  float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
  float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
  Convolver c=new Convolver();
  GaussianBlur gs=new GaussianBlur();
  ImageProcessor ip_x=originalImage.getProcessor().duplicate();
  gs.blur(ip_x,sigma);
  c.convolveFloat(ip_x,sobelFilter_x,3,3);
  ImageProcessor ip_y=originalImage.getProcessor().duplicate();
  gs.blur(ip_y,sigma);
  c=new Convolver();
  c.convolveFloat(ip_y,sobelFilter_y,3,3);
  ImageProcessor ip_xx=ip_x.duplicate();
  c.convolveFloat(ip_xx,sobelFilter_x,3,3);
  ImageProcessor ip_xy=ip_x.duplicate();
  c.convolveFloat(ip_xy,sobelFilter_y,3,3);
  ImageProcessor ip_yy=ip_y.duplicate();
  c.convolveFloat(ip_yy,sobelFilter_y,3,3);
  ImageProcessor ip=new FloatProcessor(width,height);
  ImageProcessor ipTr=new FloatProcessor(width,height);
  ImageProcessor ipDet=new FloatProcessor(width,height);
  ImageProcessor ipEig1=new FloatProcessor(width,height);
  ImageProcessor ipEig2=new FloatProcessor(width,height);
  ImageProcessor ipOri=new FloatProcessor(width,height);
  ImageProcessor ipSed=new FloatProcessor(width,height);
  ImageProcessor ipNed=new FloatProcessor(width,height);
  final double t=Math.pow(1,0.75);
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      float s_xx=ip_xx.getf(x,y);
      float s_xy=ip_xy.getf(x,y);
      float s_yy=ip_yy.getf(x,y);
      ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
      final float trace=(float)s_xx + s_yy;
      ipTr.setf(x,y,trace);
      final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
      ipDet.setf(x,y,determinant);
      ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
      ipTr.setf(x,y,(float)s_xx + s_yy);
      ipDet.setf(x,y,(float)s_xx * s_yy - s_xy * s_xy);
      ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
      ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
      if (s_xy < 0.0) {
        float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
        if (Float.isNaN(orientation))         orientation=0;
        ipOri.setf(x,y,orientation);
      }
 else {
        float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
        if (Float.isNaN(orientation))         orientation=0;
        ipOri.setf(x,y,orientation);
      }
      ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
      ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
    }
  }
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
  wholeStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
}",0.6583050847457627
22762,"/** 
 * Get Hessian features from original image (to be submitted in an ExecutorService). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue and 2nd eigenvalue.
 * @param originalImage input image
 * @param sigma radius of the Gaussian filter to use
 * @return filtered image (stack: hessian, trace, determinant, 1st eigenvalue and 2nd eigenvalue) 
 */
public Callable<ImagePlus> getHessian(final ImagePlus originalImage,final float sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      final int width=originalImage.getWidth();
      final int height=originalImage.getHeight();
      float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
      float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
      Convolver c=new Convolver();
      GaussianBlur gs=new GaussianBlur();
      ImageProcessor ip_x=originalImage.getProcessor().duplicate();
      gs.blur(ip_x,sigma);
      c.convolveFloat(ip_x,sobelFilter_x,3,3);
      ImageProcessor ip_y=originalImage.getProcessor().duplicate();
      gs.blur(ip_y,sigma);
      c=new Convolver();
      c.convolveFloat(ip_y,sobelFilter_y,3,3);
      ImageProcessor ip_xx=ip_x.duplicate();
      c.convolveFloat(ip_xx,sobelFilter_x,3,3);
      ImageProcessor ip_xy=ip_x.duplicate();
      c.convolveFloat(ip_xy,sobelFilter_y,3,3);
      ImageProcessor ip_yy=ip_y.duplicate();
      c.convolveFloat(ip_yy,sobelFilter_y,3,3);
      ImageProcessor ip=new FloatProcessor(width,height);
      ImageProcessor ipTr=new FloatProcessor(width,height);
      ImageProcessor ipDet=new FloatProcessor(width,height);
      ImageProcessor ipEig1=new FloatProcessor(width,height);
      ImageProcessor ipEig2=new FloatProcessor(width,height);
      ImageProcessor ipOri=new FloatProcessor(width,height);
      ImageProcessor ipSed=new FloatProcessor(width,height);
      ImageProcessor ipNed=new FloatProcessor(width,height);
      final double t=Math.pow(1,0.75);
      for (int x=0; x < width; x++) {
        for (int y=0; y < height; y++) {
          float s_xx=ip_xx.getf(x,y);
          float s_xy=ip_xy.getf(x,y);
          float s_yy=ip_yy.getf(x,y);
          ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
          final float trace=(float)s_xx + s_yy;
          ipTr.setf(x,y,trace);
          final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
          ipDet.setf(x,y,determinant);
          ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          if (s_xy < 0.0) {
            float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
            if (Float.isNaN(orientation))             orientation=0;
            ipOri.setf(x,y,orientation);
          }
 else {
            float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
            if (Float.isNaN(orientation))             orientation=0;
            ipOri.setf(x,y,orientation);
          }
          ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
          ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
        }
      }
      ImageStack hessianStack=new ImageStack(width,height);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
      return new ImagePlus(""String_Node_Str"",hessianStack);
    }
  }
;
}","/** 
 * Get Hessian features from original image (to be submitted in an ExecutorService). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue, 2nd eigenvalue, orientation, gamma-normalized square eigenvalue difference and the square of Gamma-normalized eigenvalue difference
 * @param originalImage input image
 * @param sigma radius of the Gaussian filter to use
 * @return filtered image (stack: hessian, trace, determinant, 1st eigenvalue and 2nd eigenvalue) 
 */
public Callable<ImagePlus> getHessian(final ImagePlus originalImage,final float sigma){
  if (Thread.currentThread().isInterrupted())   return null;
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      final int width=originalImage.getWidth();
      final int height=originalImage.getHeight();
      float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
      float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
      Convolver c=new Convolver();
      GaussianBlur gs=new GaussianBlur();
      ImageProcessor ip_x=originalImage.getProcessor().duplicate();
      gs.blur(ip_x,sigma);
      c.convolveFloat(ip_x,sobelFilter_x,3,3);
      ImageProcessor ip_y=originalImage.getProcessor().duplicate();
      gs.blur(ip_y,sigma);
      c=new Convolver();
      c.convolveFloat(ip_y,sobelFilter_y,3,3);
      ImageProcessor ip_xx=ip_x.duplicate();
      c.convolveFloat(ip_xx,sobelFilter_x,3,3);
      ImageProcessor ip_xy=ip_x.duplicate();
      c.convolveFloat(ip_xy,sobelFilter_y,3,3);
      ImageProcessor ip_yy=ip_y.duplicate();
      c.convolveFloat(ip_yy,sobelFilter_y,3,3);
      ImageProcessor ip=new FloatProcessor(width,height);
      ImageProcessor ipTr=new FloatProcessor(width,height);
      ImageProcessor ipDet=new FloatProcessor(width,height);
      ImageProcessor ipEig1=new FloatProcessor(width,height);
      ImageProcessor ipEig2=new FloatProcessor(width,height);
      ImageProcessor ipOri=new FloatProcessor(width,height);
      ImageProcessor ipSed=new FloatProcessor(width,height);
      ImageProcessor ipNed=new FloatProcessor(width,height);
      final double t=Math.pow(1,0.75);
      for (int x=0; x < width; x++) {
        for (int y=0; y < height; y++) {
          float s_xx=ip_xx.getf(x,y);
          float s_xy=ip_xy.getf(x,y);
          float s_yy=ip_yy.getf(x,y);
          ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
          final float trace=(float)s_xx + s_yy;
          ipTr.setf(x,y,trace);
          final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
          ipDet.setf(x,y,determinant);
          ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          if (s_xy < 0.0) {
            float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
            if (Float.isNaN(orientation))             orientation=0;
            ipOri.setf(x,y,orientation);
          }
 else {
            float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
            if (Float.isNaN(orientation))             orientation=0;
            ipOri.setf(x,y,orientation);
          }
          ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
          ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
        }
      }
      ImageStack hessianStack=new ImageStack(width,height);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
      return new ImagePlus(""String_Node_Str"",hessianStack);
    }
  }
;
}",0.986090693203664
22763,"/** 
 * Get Hessian features from original image (to be submitted in an ExecutorService). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue and 2nd eigenvalue.
 * @param originalImage input image
 * @param sigma radius of the Gaussian filter to use
 * @return filtered image (stack: hessian, trace, determinant, 1st eigenvalue and 2nd eigenvalue) 
 */
public Callable<ImagePlus> getHessian(final ImagePlus originalImage,final float sigma){
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      final int width=originalImage.getWidth();
      final int height=originalImage.getHeight();
      float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
      float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
      Convolver c=new Convolver();
      GaussianBlur gs=new GaussianBlur();
      ImageProcessor ip_x=originalImage.getProcessor().duplicate();
      gs.blur(ip_x,sigma);
      c.convolveFloat(ip_x,sobelFilter_x,3,3);
      ImageProcessor ip_y=originalImage.getProcessor().duplicate();
      gs.blur(ip_y,sigma);
      c=new Convolver();
      c.convolveFloat(ip_y,sobelFilter_y,3,3);
      ImageProcessor ip_xx=ip_x.duplicate();
      c.convolveFloat(ip_xx,sobelFilter_x,3,3);
      ImageProcessor ip_xy=ip_x.duplicate();
      c.convolveFloat(ip_xy,sobelFilter_y,3,3);
      ImageProcessor ip_yy=ip_y.duplicate();
      c.convolveFloat(ip_yy,sobelFilter_y,3,3);
      ImageProcessor ip=new FloatProcessor(width,height);
      ImageProcessor ipTr=new FloatProcessor(width,height);
      ImageProcessor ipDet=new FloatProcessor(width,height);
      ImageProcessor ipEig1=new FloatProcessor(width,height);
      ImageProcessor ipEig2=new FloatProcessor(width,height);
      ImageProcessor ipOri=new FloatProcessor(width,height);
      ImageProcessor ipSed=new FloatProcessor(width,height);
      ImageProcessor ipNed=new FloatProcessor(width,height);
      final double t=Math.pow(1,0.75);
      for (int x=0; x < width; x++) {
        for (int y=0; y < height; y++) {
          float s_xx=ip_xx.getf(x,y);
          float s_xy=ip_xy.getf(x,y);
          float s_yy=ip_yy.getf(x,y);
          ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
          final float trace=(float)s_xx + s_yy;
          ipTr.setf(x,y,trace);
          final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
          ipDet.setf(x,y,determinant);
          ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          if (s_xy < 0.0) {
            ipOri.setf(x,y,(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)))));
          }
 else {
            ipOri.setf(x,y,(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)))));
          }
          ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
          ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
        }
      }
      ImageStack hessianStack=new ImageStack(width,height);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
      return new ImagePlus(""String_Node_Str"",hessianStack);
    }
  }
;
}","/** 
 * Get Hessian features from original image (to be submitted in an ExecutorService). The features include a scalar representing the Hessian, the trace, determinant,  1st eigenvalue and 2nd eigenvalue.
 * @param originalImage input image
 * @param sigma radius of the Gaussian filter to use
 * @return filtered image (stack: hessian, trace, determinant, 1st eigenvalue and 2nd eigenvalue) 
 */
public Callable<ImagePlus> getHessian(final ImagePlus originalImage,final float sigma){
  return new Callable<ImagePlus>(){
    public ImagePlus call(){
      final int width=originalImage.getWidth();
      final int height=originalImage.getHeight();
      float[] sobelFilter_x={1f,2f,1f,0f,0f,0f,-1f,-2f,-1f};
      float[] sobelFilter_y={1f,0f,-1f,2f,0f,-2f,1f,0f,-1f};
      Convolver c=new Convolver();
      GaussianBlur gs=new GaussianBlur();
      ImageProcessor ip_x=originalImage.getProcessor().duplicate();
      gs.blur(ip_x,sigma);
      c.convolveFloat(ip_x,sobelFilter_x,3,3);
      ImageProcessor ip_y=originalImage.getProcessor().duplicate();
      gs.blur(ip_y,sigma);
      c=new Convolver();
      c.convolveFloat(ip_y,sobelFilter_y,3,3);
      ImageProcessor ip_xx=ip_x.duplicate();
      c.convolveFloat(ip_xx,sobelFilter_x,3,3);
      ImageProcessor ip_xy=ip_x.duplicate();
      c.convolveFloat(ip_xy,sobelFilter_y,3,3);
      ImageProcessor ip_yy=ip_y.duplicate();
      c.convolveFloat(ip_yy,sobelFilter_y,3,3);
      ImageProcessor ip=new FloatProcessor(width,height);
      ImageProcessor ipTr=new FloatProcessor(width,height);
      ImageProcessor ipDet=new FloatProcessor(width,height);
      ImageProcessor ipEig1=new FloatProcessor(width,height);
      ImageProcessor ipEig2=new FloatProcessor(width,height);
      ImageProcessor ipOri=new FloatProcessor(width,height);
      ImageProcessor ipSed=new FloatProcessor(width,height);
      ImageProcessor ipNed=new FloatProcessor(width,height);
      final double t=Math.pow(1,0.75);
      for (int x=0; x < width; x++) {
        for (int y=0; y < height; y++) {
          float s_xx=ip_xx.getf(x,y);
          float s_xy=ip_xy.getf(x,y);
          float s_yy=ip_yy.getf(x,y);
          ip.setf(x,y,(float)Math.sqrt(s_xx * s_xx + s_xy * s_xy + s_yy * s_yy));
          final float trace=(float)s_xx + s_yy;
          ipTr.setf(x,y,trace);
          final float determinant=(float)s_xx * s_yy - s_xy * s_xy;
          ipDet.setf(x,y,determinant);
          ipEig1.setf(x,y,(float)(trace / 2.0 + Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          ipEig2.setf(x,y,(float)(trace / 2.0 - Math.sqrt((4 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy)) / 2.0)));
          if (s_xy < 0.0) {
            float orientation=(float)(-0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
            if (Float.isNaN(orientation))             orientation=0;
            ipOri.setf(x,y,orientation);
          }
 else {
            float orientation=(float)(0.5 * Math.acos((s_xx - s_yy) / Math.sqrt(4.0 * s_xy * s_xy + (s_xx - s_yy) * (s_xx - s_yy))));
            if (Float.isNaN(orientation))             orientation=0;
            ipOri.setf(x,y,orientation);
          }
          ipSed.setf(x,y,(float)(Math.pow(t,4) * trace * trace* ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
          ipNed.setf(x,y,(float)(Math.pow(t,2) * ((s_xx - s_yy) * (s_xx - s_yy) + 4 * s_xy * s_xy)));
        }
      }
      ImageStack hessianStack=new ImageStack(width,height);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ip);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipTr);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipDet);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig1);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipEig2);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipOri);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipSed);
      hessianStack.addSlice(availableFeatures[HESSIAN] + ""String_Node_Str"" + sigma,ipNed);
      return new ImagePlus(""String_Node_Str"",hessianStack);
    }
  }
;
}",0.94537213740458
22764,"/** 
 * Adjust current segmentation state (attributes and classes) to  loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStack.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStack.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i != FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  if (minSigma != this.minimumSigma) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStack.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStack.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    if (!className.equals(this.classLabels[j])) {
      String currentLabels=classLabels[0];
      for (int i=1; i < numOfClasses; i++)       currentLabels=currentLabels.concat(""String_Node_Str"" + classLabels[i]);
      String loadedLabels=loadedClassNames.get(0);
      for (int i=1; i < loadedClassNames.size(); i++)       loadedLabels=loadedLabels.concat(""String_Node_Str"" + loadedClassNames.get(i));
      IJ.error(""String_Node_Str"" + loadedLabels + ""String_Node_Str""+ currentLabels);
      return false;
    }
    j++;
  }
  if (j != numOfClasses) {
    IJ.error(""String_Node_Str"");
    return false;
  }
  final boolean[] oldEnableFeatures=this.featureStack.getEnableFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.featureStack.setEnableFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to  loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStack.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStack.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i < FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
  if (minSigma != this.minimumSigma && minSigma != 0) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStack.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStack.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    if (!className.equals(this.classLabels[j])) {
      String currentLabels=classLabels[0];
      for (int i=1; i < numOfClasses; i++)       currentLabels=currentLabels.concat(""String_Node_Str"" + classLabels[i]);
      String loadedLabels=loadedClassNames.get(0);
      for (int i=1; i < loadedClassNames.size(); i++)       loadedLabels=loadedLabels.concat(""String_Node_Str"" + loadedClassNames.get(i));
      IJ.error(""String_Node_Str"" + loadedLabels + ""String_Node_Str""+ currentLabels);
      return false;
    }
    j++;
  }
  if (j != numOfClasses) {
    IJ.error(""String_Node_Str"");
    return false;
  }
  final boolean[] oldEnableFeatures=this.featureStack.getEnableFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.featureStack.setEnableFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}",0.9857857330876546
22765,"/** 
 * Update features with current list in a multi-thread fashion
 */
public void updateFeaturesMT(){
  wholeStack=new ImageStack(width,height);
  wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate());
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<ImagePlus>> futures=new ArrayList<Future<ImagePlus>>();
  try {
    if (enableFeatures[ANISOTROPIC_DIFFUSION]) {
      for (float i=minimumSigma; i <= maximumSigma; i*=2)       for (float j=0.10f; j < 0.5f; j+=0.25f)       futures.add(exe.submit(getAnisotropicDiffusion(originalImage,20,20,(int)i,j,0.9f,(float)membraneSize)));
    }
    if (enableFeatures[BILATERAL]) {
      for (double i=5; i < 20; i*=2)       for (double j=50; j <= 100; j*=2)       futures.add(exe.submit(getBilateralFilter(originalImage,i,j)));
    }
    if (enableFeatures[LIPSCHITZ]) {
      for (double i=5; i < 30; i+=5)       futures.add(exe.submit(getLipschitzFilter(originalImage,true,true,i)));
    }
    if (enableFeatures[KUWAHARA]) {
      for (int i=0; i < 3; i++)       futures.add(exe.submit(getKuwaharaFeatures(originalImage,membranePatchSize,nAngles,i)));
    }
    if (enableFeatures[GABOR]) {
      for (int i=0; i < 3; i++)       for (double gamma=1; gamma >= 0.25; gamma/=2)       for (int frequency=2; frequency <= 3; frequency++) {
        final double psi=Math.PI / 4 * i;
        futures.add(exe.submit(getGabor(originalImage,1.0,gamma,psi,frequency,nAngles)));
      }
      for (int i=0; i < 3; i++)       for (double sigma=2.0; sigma <= 4.0; sigma*=2)       for (double gamma=1.0; gamma <= 2.0; gamma*=2)       for (int frequency=2; frequency <= 3; frequency++) {
        final double psi=Math.PI / 4 * i;
        futures.add(exe.submit(getGabor(originalImage,sigma,gamma,psi,frequency,nAngles)));
      }
    }
    if (enableFeatures[SOBEL]) {
      futures.add(exe.submit(getGradient(originalImage,0)));
    }
    if (enableFeatures[HESSIAN]) {
      futures.add(exe.submit(getHessian(originalImage,0)));
    }
    for (float i=minimumSigma; i <= maximumSigma; i*=2) {
      if (enableFeatures[GAUSSIAN]) {
        futures.add(exe.submit(getGaussianBlur(originalImage,i)));
      }
      if (enableFeatures[SOBEL]) {
        futures.add(exe.submit(getGradient(originalImage,i)));
      }
      if (enableFeatures[HESSIAN]) {
        futures.add(exe.submit(getHessian(originalImage,i)));
      }
      if (enableFeatures[DOG]) {
        for (float j=minimumSigma; j < i; j*=2) {
          futures.add(exe.submit(getDoG(originalImage,i,j)));
        }
      }
      if (enableFeatures[VARIANCE]) {
        futures.add(exe.submit(getVariance(originalImage,i)));
      }
      if (enableFeatures[MEAN]) {
        futures.add(exe.submit(getMean(originalImage,i)));
      }
      if (enableFeatures[MINIMUM]) {
        futures.add(exe.submit(getMin(originalImage,i)));
      }
      if (enableFeatures[MAXIMUM]) {
        futures.add(exe.submit(getMax(originalImage,i)));
      }
    }
    if (enableFeatures[MEMBRANE])     futures.add(exe.submit(getMembraneFeatures(originalImage,membranePatchSize,membraneSize)));
    for (    Future<ImagePlus> f : futures) {
      final ImagePlus res=f.get();
      if (res.getImageStackSize() == 1) {
        this.wholeStack.addSlice(res.getTitle(),res.getProcessor());
      }
 else {
        final ImageStack slices=res.getImageStack();
        for (int i=1; i <= slices.getSize(); i++)         this.wholeStack.addSlice(slices.getSliceLabel(i),slices.getProcessor(i));
      }
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  IJ.showProgress(1.0);
  IJ.showStatus(""String_Node_Str"");
}","/** 
 * Update features with current list in a multi-thread fashion
 */
public void updateFeaturesMT(){
  wholeStack=new ImageStack(width,height);
  wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate());
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<ImagePlus>> futures=new ArrayList<Future<ImagePlus>>();
  try {
    if (enableFeatures[ANISOTROPIC_DIFFUSION]) {
      for (float i=minimumSigma; i <= maximumSigma; i*=2)       for (float j=0.10f; j < 0.5f; j+=0.25f)       futures.add(exe.submit(getAnisotropicDiffusion(originalImage,20,20,(int)i,j,0.9f,(float)membraneSize)));
    }
    if (enableFeatures[BILATERAL]) {
      for (double i=5; i < 20; i*=2)       for (double j=50; j <= 100; j*=2)       futures.add(exe.submit(getBilateralFilter(originalImage,i,j)));
    }
    if (enableFeatures[LIPSCHITZ]) {
      for (double i=5; i < 30; i+=5)       futures.add(exe.submit(getLipschitzFilter(originalImage,true,true,i)));
    }
    if (enableFeatures[KUWAHARA]) {
      for (int i=0; i < 3; i++)       futures.add(exe.submit(getKuwaharaFeatures(originalImage,membranePatchSize,nAngles,i)));
    }
    if (enableFeatures[GABOR]) {
      for (int i=0; i < 3; i++)       for (double gamma=1; gamma >= 0.25; gamma/=2)       for (int frequency=2; frequency <= 3; frequency++) {
        final double psi=Math.PI / 4 * i;
        futures.add(exe.submit(getGabor(originalImage,1.0,gamma,psi,frequency,nAngles)));
      }
      for (int i=0; i < 3; i++)       for (double sigma=2.0; sigma <= 4.0; sigma*=2)       for (double gamma=1.0; gamma <= 2.0; gamma*=2)       for (int frequency=2; frequency <= 3; frequency++) {
        final double psi=Math.PI / 4 * i;
        futures.add(exe.submit(getGabor(originalImage,sigma,gamma,psi,frequency,nAngles)));
      }
    }
    if (enableFeatures[SOBEL]) {
      futures.add(exe.submit(getGradient(originalImage,0)));
    }
    if (enableFeatures[HESSIAN]) {
      futures.add(exe.submit(getHessian(originalImage,0)));
    }
    for (float i=minimumSigma; i <= maximumSigma; i*=2) {
      if (enableFeatures[GAUSSIAN]) {
        futures.add(exe.submit(getGaussianBlur(originalImage,i)));
      }
      if (enableFeatures[SOBEL]) {
        futures.add(exe.submit(getGradient(originalImage,i)));
      }
      if (enableFeatures[HESSIAN]) {
        futures.add(exe.submit(getHessian(originalImage,i)));
      }
      if (enableFeatures[DOG]) {
        for (float j=minimumSigma; j < i; j*=2) {
          futures.add(exe.submit(getDoG(originalImage,i,j)));
        }
      }
      if (enableFeatures[VARIANCE]) {
        futures.add(exe.submit(getVariance(originalImage,i)));
      }
      if (enableFeatures[MEAN]) {
        futures.add(exe.submit(getMean(originalImage,i)));
      }
      if (enableFeatures[MINIMUM]) {
        futures.add(exe.submit(getMin(originalImage,i)));
      }
      if (enableFeatures[MAXIMUM]) {
        futures.add(exe.submit(getMax(originalImage,i)));
      }
      if (enableFeatures[MEDIAN]) {
        futures.add(exe.submit(getMedian(originalImage,i)));
      }
    }
    if (enableFeatures[MEMBRANE])     futures.add(exe.submit(getMembraneFeatures(originalImage,membranePatchSize,membraneSize)));
    for (    Future<ImagePlus> f : futures) {
      final ImagePlus res=f.get();
      if (res.getImageStackSize() == 1) {
        this.wholeStack.addSlice(res.getTitle(),res.getProcessor());
      }
 else {
        final ImageStack slices=res.getImageStack();
        for (int i=1; i <= slices.getSize(); i++)         this.wholeStack.addSlice(slices.getSliceLabel(i),slices.getProcessor(i));
      }
    }
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  IJ.showProgress(1.0);
  IJ.showStatus(""String_Node_Str"");
}",0.9862403354737256
22766,"/** 
 * Adjust current segmentation state (attributes and classes) to  loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStack.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStack.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i != FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  if (minSigma != this.minimumSigma) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStack.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStack.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    if (!className.equals(this.classLabels[j])) {
      String currentLabels=classLabels[0];
      for (int i=1; i < numOfClasses; i++)       currentLabels=currentLabels.concat(""String_Node_Str"" + classLabels[i]);
      String loadedLabels=loadedClassNames.get(0);
      for (int i=1; i < loadedClassNames.size(); i++)       loadedLabels=loadedLabels.concat(""String_Node_Str"" + loadedClassNames.get(i));
      IJ.error(""String_Node_Str"" + loadedLabels + ""String_Node_Str""+ currentLabels);
      return false;
    }
    j++;
  }
  if (j != numOfClasses) {
    IJ.error(""String_Node_Str"");
    return false;
  }
  final boolean[] oldEnableFeatures=this.featureStack.getEnableFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.featureStack.setEnableFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}","/** 
 * Adjust current segmentation state (attributes and classes) to  loaded data
 * @param data loaded instances
 * @return false if error
 */
public boolean adjustSegmentationStateToData(Instances data){
  boolean featuresChanged=false;
  Enumeration<Attribute> attributes=data.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  this.featureNames=new ArrayList<String>();
  float minSigma=Float.MAX_VALUE;
  float maxSigma=Float.MIN_VALUE;
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    this.featureNames.add(a.name());
    for (int i=0; i < numFeatures; i++) {
      if (a.name().startsWith(FeatureStack.availableFeatures[i])) {
        usedFeatures[i]=true;
        if (i == FeatureStack.MEMBRANE) {
          int index=a.name().indexOf(""String_Node_Str"") + 4;
          int index2=a.name().indexOf(""String_Node_Str"",index + 1);
          final int patchSize=Integer.parseInt(a.name().substring(index,index2));
          if (patchSize != membranePatchSize) {
            membranePatchSize=patchSize;
            this.featureStack.setMembranePatchSize(patchSize);
            featuresChanged=true;
          }
          index=a.name().lastIndexOf(""String_Node_Str"");
          final int thickness=Integer.parseInt(a.name().substring(index + 1));
          if (thickness != membraneThickness) {
            membraneThickness=thickness;
            this.featureStack.setMembraneSize(thickness);
            featuresChanged=true;
          }
        }
 else         if (i < FeatureStack.ANISOTROPIC_DIFFUSION) {
          String[] tokens=a.name().split(""String_Node_Str"");
          for (int j=0; j < tokens.length; j++)           if (tokens[j].indexOf(""String_Node_Str"") != -1) {
            final float sigma=Float.parseFloat(tokens[j]);
            if (sigma < minSigma)             minSigma=sigma;
            if (sigma > maxSigma)             maxSigma=sigma;
          }
        }
      }
    }
  }
  IJ.log(""String_Node_Str"" + maxSigma + ""String_Node_Str""+ minSigma);
  IJ.log(""String_Node_Str"" + membraneThickness + ""String_Node_Str""+ membranePatchSize);
  if (minSigma != this.minimumSigma) {
    this.minimumSigma=minSigma;
    featuresChanged=true;
    this.featureStack.setMinimumSigma(minSigma);
  }
  if (maxSigma != this.maximumSigma) {
    this.maximumSigma=maxSigma;
    featuresChanged=true;
    this.featureStack.setMaximumSigma(maxSigma);
  }
  Attribute classAttribute=data.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
  }
  for (  String className : loadedClassNames) {
    IJ.log(""String_Node_Str"" + className);
    if (!className.equals(this.classLabels[j])) {
      String currentLabels=classLabels[0];
      for (int i=1; i < numOfClasses; i++)       currentLabels=currentLabels.concat(""String_Node_Str"" + classLabels[i]);
      String loadedLabels=loadedClassNames.get(0);
      for (int i=1; i < loadedClassNames.size(); i++)       loadedLabels=loadedLabels.concat(""String_Node_Str"" + loadedClassNames.get(i));
      IJ.error(""String_Node_Str"" + loadedLabels + ""String_Node_Str""+ currentLabels);
      return false;
    }
    j++;
  }
  if (j != numOfClasses) {
    IJ.error(""String_Node_Str"");
    return false;
  }
  final boolean[] oldEnableFeatures=this.featureStack.getEnableFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.featureStack.setEnableFeatures(usedFeatures);
    updateFeatures=true;
  }
  return true;
}",0.9879963065558632
22767,"/** 
 * Apply classifier to test data
 */
public void applyClassifierToTestData(){
  File[] imageFiles;
  String storeDir=""String_Node_Str"";
  JFileChooser fileChooser=new JFileChooser(""String_Node_Str"");
  fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  fileChooser.setMultiSelectionEnabled(true);
  int returnVal=fileChooser.showOpenDialog(null);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    imageFiles=fileChooser.getSelectedFiles();
  }
 else {
    return;
  }
  boolean showResults=true;
  boolean storeResults=false;
  if (imageFiles.length >= 3) {
    int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
    if (decision == JOptionPane.YES_OPTION) {
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setMultiSelectionEnabled(false);
      returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        storeDir=fileChooser.getSelectedFile().getPath();
      }
 else {
        return;
      }
      showResults=false;
      storeResults=true;
    }
  }
  final boolean probabilityMaps;
  int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
  if (decision == JOptionPane.YES_OPTION)   probabilityMaps=true;
 else   probabilityMaps=false;
  final int numProcessors=Runtime.getRuntime().availableProcessors();
  final int numFurtherThreads=numProcessors / imageFiles.length;
  IJ.log(""String_Node_Str"" + imageFiles.length + ""String_Node_Str""+ numProcessors+ ""String_Node_Str"");
  setButtonsEnabled(false);
  Thread[] threads=new Thread[numProcessors];
class ImageProcessingThread extends Thread {
    final int numThread;
    final int numProcessors;
    final File[] imageFiles;
    final boolean storeResults;
    final boolean showResults;
    final String storeDir;
    public ImageProcessingThread(    int numThread,    int numProcessors,    File[] imageFiles,    boolean storeResults,    boolean showResults,    String storeDir){
      this.numThread=numThread;
      this.numProcessors=numProcessors;
      this.imageFiles=imageFiles;
      this.storeResults=storeResults;
      this.showResults=showResults;
      this.storeDir=storeDir;
    }
    public void run(){
      for (int i=numThread; i < imageFiles.length; i+=numProcessors) {
        File file=imageFiles[i];
        ImagePlus testImage=IJ.openImage(file.getPath());
        IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ numThread);
        ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,numFurtherThreads,probabilityMaps);
        if (showResults) {
          segmentation.show();
          testImage.show();
        }
        if (storeResults) {
          String filename=storeDir + File.separator + file.getName();
          IJ.log(""String_Node_Str"" + filename);
          IJ.save(segmentation,filename);
          segmentation.close();
          testImage.close();
        }
      }
    }
  }
  for (int i=0; i < numProcessors; i++) {
    threads[i]=new ImageProcessingThread(i,numProcessors,imageFiles,storeResults,showResults,storeDir);
    threads[i].start();
  }
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  updateButtonsEnabling();
}","/** 
 * Apply classifier to test data
 */
public void applyClassifierToTestData(){
  File[] imageFiles;
  String storeDir=""String_Node_Str"";
  JFileChooser fileChooser=new JFileChooser(""String_Node_Str"");
  fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  fileChooser.setMultiSelectionEnabled(true);
  int returnVal=fileChooser.showOpenDialog(null);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    imageFiles=fileChooser.getSelectedFiles();
  }
 else {
    return;
  }
  boolean showResults=true;
  boolean storeResults=false;
  if (imageFiles.length >= 3) {
    int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
    if (decision == JOptionPane.YES_OPTION) {
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setMultiSelectionEnabled(false);
      returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        storeDir=fileChooser.getSelectedFile().getPath();
      }
 else {
        return;
      }
      showResults=false;
      storeResults=true;
    }
  }
  final boolean probabilityMaps;
  int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
  if (decision == JOptionPane.YES_OPTION)   probabilityMaps=true;
 else   probabilityMaps=false;
  final int numProcessors=Runtime.getRuntime().availableProcessors();
  final int numThreads=Math.min(imageFiles.length,numProcessors);
  final int numFurtherThreads=(int)Math.ceil((double)(numProcessors - numThreads) / imageFiles.length) + 1;
  IJ.log(""String_Node_Str"" + imageFiles.length + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  setButtonsEnabled(false);
  Thread[] threads=new Thread[numThreads];
class ImageProcessingThread extends Thread {
    final int numThread;
    final int numProcessors;
    final File[] imageFiles;
    final boolean storeResults;
    final boolean showResults;
    final String storeDir;
    public ImageProcessingThread(    int numThread,    int numProcessors,    File[] imageFiles,    boolean storeResults,    boolean showResults,    String storeDir){
      this.numThread=numThread;
      this.numProcessors=numProcessors;
      this.imageFiles=imageFiles;
      this.storeResults=storeResults;
      this.showResults=showResults;
      this.storeDir=storeDir;
    }
    public void run(){
      for (int i=numThread; i < imageFiles.length; i+=numProcessors) {
        File file=imageFiles[i];
        ImagePlus testImage=IJ.openImage(file.getPath());
        IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ numThread);
        ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,numFurtherThreads,probabilityMaps);
        if (showResults) {
          segmentation.show();
          testImage.show();
        }
        if (storeResults) {
          String filename=storeDir + File.separator + file.getName();
          IJ.log(""String_Node_Str"" + filename);
          IJ.save(segmentation,filename);
          segmentation.close();
          testImage.close();
        }
      }
    }
  }
  for (int i=0; i < numProcessors; i++) {
    threads[i]=new ImageProcessingThread(i,numProcessors,imageFiles,storeResults,showResults,storeDir);
    threads[i].start();
  }
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  updateButtonsEnabling();
}",0.979705066433056
22768,"/** 
 * Apply classifier to test data
 */
public void applyClassifierToTestData(){
  File[] imageFiles;
  String storeDir=""String_Node_Str"";
  JFileChooser fileChooser=new JFileChooser(""String_Node_Str"");
  fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  fileChooser.setMultiSelectionEnabled(true);
  int returnVal=fileChooser.showOpenDialog(null);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    imageFiles=fileChooser.getSelectedFiles();
  }
 else {
    return;
  }
  boolean showResults=true;
  boolean storeResults=false;
  if (imageFiles.length >= 3) {
    int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
    if (decision == JOptionPane.YES_OPTION) {
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setMultiSelectionEnabled(false);
      returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        storeDir=fileChooser.getSelectedFile().getPath();
      }
 else {
        return;
      }
      showResults=false;
      storeResults=true;
    }
  }
  final boolean probabilityMaps;
  int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
  if (decision == JOptionPane.YES_OPTION)   probabilityMaps=true;
 else   probabilityMaps=false;
  final int numProcessors=Runtime.getRuntime().availableProcessors();
  final int numThreads=Math.min(imageFiles.length,numProcessors);
  final int numFurtherThreads=(int)Math.ceil((double)(numProcessors - numThreads) / imageFiles.length) + 1;
  IJ.log(""String_Node_Str"" + imageFiles.length + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  setButtonsEnabled(false);
  Thread[] threads=new Thread[numThreads];
class ImageProcessingThread extends Thread {
    final int numThread;
    final int numProcessors;
    final File[] imageFiles;
    final boolean storeResults;
    final boolean showResults;
    final String storeDir;
    public ImageProcessingThread(    int numThread,    int numProcessors,    File[] imageFiles,    boolean storeResults,    boolean showResults,    String storeDir){
      this.numThread=numThread;
      this.numProcessors=numProcessors;
      this.imageFiles=imageFiles;
      this.storeResults=storeResults;
      this.showResults=showResults;
      this.storeDir=storeDir;
    }
    public void run(){
      for (int i=numThread; i < imageFiles.length; i+=numProcessors) {
        File file=imageFiles[i];
        ImagePlus testImage=IJ.openImage(file.getPath());
        IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ numThread);
        ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,numFurtherThreads,probabilityMaps);
        if (showResults) {
          segmentation.show();
          testImage.show();
        }
        if (storeResults) {
          String filename=storeDir + File.separator + file.getName();
          IJ.log(""String_Node_Str"" + filename);
          IJ.save(segmentation,filename);
          segmentation.close();
          testImage.close();
        }
      }
    }
  }
  for (int i=0; i < numProcessors; i++) {
    threads[i]=new ImageProcessingThread(i,numProcessors,imageFiles,storeResults,showResults,storeDir);
    threads[i].start();
  }
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  updateButtonsEnabling();
}","/** 
 * Apply classifier to test data
 */
public void applyClassifierToTestData(){
  File[] imageFiles;
  String storeDir=""String_Node_Str"";
  JFileChooser fileChooser=new JFileChooser(""String_Node_Str"");
  fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  fileChooser.setMultiSelectionEnabled(true);
  int returnVal=fileChooser.showOpenDialog(null);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    imageFiles=fileChooser.getSelectedFiles();
  }
 else {
    return;
  }
  boolean showResults=true;
  boolean storeResults=false;
  if (imageFiles.length >= 3) {
    int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
    if (decision == JOptionPane.YES_OPTION) {
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setMultiSelectionEnabled(false);
      returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        storeDir=fileChooser.getSelectedFile().getPath();
      }
 else {
        return;
      }
      showResults=false;
      storeResults=true;
    }
  }
  final boolean probabilityMaps;
  int decision=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
  if (decision == JOptionPane.YES_OPTION)   probabilityMaps=true;
 else   probabilityMaps=false;
  final int numProcessors=Runtime.getRuntime().availableProcessors();
  final int numThreads=Math.min(imageFiles.length,numProcessors);
  final int numFurtherThreads=(int)Math.ceil((double)(numProcessors - numThreads) / imageFiles.length) + 1;
  IJ.log(""String_Node_Str"" + imageFiles.length + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  setButtonsEnabled(false);
  Thread[] threads=new Thread[numThreads];
class ImageProcessingThread extends Thread {
    final int numThread;
    final int numThreads;
    final File[] imageFiles;
    final boolean storeResults;
    final boolean showResults;
    final String storeDir;
    public ImageProcessingThread(    int numThread,    int numThreads,    File[] imageFiles,    boolean storeResults,    boolean showResults,    String storeDir){
      this.numThread=numThread;
      this.numThreads=numThreads;
      this.imageFiles=imageFiles;
      this.storeResults=storeResults;
      this.showResults=showResults;
      this.storeDir=storeDir;
    }
    public void run(){
      for (int i=numThread; i < imageFiles.length; i+=numThreads) {
        File file=imageFiles[i];
        ImagePlus testImage=IJ.openImage(file.getPath());
        IJ.log(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ numThread);
        ImagePlus segmentation=wekaSegmentation.applyClassifier(testImage,numFurtherThreads,probabilityMaps);
        if (showResults) {
          segmentation.show();
          testImage.show();
        }
        if (storeResults) {
          String filename=storeDir + File.separator + file.getName();
          IJ.log(""String_Node_Str"" + filename);
          IJ.save(segmentation,filename);
          segmentation.close();
          testImage.close();
        }
      }
    }
  }
  for (int i=0; i < numThreads; i++) {
    threads[i]=new ImageProcessingThread(i,numThreads,imageFiles,storeResults,showResults,storeDir);
    threads[i].start();
  }
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  updateButtonsEnabling();
}",0.9834078776511326
22769,"public ImageProcessingThread(int numThread,int numProcessors,File[] imageFiles,boolean storeResults,boolean showResults,String storeDir){
  this.numThread=numThread;
  this.numProcessors=numProcessors;
  this.imageFiles=imageFiles;
  this.storeResults=storeResults;
  this.showResults=showResults;
  this.storeDir=storeDir;
}","public ImageProcessingThread(int numThread,int numThreads,File[] imageFiles,boolean storeResults,boolean showResults,String storeDir){
  this.numThread=numThread;
  this.numThreads=numThreads;
  this.imageFiles=imageFiles;
  this.storeResults=storeResults;
  this.showResults=showResults;
  this.storeDir=storeDir;
}",0.9141965678627144
22770,"/** 
 * Use simple point relaxation to warp 2D source into 2D target.  Source is only modified at nonzero locations in the mask  (multi-thread version)
 * @param source input image to be relaxed
 * @param target target image
 * @param mask image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image
 */
public ImagePlus simplePointWarp2dMT(ImagePlus source,ImagePlus target,ImagePlus mask,double binaryThreshold){
  if (source.getWidth() != target.getWidth() || source.getHeight() != target.getHeight() || source.getImageStackSize() != target.getImageStackSize()) {
    IJ.log(""String_Node_Str"");
    return null;
  }
  final ImageStack sourceSlices=source.getImageStack();
  final ImageStack targetSlices=target.getImageStack();
  final ImageStack maskSlices=(null != mask) ? mask.getImageStack() : null;
  final ImageStack warpedSource=new ImageStack(source.getWidth(),source.getHeight());
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<WarpingResults>> futures=new ArrayList<Future<WarpingResults>>();
  try {
    for (int i=1; i <= sourceSlices.getSize(); i++) {
      futures.add(exe.submit(simplePointWarp2DConcurrent(sourceSlices.getProcessor(i),targetSlices.getProcessor(i),null != mask ? maskSlices.getProcessor(i) : null,binaryThreshold)));
    }
    double warpingError=0;
    int i=0;
    for (    Future<WarpingResults> f : futures) {
      final WarpingResults wr=f.get();
      if (null != wr.warpedSource)       warpedSource.addSlice(""String_Node_Str"" + i,wr.warpedSource.getProcessor());
      if (wr.warpingError != -1)       warpingError+=wr.warpingError;
      i++;
    }
    IJ.log(""String_Node_Str"" + (warpingError / sourceSlices.getSize()));
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
  }
 finally {
    exe.shutdown();
  }
  return new ImagePlus(""String_Node_Str"",warpedSource);
}","/** 
 * Use simple point relaxation to warp 2D source into 2D target.  Source is only modified at nonzero locations in the mask  (multi-thread version)
 * @param source input image to be relaxed
 * @param target target image
 * @param mask image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image
 */
public ImagePlus simplePointWarp2dMT(ImagePlus source,ImagePlus target,ImagePlus mask,double binaryThreshold){
  if (source.getWidth() != target.getWidth() || source.getHeight() != target.getHeight() || source.getImageStackSize() != target.getImageStackSize()) {
    IJ.log(""String_Node_Str"");
    return null;
  }
  final ImageStack sourceSlices=source.getImageStack();
  final ImageStack targetSlices=target.getImageStack();
  final ImageStack maskSlices=(null != mask) ? mask.getImageStack() : null;
  final ImageStack warpedSource=new ImageStack(source.getWidth(),source.getHeight());
  final ExecutorService exe=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<WarpingResults>> futures=new ArrayList<Future<WarpingResults>>();
  try {
    for (int i=1; i <= sourceSlices.getSize(); i++) {
      futures.add(exe.submit(simplePointWarp2DConcurrent(sourceSlices.getProcessor(i),targetSlices.getProcessor(i),null != maskSlices ? maskSlices.getProcessor(i) : null,binaryThreshold)));
    }
    double warpingError=0;
    int i=0;
    for (    Future<WarpingResults> f : futures) {
      final WarpingResults wr=f.get();
      if (null != wr.warpedSource)       warpedSource.addSlice(""String_Node_Str"" + i,wr.warpedSource.getProcessor());
      if (wr.warpingError != -1)       warpingError+=wr.warpingError;
      i++;
    }
    IJ.log(""String_Node_Str"" + (warpingError / sourceSlices.getSize()));
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
    ex.printStackTrace();
  }
 finally {
    exe.shutdown();
  }
  return new ImagePlus(""String_Node_Str"",warpedSource);
}",0.9917948717948718
22771,"/** 
 * Use simple point relaxation to warp 2D source into 2D target.  Source is only modified at nonzero locations in the mask
 * @param source input 2D image to be relaxed
 * @param target target 2D image
 * @param mask 2D image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image and warping error
 */
public static WarpingResults simplePointWarp2d(ImageProcessor source,ImageProcessor target,ImageProcessor mask,double binaryThreshold){
  if (binaryThreshold < 0 || binaryThreshold > 1)   binaryThreshold=0.5;
  final ImagePlus targetReal=new ImagePlus(""String_Node_Str"",target.duplicate());
  final ImagePlus targetBin=new ImagePlus(""String_Node_Str"",target.duplicate());
  final ImagePlus sourceReal=new ImagePlus(""String_Node_Str"",source.duplicate());
  final ImagePlus maskReal=(null != mask) ? new ImagePlus(""String_Node_Str"",mask.duplicate()) : null;
  final int width=target.getWidth();
  final int height=target.getHeight();
  IJ.run(targetReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  IJ.run(targetBin,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  IJ.run(sourceReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  if (null != maskReal)   IJ.run(maskReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  final float[] sourceRealPix=(float[])sourceReal.getProcessor().getPixels();
  for (int i=0; i < sourceRealPix.length; i++)   if (sourceRealPix[i] > 0)   sourceRealPix[i]=1.0f;
  final float[] targetBinPix=(float[])targetBin.getProcessor().getPixels();
  for (int i=0; i < targetBinPix.length; i++)   targetBinPix[i]=(targetBinPix[i] > binaryThreshold) ? 1.0f : 0.0f;
  double diff=Double.MIN_VALUE;
  double diff_before=0;
  while (true) {
    ImageProcessor missclass_points_image=sourceReal.getProcessor().duplicate();
    missclass_points_image.copyBits(targetBin.getProcessor(),0,0,Blitter.DIFFERENCE);
    diff_before=diff;
    float pixels[]=(float[])missclass_points_image.getPixels();
    float mask_pixels[]=(null != mask) ? (float[])maskReal.getProcessor().getPixels() : new float[pixels.length];
    if (null == mask)     Arrays.fill(mask_pixels,1f);
    diff=0;
    for (int k=0; k < pixels.length; k++)     if (pixels[k] != 0 && mask_pixels[k] != 0)     diff++;
    if (diff == diff_before || diff == 0)     break;
    final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
    final float[] realTargetPix=(float[])targetReal.getProcessor().getPixels();
    for (int x=1; x < width + 1; x++)     for (int y=1; y < height + 1; y++) {
      if (pixels[x + y * (width + 2)] != 0 && mask_pixels[x + y * (width + 2)] != 0)       mismatches.add(new Point3f(x,y,(float)Math.abs(realTargetPix[x + y * (width + 2)] - binaryThreshold)));
    }
    Collections.sort(mismatches,new Comparator<Point3f>(){
      public int compare(      Point3f o1,      Point3f o2){
        return (int)((o2.z - o1.z) * 10000);
      }
    }
);
    for (    final Point3f p : mismatches) {
      final int x=(int)p.x;
      final int y=(int)p.y;
      double[] val=new double[]{sourceRealPix[(x - 1) + (y - 1) * (width + 2)],sourceRealPix[(x) + (y - 1) * (width + 2)],sourceRealPix[(x + 1) + (y - 1) * (width + 2)],sourceRealPix[(x - 1) + (y) * (width + 2)],sourceRealPix[(x) + (y) * (width + 2)],sourceRealPix[(x + 1) + (y) * (width + 2)],sourceRealPix[(x - 1) + (y + 1) * (width + 2)],sourceRealPix[(x) + (y + 1) * (width + 2)],sourceRealPix[(x + 1) + (y + 1) * (width + 2)]};
      final double pix=val[4];
      final ImagePlus patch=new ImagePlus(""String_Node_Str"",new FloatProcessor(3,3,val));
      if (simple2D(patch,4)) {
        sourceRealPix[x + y * (width + 2)]=pix > 0.0 ? 0.0f : 1.0f;
      }
    }
  }
  IJ.run(sourceReal,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
  WarpingResults result=new WarpingResults();
  result.warpedSource=sourceReal;
  result.warpingError=diff / (width * height);
  return result;
}","/** 
 * Use simple point relaxation to warp 2D source into 2D target.  Source is only modified at nonzero locations in the mask
 * @param source input 2D image to be relaxed
 * @param target target 2D image
 * @param mask 2D image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image and warping error
 */
public static WarpingResults simplePointWarp2d(final ImageProcessor source,final ImageProcessor target,final ImageProcessor mask,double binaryThreshold){
  if (binaryThreshold < 0 || binaryThreshold > 1)   binaryThreshold=0.5;
  final ImagePlus targetReal=new ImagePlus(""String_Node_Str"",target.duplicate());
  final ImagePlus targetBin=new ImagePlus(""String_Node_Str"",target.duplicate());
  final ImagePlus sourceReal=new ImagePlus(""String_Node_Str"",source.duplicate());
  final ImagePlus maskReal=(null != mask) ? new ImagePlus(""String_Node_Str"",mask.duplicate().convertToFloat()) : null;
  final int width=target.getWidth();
  final int height=target.getHeight();
  IJ.run(targetReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  IJ.run(targetBin,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  IJ.run(sourceReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  if (null != maskReal)   IJ.run(maskReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  final float[] sourceRealPix=(float[])sourceReal.getProcessor().getPixels();
  for (int i=0; i < sourceRealPix.length; i++)   if (sourceRealPix[i] > 0)   sourceRealPix[i]=1.0f;
  final float[] targetBinPix=(float[])targetBin.getProcessor().getPixels();
  for (int i=0; i < targetBinPix.length; i++)   targetBinPix[i]=(targetBinPix[i] > binaryThreshold) ? 1.0f : 0.0f;
  double diff=Double.MIN_VALUE;
  double diff_before=0;
  while (true) {
    ImageProcessor missclass_points_image=sourceReal.getProcessor().duplicate();
    missclass_points_image.copyBits(targetBin.getProcessor(),0,0,Blitter.DIFFERENCE);
    diff_before=diff;
    float pixels[]=(float[])missclass_points_image.getPixels();
    float mask_pixels[]=(null != maskReal) ? (float[])maskReal.getProcessor().getPixels() : new float[pixels.length];
    if (null == maskReal)     Arrays.fill(mask_pixels,1f);
    diff=0;
    for (int k=0; k < pixels.length; k++)     if (pixels[k] != 0 && mask_pixels[k] != 0)     diff++;
    if (diff == diff_before || diff == 0)     break;
    final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
    final float[] realTargetPix=(float[])targetReal.getProcessor().getPixels();
    for (int x=1; x < width + 1; x++)     for (int y=1; y < height + 1; y++) {
      if (pixels[x + y * (width + 2)] != 0 && mask_pixels[x + y * (width + 2)] != 0)       mismatches.add(new Point3f(x,y,(float)Math.abs(realTargetPix[x + y * (width + 2)] - binaryThreshold)));
    }
    Collections.sort(mismatches,new Comparator<Point3f>(){
      public int compare(      Point3f o1,      Point3f o2){
        return (int)((o2.z - o1.z) * 10000);
      }
    }
);
    for (    final Point3f p : mismatches) {
      final int x=(int)p.x;
      final int y=(int)p.y;
      double[] val=new double[]{sourceRealPix[(x - 1) + (y - 1) * (width + 2)],sourceRealPix[(x) + (y - 1) * (width + 2)],sourceRealPix[(x + 1) + (y - 1) * (width + 2)],sourceRealPix[(x - 1) + (y) * (width + 2)],sourceRealPix[(x) + (y) * (width + 2)],sourceRealPix[(x + 1) + (y) * (width + 2)],sourceRealPix[(x - 1) + (y + 1) * (width + 2)],sourceRealPix[(x) + (y + 1) * (width + 2)],sourceRealPix[(x + 1) + (y + 1) * (width + 2)]};
      final double pix=val[4];
      final ImagePlus patch=new ImagePlus(""String_Node_Str"",new FloatProcessor(3,3,val));
      if (simple2D(patch,4)) {
        sourceRealPix[x + y * (width + 2)]=pix > 0.0 ? 0.0f : 1.0f;
      }
    }
  }
  IJ.run(sourceReal,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
  WarpingResults result=new WarpingResults();
  result.warpedSource=sourceReal;
  result.warpingError=diff / (width * height);
  return result;
}",0.994857074512618
22772,"/** 
 * Load a new image to segment (no GUI)
 * @param newImage new image to segment
 * @return false if error
 */
public boolean loadNewImage(ImagePlus newImage){
  if (Math.max(newImage.getWidth(),newImage.getHeight()) > 1024)   if (!IJ.showMessageWithCancel(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""))   return false;
  IJ.log(""String_Node_Str"");
  if (featureStack.isEmpty() || updateFeatures) {
    IJ.log(""String_Node_Str"");
    featureStack.updateFeaturesMT();
    filterFeatureStackByList();
    updateFeatures=false;
    IJ.log(""String_Node_Str"");
  }
  Instances data=createTrainingInstances();
  if (null != loadedTrainingData && null != data) {
    data.setClassIndex(data.numAttributes() - 1);
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++) {
      data.add(loadedTrainingData.instance(i));
    }
    IJ.log(""String_Node_Str"");
  }
 else   if (null == data)   data=loadedTrainingData;
  loadedTrainingData=data;
  if (null != loadedTrainingData) {
    Attribute classAttribute=loadedTrainingData.classAttribute();
    Enumeration<String> classValues=classAttribute.enumerateValues();
    loadedClassNames=new ArrayList<String>();
    while (classValues.hasMoreElements()) {
      final String className=classValues.nextElement().trim();
      loadedClassNames.add(className);
    }
    IJ.log(""String_Node_Str"" + loadedTrainingData.numInstances());
  }
 else   IJ.log(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  for (int i=0; i < numOfClasses; i++) {
    examples[i]=new ArrayList<Roi>();
  }
  IJ.log(""String_Node_Str"");
  trainingImage.setProcessor(""String_Node_Str"",newImage.getProcessor().duplicate().convertToByte(true));
  final boolean[] enabledFeatures=featureStack.getEnableFeatures();
  featureStack=new FeatureStack(trainingImage);
  featureStack.setEnableFeatures(enabledFeatures);
  updateFeatures=true;
  updateWholeData=true;
  classifiedImage=null;
  IJ.log(""String_Node_Str"");
  return true;
}","/** 
 * Load a new image to segment (no GUI)
 * @param newImage new image to segment
 * @return false if error
 */
public boolean loadNewImage(ImagePlus newImage){
  if (Math.max(newImage.getWidth(),newImage.getHeight()) > 1024)   if (!IJ.showMessageWithCancel(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""))   return false;
  IJ.log(""String_Node_Str"");
  if (featureStack.isEmpty() || updateFeatures) {
    IJ.log(""String_Node_Str"");
    featureStack.updateFeaturesMT();
    filterFeatureStackByList();
    updateFeatures=false;
    IJ.log(""String_Node_Str"");
  }
  Instances data=createTrainingInstances();
  if (null != loadedTrainingData && null != data) {
    data.setClassIndex(data.numAttributes() - 1);
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++) {
      data.add(loadedTrainingData.instance(i));
    }
    IJ.log(""String_Node_Str"");
  }
 else   if (null == data)   data=loadedTrainingData;
  loadedTrainingData=data;
  if (null != loadedTrainingData) {
    Attribute classAttribute=loadedTrainingData.classAttribute();
    Enumeration<String> classValues=classAttribute.enumerateValues();
    loadedClassNames=new ArrayList<String>();
    while (classValues.hasMoreElements()) {
      final String className=classValues.nextElement().trim();
      loadedClassNames.add(className);
    }
    IJ.log(""String_Node_Str"" + loadedTrainingData.numInstances());
  }
 else   IJ.log(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  for (int i=0; i < numOfClasses; i++) {
    examples[i]=new ArrayList<Roi>();
  }
  IJ.log(""String_Node_Str"");
  trainingImage.setProcessor(""String_Node_Str"",newImage.getProcessor().duplicate().convertToByte(true));
  final boolean[] enabledFeatures=featureStack.getEnableFeatures();
  featureStack=new FeatureStack(trainingImage);
  featureStack.setEnableFeatures(enabledFeatures);
  featureStack.setMaximumSigma(this.maximumSigma);
  featureStack.setMinimumSigma(this.minimumSigma);
  featureStack.setMembranePatchSize(this.membranePatchSize);
  featureStack.setMembraneSize(this.membraneThickness);
  updateFeatures=true;
  updateWholeData=true;
  classifiedImage=null;
  IJ.log(""String_Node_Str"");
  return true;
}",0.9492468134414832
22773,"/** 
 * Train a classifier using BLOTC (static method)
 * @param image input image
 * @param labels binary labels
 * @param classifier Weka classifier
 * @param resample flag to resample input data (to homogenize classes distribution)
 * @param selectAttributes flag to select best attributes and filter the data
 * @return warped labels from applying BLOTC 
 */
public static ImagePlus trainBLOTC(final ImagePlus image,final ImagePlus labels,final AbstractClassifier classifier,final boolean resample,final boolean selectAttributes){
  final ImageStack warpedLabelStack=new ImageStack(image.getWidth(),image.getHeight());
  for (int i=1; i <= labels.getStackSize(); i++)   warpedLabelStack.addSlice(""String_Node_Str"" + i,labels.getStack().getProcessor(i).duplicate().convertToFloat());
  ImagePlus warpedLabels=new ImagePlus(""String_Node_Str"",warpedLabelStack);
  final Weka_Segmentation seg=new Weka_Segmentation(image);
  if (null != classifier)   seg.setClassifier(classifier);
  seg.useAllFeatures();
  String firstClass=seg.classLabels[0];
  String secondClass=seg.classLabels[1];
  double error=Double.MAX_VALUE;
  final int numOfPixelsPerImage=image.getWidth() * image.getHeight();
  IJ.log(""String_Node_Str"");
  seg.addBinaryData(image,labels,secondClass,firstClass);
  Instances originalData=seg.getTrainingInstances();
  if (selectAttributes) {
    IJ.log(""String_Node_Str"");
    final long start=System.currentTimeMillis();
    originalData=selectAttributes(originalData);
    final long end=System.currentTimeMillis();
    seg.setLoadedTrainingData(originalData);
    IJ.log(""String_Node_Str"" + originalData.numInstances() + ""String_Node_Str""+ originalData.numAttributes()+ ""String_Node_Str""+ originalData.numClasses()+ ""String_Node_Str"");
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  Instances trainingData=originalData;
  if (resample) {
    IJ.log(""String_Node_Str"");
    trainingData=homogenizeTrainingData(trainingData);
    seg.setLoadedTrainingData(trainingData);
  }
  int iter=1;
  while (true) {
    IJ.log(""String_Node_Str"");
    seg.trainClassifier();
    double newError=seg.getTrainingError();
    IJ.log(""String_Node_Str"" + iter + ""String_Node_Str""+ newError);
    if (newError >= error)     break;
    error=newError;
    final ImageStack proposalStack=new ImageStack(image.getWidth(),image.getHeight());
    for (int i=1; i <= image.getStackSize(); i++) {
      final Instances subDataSet=new Instances(originalData,(i - 1) * numOfPixelsPerImage,numOfPixelsPerImage);
      IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
      ImagePlus result=seg.getProbabilityMapsMT(subDataSet,image.getWidth(),image.getHeight());
      proposalStack.addSlice(""String_Node_Str"" + i,result.getImageStack().getProcessor(2));
    }
    final ImagePlus proposal=new ImagePlus(""String_Node_Str"",proposalStack);
    IJ.log(""String_Node_Str"");
    warpedLabels=seg.simplePointWarp2d(warpedLabels,proposal,null,0.5);
    if (!resample)     seg.udpateDataClassification(warpedLabels,secondClass,firstClass);
 else {
      IJ.log(""String_Node_Str"");
      updateDataClassification(originalData,warpedLabels,1,0);
      trainingData=homogenizeTrainingData(originalData);
      seg.setLoadedTrainingData(trainingData);
    }
    iter++;
  }
  return warpedLabels;
}","/** 
 * Train a classifier using BLOTC (static method)
 * @param image input image
 * @param labels binary labels
 * @param classifier Weka classifier
 * @param resample flag to resample input data (to homogenize classes distribution)
 * @param selectAttributes flag to select best attributes and filter the data
 * @return warped labels from applying BLOTC 
 */
public static ImagePlus trainBLOTC(final ImagePlus image,final ImagePlus labels,final AbstractClassifier classifier,final boolean resample,final boolean selectAttributes){
  final ImageStack warpedLabelStack=new ImageStack(image.getWidth(),image.getHeight());
  for (int i=1; i <= labels.getStackSize(); i++)   warpedLabelStack.addSlice(""String_Node_Str"" + i,labels.getStack().getProcessor(i).duplicate().convertToFloat());
  ImagePlus warpedLabels=new ImagePlus(""String_Node_Str"",warpedLabelStack);
  final Weka_Segmentation seg=new Weka_Segmentation(image);
  if (null != classifier)   seg.setClassifier(classifier);
  seg.useAllFeatures();
  String firstClass=seg.classLabels[0];
  String secondClass=seg.classLabels[1];
  double error=Double.MAX_VALUE;
  final int numOfPixelsPerImage=image.getWidth() * image.getHeight();
  IJ.log(""String_Node_Str"");
  seg.addBinaryData(image,labels,secondClass,firstClass);
  Instances originalData=seg.getTrainingInstances();
  if (selectAttributes) {
    IJ.log(""String_Node_Str"");
    final long start=System.currentTimeMillis();
    originalData=selectAttributes(originalData);
    final long end=System.currentTimeMillis();
    seg.setLoadedTrainingData(originalData);
    IJ.log(""String_Node_Str"" + originalData.numInstances() + ""String_Node_Str""+ originalData.numAttributes()+ ""String_Node_Str""+ originalData.numClasses()+ ""String_Node_Str"");
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  Instances trainingData=originalData;
  if (resample) {
    IJ.log(""String_Node_Str"");
    trainingData=homogenizeTrainingData(trainingData);
    seg.setLoadedTrainingData(trainingData);
  }
  int iter=1;
  while (true) {
    IJ.log(""String_Node_Str"");
    seg.trainClassifier();
    double newError=seg.getTrainingError();
    IJ.log(""String_Node_Str"" + iter + ""String_Node_Str""+ newError);
    if (newError >= error)     break;
    error=newError;
    final ImageStack proposalStack=new ImageStack(image.getWidth(),image.getHeight());
    for (int i=1; i <= image.getStackSize(); i++) {
      final Instances subDataSet=new Instances(originalData,(i - 1) * numOfPixelsPerImage,numOfPixelsPerImage);
      IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
      ImagePlus result=seg.getProbabilityMapsMT(subDataSet,image.getWidth(),image.getHeight());
      proposalStack.addSlice(""String_Node_Str"" + i,result.getImageStack().getProcessor(2));
    }
    final ImagePlus proposal=new ImagePlus(""String_Node_Str"",proposalStack);
    IJ.log(""String_Node_Str"");
    warpedLabels=seg.simplePointWarp2dMT(warpedLabels,proposal,null,0.5);
    if (!resample)     seg.udpateDataClassification(warpedLabels,secondClass,firstClass);
 else {
      IJ.log(""String_Node_Str"");
      updateDataClassification(originalData,warpedLabels,1,0);
      trainingData=homogenizeTrainingData(originalData);
      seg.setLoadedTrainingData(trainingData);
    }
    iter++;
  }
  return warpedLabels;
}",0.9996971532404604
22774,"/** 
 * Use simple point relaxation to warp 2D source into 2D target.  Source is only modified at nonzero locations in the mask
 * @param source input 2D image to be relaxed
 * @param target target 2D image
 * @param mask 2D image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image and warping error
 */
public static WarpingResults simplePointWarp2d(final ImageProcessor source,final ImageProcessor target,final ImageProcessor mask,double binaryThreshold){
  if (binaryThreshold < 0 || binaryThreshold > 1)   binaryThreshold=0.5;
  final ImagePlus targetReal=new ImagePlus(""String_Node_Str"",target.duplicate());
  final ImagePlus targetBin=new ImagePlus(""String_Node_Str"",target.duplicate());
  final ImagePlus sourceReal=new ImagePlus(""String_Node_Str"",source.duplicate());
  final ImagePlus maskReal=(null != mask) ? new ImagePlus(""String_Node_Str"",mask.duplicate().convertToFloat()) : null;
  final int width=target.getWidth();
  final int height=target.getHeight();
  IJ.run(targetReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  IJ.run(targetBin,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  IJ.run(sourceReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  if (null != maskReal)   IJ.run(maskReal,""String_Node_Str"",""String_Node_Str"" + (width + 2) + ""String_Node_Str""+ (height + 2)+ ""String_Node_Str"");
  final float[] sourceRealPix=(float[])sourceReal.getProcessor().getPixels();
  for (int i=0; i < sourceRealPix.length; i++)   if (sourceRealPix[i] > 0)   sourceRealPix[i]=1.0f;
  final float[] targetBinPix=(float[])targetBin.getProcessor().getPixels();
  for (int i=0; i < targetBinPix.length; i++)   targetBinPix[i]=(targetBinPix[i] > binaryThreshold) ? 1.0f : 0.0f;
  double diff=Double.MIN_VALUE;
  double diff_before=0;
  while (true) {
    ImageProcessor missclass_points_image=sourceReal.getProcessor().duplicate();
    missclass_points_image.copyBits(targetBin.getProcessor(),0,0,Blitter.DIFFERENCE);
    diff_before=diff;
    float pixels[]=(float[])missclass_points_image.getPixels();
    float mask_pixels[]=(null != maskReal) ? (float[])maskReal.getProcessor().getPixels() : new float[pixels.length];
    if (null == maskReal)     Arrays.fill(mask_pixels,1f);
    diff=0;
    for (int k=0; k < pixels.length; k++)     if (pixels[k] != 0 && mask_pixels[k] != 0)     diff++;
    if (diff == diff_before || diff == 0)     break;
    final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
    final float[] realTargetPix=(float[])targetReal.getProcessor().getPixels();
    for (int x=1; x < width + 1; x++)     for (int y=1; y < height + 1; y++) {
      if (pixels[x + y * (width + 2)] != 0 && mask_pixels[x + y * (width + 2)] != 0)       mismatches.add(new Point3f(x,y,(float)Math.abs(realTargetPix[x + y * (width + 2)] - binaryThreshold)));
    }
    Collections.sort(mismatches,new Comparator<Point3f>(){
      public int compare(      Point3f o1,      Point3f o2){
        return (int)((o2.z - o1.z) * 10000);
      }
    }
);
    for (    final Point3f p : mismatches) {
      final int x=(int)p.x;
      final int y=(int)p.y;
      double[] val=new double[]{sourceRealPix[(x - 1) + (y - 1) * (width + 2)],sourceRealPix[(x) + (y - 1) * (width + 2)],sourceRealPix[(x + 1) + (y - 1) * (width + 2)],sourceRealPix[(x - 1) + (y) * (width + 2)],sourceRealPix[(x) + (y) * (width + 2)],sourceRealPix[(x + 1) + (y) * (width + 2)],sourceRealPix[(x - 1) + (y + 1) * (width + 2)],sourceRealPix[(x) + (y + 1) * (width + 2)],sourceRealPix[(x + 1) + (y + 1) * (width + 2)]};
      final double pix=val[4];
      final ImagePlus patch=new ImagePlus(""String_Node_Str"",new FloatProcessor(3,3,val));
      if (simple2D(patch,4)) {
        sourceRealPix[x + y * (width + 2)]=pix > 0.0 ? 0.0f : 1.0f;
      }
    }
  }
  IJ.run(sourceReal,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
  WarpingResults result=new WarpingResults();
  result.warpedSource=sourceReal;
  result.warpingError=diff / (width * height);
  return result;
}","/** 
 * Use simple point relaxation to warp 2D source into 2D target.  Source is only modified at nonzero locations in the mask
 * @param source input 2D image to be relaxed
 * @param target target 2D image
 * @param mask 2D image mask
 * @param binaryThreshold binarization threshold
 * @return warped source image and warping error
 */
public static WarpingResults simplePointWarp2d(final ImageProcessor source,final ImageProcessor target,final ImageProcessor mask,double binaryThreshold){
  if (binaryThreshold < 0 || binaryThreshold > 1)   binaryThreshold=0.5;
  final ImagePlus targetReal;
  final ImagePlus targetBin;
  final ImagePlus sourceReal;
  final ImagePlus maskReal;
  final int width=target.getWidth();
  final int height=target.getHeight();
  ImageProcessor ip=target.createProcessor(width + 2,height + 2);
  ip.insert(target,1,1);
  targetReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  targetBin=new ImagePlus(""String_Node_Str"",ip.duplicate());
  ip=target.createProcessor(width + 2,height + 2);
  ip.insert(source,1,1);
  sourceReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  if (null != mask) {
    ip=target.createProcessor(width + 2,height + 2);
    ip.insert(mask,1,1);
    maskReal=new ImagePlus(""String_Node_Str"",ip.duplicate());
  }
 else {
    maskReal=null;
  }
  final float[] sourceRealPix=(float[])sourceReal.getProcessor().getPixels();
  for (int i=0; i < sourceRealPix.length; i++)   if (sourceRealPix[i] > 0)   sourceRealPix[i]=1.0f;
  final float[] targetBinPix=(float[])targetBin.getProcessor().getPixels();
  for (int i=0; i < targetBinPix.length; i++)   targetBinPix[i]=(targetBinPix[i] > binaryThreshold) ? 1.0f : 0.0f;
  double diff=Double.MIN_VALUE;
  double diff_before=0;
  while (true) {
    ImageProcessor missclass_points_image=sourceReal.getProcessor().duplicate();
    missclass_points_image.copyBits(targetBin.getProcessor(),0,0,Blitter.DIFFERENCE);
    diff_before=diff;
    float pixels[]=(float[])missclass_points_image.getPixels();
    float mask_pixels[]=(null != maskReal) ? (float[])maskReal.getProcessor().getPixels() : new float[pixels.length];
    if (null == maskReal)     Arrays.fill(mask_pixels,1f);
    diff=0;
    for (int k=0; k < pixels.length; k++)     if (pixels[k] != 0 && mask_pixels[k] != 0)     diff++;
    if (diff == diff_before || diff == 0)     break;
    final ArrayList<Point3f> mismatches=new ArrayList<Point3f>();
    final float[] realTargetPix=(float[])targetReal.getProcessor().getPixels();
    for (int x=1; x < width + 1; x++)     for (int y=1; y < height + 1; y++) {
      if (pixels[x + y * (width + 2)] != 0 && mask_pixels[x + y * (width + 2)] != 0)       mismatches.add(new Point3f(x,y,(float)Math.abs(realTargetPix[x + y * (width + 2)] - binaryThreshold)));
    }
    Collections.sort(mismatches,new Comparator<Point3f>(){
      public int compare(      Point3f o1,      Point3f o2){
        return (int)((o2.z - o1.z) * 10000);
      }
    }
);
    for (    final Point3f p : mismatches) {
      final int x=(int)p.x;
      final int y=(int)p.y;
      double[] val=new double[]{sourceRealPix[(x - 1) + (y - 1) * (width + 2)],sourceRealPix[(x) + (y - 1) * (width + 2)],sourceRealPix[(x + 1) + (y - 1) * (width + 2)],sourceRealPix[(x - 1) + (y) * (width + 2)],sourceRealPix[(x) + (y) * (width + 2)],sourceRealPix[(x + 1) + (y) * (width + 2)],sourceRealPix[(x - 1) + (y + 1) * (width + 2)],sourceRealPix[(x) + (y + 1) * (width + 2)],sourceRealPix[(x + 1) + (y + 1) * (width + 2)]};
      final double pix=val[4];
      final ImagePlus patch=new ImagePlus(""String_Node_Str"",new FloatProcessor(3,3,val));
      if (simple2D(patch,4)) {
        sourceRealPix[x + y * (width + 2)]=pix > 0.0 ? 0.0f : 1.0f;
      }
    }
  }
  ip=source.createProcessor(width,height);
  ip.insert(sourceReal.getProcessor(),-1,-1);
  sourceReal.setProcessor(ip.duplicate());
  WarpingResults result=new WarpingResults();
  result.warpedSource=sourceReal;
  result.warpingError=diff / (width * height);
  return result;
}",0.78839590443686
22775,"/** 
 * Get probability distribution of each class for current classifier  and specific image data (multi-thread version)
 * @param data input data set
 * @param width image width
 * @param height image height
 * @return probability stack, one image per class
 */
public ImagePlus getProbabilityMapsMT(Instances data,final int width,final int height){
  if (this.classifier == null)   return null;
  final int nClasses=data.numClasses();
  final ImageStack is=new ImageStack(width,height);
  final FloatProcessor[] classProb=new FloatProcessor[nClasses];
  for (int k=0; k < nClasses; k++)   classProb[k]=new FloatProcessor(width,height);
  IJ.log(""String_Node_Str"");
  final int numOfProcessors=Runtime.getRuntime().availableProcessors();
  final ExecutorService exe=Executors.newFixedThreadPool(numOfProcessors);
  final ArrayList<Future<double[][]>> futures=new ArrayList<Future<double[][]>>();
  final Instances[] partialData=new Instances[numOfProcessors];
  final int partialSize=data.numInstances() / numOfProcessors;
  final Rectangle[] rects=new Rectangle[numOfProcessors];
  ImagePlus result=null;
  try {
    int block_height=height / numOfProcessors;
    if (height % 2 != 0)     block_height++;
    for (int i=0; i < numOfProcessors; i++) {
      if (i == numOfProcessors - 1) {
        partialData[i]=new Instances(data,i * partialSize,data.numInstances() - i * partialSize);
        block_height=height - i * block_height;
      }
 else {
        partialData[i]=new Instances(data,i * partialSize,partialSize);
      }
      int y_start=i * block_height;
      rects[i]=new Rectangle(0,y_start,width,block_height);
      futures.add(exe.submit(getDistributionForIntances(partialData[i],this.classifier)));
    }
    for (int index=0; index < futures.size(); index++) {
      final double[][] partialProb=futures.get(index).get();
      for (int k=0; k < nClasses; k++)       classProb[k].insert(new FloatProcessor(width,block_height,partialProb[k]),rects[index].x,rects[index].y);
    }
    for (int k=0; k < nClasses; k++)     is.addSlice(""String_Node_Str"" + (k + 1),classProb[k]);
    result=new ImagePlus(""String_Node_Str"",is);
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
  }
 finally {
    exe.shutdown();
  }
  IJ.log(""String_Node_Str"");
  return result;
}","/** 
 * Get probability distribution of each class for current classifier  and specific image data (multi-thread version)
 * @param data input data set
 * @param width image width
 * @param height image height
 * @return probability stack, one image per class
 */
public ImagePlus getProbabilityMapsMT(Instances data,final int width,final int height){
  if (this.classifier == null)   return null;
  final int nClasses=data.numClasses();
  final ImageStack is=new ImageStack(width,height);
  final FloatProcessor[] classProb=new FloatProcessor[nClasses];
  for (int k=0; k < nClasses; k++)   classProb[k]=new FloatProcessor(width,height);
  final int numOfProcessors=Runtime.getRuntime().availableProcessors();
  final ExecutorService exe=Executors.newFixedThreadPool(numOfProcessors);
  final ArrayList<Future<double[][]>> futures=new ArrayList<Future<double[][]>>();
  final Instances[] partialData=new Instances[numOfProcessors];
  final int partialSize=data.numInstances() / numOfProcessors;
  final Rectangle[] rects=new Rectangle[numOfProcessors];
  ImagePlus result=null;
  try {
    int block_height=height / numOfProcessors;
    if (height % 2 != 0)     block_height++;
    for (int i=0; i < numOfProcessors; i++) {
      if (i == numOfProcessors - 1) {
        partialData[i]=new Instances(data,i * partialSize,data.numInstances() - i * partialSize);
        block_height=height - i * block_height;
      }
 else {
        partialData[i]=new Instances(data,i * partialSize,partialSize);
      }
      int y_start=i * block_height;
      rects[i]=new Rectangle(0,y_start,width,block_height);
      futures.add(exe.submit(getDistributionForIntances(partialData[i],this.classifier)));
    }
    for (int index=0; index < futures.size(); index++) {
      final double[][] partialProb=futures.get(index).get();
      for (int k=0; k < nClasses; k++)       classProb[k].insert(new FloatProcessor(width,block_height,partialProb[k]),rects[index].x,rects[index].y);
    }
    for (int k=0; k < nClasses; k++)     is.addSlice(""String_Node_Str"" + (k + 1),classProb[k]);
    result=new ImagePlus(""String_Node_Str"",is);
  }
 catch (  Exception ex) {
    IJ.log(""String_Node_Str"");
  }
 finally {
    exe.shutdown();
  }
  IJ.log(""String_Node_Str"");
  return result;
}",0.9936361641430764
22776,"/** 
 * Train a classifier using BLOTC (static method)
 * @param image input image
 * @param labels binary labels
 * @param classifier Weka classifier
 * @param resample flag to resample input data (to homogenize classes distribution)
 * @param selectAttributes flag to select best attributes and filter the data
 * @return warped labels from applying BLOTC 
 */
public static ImagePlus trainBLOTC(final ImagePlus image,final ImagePlus labels,final AbstractClassifier classifier,final boolean resample,final boolean selectAttributes){
  final ImageStack warpedLabelStack=new ImageStack(image.getWidth(),image.getHeight());
  for (int i=1; i <= labels.getStackSize(); i++)   warpedLabelStack.addSlice(""String_Node_Str"" + i,labels.getStack().getProcessor(i).duplicate().convertToFloat());
  ImagePlus warpedLabels=new ImagePlus(""String_Node_Str"",warpedLabelStack);
  final Weka_Segmentation seg=new Weka_Segmentation(image);
  if (null != classifier)   seg.setClassifier(classifier);
  seg.useAllFeatures();
  String firstClass=seg.classLabels[0];
  String secondClass=seg.classLabels[1];
  double error=Double.MAX_VALUE;
  final int numOfPixelsPerImage=image.getWidth() * image.getHeight();
  IJ.log(""String_Node_Str"");
  seg.addBinaryData(image,labels,secondClass,firstClass);
  Instances originalData=seg.getTrainingInstances();
  if (selectAttributes) {
    IJ.log(""String_Node_Str"");
    final long start=System.currentTimeMillis();
    originalData=selectAttributes(originalData);
    final long end=System.currentTimeMillis();
    seg.setLoadedTrainingData(originalData);
    IJ.log(""String_Node_Str"" + originalData.numInstances() + ""String_Node_Str""+ originalData.numAttributes()+ ""String_Node_Str""+ originalData.numClasses()+ ""String_Node_Str"");
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  Instances trainingData=originalData;
  if (resample) {
    IJ.log(""String_Node_Str"");
    trainingData=homogenizeTrainingData(trainingData);
    seg.setLoadedTrainingData(trainingData);
  }
  int iter=1;
  while (true) {
    IJ.log(""String_Node_Str"");
    seg.trainClassifier();
    double newError=seg.getTrainingError();
    IJ.log(""String_Node_Str"" + iter + ""String_Node_Str""+ newError);
    if (newError >= error)     break;
    error=newError;
    final ImageStack proposalStack=new ImageStack(image.getWidth(),image.getHeight());
    for (int i=1; i <= image.getStackSize(); i++) {
      final Instances subDataSet=new Instances(originalData,(i - 1) * numOfPixelsPerImage,numOfPixelsPerImage);
      ImagePlus result=seg.getProbabilityMapsMT(subDataSet,image.getWidth(),image.getHeight());
      proposalStack.addSlice(""String_Node_Str"" + i,result.getImageStack().getProcessor(2));
    }
    final ImagePlus proposal=new ImagePlus(""String_Node_Str"",proposalStack);
    IJ.log(""String_Node_Str"");
    warpedLabels=simplePointWarp2d(warpedLabels,proposal,null,0.5);
    if (!resample)     seg.udpateDataClassification(warpedLabels,secondClass,firstClass);
 else {
      IJ.log(""String_Node_Str"");
      updateDataClassification(originalData,warpedLabels,1,0);
      trainingData=homogenizeTrainingData(originalData);
      seg.setLoadedTrainingData(trainingData);
    }
    iter++;
  }
  return warpedLabels;
}","/** 
 * Train a classifier using BLOTC (static method)
 * @param image input image
 * @param labels binary labels
 * @param classifier Weka classifier
 * @param resample flag to resample input data (to homogenize classes distribution)
 * @param selectAttributes flag to select best attributes and filter the data
 * @return warped labels from applying BLOTC 
 */
public static ImagePlus trainBLOTC(final ImagePlus image,final ImagePlus labels,final AbstractClassifier classifier,final boolean resample,final boolean selectAttributes){
  final ImageStack warpedLabelStack=new ImageStack(image.getWidth(),image.getHeight());
  for (int i=1; i <= labels.getStackSize(); i++)   warpedLabelStack.addSlice(""String_Node_Str"" + i,labels.getStack().getProcessor(i).duplicate().convertToFloat());
  ImagePlus warpedLabels=new ImagePlus(""String_Node_Str"",warpedLabelStack);
  final Weka_Segmentation seg=new Weka_Segmentation(image);
  if (null != classifier)   seg.setClassifier(classifier);
  seg.useAllFeatures();
  String firstClass=seg.classLabels[0];
  String secondClass=seg.classLabels[1];
  double error=Double.MAX_VALUE;
  final int numOfPixelsPerImage=image.getWidth() * image.getHeight();
  IJ.log(""String_Node_Str"");
  seg.addBinaryData(image,labels,secondClass,firstClass);
  Instances originalData=seg.getTrainingInstances();
  if (selectAttributes) {
    IJ.log(""String_Node_Str"");
    final long start=System.currentTimeMillis();
    originalData=selectAttributes(originalData);
    final long end=System.currentTimeMillis();
    seg.setLoadedTrainingData(originalData);
    IJ.log(""String_Node_Str"" + originalData.numInstances() + ""String_Node_Str""+ originalData.numAttributes()+ ""String_Node_Str""+ originalData.numClasses()+ ""String_Node_Str"");
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  Instances trainingData=originalData;
  if (resample) {
    IJ.log(""String_Node_Str"");
    trainingData=homogenizeTrainingData(trainingData);
    seg.setLoadedTrainingData(trainingData);
  }
  int iter=1;
  while (true) {
    IJ.log(""String_Node_Str"");
    seg.trainClassifier();
    double newError=seg.getTrainingError();
    IJ.log(""String_Node_Str"" + iter + ""String_Node_Str""+ newError);
    if (newError >= error)     break;
    error=newError;
    final ImageStack proposalStack=new ImageStack(image.getWidth(),image.getHeight());
    for (int i=1; i <= image.getStackSize(); i++) {
      final Instances subDataSet=new Instances(originalData,(i - 1) * numOfPixelsPerImage,numOfPixelsPerImage);
      IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
      ImagePlus result=seg.getProbabilityMapsMT(subDataSet,image.getWidth(),image.getHeight());
      proposalStack.addSlice(""String_Node_Str"" + i,result.getImageStack().getProcessor(2));
    }
    final ImagePlus proposal=new ImagePlus(""String_Node_Str"",proposalStack);
    IJ.log(""String_Node_Str"");
    warpedLabels=simplePointWarp2d(warpedLabels,proposal,null,0.5);
    if (!resample)     seg.udpateDataClassification(warpedLabels,secondClass,firstClass);
 else {
      IJ.log(""String_Node_Str"");
      updateDataClassification(originalData,warpedLabels,1,0);
      trainingData=homogenizeTrainingData(originalData);
      seg.setLoadedTrainingData(trainingData);
    }
    iter++;
  }
  return warpedLabels;
}",0.9912804038549794
22777,"/** 
 * Filter feature stack based on the list of feature names to use	
 * @param featureNames list of feature names to use
 * @param featureStack feature stack to filter
 */
public static void filterFeatureStackByList(ArrayList<String> featureNames,FeatureStack featureStack){
  if (null == featureNames)   return;
  for (int i=1; i <= featureStack.getSize(); i++) {
    final String featureName=featureStack.getSliceLabel(i);
    IJ.log(""String_Node_Str"" + featureName + ""String_Node_Str"");
    if (false == featureNames.contains(featureName)) {
      featureStack.removeFeature(featureName);
      i--;
    }
  }
  featureStack.show();
}","/** 
 * Filter feature stack based on the list of feature names to use	
 * @param featureNames list of feature names to use
 * @param featureStack feature stack to filter
 */
public static void filterFeatureStackByList(ArrayList<String> featureNames,FeatureStack featureStack){
  IJ.log(""String_Node_Str"");
  if (null == featureNames)   return;
  for (int i=1; i <= featureStack.getSize(); i++) {
    final String featureName=featureStack.getSliceLabel(i);
    if (false == featureNames.contains(featureName)) {
      featureStack.removeFeature(featureName);
      i--;
    }
  }
}",0.719082719082719
22778,"/** 
 * Create training instances out of the user markings
 * @return set of instances
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStack.getSize(); i++) {
    String attString=featureStack.getSliceLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes=new ArrayList<String>();
  int numOfInstances=0;
  int numOfUsedClasses=0;
  for (int i=0; i < numOfClasses; i++) {
    if (examples[i].size() > 0) {
      classes.add(classLabels[i]);
      numOfUsedClasses++;
    }
    numOfInstances+=examples[i].size();
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int j=0; j < examples[l].size(); j++) {
      Roi r=examples[l].get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStack.getSize() + 1];
            for (int z=1; z <= featureStack.getSize(); z++)             values[z - 1]=featureStack.getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStack.getSize()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStack.getWidth() && y >= 0 && y < featureStack.getHeight()) {
                double[] values=new double[featureStack.getSize() + 1];
                for (int z=1; z <= featureStack.getSize(); z++)                 values[z - 1]=featureStack.getProcessor(z).getInterpolatedValue(x,y);
                values[featureStack.getSize()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStack.getSize() + 1];
          for (int z=1; z <= featureStack.getSize(); z++)           values[z - 1]=featureStack.getProcessor(z).getPixelValue(x,y);
          values[featureStack.getSize()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + classLabels[l] + ""String_Node_Str""+ nl);
  }
  if (trainingData.numInstances() == 0)   return null;
  return trainingData;
}","/** 
 * Create training instances out of the user markings
 * @return set of instances
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStack.getSize(); i++) {
    String attString=featureStack.getSliceLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes;
  int numOfInstances=0;
  int numOfUsedClasses=0;
  if (null == this.loadedTrainingData) {
    classes=new ArrayList<String>();
    for (int i=0; i < numOfClasses; i++) {
      if (examples[i].size() > 0) {
        classes.add(classLabels[i]);
        numOfUsedClasses++;
      }
      numOfInstances+=examples[i].size();
    }
  }
 else {
    classes=this.loadedClassNames;
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int j=0; j < examples[l].size(); j++) {
      Roi r=examples[l].get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStack.getSize() + 1];
            for (int z=1; z <= featureStack.getSize(); z++)             values[z - 1]=featureStack.getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStack.getSize()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStack.getWidth() && y >= 0 && y < featureStack.getHeight()) {
                double[] values=new double[featureStack.getSize() + 1];
                for (int z=1; z <= featureStack.getSize(); z++)                 values[z - 1]=featureStack.getProcessor(z).getInterpolatedValue(x,y);
                values[featureStack.getSize()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStack.getSize() + 1];
          for (int z=1; z <= featureStack.getSize(); z++)           values[z - 1]=featureStack.getProcessor(z).getPixelValue(x,y);
          values[featureStack.getSize()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + classLabels[l] + ""String_Node_Str""+ nl);
  }
  if (trainingData.numInstances() == 0)   return null;
  trainingData.setClassIndex(featureStack.getSize());
  return trainingData;
}",0.9694050253873192
22779,"/** 
 * Train classifier with the current instances
 */
public boolean trainClassifier(){
  int nonEmpty=0;
  for (int i=0; i < numOfClasses; i++)   if (examples[i].size() > 0)   nonEmpty++;
  if (nonEmpty < 2 && loadedTrainingData == null) {
    IJ.showMessage(""String_Node_Str"");
    return false;
  }
  setButtonsEnabled(false);
  if (nonEmpty > 1 && featureStack.isEmpty() || updateFeatures) {
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    featureStack.updateFeaturesMT();
    filterFeatureStackByList();
    updateFeatures=false;
    updateWholeData=true;
    IJ.log(""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  Instances data=null;
  if (nonEmpty < 2)   IJ.log(""String_Node_Str"");
 else {
    final long start=System.currentTimeMillis();
    data=createTrainingInstances();
    final long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
    data.setClassIndex(data.numAttributes() - 1);
  }
  if (loadedTrainingData != null && data != null) {
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++)     data.add(loadedTrainingData.instance(i));
    IJ.log(""String_Node_Str"" + data.numInstances());
  }
 else   if (data == null) {
    data=loadedTrainingData;
    IJ.log(""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  if (null == data) {
    IJ.log(""String_Node_Str"");
  }
  this.trainHeader=new Instances(data,0);
  final long start=System.currentTimeMillis();
  try {
    classifier.buildClassifier(data);
  }
 catch (  Exception e) {
    IJ.showMessage(e.getMessage());
    e.printStackTrace();
    return false;
  }
  IJ.log(this.classifier.toString());
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return true;
}","/** 
 * Train classifier with the current instances
 */
public boolean trainClassifier(){
  int nonEmpty=0;
  for (int i=0; i < numOfClasses; i++)   if (examples[i].size() > 0)   nonEmpty++;
  if (nonEmpty < 2 && null == loadedTrainingData) {
    IJ.showMessage(""String_Node_Str"");
    return false;
  }
  setButtonsEnabled(false);
  if (nonEmpty > 1 && featureStack.isEmpty() || updateFeatures) {
    IJ.showStatus(""String_Node_Str"");
    IJ.log(""String_Node_Str"");
    featureStack.updateFeaturesMT();
    filterFeatureStackByList();
    updateFeatures=false;
    updateWholeData=true;
    IJ.log(""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  Instances data=null;
  if (nonEmpty < 1)   IJ.log(""String_Node_Str"");
 else {
    final long start=System.currentTimeMillis();
    data=createTrainingInstances();
    final long end=System.currentTimeMillis();
    IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  }
  if (loadedTrainingData != null && data != null) {
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++)     data.add(loadedTrainingData.instance(i));
    IJ.log(""String_Node_Str"" + data.numInstances());
  }
 else   if (data == null) {
    data=loadedTrainingData;
    IJ.log(""String_Node_Str"");
  }
  IJ.showStatus(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  if (null == data) {
    IJ.log(""String_Node_Str"");
  }
  this.trainHeader=new Instances(data,0);
  final long start=System.currentTimeMillis();
  try {
    classifier.buildClassifier(data);
  }
 catch (  Exception e) {
    IJ.showMessage(e.getMessage());
    e.printStackTrace();
    return false;
  }
  IJ.log(this.classifier.toString());
  final long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return true;
}",0.9815217391304348
22780,"/** 
 * Select attributes to reduce the number of parameters per instance
 * @param data input set of instances
 * @return resampled set of instances
 */
public static Instances selectAttributes(Instances data){
  final AttributeSelection filter=new AttributeSelection();
  Instances filteredIns=null;
  final CfsSubsetEval evaluator=new CfsSubsetEval();
  evaluator.setMissingSeparate(true);
  filter.setEvaluator(evaluator);
  final BestFirst search=new BestFirst();
  filter.setSearch(search);
  try {
    filter.setInputFormat(data);
    filteredIns=Filter.useFilter(data,filter);
  }
 catch (  Exception e) {
    IJ.log(""String_Node_Str"");
    e.printStackTrace();
  }
  return filteredIns;
}","/** 
 * Select attributes using BestFirst search to reduce  the number of parameters per instance of a dataset
 * @param data input set of instances
 * @return resampled set of instances
 */
public static Instances selectAttributes(Instances data){
  final AttributeSelection filter=new AttributeSelection();
  Instances filteredIns=null;
  final CfsSubsetEval evaluator=new CfsSubsetEval();
  evaluator.setMissingSeparate(true);
  filter.setEvaluator(evaluator);
  final BestFirst search=new BestFirst();
  filter.setSearch(search);
  try {
    filter.setInputFormat(data);
    filteredIns=Filter.useFilter(data,filter);
  }
 catch (  Exception e) {
    IJ.log(""String_Node_Str"");
    e.printStackTrace();
  }
  return filteredIns;
}",0.9615653389238294
22781,"/** 
 * Create multi-channel probability distribution image from image
 * @param testImage test image (2D single image or stack)
 * @param numThreads number of threads to be used
 * @return result image (probability distribution)
 */
public ImagePlus createProbImgFromTestData(final ImagePlus testImage,final int numThreads){
  IJ.log(""String_Node_Str"" + testImage.getTitle() + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  ArrayList<String> classNames=new ArrayList<String>();
  if (null == loadedClassNames) {
    for (int i=0; i < numOfClasses; i++)     if (examples[i].size() > 0)     classNames.add(classLabels[i]);
  }
 else   classNames=loadedClassNames;
  final int numFurtherThreads=Math.max(1,(numThreads - testImage.getStackSize()) / testImage.getStackSize() + 1);
  final ImagePlus[] probSlices=new ImagePlus[testImage.getStackSize() * numOfClasses];
class ProbImageThread extends Thread {
    final int startSlice;
    final int numSlices;
    final int numFurtherThreads;
    final ArrayList<String> classNames;
    public ProbImageThread(    int startSlice,    int numSlices,    int numFurtherThreads,    ArrayList<String> classNames){
      this.startSlice=startSlice;
      this.numSlices=numSlices;
      this.numFurtherThreads=numFurtherThreads;
      this.classNames=classNames;
    }
    public void run(){
      for (int i=startSlice; i < startSlice + numSlices; i++) {
        final ImagePlus testSlice=new ImagePlus(testImage.getImageStack().getSliceLabel(i),testImage.getImageStack().getProcessor(i).convertToByte(true));
        IJ.showStatus(""String_Node_Str"");
        IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
        final FeatureStack testImageFeatures=new FeatureStack(testSlice);
        testImageFeatures.setEnableFeatures(featureStack.getEnableFeatures());
        testImageFeatures.updateFeatures();
        final Instances testData=testImageFeatures.createInstances(classNames);
        testData.setClassIndex(testData.numAttributes() - 1);
        final ImagePlus[] testClassImages=getClassifierDistribution(testData,testSlice.getWidth(),testSlice.getHeight(),numFurtherThreads);
        for (int c=0; c < numOfClasses; c++)         probSlices[(i - 1) * numOfClasses + c]=testClassImages[c];
      }
    }
  }
  final ProbImageThread[] threads=new ProbImageThread[numThreads];
  for (int i=0; i < numThreads; i++) {
    int startSlice=i * testImage.getStackSize() / numThreads + 1;
    int numSlices;
    if (i < numThreads - 1)     numSlices=testImage.getStackSize() / numThreads;
 else     numSlices=testImage.getStackSize() - (numThreads - 1) * (testImage.getStackSize() / numThreads);
    threads[i]=new ProbImageThread(startSlice,numSlices,numFurtherThreads,classNames);
    threads[i].start();
  }
  final ImageStack probStack=new ImageStack(testImage.getWidth(),testImage.getHeight());
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  for (int i=0; i < testImage.getStackSize() * numOfClasses; i++)   probStack.addSlice(probSlices[i].getTitle(),probSlices[i].getProcessor().convertToByte(true).duplicate());
  ImagePlus probImage=new ImagePlus(""String_Node_Str"",probStack);
  probImage.setDimensions(numOfClasses,testImage.getNSlices(),testImage.getNFrames());
  probImage.setOpenAsHyperStack(true);
  return probImage;
}","/** 
 * Create multi-channel probability distribution image from image
 * @param testImage test image (2D single image or stack)
 * @param numThreads number of threads to be used
 * @return result image (probability distribution)
 */
public ImagePlus createProbImgFromTestData(final ImagePlus testImage,final int numThreads){
  IJ.log(""String_Node_Str"" + testImage.getTitle() + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  ArrayList<String> classNames=new ArrayList<String>();
  if (null == loadedClassNames) {
    for (int i=0; i < numOfClasses; i++)     if (examples[i].size() > 0)     classNames.add(classLabels[i]);
  }
 else   classNames=loadedClassNames;
  final int numFurtherThreads=Math.max(1,(numThreads - testImage.getStackSize()) / testImage.getStackSize() + 1);
  final ImagePlus[] probSlices=new ImagePlus[testImage.getStackSize() * numOfClasses];
class ProbImageThread extends Thread {
    final int startSlice;
    final int numSlices;
    final int numFurtherThreads;
    final ArrayList<String> classNames;
    public ProbImageThread(    int startSlice,    int numSlices,    int numFurtherThreads,    ArrayList<String> classNames){
      this.startSlice=startSlice;
      this.numSlices=numSlices;
      this.numFurtherThreads=numFurtherThreads;
      this.classNames=classNames;
    }
    public void run(){
      for (int i=startSlice; i < startSlice + numSlices; i++) {
        final ImagePlus testSlice=new ImagePlus(testImage.getImageStack().getSliceLabel(i),testImage.getImageStack().getProcessor(i).convertToByte(true));
        IJ.showStatus(""String_Node_Str"");
        IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
        final FeatureStack testImageFeatures=new FeatureStack(testSlice);
        testImageFeatures.setEnableFeatures(featureStack.getEnableFeatures());
        testImageFeatures.updateFeatures();
        final Instances testData=testImageFeatures.createInstances(classNames);
        testData.setClassIndex(testData.numAttributes() - 1);
        final ImagePlus[] testClassImages=getClassifierDistribution(testData,testSlice.getWidth(),testSlice.getHeight(),numFurtherThreads);
        for (int c=0; c < numOfClasses; c++)         probSlices[(i - 1) * numOfClasses + c]=testClassImages[c];
      }
    }
  }
  final ProbImageThread[] threads=new ProbImageThread[numThreads];
  int numSlices=testImage.getStackSize() / numThreads;
  for (int i=0; i < numThreads; i++) {
    int startSlice=i * numSlices + 1;
    if (i == numThreads - 1)     numSlices=testImage.getStackSize() - (numThreads - 1) * (testImage.getStackSize() / numThreads);
    IJ.log(""String_Node_Str"" + i + ""String_Node_Str""+ numSlices+ ""String_Node_Str""+ startSlice);
    threads[i]=new ProbImageThread(startSlice,numSlices,numFurtherThreads,classNames);
    threads[i].start();
  }
  final ImageStack probStack=new ImageStack(testImage.getWidth(),testImage.getHeight());
  for (  Thread thread : threads) {
    try {
      thread.join();
    }
 catch (    InterruptedException e) {
    }
  }
  for (int i=0; i < testImage.getStackSize() * numOfClasses; i++)   probStack.addSlice(probSlices[i].getTitle(),probSlices[i].getProcessor().convertToByte(true).duplicate());
  ImagePlus probImage=new ImagePlus(""String_Node_Str"",probStack);
  probImage.setDimensions(numOfClasses,testImage.getNSlices(),testImage.getNFrames());
  probImage.setOpenAsHyperStack(true);
  return probImage;
}",0.9317946441781328
22782,"/** 
 * Apply current classifier to image
 * @param testImage test image (2D single image or stack)
 * @return result image (classification)
 */
public ImagePlus applyClassifierToTestImage(final ImagePlus testImage,final int numThreads){
  IJ.log(""String_Node_Str"" + testImage.getTitle() + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  ArrayList<String> classNames=new ArrayList<String>();
  if (null == loadedClassNames) {
    for (int i=0; i < numOfClasses; i++)     if (examples[i].size() > 0)     classNames.add(classLabels[i]);
  }
 else   classNames=loadedClassNames;
  final ImagePlus[] classifiedSlices=new ImagePlus[testImage.getStackSize()];
class ApplyClassifierThread extends Thread {
    final int startSlice;
    final int numSlices;
    final int numFurtherThreads;
    final ArrayList<String> classNames;
    public ApplyClassifierThread(    int startSlice,    int numSlices,    int numFurtherThreads,    ArrayList<String> classNames){
      this.startSlice=startSlice;
      this.numSlices=numSlices;
      this.numFurtherThreads=numFurtherThreads;
      this.classNames=classNames;
    }
    public void run(){
      for (int i=startSlice; i < startSlice + numSlices; i++) {
        final ImagePlus testSlice=new ImagePlus(testImage.getImageStack().getSliceLabel(i),testImage.getImageStack().getProcessor(i).convertToByte(true));
        IJ.showStatus(""String_Node_Str"");
        IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
        final FeatureStack testImageFeatures=new FeatureStack(testSlice);
        testImageFeatures.setEnableFeatures(featureStack.getEnableFeatures());
        testImageFeatures.updateFeatures();
        final Instances testData=testImageFeatures.createInstances(classNames);
        testData.setClassIndex(testData.numAttributes() - 1);
        final ImagePlus testClassImage=applyClassifier(testData,testSlice.getWidth(),testSlice.getHeight(),numFurtherThreads);
        testClassImage.setTitle(""String_Node_Str"" + testSlice.getTitle());
        testClassImage.setProcessor(testClassImage.getProcessor().convertToByte(true).duplicate());
        classifiedSlices[i - 1]=testClassImage;
      }
    }
  }
  final int numFurtherThreads=Math.max(1,(numThreads - testImage.getStackSize()) / testImage.getStackSize() + 1);
  final ApplyClassifierThread[] threads=new ApplyClassifierThread[numThreads];
  for (int i=0; i < numThreads; i++) {
    int startSlice=i * testImage.getStackSize() / numThreads + 1;
    int numSlices;
    if (i < numThreads - 1)     numSlices=testImage.getStackSize() / numThreads;
 else     numSlices=testImage.getStackSize() - (numThreads - 1) * (testImage.getStackSize() / numThreads);
    threads[i]=new ApplyClassifierThread(startSlice,numSlices,numFurtherThreads,classNames);
    threads[i].start();
  }
  final ImageStack classified=new ImageStack(testImage.getWidth(),testImage.getHeight());
  for (  Thread thread : threads)   try {
    thread.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  for (int i=0; i < testImage.getStackSize(); i++)   classified.addSlice(classifiedSlices[i].getTitle(),classifiedSlices[i].getProcessor());
  return new ImagePlus(""String_Node_Str"",classified);
}","/** 
 * Apply current classifier to image
 * @param testImage test image (2D single image or stack)
 * @return result image (classification)
 */
public ImagePlus applyClassifierToTestImage(final ImagePlus testImage,final int numThreads){
  IJ.log(""String_Node_Str"" + testImage.getTitle() + ""String_Node_Str""+ numThreads+ ""String_Node_Str"");
  ArrayList<String> classNames=new ArrayList<String>();
  if (null == loadedClassNames) {
    for (int i=0; i < numOfClasses; i++)     if (examples[i].size() > 0)     classNames.add(classLabels[i]);
  }
 else   classNames=loadedClassNames;
  final ImagePlus[] classifiedSlices=new ImagePlus[testImage.getStackSize()];
class ApplyClassifierThread extends Thread {
    final int startSlice;
    final int numSlices;
    final int numFurtherThreads;
    final ArrayList<String> classNames;
    public ApplyClassifierThread(    int startSlice,    int numSlices,    int numFurtherThreads,    ArrayList<String> classNames){
      this.startSlice=startSlice;
      this.numSlices=numSlices;
      this.numFurtherThreads=numFurtherThreads;
      this.classNames=classNames;
    }
    public void run(){
      for (int i=startSlice; i < startSlice + numSlices; i++) {
        final ImagePlus testSlice=new ImagePlus(testImage.getImageStack().getSliceLabel(i),testImage.getImageStack().getProcessor(i).convertToByte(true));
        IJ.showStatus(""String_Node_Str"");
        IJ.log(""String_Node_Str"" + i + ""String_Node_Str"");
        final FeatureStack testImageFeatures=new FeatureStack(testSlice);
        testImageFeatures.setEnableFeatures(featureStack.getEnableFeatures());
        testImageFeatures.updateFeatures();
        final Instances testData=testImageFeatures.createInstances(classNames);
        testData.setClassIndex(testData.numAttributes() - 1);
        final ImagePlus testClassImage=applyClassifier(testData,testSlice.getWidth(),testSlice.getHeight(),numFurtherThreads);
        testClassImage.setTitle(""String_Node_Str"" + testSlice.getTitle());
        testClassImage.setProcessor(testClassImage.getProcessor().convertToByte(true).duplicate());
        classifiedSlices[i - 1]=testClassImage;
      }
    }
  }
  final int numFurtherThreads=Math.max(1,(numThreads - testImage.getStackSize()) / testImage.getStackSize() + 1);
  final ApplyClassifierThread[] threads=new ApplyClassifierThread[numThreads];
  int numSlices=testImage.getStackSize() / numThreads;
  for (int i=0; i < numThreads; i++) {
    int startSlice=i * numSlices + 1;
    if (i == numThreads - 1)     numSlices=testImage.getStackSize() - (numThreads - 1) * (testImage.getStackSize() / numThreads);
    IJ.log(""String_Node_Str"" + i + ""String_Node_Str""+ numSlices+ ""String_Node_Str""+ startSlice);
    threads[i]=new ApplyClassifierThread(startSlice,numSlices,numFurtherThreads,classNames);
    threads[i].start();
  }
  final ImageStack classified=new ImageStack(testImage.getWidth(),testImage.getHeight());
  for (  Thread thread : threads)   try {
    thread.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  for (int i=0; i < testImage.getStackSize(); i++)   classified.addSlice(classifiedSlices[i].getTitle(),classifiedSlices[i].getProcessor());
  return new ImagePlus(""String_Node_Str"",classified);
}",0.9286046151463528
22783,"/** 
 * Update buttons enabling depending on the current status of the plugin
 */
private void updateButtonsEnabling(){
  if (useGUI) {
    final boolean classifierExists=null != this.classifier;
    trainButton.setEnabled(classifierExists);
    applyButton.setEnabled(classifierExists);
    final boolean resultExists=null != this.classifiedImage && null != this.classifiedImage.getProcessor();
    saveClassifierButton.setEnabled(resultExists);
    overlayButton.setEnabled(resultExists);
    resultButton.setEnabled(resultExists);
    probabilityButton.setEnabled(resultExists);
    newImageButton.setEnabled(true);
    loadClassifierButton.setEnabled(true);
    loadDataButton.setEnabled(true);
    addClassButton.setEnabled(this.numOfClasses < MAX_NUM_CLASSES);
    settingsButton.setEnabled(true);
    wekaButton.setEnabled(true);
    boolean examplesEmpty=true;
    for (int i=0; i < numOfClasses; i++)     if (examples[i].size() > 0) {
      examplesEmpty=false;
      break;
    }
    saveDataButton.setEnabled(!examplesEmpty || null != loadedTrainingData);
    for (int i=0; i < numOfClasses; i++) {
      exampleList[i].setEnabled(true);
      addExampleButton[i].setEnabled(true);
    }
  }
}","/** 
 * Update buttons enabling depending on the current status of the plugin
 */
private void updateButtonsEnabling(){
  if (useGUI) {
    final boolean classifierExists=null != this.classifier;
    trainButton.setEnabled(classifierExists);
    applyButton.setEnabled(classifierExists);
    final boolean resultExists=null != this.classifiedImage && null != this.classifiedImage.getProcessor();
    saveClassifierButton.setEnabled(resultExists);
    overlayButton.setEnabled(resultExists);
    resultButton.setEnabled(resultExists);
    probabilityButton.setEnabled(classifierExists);
    newImageButton.setEnabled(true);
    loadClassifierButton.setEnabled(true);
    loadDataButton.setEnabled(true);
    addClassButton.setEnabled(this.numOfClasses < MAX_NUM_CLASSES);
    settingsButton.setEnabled(true);
    wekaButton.setEnabled(true);
    boolean examplesEmpty=true;
    for (int i=0; i < numOfClasses; i++)     if (examples[i].size() > 0) {
      examplesEmpty=false;
      break;
    }
    saveDataButton.setEnabled(!examplesEmpty || null != loadedTrainingData);
    for (int i=0; i < numOfClasses; i++) {
      exampleList[i].setEnabled(true);
      addExampleButton[i].setEnabled(true);
    }
  }
}",0.9933665008291874
22784,"/** 
 * Display the current probability maps 
 */
void showProbabilityImage(){
  this.setButtonsEnabled(false);
  final ImagePlus probImage=this.getProbabilityMapsMT();
  if (null != probImage)   probImage.show();
  this.updateButtonsEnabling();
}","/** 
 * Display the current probability maps 
 */
void showProbabilityImage(){
  IJ.showStatus(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
  this.setButtonsEnabled(false);
  final ImagePlus probImage=this.getProbabilityMapsMT();
  if (null != probImage)   probImage.show();
  this.updateButtonsEnabling();
  IJ.showStatus(""String_Node_Str"");
  IJ.log(""String_Node_Str"");
}",0.7916666666666666
22785,"/** 
 * Create training instances out of the user markings
 * @return set of instances
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStack.getSize(); i++) {
    String attString=featureStack.getSliceLabel(i) + ""String_Node_Str"";
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes=new ArrayList<String>();
  int numOfInstances=0;
  for (int i=0; i < numOfClasses; i++) {
    if (examples[i].size() > 0)     classes.add(classLabels[i]);
    numOfInstances+=examples[i].size();
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int j=0; j < examples[l].size(); j++) {
      Roi r=examples[l].get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStack.getSize() + 1];
            for (int z=1; z <= featureStack.getSize(); z++)             values[z - 1]=featureStack.getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStack.getSize()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              double[] values=new double[featureStack.getSize() + 1];
              for (int z=1; z <= featureStack.getSize(); z++)               values[z - 1]=featureStack.getProcessor(z).getInterpolatedValue(x,y);
              values[featureStack.getSize()]=(double)l;
              trainingData.add(new DenseInstance(1.0,values));
              nl++;
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStack.getSize() + 1];
          for (int z=1; z <= featureStack.getSize(); z++)           values[z - 1]=featureStack.getProcessor(z).getPixelValue(x,y);
          values[featureStack.getSize()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + classLabels[l] + ""String_Node_Str""+ nl);
  }
  return trainingData;
}","/** 
 * Create training instances out of the user markings
 * @return set of instances
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStack.getSize(); i++) {
    String attString=featureStack.getSliceLabel(i) + ""String_Node_Str"";
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes=new ArrayList<String>();
  int numOfInstances=0;
  for (int i=0; i < numOfClasses; i++) {
    if (examples[i].size() > 0)     classes.add(classLabels[i]);
    numOfInstances+=examples[i].size();
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int j=0; j < examples[l].size(); j++) {
      Roi r=examples[l].get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStack.getSize() + 1];
            for (int z=1; z <= featureStack.getSize(); z++)             values[z - 1]=featureStack.getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStack.getSize()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStack.getWidth() && y >= 0 && y < featureStack.getHeight()) {
                double[] values=new double[featureStack.getSize() + 1];
                for (int z=1; z <= featureStack.getSize(); z++)                 values[z - 1]=featureStack.getProcessor(z).getInterpolatedValue(x,y);
                values[featureStack.getSize()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStack.getSize() + 1];
          for (int z=1; z <= featureStack.getSize(); z++)           values[z - 1]=featureStack.getProcessor(z).getPixelValue(x,y);
          values[featureStack.getSize()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + classLabels[l] + ""String_Node_Str""+ nl);
  }
  return trainingData;
}",0.9806541405706332
22786,"/** 
 * Load training data (no GUI)
 * @param pathname complete path name of the training data file (.arff)
 * @return false if error
 */
public boolean loadTrainingData(String pathname){
  IJ.log(""String_Node_Str"" + pathname + ""String_Node_Str"");
  loadedTrainingData=readDataFromARFF(pathname);
  Enumeration<Attribute> attributes=loadedTrainingData.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    for (int i=0; i < numFeatures; i++)     if (a.name().startsWith(FeatureStack.availableFeatures[i]))     usedFeatures[i]=true;
  }
  Attribute classAttribute=loadedTrainingData.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
    IJ.log(""String_Node_Str"" + className);
    if (!className.equals(this.classLabels[j])) {
      String s=classLabels[0];
      for (int i=1; i < numOfClasses; i++)       s=s.concat(""String_Node_Str"" + classLabels[i]);
      IJ.error(""String_Node_Str"" + s);
      loadedTrainingData=null;
      return false;
    }
    j++;
  }
  if (j != numOfClasses) {
    IJ.error(""String_Node_Str"");
    loadedTrainingData=null;
    return false;
  }
  IJ.log(""String_Node_Str"" + loadedTrainingData.numInstances() + ""String_Node_Str""+ wholeImageData.numAttributes()+ ""String_Node_Str"");
  boolean featuresChanged=false;
  final boolean[] oldEnableFeatures=this.featureStack.getEnableFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.setButtonsEnabled(false);
    this.featureStack.setEnableFeatures(usedFeatures);
    this.featureStack.updateFeatures();
    this.setButtonsEnabled(true);
    updateWholeData=true;
  }
  return true;
}","/** 
 * Load training data (no GUI)
 * @param pathname complete path name of the training data file (.arff)
 * @return false if error
 */
public boolean loadTrainingData(String pathname){
  IJ.log(""String_Node_Str"" + pathname + ""String_Node_Str"");
  loadedTrainingData=readDataFromARFF(pathname);
  Enumeration<Attribute> attributes=loadedTrainingData.enumerateAttributes();
  final int numFeatures=FeatureStack.availableFeatures.length;
  boolean[] usedFeatures=new boolean[numFeatures];
  while (attributes.hasMoreElements()) {
    final Attribute a=attributes.nextElement();
    for (int i=0; i < numFeatures; i++)     if (a.name().startsWith(FeatureStack.availableFeatures[i]))     usedFeatures[i]=true;
  }
  Attribute classAttribute=loadedTrainingData.classAttribute();
  Enumeration<String> classValues=classAttribute.enumerateValues();
  loadedClassNames=new ArrayList<String>();
  int j=0;
  while (classValues.hasMoreElements()) {
    final String className=classValues.nextElement().trim();
    loadedClassNames.add(className);
    IJ.log(""String_Node_Str"" + className);
    if (!className.equals(this.classLabels[j])) {
      String s=classLabels[0];
      for (int i=1; i < numOfClasses; i++)       s=s.concat(""String_Node_Str"" + classLabels[i]);
      IJ.error(""String_Node_Str"" + s);
      loadedTrainingData=null;
      return false;
    }
    j++;
  }
  if (j != numOfClasses) {
    IJ.error(""String_Node_Str"");
    loadedTrainingData=null;
    return false;
  }
  IJ.log(""String_Node_Str"" + loadedTrainingData.numInstances() + ""String_Node_Str""+ loadedTrainingData.numAttributes()+ ""String_Node_Str"");
  boolean featuresChanged=false;
  final boolean[] oldEnableFeatures=this.featureStack.getEnableFeatures();
  for (int i=0; i < numFeatures; i++) {
    if (usedFeatures[i] != oldEnableFeatures[i])     featuresChanged=true;
  }
  if (featuresChanged) {
    this.setButtonsEnabled(false);
    this.featureStack.setEnableFeatures(usedFeatures);
    this.featureStack.updateFeatures();
    this.setButtonsEnabled(true);
    updateWholeData=true;
  }
  return true;
}",0.9942307692307693
22787,"/** 
 * Create training instances out of the user markings
 * @return set of instances
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStack.getSize(); i++) {
    String attString=featureStack.getSliceLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes=new ArrayList<String>();
  int numOfInstances=0;
  for (int i=0; i < numOfClasses; i++) {
    if (examples[i].size() > 0)     classes.add(classLabels[i]);
    numOfInstances+=examples[i].size();
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int j=0; j < examples[l].size(); j++) {
      Roi r=examples[l].get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStack.getSize() + 1];
            for (int z=1; z <= featureStack.getSize(); z++)             values[z - 1]=featureStack.getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStack.getSize()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              double[] values=new double[featureStack.getSize() + 1];
              for (int z=1; z <= featureStack.getSize(); z++)               values[z - 1]=featureStack.getProcessor(z).getInterpolatedValue(x,y);
              values[featureStack.getSize()]=(double)l;
              trainingData.add(new DenseInstance(1.0,values));
              nl++;
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStack.getSize() + 1];
          for (int z=1; z <= featureStack.getSize(); z++)           values[z - 1]=featureStack.getProcessor(z).getPixelValue(x,y);
          values[featureStack.getSize()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + classLabels[l] + ""String_Node_Str""+ nl);
  }
  return trainingData;
}","/** 
 * Create training instances out of the user markings
 * @return set of instances
 */
public Instances createTrainingInstances(){
  ArrayList<Attribute> attributes=new ArrayList<Attribute>();
  for (int i=1; i <= featureStack.getSize(); i++) {
    String attString=featureStack.getSliceLabel(i);
    attributes.add(new Attribute(attString));
  }
  final ArrayList<String> classes=new ArrayList<String>();
  int numOfInstances=0;
  for (int i=0; i < numOfClasses; i++) {
    if (examples[i].size() > 0)     classes.add(classLabels[i]);
    numOfInstances+=examples[i].size();
  }
  attributes.add(new Attribute(""String_Node_Str"",classes));
  final Instances trainingData=new Instances(""String_Node_Str"",attributes,numOfInstances);
  IJ.log(""String_Node_Str"");
  for (int l=0; l < numOfClasses; l++) {
    int nl=0;
    for (int j=0; j < examples[l].size(); j++) {
      Roi r=examples[l].get(j);
      if (r instanceof PolygonRoi && r.getType() != Roi.FREEROI) {
        if (r.getStrokeWidth() == 1) {
          int[] x=r.getPolygon().xpoints;
          int[] y=r.getPolygon().ypoints;
          final int n=r.getPolygon().npoints;
          for (int i=0; i < n; i++) {
            double[] values=new double[featureStack.getSize() + 1];
            for (int z=1; z <= featureStack.getSize(); z++)             values[z - 1]=featureStack.getProcessor(z).getPixelValue(x[i],y[i]);
            values[featureStack.getSize()]=(double)l;
            trainingData.add(new DenseInstance(1.0,values));
            nl++;
          }
        }
 else {
          final int width=(int)Math.round(r.getStrokeWidth());
          FloatPolygon p=r.getFloatPolygon();
          int n=p.npoints;
          double x1, y1;
          double x2=p.xpoints[0] - (p.xpoints[1] - p.xpoints[0]);
          double y2=p.ypoints[0] - (p.ypoints[1] - p.ypoints[0]);
          for (int i=0; i < n; i++) {
            x1=x2;
            y1=y2;
            x2=p.xpoints[i];
            y2=p.ypoints[i];
            double dx=x2 - x1;
            double dy=y1 - y2;
            double length=(float)Math.sqrt(dx * dx + dy * dy);
            dx/=length;
            dy/=length;
            double x=x2 - dy * width / 2.0;
            double y=y2 - dx * width / 2.0;
            int n2=width;
            do {
              if (x >= 0 && x < featureStack.getWidth() && y >= 0 && y < featureStack.getHeight()) {
                double[] values=new double[featureStack.getSize() + 1];
                for (int z=1; z <= featureStack.getSize(); z++)                 values[z - 1]=featureStack.getProcessor(z).getInterpolatedValue(x,y);
                values[featureStack.getSize()]=(double)l;
                trainingData.add(new DenseInstance(1.0,values));
                nl++;
              }
              x+=dy;
              y+=dx;
            }
 while (--n2 > 0);
          }
        }
      }
 else {
        final ShapeRoi shapeRoi=new ShapeRoi(r);
        final Rectangle rect=shapeRoi.getBounds();
        final int lastX=rect.x + rect.width;
        final int lastY=rect.y + rect.height;
        for (int x=rect.x; x < lastX; x++)         for (int y=rect.y; y < lastY; y++)         if (shapeRoi.contains(x,y)) {
          double[] values=new double[featureStack.getSize() + 1];
          for (int z=1; z <= featureStack.getSize(); z++)           values[z - 1]=featureStack.getProcessor(z).getPixelValue(x,y);
          values[featureStack.getSize()]=(double)l;
          trainingData.add(new DenseInstance(1.0,values));
          nl++;
        }
      }
    }
    IJ.log(""String_Node_Str"" + classLabels[l] + ""String_Node_Str""+ nl);
  }
  return trainingData;
}",0.9805458362491252
22788,"/** 
 * Update features with current list
 */
public void updateFeatures(){
  wholeStack=new ImageStack(width,height);
  wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate());
  int counter=1;
  for (float i=1.0f; i <= FeatureStack.MAX_SIGMA; i*=2) {
    if (enableFeatures[GAUSSIAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addGaussianBlur(i);
      counter++;
    }
    if (enableFeatures[SOBEL]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addGradient(i);
      counter++;
    }
    if (enableFeatures[HESSIAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addHessian(i);
      counter++;
    }
    if (enableFeatures[DOG]) {
      for (float j=1.0f; j < i; j*=2) {
        IJ.showStatus(""String_Node_Str"" + counter);
        this.addDoG(i,j);
        counter++;
      }
    }
    if (enableFeatures[VARIANCE]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addVariance(i);
      counter++;
    }
    if (enableFeatures[MEAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMean(i);
      counter++;
    }
    if (enableFeatures[MINIMUM]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMin(i);
      counter++;
    }
    if (enableFeatures[MAXIMUM]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMax(i);
      counter++;
    }
    if (enableFeatures[MEDIAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMedian(i);
      counter++;
    }
  }
  if (enableFeatures[MEMBRANE])   this.addMembraneFeatures(19,1);
  if (normalize) {
    IJ.showStatus(""String_Node_Str"");
    final ImagePlus imp=new ImagePlus(""String_Node_Str"",this.wholeStack);
    IJ.run(imp,""String_Node_Str"",""String_Node_Str"");
  }
  IJ.showProgress(1.0);
  IJ.showStatus(""String_Node_Str"");
}","/** 
 * Update features with current list
 */
public void updateFeatures(){
  wholeStack=new ImageStack(width,height);
  wholeStack.addSlice(""String_Node_Str"",originalImage.getProcessor().duplicate());
  int counter=1;
  for (float i=1.0f; i < FeatureStack.MAX_SIGMA; i*=2) {
    if (enableFeatures[GAUSSIAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addGaussianBlur(i);
      counter++;
    }
    if (enableFeatures[SOBEL]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addGradient(i);
      counter++;
    }
    if (enableFeatures[HESSIAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addHessian(i);
      counter++;
    }
    if (enableFeatures[DOG]) {
      for (float j=1.0f; j < i; j*=2) {
        IJ.showStatus(""String_Node_Str"" + counter);
        this.addDoG(i,j);
        counter++;
      }
    }
    if (enableFeatures[VARIANCE]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addVariance(i);
      counter++;
    }
    if (enableFeatures[MEAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMean(i);
      counter++;
    }
    if (enableFeatures[MINIMUM]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMin(i);
      counter++;
    }
    if (enableFeatures[MAXIMUM]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMax(i);
      counter++;
    }
    if (enableFeatures[MEDIAN]) {
      IJ.showStatus(""String_Node_Str"" + counter);
      this.addMedian(i);
      counter++;
    }
  }
  if (enableFeatures[MEMBRANE])   this.addMembraneFeatures(19,1);
  if (normalize) {
    IJ.showStatus(""String_Node_Str"");
    final ImagePlus imp=new ImagePlus(""String_Node_Str"",this.wholeStack);
    IJ.run(imp,""String_Node_Str"",""String_Node_Str"");
  }
  IJ.showProgress(1.0);
  IJ.showStatus(""String_Node_Str"");
}",0.99972833469166
22789,"/** 
 * Save training model into a file
 */
public void saveTrainingData(){
  boolean examplesEmpty=true;
  for (int i=0; i < numOfClasses; i++)   if (examples[i].size() > 0) {
    examplesEmpty=false;
    break;
  }
  if (examplesEmpty && loadedTrainingData == null) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  Instances data=createTrainingInstances();
  data.setClassIndex(data.numAttributes() - 1);
  if (null != loadedTrainingData && null != data) {
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++) {
      data.add(loadedTrainingData.instance(i));
    }
    IJ.log(""String_Node_Str"");
  }
 else   if (null == data)   data=loadedTrainingData;
  SaveDialog sd=new SaveDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (sd.getFileName() == null)   return;
  IJ.log(""String_Node_Str"" + data.numInstances() + ""String_Node_Str"");
  writeDataToARFF(data,sd.getDirectory() + sd.getFileName());
  IJ.log(""String_Node_Str"" + sd.getDirectory() + ""String_Node_Str""+ sd.getFileName());
}","/** 
 * Save training model into a file
 */
public void saveTrainingData(){
  boolean examplesEmpty=true;
  for (int i=0; i < numOfClasses; i++)   if (examples[i].size() > 0) {
    examplesEmpty=false;
    break;
  }
  if (examplesEmpty && loadedTrainingData == null) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  if (featureStack.getSize() < 2) {
    setButtonsEnabled(false);
    featureStack.updateFeatures();
    setButtonsEnabled(true);
  }
  Instances data=createTrainingInstances();
  data.setClassIndex(data.numAttributes() - 1);
  if (null != loadedTrainingData && null != data) {
    IJ.log(""String_Node_Str"");
    for (int i=0; i < loadedTrainingData.numInstances(); i++) {
      data.add(loadedTrainingData.instance(i));
    }
    IJ.log(""String_Node_Str"");
  }
 else   if (null == data)   data=loadedTrainingData;
  SaveDialog sd=new SaveDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (sd.getFileName() == null)   return;
  IJ.log(""String_Node_Str"" + data.numInstances() + ""String_Node_Str"");
  writeDataToARFF(data,sd.getDirectory() + sd.getFileName());
  IJ.log(""String_Node_Str"" + sd.getDirectory() + ""String_Node_Str""+ sd.getFileName());
}",0.9403383793410508
22790,"/** 
 * Call the Weka chooser
 */
public static void launchWeka(){
  IJ.log(""String_Node_Str"" + ClassLoader.getSystemClassLoader());
  GUIChooser chooser=new GUIChooser();
  for (  WindowListener wl : chooser.getWindowListeners()) {
    chooser.removeWindowListener(wl);
  }
  chooser.setVisible(true);
}","/** 
 * Call the Weka chooser
 */
public static void launchWeka(){
  IJ.log(""String_Node_Str"" + ClassLoader.getSystemClassLoader());
  weka.gui.GUIChooser chooser=new weka.gui.GUIChooser();
  for (  WindowListener wl : chooser.getWindowListeners()) {
    chooser.removeWindowListener(wl);
  }
  chooser.setVisible(true);
}",0.9712460063897764
22791,"/** 
 * Read header classifier from a .model file
 * @param filename complete path and file name
 * @return false if error
 */
public boolean loadClassifier(String filename){
  File selected=new File(filename);
  try {
    InputStream is=new FileInputStream(selected);
    if (selected.getName().endsWith(ClassifierPanel.PMML_FILE_EXTENSION)) {
      PMMLModel model=PMMLFactory.getPMMLModel(is,null);
      if (model instanceof PMMLClassifier)       classifier=(PMMLClassifier)model;
 else       throw new Exception(""String_Node_Str"");
    }
 else {
      if (selected.getName().endsWith(""String_Node_Str""))       is=new GZIPInputStream(is);
      ObjectInputStream objectInputStream=new ObjectInputStream(is);
      classifier=(AbstractClassifier)objectInputStream.readObject();
      try {
        trainHeader=(Instances)objectInputStream.readObject();
      }
 catch (      Exception e) {
        IJ.error(""String_Node_Str"",""String_Node_Str"");
        return false;
      }
 finally {
        objectInputStream.close();
      }
    }
  }
 catch (  Exception e) {
    IJ.error(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
    return false;
  }
  return true;
}","/** 
 * Read header classifier from a .model file
 * @param filename complete path and file name
 * @return false if error
 */
public boolean loadClassifier(String filename){
  Thread t=Thread.currentThread();
  t.setContextClassLoader(ClassLoader.getSystemClassLoader());
  IJ.log(""String_Node_Str"" + t.getContextClassLoader().getClass());
  File selected=new File(filename);
  try {
    InputStream is=new FileInputStream(selected);
    if (selected.getName().endsWith(weka.gui.explorer.ClassifierPanel.PMML_FILE_EXTENSION)) {
      weka.core.pmml.PMMLModel model=weka.core.pmml.PMMLFactory.getPMMLModel(is,null);
      if (model instanceof weka.classifiers.pmml.consumer.PMMLClassifier)       classifier=(weka.classifiers.pmml.consumer.PMMLClassifier)model;
 else       throw new Exception(""String_Node_Str"");
    }
 else {
      if (selected.getName().endsWith(""String_Node_Str""))       is=new GZIPInputStream(is);
      ObjectInputStream objectInputStream=new ObjectInputStream(is);
      classifier=(AbstractClassifier)objectInputStream.readObject();
      try {
        trainHeader=(Instances)objectInputStream.readObject();
      }
 catch (      Exception e) {
        IJ.error(""String_Node_Str"",""String_Node_Str"");
        return false;
      }
 finally {
        objectInputStream.close();
      }
    }
  }
 catch (  Exception e) {
    IJ.error(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
    return false;
  }
  return true;
}",0.8953752843062927
22792,"public void trainClassifier(){
  if (positiveExamples.size() == 0) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  if (negativeExamples.size() == 0) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  IJ.showStatus(""String_Node_Str"");
  long start=System.currentTimeMillis();
  Instances data=createTrainingInstances();
  long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start));
  data.setClassIndex(data.numAttributes() - 1);
  FastRandomForest rf=new FastRandomForest();
  rf.setNumTrees(200);
  rf.setNumFeatures((int)Math.round(Math.sqrt(featureStack.getSize())));
  writeDataToARFF(data,""String_Node_Str"");
  rf.setSeed(123);
  IJ.log(""String_Node_Str"");
  try {
    rf.buildClassifier(data);
  }
 catch (  Exception e) {
    IJ.showMessage(""String_Node_Str"");
  }
  IJ.log(""String_Node_Str"");
  start=System.currentTimeMillis();
  data=featureStack.createInstances();
  end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start));
  data.setClassIndex(data.numAttributes() - 1);
  IJ.log(""String_Node_Str"");
  double[] classificationResult=new double[data.numInstances()];
  for (int i=0; i < data.numInstances(); i++) {
    try {
      classificationResult[i]=rf.classifyInstance(data.instance(i));
    }
 catch (    Exception e) {
      IJ.showMessage(""String_Node_Str"");
    }
  }
  IJ.log(""String_Node_Str"");
  ImageProcessor classifiedImageProcessor=new FloatProcessor(trainingImage.getWidth(),trainingImage.getHeight(),classificationResult);
  classifiedImageProcessor.convertToByte(true);
  classifiedImage=new ImagePlus(""String_Node_Str"",classifiedImageProcessor);
  overlayButton.setEnabled(true);
  resultButton.setEnabled(true);
  showColorOverlay=false;
  toggleOverlay();
}","public void trainClassifier(){
  if (positiveExamples.size() == 0) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  if (negativeExamples.size() == 0) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  IJ.showStatus(""String_Node_Str"");
  long start=System.currentTimeMillis();
  Instances data=createTrainingInstances();
  long end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start));
  data.setClassIndex(data.numAttributes() - 1);
  FastRandomForest rf=new FastRandomForest();
  rf.setNumTrees(200);
  rf.setNumFeatures((int)Math.round(Math.sqrt(featureStack.getSize())));
  rf.setSeed(123);
  IJ.log(""String_Node_Str"");
  try {
    rf.buildClassifier(data);
  }
 catch (  Exception e) {
    IJ.showMessage(""String_Node_Str"");
  }
  IJ.log(""String_Node_Str"");
  start=System.currentTimeMillis();
  data=featureStack.createInstances();
  end=System.currentTimeMillis();
  IJ.log(""String_Node_Str"" + (end - start));
  data.setClassIndex(data.numAttributes() - 1);
  IJ.log(""String_Node_Str"");
  double[] classificationResult=new double[data.numInstances()];
  for (int i=0; i < data.numInstances(); i++) {
    try {
      classificationResult[i]=rf.classifyInstance(data.instance(i));
    }
 catch (    Exception e) {
      IJ.showMessage(""String_Node_Str"");
    }
  }
  IJ.log(""String_Node_Str"");
  ImageProcessor classifiedImageProcessor=new FloatProcessor(trainingImage.getWidth(),trainingImage.getHeight(),classificationResult);
  classifiedImageProcessor.convertToByte(true);
  classifiedImage=new ImagePlus(""String_Node_Str"",classifiedImageProcessor);
  overlayButton.setEnabled(true);
  resultButton.setEnabled(true);
  showColorOverlay=false;
  toggleOverlay();
}",0.9875686614628504
22793,"private void addPositiveExamples(){
  Roi r=displayImage.getRoi();
  displayImage.killRoi();
  positiveExamples.add(r);
  posExampleList.add(""String_Node_Str"" + posTraceCounter);
  posTraceCounter++;
  drawExamples();
}","private void addPositiveExamples(){
  Roi r=displayImage.getRoi();
  if (null == r) {
    return;
  }
  displayImage.killRoi();
  positiveExamples.add(r);
  posExampleList.add(""String_Node_Str"" + posTraceCounter);
  posTraceCounter++;
  drawExamples();
}",0.9260042283298098
22794,"private void addNegativeExamples(){
  Roi r=displayImage.getRoi();
  displayImage.killRoi();
  negativeExamples.add(r);
  negExampleList.add(""String_Node_Str"" + negTraceCounter);
  negTraceCounter++;
  drawExamples();
}","private void addNegativeExamples(){
  Roi r=displayImage.getRoi();
  if (null == r) {
    return;
  }
  displayImage.killRoi();
  negativeExamples.add(r);
  negExampleList.add(""String_Node_Str"" + negTraceCounter);
  negTraceCounter++;
  drawExamples();
}",0.9260042283298098
22795,"@Override public Cursor loadInBackground(){
  Cursor cursor=super.loadInBackground();
  MatrixCursor prepend=new MatrixCursor(cursor.getColumnNames());
  onPrependDummy(prepend);
  MatrixCursor append=new MatrixCursor(cursor.getColumnNames());
  onAppendDummy(append);
  return new MergeCursor(new Cursor[]{prepend,cursor,append});
}","@Override public Cursor loadInBackground(){
  Cursor cursor=super.loadInBackground();
  MatrixCursor prepend=new MatrixCursor(getProjection());
  onPrependDummy(prepend);
  MatrixCursor append=new MatrixCursor(getProjection());
  onAppendDummy(append);
  return new MergeCursor(new Cursor[]{prepend,cursor,append});
}",0.8953846153846153
22796,"@Override public void bindView(View view,Context context,Cursor cursor){
  TextView albumName=(TextView)view.findViewById(R.id.label_album_name);
  BucketId bucketId=BucketId.from(cursor);
  if (bucketId.equals(FixedBucketIdFactory.CAMERA.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.CAMERA.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.DOWNLOAD.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.DOWNLOAD.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.EDITED_ONLINE_PHOTO.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.EDITED_ONLINE_PHOTO.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.IMPORTED_PHOTO.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.IMPORTED_PHOTO.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.SNAP_SHOT.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.SNAP_SHOT.getLocalizedDisplayName(context));
  }
 else {
    String name=cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_DISPLAY_NAME));
    albumName.setText(name);
  }
}","@Override public void bindView(View view,Context context,Cursor cursor){
  TextView albumName=(TextView)view.findViewById(R.id.label_album_name);
  BucketId bucketId=BucketId.from(cursor);
  if (bucketId.equals(FixedBucketIdFactory.CAMERA.getBucketId())) {
    albumName.setText(""String_Node_Str"" + FixedBucketIdFactory.CAMERA.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.DOWNLOAD.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.DOWNLOAD.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.EDITED_ONLINE_PHOTO.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.EDITED_ONLINE_PHOTO.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.IMPORTED_PHOTO.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.IMPORTED_PHOTO.getLocalizedDisplayName(context));
  }
 else   if (bucketId.equals(FixedBucketIdFactory.SNAP_SHOT.getBucketId())) {
    albumName.setText(FixedBucketIdFactory.SNAP_SHOT.getLocalizedDisplayName(context));
  }
 else {
    String name=cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_DISPLAY_NAME));
    albumName.setText(name);
  }
}",0.9916943521594684
22797,"private double[] handleEntityCollision(Entity entity,double motionX,double motionZ){
  double X=motionX;
  double Z=motionZ;
  List list=this.worldObj.getCollidingBoundingBoxes(entity,entity.boundingBox.addCoord(X,0,Z));
  int j;
  for (j=0; j < list.size(); ++j) {
    X=((AxisAlignedBB)list.get(j)).calculateXOffset(entity.boundingBox,X);
  }
  entity.boundingBox.offset(X,0.0D,0.0D);
  for (j=0; j < list.size(); ++j) {
    Z=((AxisAlignedBB)list.get(j)).calculateZOffset(entity.boundingBox,motionZ);
  }
  entity.boundingBox.offset(0.0D,0.0D,motionZ);
  entity.posX=(entity.boundingBox.minX + entity.boundingBox.maxX) / 2.0D;
  entity.posZ=(entity.boundingBox.minZ + entity.boundingBox.maxZ) / 2.0D;
  entity.isCollidedHorizontally=motionX != X || motionZ != Z;
  entity.isCollided=entity.isCollidedHorizontally || entity.isCollidedVertically;
  motionX=X;
  motionZ=Z;
  return new double[]{motionX,motionZ};
}","private double[] handleEntityCollision(Entity entity,double motionX,double motionZ){
  double X=motionX;
  double Z=motionZ;
  List list=this.worldObj.getCollidingBoundingBoxes(entity,entity.boundingBox.addCoord(X,0,Z));
  int j;
  for (j=0; j < list.size(); ++j) {
    X=((AxisAlignedBB)list.get(j)).calculateXOffset(entity.boundingBox,X);
  }
  entity.boundingBox.offset(X,0.0D,0.0D);
  for (j=0; j < list.size(); ++j) {
    Z=((AxisAlignedBB)list.get(j)).calculateZOffset(entity.boundingBox,motionZ);
  }
  entity.boundingBox.offset(0.0D,0.0D,Z);
  entity.posX=(entity.boundingBox.minX + entity.boundingBox.maxX) / 2.0D;
  entity.posZ=(entity.boundingBox.minZ + entity.boundingBox.maxZ) / 2.0D;
  entity.isCollidedHorizontally=motionX != X || motionZ != Z;
  entity.isCollided=entity.isCollidedHorizontally || entity.isCollidedVertically;
  motionX=X;
  motionZ=Z;
  return new double[]{motionX,motionZ};
}",0.9967105263157896
22798,"private double[] handleEntityCollision(Entity entity,double motionX,double motionZ){
  double X=motionX;
  double Z=motionZ;
  List list=this.worldObj.getCollidingBoundingBoxes(entity,entity.boundingBox.addCoord(X,0,Z));
  int j;
  for (j=0; j < list.size(); ++j) {
    X=((AxisAlignedBB)list.get(j)).calculateXOffset(entity.boundingBox,X);
  }
  entity.boundingBox.offset(X,0.0D,0.0D);
  for (j=0; j < list.size(); ++j) {
    Z=((AxisAlignedBB)list.get(j)).calculateZOffset(entity.boundingBox,motionZ);
  }
  entity.boundingBox.offset(0.0D,0.0D,Z);
  entity.posX=(entity.boundingBox.minX + entity.boundingBox.maxX) / 2.0D;
  entity.posZ=(entity.boundingBox.minZ + entity.boundingBox.maxZ) / 2.0D;
  entity.isCollidedHorizontally=motionX != X || motionZ != Z;
  entity.isCollided=entity.isCollidedHorizontally || entity.isCollidedVertically;
  motionX=X;
  motionZ=Z;
  return new double[]{motionX,motionZ};
}","private double[] handleEntityCollision(Entity entity,double motionX,double motionZ){
  double X=motionX;
  double Z=motionZ;
  List list=this.worldObj.getCollidingBoundingBoxes(entity,entity.boundingBox.addCoord(X,0,Z));
  int j;
  for (j=0; j < list.size(); ++j) {
    X=((AxisAlignedBB)list.get(j)).calculateXOffset(entity.boundingBox,X);
  }
  entity.boundingBox.offset(X,0.0D,0.0D);
  for (j=0; j < list.size(); ++j) {
    Z=((AxisAlignedBB)list.get(j)).calculateZOffset(entity.boundingBox,Z);
  }
  entity.boundingBox.offset(0.0D,0.0D,Z);
  entity.posX=(entity.boundingBox.minX + entity.boundingBox.maxX) / 2.0D;
  entity.posZ=(entity.boundingBox.minZ + entity.boundingBox.maxZ) / 2.0D;
  entity.isCollidedHorizontally=motionX != X || motionZ != Z;
  entity.isCollided=entity.isCollidedHorizontally || entity.isCollidedVertically;
  motionX=X;
  motionZ=Z;
  return new double[]{motionX,motionZ};
}",0.9966887417218544
22799,"private static void postEvent(Event e){
  try {
    eventPhase.set(e,null);
  }
 catch (  IllegalArgumentException|IllegalAccessException e1) {
    throw (new RuntimeException(e1));
  }
  RiMRegistry.blockMoveBus.post(e);
}","private static void postEvent(Event e){
  try {
    eventPhase.set(e,null);
  }
 catch (  IllegalArgumentException e1) {
    throw (new RuntimeException(e1));
  }
catch (  IllegalAccessException e1) {
    throw (new RuntimeException(e1));
  }
  RiMRegistry.blockMoveBus.post(e);
}",0.882703777335984
22800,"public void handleChickenChunks(World worldObj,BlockRecord record,BlockRecord newPosition){
  if (record.entityRecord == null)   return;
  TileEntity te=worldObj.getTileEntity(record.X,record.Y,record.Z);
  if (te != null) {
    if (te instanceof TileChunkLoaderBase) {
      if (record.X >> 4 != newPosition.X >> 4 && record.Z >> 4 != newPosition.Z >> 4) {
        if (((TileChunkLoaderBase)te).active) {
          NBTTagCompound tag=new NBTTagCompound();
          ChickenChunkLoader loader=new ChickenChunkLoader((TileChunkLoaderBase)te);
          loader.writeToNBT(tag);
          record.entityRecord.setTag(""String_Node_Str"",tag);
        }
      }
    }
  }
}","public void handleChickenChunks(World worldObj,BlockRecord record,BlockRecord newPosition){
  if (record.entityRecord == null)   return;
  TileEntity te=worldObj.getTileEntity(record.X,record.Y,record.Z);
  if (te != null) {
    if (te instanceof TileChunkLoaderBase) {
      if (!(record.X >> 4 == newPosition.X >> 4 && record.Z >> 4 == newPosition.Z >> 4)) {
        if (((TileChunkLoaderBase)te).active) {
          NBTTagCompound tag=new NBTTagCompound();
          ChickenChunkLoader loader=new ChickenChunkLoader((TileChunkLoaderBase)te);
          loader.writeToNBT(tag);
          record.entityRecord.setTag(""String_Node_Str"",tag);
        }
      }
    }
  }
}",0.994756554307116
22801,"@Override public void fillPackage(CarriagePackage Package) throws CarriageMotionException {
  Directions SupportDirection=null;
  for (  Directions Direction : Directions.values()) {
    if (!SideClosed[Direction.ordinal()]) {
      SupportDirection=Direction;
      break;
    }
  }
  if (SupportDirection == null) {
    return;
  }
  BlockRecordSet ValidColumns=new BlockRecordSet();
  int ValidColumnCheckFactorX=(SupportDirection.deltaX == 0) ? (1) : (0);
  int ValidColumnCheckFactorY=(SupportDirection.deltaY == 0) ? (1) : (0);
  int ValidColumnCheckFactorZ=(SupportDirection.deltaZ == 0) ? (1) : (0);
  BlockRecordSet BlocksChecked=new BlockRecordSet();
  BlockRecordSet CarriagesToCheck=new BlockRecordSet();
  BlockRecordSet BlocksToCheck=new BlockRecordSet();
  BlocksChecked.add(Package.AnchorRecord);
  Package.AddBlock(Package.AnchorRecord);
  CarriagesToCheck.add(Package.AnchorRecord);
  int BlocksCarried=0;
  boolean terminatedByReversal=false;
  while (CarriagesToCheck.size() > 0) {
    BlockRecord CarriageRecord=CarriagesToCheck.pollFirst();
    if (((TileEntitySupportCarriage)CarriageRecord.entity).SideClosed[SupportDirection.ordinal()]) {
      throw (new CarriageMotionException(""String_Node_Str""));
    }
    ValidColumns.add(new BlockRecord(CarriageRecord.X * ValidColumnCheckFactorX,CarriageRecord.Y * ValidColumnCheckFactorY,CarriageRecord.Z * ValidColumnCheckFactorZ));
    if (Package.MotionDirection == SupportDirection.opposite()) {
      Package.AddPotentialObstruction(CarriageRecord.NextInDirection(Package.MotionDirection));
    }
    for (    Directions TargetDirection : Directions.values()) {
      if (TargetDirection == SupportDirection.opposite()) {
        continue;
      }
      BlockRecord TargetRecord=CarriageRecord.NextInDirection(TargetDirection);
      if (!BlocksChecked.add(TargetRecord)) {
        continue;
      }
      if (worldObj.isAirBlock(TargetRecord.X,TargetRecord.Y,TargetRecord.Z)) {
        continue;
      }
      TargetRecord.Identify(worldObj);
      if (TargetDirection == SupportDirection && !terminatedByReversal) {
        Package.AddBlock(TargetRecord);
        BlocksToCheck.add(TargetRecord);
        BlocksCarried++;
        if (BlocksCarried > RiMConfiguration.Carriage.MaxSupportBurden) {
          FailBecauseOverburdened();
        }
        if (TargetRecord.entity != null && TargetRecord.entity instanceof TileEntitySupportCarriage) {
          if (((TileEntityPlatformCarriage)TargetRecord.entity).treatSideAsClosed(SupportDirection.oppositeOrdinal)) {
            terminatedByReversal=true;
          }
        }
        continue;
      }
      if (Package.MatchesCarriageType(TargetRecord)) {
        Package.AddBlock(TargetRecord);
        CarriagesToCheck.add(TargetRecord);
        continue;
      }
      if (TargetDirection == Package.MotionDirection) {
        Package.AddPotentialObstruction(TargetRecord);
      }
    }
  }
  terminatedByReversal=false;
  while (BlocksToCheck.size() > 0) {
    BlockRecord BlockRecord=BlocksToCheck.pollFirst();
    for (    Directions TargetDirection : Directions.values()) {
      BlockRecord TargetRecord=BlockRecord.NextInDirection(TargetDirection);
{
        BlockRecord TargetRecordCheck=new BlockRecord(TargetRecord.X * ValidColumnCheckFactorX,TargetRecord.Y * ValidColumnCheckFactorY,TargetRecord.Z * ValidColumnCheckFactorZ);
        if (!ValidColumns.contains(TargetRecordCheck)) {
          if (TargetDirection == Package.MotionDirection) {
            Package.AddPotentialObstruction(TargetRecord);
          }
          continue;
        }
      }
      if (!BlocksChecked.add(TargetRecord)) {
        continue;
      }
      if (worldObj.isAirBlock(TargetRecord.X,TargetRecord.Y,TargetRecord.Z)) {
        continue;
      }
      TargetRecord.Identify(worldObj);
      if (SupportDirection == TargetDirection && terminatedByReversal)       continue;
      if (TargetRecord.entity != null && TargetRecord.entity instanceof TileEntitySupportCarriage) {
        if (!((TileEntityCarriage)TargetRecord.entity).treatSideAsClosed(SupportDirection.oppositeOrdinal)) {
          terminatedByReversal=true;
        }
      }
      Package.AddBlock(TargetRecord);
      BlocksToCheck.add(TargetRecord);
      BlocksCarried++;
      if (BlocksCarried > RiMConfiguration.Carriage.MaxSupportBurden) {
        FailBecauseOverburdened();
      }
    }
  }
}","@Override public void fillPackage(CarriagePackage Package) throws CarriageMotionException {
  Directions SupportDirection=null;
  for (  Directions Direction : Directions.values()) {
    if (!SideClosed[Direction.ordinal()]) {
      SupportDirection=Direction;
      break;
    }
  }
  if (SupportDirection == null) {
    return;
  }
  BlockRecordSet ValidColumns=new BlockRecordSet();
  int ValidColumnCheckFactorX=(SupportDirection.deltaX == 0) ? (1) : (0);
  int ValidColumnCheckFactorY=(SupportDirection.deltaY == 0) ? (1) : (0);
  int ValidColumnCheckFactorZ=(SupportDirection.deltaZ == 0) ? (1) : (0);
  BlockRecordSet BlocksChecked=new BlockRecordSet();
  BlockRecordSet CarriagesToCheck=new BlockRecordSet();
  BlockRecordSet BlocksToCheck=new BlockRecordSet();
  BlocksChecked.add(Package.AnchorRecord);
  Package.AddBlock(Package.AnchorRecord);
  CarriagesToCheck.add(Package.AnchorRecord);
  int BlocksCarried=0;
  boolean terminatedByReversal=false;
  while (CarriagesToCheck.size() > 0) {
    BlockRecord CarriageRecord=CarriagesToCheck.pollFirst();
    if (((TileEntitySupportCarriage)CarriageRecord.entity).SideClosed[SupportDirection.ordinal()]) {
      throw (new CarriageMotionException(""String_Node_Str""));
    }
    ValidColumns.add(new BlockRecord(CarriageRecord.X * ValidColumnCheckFactorX,CarriageRecord.Y * ValidColumnCheckFactorY,CarriageRecord.Z * ValidColumnCheckFactorZ));
    if (Package.MotionDirection == SupportDirection.opposite()) {
      Package.AddPotentialObstruction(CarriageRecord.NextInDirection(Package.MotionDirection));
    }
    for (    Directions TargetDirection : Directions.values()) {
      if (TargetDirection == SupportDirection.opposite()) {
        continue;
      }
      BlockRecord TargetRecord=CarriageRecord.NextInDirection(TargetDirection);
      if (!BlocksChecked.add(TargetRecord)) {
        continue;
      }
      if (worldObj.isAirBlock(TargetRecord.X,TargetRecord.Y,TargetRecord.Z)) {
        continue;
      }
      TargetRecord.Identify(worldObj);
      if (TargetDirection == SupportDirection && !terminatedByReversal) {
        Package.AddBlock(TargetRecord);
        BlocksToCheck.add(TargetRecord);
        BlocksCarried++;
        if (BlocksCarried > RiMConfiguration.Carriage.MaxSupportBurden) {
          FailBecauseOverburdened();
        }
        if (TargetRecord.entity != null && TargetRecord.entity instanceof TileEntitySupportCarriage) {
          if (((TileEntityCarriage)TargetRecord.entity).treatSideAsClosed(SupportDirection.oppositeOrdinal)) {
            terminatedByReversal=true;
          }
        }
        continue;
      }
      if (Package.MatchesCarriageType(TargetRecord)) {
        Package.AddBlock(TargetRecord);
        CarriagesToCheck.add(TargetRecord);
        continue;
      }
      if (TargetDirection == Package.MotionDirection) {
        Package.AddPotentialObstruction(TargetRecord);
      }
    }
  }
  terminatedByReversal=false;
  while (BlocksToCheck.size() > 0) {
    BlockRecord BlockRecord=BlocksToCheck.pollFirst();
    for (    Directions TargetDirection : Directions.values()) {
      BlockRecord TargetRecord=BlockRecord.NextInDirection(TargetDirection);
{
        BlockRecord TargetRecordCheck=new BlockRecord(TargetRecord.X * ValidColumnCheckFactorX,TargetRecord.Y * ValidColumnCheckFactorY,TargetRecord.Z * ValidColumnCheckFactorZ);
        if (!ValidColumns.contains(TargetRecordCheck)) {
          if (TargetDirection == Package.MotionDirection) {
            Package.AddPotentialObstruction(TargetRecord);
          }
          continue;
        }
      }
      if (!BlocksChecked.add(TargetRecord)) {
        continue;
      }
      if (worldObj.isAirBlock(TargetRecord.X,TargetRecord.Y,TargetRecord.Z)) {
        continue;
      }
      TargetRecord.Identify(worldObj);
      if (SupportDirection == TargetDirection && terminatedByReversal)       continue;
      if (TargetRecord.entity != null && TargetRecord.entity instanceof TileEntitySupportCarriage) {
        if (!((TileEntityCarriage)TargetRecord.entity).treatSideAsClosed(SupportDirection.oppositeOrdinal)) {
          terminatedByReversal=true;
        }
      }
      Package.AddBlock(TargetRecord);
      BlocksToCheck.add(TargetRecord);
      BlocksCarried++;
      if (BlocksCarried > RiMConfiguration.Carriage.MaxSupportBurden) {
        FailBecauseOverburdened();
      }
    }
  }
}",0.9990871748060246
22802,"@EventHandler public void ServerStopping(FMLServerStoppingEvent Event){
  try {
    TileEntityCarriageTranslocator.ActiveTranslocatorSets.clear();
  }
 catch (  Error e) {
  }
}","@EventHandler public void ServerStopping(FMLServerStoppingEvent Event){
  TileEntityCarriageTranslocator.ActiveTranslocatorSets.clear();
  TileEntityCarriageTransduplicator.ActiveTranslocatorSets.clear();
}",0.7467362924281984
22803,"@Override public void WriteCommonRecord(NBTTagCompound TagCompound){
  super.WriteCommonRecord(TagCompound);
  if (Player == null)   Player=""String_Node_Str"";
  TagCompound.setString(""String_Node_Str"",Player);
  TagCompound.setInteger(""String_Node_Str"",Label);
}","@Override public void WriteCommonRecord(NBTTagCompound TagCompound){
  super.WriteCommonRecord(TagCompound);
  TagCompound.setString(""String_Node_Str"",Player);
  TagCompound.setInteger(""String_Node_Str"",Label);
}",0.8945147679324894
22804,"public void setConfiguration(long flags,EntityPlayerMP changer){
  unregisterLabel();
  super.setConfiguration(flags,changer);
  flags=flags >> 3;
  Label=(int)(flags & 0xFFFFl);
  if ((flags & (1 << (Buttons.PRIVATE.ordinal() + 3))) != 0) {
    Player=changer.getDisplayName();
  }
 else {
    Player=""String_Node_Str"";
  }
  registerLabel();
}","public void setConfiguration(long flags,EntityPlayerMP changer){
  unregisterLabel();
  super.setConfiguration(flags,changer);
  flags=flags >> 3;
  Label=(int)(flags & 0xFFFFl);
  if ((flags & (1 << (Buttons.PRIVATE.ordinal()))) != 0) {
    Player=changer.getDisplayName();
  }
 else {
    Player=""String_Node_Str"";
  }
  registerLabel();
}",0.9941690962099126
22805,"@Override public boolean onBlockActivated(World World,int X,int Y,int Z,EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  TileEntity te=World.getTileEntity(X,Y,Z);
  if (te instanceof TileEntityCarriageDrive) {
    if (!(((TileEntityCarriageDrive)te).requiresScrewdriverToOpen && (Player.getHeldItem() == null || Player.getHeldItem().getItem() != RiMItems.ToolItemSet))) {
      if (te instanceof TileEntityCarriageTranslocator)       Player.openGui(ModRiM.instance,1,World,X,Y,Z);
 else       if (te instanceof TileEntityCarriageDirected)       Player.openGui(ModRiM.instance,2,World,X,Y,Z);
 else       Player.openGui(ModRiM.instance,0,World,X,Y,Z);
      return true;
    }
  }
  return false;
}","@Override public boolean onBlockActivated(World World,int X,int Y,int Z,EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  TileEntity te=World.getTileEntity(X,Y,Z);
  if (te instanceof TileEntityCarriageDrive && Player != null) {
    return ((TileEntityCarriageDrive)te).HandleToolUsage(Side,Player.isSneaking(),Player);
  }
  return false;
}",0.5004668534080299
22806,"@Override public void HandleToolUsage(int clickedSide,boolean sneaking){
  if (sneaking) {
    boolean sideClosedAtIMinus1=SideClosed[SideClosed.length - 1];
    for (int i=0; i < SideClosed.length; i++) {
      boolean oldSC=SideClosed[i];
      setSideClosed(i,sideClosedAtIMinus1);
      sideClosedAtIMinus1=oldSC;
    }
  }
 else {
    for (int i=0; i < SideClosed.length; i++) {
      setSideClosed(i,i != clickedSide);
    }
  }
  Propagate();
}","@Override public boolean HandleToolUsage(int clickedSide,boolean sneaking,EntityPlayer player){
  if (sneaking) {
    boolean sideClosedAtIMinus1=SideClosed[SideClosed.length - 1];
    for (int i=0; i < SideClosed.length; i++) {
      boolean oldSC=SideClosed[i];
      setSideClosed(i,sideClosedAtIMinus1);
      sideClosedAtIMinus1=oldSC;
    }
  }
 else {
    for (int i=0; i < SideClosed.length; i++) {
      setSideClosed(i,i != clickedSide);
    }
  }
  Propagate();
  return true;
}",0.951063829787234
22807,"public void HandleToolUsage(int Side,boolean Sneaking){
  if (Sneaking) {
    SideClosed[Side]=!SideClosed[Side];
  }
 else {
    Continuous=!Continuous;
  }
  Propagate();
}","public boolean HandleToolUsage(int Side,boolean Sneaking,EntityPlayer player){
  if (!requiresScrewdriverToOpen || (player.getHeldItem() != null && player.getHeldItem().getItem() == RiMItems.ToolItemSet)) {
    player.openGui(ModRiM.instance,0,worldObj,xCoord,yCoord,zCoord);
    return true;
  }
  return false;
}",0.0778688524590164
22808,"public void setAxis(int axis){
  axisOfRotationIndex=axis;
}","public void setAxis(int axis){
  pointedDir=Directions.validDirections()[axis];
}",0.5673758865248227
22809,"@Override public void EstablishSpectre(CarriagePackage Package){
  int CarriageX=Package.AnchorRecord.X;
  int CarriageY=Package.AnchorRecord.Y;
  int CarriageZ=Package.AnchorRecord.Z;
  WorldUtil.SetBlock(worldObj,CarriageX,CarriageY,CarriageZ,RIMBlocks.Spectre,BlockSpectre.Types.Rotative.ordinal());
  TileEntityRotativeSpectre theEntity=new TileEntityRotativeSpectre();
  theEntity.setAxis(axisOfRotationIndex);
  worldObj.setTileEntity(CarriageX,CarriageY,CarriageZ,theEntity);
  theEntity.Absorb(Package);
  worldObj.markBlockForUpdate(CarriageX,CarriageY,CarriageZ);
  worldObj.func_147451_t(CarriageX,CarriageY,CarriageZ);
}","@Override public void EstablishSpectre(CarriagePackage Package){
  int CarriageX=Package.AnchorRecord.X;
  int CarriageY=Package.AnchorRecord.Y;
  int CarriageZ=Package.AnchorRecord.Z;
  WorldUtil.SetBlock(worldObj,CarriageX,CarriageY,CarriageZ,RIMBlocks.Spectre,BlockSpectre.Types.Rotative.ordinal());
  TileEntityRotativeSpectre theEntity=new TileEntityRotativeSpectre();
  theEntity.setAxis(pointedDir.ordinal());
  worldObj.setTileEntity(CarriageX,CarriageY,CarriageZ,theEntity);
  theEntity.Absorb(Package);
  worldObj.markBlockForUpdate(CarriageX,CarriageY,CarriageZ);
  worldObj.func_147451_t(CarriageX,CarriageY,CarriageZ);
}",0.9691699604743084
22810,"@Override public IIcon getIcon(int side,int meta){
  try {
    if (drawSideClosed(side)) {
      return BlockCarriageDrive.InactiveIcon;
    }
 else {
      return icons[axisOfRotationIndex][side];
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    return Blocks.activator_rail.getIcon(0,0);
  }
}","@Override public IIcon getIcon(int side,int meta){
  try {
    if (drawSideClosed(side)) {
      return BlockCarriageDrive.InactiveIcon;
    }
 else {
      return icons[pointedDir.ordinal()][side];
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    return Blocks.activator_rail.getIcon(0,0);
  }
}",0.936378466557912
22811,"@Override public CarriagePackage GeneratePackage(TileEntity carriage,Directions CarriageDirection,Directions MotionDirection) throws CarriageMotionException {
  if (!DirtyHacks.allowRotation) {
    throw new CarriageMotionException(Lang.translate(ModRiM.Handle + ""String_Node_Str""));
  }
  CarriagePackage Package=new CarriagePackage(this,carriage,Directions.Null);
  Package.axis=axisOfRotationIndex;
  Package.blacklistByRotation=true;
  Package.AddBlock(Package.driveRecord);
  MultiTypeCarriageUtil.fillPackage(Package,carriage);
  Directions axis=Directions.values()[axisOfRotationIndex];
  BlockRecordSet dests=new BlockRecordSet();
  for (  BlockRecord record : Package.Body) {
    if ((record.X == xCoord || record.Y == yCoord || record.Z == zCoord)) {
      continue;
    }
    BlockRecord dest=RemIMRotator.simulateRotateOrthogonal(new BlockRecord(xCoord,yCoord,zCoord),axis,record);
    Package.AddPotentialObstruction(dest);
  }
  Package.Finalize();
  return (Package);
}","@Override public CarriagePackage GeneratePackage(TileEntity carriage,Directions CarriageDirection,Directions MotionDirection) throws CarriageMotionException {
  if (!DirtyHacks.allowRotation) {
    throw new CarriageMotionException(Lang.translate(ModRiM.Handle + ""String_Node_Str""));
  }
  CarriagePackage Package=new CarriagePackage(this,carriage,Directions.Null);
  Package.axis=pointedDir.ordinal();
  Package.blacklistByRotation=true;
  MultiTypeCarriageUtil.fillPackage(Package,carriage);
  BlockRecordSet dests=new BlockRecordSet();
  for (  BlockRecord record : Package.Body) {
    if ((record.X == xCoord || record.Y == yCoord || record.Z == zCoord)) {
      continue;
    }
    BlockRecord dest=RemIMRotator.simulateRotateOrthogonal(new BlockRecord(xCoord,yCoord,zCoord),pointedDir,record);
    Package.AddPotentialObstruction(dest);
  }
  Package.Finalize();
  return (Package);
}",0.9178228388473852
22812,"@Override public void updateEntity(){
  if (!(CarriageDirection != null && (CarriageDirection.ordinal() == axisOfRotationIndex || CarriageDirection.oppositeOrdinal == axisOfRotationIndex))) {
    CarriageDirection=null;
  }
  super.updateEntity();
}","@Override public void updateEntity(){
  if (!(CarriageDirection != null && (CarriageDirection == pointedDir || CarriageDirection.oppositeOrdinal == pointedDir.ordinal()))) {
    CarriageDirection=null;
  }
  super.updateEntity();
}",0.575
22813,"@Override public void rotateSpecial(ForgeDirection axis){
  super.rotateSpecial(axis);
  axisOfRotationIndex=Rotator.newSide(axisOfRotationIndex,axis);
}","@Override public void rotateSpecial(ForgeDirection axis){
  super.rotateSpecial(axis);
  pointedDir=Directions.values()[Rotator.newSide(pointedDir.ordinal(),axis)];
}",0.7648902821316614
22814,"public void setConfiguration(long flags,EntityPlayerMP changer){
  super.setConfiguration(flags,changer);
  flags=flags >> 3;
  Label=(int)(flags & 0xFFFFl);
  if ((flags & (1 << (Buttons.PRIVATE.ordinal() + 3))) != 0) {
    Player=changer.getDisplayName();
  }
 else {
    Player=""String_Node_Str"";
  }
}","public void setConfiguration(long flags,EntityPlayerMP changer){
  unregisterLabel();
  super.setConfiguration(flags,changer);
  flags=flags >> 3;
  Label=(int)(flags & 0xFFFFl);
  if ((flags & (1 << (Buttons.PRIVATE.ordinal() + 3))) != 0) {
    Player=changer.getDisplayName();
  }
 else {
    Player=""String_Node_Str"";
  }
  registerLabel();
}",0.9384615384615383
22815,"@Override public void updateEntity(){
  worldObj.theProfiler.startSection(""String_Node_Str"");
  if (worldObj.isRemote) {
    return;
  }
  if (Active) {
    if (ticksExisted > 0 && ticksExisted < CarriageMotion.MotionDuration && ticksExisted % 20 == 0) {
      if (Anchored()) {
        ModRiM.plHelper.playSound(worldObj,xCoord,yCoord,zCoord,CarriageMotion.SoundFile,CarriageMotion.volume,1f);
      }
    }
    ticksExisted++;
    if (ticksExisted >= CarriageMotion.MotionDuration)     ticksExisted=0;
  }
 else {
    if (ticksExisted != 0)     ticksExisted=0;
  }
  if (Stale) {
    HandleNeighbourBlockChange();
  }
  if (CooldownRemaining > 0) {
    CooldownRemaining--;
    MarkServerRecordDirty();
    return;
  }
  if (Active) {
    return;
  }
  if (SignalDirection == null) {
    if (Signalled) {
      Signalled=false;
      MarkServerRecordDirty();
    }
    return;
  }
  if (CarriageDirection == null) {
    return;
  }
  if (Signalled) {
    if (!Continuous) {
      return;
    }
  }
 else {
    Signalled=true;
    MarkServerRecordDirty();
  }
  worldObj.theProfiler.startSection(""String_Node_Str"");
  try {
    InitiateMotion(PreparePackage(getSignalDirection().opposite()));
    ModRiM.plHelper.playSound(worldObj,xCoord,yCoord,zCoord,CarriageMotion.SoundFile,CarriageMotion.volume,1f);
  }
 catch (  CarriageMotionException Exception) {
    String Message=""String_Node_Str"" + xCoord + ""String_Node_Str""+ yCoord+ ""String_Node_Str""+ zCoord+ ""String_Node_Str""+ worldObj.provider.dimensionId+ ""String_Node_Str""+ Exception.getMessage();
    if (Exception instanceof CarriageObstructionException) {
      CarriageObstructionException ObstructionException=(CarriageObstructionException)Exception;
      Message+=""String_Node_Str"" + ObstructionException.X + ""String_Node_Str""+ ObstructionException.Y+ ""String_Node_Str""+ ObstructionException.Z+ ""String_Node_Str"";
    }
    if (RiMConfiguration.Debug.LogMotionExceptions) {
      Debug.dbg(Message);
    }
    if (lastUsingPlayer != null) {
      lastUsingPlayer.addChatComponentMessage(new ChatComponentText(Message));
    }
  }
  worldObj.theProfiler.endSection();
  worldObj.theProfiler.endSection();
}","@Override public void updateEntity(){
  worldObj.theProfiler.startSection(""String_Node_Str"");
  if (worldObj.isRemote) {
    worldObj.theProfiler.endSection();
    return;
  }
  if (Active) {
    if (ticksExisted > 0 && ticksExisted < CarriageMotion.MotionDuration && ticksExisted % 20 == 0) {
      if (Anchored()) {
        ModRiM.plHelper.playSound(worldObj,xCoord,yCoord,zCoord,CarriageMotion.SoundFile,CarriageMotion.volume,1f);
      }
    }
    ticksExisted++;
    if (ticksExisted >= CarriageMotion.MotionDuration)     ticksExisted=0;
  }
 else {
    if (ticksExisted != 0)     ticksExisted=0;
  }
  if (Stale) {
    HandleNeighbourBlockChange();
  }
  if (CooldownRemaining > 0) {
    CooldownRemaining--;
    MarkServerRecordDirty();
    worldObj.theProfiler.endSection();
    return;
  }
  if (Active) {
    worldObj.theProfiler.endSection();
    return;
  }
  if (SignalDirection == null) {
    if (Signalled) {
      Signalled=false;
      MarkServerRecordDirty();
    }
    worldObj.theProfiler.endSection();
    return;
  }
  if (CarriageDirection == null) {
    worldObj.theProfiler.endSection();
    return;
  }
  if (Signalled) {
    if (!Continuous) {
      worldObj.theProfiler.endSection();
      return;
    }
  }
 else {
    Signalled=true;
    MarkServerRecordDirty();
  }
  worldObj.theProfiler.startSection(""String_Node_Str"");
  try {
    InitiateMotion(PreparePackage(getSignalDirection().opposite()));
    ModRiM.plHelper.playSound(worldObj,xCoord,yCoord,zCoord,CarriageMotion.SoundFile,CarriageMotion.volume,1f);
  }
 catch (  CarriageMotionException Exception) {
    String Message=""String_Node_Str"" + xCoord + ""String_Node_Str""+ yCoord+ ""String_Node_Str""+ zCoord+ ""String_Node_Str""+ worldObj.provider.dimensionId+ ""String_Node_Str""+ Exception.getMessage();
    if (Exception instanceof CarriageObstructionException) {
      CarriageObstructionException ObstructionException=(CarriageObstructionException)Exception;
      Message+=""String_Node_Str"" + ObstructionException.X + ""String_Node_Str""+ ObstructionException.Y+ ""String_Node_Str""+ ObstructionException.Z+ ""String_Node_Str"";
    }
    if (RiMConfiguration.Debug.LogMotionExceptions) {
      Debug.dbg(Message);
    }
    if (lastUsingPlayer != null) {
      lastUsingPlayer.addChatComponentMessage(new ChatComponentText(Message));
    }
  }
  worldObj.theProfiler.endSection();
  worldObj.theProfiler.endSection();
}",0.948336252189142
22816,"@Override public void updateEntity(){
  worldObj.theProfiler.startSection(""String_Node_Str"");
  ticksExisted++;
  for (  CapturedEntity Entity : CapturedEntities) {
    worldObj.theProfiler.startSection(""String_Node_Str"");
    Entity.Update();
    worldObj.theProfiler.endSection();
  }
  if (worldObj.isRemote) {
    return;
  }
  if (ticksExisted > 0 && ticksExisted < RiMConfiguration.CarriageMotion.MotionDuration && ticksExisted % 20 == 0) {
    if (bodyHasCarriageDrive()) {
      ModRiM.plHelper.playSound(worldObj,xCoord,yCoord,zCoord,CarriageMotion.SoundFile,CarriageMotion.volume,1f);
    }
  }
  if (ticksExisted < RiMConfiguration.CarriageMotion.MotionDuration) {
    return;
  }
  worldObj.theProfiler.startSection(""String_Node_Str"");
  Release();
  worldObj.theProfiler.endSection();
  worldObj.theProfiler.endSection();
}","@Override public void updateEntity(){
  worldObj.theProfiler.startSection(""String_Node_Str"");
  ticksExisted++;
  for (  CapturedEntity Entity : CapturedEntities) {
    worldObj.theProfiler.startSection(""String_Node_Str"");
    Entity.Update();
    worldObj.theProfiler.endSection();
  }
  if (worldObj.isRemote) {
    worldObj.theProfiler.endSection();
    return;
  }
  if (ticksExisted > 0 && ticksExisted < RiMConfiguration.CarriageMotion.MotionDuration && ticksExisted % 20 == 0) {
    if (bodyHasCarriageDrive()) {
      ModRiM.plHelper.playSound(worldObj,xCoord,yCoord,zCoord,CarriageMotion.SoundFile,CarriageMotion.volume,1f);
    }
  }
  if (ticksExisted < RiMConfiguration.CarriageMotion.MotionDuration) {
    worldObj.theProfiler.endSection();
    return;
  }
  worldObj.theProfiler.startSection(""String_Node_Str"");
  Release();
  worldObj.theProfiler.endSection();
  worldObj.theProfiler.endSection();
}",0.9554285714285714
22817,"public static boolean SetBlock(World world,int x,int y,int z,Block block,int meta){
  world.theProfiler.startSection(""String_Node_Str"");
  int chunkX=x & 0xF;
  int chunkZ=z & 0xF;
  Chunk chunk=world.getChunkFromBlockCoords(x,z);
  int i1=chunkZ << 4 | chunkX;
  if (y >= chunk.precipitationHeightMap[i1] - 1) {
    chunk.precipitationHeightMap[i1]=-999;
  }
  int j1=chunk.heightMap[i1];
  Block block1=chunk.getBlock(chunkX,y,chunkZ);
  int k1=chunk.getBlockMetadata(chunkX,y,chunkZ);
  if (block1 == block && k1 == meta) {
    world.theProfiler.endSection();
    return false;
  }
 else {
    ExtendedBlockStorage extendedblockstorage=chunk.storageArrays[y >> 4];
    boolean flag=false;
    if (extendedblockstorage == null) {
      if (block == Blocks.air) {
        world.theProfiler.endSection();
        return false;
      }
      extendedblockstorage=chunk.storageArrays[y >> 4]=new ExtendedBlockStorage(y >> 4 << 4,!world.provider.hasNoSky);
      flag=y >= j1;
    }
    int l1=x;
    int i2=z;
    int k2=block1.getLightOpacity(world,l1,y,i2);
    extendedblockstorage.func_150818_a(chunkX,y & 15,chunkZ,block);
    extendedblockstorage.setExtBlockMetadata(chunkX,y & 15,chunkZ,meta);
    if (!world.isRemote) {
      TileEntity te=chunk.getTileEntityUnsafe(chunkX & 0x0F,y,chunkZ & 0x0F);
      if (te != null && te.shouldRefresh(block1,chunk.getBlock(chunkX & 0x0F,y,chunkZ & 0x0F),k1,chunk.getBlockMetadata(chunkX & 0x0F,y,chunkZ & 0x0F),world,l1,y,i2)) {
        chunk.removeTileEntity(chunkX & 0x0F,y,chunkZ & 0x0F);
      }
    }
 else     if (block1.hasTileEntity(k1)) {
      TileEntity te=chunk.getTileEntityUnsafe(chunkX & 0x0F,y,chunkZ & 0x0F);
      if (te != null && te.shouldRefresh(block1,block,k1,meta,world,l1,y,i2)) {
        world.removeTileEntity(l1,y,i2);
      }
    }
    if (extendedblockstorage.getBlockByExtId(chunkX,y & 15,chunkZ) != block) {
      world.theProfiler.endSection();
      return false;
    }
 else {
      extendedblockstorage.setExtBlockMetadata(chunkX,y & 15,chunkZ,meta);
      if (flag) {
        chunk.generateSkylightMap();
      }
 else {
        int j2=block.getLightOpacity(world,l1,y,i2);
        if (j2 > 0) {
          if (y >= j1) {
            chunk.relightBlock(chunkX,y + 1,chunkZ);
          }
        }
 else         if (y == j1 - 1) {
          chunk.relightBlock(chunkX,y,chunkZ);
        }
        if (j2 != k2 && (j2 < k2 || chunk.getSavedLightValue(EnumSkyBlock.Sky,chunkX,y,chunkZ) > 0 || chunk.getSavedLightValue(EnumSkyBlock.Block,chunkX,y,chunkZ) > 0)) {
          chunk.propagateSkylightOcclusion(chunkX,chunkZ);
        }
      }
      TileEntity tileentity;
      if (block.hasTileEntity(meta)) {
        tileentity=chunk.func_150806_e(chunkX,y,chunkZ);
        if (tileentity != null) {
          tileentity.updateContainingBlockInfo();
          tileentity.blockMetadata=meta;
        }
      }
      chunk.isModified=true;
      world.theProfiler.startSection(""String_Node_Str"");
      world.func_147451_t(x,y,z);
      world.theProfiler.endSection();
      if (chunk.func_150802_k())       world.markBlockForUpdate(x,y,z);
      world.theProfiler.endSection();
      return true;
    }
  }
}","public static boolean SetBlock(World world,int x,int y,int z,Block block,int meta){
  int chunkX=x & 0xF;
  int chunkZ=z & 0xF;
  Chunk chunk=world.getChunkFromBlockCoords(x,z);
  int i1=chunkZ << 4 | chunkX;
  if (y >= chunk.precipitationHeightMap[i1] - 1) {
    chunk.precipitationHeightMap[i1]=-999;
  }
  int j1=chunk.heightMap[i1];
  Block block1=chunk.getBlock(chunkX,y,chunkZ);
  int k1=chunk.getBlockMetadata(chunkX,y,chunkZ);
  if (block1 == block && k1 == meta) {
    return false;
  }
 else {
    ExtendedBlockStorage extendedblockstorage=chunk.storageArrays[y >> 4];
    boolean flag=false;
    if (extendedblockstorage == null) {
      if (block == Blocks.air) {
        return false;
      }
      extendedblockstorage=chunk.storageArrays[y >> 4]=new ExtendedBlockStorage(y >> 4 << 4,!world.provider.hasNoSky);
      flag=y >= j1;
    }
    int l1=x;
    int i2=z;
    int k2=block1.getLightOpacity(world,l1,y,i2);
    extendedblockstorage.func_150818_a(chunkX,y & 15,chunkZ,block);
    extendedblockstorage.setExtBlockMetadata(chunkX,y & 15,chunkZ,meta);
    if (!world.isRemote) {
      TileEntity te=chunk.getTileEntityUnsafe(chunkX & 0x0F,y,chunkZ & 0x0F);
      if (te != null && te.shouldRefresh(block1,chunk.getBlock(chunkX & 0x0F,y,chunkZ & 0x0F),k1,chunk.getBlockMetadata(chunkX & 0x0F,y,chunkZ & 0x0F),world,l1,y,i2)) {
        chunk.removeTileEntity(chunkX & 0x0F,y,chunkZ & 0x0F);
      }
    }
 else     if (block1.hasTileEntity(k1)) {
      TileEntity te=chunk.getTileEntityUnsafe(chunkX & 0x0F,y,chunkZ & 0x0F);
      if (te != null && te.shouldRefresh(block1,block,k1,meta,world,l1,y,i2)) {
        world.removeTileEntity(l1,y,i2);
      }
    }
    if (extendedblockstorage.getBlockByExtId(chunkX,y & 15,chunkZ) != block) {
      return false;
    }
 else {
      extendedblockstorage.setExtBlockMetadata(chunkX,y & 15,chunkZ,meta);
      if (flag) {
        chunk.generateSkylightMap();
      }
 else {
        int j2=block.getLightOpacity(world,l1,y,i2);
        if (j2 > 0) {
          if (y >= j1) {
            chunk.relightBlock(chunkX,y + 1,chunkZ);
          }
        }
 else         if (y == j1 - 1) {
          chunk.relightBlock(chunkX,y,chunkZ);
        }
        if (j2 != k2 && (j2 < k2 || chunk.getSavedLightValue(EnumSkyBlock.Sky,chunkX,y,chunkZ) > 0 || chunk.getSavedLightValue(EnumSkyBlock.Block,chunkX,y,chunkZ) > 0)) {
          chunk.propagateSkylightOcclusion(chunkX,chunkZ);
        }
      }
      TileEntity tileentity;
      if (block.hasTileEntity(meta)) {
        tileentity=chunk.func_150806_e(chunkX,y,chunkZ);
        if (tileentity != null) {
          tileentity.updateContainingBlockInfo();
          tileentity.blockMetadata=meta;
        }
      }
      chunk.isModified=true;
      world.func_147451_t(x,y,z);
      if (chunk.func_150802_k())       world.markBlockForUpdate(x,y,z);
      return true;
    }
  }
}",0.950511382382052
22818,"@Override public void Setup(EntityPlayer Player,ItemStack Item){
  super.Setup(Player,Item);
  int l=BlockPistonBase.determineOrientation(Player.worldObj,xCoord,yCoord,zCoord,Player);
  pointedDir=Directions.values()[l];
}","@Override public void Setup(EntityPlayer Player,ItemStack Item){
  super.Setup(Player,Item);
  int l=BlockPistonBase.determineOrientation(Player.worldObj,xCoord,yCoord,zCoord,Player);
  pointedDir=Directions.values()[l].opposite();
}",0.9758241758241758
22819,"@SubscribeEvent public void onJoin(PlayerEvent.PlayerLoggedInEvent event){
  PacketSpecterVelocity.Dispatch((EntityPlayerMP)event.player);
}","@SubscribeEvent public void onJoin(PlayerEvent.PlayerLoggedInEvent event){
  if (!(event.player instanceof EntityPlayerMP))   return;
  if (((EntityPlayerMP)event.player).isClientWorld())   PacketSpecterVelocity.Dispatch((EntityPlayerMP)event.player);
}",0.712468193384224
22820,"public void EstablishPlaceholders(CarriagePackage Package){
  BlockRecordSet temp=new BlockRecordSet();
  if (Package.MotionDirection != null) {
    for (    BlockRecord Record : Package.Body) {
      BlockRecord temp2=Record.NextInDirection(Package.MotionDirection);
      temp2.block=Record.block;
      temp.add(temp2);
    }
  }
 else {
    temp=Package.Body;
  }
  for (  BlockRecord Record : temp) {
    SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,RIMBlocks.Spectre,BlockSpectre.Types.Supportive.ordinal());
    if (Package.MotionDirection != null) {
      worldObj.setTileEntity(Record.X,Record.Y,Record.Z,new TileEntitySupportiveSpectre());
      if (Record.block instanceof BlockCamouflageable) {
        if (Record.entityRecord != null) {
          Block b2=Block.getBlockById(Record.entityRecord.getInteger(""String_Node_Str""));
          if (b2 != null) {
            ((TileEntitySupportiveSpectre)worldObj.getTileEntity(Record.X,Record.Y,Record.Z)).setLight(b2);
          }
        }
      }
 else {
        ((TileEntitySupportiveSpectre)worldObj.getTileEntity(Record.X,Record.Y,Record.Z)).setLight(Record.block);
      }
    }
  }
  for (  BlockRecord Record : Package.Body) {
    if (temp.contains(Record))     continue;
    SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,RIMBlocks.air,0);
  }
}","public void EstablishPlaceholders(CarriagePackage Package){
  BlockRecordSet temp=new BlockRecordSet();
  if (Package.MotionDirection != null) {
    for (    BlockRecord Record : Package.Body) {
      BlockRecord temp2=Record.NextInDirection(Package.MotionDirection);
      temp2.block=Record.block;
      temp.add(temp2);
    }
  }
 else {
    temp=Package.Body;
  }
  for (  BlockRecord Record : temp) {
    SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,Blocks.air,0);
  }
  for (  BlockRecord Record : temp) {
    worldObj.setBlock(Record.X,Record.Y,Record.Z,RIMBlocks.Spectre,BlockSpectre.Types.Supportive.ordinal(),3);
    if (Package.MotionDirection != null && Package.MotionDirection.ordinal() != ForgeDirection.UNKNOWN.ordinal()) {
      worldObj.setTileEntity(Record.X,Record.Y,Record.Z,new TileEntitySupportiveSpectre());
      if (Record.block instanceof BlockCamouflageable) {
        if (Record.entityRecord != null) {
          Block b2=Block.getBlockById(Record.entityRecord.getInteger(""String_Node_Str""));
          if (b2 != null) {
            ((TileEntitySupportiveSpectre)worldObj.getTileEntity(Record.X,Record.Y,Record.Z)).setLight(b2);
          }
        }
      }
 else {
        ((TileEntitySupportiveSpectre)worldObj.getTileEntity(Record.X,Record.Y,Record.Z)).setLight(Record.block);
      }
    }
  }
  for (  BlockRecord Record : Package.Body) {
    if (temp.contains(Record))     continue;
    SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,RIMBlocks.air,0);
  }
}",0.8753056234718827
22821,"public static void Dispatch(EntityPlayerMP Player){
  if (Player.worldObj.isRemote)   return;
  NBTTagCompound Packet=new NBTTagCompound();
  Packet.setInteger(""String_Node_Str"",RiMConfiguration.CarriageMotion.MotionDuration);
  PacketManager.SendPacketToPlayer(Player,PacketTypes.SpecterVelocity,Packet);
}","public static void Dispatch(EntityPlayerMP Player){
  NBTTagCompound Packet=new NBTTagCompound();
  Packet.setInteger(""String_Node_Str"",RiMConfiguration.CarriageMotion.MotionDuration);
  PacketManager.SendPacketToPlayer(Player,PacketTypes.SpecterVelocity,Packet);
}",0.9265734265734266
22822,"@Override public void fillPackage(CarriagePackage Package) throws CarriageMotionException {
  if (Pattern == null) {
    updatePattern();
  }
  Package.AddBlock(Package.AnchorRecord);
  if (Package.MotionDirection != null) {
    Package.AddPotentialObstruction(Package.AnchorRecord.NextInDirection(Package.MotionDirection));
  }
  for (  BlockRecord PatternBlock : Pattern) {
    BlockRecord Record=new BlockRecord(PatternBlock.X + xCoord,PatternBlock.Y + yCoord,PatternBlock.Z + zCoord);
    if (worldObj.isAirBlock(Record.X,Record.Y,Record.Z)) {
      continue;
    }
    Record.Identify(worldObj);
    Package.AddBlock(Record);
    if (Package.MotionDirection != null) {
      Package.AddPotentialObstruction(Record.NextInDirection(Package.MotionDirection));
    }
  }
}","@Override public void fillPackage(CarriagePackage cPackage) throws CarriageMotionException {
  if (Pattern == null) {
    updatePattern();
  }
  cPackage.AddBlock(cPackage.AnchorRecord);
  if (cPackage.MotionDirection != null) {
    cPackage.AddPotentialObstruction(cPackage.AnchorRecord.NextInDirection(cPackage.MotionDirection));
  }
  for (  BlockRecord PatternBlock : Pattern) {
    BlockRecord Record=new BlockRecord(PatternBlock.X + xCoord,PatternBlock.Y + yCoord,PatternBlock.Z + zCoord);
    if (worldObj.isAirBlock(Record.X,Record.Y,Record.Z)) {
      continue;
    }
    Record.Identify(worldObj);
    cPackage.AddBlock(Record);
    if (cPackage.MotionDirection != null) {
      cPackage.AddPotentialObstruction(Record.NextInDirection(cPackage.MotionDirection));
    }
  }
}",0.9929351316634554
22823,"public void Finalize() throws CarriageMotionException {
  updateHardModeData();
  for (  BlockRecord PotentialObstruction : PotentialObstructions) {
    AssertNotObstruction(PotentialObstruction);
  }
  long WorldTime=World.getWorldInfo().getWorldTotalTime();
  try {
    TreeSet<NextTickListEntry> ticks=(TreeSet<NextTickListEntry>)Reflection.get(WorldServer.class,World,""String_Node_Str"");
    Set ticksHash=(Set)Reflection.get(WorldServer.class,World,""String_Node_Str"");
    java.util.Iterator PendingBlockUpdateSetIterator=ticks.iterator();
    while (PendingBlockUpdateSetIterator.hasNext()) {
      NextTickListEntry PendingBlockUpdate=(NextTickListEntry)PendingBlockUpdateSetIterator.next();
      if (Body.contains(new BlockRecord(PendingBlockUpdate.xCoord,PendingBlockUpdate.yCoord,PendingBlockUpdate.zCoord))) {
        PendingBlockUpdateSetIterator.remove();
        ticks.remove(PendingBlockUpdate);
        ticksHash.remove(PendingBlockUpdate);
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
      }
    }
  }
 catch (  Throwable VanillaThrowable) {
    if (VanillaThrowable instanceof ThreadDeath) {
      throw ((ThreadDeath)VanillaThrowable);
    }
    try {
      java.util.Set PendingBlockUpdateSet=(java.util.Set)ModInteraction.PendingBlockUpdateSetField.get(World);
      while (true) {
        NextTickListEntry PendingBlockUpdate=null;
        for (        Object Target : PendingBlockUpdateSet) {
          NextTickListEntry TargetPendingBlockUpdate=(NextTickListEntry)Target;
          if (Body.contains(new BlockRecord(TargetPendingBlockUpdate.xCoord,TargetPendingBlockUpdate.yCoord,TargetPendingBlockUpdate.zCoord))) {
            PendingBlockUpdate=TargetPendingBlockUpdate;
            break;
          }
        }
        if (PendingBlockUpdate == null) {
          break;
        }
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
        ModInteraction.RemovePendingBlockUpdate.invoke(World,PendingBlockUpdate);
      }
    }
 catch (    Throwable McpcThrowable) {
      McpcThrowable.printStackTrace();
      VanillaThrowable.printStackTrace();
    }
  }
  PotentialObstructions=null;
  Carriages=null;
  Cargo=null;
  CargoBurdenFactors=null;
}","public void Finalize() throws CarriageMotionException {
  updateHardModeData();
  for (  BlockRecord PotentialObstruction : PotentialObstructions) {
    AssertNotObstruction(PotentialObstruction);
  }
  long WorldTime=World.getWorldInfo().getWorldTotalTime();
  try {
    TreeSet<NextTickListEntry> ticks=(TreeSet<NextTickListEntry>)Reflection.get(WorldServer.class,World,""String_Node_Str"");
    Set ticksHash=(Set)Reflection.get(WorldServer.class,World,""String_Node_Str"");
    Iterator<NextTickListEntry> PendingBlockUpdateSetIterator=ticks.iterator();
    while (PendingBlockUpdateSetIterator.hasNext()) {
      NextTickListEntry PendingBlockUpdate=(NextTickListEntry)PendingBlockUpdateSetIterator.next();
      if (Body.contains(new BlockRecord(PendingBlockUpdate.xCoord,PendingBlockUpdate.yCoord,PendingBlockUpdate.zCoord))) {
        PendingBlockUpdateSetIterator.remove();
        ticks.remove(PendingBlockUpdate);
        ticksHash.remove(PendingBlockUpdate);
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
      }
    }
  }
 catch (  Throwable VanillaThrowable) {
    if (VanillaThrowable instanceof ThreadDeath) {
      throw ((ThreadDeath)VanillaThrowable);
    }
    try {
      java.util.Set PendingBlockUpdateSet=(java.util.Set)ModInteraction.PendingBlockUpdateSetField.get(World);
      while (true) {
        NextTickListEntry PendingBlockUpdate=null;
        for (        Object Target : PendingBlockUpdateSet) {
          NextTickListEntry TargetPendingBlockUpdate=(NextTickListEntry)Target;
          if (Body.contains(new BlockRecord(TargetPendingBlockUpdate.xCoord,TargetPendingBlockUpdate.yCoord,TargetPendingBlockUpdate.zCoord))) {
            PendingBlockUpdate=TargetPendingBlockUpdate;
            break;
          }
        }
        if (PendingBlockUpdate == null) {
          break;
        }
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
        ModInteraction.RemovePendingBlockUpdate.invoke(World,PendingBlockUpdate);
      }
    }
 catch (    Throwable McpcThrowable) {
      McpcThrowable.printStackTrace();
      VanillaThrowable.printStackTrace();
    }
  }
  PotentialObstructions=null;
  Carriages=null;
  Cargo=null;
  CargoBurdenFactors=null;
}",0.9934787497189116
22824,"public void AssertNotObstruction(BlockRecord Record) throws CarriageMotionException {
  if (Body.contains(Record)) {
    return;
  }
  if (World.isAirBlock(Record.X,Record.Y,Record.Z)) {
    return;
  }
  if (World.getBlock(Record.X,Record.Y,Record.Z).getMaterial().isLiquid()) {
    if (ObstructedByLiquids) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  if (World.getBlock(Record.X,Record.Y,Record.Z).canBeReplacedByLeaves(World,Record.X,Record.Y,Record.Z)) {
    if (ObstructedByFragileBlocks) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  FailBecauseObstructed(Record,""String_Node_Str"");
}","public void AssertNotObstruction(BlockRecord record) throws CarriageMotionException {
  if (Body.contains(record)) {
    return;
  }
  if (World.isAirBlock(record.X,record.Y,record.Z))   return;
  Block block=World.getBlock(record.X,record.Y,record.Z);
  if (block != null) {
    if (!ObstructedByLiquids && (FluidRegistry.lookupFluidForBlock(block) != null)) {
      return;
    }
 else     if (ObstructedByLiquids && (FluidRegistry.lookupFluidForBlock(block) != null)) {
      FailBecauseObstructed(record,""String_Node_Str"");
    }
    if (!ObstructedByFragileBlocks && block.getMaterial().isReplaceable()) {
      return;
    }
 else     if (ObstructedByFragileBlocks && block.getMaterial().isReplaceable()) {
      FailBecauseObstructed(record,""String_Node_Str"");
    }
    FailBecauseObstructed(record,""String_Node_Str"");
  }
}",0.5997322623828648
22825,"@Override public void Setup(EntityPlayer Player,ItemStack Item){
  Decoration=ItemCarriage.GetDecorationId(Item);
  DecorationMeta=ItemCarriage.GetDecorationMeta(Item);
}","@Override public void Setup(EntityPlayer Player,ItemStack Item){
  Decoration=ItemCarriage.GetDecorationBlock(Item);
  DecorationMeta=ItemCarriage.GetDecorationMeta(Item);
}",0.979591836734694
22826,"@Override public IIcon getIcon(IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    TileEntityCarriage Carriage=(TileEntityCarriage)World.getTileEntity(X,Y,Z);
    if ((Carriage.Decoration != null) && (Carriage.SideClosed[Side])) {
      return (Carriage.Decoration.getIcon(Side,Carriage.DecorationMeta));
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    return (Carriage.SideClosed[Side] ? Type.ClosedIcon : Type.OpenIcon);
  }
 catch (  Throwable t) {
    t.printStackTrace();
    return (RIMBlocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(IBlockAccess world,int X,int Y,int Z,int Side){
  try {
    TileEntityCarriage carriage=(TileEntityCarriage)world.getTileEntity(X,Y,Z);
    if ((carriage.Decoration != null) && (carriage.SideClosed[Side])) {
      return (carriage.Decoration.getIcon(Side,carriage.DecorationMeta));
    }
    Types type=Types.values()[world.getBlockMetadata(X,Y,Z)];
    return (carriage.SideClosed[Side] ? type.ClosedIcon : type.OpenIcon);
  }
 catch (  Throwable t) {
    t.printStackTrace();
    return (RIMBlocks.Spectre.getIcon(world,X,Y,Z,Side));
  }
}",0.8381962864721485
22827,"public static int GetDecorationMeta(ItemStack Item){
  if (Item.stackTagCompound != null) {
    return (Item.stackTagCompound.getInteger(""String_Node_Str""));
  }
  return ((Item.getItemDamage() >>> 4) & 0xF);
}","public static int GetDecorationMeta(ItemStack Item){
  if (Item.stackTagCompound != null) {
    return (Item.stackTagCompound.getInteger(""String_Node_Str""));
  }
  return Item.getItemDamage();
}",0.9603960396039604
22828,"@Override public void AddTooltip(ItemStack Item,List TooltipLines){
  if (RiMConfiguration.Cosmetic.ShowHelpInTooltips) {
    try {
      for (      String s : Lang.translate(ModRiM.Handle + ""String_Node_Str"" + GetBlockType(Item)).split(""String_Node_Str"")) {
        TooltipLines.add(s);
      }
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
      return;
    }
  }
  Block DecorationId=GetDecorationId(Item);
  if (DecorationId == Blocks.air) {
    return;
  }
  if (Item.stackTagCompound == null) {
    TooltipLines.add(Arrays.asList(Lang.translate(ModRiM.Handle + ""String_Node_Str"").split(""String_Node_Str"")));
  }
  ItemStack Decoration=Stack.New(DecorationId,GetDecorationMeta(Item));
  try {
    TooltipLines.add(Lang.translate(ModRiM.Handle + ""String_Node_Str"") + Decoration.getItem().getItemStackDisplayName(Decoration));
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    TooltipLines.add(Lang.translate(ModRiM.Handle + ""String_Node_Str"") + ""String_Node_Str"");
  }
}","@Override public void AddTooltip(ItemStack Item,List TooltipLines){
  if (RiMConfiguration.Cosmetic.ShowHelpInTooltips) {
    try {
      for (      String s : Lang.translate(ModRiM.Handle + ""String_Node_Str"" + GetBlockType(Item)).split(""String_Node_Str"")) {
        TooltipLines.add(s);
      }
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
      return;
    }
  }
  Block DecorationId=GetDecorationBlock(Item);
  if (DecorationId == Blocks.air) {
    return;
  }
  if (Item.stackTagCompound == null) {
    TooltipLines.add(Arrays.asList(Lang.translate(ModRiM.Handle + ""String_Node_Str"").split(""String_Node_Str"")));
  }
  ItemStack Decoration=Stack.New(DecorationId,GetDecorationMeta(Item));
  try {
    TooltipLines.add(Lang.translate(ModRiM.Handle + ""String_Node_Str"") + Decoration.getItem().getItemStackDisplayName(Decoration));
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    TooltipLines.add(Lang.translate(ModRiM.Handle + ""String_Node_Str"") + ""String_Node_Str"");
  }
}",0.996600291403594
22829,"public int Integer(String Name,int Default){
  return (Configuration.get(Category,Name,Default).getInt(Default));
}","public int Integer(String Name,String comment,int Default){
  Property a=Configuration.get(Category,Name,Default);
  a.comment=comment;
  return a.getInt(Default);
}",0.7857142857142857
22830,"public int BoundedInteger(String Name,int Min,int Default,int Max){
  int Value=Integer(Name,Default);
  if (Value < Min) {
    new RuntimeException(Name + ""String_Node_Str"" + Min).printStackTrace();
    return (Default);
  }
  if (Value > Max) {
    new RuntimeException(Name + ""String_Node_Str"" + Max).printStackTrace();
    return (Default);
  }
  return (Value);
}","public int BoundedInteger(String Name,String comment,int Min,int Default,int Max){
  int Value=Integer(Name,comment,Default);
  if (Value < Min) {
    new RuntimeException(Name + ""String_Node_Str"" + Min).printStackTrace();
    return (Default);
  }
  if (Value > Max) {
    new RuntimeException(Name + ""String_Node_Str"" + Max).printStackTrace();
    return (Default);
  }
  return (Value);
}",0.9696969696969696
22831,"public String String(String Name,String Default){
  return (Configuration.get(Category,Name,Default).getString());
}","public String String(String Name,String comment,String Default){
  Property a=Configuration.get(Category,Name,Default);
  a.comment=comment;
  return a.getString();
}",0.7872340425531915
22832,"public boolean Boolean(String Name,boolean Default){
  return (Configuration.get(Category,Name,Default).getBoolean(Default));
}","public boolean Boolean(String Name,String comment,boolean Default){
  Property a=Configuration.get(Category,Name,Default);
  a.comment=comment;
  return a.getBoolean(Default);
}",0.8026315789473685
22833,"public BlockRiM(Block Template,Class<? extends ItemBlockRiM> BlockItemClass,String HarvestToolType,Class<? extends TileEntityRiM>... TileEntityClasses){
  this(Template,BlockItemClass,TileEntityClasses);
  setCreativeTab(CreativeTab.Instance);
}","public BlockRiM(Block Template,Class<? extends ItemBlockRiM> BlockItemClass,Class<? extends TileEntityRiM>... TileEntityList){
  super(Template.getMaterial());
  TileEntityClasses=TileEntityList;
  setBlockName(ModRiM.Handle + ""String_Node_Str"" + getClass().getSimpleName().substring(5,getClass().getSimpleName().length()));
  setHardness(Template.getBlockHardness(null,0,0,0));
  setStepSound(Template.stepSound);
  GameRegistry.registerBlock(this,BlockItemClass,getUnlocalizedName());
  this.setCreativeTab(CreativeTab.Instance);
}",0.467866323907455
22834,"public BlockCarriage(){
  super(Blocks.planks,ItemCarriage.class,HarvestToolTypes.Hatchet,TileEntityFrameCarriage.class,TileEntitySupportCarriage.class,TileEntityStructureCarriage.class,TileEntityPlatformCarriage.class,TileEntityTemplateCarriage.class);
}","public BlockCarriage(){
  super(Blocks.planks,ItemCarriage.class,TileEntityFrameCarriage.class,TileEntitySupportCarriage.class,TileEntityStructureCarriage.class,TileEntityPlatformCarriage.class,TileEntityTemplateCarriage.class);
  this.setHarvestLevel(HarvestToolTypes.Hatchet,0);
}",0.3128491620111732
22835,"public static boolean isAWrench(ItemStack stk){
  for (  Class c : wrenchClasses) {
    if (stk != null && stk.getItem() != null && stk.getItem().getClass().isAssignableFrom(c)) {
      return true;
    }
  }
  return false;
}","public static boolean isAWrench(ItemStack stk){
  for (  Class c : wrenchClasses) {
    if (stk != null && stk.getItem() != null && (stk.getItem().getClass().isAssignableFrom(c) || c.isInstance(stk.getItem()))) {
      return true;
    }
  }
  return false;
}",0.931958762886598
22836,"public static void Initialize(){
  Carriage=new BlockCarriage();
  CarriageDrive=new BlockCarriageDrive();
  Spectre=new BlockSpectre();
}","public static void Initialize(){
  BlockRiM.initLegacyClassMap();
  Carriage=new BlockCarriage();
  CarriageDrive=new BlockCarriageDrive();
  Spectre=new BlockSpectre();
}",0.8932038834951457
22837,"public BlockCarriageDrive(){
  super(Blocks.iron_block,ItemCarriageDrive.class,HarvestToolTypes.Pickaxe,TileEntityCarriageEngine.class,TileEntityCarriageMotor.class,TileEntityCarriageController.class,TileEntityCarriageTranslocator.class,TileEntityCarriageTransduplicator.class,TileEntityCarriageAdapter.class,TileEntityCarriageRotator.class);
}","public BlockCarriageDrive(){
  super(Blocks.iron_block,ItemCarriageDrive.class,TileEntityCarriageEngine.class,TileEntityCarriageMotor.class,TileEntityCarriageController.class,TileEntityCarriageTranslocator.class,TileEntityCarriageTransduplicator.class,TileEntityCarriageAdapter.class,TileEntityCarriageRotator.class);
  this.setHarvestLevel(HarvestToolTypes.Pickaxe,0);
}",0.8923076923076924
22838,"@SideOnly(Side.CLIENT) public IIcon getIcon(int Side,int meta){
  try {
    if (SideClosed[Side]) {
      return (CarriageDrive.InactiveIcon);
    }
    Types Type=Types.values()[meta];
    if (Continuous) {
      return (Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.iron_block.getIcon(0,0));
  }
}","public IIcon getIcon(int Side,int meta){
  try {
    if (SideClosed[Side]) {
      return (CarriageDrive.InactiveIcon);
    }
    Types Type=Types.values()[meta];
    if (Continuous) {
      return (Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.iron_block.getIcon(0,0));
  }
}",0.972972972972973
22839,"@Override public Packet getDescriptionPacket(){
  S35PacketUpdateTileEntity Packet=new S35PacketUpdateTileEntity(xCoord,yCoord,zCoord,0,new net.minecraft.nbt.NBTTagCompound());
  WriteCommonRecord(Packet.func_148857_g());
  WriteClientRecord(Packet.func_148857_g());
  return (Packet);
}","@Override public Packet getDescriptionPacket(){
  NBTTagCompound tag=new NBTTagCompound();
  this.writeToNBT(tag);
  return new S35PacketUpdateTileEntity(xCoord,yCoord,zCoord,1,tag);
}",0.505307855626327
22840,"public void Finalize() throws CarriageMotionException {
  for (  BlockRecord PotentialObstruction : PotentialObstructions) {
    AssertNotObstruction(PotentialObstruction);
  }
  long WorldTime=World.getWorldInfo().getWorldTotalTime();
  try {
    TreeSet<NextTickListEntry> ticks=(TreeSet<NextTickListEntry>)Reflection.get(WorldServer.class,World,""String_Node_Str"");
    java.util.Iterator PendingBlockUpdateSetIterator=ticks.iterator();
    while (PendingBlockUpdateSetIterator.hasNext()) {
      NextTickListEntry PendingBlockUpdate=(net.minecraft.world.NextTickListEntry)PendingBlockUpdateSetIterator.next();
      if (Body.contains(new BlockRecord(PendingBlockUpdate.xCoord,PendingBlockUpdate.yCoord,PendingBlockUpdate.zCoord))) {
        PendingBlockUpdateSetIterator.remove();
        ticks.remove(PendingBlockUpdate);
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
      }
    }
  }
 catch (  Throwable VanillaThrowable) {
    if (VanillaThrowable instanceof ThreadDeath) {
      throw ((ThreadDeath)VanillaThrowable);
    }
    try {
      java.util.Set PendingBlockUpdateSet=(java.util.Set)ModInteraction.PendingBlockUpdateSetField.get(World);
      while (true) {
        net.minecraft.world.NextTickListEntry PendingBlockUpdate=null;
        for (        Object Target : PendingBlockUpdateSet) {
          net.minecraft.world.NextTickListEntry TargetPendingBlockUpdate=(net.minecraft.world.NextTickListEntry)Target;
          if (Body.contains(new BlockRecord(TargetPendingBlockUpdate.xCoord,TargetPendingBlockUpdate.yCoord,TargetPendingBlockUpdate.zCoord))) {
            PendingBlockUpdate=TargetPendingBlockUpdate;
            break;
          }
        }
        if (PendingBlockUpdate == null) {
          break;
        }
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
        ModInteraction.RemovePendingBlockUpdate.invoke(World,PendingBlockUpdate);
      }
    }
 catch (    Throwable McpcThrowable) {
      McpcThrowable.printStackTrace();
      VanillaThrowable.printStackTrace();
    }
  }
  if (Configuration.HardmodeActive) {
    for (    BlockRecord CarriageRecord : Carriages) {
      int Tier=((CarriageEntity)CarriageRecord.Entity).Tier;
      double Factor=Carriage.Tiers.values()[Tier].CargoBurdenFactor;
      if (Tier == 0) {
        for (        Directions Direction : Directions.values()) {
          BlockRecord Position=CarriageRecord.NextInDirection(Direction);
          ApplyCargoBurdenFactor(Position,Factor);
        }
      }
 else {
        for (int Distance=1; Distance <= Tier; Distance++, Factor=Math.sqrt(Factor)) {
          int MinX=CarriageRecord.X - Distance;
          int MinY=CarriageRecord.Y - Distance;
          int MinZ=CarriageRecord.Z - Distance;
          int MaxX=CarriageRecord.X + Distance;
          int MaxY=CarriageRecord.Y + Distance;
          int MaxZ=CarriageRecord.Z + Distance;
          for (int X=MinX; X <= MaxX; X++) {
            for (int Y=MinY; Y <= MaxY; Y++) {
              for (int Z=MinZ; Z <= MaxZ; Z++) {
                if ((X == MinX) || (X == MaxX) || (Y == MinY)|| (Y == MaxY)|| (Z == MinZ)|| (Z == MaxZ)) {
                  ApplyCargoBurdenFactor(new BlockRecord(X,Y,Z),Factor);
                }
              }
            }
          }
        }
      }
    }
    for (    BlockRecord CargoRecord : Cargo) {
      Double BurdenFactor=CargoBurdenFactors.get(CargoRecord);
      double Burden=GetBaseBurden(CargoRecord);
      if (BurdenFactor == null) {
        Mass+=Burden;
      }
 else {
        Mass+=Burden * BurdenFactor;
      }
    }
  }
  PotentialObstructions=null;
  Carriages=null;
  Cargo=null;
  CargoBurdenFactors=null;
}","public void Finalize() throws CarriageMotionException {
  Debug.dbg(""String_Node_Str"");
  for (  BlockRecord PotentialObstruction : PotentialObstructions) {
    Debug.dbg(""String_Node_Str"" + PotentialObstruction);
    AssertNotObstruction(PotentialObstruction);
  }
  Debug.dbg(""String_Node_Str"");
  long WorldTime=World.getWorldInfo().getWorldTotalTime();
  try {
    TreeSet<NextTickListEntry> ticks=(TreeSet<NextTickListEntry>)Reflection.get(WorldServer.class,World,""String_Node_Str"");
    java.util.Iterator PendingBlockUpdateSetIterator=ticks.iterator();
    while (PendingBlockUpdateSetIterator.hasNext()) {
      NextTickListEntry PendingBlockUpdate=(net.minecraft.world.NextTickListEntry)PendingBlockUpdateSetIterator.next();
      if (Body.contains(new BlockRecord(PendingBlockUpdate.xCoord,PendingBlockUpdate.yCoord,PendingBlockUpdate.zCoord))) {
        PendingBlockUpdateSetIterator.remove();
        ticks.remove(PendingBlockUpdate);
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
      }
    }
  }
 catch (  Throwable VanillaThrowable) {
    if (VanillaThrowable instanceof ThreadDeath) {
      throw ((ThreadDeath)VanillaThrowable);
    }
    try {
      java.util.Set PendingBlockUpdateSet=(java.util.Set)ModInteraction.PendingBlockUpdateSetField.get(World);
      while (true) {
        net.minecraft.world.NextTickListEntry PendingBlockUpdate=null;
        for (        Object Target : PendingBlockUpdateSet) {
          net.minecraft.world.NextTickListEntry TargetPendingBlockUpdate=(net.minecraft.world.NextTickListEntry)Target;
          if (Body.contains(new BlockRecord(TargetPendingBlockUpdate.xCoord,TargetPendingBlockUpdate.yCoord,TargetPendingBlockUpdate.zCoord))) {
            PendingBlockUpdate=TargetPendingBlockUpdate;
            break;
          }
        }
        if (PendingBlockUpdate == null) {
          break;
        }
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
        ModInteraction.RemovePendingBlockUpdate.invoke(World,PendingBlockUpdate);
      }
    }
 catch (    Throwable McpcThrowable) {
      McpcThrowable.printStackTrace();
      VanillaThrowable.printStackTrace();
    }
  }
  if (Configuration.HardmodeActive) {
    for (    BlockRecord CarriageRecord : Carriages) {
      int Tier=((CarriageEntity)CarriageRecord.Entity).Tier;
      double Factor=Carriage.Tiers.values()[Tier].CargoBurdenFactor;
      if (Tier == 0) {
        for (        Directions Direction : Directions.values()) {
          BlockRecord Position=CarriageRecord.NextInDirection(Direction);
          ApplyCargoBurdenFactor(Position,Factor);
        }
      }
 else {
        for (int Distance=1; Distance <= Tier; Distance++, Factor=Math.sqrt(Factor)) {
          int MinX=CarriageRecord.X - Distance;
          int MinY=CarriageRecord.Y - Distance;
          int MinZ=CarriageRecord.Z - Distance;
          int MaxX=CarriageRecord.X + Distance;
          int MaxY=CarriageRecord.Y + Distance;
          int MaxZ=CarriageRecord.Z + Distance;
          for (int X=MinX; X <= MaxX; X++) {
            for (int Y=MinY; Y <= MaxY; Y++) {
              for (int Z=MinZ; Z <= MaxZ; Z++) {
                if ((X == MinX) || (X == MaxX) || (Y == MinY)|| (Y == MaxY)|| (Z == MinZ)|| (Z == MaxZ)) {
                  ApplyCargoBurdenFactor(new BlockRecord(X,Y,Z),Factor);
                }
              }
            }
          }
        }
      }
    }
    for (    BlockRecord CargoRecord : Cargo) {
      Double BurdenFactor=CargoBurdenFactors.get(CargoRecord);
      double Burden=GetBaseBurden(CargoRecord);
      if (BurdenFactor == null) {
        Mass+=Burden;
      }
 else {
        Mass+=Burden * BurdenFactor;
      }
    }
  }
  PotentialObstructions=null;
  Carriages=null;
  Cargo=null;
  CargoBurdenFactors=null;
}",0.9792642140468228
22841,"public void AssertNotObstruction(BlockRecord Record) throws CarriageMotionException {
  Debug.dbg(""String_Node_Str"");
  if (Body.contains(Record)) {
    return;
  }
  if (World.isAirBlock(Record.X,Record.Y,Record.Z)) {
    return;
  }
  if (World.getBlock(Record.X,Record.Y,Record.Z).getMaterial().isLiquid()) {
    if (ObstructedByLiquids) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  if (!World.getBlock(Record.X,Record.Y,Record.Z).canBeReplacedByLeaves(World,Record.X,Record.Y,Record.Z)) {
    if (ObstructedByFragileBlocks) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  FailBecauseObstructed(Record,""String_Node_Str"");
}","public void AssertNotObstruction(BlockRecord Record) throws CarriageMotionException {
  Debug.dbg(""String_Node_Str"" + Record);
  if (Body.contains(Record)) {
    Debug.dbg(""String_Node_Str"");
    return;
  }
  if (World.isAirBlock(Record.X,Record.Y,Record.Z)) {
    Debug.dbg(""String_Node_Str"");
    return;
  }
  if (World.getBlock(Record.X,Record.Y,Record.Z).getMaterial().isLiquid()) {
    Debug.dbg(""String_Node_Str"");
    if (ObstructedByLiquids) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  if (!World.getBlock(Record.X,Record.Y,Record.Z).canBeReplacedByLeaves(World,Record.X,Record.Y,Record.Z)) {
    Debug.dbg(""String_Node_Str"");
    if (ObstructedByFragileBlocks) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  Debug.dbg(""String_Node_Str"");
  FailBecauseObstructed(Record,""String_Node_Str"");
}",0.8870453095086152
22842,"public void doRelease(){
  Debug.dbg(""String_Node_Str"" + Body.toString());
  for (  BlockRecord Record : Body) {
    SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,Record.Id,Record.Meta);
  }
  BlockRecordList PipesToInitialize=new BlockRecordList();
  if (ModInteraction.ForgeMultipart.MultipartSaveLoad_loadingWorld_$eq != null) {
    try {
      ModInteraction.ForgeMultipart.MultipartSaveLoad_loadingWorld_$eq.invoke(null,worldObj);
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  BlockRecordList MultipartTilesToInitialize=new BlockRecordList();
  java.util.HashMap<net.minecraft.world.chunk.Chunk,java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>> MultipartTileSetsToPropagate=new java.util.HashMap<net.minecraft.world.chunk.Chunk,java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>>();
  for (  BlockRecord Record : Body) {
    if (Record.EntityRecord != null) {
      Record.EntityRecord.setInteger(""String_Node_Str"",Record.X);
      Record.EntityRecord.setInteger(""String_Node_Str"",Record.Y);
      Record.EntityRecord.setInteger(""String_Node_Str"",Record.Z);
      if (Record.EntityRecord.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        try {
          if (ModInteraction.ForgeMultipart.MultipartHelper_createTileFromNBT != null) {
            Record.Entity=(net.minecraft.tileentity.TileEntity)ModInteraction.ForgeMultipart.MultipartHelper_createTileFromNBT.invoke(null,worldObj,Record.EntityRecord);
          }
 else {
            Record.Entity=(net.minecraft.tileentity.TileEntity)ModInteraction.ForgeMultipart.TileMultipart_createFromNBT.invoke(null,Record.EntityRecord);
            MultipartContainerBlockId=Record.Id;
            net.minecraft.world.chunk.Chunk Chunk=worldObj.getChunkFromBlockCoords(Record.X,Record.Z);
            java.util.HashMap<Object,net.minecraft.tileentity.TileEntity> MultipartTilesToPropagate=MultipartTileSetsToPropagate.get(Chunk);
            if (MultipartTilesToPropagate == null) {
              MultipartTilesToPropagate=new java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>();
              MultipartTileSetsToPropagate.put(Chunk,MultipartTilesToPropagate);
            }
            MultipartTilesToPropagate.put(Record.Entity,Record.Entity);
          }
          MultipartTilesToInitialize.add(Record);
        }
 catch (        Throwable Throwable) {
          Throwable.printStackTrace();
          continue;
        }
      }
 else {
        Record.Entity=net.minecraft.tileentity.TileEntity.createAndLoadEntity(Record.EntityRecord);
      }
      SneakyWorldUtil.SetTileEntity(worldObj,Record.X,Record.Y,Record.Z,Record.Entity);
      if (Configuration.DirtyHacks.UpdateBuildcraftPipes) {
        if (ModInteraction.BC_TileGenericPipe != null) {
          if (ModInteraction.BC_TileGenericPipe.isInstance(Record.Entity)) {
            PipesToInitialize.add(Record);
          }
        }
      }
    }
  }
  for (  BlockRecord Record : MultipartTilesToInitialize) {
    try {
      ModInteraction.ForgeMultipart.TileMultipart_onChunkLoad.invoke(Record.Entity);
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  if (ModInteraction.ForgeMultipart.MultipartHelper_sendDescPacket != null) {
    for (    BlockRecord Record : MultipartTilesToInitialize) {
      try {
        ModInteraction.ForgeMultipart.MultipartHelper_sendDescPacket.invoke(null,worldObj,Record.Entity);
      }
 catch (      Throwable Throwable) {
        Throwable.printStackTrace();
      }
    }
  }
 else {
    for (    java.util.Map.Entry<net.minecraft.world.chunk.Chunk,java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>> MultipartTilesToPropagate : MultipartTileSetsToPropagate.entrySet()) {
      net.minecraft.world.chunk.Chunk Chunk=MultipartTilesToPropagate.getKey();
      java.util.Map SavedTileEntityMap=Chunk.chunkTileEntityMap;
      Chunk.chunkTileEntityMap=MultipartTilesToPropagate.getValue();
      try {
        for (        net.minecraft.entity.player.EntityPlayerMP Player : ((java.util.List<net.minecraft.entity.player.EntityPlayerMP>)Reflection.get(Class.forName(""String_Node_Str""),Reflection.runMethod(WorldServer.class,(((WorldServer)worldObj).getPlayerManager()),""String_Node_Str"",Chunk.xPosition,Chunk.zPosition,false),""String_Node_Str""))) {
          if (!Player.loadedChunks.contains(Chunk.getChunkCoordIntPair())) {
            try {
              if (ModInteraction.ForgeMultipart.MultipartSaveLoad_loadingWorld_$eq == null) {
                MultipartPropagationPacket.Dispatch(Player,MultipartTilesToPropagate.getValue().values());
              }
              ModInteraction.ForgeMultipart.MultipartSPH_onChunkWatch.invoke(null,Player,Chunk);
            }
 catch (            Throwable Throwable) {
              Throwable.printStackTrace();
            }
          }
        }
      }
 catch (      Throwable Throwable) {
        Throwable.printStackTrace();
      }
      Chunk.chunkTileEntityMap=SavedTileEntityMap;
    }
  }
  for (  BlockRecord Record : PipesToInitialize) {
    try {
      Object Pipe=ModInteraction.BC_TileGenericPipe_pipe.get(Record.Entity);
      ModInteraction.BC_TileGenericPipe_initialize.invoke(Record.Entity,Pipe);
      Object Transport=ModInteraction.BC_Pipe_transport.get(Pipe);
      if (!ModInteraction.BC_PipeTransportItems.isInstance(Transport)) {
        continue;
      }
      ModInteraction.BC_PipeTransportItems_delay.set(Transport,-1);
      java.util.List DelayedEntities=(java.util.List)ModInteraction.BC_PipeTransportItems_delayedEntitiesToLoad.get(Transport);
      java.util.Map EntityMap=(java.util.Map)ModInteraction.BC_PipeTransportItems_travelingEntities.get(Transport);
      for (      Object Entity : DelayedEntities) {
        Object Item=ModInteraction.BC_EntityData_item.get(Entity);
        ModInteraction.BC_EntityPassiveItem_setWorld.invoke(Item,worldObj);
        int Id=(Integer)ModInteraction.BC_EntityPassiveItem_getEntityId.invoke(Item);
        EntityMap.put(Id,Entity);
        Object ItemPosition=ModInteraction.BC_EntityPassiveItem_position.get(Item);
        ShiftPipeItemPosition(ItemPosition);
      }
      DelayedEntities.clear();
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)worldObj.getTileEntity(DriveRecord.X,DriveRecord.Y,DriveRecord.Z);
    if (!DriveIsAnchored) {
      Drive.Active=true;
    }
    Drive.ToggleActivity();
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
  SneakyWorldUtil.RefreshBlock(worldObj,xCoord,yCoord,zCoord,RIMBlocks.Spectre,Blocks.air);
  for (  BlockRecord Record : Body) {
    SneakyWorldUtil.RefreshBlock(worldObj,Record.X,Record.Y,Record.Z,Blocks.air,Record.Id);
  }
  int PendingBlockUpdateCount=PendingBlockUpdates.tagCount();
  for (int Index=0; Index < PendingBlockUpdateCount; Index++) {
    ScheduleShiftedBlockUpdate((net.minecraft.nbt.NBTTagCompound)PendingBlockUpdates.getCompoundTagAt(Index));
  }
}","public void doRelease(){
  for (  BlockRecord Record : Body) {
    SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,Record.Id,Record.Meta);
  }
  BlockRecordList PipesToInitialize=new BlockRecordList();
  if (ModInteraction.ForgeMultipart.MultipartSaveLoad_loadingWorld_$eq != null) {
    try {
      ModInteraction.ForgeMultipart.MultipartSaveLoad_loadingWorld_$eq.invoke(null,worldObj);
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  BlockRecordList MultipartTilesToInitialize=new BlockRecordList();
  java.util.HashMap<net.minecraft.world.chunk.Chunk,java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>> MultipartTileSetsToPropagate=new java.util.HashMap<net.minecraft.world.chunk.Chunk,java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>>();
  for (  BlockRecord Record : Body) {
    if (Record.EntityRecord != null) {
      Record.EntityRecord.setInteger(""String_Node_Str"",Record.X);
      Record.EntityRecord.setInteger(""String_Node_Str"",Record.Y);
      Record.EntityRecord.setInteger(""String_Node_Str"",Record.Z);
      if (Record.EntityRecord.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        try {
          if (ModInteraction.ForgeMultipart.MultipartHelper_createTileFromNBT != null) {
            Record.Entity=(net.minecraft.tileentity.TileEntity)ModInteraction.ForgeMultipart.MultipartHelper_createTileFromNBT.invoke(null,worldObj,Record.EntityRecord);
          }
 else {
            Record.Entity=(net.minecraft.tileentity.TileEntity)ModInteraction.ForgeMultipart.TileMultipart_createFromNBT.invoke(null,Record.EntityRecord);
            MultipartContainerBlockId=Record.Id;
            net.minecraft.world.chunk.Chunk Chunk=worldObj.getChunkFromBlockCoords(Record.X,Record.Z);
            java.util.HashMap<Object,net.minecraft.tileentity.TileEntity> MultipartTilesToPropagate=MultipartTileSetsToPropagate.get(Chunk);
            if (MultipartTilesToPropagate == null) {
              MultipartTilesToPropagate=new java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>();
              MultipartTileSetsToPropagate.put(Chunk,MultipartTilesToPropagate);
            }
            MultipartTilesToPropagate.put(Record.Entity,Record.Entity);
          }
          MultipartTilesToInitialize.add(Record);
        }
 catch (        Throwable Throwable) {
          Throwable.printStackTrace();
          continue;
        }
      }
 else {
        Record.Entity=net.minecraft.tileentity.TileEntity.createAndLoadEntity(Record.EntityRecord);
      }
      SneakyWorldUtil.SetTileEntity(worldObj,Record.X,Record.Y,Record.Z,Record.Entity);
      if (Configuration.DirtyHacks.UpdateBuildcraftPipes) {
        if (ModInteraction.BC_TileGenericPipe != null) {
          if (ModInteraction.BC_TileGenericPipe.isInstance(Record.Entity)) {
            PipesToInitialize.add(Record);
          }
        }
      }
    }
  }
  for (  BlockRecord Record : MultipartTilesToInitialize) {
    try {
      ModInteraction.ForgeMultipart.TileMultipart_onChunkLoad.invoke(Record.Entity);
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  if (ModInteraction.ForgeMultipart.MultipartHelper_sendDescPacket != null) {
    for (    BlockRecord Record : MultipartTilesToInitialize) {
      try {
        ModInteraction.ForgeMultipart.MultipartHelper_sendDescPacket.invoke(null,worldObj,Record.Entity);
      }
 catch (      Throwable Throwable) {
        Throwable.printStackTrace();
      }
    }
  }
 else {
    for (    java.util.Map.Entry<net.minecraft.world.chunk.Chunk,java.util.HashMap<Object,net.minecraft.tileentity.TileEntity>> MultipartTilesToPropagate : MultipartTileSetsToPropagate.entrySet()) {
      net.minecraft.world.chunk.Chunk Chunk=MultipartTilesToPropagate.getKey();
      java.util.Map SavedTileEntityMap=Chunk.chunkTileEntityMap;
      Chunk.chunkTileEntityMap=MultipartTilesToPropagate.getValue();
      try {
        for (        net.minecraft.entity.player.EntityPlayerMP Player : ((java.util.List<net.minecraft.entity.player.EntityPlayerMP>)Reflection.get(Class.forName(""String_Node_Str""),Reflection.runMethod(WorldServer.class,(((WorldServer)worldObj).getPlayerManager()),""String_Node_Str"",Chunk.xPosition,Chunk.zPosition,false),""String_Node_Str""))) {
          if (!Player.loadedChunks.contains(Chunk.getChunkCoordIntPair())) {
            try {
              if (ModInteraction.ForgeMultipart.MultipartSaveLoad_loadingWorld_$eq == null) {
                MultipartPropagationPacket.Dispatch(Player,MultipartTilesToPropagate.getValue().values());
              }
              ModInteraction.ForgeMultipart.MultipartSPH_onChunkWatch.invoke(null,Player,Chunk);
            }
 catch (            Throwable Throwable) {
              Throwable.printStackTrace();
            }
          }
        }
      }
 catch (      Throwable Throwable) {
        Throwable.printStackTrace();
      }
      Chunk.chunkTileEntityMap=SavedTileEntityMap;
    }
  }
  for (  BlockRecord Record : PipesToInitialize) {
    try {
      Object Pipe=ModInteraction.BC_TileGenericPipe_pipe.get(Record.Entity);
      ModInteraction.BC_TileGenericPipe_initialize.invoke(Record.Entity,Pipe);
      Object Transport=ModInteraction.BC_Pipe_transport.get(Pipe);
      if (!ModInteraction.BC_PipeTransportItems.isInstance(Transport)) {
        continue;
      }
      ModInteraction.BC_PipeTransportItems_delay.set(Transport,-1);
      java.util.List DelayedEntities=(java.util.List)ModInteraction.BC_PipeTransportItems_delayedEntitiesToLoad.get(Transport);
      java.util.Map EntityMap=(java.util.Map)ModInteraction.BC_PipeTransportItems_travelingEntities.get(Transport);
      for (      Object Entity : DelayedEntities) {
        Object Item=ModInteraction.BC_EntityData_item.get(Entity);
        ModInteraction.BC_EntityPassiveItem_setWorld.invoke(Item,worldObj);
        int Id=(Integer)ModInteraction.BC_EntityPassiveItem_getEntityId.invoke(Item);
        EntityMap.put(Id,Entity);
        Object ItemPosition=ModInteraction.BC_EntityPassiveItem_position.get(Item);
        ShiftPipeItemPosition(ItemPosition);
      }
      DelayedEntities.clear();
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)worldObj.getTileEntity(DriveRecord.X,DriveRecord.Y,DriveRecord.Z);
    if (!DriveIsAnchored) {
      Drive.Active=true;
    }
    Drive.ToggleActivity();
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
  SneakyWorldUtil.RefreshBlock(worldObj,xCoord,yCoord,zCoord,RIMBlocks.Spectre,Blocks.air);
  for (  BlockRecord Record : Body) {
    SneakyWorldUtil.RefreshBlock(worldObj,Record.X,Record.Y,Record.Z,Blocks.air,Record.Id);
  }
  int PendingBlockUpdateCount=PendingBlockUpdates.tagCount();
  for (int Index=0; Index < PendingBlockUpdateCount; Index++) {
    ScheduleShiftedBlockUpdate((net.minecraft.nbt.NBTTagCompound)PendingBlockUpdates.getCompoundTagAt(Index));
  }
}",0.9964493679875016
22843,"public void Release(){
  Debug.dbg(""String_Node_Str"");
  for (  BlockRecord Record : Body)   ShiftBlockPosition(Record);
  doRelease();
}","public void Release(){
  for (  BlockRecord Record : Body)   ShiftBlockPosition(Record);
  doRelease();
}",0.8677685950413223
22844,"@Override public void Render(net.minecraft.tileentity.TileEntity TileEntity,float PartialTick){
  MotiveSpectreEntity Spectre=(MotiveSpectreEntity)TileEntity;
  if (Spectre.RenderCacheKey == null) {
    return;
  }
{
    double Offset;
    if (Configuration.CarriageMotion.RenderInFinalPositionDuringLag && (Spectre.TicksExisted >= Configuration.CarriageMotion.MotionDuration)) {
      Offset=1;
    }
 else {
      Offset=Spectre.Velocity * (Spectre.TicksExisted + PartialTick);
    }
    Render.Translate(Offset * Spectre.MotionDirection.DeltaX - Spectre.xCoord,Offset * Spectre.MotionDirection.DeltaY - Spectre.yCoord,Offset * Spectre.MotionDirection.DeltaZ - Spectre.zCoord);
  }
  Integer DisplayList=CarriageRenderCache.Lookup(Spectre.RenderCacheKey);
  if (DisplayList != null) {
    Debug.dbg(""String_Node_Str"");
    Render.ResetBoundTexture();
    Render.ExecuteDisplayList(DisplayList);
    Render.ResetBoundTexture();
  }
}","@Override public void Render(net.minecraft.tileentity.TileEntity TileEntity,float PartialTick){
  MotiveSpectreEntity Spectre=(MotiveSpectreEntity)TileEntity;
  if (Spectre.RenderCacheKey == null) {
    return;
  }
{
    double Offset;
    if (Configuration.CarriageMotion.RenderInFinalPositionDuringLag && (Spectre.TicksExisted >= Configuration.CarriageMotion.MotionDuration)) {
      Offset=1;
    }
 else {
      Offset=Spectre.Velocity * (Spectre.TicksExisted + PartialTick);
    }
    Render.Translate(Offset * Spectre.MotionDirection.DeltaX - Spectre.xCoord,Offset * Spectre.MotionDirection.DeltaY - Spectre.yCoord,Offset * Spectre.MotionDirection.DeltaZ - Spectre.zCoord);
  }
  Integer DisplayList=CarriageRenderCache.Lookup(Spectre.RenderCacheKey);
  if (DisplayList != null) {
    Render.ResetBoundTexture();
    Render.ExecuteDisplayList(DisplayList);
    Render.ResetBoundTexture();
  }
}",0.9814612868047984
22845,"@Override public CarriagePackage GeneratePackage(TileEntity carriage,Directions CarriageDirection,Directions MotionDirection) throws CarriageMotionException {
  if (MotionDirection == CarriageDirection) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  if (MotionDirection == CarriageDirection.Opposite()) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  CarriagePackage Package=new CarriagePackage(this,carriage,MotionDirection);
  MultiTypeCarriageUtil.fillPackage(Package,carriage);
  if (Package.Body.contains(Package.DriveRecord)) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  if (Package.Body.contains(Package.DriveRecord.NextInDirection(MotionDirection.Opposite()))) {
    throw (new CarriageObstructionException(""String_Node_Str"",xCoord,yCoord,zCoord));
  }
  Package.Finalize();
  return (Package);
}","@Override public CarriagePackage GeneratePackage(TileEntity carriage,Directions CarriageDirection,Directions MotionDirection) throws CarriageMotionException {
  if (MotionDirection == CarriageDirection) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  if (MotionDirection == CarriageDirection.Opposite()) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  CarriagePackage Package=new CarriagePackage(this,carriage,MotionDirection);
  MultiTypeCarriageUtil.fillPackage(Package,carriage);
  if (Package.Body.contains(Package.DriveRecord)) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  if (Package.Body.contains(Package.DriveRecord.NextInDirection(MotionDirection.Opposite()))) {
    throw (new CarriageObstructionException(""String_Node_Str"",xCoord,yCoord,zCoord));
  }
  Debug.dbg(""String_Node_Str"");
  Package.Finalize();
  return (Package);
}",0.9819004524886876
22846,"public static void dbg(Object o){
  if (Configuration.Debug.verbose)   log.debug(m,o);
}","public static void dbg(Object o){
  StackTraceElement[] trace=Thread.currentThread().getStackTrace();
  System.out.println(trace[2] + ""String_Node_Str"" + o);
}",0.437246963562753
22847,"public ReflectionObfuscated(){
  Debug.dbg(""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
}","public ReflectionObfuscated(){
  Debug.dbg(""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
  map(""String_Node_Str"",""String_Node_Str"");
}",0.9371428571428572
22848,"public Carriage(){
  super(Configuration.BlockIds.Carriage,wood,CarriageItem.class,HarvestToolTypes.Hatchet,FrameCarriageEntity.class,PlatformCarriageEntity.class,StructureCarriageEntity.class,SupportCarriageEntity.class,TemplateCarriageEntity.class);
}","public Carriage(){
  super((net.minecraft.block.Block)Block.blockRegistry.getObject(""String_Node_Str""),CarriageItem.class,HarvestToolTypes.Hatchet,FrameCarriageEntity.class,PlatformCarriageEntity.class,StructureCarriageEntity.class,SupportCarriageEntity.class,TemplateCarriageEntity.class);
}",0.8256880733944955
22849,"@Override public IIcon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageEntity Carriage=(CarriageEntity)World.getTileEntity(X,Y,Z);
    if ((Carriage.decorationId != null) && (Carriage.SideClosed[Side])) {
      return (Carriage.decorationId.getIcon(Side,Carriage.DecorationMeta));
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    return (Carriage.SideClosed[Side] ? Type.ClosedIcon : Type.OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.1509900990099009
22850,"@Override public IIcon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)World.getTileEntity(X,Y,Z);
    if (Drive.SideClosed[Side]) {
      return (InactiveIcon);
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    if (Drive.Continuous) {
      return (Drive.Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Drive.Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.1540372670807453
22851,"public void HandleNeighbourBlockChange(){
  Stale=false;
  CarriageDirection=null;
  boolean CarriageDirectionValid=true;
  SignalDirection=null;
  boolean SignalDirectionValid=true;
  for (  Directions Direction : Directions.values()) {
    int X=xCoord + Direction.DeltaX;
    int Y=yCoord + Direction.DeltaY;
    int Z=zCoord + Direction.DeltaZ;
    if (worldObj.isAirBlock(X,Y,Z)) {
      continue;
    }
    int Id=worldObj.getBlockId(X,Y,Z);
    if (Id == Blocks.Carriage.blockID) {
      if (SideClosed[Direction.ordinal()]) {
        continue;
      }
      if (CarriageDirection != null) {
        CarriageDirectionValid=false;
      }
 else {
        CarriageDirection=Direction;
      }
    }
 else     if (net.minecraft.block.Block.blocksList[Id].isProvidingWeakPower(worldObj,X,Y,Z,Direction.ordinal()) > 0) {
      if (SignalDirection != null) {
        SignalDirectionValid=false;
      }
 else {
        SignalDirection=Direction;
      }
    }
  }
  if (!CarriageDirectionValid) {
    CarriageDirection=null;
  }
  if (!SignalDirectionValid) {
    SignalDirection=null;
  }
}","public void HandleNeighbourBlockChange(){
  Stale=false;
  CarriageDirection=null;
  boolean CarriageDirectionValid=true;
  SignalDirection=null;
  boolean SignalDirectionValid=true;
  for (  Directions Direction : Directions.values()) {
    int X=xCoord + Direction.DeltaX;
    int Y=yCoord + Direction.DeltaY;
    int Z=zCoord + Direction.DeltaZ;
    if (worldObj.isAirBlock(X,Y,Z)) {
      continue;
    }
    Block Id=(net.minecraft.block.Block)worldObj.getBlock(X,Y,Z);
    if (Id == Blocks.Carriage) {
      if (SideClosed[Direction.ordinal()]) {
        continue;
      }
      if (CarriageDirection != null) {
        CarriageDirectionValid=false;
      }
 else {
        CarriageDirection=Direction;
      }
    }
 else     if (Id.isProvidingWeakPower(worldObj,X,Y,Z,Direction.ordinal()) > 0) {
      if (SignalDirection != null) {
        SignalDirectionValid=false;
      }
 else {
        SignalDirection=Direction;
      }
    }
  }
  if (!CarriageDirectionValid) {
    CarriageDirection=null;
  }
  if (!SignalDirectionValid) {
    SignalDirection=null;
  }
}",0.7454965357967668
22852,"@Override public void updateEntity(){
  if (worldObj.isRemote) {
    return;
  }
  if (Stale) {
    HandleNeighbourBlockChange();
  }
  if (CooldownRemaining > 0) {
    CooldownRemaining--;
    MarkServerRecordDirty();
    return;
  }
  if (Active) {
    return;
  }
  if (SignalDirection == null) {
    if (Signalled) {
      Signalled=false;
      MarkServerRecordDirty();
    }
    return;
  }
  if (CarriageDirection == null) {
    return;
  }
  if (Signalled) {
    if (!Continuous) {
      return;
    }
  }
 else {
    Signalled=true;
    MarkServerRecordDirty();
  }
  try {
    InitiateMotion(PreparePackage(SignalDirection.Opposite()));
  }
 catch (  CarriageMotionException Exception) {
    String Message=""String_Node_Str"" + xCoord + ""String_Node_Str""+ yCoord+ ""String_Node_Str""+ zCoord+ ""String_Node_Str""+ worldObj.provider.dimensionId+ ""String_Node_Str""+ Exception.getMessage();
    if (Exception instanceof CarriageObstructionException) {
      CarriageObstructionException ObstructionException=(CarriageObstructionException)Exception;
      Message+=""String_Node_Str"" + ObstructionException.X + ""String_Node_Str""+ ObstructionException.Y+ ""String_Node_Str""+ ObstructionException.Z+ ""String_Node_Str"";
    }
    if (Configuration.Debug.LogMotionExceptions) {
      Debug.Emit(Message);
    }
    if (this.lastUsingPlayer != null) {
      ChatMessageComponent chatMessage=new ChatMessageComponent();
      chatMessage.addText(Message);
      this.lastUsingPlayer.sendChatToPlayer(chatMessage);
    }
  }
}","@Override public void updateEntity(){
  if (worldObj.isRemote) {
    return;
  }
  if (Stale) {
    HandleNeighbourBlockChange();
  }
  if (CooldownRemaining > 0) {
    CooldownRemaining--;
    MarkServerRecordDirty();
    return;
  }
  if (Active) {
    return;
  }
  if (SignalDirection == null) {
    if (Signalled) {
      Signalled=false;
      MarkServerRecordDirty();
    }
    return;
  }
  if (CarriageDirection == null) {
    return;
  }
  if (Signalled) {
    if (!Continuous) {
      return;
    }
  }
 else {
    Signalled=true;
    MarkServerRecordDirty();
  }
  try {
    InitiateMotion(PreparePackage(SignalDirection.Opposite()));
  }
 catch (  CarriageMotionException Exception) {
    String Message=""String_Node_Str"" + xCoord + ""String_Node_Str""+ yCoord+ ""String_Node_Str""+ zCoord+ ""String_Node_Str""+ worldObj.provider.dimensionId+ ""String_Node_Str""+ Exception.getMessage();
    if (Exception instanceof CarriageObstructionException) {
      CarriageObstructionException ObstructionException=(CarriageObstructionException)Exception;
      Message+=""String_Node_Str"" + ObstructionException.X + ""String_Node_Str""+ ObstructionException.Y+ ""String_Node_Str""+ ObstructionException.Z+ ""String_Node_Str"";
    }
    if (Configuration.Debug.LogMotionExceptions) {
      Debug.Emit(Message);
    }
    if (this.lastUsingPlayer != null) {
      IChatComponent chatMessage=new ChatComponentText(Message);
      this.lastUsingPlayer.addChatComponentMessage(chatMessage);
    }
  }
}",0.9257903494176372
22853,"public CarriagePackage PreparePackage(Directions MotionDirection) throws CarriageMotionException {
  CarriageEntity Carriage=(CarriageEntity)worldObj.getBlockTileEntity(xCoord + CarriageDirection.DeltaX,yCoord + CarriageDirection.DeltaY,zCoord + CarriageDirection.DeltaZ);
  CarriagePackage Package=GeneratePackage(Carriage,CarriageDirection,MotionDirection);
  if (Configuration.HardmodeActive) {
    int Type=worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
{
      double MaxBurden=CarriageDrive.Types.values()[Type].MaxBurden * CarriageDrive.Tiers.values()[Tier].MaxBurdenFactor;
      if (Package.Mass > MaxBurden) {
        throw (new CarriageMotionException(""String_Node_Str"" + ((int)(Package.Mass - MaxBurden)) + ""String_Node_Str""));
      }
    }
    double EnergyRequired=Package.Mass * CarriageDrive.Types.values()[Type].EnergyConsumption * CarriageDrive.Tiers.values()[Tier].EnergyConsumptionFactor;
    int powerConsumed=(int)Math.ceil(EnergyRequired * Configuration.PowerConsumptionFactor);
    if (powerConsumed > this.energyStored) {
      throw (new CarriageMotionException(""String_Node_Str"" + energyStored + ""String_Node_Str""+ powerConsumed));
    }
 else {
      this.energyStored-=powerConsumed;
    }
  }
  return (Package);
}","public CarriagePackage PreparePackage(Directions MotionDirection) throws CarriageMotionException {
  CarriageEntity Carriage=(CarriageEntity)worldObj.getTileEntity(xCoord + CarriageDirection.DeltaX,yCoord + CarriageDirection.DeltaY,zCoord + CarriageDirection.DeltaZ);
  CarriagePackage Package=GeneratePackage(Carriage,CarriageDirection,MotionDirection);
  if (Configuration.HardmodeActive) {
    int Type=worldObj.getBlockMetadata(xCoord,yCoord,zCoord);
{
      double MaxBurden=CarriageDrive.Types.values()[Type].MaxBurden * CarriageDrive.Tiers.values()[Tier].MaxBurdenFactor;
      if (Package.Mass > MaxBurden) {
        throw (new CarriageMotionException(""String_Node_Str"" + ((int)(Package.Mass - MaxBurden)) + ""String_Node_Str""));
      }
    }
    double EnergyRequired=Package.Mass * CarriageDrive.Types.values()[Type].EnergyConsumption * CarriageDrive.Tiers.values()[Tier].EnergyConsumptionFactor;
    int powerConsumed=(int)Math.ceil(EnergyRequired * Configuration.PowerConsumptionFactor);
    if (powerConsumed > this.energyStored) {
      throw (new CarriageMotionException(""String_Node_Str"" + energyStored + ""String_Node_Str""+ powerConsumed));
    }
 else {
      this.energyStored-=powerConsumed;
    }
  }
  return (Package);
}",0.9979911611088792
22854,"public void EstablishPlaceholders(CarriagePackage Package){
  for (  BlockRecord Record : Package.Body) {
    if (Package.NewPositions.contains(Record)) {
      SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,Blocks.Spectre.blockID,Spectre.Types.Supportive.ordinal());
    }
 else {
      SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,0,0);
    }
  }
}","public void EstablishPlaceholders(CarriagePackage Package){
  for (  BlockRecord Record : Package.Body) {
    if (Package.NewPositions.contains(Record)) {
      SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,Blocks.Spectre,Spectre.Types.Supportive.ordinal());
    }
 else {
      SneakyWorldUtil.SetBlock(worldObj,Record.X,Record.Y,Record.Z,null,0);
    }
  }
}",0.9801324503311258
22855,"public void WriteCommonRecord(net.minecraft.nbt.NBTTagCompound TagCompound){
  for (int Index=0; Index < SideClosed.length; Index++) {
    TagCompound.setBoolean(""String_Node_Str"" + Index,SideClosed[Index]);
  }
  TagCompound.setInteger(""String_Node_Str"",DecorationId);
  TagCompound.setInteger(""String_Node_Str"",DecorationMeta);
  TagCompound.setInteger(""String_Node_Str"",Tier);
}","public void WriteCommonRecord(net.minecraft.nbt.NBTTagCompound TagCompound){
  for (int Index=0; Index < SideClosed.length; Index++) {
    TagCompound.setBoolean(""String_Node_Str"" + Index,SideClosed[Index]);
  }
  TagCompound.setInteger(""String_Node_Str"",Block.blockRegistry.getIDForObject(decorationId));
  TagCompound.setInteger(""String_Node_Str"",DecorationMeta);
  TagCompound.setInteger(""String_Node_Str"",Tier);
}",0.9273182957393484
22856,"@Override public void EmitDrops(Block Block,int Meta){
  EmitDrop(Block,CarriageItem.Stack(Meta,Tier,DecorationId,DecorationMeta));
}","@Override public void EmitDrops(Block Block,int Meta){
  EmitDrop(Block,CarriageItem.Stack(Meta,Tier,decorationId,DecorationMeta));
}",0.9924812030075189
22857,"@Override public void Setup(net.minecraft.entity.player.EntityPlayer Player,net.minecraft.item.ItemStack Item){
  DecorationId=CarriageItem.GetDecorationId(Item);
  DecorationMeta=CarriageItem.GetDecorationMeta(Item);
  Tier=CarriageItem.GetTier(Item);
}","@Override public void Setup(net.minecraft.entity.player.EntityPlayer Player,net.minecraft.item.ItemStack Item){
  decorationId=CarriageItem.GetDecorationId(Item);
  DecorationMeta=CarriageItem.GetDecorationMeta(Item);
  Tier=CarriageItem.GetTier(Item);
}",0.9960629921259844
22858,"@Override public void ReadCommonRecord(net.minecraft.nbt.NBTTagCompound TagCompound){
  for (int Index=0; Index < SideClosed.length; Index++) {
    SideClosed[Index]=TagCompound.getBoolean(""String_Node_Str"" + Index);
  }
  DecorationId=TagCompound.getInteger(""String_Node_Str"");
  DecorationMeta=TagCompound.getInteger(""String_Node_Str"");
  Tier=TagCompound.getInteger(""String_Node_Str"");
}","@Override public void ReadCommonRecord(net.minecraft.nbt.NBTTagCompound TagCompound){
  for (int Index=0; Index < SideClosed.length; Index++) {
    SideClosed[Index]=TagCompound.getBoolean(""String_Node_Str"" + Index);
  }
  decorationId=(net.minecraft.block.Block)Block.blockRegistry.getObjectById(TagCompound.getInteger(""String_Node_Str""));
  DecorationMeta=TagCompound.getInteger(""String_Node_Str"");
  Tier=TagCompound.getInteger(""String_Node_Str"");
}",0.7695961995249406
22859,"public static net.minecraft.item.ItemStack Stack(int Type,int Tier,int DecorationId,int DecorationMeta){
  net.minecraft.item.ItemStack Item=Stack.Tag(Stack.New(Blocks.Carriage,Type));
  Item.stackTagCompound.setInteger(""String_Node_Str"",DecorationId);
  Item.stackTagCompound.setInteger(""String_Node_Str"",DecorationMeta);
  Item.stackTagCompound.setInteger(""String_Node_Str"",Tier);
  return (Item);
}","public static net.minecraft.item.ItemStack Stack(int Type,int Tier,Block decorationId,int DecorationMeta){
  net.minecraft.item.ItemStack Item=Stack.Tag(Stack.New(Blocks.Carriage,Type));
  if (decorationId != null) {
    Item.stackTagCompound.setInteger(""String_Node_Str"",Block.blockRegistry.getIDForObject(decorationId));
  }
 else {
    Item.stackTagCompound.setInteger(""String_Node_Str"",0);
  }
  Item.stackTagCompound.setInteger(""String_Node_Str"",DecorationMeta);
  Item.stackTagCompound.setInteger(""String_Node_Str"",Tier);
  return (Item);
}",0.2238648363252376
22860,"public void Finalize() throws CarriageMotionException {
  for (  BlockRecord PotentialObstruction : PotentialObstructions) {
    AssertNotObstruction(PotentialObstruction);
  }
  long WorldTime=World.getWorldInfo().getWorldTotalTime();
  try {
    java.util.Iterator PendingBlockUpdateSetIterator=World.pendingTickListEntriesTreeSet.iterator();
    while (PendingBlockUpdateSetIterator.hasNext()) {
      net.minecraft.world.NextTickListEntry PendingBlockUpdate=(net.minecraft.world.NextTickListEntry)PendingBlockUpdateSetIterator.next();
      if (Body.contains(new BlockRecord(PendingBlockUpdate.xCoord,PendingBlockUpdate.yCoord,PendingBlockUpdate.zCoord))) {
        PendingBlockUpdateSetIterator.remove();
        World.pendingTickListEntriesHashSet.remove(PendingBlockUpdate);
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
      }
    }
  }
 catch (  Throwable VanillaThrowable) {
    if (VanillaThrowable instanceof ThreadDeath) {
      throw ((ThreadDeath)VanillaThrowable);
    }
    try {
      java.util.Set PendingBlockUpdateSet=(java.util.Set)ModInteraction.PendingBlockUpdateSetField.get(World);
      while (true) {
        net.minecraft.world.NextTickListEntry PendingBlockUpdate=null;
        for (        Object Target : PendingBlockUpdateSet) {
          net.minecraft.world.NextTickListEntry TargetPendingBlockUpdate=(net.minecraft.world.NextTickListEntry)Target;
          if (Body.contains(new BlockRecord(TargetPendingBlockUpdate.xCoord,TargetPendingBlockUpdate.yCoord,TargetPendingBlockUpdate.zCoord))) {
            PendingBlockUpdate=TargetPendingBlockUpdate;
            break;
          }
        }
        if (PendingBlockUpdate == null) {
          break;
        }
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
        ModInteraction.RemovePendingBlockUpdate.invoke(World,PendingBlockUpdate);
      }
    }
 catch (    Throwable McpcThrowable) {
      McpcThrowable.printStackTrace();
      VanillaThrowable.printStackTrace();
    }
  }
  if (Configuration.HardmodeActive) {
    for (    BlockRecord CarriageRecord : Carriages) {
      int Tier=((CarriageEntity)CarriageRecord.Entity).Tier;
      double Factor=Carriage.Tiers.values()[Tier].CargoBurdenFactor;
      if (Tier == 0) {
        for (        Directions Direction : Directions.values()) {
          BlockRecord Position=CarriageRecord.NextInDirection(Direction);
          ApplyCargoBurdenFactor(Position,Factor);
        }
      }
 else {
        for (int Distance=1; Distance <= Tier; Distance++, Factor=Math.sqrt(Factor)) {
          int MinX=CarriageRecord.X - Distance;
          int MinY=CarriageRecord.Y - Distance;
          int MinZ=CarriageRecord.Z - Distance;
          int MaxX=CarriageRecord.X + Distance;
          int MaxY=CarriageRecord.Y + Distance;
          int MaxZ=CarriageRecord.Z + Distance;
          for (int X=MinX; X <= MaxX; X++) {
            for (int Y=MinY; Y <= MaxY; Y++) {
              for (int Z=MinZ; Z <= MaxZ; Z++) {
                if ((X == MinX) || (X == MaxX) || (Y == MinY)|| (Y == MaxY)|| (Z == MinZ)|| (Z == MaxZ)) {
                  ApplyCargoBurdenFactor(new BlockRecord(X,Y,Z),Factor);
                }
              }
            }
          }
        }
      }
    }
    for (    BlockRecord CargoRecord : Cargo) {
      Double BurdenFactor=CargoBurdenFactors.get(CargoRecord);
      double Burden=GetBaseBurden(CargoRecord);
      if (BurdenFactor == null) {
        Mass+=Burden;
      }
 else {
        Mass+=Burden * BurdenFactor;
      }
    }
  }
  PotentialObstructions=null;
  Carriages=null;
  Cargo=null;
  CargoBurdenFactors=null;
}","public void Finalize() throws CarriageMotionException {
  for (  BlockRecord PotentialObstruction : PotentialObstructions) {
    AssertNotObstruction(PotentialObstruction);
  }
  long WorldTime=World.getWorldInfo().getWorldTotalTime();
  try {
    java.util.Iterator PendingBlockUpdateSetIterator=((TreeSet<BlockRecord>)Reflection.stealField(""String_Node_Str"",World)).iterator();
    while (PendingBlockUpdateSetIterator.hasNext()) {
      net.minecraft.world.NextTickListEntry PendingBlockUpdate=(net.minecraft.world.NextTickListEntry)PendingBlockUpdateSetIterator.next();
      if (Body.contains(new BlockRecord(PendingBlockUpdate.xCoord,PendingBlockUpdate.yCoord,PendingBlockUpdate.zCoord))) {
        PendingBlockUpdateSetIterator.remove();
        ((HashSet<BlockRecord>)Reflection.stealField(""String_Node_Str"",World)).remove(PendingBlockUpdate);
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
      }
    }
  }
 catch (  Throwable VanillaThrowable) {
    if (VanillaThrowable instanceof ThreadDeath) {
      throw ((ThreadDeath)VanillaThrowable);
    }
    try {
      java.util.Set PendingBlockUpdateSet=(java.util.Set)ModInteraction.PendingBlockUpdateSetField.get(World);
      while (true) {
        net.minecraft.world.NextTickListEntry PendingBlockUpdate=null;
        for (        Object Target : PendingBlockUpdateSet) {
          net.minecraft.world.NextTickListEntry TargetPendingBlockUpdate=(net.minecraft.world.NextTickListEntry)Target;
          if (Body.contains(new BlockRecord(TargetPendingBlockUpdate.xCoord,TargetPendingBlockUpdate.yCoord,TargetPendingBlockUpdate.zCoord))) {
            PendingBlockUpdate=TargetPendingBlockUpdate;
            break;
          }
        }
        if (PendingBlockUpdate == null) {
          break;
        }
        StorePendingBlockUpdateRecord(PendingBlockUpdate,WorldTime);
        ModInteraction.RemovePendingBlockUpdate.invoke(World,PendingBlockUpdate);
      }
    }
 catch (    Throwable McpcThrowable) {
      McpcThrowable.printStackTrace();
      VanillaThrowable.printStackTrace();
    }
  }
  if (Configuration.HardmodeActive) {
    for (    BlockRecord CarriageRecord : Carriages) {
      int Tier=((CarriageEntity)CarriageRecord.Entity).Tier;
      double Factor=Carriage.Tiers.values()[Tier].CargoBurdenFactor;
      if (Tier == 0) {
        for (        Directions Direction : Directions.values()) {
          BlockRecord Position=CarriageRecord.NextInDirection(Direction);
          ApplyCargoBurdenFactor(Position,Factor);
        }
      }
 else {
        for (int Distance=1; Distance <= Tier; Distance++, Factor=Math.sqrt(Factor)) {
          int MinX=CarriageRecord.X - Distance;
          int MinY=CarriageRecord.Y - Distance;
          int MinZ=CarriageRecord.Z - Distance;
          int MaxX=CarriageRecord.X + Distance;
          int MaxY=CarriageRecord.Y + Distance;
          int MaxZ=CarriageRecord.Z + Distance;
          for (int X=MinX; X <= MaxX; X++) {
            for (int Y=MinY; Y <= MaxY; Y++) {
              for (int Z=MinZ; Z <= MaxZ; Z++) {
                if ((X == MinX) || (X == MaxX) || (Y == MinY)|| (Y == MaxY)|| (Z == MinZ)|| (Z == MaxZ)) {
                  ApplyCargoBurdenFactor(new BlockRecord(X,Y,Z),Factor);
                }
              }
            }
          }
        }
      }
    }
    for (    BlockRecord CargoRecord : Cargo) {
      Double BurdenFactor=CargoBurdenFactors.get(CargoRecord);
      double Burden=GetBaseBurden(CargoRecord);
      if (BurdenFactor == null) {
        Mass+=Burden;
      }
 else {
        Mass+=Burden * BurdenFactor;
      }
    }
  }
  PotentialObstructions=null;
  Carriages=null;
  Cargo=null;
  CargoBurdenFactors=null;
}",0.9746455834242094
22861,"public void StorePendingBlockUpdateRecord(net.minecraft.world.NextTickListEntry PendingBlockUpdate,long WorldTime){
  net.minecraft.nbt.NBTTagCompound PendingBlockUpdateRecord=new net.minecraft.nbt.NBTTagCompound();
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.xCoord);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.yCoord);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.zCoord);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.blockID);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",(int)(PendingBlockUpdate.scheduledTime - WorldTime));
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.priority);
  PendingBlockUpdates.appendTag(PendingBlockUpdateRecord);
}","public void StorePendingBlockUpdateRecord(net.minecraft.world.NextTickListEntry PendingBlockUpdate,long WorldTime){
  net.minecraft.nbt.NBTTagCompound PendingBlockUpdateRecord=new net.minecraft.nbt.NBTTagCompound();
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.xCoord);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.yCoord);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.zCoord);
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",Block.getIdFromBlock(PendingBlockUpdate.func_151351_a()));
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",(int)(PendingBlockUpdate.scheduledTime - WorldTime));
  PendingBlockUpdateRecord.setInteger(""String_Node_Str"",PendingBlockUpdate.priority);
  PendingBlockUpdates.appendTag(PendingBlockUpdateRecord);
}",0.9514563106796116
22862,"public void AssertNotObstruction(BlockRecord Record) throws CarriageMotionException {
  if (Body.contains(Record)) {
    return;
  }
  if (World.isAirBlock(Record.X,Record.Y,Record.Z)) {
    return;
  }
  if (((Material)Reflection.stealField(""String_Node_Str"",World.getBlock(Record.X,Record.Y,Record.Z))).isLiquid()) {
    if (ObstructedByLiquids) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  if (!((net.minecraft.block.BlockFlowing)net.minecraft.block.Block.waterMoving).blockBlocksFlow(World,Record.X,Record.Y,Record.Z)) {
    if (ObstructedByFragileBlocks) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  FailBecauseObstructed(Record,""String_Node_Str"");
}","public void AssertNotObstruction(BlockRecord Record) throws CarriageMotionException {
  if (Body.contains(Record)) {
    return;
  }
  if (World.isAirBlock(Record.X,Record.Y,Record.Z)) {
    return;
  }
  if (((Material)Reflection.stealField(""String_Node_Str"",World.getBlock(Record.X,Record.Y,Record.Z))).isLiquid()) {
    if (ObstructedByLiquids) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  if (!World.getBlock(Record.X,Record.Y,Record.Z).canBeReplacedByLeaves(World,Record.X,Record.Y,Record.Z)) {
    if (ObstructedByFragileBlocks) {
      FailBecauseObstructed(Record,""String_Node_Str"");
    }
    return;
  }
  FailBecauseObstructed(Record,""String_Node_Str"");
}",0.8999300209937019
22863,"@Override public IIcon GetIcon(net.minecraft.item.ItemStack Item,Directions Side){
  if (Side != Directions.PosY) {
    int DecorationId=CarriageItem.GetDecorationId(Item);
    if (DecorationId != 0) {
      int DecorationMeta=CarriageItem.GetDecorationMeta(Item);
      try {
        return (Block.Get(DecorationId).getIcon(Side.ordinal(),DecorationMeta));
      }
 catch (      Throwable Throwable) {
        Throwable.printStackTrace();
      }
    }
  }
  return (Blocks.Carriage.getIcon(0,BlockItem.GetBlockType(Item)));
}","@Override public IIcon GetIcon(net.minecraft.item.ItemStack Item,Directions Side){
  if (Side != Directions.PosY) {
    if (DecorationId != null) {
      int DecorationMeta=CarriageItem.GetDecorationMeta(Item);
      try {
        return (Block.Get(DecorationId).getIcon(Side.ordinal(),DecorationMeta));
      }
 catch (      Throwable Throwable) {
        Throwable.printStackTrace();
      }
    }
  }
  return (Blocks.Carriage.getIcon(0,BlockItem.GetBlockType(Item)));
}",0.938
22864,"public static net.minecraft.util.Icon RegisterIcon(net.minecraft.client.renderer.texture.IconRegister IconRegister,String Handle){
  return (IconRegister.registerIcon(Mod.Handle + ""String_Node_Str"" + TexturePrefix+ Handle));
}","public static IIcon RegisterIcon(IIconRegister IconRegister,String Handle){
  return (IconRegister.registerIcon(Mod.Handle + ""String_Node_Str"" + TexturePrefix+ Handle));
}",0.8513853904282116
22865,"public static void SetBlock(net.minecraft.world.World World,int X,int Y,int Z,int Id,int Meta){
  net.minecraft.world.chunk.Chunk Chunk=World.getChunkFromBlockCoords(X,Z);
  int ChunkX=X & 0xF;
  int ChunkY=Y & 0xF;
  int ChunkZ=Z & 0xF;
  Chunk.removeChunkBlockTileEntity(ChunkX,Y,ChunkZ);
  int LayerY=Y >> 4;
  if (Chunk.storageArrays[LayerY] == null) {
    Chunk.storageArrays[LayerY]=new net.minecraft.world.chunk.storage.ExtendedBlockStorage((LayerY) << 4,!World.provider.hasNoSky);
  }
  Chunk.storageArrays[LayerY].setExtBlockID(ChunkX,ChunkY,ChunkZ,Id);
  Chunk.storageArrays[LayerY].setExtBlockMetadata(ChunkX,ChunkY,ChunkZ,Meta);
  Chunk.isModified=true;
  World.markBlockForUpdate(X,Y,Z);
}","public static void SetBlock(net.minecraft.world.World World,int X,int Y,int Z,Block spectre,int Meta){
  net.minecraft.world.chunk.Chunk Chunk=World.getChunkFromBlockCoords(X,Z);
  int ChunkX=X & 0xF;
  int ChunkY=Y & 0xF;
  int ChunkZ=Z & 0xF;
  Chunk.removeTileEntity(ChunkX,Y,ChunkZ);
  int LayerY=Y >> 4;
  ExtendedBlockStorage[] storageArrays=(ExtendedBlockStorage[])Reflection.stealField(""String_Node_Str"",Chunk);
  if (storageArrays[LayerY] == null) {
    storageArrays[LayerY]=new net.minecraft.world.chunk.storage.ExtendedBlockStorage((LayerY) << 4,!World.provider.hasNoSky);
  }
  storageArrays[LayerY].func_150818_a(ChunkX,ChunkY,ChunkZ,spectre);
  storageArrays[LayerY].setExtBlockMetadata(ChunkX,ChunkY,ChunkZ,Meta);
  Chunk.isModified=true;
  World.markBlockForUpdate(X,Y,Z);
}",0.797052913596785
22866,"public Block(int Id,net.minecraft.block.Block Template,Class<? extends BlockItem> BlockItemClass,String HarvestToolType,Class<? extends TileEntity>... TileEntityClasses){
  this(Id,Template,BlockItemClass,TileEntityClasses);
  net.minecraftforge.common.MinecraftForge.setBlockHarvestLevel(this,HarvestToolType,0);
  setCreativeTab(CreativeTab.Instance);
}","public Block(net.minecraft.block.Block Template,Class<? extends BlockItem> BlockItemClass,String HarvestToolType,Class<? extends TileEntity>... TileEntityClasses){
  this(Template,BlockItemClass,TileEntityClasses);
  setCreativeTab(CreativeTab.Instance);
}",0.8379705400981997
22867,"@Override public void onBlockPlacedBy(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.EntityLivingBase Entity,net.minecraft.item.ItemStack Item){
  super.onBlockPlacedBy(World,X,Y,Z,Entity,Item);
  try {
    ((TileEntity)World.getBlockTileEntity(X,Y,Z)).Setup((net.minecraft.entity.player.EntityPlayer)Entity,Item);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}","@Override public void onBlockPlacedBy(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.EntityLivingBase Entity,net.minecraft.item.ItemStack Item){
  super.onBlockPlacedBy(World,X,Y,Z,Entity,Item);
  try {
    ((TileEntity)World.getTileEntity(X,Y,Z)).Setup((net.minecraft.entity.player.EntityPlayer)Entity,Item);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}",0.993924665856622
22868,"@Override public void getSubBlocks(int Id,net.minecraft.creativetab.CreativeTabs CreativeTab,java.util.List Showcase){
  AddShowcaseStacks(Showcase);
}","@Override public void getSubBlocks(net.minecraft.creativetab.CreativeTabs CreativeTab,java.util.List Showcase){
  AddShowcaseStacks(Showcase);
}",0.976271186440678
22869,"public BlockItem(int Id){
  super(Id);
  setHasSubtypes(true);
}","public BlockItem(Block Id){
  super(Id);
  setHasSubtypes(true);
}",0.9384615384615383
22870,"public static BlockRecord Identified(TileEntity Anchor,int X,int Y,int Z){
  BlockRecord Record=new BlockRecord(X,Y,Z);
  Record.Identify(Anchor.worldObj);
  return (Record);
}","public static BlockRecord Identified(TileEntity Anchor,int X,int Y,int Z){
  BlockRecord Record=new BlockRecord(X,Y,Z);
  Record.Identify(Anchor.getWorldObj());
  return (Record);
}",0.9803921568627452
22871,"public void Identify(net.minecraft.world.World World){
  this.World=World;
  Id=World.getBlockId(X,Y,Z);
  Meta=World.getBlockMetadata(X,Y,Z);
  Entity=World.getBlockTileEntity(X,Y,Z);
}","public void Identify(net.minecraft.world.World World){
  this.World=World;
  block=World.getBlock(X,Y,Z);
  Meta=World.getBlockMetadata(X,Y,Z);
  Entity=World.getTileEntity(X,Y,Z);
}",0.9619565217391304
22872,"@Override public boolean renderWorldBlock(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,net.minecraft.block.Block Block,int RenderId,net.minecraft.client.renderer.RenderBlocks RenderBlocks){
  this.X=X;
  this.Y=Y;
  this.Z=Z;
  Brightness=Block.getMixedBrightnessForBlock(World,X,Y,Z);
  RenderBlocks.setRenderBounds(0,0,0,1,1,1);
  RenderBlocks.renderStandardBlock(Block,X,Y,Z);
  Render(World.getBlockTileEntity(X,Y,Z));
  return (true);
}","@Override public boolean renderWorldBlock(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,net.minecraft.block.Block Block,int RenderId,net.minecraft.client.renderer.RenderBlocks RenderBlocks){
  this.X=X;
  this.Y=Y;
  this.Z=Z;
  Brightness=Block.getMixedBrightnessForBlock(World,X,Y,Z);
  RenderBlocks.setRenderBounds(0,0,0,1,1,1);
  RenderBlocks.renderStandardBlock(Block,X,Y,Z);
  Render(World.getTileEntity(X,Y,Z));
  return (true);
}",0.9944506104328524
22873,"public int Initialize(int BlockId){
  RenderId=cpw.mods.fml.client.registry.RenderingRegistry.getNextAvailableRenderId();
  cpw.mods.fml.client.registry.RenderingRegistry.registerBlockHandler(this);
  net.minecraftforge.client.MinecraftForgeClient.registerItemRenderer(BlockId,this);
  return (RenderId);
}","public int Initialize(Block block){
  RenderId=cpw.mods.fml.client.registry.RenderingRegistry.getNextAvailableRenderId();
  cpw.mods.fml.client.registry.RenderingRegistry.registerBlockHandler(this);
  net.minecraftforge.client.MinecraftForgeClient.registerItemRenderer(new ItemBlock(block),this);
  return (RenderId);
}",0.9536
22874,"@Override public boolean shouldRender3DInInventory(){
  return (true);
}","@Override public boolean shouldRender3DInInventory(int id){
  return (true);
}",0.96
22875,"public void SetTextureSpan(net.minecraft.util.Icon Texture){
  TextureMinU=Texture.getInterpolatedU(0);
  TextureMinV=Texture.getInterpolatedV(0);
  TextureMaxU=Texture.getInterpolatedU(16);
  TextureMaxV=Texture.getInterpolatedV(16);
}","public void SetTextureSpan(IIcon Texture){
  TextureMinU=Texture.getInterpolatedU(0);
  TextureMinV=Texture.getInterpolatedV(0);
  TextureMaxU=Texture.getInterpolatedU(16);
  TextureMaxV=Texture.getInterpolatedV(16);
}",0.9559471365638766
22876,"public abstract net.minecraft.util.Icon GetIcon(net.minecraft.item.ItemStack Item,Directions Side);","public abstract IIcon GetIcon(net.minecraft.item.ItemStack Item,Directions Side);",0.8888888888888888
22877,"@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    ((CarriageEntity)World.getBlockTileEntity(X,Y,Z)).ToggleSide(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}","@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    ((CarriageEntity)World.getTileEntity(X,Y,Z)).ToggleSide(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}",0.9954421148587056
22878,"@Override public net.minecraft.util.Icon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageEntity Carriage=(CarriageEntity)World.getBlockTileEntity(X,Y,Z);
    if ((Carriage.DecorationId != 0) && (Carriage.SideClosed[Side])) {
      return (net.minecraft.block.Block.blocksList[Carriage.DecorationId].getIcon(Side,Carriage.DecorationMeta));
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    return (Carriage.SideClosed[Side] ? Type.ClosedIcon : Type.OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageEntity Carriage=(CarriageEntity)World.getTileEntity(X,Y,Z);
    if ((Carriage.DecorationId != 0) && (Carriage.SideClosed[Side])) {
      return (net.minecraft.block.Block.blocksList[Carriage.DecorationId].getIcon(Side,Carriage.DecorationMeta));
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    return (Carriage.SideClosed[Side] ? Type.ClosedIcon : Type.OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9369649805447472
22879,"@Override public net.minecraft.util.Icon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9563318777292577
22880,"@Override public void onNeighborBlockChange(net.minecraft.world.World World,int X,int Y,int Z,int Id){
  try {
    ((CarriageDriveEntity)World.getBlockTileEntity(X,Y,Z)).HandleNeighbourBlockChange();
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}","@Override public void onNeighborBlockChange(net.minecraft.world.World World,int X,int Y,int Z,int Id){
  try {
    ((CarriageDriveEntity)World.getTileEntity(X,Y,Z)).HandleNeighbourBlockChange();
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}",0.9908256880733946
22881,"@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    CarriageDriveEntity cde=(CarriageDriveEntity)World.getBlockTileEntity(X,Y,Z);
    cde.lastUsingPlayer=Player;
    System.out.println(""String_Node_Str"");
    cde.HandleToolUsage(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}","@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    CarriageDriveEntity cde=(CarriageDriveEntity)World.getTileEntity(X,Y,Z);
    cde.lastUsingPlayer=Player;
    System.out.println(""String_Node_Str"");
    cde.HandleToolUsage(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}",0.6275395033860045
22882,"@Override public net.minecraft.util.Icon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)World.getBlockTileEntity(X,Y,Z);
    if (Drive.SideClosed[Side]) {
      return (InactiveIcon);
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    if (Drive.Continuous) {
      return (Drive.Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Drive.Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)World.getTileEntity(X,Y,Z);
    if (Drive.SideClosed[Side]) {
      return (InactiveIcon);
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    if (Drive.Continuous) {
      return (Drive.Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Drive.Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.980330448465775
22883,"@Override public net.minecraft.util.Icon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9494949494949496
22884,"@Override public net.minecraft.util.Icon GetIcon(net.minecraft.item.ItemStack Item,Directions Side){
  return (Blocks.CarriageDrive.getIcon(0,BlockItem.GetBlockType(Item)));
}","@Override public IIcon GetIcon(net.minecraft.item.ItemStack Item,Directions Side){
  return (Blocks.CarriageDrive.getIcon(0,BlockItem.GetBlockType(Item)));
}",0.9397590361445785
22885,"@Override public net.minecraft.item.ItemStack Process(net.minecraft.inventory.InventoryCrafting Inventory){
  net.minecraft.item.ItemStack Carriage=null;
  net.minecraft.item.ItemStack Decoration=null;
  int InventorySize=Inventory.getSizeInventory();
  for (int Index=0; Index < InventorySize; Index++) {
    net.minecraft.item.ItemStack Item=Inventory.getStackInSlot(Index);
    if (Item == null) {
      continue;
    }
    if (Item.itemID == Blocks.Carriage.blockID) {
      if (Carriage != null) {
        return (null);
      }
      Carriage=Item;
      continue;
    }
    if (Decoration != null) {
      return (null);
    }
    Decoration=Item;
  }
  if (Carriage == null) {
    return (null);
  }
  int Tier=CarriageItem.GetTier(Carriage);
  int DecorationId=CarriageItem.GetDecorationId(Carriage);
  if (DecorationId == 0) {
    if (Decoration == null) {
      return (null);
    }
    if (!(Decoration.getItem() instanceof net.minecraft.item.ItemBlock)) {
      return (null);
    }
    DecorationId=Decoration.itemID;
    int DecorationMeta=Decoration.getItem().getMetadata(Decoration.getItemDamage());
    return (CarriageItem.Stack(Carriage.getItemDamage(),Tier,DecorationId,DecorationMeta));
  }
  if (Decoration != null) {
    return (null);
  }
  return (CarriageItem.Stack(BlockItem.GetBlockType(Carriage),Tier));
}","@Override public net.minecraft.item.ItemStack Process(net.minecraft.inventory.InventoryCrafting Inventory){
  net.minecraft.item.ItemStack Carriage=null;
  net.minecraft.item.ItemStack Decoration=null;
  int InventorySize=Inventory.getSizeInventory();
  for (int Index=0; Index < InventorySize; Index++) {
    net.minecraft.item.ItemStack Item=Inventory.getStackInSlot(Index);
    if (Item == null) {
      continue;
    }
    if (Item.getItem() instanceof ItemBlock && ((ItemBlock)Item.getItem()).field_150939_a == Blocks.Carriage) {
      if (Carriage != null) {
        return (null);
      }
      Carriage=Item;
      continue;
    }
    if (Decoration != null) {
      return (null);
    }
    Decoration=Item;
  }
  if (Carriage == null) {
    return (null);
  }
  int Tier=CarriageItem.GetTier(Carriage);
  net.minecraft.block.Block DecorationId=CarriageItem.GetDecorationId(Carriage);
  if (DecorationId == null) {
    if (Decoration == null) {
      return (null);
    }
    if (!(Decoration.getItem() instanceof net.minecraft.item.ItemBlock)) {
      return (null);
    }
    DecorationId=((ItemBlock)Decoration.getItem()).field_150939_a;
    int DecorationMeta=Decoration.getItem().getMetadata(Decoration.getItemDamage());
    return (CarriageItem.Stack(Carriage.getItemDamage(),Tier,DecorationId,DecorationMeta));
  }
  if (Decoration != null) {
    return (null);
  }
  return (CarriageItem.Stack(BlockItem.GetBlockType(Carriage),Tier));
}",0.5781922525107605
22886,"public CarriageDriveItem(int Id){
  super(Id);
}","public CarriageDriveItem(Block b){
  super(b);
}",0.8541666666666666
22887,"@Override public void Render(net.minecraft.tileentity.TileEntity TileEntity){
  if (TileEntity instanceof CarriageTranslocatorEntity) {
    CarriageTranslocatorEntity Translocator=(CarriageTranslocatorEntity)TileEntity;
    if (Translocator.Player == null) {
      return;
    }
    UseFullLabel();
    if (Translocator.Player.equals(""String_Node_Str"")) {
      UseFullIcon(CarriageDrive.PublicIcon);
    }
 else {
      if (Translocator.Player.equals(net.minecraft.client.Minecraft.getMinecraft().thePlayer.username)) {
        UseFullIcon(CarriageDrive.PrivateToSelfIcon);
      }
 else {
        UseFullIcon(CarriageDrive.PrivateToOtherIcon);
      }
    }
    RenderOverlay(0.001,Translocator.SideClosed,false);
    for (    Vanilla.DyeTypes DyeType : Vanilla.DyeTypes.values()) {
      if (CarriageDriveItem.LabelHasDye(Translocator.Label,DyeType)) {
        double GridH=((double)(DyeType.ordinal() % 4)) / 4;
        double GridV=((double)(DyeType.ordinal() / 4)) / 4;
        UsePartialLabel(GridH,GridV,GridH + 0.25,GridV + 0.25);
        UsePartialIcon(CarriageDrive.DyeIconSet,GridH,GridV,GridH + 0.25,GridV + 0.25);
        RenderOverlay(0.002,Translocator.SideClosed,false);
      }
    }
  }
}","@Override public void Render(net.minecraft.tileentity.TileEntity TileEntity){
  if (TileEntity instanceof CarriageTranslocatorEntity) {
    CarriageTranslocatorEntity Translocator=(CarriageTranslocatorEntity)TileEntity;
    if (Translocator.Player == null) {
      return;
    }
    UseFullLabel();
    if (Translocator.Player.equals(""String_Node_Str"")) {
      UseFullIcon(CarriageDrive.PublicIcon);
    }
 else {
      if (Translocator.Player.equals(net.minecraft.client.Minecraft.getMinecraft().thePlayer.getDisplayName())) {
        UseFullIcon(CarriageDrive.PrivateToSelfIcon);
      }
 else {
        UseFullIcon(CarriageDrive.PrivateToOtherIcon);
      }
    }
    RenderOverlay(0.001,Translocator.SideClosed,false);
    for (    Vanilla.DyeTypes DyeType : Vanilla.DyeTypes.values()) {
      if (CarriageDriveItem.LabelHasDye(Translocator.Label,DyeType)) {
        double GridH=((double)(DyeType.ordinal() % 4)) / 4;
        double GridV=((double)(DyeType.ordinal() / 4)) / 4;
        UsePartialLabel(GridH,GridV,GridH + 0.25,GridV + 0.25);
        UsePartialIcon(CarriageDrive.DyeIconSet,GridH,GridV,GridH + 0.25,GridV + 0.25);
        RenderOverlay(0.002,Translocator.SideClosed,false);
      }
    }
  }
}",0.9925681255161024
22888,"public void UseFullIcon(net.minecraft.util.Icon Icon){
  SetTextureSpan(Icon);
}","public void UseFullIcon(net.minecraft.util.IIcon Icon){
  SetTextureSpan(Icon);
}",0.9937888198757764
22889,"public CarriageDriveRenderer(){
  Blocks.CarriageDrive.RenderId=Initialize(Blocks.CarriageDrive.blockID);
}","public CarriageDriveRenderer(){
  Blocks.CarriageDrive.RenderId=Initialize(Blocks.CarriageDrive);
}",0.9611650485436892
22890,"public void UsePartialIcon(net.minecraft.util.Icon Icon,double MinU,double MinV,double MaxU,double MaxV){
  UseFullIcon(Icon);
  SubsectTextureSpan(MinU,MinV,MaxU,MaxV);
}","public void UsePartialIcon(net.minecraft.util.IIcon Icon,double MinU,double MinV,double MaxU,double MaxV){
  UseFullIcon(Icon);
  SubsectTextureSpan(MinU,MinV,MaxU,MaxV);
}",0.9970845481049564
22891,"@Override public CarriagePackage PreparePackage(Directions MotionDirection) throws CarriageMotionException {
  CarriagePackage Package=super.PreparePackage(null);
  CarriageTranslocatorEntity Target=null;
  java.util.LinkedList<BlockPosition> ActiveTranslocators;
  try {
    ActiveTranslocators=ActiveTranslocatorSets.get(Player).get(Label);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  for (int Index=0; Index < ActiveTranslocators.size(); Index++) {
    BlockPosition Position=ActiveTranslocators.get(Index);
    try {
      CarriageTranslocatorEntity Translocator=(CarriageTranslocatorEntity)WorldUtil.GetWorld(Position.Dimension).getBlockTileEntity(Position.X,Position.Y,Position.Z);
      if (Translocator == this) {
        continue;
      }
      boolean TargetValid=true;
      for (      BlockRecord Record : Package.NewPositions) {
        if (!Translocator.worldObj.isAirBlock(Record.X + Translocator.xCoord,Record.Y + Translocator.yCoord,Record.Z + Translocator.zCoord)) {
          TargetValid=false;
          break;
        }
      }
      if (TargetValid) {
        Target=Translocator;
        break;
      }
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  if (Target == null) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  Package.Translocator=Target;
  return (Package);
}","@Override public CarriagePackage PreparePackage(Directions MotionDirection) throws CarriageMotionException {
  CarriagePackage Package=super.PreparePackage(null);
  CarriageTranslocatorEntity Target=null;
  java.util.LinkedList<BlockPosition> ActiveTranslocators;
  try {
    ActiveTranslocators=ActiveTranslocatorSets.get(Player).get(Label);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  for (int Index=0; Index < ActiveTranslocators.size(); Index++) {
    BlockPosition Position=ActiveTranslocators.get(Index);
    try {
      CarriageTranslocatorEntity Translocator=(CarriageTranslocatorEntity)WorldUtil.GetWorld(Position.Dimension).getTileEntity(Position.X,Position.Y,Position.Z);
      if (Translocator == this) {
        continue;
      }
      boolean TargetValid=true;
      for (      BlockRecord Record : Package.NewPositions) {
        if (!Translocator.worldObj.isAirBlock(Record.X + Translocator.xCoord,Record.Y + Translocator.yCoord,Record.Z + Translocator.zCoord)) {
          TargetValid=false;
          break;
        }
      }
      if (TargetValid) {
        Target=Translocator;
        break;
      }
    }
 catch (    Throwable Throwable) {
      Throwable.printStackTrace();
    }
  }
  if (Target == null) {
    throw (new CarriageMotionException(""String_Node_Str""));
  }
  Package.Translocator=Target;
  return (Package);
}",0.998265695456122
22892,"@Override public void Setup(net.minecraft.entity.player.EntityPlayer Player,net.minecraft.item.ItemStack Item){
  super.Setup(Player,Item);
  this.Player=CarriageDriveItem.GetPrivateFlag(Item) ? Player.username : ""String_Node_Str"";
  Label=CarriageDriveItem.GetLabel(Item);
  if (!worldObj.isRemote) {
    RegisterLabel();
{
      ClearLabel();
      RegisterLabel();
    }
  }
}","@Override public void Setup(net.minecraft.entity.player.EntityPlayer Player,net.minecraft.item.ItemStack Item){
  super.Setup(Player,Item);
  this.Player=CarriageDriveItem.GetPrivateFlag(Item) ? Player.getDisplayName() : ""String_Node_Str"";
  Label=CarriageDriveItem.GetLabel(Item);
  if (!worldObj.isRemote) {
    RegisterLabel();
{
      ClearLabel();
      RegisterLabel();
    }
  }
}",0.9686684073107048
22893,"@Override public void getSubItems(int Id,net.minecraft.creativetab.CreativeTabs CreativeTab,java.util.List Showcase){
  AddShowcaseStacks(Showcase);
}","@SideOnly(Side.CLIENT) @Override public void getSubItems(net.minecraft.item.Item p_150895_1_,CreativeTabs p_150895_2_,List Showcase){
  AddShowcaseStacks(Showcase);
}",0.7151898734177216
22894,"public static void Handle(net.minecraft.nbt.NBTTagCompound Packet,net.minecraft.world.World World){
  int Id=Packet.getInteger(""String_Node_Str"");
  net.minecraft.nbt.NBTTagList Body=Packet.getTagList(""String_Node_Str"");
  for (int Index=0; Index < Body.tagCount(); Index++) {
    net.minecraft.nbt.NBTTagCompound Tag=(net.minecraft.nbt.NBTTagCompound)Body.tagAt(Index);
    World.setBlock(Tag.getInteger(""String_Node_Str""),Tag.getInteger(""String_Node_Str""),Tag.getInteger(""String_Node_Str""),Id,0,0);
  }
}","public static void Handle(net.minecraft.nbt.NBTTagCompound Packet,net.minecraft.world.World World){
  int Id=Packet.getInteger(""String_Node_Str"");
  net.minecraft.nbt.NBTTagList Body=Packet.getTagList(""String_Node_Str"",9);
  for (int Index=0; Index < Body.tagCount(); Index++) {
    net.minecraft.nbt.NBTTagCompound Tag=(net.minecraft.nbt.NBTTagCompound)Body.tagAt(Index);
    World.setBlock(Tag.getInteger(""String_Node_Str""),Tag.getInteger(""String_Node_Str""),Tag.getInteger(""String_Node_Str""),Block.getBlockById(Id),0,0);
  }
}",0.9748549323017408
22895,"public static void RegisterSmeltingRecipe(net.minecraft.item.ItemStack Output,net.minecraft.item.ItemStack Input,float Xp){
  net.minecraft.item.crafting.FurnaceRecipes.smelting().addSmelting(Input.itemID,Input.getItemDamage(),Output,Xp);
}","public static void RegisterSmeltingRecipe(net.minecraft.item.ItemStack Output,net.minecraft.item.ItemStack Input,float Xp){
  net.minecraft.item.crafting.FurnaceRecipes.smelting().func_151394_a(Input,Output,Xp);
}",0.8830022075055187
22896,"public Spectre(){
  super(Configuration.BlockIds.Spectre,bedrock,SpectreItem.class,MotiveSpectreEntity.class,null,TeleportativeSpectreEntity.class);
  RenderId=-1;
}","public Spectre(){
  super((net.minecraft.block.Block)Block.blockRegistry.getObject(""String_Node_Str""),SpectreItem.class,MotiveSpectreEntity.class,null,TeleportativeSpectreEntity.class);
  RenderId=-1;
}",0.7084468664850136
22897,"public SpectreItem(int Id){
  super(Id);
}","public SpectreItem(Block b){
  super(b);
}",0.8333333333333334
22898,"public boolean IsStructureCarriage(BlockRecord Record){
  Record.Identify(worldObj);
  if (Record.Id == Blocks.Carriage.blockID) {
    if (Record.Meta == Carriage.Types.Structure.ordinal()) {
      return (true);
    }
  }
  return (false);
}","public boolean IsStructureCarriage(BlockRecord Record){
  Record.Identify(worldObj);
  if (Record.block == Blocks.Carriage) {
    if (Record.Meta == Carriage.Types.Structure.ordinal()) {
      return (true);
    }
  }
  return (false);
}",0.9686847599164928
22899,"@Override public void ScheduleShiftedBlockUpdate(net.minecraft.nbt.NBTTagCompound PendingBlockUpdateRecord){
  worldObj.scheduleBlockUpdateFromLoad(PendingBlockUpdateRecord.getInteger(""String_Node_Str"") + ShiftX,PendingBlockUpdateRecord.getInteger(""String_Node_Str"") + ShiftY,PendingBlockUpdateRecord.getInteger(""String_Node_Str"") + ShiftZ,PendingBlockUpdateRecord.getInteger(""String_Node_Str""),PendingBlockUpdateRecord.getInteger(""String_Node_Str""),PendingBlockUpdateRecord.getInteger(""String_Node_Str""));
}","@Override public void ScheduleShiftedBlockUpdate(net.minecraft.nbt.NBTTagCompound PendingBlockUpdateRecord){
  worldObj.scheduleBlockUpdateWithPriority(PendingBlockUpdateRecord.getInteger(""String_Node_Str"") + ShiftX,PendingBlockUpdateRecord.getInteger(""String_Node_Str"") + ShiftY,PendingBlockUpdateRecord.getInteger(""String_Node_Str"") + ShiftZ,Block.getBlockById(PendingBlockUpdateRecord.getInteger(""String_Node_Str"")),PendingBlockUpdateRecord.getInteger(""String_Node_Str""),PendingBlockUpdateRecord.getInteger(""String_Node_Str""));
}",0.8596153846153847
22900,"public boolean IsUnpatternedTemplateCarriage(BlockRecord Record){
  boolean IsUnpatternedTemplateCarriage=false;
  Record.Identify(worldObj);
  if (Record.Id == Blocks.Carriage.blockID) {
    if (Record.Meta == Carriage.Types.Template.ordinal()) {
      if (((TemplateCarriageEntity)Record.Entity).Pattern == null) {
        IsUnpatternedTemplateCarriage=true;
      }
    }
  }
  Record.Entity=null;
  return (IsUnpatternedTemplateCarriage);
}","public boolean IsUnpatternedTemplateCarriage(BlockRecord Record){
  boolean IsUnpatternedTemplateCarriage=false;
  Record.Identify(worldObj);
  if (Record.block == Blocks.Carriage) {
    if (Record.Meta == Carriage.Types.Template.ordinal()) {
      if (((TemplateCarriageEntity)Record.Entity).Pattern == null) {
        IsUnpatternedTemplateCarriage=true;
      }
    }
  }
  Record.Entity=null;
  return (IsUnpatternedTemplateCarriage);
}",0.4258210645526614
22901,"@Override public void ReadCommonRecord(net.minecraft.nbt.NBTTagCompound TagCompound){
  super.ReadCommonRecord(TagCompound);
  if (TagCompound.hasKey(""String_Node_Str"")) {
    net.minecraft.nbt.NBTTagList PatternRecord=TagCompound.getTagList(""String_Node_Str"");
    Pattern=new BlockRecordList();
    int PatternSize=PatternRecord.tagCount();
    for (int Index=0; Index < PatternSize; Index++) {
      net.minecraft.nbt.NBTTagCompound PatternBlockRecord=(net.minecraft.nbt.NBTTagCompound)PatternRecord.tagAt(Index);
      Pattern.add(new BlockRecord(PatternBlockRecord.getInteger(""String_Node_Str""),PatternBlockRecord.getInteger(""String_Node_Str""),PatternBlockRecord.getInteger(""String_Node_Str"")));
    }
  }
 else {
    Pattern=null;
  }
  RenderPattern=TagCompound.getBoolean(""String_Node_Str"");
}","@Override public void ReadCommonRecord(net.minecraft.nbt.NBTTagCompound TagCompound){
  super.ReadCommonRecord(TagCompound);
  if (TagCompound.hasKey(""String_Node_Str"")) {
    net.minecraft.nbt.NBTTagList PatternRecord=TagCompound.getTagList(""String_Node_Str"",9);
    Pattern=new BlockRecordList();
    int PatternSize=PatternRecord.tagCount();
    for (int Index=0; Index < PatternSize; Index++) {
      net.minecraft.nbt.NBTTagCompound PatternBlockRecord=(net.minecraft.nbt.NBTTagCompound)PatternRecord.getCompoundTagAt(Index);
      Pattern.add(new BlockRecord(PatternBlockRecord.getInteger(""String_Node_Str""),PatternBlockRecord.getInteger(""String_Node_Str""),PatternBlockRecord.getInteger(""String_Node_Str"")));
    }
  }
 else {
    Pattern=null;
  }
  RenderPattern=TagCompound.getBoolean(""String_Node_Str"");
}",0.9907120743034056
22902,"public static boolean IsScrewdriverOrEquivalent(net.minecraft.item.ItemStack Item){
  if (Item == null) {
    return (false);
  }
  if (Item.itemID == Items.ToolItemSet.itemID) {
    if (Item.getItemDamage() == Types.Screwdriver.ordinal()) {
      return (true);
    }
  }
  if (ModInteraction.OmniTools.ItemWrench != null) {
    if (ModInteraction.OmniTools.ItemWrench.isInstance(Item.getItem())) {
      return (true);
    }
  }
  return (false);
}","public static boolean IsScrewdriverOrEquivalent(net.minecraft.item.ItemStack Item){
  if (Item == null) {
    return (false);
  }
  if (Item.getItem() == Items.ToolItemSet) {
    if (Item.getItemDamage() == Types.Screwdriver.ordinal()) {
      return (true);
    }
  }
  if (ModInteraction.OmniTools.ItemWrench != null) {
    if (ModInteraction.OmniTools.ItemWrench.isInstance(Item.getItem())) {
      return (true);
    }
  }
  return (false);
}",0.9754464285714286
22903,"@Override public net.minecraft.util.Icon getIconFromDamage(int Damage){
  try {
    return (Types.values()[Damage].Icon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public net.minecraft.util.IIcon getIconFromDamage(int Damage){
  try {
    return (Types.values()[Damage].Icon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9979123173277662
22904,"@Override public void registerIcons(net.minecraft.client.renderer.texture.IconRegister IconRegister){
  for (  Types Type : Types.values()) {
    Type.Icon=Registry.RegisterIcon(IconRegister,Type.name());
  }
}","@Override public void registerIcons(net.minecraft.client.renderer.texture.IIconRegister IconRegister){
  for (  Types Type : Types.values()) {
    Type.Icon=Registry.RegisterIcon(IconRegister,Type.name());
  }
}",0.997624703087886
22905,"public ToolItemSet(){
  super(Id);
  setMaxStackSize(1);
}","public ToolItemSet(){
  super();
  setMaxStackSize(1);
}",0.9824561403508772
22906,"public Block(int Id,net.minecraft.block.Block Template,Class<? extends BlockItem> BlockItemClass,String HarvestToolType,Class<? extends TileEntity>... TileEntityClasses){
  this(Id,Template,BlockItemClass,TileEntityClasses);
  net.minecraftforge.common.MinecraftForge.setBlockHarvestLevel(this,HarvestToolType,0);
  setCreativeTab(CreativeTab.Instance);
}","public Block(net.minecraft.block.Block Template,Class<? extends BlockItem> BlockItemClass,String HarvestToolType,Class<? extends TileEntity>... TileEntityClasses){
  this(Template,BlockItemClass,TileEntityClasses);
  setCreativeTab(CreativeTab.Instance);
}",0.8379705400981997
22907,"@Override public void onBlockPlacedBy(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.EntityLivingBase Entity,net.minecraft.item.ItemStack Item){
  super.onBlockPlacedBy(World,X,Y,Z,Entity,Item);
  try {
    ((TileEntity)World.getBlockTileEntity(X,Y,Z)).Setup((net.minecraft.entity.player.EntityPlayer)Entity,Item);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}","@Override public void onBlockPlacedBy(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.EntityLivingBase Entity,net.minecraft.item.ItemStack Item){
  super.onBlockPlacedBy(World,X,Y,Z,Entity,Item);
  try {
    ((TileEntity)World.getTileEntity(X,Y,Z)).Setup((net.minecraft.entity.player.EntityPlayer)Entity,Item);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}",0.993924665856622
22908,"@Override public void getSubBlocks(int Id,net.minecraft.creativetab.CreativeTabs CreativeTab,java.util.List Showcase){
  AddShowcaseStacks(Showcase);
}","@Override public void getSubBlocks(net.minecraft.creativetab.CreativeTabs CreativeTab,java.util.List Showcase){
  AddShowcaseStacks(Showcase);
}",0.976271186440678
22909,"public BlockItem(int Id){
  super(Id);
  setHasSubtypes(true);
}","public BlockItem(Block Id){
  super(Id);
  setHasSubtypes(true);
}",0.9384615384615383
22910,"public static BlockRecord Identified(TileEntity Anchor,int X,int Y,int Z){
  BlockRecord Record=new BlockRecord(X,Y,Z);
  Record.Identify(Anchor.worldObj);
  return (Record);
}","public static BlockRecord Identified(TileEntity Anchor,int X,int Y,int Z){
  BlockRecord Record=new BlockRecord(X,Y,Z);
  Record.Identify(Anchor.getWorldObj());
  return (Record);
}",0.9803921568627452
22911,"public void Identify(net.minecraft.world.World World){
  this.World=World;
  Id=World.getBlockId(X,Y,Z);
  Meta=World.getBlockMetadata(X,Y,Z);
  Entity=World.getBlockTileEntity(X,Y,Z);
}","public void Identify(net.minecraft.world.World World){
  this.World=World;
  block=World.getBlock(X,Y,Z);
  Meta=World.getBlockMetadata(X,Y,Z);
  Entity=World.getTileEntity(X,Y,Z);
}",0.9619565217391304
22912,"@Override public boolean renderWorldBlock(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,net.minecraft.block.Block Block,int RenderId,net.minecraft.client.renderer.RenderBlocks RenderBlocks){
  this.X=X;
  this.Y=Y;
  this.Z=Z;
  Brightness=Block.getMixedBrightnessForBlock(World,X,Y,Z);
  RenderBlocks.setRenderBounds(0,0,0,1,1,1);
  RenderBlocks.renderStandardBlock(Block,X,Y,Z);
  Render(World.getBlockTileEntity(X,Y,Z));
  return (true);
}","@Override public boolean renderWorldBlock(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,net.minecraft.block.Block Block,int RenderId,net.minecraft.client.renderer.RenderBlocks RenderBlocks){
  this.X=X;
  this.Y=Y;
  this.Z=Z;
  Brightness=Block.getMixedBrightnessForBlock(World,X,Y,Z);
  RenderBlocks.setRenderBounds(0,0,0,1,1,1);
  RenderBlocks.renderStandardBlock(Block,X,Y,Z);
  Render(World.getTileEntity(X,Y,Z));
  return (true);
}",0.9944506104328524
22913,"public int Initialize(int BlockId){
  RenderId=cpw.mods.fml.client.registry.RenderingRegistry.getNextAvailableRenderId();
  cpw.mods.fml.client.registry.RenderingRegistry.registerBlockHandler(this);
  net.minecraftforge.client.MinecraftForgeClient.registerItemRenderer(BlockId,this);
  return (RenderId);
}","public int Initialize(Block block){
  RenderId=cpw.mods.fml.client.registry.RenderingRegistry.getNextAvailableRenderId();
  cpw.mods.fml.client.registry.RenderingRegistry.registerBlockHandler(this);
  net.minecraftforge.client.MinecraftForgeClient.registerItemRenderer(new ItemBlock(block),this);
  return (RenderId);
}",0.9536
22914,"@Override public boolean shouldRender3DInInventory(){
  return (true);
}","@Override public boolean shouldRender3DInInventory(int id){
  return (true);
}",0.96
22915,"public void SetTextureSpan(net.minecraft.util.Icon Texture){
  TextureMinU=Texture.getInterpolatedU(0);
  TextureMinV=Texture.getInterpolatedV(0);
  TextureMaxU=Texture.getInterpolatedU(16);
  TextureMaxV=Texture.getInterpolatedV(16);
}","public void SetTextureSpan(IIcon Texture){
  TextureMinU=Texture.getInterpolatedU(0);
  TextureMinV=Texture.getInterpolatedV(0);
  TextureMaxU=Texture.getInterpolatedU(16);
  TextureMaxV=Texture.getInterpolatedV(16);
}",0.9559471365638766
22916,"public abstract net.minecraft.util.Icon GetIcon(net.minecraft.item.ItemStack Item,Directions Side);","public abstract IIcon GetIcon(net.minecraft.item.ItemStack Item,Directions Side);",0.8888888888888888
22917,"@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    ((CarriageEntity)World.getBlockTileEntity(X,Y,Z)).ToggleSide(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}","@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    ((CarriageEntity)World.getTileEntity(X,Y,Z)).ToggleSide(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}",0.9954421148587056
22918,"@Override public net.minecraft.util.Icon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageEntity Carriage=(CarriageEntity)World.getBlockTileEntity(X,Y,Z);
    if ((Carriage.DecorationId != 0) && (Carriage.SideClosed[Side])) {
      return (net.minecraft.block.Block.blocksList[Carriage.DecorationId].getIcon(Side,Carriage.DecorationMeta));
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    return (Carriage.SideClosed[Side] ? Type.ClosedIcon : Type.OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageEntity Carriage=(CarriageEntity)World.getTileEntity(X,Y,Z);
    if ((Carriage.DecorationId != 0) && (Carriage.SideClosed[Side])) {
      return (net.minecraft.block.Block.blocksList[Carriage.DecorationId].getIcon(Side,Carriage.DecorationMeta));
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    return (Carriage.SideClosed[Side] ? Type.ClosedIcon : Type.OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9369649805447472
22919,"@Override public net.minecraft.util.Icon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].OpenIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9563318777292577
22920,"@Override public void onNeighborBlockChange(net.minecraft.world.World World,int X,int Y,int Z,int Id){
  try {
    ((CarriageDriveEntity)World.getBlockTileEntity(X,Y,Z)).HandleNeighbourBlockChange();
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}","@Override public void onNeighborBlockChange(net.minecraft.world.World World,int X,int Y,int Z,int Id){
  try {
    ((CarriageDriveEntity)World.getTileEntity(X,Y,Z)).HandleNeighbourBlockChange();
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
  }
}",0.9908256880733946
22921,"@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    CarriageDriveEntity cde=(CarriageDriveEntity)World.getBlockTileEntity(X,Y,Z);
    cde.lastUsingPlayer=Player;
    System.out.println(""String_Node_Str"");
    cde.HandleToolUsage(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}","@Override public boolean onBlockActivated(net.minecraft.world.World World,int X,int Y,int Z,net.minecraft.entity.player.EntityPlayer Player,int Side,float HitX,float HitY,float HitZ){
  if (World.isRemote) {
    return (false);
  }
  if (!ToolItemSet.IsScrewdriverOrEquivalent(Player.inventory.getCurrentItem())) {
    return (false);
  }
  try {
    CarriageDriveEntity cde=(CarriageDriveEntity)World.getTileEntity(X,Y,Z);
    cde.lastUsingPlayer=Player;
    System.out.println(""String_Node_Str"");
    cde.HandleToolUsage(Side,Player.isSneaking());
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (false);
  }
  return (true);
}",0.6275395033860045
22922,"@Override public net.minecraft.util.Icon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)World.getBlockTileEntity(X,Y,Z);
    if (Drive.SideClosed[Side]) {
      return (InactiveIcon);
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    if (Drive.Continuous) {
      return (Drive.Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Drive.Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getBlockTexture(net.minecraft.world.IBlockAccess World,int X,int Y,int Z,int Side){
  try {
    CarriageDriveEntity Drive=(CarriageDriveEntity)World.getTileEntity(X,Y,Z);
    if (Drive.SideClosed[Side]) {
      return (InactiveIcon);
    }
    Types Type=Types.values()[World.getBlockMetadata(X,Y,Z)];
    if (Drive.Continuous) {
      return (Drive.Active ? Type.ContinuousActiveIcon : Type.ContinuousIcon);
    }
    return (Drive.Active ? Type.NormalActiveIcon : Type.NormalIcon);
  }
 catch (  Throwable Throwable) {
    Throwable.printStackTrace();
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.980330448465775
22923,"@Override public net.minecraft.util.Icon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.Spectre.getIcon(0,0));
  }
}","@Override public IIcon getIcon(int Side,int Meta){
  try {
    return (Types.values()[Meta].NormalIcon);
  }
 catch (  Throwable Throwable) {
    return (Blocks.Spectre.getIcon(0,0));
  }
}",0.9494949494949496
22924,"@Override public net.minecraft.util.Icon GetIcon(net.minecraft.item.ItemStack Item,Directions Side){
  return (Blocks.CarriageDrive.getIcon(0,BlockItem.GetBlockType(Item)));
}","@Override public IIcon GetIcon(net.minecraft.item.ItemStack Item,Directions Side){
  return (Blocks.CarriageDrive.getIcon(0,BlockItem.GetBlockType(Item)));
}",0.9397590361445785
22925,"public BerTlvBuilder addAmount(BerTag aObject,BigDecimal aAmount){
  BigDecimal numeric=aAmount.multiply(new BigDecimal(100));
  StringBuilder sb=new StringBuilder(12);
  sb.append(numeric.longValue());
  while (sb.length() < 12) {
    sb.insert(0,'0');
  }
  return addHex(aObject,sb.toString());
}","public BerTlvBuilder addAmount(BerTag aObject,BigDecimal aAmount){
  BigDecimal numeric=aAmount.multiply(HUNDRED);
  StringBuilder sb=new StringBuilder(12);
  sb.append(numeric.longValue());
  while (sb.length() < 12) {
    sb.insert(0,'0');
  }
  return addHex(aObject,sb.toString());
}",0.955631399317406
22926,"public int build(){
  if (theTemplate) {
    theBuffer[theLengthPosition]=(byte)(thePos - theLengthPosition - 1);
  }
  return thePos;
}","public int build(){
  if (theTemplate != null) {
    int tagLen=theTemplate.bytes.length;
    int lengthBytesCount=calculateBytesCountForLength(thePos);
    System.arraycopy(theBuffer,theBufferOffset,theBuffer,tagLen + lengthBytesCount,thePos);
    System.arraycopy(theTemplate.bytes,0,theBuffer,theBufferOffset,theTemplate.bytes.length);
    fillLength(theBuffer,tagLen,thePos);
    thePos+=tagLen + lengthBytesCount;
  }
  return thePos;
}",0.194107452339688
22927,"public BerTlvBuilder(){
  this(new byte[1024],0,1024);
}","public BerTlvBuilder(BerTag aTemplate,byte[] aBuffer,int aOffset,int aLength){
  theTemplate=aTemplate;
  theBuffer=aBuffer;
  thePos=aOffset;
  theBufferOffset=aOffset;
}",0.2995594713656387
22928,"public static void log(String aPadding,BerTlv aTlv,IBerTlvLogger aLogger){
  if (aTlv == null) {
    aLogger.debug(""String_Node_Str"",aPadding);
    return;
  }
  if (aTlv.isConstructed()) {
    aLogger.debug(""String_Node_Str"",aPadding,aTlv.getTag());
    for (    BerTlv child : aTlv.getValues()) {
      log(aPadding + ""String_Node_Str"",child,aLogger);
    }
  }
 else {
    aLogger.debug(""String_Node_Str"",aPadding,aTlv.getTag(),aTlv.getHexValue());
  }
}","public static void log(String aPadding,BerTlv aTlv,IBerTlvLogger aLogger){
  if (aTlv == null) {
    aLogger.debug(""String_Node_Str"",aPadding);
    return;
  }
  if (aTlv.isConstructed()) {
    aLogger.debug(""String_Node_Str"",aPadding,HexUtil.toHexString(aTlv.getTag().bytes));
    for (    BerTlv child : aTlv.getValues()) {
      log(aPadding + ""String_Node_Str"",child,aLogger);
    }
  }
 else {
    aLogger.debug(""String_Node_Str"",aPadding,HexUtil.toHexString(aTlv.getTag().bytes),aTlv.getHexValue());
  }
}",0.8946280991735537
22929,"private ParseResult parseWithResult(int aLevel,byte[] aBuf,int aOffset,int aLen){
  String levelPadding=createLevelPadding(aLevel);
  if (aOffset + aLen > aBuf.length) {
    throw new IllegalStateException(""String_Node_Str"" + aOffset + ""String_Node_Str""+ aLen+ ""String_Node_Str""+ aBuf.length+ ""String_Node_Str""+ aLevel+ ""String_Node_Str"");
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",levelPadding,aLevel,aOffset,aLen,HexUtil.toFormattedHexString(aBuf,aOffset,aLen));
  }
  int tagOffset=getTagOffset(aBuf,aOffset);
  BerTag tag=findTag(levelPadding,aBuf,aOffset,tagOffset);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",levelPadding,tag,tagOffset,HexUtil.toHexString(aBuf,aOffset,tagOffset));
  }
  int dataOffset=getDataOffset(aBuf,aOffset + tagOffset);
  int valueLength=getDataLength(aBuf,aOffset + tagOffset);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",levelPadding,valueLength,HexUtil.toHexString(aBuf,aOffset + tagOffset,dataOffset));
  }
  if (tag.isConstructed()) {
    ArrayList<BerTlv> list=new ArrayList<BerTlv>();
    addChildren(aLevel,aBuf,aOffset,levelPadding,tagOffset,dataOffset,valueLength,list);
    int resultOffset=aOffset + tagOffset + dataOffset+ valueLength;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",levelPadding,resultOffset);
    }
    return new ParseResult(new BerTlv(tag,list),resultOffset);
  }
 else {
    byte[] value=new byte[valueLength];
    System.arraycopy(aBuf,aOffset + tagOffset + dataOffset,value,0,valueLength);
    int resultOffset=aOffset + tagOffset + dataOffset+ valueLength;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",levelPadding,HexUtil.toFormattedHexString(value));
      log.debug(""String_Node_Str"",levelPadding,resultOffset);
    }
    return new ParseResult(new BerTlv(tag,value),resultOffset);
  }
}","private ParseResult parseWithResult(int aLevel,byte[] aBuf,int aOffset,int aLen){
  String levelPadding=createLevelPadding(aLevel);
  if (aOffset + aLen > aBuf.length) {
    throw new IllegalStateException(""String_Node_Str"" + aOffset + ""String_Node_Str""+ aLen+ ""String_Node_Str""+ aBuf.length+ ""String_Node_Str""+ aLevel+ ""String_Node_Str"");
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",levelPadding,aLevel,aOffset,aLen,HexUtil.toFormattedHexString(aBuf,aOffset,aLen));
  }
  int tagBytesCount=getTagBytesCount(aBuf,aOffset);
  BerTag tag=createTag(levelPadding,aBuf,aOffset,tagBytesCount);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",levelPadding,tag,tagBytesCount,HexUtil.toFormattedHexString(aBuf,aOffset,tagBytesCount));
  }
  int lengthBytesCount=getLengthBytesCount(aBuf,aOffset + tagBytesCount);
  int valueLength=getDataLength(aBuf,aOffset + tagBytesCount);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",levelPadding,lengthBytesCount,valueLength,HexUtil.toFormattedHexString(aBuf,aOffset + tagBytesCount,lengthBytesCount));
  }
  if (tag.isConstructed()) {
    ArrayList<BerTlv> list=new ArrayList<BerTlv>();
    addChildren(aLevel,aBuf,aOffset,levelPadding,tagBytesCount,lengthBytesCount,valueLength,list);
    int resultOffset=aOffset + tagBytesCount + lengthBytesCount+ valueLength;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",levelPadding,resultOffset);
    }
    return new ParseResult(new BerTlv(tag,list),resultOffset);
  }
 else {
    byte[] value=new byte[valueLength];
    System.arraycopy(aBuf,aOffset + tagBytesCount + lengthBytesCount,value,0,valueLength);
    int resultOffset=aOffset + tagBytesCount + lengthBytesCount+ valueLength;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",levelPadding,HexUtil.toFormattedHexString(value));
      log.debug(""String_Node_Str"",levelPadding,resultOffset);
    }
    return new ParseResult(new BerTlv(tag,value),resultOffset);
  }
}",0.8561020036429873
22930,"private void addChildren(int aLevel,byte[] aBuf,int aOffset,String levelPadding,int tagOffset,int dataOffset,int valueLength,ArrayList<BerTlv> list){
  int conOffset=aOffset + tagOffset + dataOffset;
  int conLen=valueLength;
  while (conOffset < dataOffset + valueLength) {
    ParseResult result=parseWithResult(aLevel + 1,aBuf,conOffset,conLen);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",levelPadding,aLevel,result.tlv.getTag(),result.offset);
    }
    conOffset=result.offset;
    conLen=valueLength - conOffset;
    list.add(result.tlv);
  }
}","/** 
 * @param aLevel          level for debug
 * @param aBuf            buffer
 * @param aOffset         offset (first byte)
 * @param levelPadding    level padding (for debug)
 * @param aTagBytesCount  tag bytes count
 * @param aDataBytesCount data bytes count
 * @param valueLength     length
 * @param list            list to add
 */
private void addChildren(int aLevel,byte[] aBuf,int aOffset,String levelPadding,int aTagBytesCount,int aDataBytesCount,int valueLength,ArrayList<BerTlv> list){
  int startPosition=aOffset + aTagBytesCount + aDataBytesCount;
  int len=valueLength;
  while (startPosition < aOffset + valueLength) {
    ParseResult result=parseWithResult(aLevel + 1,aBuf,startPosition,len);
    list.add(result.tlv);
    startPosition=result.offset;
    len=valueLength - startPosition;
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",levelPadding,aLevel,result.tlv.getTag(),result.offset,startPosition,aDataBytesCount,valueLength);
    }
  }
}",0.5160875160875161
22931,"private void parse(String hex){
  byte[] bytes=HexUtil.parseHex(hex);
  BerTlvParser parser=new BerTlvParser(LOG);
  BerTlvs tlvs=parser.parse(bytes,0,bytes.length);
  BerTlvLogger.log(""String_Node_Str"",tlvs,LOG);
}","private BerTlvs parse(String hex){
  byte[] bytes=HexUtil.parseHex(hex);
  BerTlvParser parser=new BerTlvParser(LOG);
  BerTlvs tlvs=parser.parse(bytes,0,bytes.length);
  BerTlvLogger.log(""String_Node_Str"",tlvs,LOG);
  return tlvs;
}",0.9419642857142856
22932,"private void attachSampleFile(PDDocument doc) throws IOException {
  PDEmbeddedFilesNameTreeNode efTree=new PDEmbeddedFilesNameTreeNode();
  PDComplexFileSpecification fs=new PDComplexFileSpecification();
  fs.setFile(""String_Node_Str"");
  COSDictionary dict=fs.getCOSDictionary();
  dict.setName(""String_Node_Str"",""String_Node_Str"");
  dict.setString(""String_Node_Str"",""String_Node_Str"");
  String payload=""String_Node_Str"";
  InputStream is=new ByteArrayInputStream(payload.getBytes());
  PDEmbeddedFile ef=new PDEmbeddedFile(doc,is);
  ef.setSubtype(""String_Node_Str"");
  ef.setModDate(GregorianCalendar.getInstance());
  ef.setSize(payload.length());
  ef.setCreationDate(new GregorianCalendar());
  fs.setEmbeddedFile(ef);
  efTree.setNames(Collections.singletonMap(""String_Node_Str"",fs));
  PDDocumentCatalog catalog=doc.getDocumentCatalog();
  PDDocumentNameDictionary names=new PDDocumentNameDictionary(doc.getDocumentCatalog());
  names.setEmbeddedFiles(efTree);
  catalog.setNames(names);
}","private void attachSampleFile(PDDocument doc) throws IOException {
  PDEmbeddedFilesNameTreeNode efTree=new PDEmbeddedFilesNameTreeNode();
  PDComplexFileSpecification fs=new PDComplexFileSpecification();
  fs.setFile(""String_Node_Str"");
  COSDictionary dict=fs.getCOSDictionary();
  dict.setName(""String_Node_Str"",""String_Node_Str"");
  dict.setString(""String_Node_Str"",""String_Node_Str"");
  String payload=""String_Node_Str"";
  InputStream is=new ByteArrayInputStream(payload.getBytes());
  PDEmbeddedFile ef=new PDEmbeddedFile(doc,is);
  ef.setSubtype(""String_Node_Str"");
  ef.setModDate(GregorianCalendar.getInstance());
  ef.setSize(payload.length());
  ef.setCreationDate(new GregorianCalendar());
  fs.setEmbeddedFile(ef);
  efTree.setNames(Collections.singletonMap(""String_Node_Str"",fs));
  PDDocumentCatalog catalog=doc.getDocumentCatalog();
  PDDocumentNameDictionary names=new PDDocumentNameDictionary(doc.getDocumentCatalog());
  names.setEmbeddedFiles(efTree);
  catalog.setNames(names);
  COSDictionary dict2=catalog.getCOSDictionary();
  COSArray array=new COSArray();
  array.add(fs.getCOSDictionary());
  dict2.setItem(""String_Node_Str"",array);
}",0.9254974548819992
22933,"/** 
 * This is what needs to be added to the RDF metadata - basically the name of the embedded  Zugferd file
 */
public XMPSchemaZugferd(org.apache.jempbox.xmp.XMPMetadata parent){
  super(parent);
  schema.setAttributeNS(NS_NAMESPACE,""String_Node_Str"",""String_Node_Str"");
  schema.removeAttributeNS(NS_NAMESPACE,""String_Node_Str"");
  schema.removeAttributeNS(NS_NAMESPACE,""String_Node_Str"");
  Element textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
  textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
  textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
  textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
}","/** 
 * This is what needs to be added to the RDF metadata - basically the name of the embedded Zugferd file
 */
public XMPSchemaZugferd(org.apache.jempbox.xmp.XMPMetadata parent){
  super(parent);
  schema.setAttributeNS(NS_NAMESPACE,""String_Node_Str"",""String_Node_Str"");
  schema.removeAttributeNS(NS_NAMESPACE,""String_Node_Str"");
  schema.removeAttributeNS(NS_NAMESPACE,""String_Node_Str"");
  Element textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
  textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
  textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
  textNode=schema.getOwnerDocument().createElement(""String_Node_Str"");
  XMLUtil.setStringValue(textNode,""String_Node_Str"");
  schema.appendChild(textNode);
}",0.9995147986414362
22934,"private void attachSampleFile(PDDocument doc) throws IOException {
  PDEmbeddedFilesNameTreeNode efTree=new PDEmbeddedFilesNameTreeNode();
  PDComplexFileSpecification fs=new PDComplexFileSpecification();
  fs.setFile(""String_Node_Str"");
  COSDictionary dict=fs.getCOSDictionary();
  dict.setName(""String_Node_Str"",""String_Node_Str"");
  dict.setString(""String_Node_Str"",""String_Node_Str"");
  String payload=""String_Node_Str"";
  InputStream is=new ByteArrayInputStream(payload.getBytes());
  PDEmbeddedFile ef=new PDEmbeddedFile(doc,is);
  ef.setSubtype(""String_Node_Str"");
  ef.setFile(fs);
  ef.setModDate(GregorianCalendar.getInstance());
  ef.setSize(payload.length());
  ef.setCreationDate(new GregorianCalendar());
  fs.setEmbeddedFile(ef);
  Map efMap=new HashMap();
  efMap.put(""String_Node_Str"",fs);
  efTree.setNames(efMap);
  PDDocumentCatalog catalog=doc.getDocumentCatalog();
  PDDocumentNameDictionary names=new PDDocumentNameDictionary(doc.getDocumentCatalog());
  names.setEmbeddedFiles(efTree);
  catalog.setNames(names);
  COSArray cosArray=new COSArray();
  cosArray.add(fs);
  catalog.getCOSDictionary().setItem(""String_Node_Str"",cosArray);
}","private void attachSampleFile(PDDocument doc) throws IOException {
  PDEmbeddedFilesNameTreeNode efTree=new PDEmbeddedFilesNameTreeNode();
  PDComplexFileSpecification fs=new PDComplexFileSpecification();
  fs.setFile(""String_Node_Str"");
  COSDictionary dict=fs.getCOSDictionary();
  dict.setName(""String_Node_Str"",""String_Node_Str"");
  dict.setString(""String_Node_Str"",""String_Node_Str"");
  String payload=""String_Node_Str"";
  InputStream is=new ByteArrayInputStream(payload.getBytes());
  PDEmbeddedFile ef=new PDEmbeddedFile(doc,is);
  ef.setSubtype(""String_Node_Str"");
  ef.setModDate(GregorianCalendar.getInstance());
  ef.setSize(payload.length());
  ef.setCreationDate(new GregorianCalendar());
  fs.setEmbeddedFile(ef);
  efTree.setNames(Collections.singletonMap(""String_Node_Str"",fs));
  PDDocumentCatalog catalog=doc.getDocumentCatalog();
  PDDocumentNameDictionary names=new PDDocumentNameDictionary(doc.getDocumentCatalog());
  names.setEmbeddedFiles(efTree);
  catalog.setNames(names);
  COSArray cosArray=new COSArray();
  cosArray.add(fs);
  catalog.getCOSDictionary().setItem(""String_Node_Str"",cosArray);
}",0.5413929040735874
22935,"private boolean checkCode(List<ValidationMessage> errors,Element element,String path,String code,String system,String display) throws TerminologyServiceException {
  long t=System.nanoTime();
  boolean ss=context.supportsSystem(system);
  txTime=txTime + (System.nanoTime() - t);
  if (ss) {
    t=System.nanoTime();
    ValidationResult s=context.validateCode(system,code,display);
    txTime=txTime + (System.nanoTime() - t);
    if (s == null)     return true;
    if (s.isOk()) {
      if (s.getMessage() != null)       warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
      return true;
    }
    if (s.getSeverity() == IssueSeverity.INFORMATION)     hint(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     if (s.getSeverity() == IssueSeverity.WARNING)     warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     return rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
    return true;
  }
 else   if (system.startsWith(""String_Node_Str"")) {
    if (Utilities.existsInList(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))     return true;
 else {
      CodeSystem cs=getCodeSystem(system);
      if (rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,cs != null,""String_Node_Str"" + system)) {
        ConceptDefinitionComponent def=getCodeDefinition(cs,code);
        if (warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,def != null,""String_Node_Str"" + system + ""String_Node_Str""+ code+ ""String_Node_Str""))         return warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,display == null || display.equals(def.getDisplay()),""String_Node_Str"" + def.getDisplay() + ""String_Node_Str"");
      }
      return false;
    }
  }
 else   if (context.isNoTerminologyServer() && Utilities.existsInList(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    return true;
  }
 else   if (startsWithButIsNot(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system);
    return false;
  }
 else {
    try {
      if (context.fetchResourceWithException(ValueSet.class,system) != null) {
        rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system + ""String_Node_Str"");
      }
      return true;
    }
 catch (    Exception e) {
      return true;
    }
  }
}","private boolean checkCode(List<ValidationMessage> errors,Element element,String path,String code,String system,String display) throws TerminologyServiceException {
  long t=System.nanoTime();
  boolean ss=context.supportsSystem(system);
  txTime=txTime + (System.nanoTime() - t);
  if (ss) {
    t=System.nanoTime();
    ValidationResult s=context.validateCode(system,code,display);
    txTime=txTime + (System.nanoTime() - t);
    if (s == null)     return true;
    if (s.isOk()) {
      if (s.getMessage() != null)       warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
      return true;
    }
    if (s.getSeverity() == IssueSeverity.INFORMATION)     hint(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     if (s.getSeverity() == IssueSeverity.WARNING)     warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     return rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
    return true;
  }
 else   if (system.startsWith(""String_Node_Str"")) {
    if (Utilities.existsInList(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))     return true;
 else {
      CodeSystem cs=getCodeSystem(system);
      if (rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,cs != null,""String_Node_Str"" + system)) {
        ConceptDefinitionComponent def=getCodeDefinition(cs,code);
        if (warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,def != null,""String_Node_Str"" + system + ""String_Node_Str""+ code+ ""String_Node_Str""))         return warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,display == null || display.equals(def.getDisplay()),""String_Node_Str"" + def.getDisplay() + ""String_Node_Str"");
      }
      return false;
    }
  }
 else   if (context.isNoTerminologyServer() && Utilities.existsInList(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    return true;
  }
 else   if (startsWithButIsNot(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system);
    return false;
  }
 else {
    try {
      if (context.fetchResourceWithException(ValueSet.class,system) != null) {
        rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system + ""String_Node_Str"");
      }
      return true;
    }
 catch (    Exception e) {
      return true;
    }
  }
}",0.9966367713004484
22936,"private void start(ValidatorHostContext hostContext,List<ValidationMessage> errors,Element resource,Element element,StructureDefinition defn,NodeStack stack) throws FHIRException, FHIRException, IOException {
  ResourceProfiles resourceProfiles=getResourceProfiles(element,stack);
  if (!resourceProfiles.isProcessed())   checkDeclaredProfiles(resourceProfiles,errors,resource,element,stack);
  if (!resourceProfiles.isProcessed()) {
    resourceProfiles.setProcessed();
    if (!resourceProfiles.hasProfiles() && (rule(errors,IssueType.STRUCTURE,element.line(),element.col(),stack.getLiteralPath(),defn.hasSnapshot(),""String_Node_Str""))) {
      validateElement(hostContext,errors,defn,defn.getSnapshot().getElement().get(0),null,null,resource,element,element.getName(),stack,false);
    }
    if (element.getType().equals(""String_Node_Str""))     validateBundle(errors,element,stack);
 else     if (element.getType().equals(""String_Node_Str""))     validateObservation(errors,element,stack);
 else     if (element.getType().equals(""String_Node_Str""))     validateQuestionannaireResponse(errors,element,stack);
  }
  for (  ProfileUsage profileUsage : resourceProfiles.uncheckedProfiles()) {
    profileUsage.setChecked();
    validateElement(hostContext,errors,profileUsage.getProfile(),profileUsage.getProfile().getSnapshot().getElement().get(0),null,null,resource,element,element.getName(),stack,false);
  }
}","private void start(ValidatorHostContext hostContext,List<ValidationMessage> errors,Element resource,Element element,StructureDefinition defn,NodeStack stack) throws FHIRException, FHIRException, IOException {
  ResourceProfiles resourceProfiles=getResourceProfiles(element,stack);
  if (!resourceProfiles.isProcessed())   checkDeclaredProfiles(resourceProfiles,errors,resource,element,stack);
  if (!resourceProfiles.isProcessed()) {
    resourceProfiles.setProcessed();
    if (!resourceProfiles.hasProfiles() && (rule(errors,IssueType.STRUCTURE,element.line(),element.col(),stack.getLiteralPath(),defn.hasSnapshot(),""String_Node_Str""))) {
      validateElement(hostContext,errors,defn,defn.getSnapshot().getElement().get(0),null,null,resource,element,element.getName(),stack,false);
    }
    if (element.getType().equals(""String_Node_Str""))     validateBundle(errors,element,stack);
 else     if (element.getType().equals(""String_Node_Str""))     validateObservation(errors,element,stack);
 else     if (element.getType().equals(""String_Node_Str""))     validateQuestionannaireResponse(errors,element,stack);
 else     if (element.getType().equals(""String_Node_Str""))     validateCodeSystem(errors,element,stack);
  }
  for (  ProfileUsage profileUsage : resourceProfiles.uncheckedProfiles()) {
    profileUsage.setChecked();
    validateElement(hostContext,errors,profileUsage.getProfile(),profileUsage.getProfile().getSnapshot().getElement().get(0),null,null,resource,element,element.getName(),stack,false);
  }
}",0.9641270925862658
22937,"private ValidationResult serverValidateCode(Parameters pin,boolean doCache) throws Exception {
  if (noTerminologyServer)   return new ValidationResult(null,""String_Node_Str"",TerminologyServiceErrorClass.NOSERVICE);
  String cacheName=doCache ? generateCacheName(pin) : null;
  ValidationResult res=loadFromCache(cacheName);
  if (res != null)   return res;
  tlog(""String_Node_Str"" + describeValidationParameters(pin));
  for (  ParametersParameterComponent pp : pin.getParameter())   if (pp.getName().equals(""String_Node_Str""))   throw new Error(""String_Node_Str"");
  if (expParameters == null)   throw new Exception(""String_Node_Str"");
  pin.addParameter().setName(""String_Node_Str"").setResource(expParameters);
  Parameters pout=txServer.operateType(ValueSet.class,""String_Node_Str"",pin);
  boolean ok=false;
  String message=""String_Node_Str"";
  String display=null;
  TerminologyServiceErrorClass err=TerminologyServiceErrorClass.UNKNOWN;
  for (  ParametersParameterComponent p : pout.getParameter()) {
    if (p.getName().equals(""String_Node_Str""))     ok=((BooleanType)p.getValue()).getValue().booleanValue();
 else     if (p.getName().equals(""String_Node_Str""))     message=((StringType)p.getValue()).getValue();
 else     if (p.getName().equals(""String_Node_Str""))     display=((StringType)p.getValue()).getValue();
 else     if (p.getName().equals(""String_Node_Str"")) {
      try {
        IssueType it=IssueType.fromCode(((StringType)p.getValue()).getValue());
        if (it == IssueType.UNKNOWN)         err=TerminologyServiceErrorClass.UNKNOWN;
 else         if (it == IssueType.NOTSUPPORTED)         err=TerminologyServiceErrorClass.VALUESET_UNSUPPORTED;
      }
 catch (      FHIRException e) {
      }
    }
  }
  if (!ok)   res=new ValidationResult(IssueSeverity.ERROR,message,err);
 else   if (message != null)   res=new ValidationResult(IssueSeverity.WARNING,message,new ConceptDefinitionComponent().setDisplay(display));
 else   if (display != null)   res=new ValidationResult(new ConceptDefinitionComponent().setDisplay(display));
 else   res=new ValidationResult(new ConceptDefinitionComponent());
  saveToCache(res,cacheName);
  return res;
}","private ValidationResult serverValidateCode(Parameters pin,boolean doCache) throws Exception {
  if (noTerminologyServer)   return new ValidationResult(null,""String_Node_Str"",TerminologyServiceErrorClass.NOSERVICE);
  String cacheName=doCache ? generateCacheName(pin) : null;
  ValidationResult res=loadFromCache(cacheName);
  if (res != null)   return res;
  tlog(""String_Node_Str"" + describeValidationParameters(pin));
  for (  ParametersParameterComponent pp : pin.getParameter())   if (pp.getName().equals(""String_Node_Str""))   throw new Error(""String_Node_Str"");
  if (expParameters == null)   throw new Exception(""String_Node_Str"");
  pin.addParameter().setName(""String_Node_Str"").setResource(expParameters);
  Parameters pout=txServer.operateType(ValueSet.class,""String_Node_Str"",pin);
  boolean ok=false;
  String message=""String_Node_Str"";
  String display=null;
  TerminologyServiceErrorClass err=TerminologyServiceErrorClass.UNKNOWN;
  for (  ParametersParameterComponent p : pout.getParameter()) {
    if (p.getName().equals(""String_Node_Str""))     ok=((BooleanType)p.getValue()).getValue().booleanValue();
 else     if (p.getName().equals(""String_Node_Str""))     message=((StringType)p.getValue()).getValue();
 else     if (p.getName().equals(""String_Node_Str""))     display=((StringType)p.getValue()).getValue();
 else     if (p.getName().equals(""String_Node_Str"")) {
      try {
        IssueType it=IssueType.fromCode(((StringType)p.getValue()).getValue());
        if (it == IssueType.UNKNOWN)         err=TerminologyServiceErrorClass.UNKNOWN;
 else         if (it == IssueType.NOTSUPPORTED)         err=TerminologyServiceErrorClass.VALUESET_UNSUPPORTED;
      }
 catch (      FHIRException e) {
      }
    }
  }
  if (!ok)   res=new ValidationResult(IssueSeverity.ERROR,message,err);
 else   if (message != null && !message.equals(""String_Node_Str""))   res=new ValidationResult(IssueSeverity.WARNING,message,new ConceptDefinitionComponent().setDisplay(display));
 else   if (display != null)   res=new ValidationResult(new ConceptDefinitionComponent().setDisplay(display));
 else   res=new ValidationResult(new ConceptDefinitionComponent());
  saveToCache(res,cacheName);
  return res;
}",0.9913122999542752
22938,"private String conceptId() throws FHIRException {
  StringBuffer res=new StringBuffer(Utilities.padLeft(""String_Node_Str"",' ',18));
  int i=0;
  while (peek() >= '0' && peek() <= '9') {
    res.setCharAt(i,next());
    i++;
  }
  rule(i > 0,""String_Node_Str"" + peekDisp() + ""String_Node_Str"");
  return res.substring(0,i);
}","private String conceptId() throws FHIRException {
  StringBuffer res=new StringBuffer(Utilities.padLeft(""String_Node_Str"",' ',18));
  int i=0;
  while (peek() >= '0' && peek() <= '9') {
    res.setCharAt(i,next());
    i++;
  }
  rule(i > 0,""String_Node_Str"" + peekDisp() + ""String_Node_Str""+ source+ ""String_Node_Str"");
  return res.substring(0,i);
}",0.96
22939,"/** 
 * @param value {@link #url} (An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which this search parameter is (or will be) published.). This is the underlying object with id, value and extensions. The accessor ""getUrl"" gives direct access to the value
 */
public SearchParameter setUrlElement(UriType value){
  this.url=value;
  return this;
}","/** 
 * @param value {@link #url} (An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.). This is the underlying object with id, value and extensions. The accessor ""getUrl"" gives direct access to the value
 */
public SearchParameter setUrlElement(UriType value){
  this.url=value;
  return this;
}",0.8608
22940,"public String getSystem(){
switch (this) {
case MISSING:
    return ""String_Node_Str"";
case EXACT:
  return ""String_Node_Str"";
case CONTAINS:
return ""String_Node_Str"";
case NOT:
return ""String_Node_Str"";
case TEXT:
return ""String_Node_Str"";
case IN:
return ""String_Node_Str"";
case NOTIN:
return ""String_Node_Str"";
case BELOW:
return ""String_Node_Str"";
case ABOVE:
return ""String_Node_Str"";
case TYPE:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}","public String getSystem(){
switch (this) {
case MISSING:
    return ""String_Node_Str"";
case EXACT:
  return ""String_Node_Str"";
case CONTAINS:
return ""String_Node_Str"";
case NOT:
return ""String_Node_Str"";
case TEXT:
return ""String_Node_Str"";
case IN:
return ""String_Node_Str"";
case NOTIN:
return ""String_Node_Str"";
case BELOW:
return ""String_Node_Str"";
case ABOVE:
return ""String_Node_Str"";
case TYPE:
return ""String_Node_Str"";
case IDENTIFIER:
return ""String_Node_Str"";
case OFTYPE:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}",0.9191321499013808
22941,"public String toCode(SearchModifierCode code){
  if (code == SearchModifierCode.MISSING)   return ""String_Node_Str"";
  if (code == SearchModifierCode.EXACT)   return ""String_Node_Str"";
  if (code == SearchModifierCode.CONTAINS)   return ""String_Node_Str"";
  if (code == SearchModifierCode.NOT)   return ""String_Node_Str"";
  if (code == SearchModifierCode.TEXT)   return ""String_Node_Str"";
  if (code == SearchModifierCode.IN)   return ""String_Node_Str"";
  if (code == SearchModifierCode.NOTIN)   return ""String_Node_Str"";
  if (code == SearchModifierCode.BELOW)   return ""String_Node_Str"";
  if (code == SearchModifierCode.ABOVE)   return ""String_Node_Str"";
  if (code == SearchModifierCode.TYPE)   return ""String_Node_Str"";
  return ""String_Node_Str"";
}","public String toCode(SearchModifierCode code){
  if (code == SearchModifierCode.MISSING)   return ""String_Node_Str"";
  if (code == SearchModifierCode.EXACT)   return ""String_Node_Str"";
  if (code == SearchModifierCode.CONTAINS)   return ""String_Node_Str"";
  if (code == SearchModifierCode.NOT)   return ""String_Node_Str"";
  if (code == SearchModifierCode.TEXT)   return ""String_Node_Str"";
  if (code == SearchModifierCode.IN)   return ""String_Node_Str"";
  if (code == SearchModifierCode.NOTIN)   return ""String_Node_Str"";
  if (code == SearchModifierCode.BELOW)   return ""String_Node_Str"";
  if (code == SearchModifierCode.ABOVE)   return ""String_Node_Str"";
  if (code == SearchModifierCode.TYPE)   return ""String_Node_Str"";
  if (code == SearchModifierCode.IDENTIFIER)   return ""String_Node_Str"";
  if (code == SearchModifierCode.OFTYPE)   return ""String_Node_Str"";
  return ""String_Node_Str"";
}",0.913939393939394
22942,"/** 
 * @return The type of value a search parameter refers to, and how the content is interpreted.
 */
public SearchParamType getType(){
  return this.type == null ? null : this.type.getValue();
}","/** 
 * @return The type of value that a search parameter may contain, and how the content is interpreted.
 */
public SearchParamType getType(){
  return this.type == null ? null : this.type.getValue();
}",0.9376558603491272
22943,"/** 
 * @return {@link #type} (The type of value a search parameter refers to, and how the content is interpreted.). This is the underlying object with id, value and extensions. The accessor ""getType"" gives direct access to the value
 */
public Enumeration<SearchParamType> getTypeElement(){
  if (this.type == null)   if (Configuration.errorOnAutoCreate())   throw new Error(""String_Node_Str"");
 else   if (Configuration.doAutoCreate())   this.type=new Enumeration<SearchParamType>(new SearchParamTypeEnumFactory());
  return this.type;
}","/** 
 * @return {@link #type} (The type of value that a search parameter may contain, and how the content is interpreted.). This is the underlying object with id, value and extensions. The accessor ""getType"" gives direct access to the value
 */
public Enumeration<SearchParamType> getTypeElement(){
  if (this.type == null)   if (Configuration.errorOnAutoCreate())   throw new Error(""String_Node_Str"");
 else   if (Configuration.doAutoCreate())   this.type=new Enumeration<SearchParamType>(new SearchParamTypeEnumFactory());
  return this.type;
}",0.9419354838709676
22944,"public SearchModifierCode fromCode(String codeString) throws IllegalArgumentException {
  if (codeString == null || ""String_Node_Str"".equals(codeString))   if (codeString == null || ""String_Node_Str"".equals(codeString))   return null;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.MISSING;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.EXACT;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.CONTAINS;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.NOT;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.TEXT;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.IN;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.NOTIN;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.BELOW;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.ABOVE;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.TYPE;
  throw new IllegalArgumentException(""String_Node_Str"" + codeString + ""String_Node_Str"");
}","public SearchModifierCode fromCode(String codeString) throws IllegalArgumentException {
  if (codeString == null || ""String_Node_Str"".equals(codeString))   if (codeString == null || ""String_Node_Str"".equals(codeString))   return null;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.MISSING;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.EXACT;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.CONTAINS;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.NOT;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.TEXT;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.IN;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.NOTIN;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.BELOW;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.ABOVE;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.TYPE;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.IDENTIFIER;
  if (""String_Node_Str"".equals(codeString))   return SearchModifierCode.OFTYPE;
  throw new IllegalArgumentException(""String_Node_Str"" + codeString + ""String_Node_Str"");
}",0.931438127090301
22945,"/** 
 * @param value An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which this search parameter is (or will be) published.
 */
public SearchParameter setUrl(String value){
  if (this.url == null)   this.url=new UriType();
  this.url.setValue(value);
  return this;
}","/** 
 * @param value An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.
 */
public SearchParameter setUrl(String value){
  if (this.url == null)   this.url=new UriType();
  this.url.setValue(value);
  return this;
}",0.8403669724770643
22946,"/** 
 * @return An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which this search parameter is (or will be) published.
 */
public String getUrl(){
  return this.url == null ? null : this.url.getValue();
}","/** 
 * @return An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.
 */
public String getUrl(){
  return this.url == null ? null : this.url.getValue();
}",0.8195020746887967
22947,"public Enumeration<SearchModifierCode> fromType(Base code) throws FHIRException {
  if (code == null)   return null;
  if (code.isEmpty())   return new Enumeration<SearchModifierCode>(this);
  String codeString=((PrimitiveType)code).asStringValue();
  if (codeString == null || ""String_Node_Str"".equals(codeString))   return null;
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.MISSING);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.EXACT);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.CONTAINS);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.NOT);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.TEXT);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.IN);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.NOTIN);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.BELOW);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.ABOVE);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.TYPE);
  throw new FHIRException(""String_Node_Str"" + codeString + ""String_Node_Str"");
}","public Enumeration<SearchModifierCode> fromType(Base code) throws FHIRException {
  if (code == null)   return null;
  if (code.isEmpty())   return new Enumeration<SearchModifierCode>(this);
  String codeString=((PrimitiveType)code).asStringValue();
  if (codeString == null || ""String_Node_Str"".equals(codeString))   return null;
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.MISSING);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.EXACT);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.CONTAINS);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.NOT);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.TEXT);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.IN);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.NOTIN);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.BELOW);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.ABOVE);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.TYPE);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.IDENTIFIER);
  if (""String_Node_Str"".equals(codeString))   return new Enumeration<SearchModifierCode>(this,SearchModifierCode.OFTYPE);
  throw new FHIRException(""String_Node_Str"" + codeString + ""String_Node_Str"");
}",0.9288582903040734
22948,"/** 
 * @param value {@link #type} (The type of value a search parameter refers to, and how the content is interpreted.). This is the underlying object with id, value and extensions. The accessor ""getType"" gives direct access to the value
 */
public SearchParameter setTypeElement(Enumeration<SearchParamType> value){
  this.type=value;
  return this;
}","/** 
 * @param value {@link #type} (The type of value that a search parameter may contain, and how the content is interpreted.). This is the underlying object with id, value and extensions. The accessor ""getType"" gives direct access to the value
 */
public SearchParameter setTypeElement(Enumeration<SearchParamType> value){
  this.type=value;
  return this;
}",0.91164095371669
22949,"/** 
 * @return {@link #url} (An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which this search parameter is (or will be) published.). This is the underlying object with id, value and extensions. The accessor ""getUrl"" gives direct access to the value
 */
public UriType getUrlElement(){
  if (this.url == null)   if (Configuration.errorOnAutoCreate())   throw new Error(""String_Node_Str"");
 else   if (Configuration.doAutoCreate())   this.url=new UriType();
  return this.url;
}","/** 
 * @return {@link #url} (An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.). This is the underlying object with id, value and extensions. The accessor ""getUrl"" gives direct access to the value
 */
public UriType getUrlElement(){
  if (this.url == null)   if (Configuration.errorOnAutoCreate())   throw new Error(""String_Node_Str"");
 else   if (Configuration.doAutoCreate())   this.url=new UriType();
  return this.url;
}",0.8849206349206349
22950,"/** 
 * @param value The type of value a search parameter refers to, and how the content is interpreted.
 */
public SearchParameter setType(SearchParamType value){
  if (this.type == null)   this.type=new Enumeration<SearchParamType>(new SearchParamTypeEnumFactory());
  this.type.setValue(value);
  return this;
}","/** 
 * @param value The type of value that a search parameter may contain, and how the content is interpreted.
 */
public SearchParameter setType(SearchParamType value){
  if (this.type == null)   this.type=new Enumeration<SearchParamType>(new SearchParamTypeEnumFactory());
  this.type.setValue(value);
  return this;
}",0.9007874015748032
22951,"public String getDisplay(){
switch (this) {
case MISSING:
    return ""String_Node_Str"";
case EXACT:
  return ""String_Node_Str"";
case CONTAINS:
return ""String_Node_Str"";
case NOT:
return ""String_Node_Str"";
case TEXT:
return ""String_Node_Str"";
case IN:
return ""String_Node_Str"";
case NOTIN:
return ""String_Node_Str"";
case BELOW:
return ""String_Node_Str"";
case ABOVE:
return ""String_Node_Str"";
case TYPE:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}","public String getDisplay(){
switch (this) {
case MISSING:
    return ""String_Node_Str"";
case EXACT:
  return ""String_Node_Str"";
case CONTAINS:
return ""String_Node_Str"";
case NOT:
return ""String_Node_Str"";
case TEXT:
return ""String_Node_Str"";
case IN:
return ""String_Node_Str"";
case NOTIN:
return ""String_Node_Str"";
case BELOW:
return ""String_Node_Str"";
case ABOVE:
return ""String_Node_Str"";
case TYPE:
return ""String_Node_Str"";
case IDENTIFIER:
return ""String_Node_Str"";
case OFTYPE:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}",0.9192913385826772
22952,"private IContextResourceLoader loaderForVersion(){
  if (Utilities.noString(version))   return null;
  if (version.equals(""String_Node_Str""))   return new R2ToR4Loader();
  if (version.equals(""String_Node_Str""))   return new R3ToR4Loader();
  if (version.equals(""String_Node_Str""))   return new R3ToR4Loader();
  return null;
}","private IContextResourceLoader loaderForVersion(){
  if (Utilities.noString(version))   return null;
  if (version.equals(""String_Node_Str""))   return new R2ToR4Loader();
  if (version.equals(""String_Node_Str""))   return new R2016MayToR4Loader();
  if (version.equals(""String_Node_Str""))   return new R3ToR4Loader();
  return null;
}",0.7787878787878788
22953,"@Override public BindingResolution resolveBinding(StructureDefinition profile,ElementDefinitionBindingComponent binding,String path){
  BindingResolution br=new BindingResolution();
  if (!binding.hasValueSet()) {
    br.url=specPath(""String_Node_Str"");
    br.display=""String_Node_Str"";
  }
 else {
    String ref=binding.getValueSet();
    if (ref.startsWith(""String_Node_Str"")) {
      br.url=specPath(""String_Node_Str"" + ref.substring(32) + ""String_Node_Str"");
      br.display=ref.substring(32);
    }
 else     if (ref.startsWith(""String_Node_Str"")) {
      ValueSet vs=context.fetchResource(ValueSet.class,makeCanonical(ref));
      if (vs == null) {
        br.url=ref;
        if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else {
          br.url=ref.substring(9) + ""String_Node_Str"";
          br.display=ref.substring(9);
          brokenLinkWarning(path,ref);
        }
      }
 else {
        br.url=vs.getUserString(""String_Node_Str"");
        br.display=vs.getName();
      }
    }
 else {
      if (ref.startsWith(""String_Node_Str"")) {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs != null) {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
 else {
          br.display=ref.substring(29);
          br.url=ref.substring(29) + ""String_Node_Str"";
          brokenLinkWarning(path,ref);
        }
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        String code=tail(ref);
        if (code.startsWith(""String_Node_Str"")) {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
 else {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
      }
 else {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs == null) {
          br.url=ref + ""String_Node_Str"";
          br.display=ref;
          brokenLinkWarning(path,ref);
        }
 else         if (ref.contains(""String_Node_Str"")) {
          br.url=vs.getUserString(""String_Node_Str"");
          if (br.url == null) {
            System.out.println(""String_Node_Str"" + ref);
            br.url=vs.getUserString(""String_Node_Str"");
          }
          br.display=vs.getName();
        }
 else {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
      }
    }
  }
  return br;
}","@Override public BindingResolution resolveBinding(StructureDefinition profile,ElementDefinitionBindingComponent binding,String path){
  BindingResolution br=new BindingResolution();
  if (!binding.hasValueSet()) {
    br.url=specPath(""String_Node_Str"");
    br.display=""String_Node_Str"";
  }
 else {
    String ref=binding.getValueSet();
    if (ref.startsWith(""String_Node_Str"")) {
      br.url=specPath(""String_Node_Str"" + ref.substring(32) + ""String_Node_Str"");
      br.display=ref.substring(32);
    }
 else     if (ref.startsWith(""String_Node_Str"")) {
      ValueSet vs=context.fetchResource(ValueSet.class,makeCanonical(ref));
      if (vs == null) {
        br.url=ref;
        if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else {
          br.url=ref.substring(9) + ""String_Node_Str"";
          br.display=ref.substring(9);
          brokenLinkWarning(path,ref);
        }
      }
 else {
        br.url=vs.getUserString(""String_Node_Str"");
        br.display=vs.getName();
      }
    }
 else {
      if (ref.startsWith(""String_Node_Str"")) {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs != null) {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
 else {
          String vsr=VersionConvertorConstants.vsToRef(ref);
          if (vsr != null) {
            br.display=ref.substring(29);
            br.url=vsr;
          }
 else {
            br.display=ref.substring(29);
            br.url=ref.substring(29) + ""String_Node_Str"";
            brokenLinkWarning(path,ref);
          }
        }
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        String code=tail(ref);
        if (code.startsWith(""String_Node_Str"")) {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
 else {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
      }
 else {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs == null) {
          br.url=ref + ""String_Node_Str"";
          br.display=ref;
          brokenLinkWarning(path,ref);
        }
 else         if (ref.contains(""String_Node_Str"")) {
          br.url=vs.getUserString(""String_Node_Str"");
          if (br.url == null) {
            System.out.println(""String_Node_Str"" + ref);
            br.url=vs.getUserString(""String_Node_Str"");
          }
          br.display=vs.getName();
        }
 else {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
      }
    }
  }
  return br;
}",0.968712029161604
22954,"private void loadIg(JsonObject dep) throws Exception {
  String name=str(dep,""String_Node_Str"");
  if (!Utilities.isToken(name))   throw new Exception(""String_Node_Str"" + name + ""String_Node_Str"");
  String canonical=str(dep,""String_Node_Str"");
  if (Utilities.noString(canonical))   throw new Exception(""String_Node_Str"" + name);
  String igver=ostr(dep,""String_Node_Str"");
  if (Utilities.noString(igver))   throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ canonical+ ""String_Node_Str"");
  String packageId=ostr(dep,""String_Node_Str"");
  if (Utilities.noString(packageId))   packageId=pcm.getPackageId(canonical);
  NpmPackage pi=packageId == null ? null : pcm.loadPackageCache(packageId,igver);
  if (pi == null) {
    pi=resolveDependency(canonical,packageId,igver);
    if (pi == null) {
      if (Utilities.noString(packageId))       throw new Exception(""String_Node_Str"" + canonical + ""String_Node_Str"");
 else       throw new Exception(""String_Node_Str"" + packageId + ""String_Node_Str""+ version);
    }
  }
  log(""String_Node_Str"" + name + ""String_Node_Str""+ canonical+ ""String_Node_Str""+ packageId+ ""String_Node_Str""+ igver);
  if (ostr(dep,""String_Node_Str"") == null && packageId != null)   dep.addProperty(""String_Node_Str"",packageId);
  SpecMapManager igm=new SpecMapManager(TextFile.streamToBytes(pi.load(""String_Node_Str"",""String_Node_Str"")),pi.getNpm().getAsJsonObject(""String_Node_Str"").get(""String_Node_Str"").getAsString());
  igm.setName(name);
  igm.setBase(canonical);
  specMaps.add(igm);
  if (!version.equals(igm.getVersion())) {
    log(""String_Node_Str"" + version + ""String_Node_Str""+ name+ ""String_Node_Str""+ igm.getVersion()+ ""String_Node_Str"");
  }
  for (  String fn : pi.list(""String_Node_Str"")) {
    if (fn.endsWith(""String_Node_Str"") && fn.contains(""String_Node_Str"")) {
      Resource r;
      if (igm.getVersion().equals(""String_Node_Str"") || igm.getVersion().equals(""String_Node_Str"")) {
        org.hl7.fhir.dstu3.model.Resource res=new org.hl7.fhir.dstu3.formats.JsonParser().parse(pi.load(""String_Node_Str"",fn));
        r=VersionConvertor_30_40.convertResource(res,true);
      }
 else       if (igm.getVersion().equals(""String_Node_Str"")) {
        org.hl7.fhir.dstu2016may.model.Resource res=new org.hl7.fhir.dstu2016may.formats.JsonParser().parse(pi.load(""String_Node_Str"",fn));
        r=VersionConvertor_14_40.convertResource(res);
      }
 else       if (igm.getVersion().equals(""String_Node_Str"")) {
        org.hl7.fhir.dstu2.model.Resource res=new org.hl7.fhir.dstu2.formats.JsonParser().parse(pi.load(""String_Node_Str"",fn));
        VersionConvertorAdvisor40 advisor=new IGR2ConvertorAdvisor();
        r=new VersionConvertor_10_40(advisor).convertResource(res);
      }
 else       if (igm.getVersion().equals(Constants.VERSION)) {
        r=new JsonParser().parse(pi.load(""String_Node_Str"",fn));
      }
 else       throw new Exception(""String_Node_Str"" + igm.getVersion());
      if (r != null) {
        if (r instanceof MetadataResource) {
          String u=((MetadataResource)r).getUrl();
          if (u != null) {
            String p=igm.getPath(u);
            if (p == null)             throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ u);
            r.setUserData(""String_Node_Str"",canonical + ""String_Node_Str"" + igpkp.doReplacements(p,r,null,null));
            String v=((MetadataResource)r).getVersion();
            if (v != null) {
              u=u + ""String_Node_Str"" + v;
              p=igm.getPath(u);
              if (p == null)               System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ u);
              r.setUserData(""String_Node_Str"",canonical + ""String_Node_Str"" + igpkp.doReplacements(p,r,null,null));
            }
          }
          context.cacheResource(r);
        }
      }
    }
  }
}","private void loadIg(JsonObject dep) throws Exception {
  String name=str(dep,""String_Node_Str"");
  if (!Utilities.isToken(name))   throw new Exception(""String_Node_Str"" + name + ""String_Node_Str"");
  String canonical=str(dep,""String_Node_Str"");
  if (Utilities.noString(canonical))   throw new Exception(""String_Node_Str"" + name);
  String igver=ostr(dep,""String_Node_Str"");
  if (Utilities.noString(igver))   throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ canonical+ ""String_Node_Str"");
  String packageId=ostr(dep,""String_Node_Str"");
  if (Utilities.noString(packageId))   packageId=pcm.getPackageId(canonical);
  NpmPackage pi=packageId == null ? null : pcm.loadPackageCache(packageId,igver);
  if (pi == null) {
    pi=resolveDependency(canonical,packageId,igver);
    if (pi == null) {
      if (Utilities.noString(packageId))       throw new Exception(""String_Node_Str"" + canonical + ""String_Node_Str"");
 else       throw new Exception(""String_Node_Str"" + packageId + ""String_Node_Str""+ version);
    }
  }
  log(""String_Node_Str"" + name + ""String_Node_Str""+ canonical+ ""String_Node_Str""+ packageId+ ""String_Node_Str""+ igver);
  if (ostr(dep,""String_Node_Str"") == null && packageId != null)   dep.addProperty(""String_Node_Str"",packageId);
  SpecMapManager igm=new SpecMapManager(TextFile.streamToBytes(pi.load(""String_Node_Str"",""String_Node_Str"")),pi.getNpm().getAsJsonObject(""String_Node_Str"").get(""String_Node_Str"").getAsString());
  igm.setName(name);
  igm.setBase(canonical);
  specMaps.add(igm);
  if (!version.equals(igm.getVersion())) {
    log(""String_Node_Str"" + version + ""String_Node_Str""+ name+ ""String_Node_Str""+ igm.getVersion()+ ""String_Node_Str"");
  }
  for (  String fn : pi.list(""String_Node_Str"")) {
    if (fn.endsWith(""String_Node_Str"") && fn.contains(""String_Node_Str"")) {
      Resource r=null;
      String t=fn.substring(0,fn.indexOf(""String_Node_Str""));
      if (Utilities.existsInList(t,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
        if (igm.getVersion().equals(""String_Node_Str"") || igm.getVersion().equals(""String_Node_Str"")) {
          org.hl7.fhir.dstu3.model.Resource res=new org.hl7.fhir.dstu3.formats.JsonParser().parse(pi.load(""String_Node_Str"",fn));
          r=VersionConvertor_30_40.convertResource(res,true);
        }
 else         if (igm.getVersion().equals(""String_Node_Str"")) {
          org.hl7.fhir.dstu2016may.model.Resource res=new org.hl7.fhir.dstu2016may.formats.JsonParser().parse(pi.load(""String_Node_Str"",fn));
          r=VersionConvertor_14_40.convertResource(res);
        }
 else         if (igm.getVersion().equals(""String_Node_Str"")) {
          org.hl7.fhir.dstu2.model.Resource res=new org.hl7.fhir.dstu2.formats.JsonParser().parse(pi.load(""String_Node_Str"",fn));
          VersionConvertorAdvisor40 advisor=new IGR2ConvertorAdvisor();
          r=new VersionConvertor_10_40(advisor).convertResource(res);
        }
 else         if (igm.getVersion().equals(Constants.VERSION)) {
          r=new JsonParser().parse(pi.load(""String_Node_Str"",fn));
        }
 else         throw new Exception(""String_Node_Str"" + igm.getVersion());
      }
      if (r != null) {
        if (r instanceof MetadataResource) {
          String u=((MetadataResource)r).getUrl();
          if (u != null) {
            String p=igm.getPath(u);
            if (p == null)             throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ u);
            r.setUserData(""String_Node_Str"",canonical + ""String_Node_Str"" + igpkp.doReplacements(p,r,null,null));
            String v=((MetadataResource)r).getVersion();
            if (v != null) {
              u=u + ""String_Node_Str"" + v;
              p=igm.getPath(u);
              if (p == null)               System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ u);
              r.setUserData(""String_Node_Str"",canonical + ""String_Node_Str"" + igpkp.doReplacements(p,r,null,null));
            }
          }
          context.cacheResource(r);
        }
      }
    }
  }
}",0.961104140526976
22955,"public static void main(String[] args) throws Exception {
  int exitCode=0;
  if (hasParam(args,""String_Node_Str"") || args.length == 0) {
    runGUI();
    return;
  }
 else   if (hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"")|| hasParam(args,""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else   if (hasParam(args,""String_Node_Str"")) {
    IGPack2NpmConvertor conv=new IGPack2NpmConvertor();
    conv.setSource(getNamedParam(args,""String_Node_Str""));
    conv.setDest(getNamedParam(args,""String_Node_Str""));
    conv.setPackageId(getNamedParam(args,""String_Node_Str""));
    conv.setVersionIg(getNamedParam(args,""String_Node_Str""));
    conv.setLicense(getNamedParam(args,""String_Node_Str""));
    conv.execute();
  }
 else   if (hasParam(args,""String_Node_Str"")) {
    int i=1;
    for (    String ig : TextFile.fileToString(getNamedParam(args,""String_Node_Str"")).split(""String_Node_Str"")) {
      if (!ig.startsWith(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + ig);
        Publisher self=new Publisher();
        self.setConfigFile(determineActualIG(ig));
        self.setTxServer(getNamedParam(args,""String_Node_Str""));
        if (hasParam(args,""String_Node_Str""))         self.setCacheOption(CacheOption.CLEAR_ALL);
 else         if (hasParam(args,""String_Node_Str""))         self.setCacheOption(CacheOption.CLEAR_ERRORS);
 else         self.setCacheOption(CacheOption.LEAVE);
        try {
          self.execute();
        }
 catch (        Exception e) {
          exitCode=1;
          System.out.println(""String_Node_Str"" + e.getMessage());
          System.out.println(""String_Node_Str"");
          System.out.println(""String_Node_Str"");
          e.printStackTrace();
          break;
        }
        TextFile.stringToFile(buildReport(ig,null,self.filelog.toString(),Utilities.path(self.qaDir,""String_Node_Str"")),Utilities.path(System.getProperty(""String_Node_Str""),""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str""));
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        i++;
      }
    }
  }
 else {
    Publisher self=new Publisher();
    System.out.println(""String_Node_Str"" + self.getToolingVersion() + ""String_Node_Str""+ Constants.VERSION+ ""String_Node_Str""+ Constants.REVISION+ ""String_Node_Str""+ nowAsString());
    System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ toMB(Runtime.getRuntime().maxMemory())+ ""String_Node_Str"");
    if (hasParam(args,""String_Node_Str"")) {
      self.setSourceDir(getNamedParam(args,""String_Node_Str""));
      self.setDestDir(getNamedParam(args,""String_Node_Str""));
    }
 else     if (!hasParam(args,""String_Node_Str"") && args.length == 1 && new File(args[0]).exists()) {
      self.setConfigFile(args[0]);
    }
 else     if (hasParam(args,""String_Node_Str"")) {
      IniFile ini=new IniFile(""String_Node_Str"");
      String last=ini.getStringProperty(""String_Node_Str"",""String_Node_Str"");
      boolean ok=false;
      if (Utilities.noString(last)) {
        while (!ok) {
          System.out.print(""String_Node_Str"");
          BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
          last=reader.readLine();
          if (new File(last).exists())           ok=true;
 else           System.out.println(""String_Node_Str"" + last);
        }
      }
 else {
        while (!ok) {
          System.out.print(""String_Node_Str"" + last + ""String_Node_Str"");
          BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
          String nlast=reader.readLine();
          if (Utilities.noString(nlast))           nlast=last;
          if (new File(nlast).exists()) {
            ok=true;
            last=nlast;
          }
 else           System.out.println(""String_Node_Str"" + nlast);
        }
      }
      ini.setStringProperty(""String_Node_Str"",""String_Node_Str"",last,null);
      ini.save();
      if (new File(last).isDirectory())       self.setConfigFile(Utilities.path(last,""String_Node_Str""));
 else       self.setConfigFile(last);
    }
 else {
      self.setConfigFile(determineActualIG(getNamedParam(args,""String_Node_Str"")));
      if (Utilities.noString(self.getConfigFile()))       throw new Exception(""String_Node_Str"");
      if (!(new File(self.getConfigFile()).isAbsolute()))       self.setConfigFile(Utilities.path(System.getProperty(""String_Node_Str""),self.getConfigFile()));
    }
    self.setJekyllCommand(getNamedParam(args,""String_Node_Str""));
    self.setIgPack(getNamedParam(args,""String_Node_Str""));
    String proxy=getNamedParam(args,""String_Node_Str"");
    if (!Utilities.noString(proxy)) {
      String[] p=proxy.split(""String_Node_Str"");
      System.setProperty(""String_Node_Str"",p[0]);
      System.setProperty(""String_Node_Str"",p[1]);
    }
    self.setTxServer(getNamedParam(args,""String_Node_Str""));
    self.setPackagesFolder(getNamedParam(args,""String_Node_Str""));
    if (hasNamedParam(args,""String_Node_Str""))     self.setMode(IGBuildMode.AUTOBUILD);
    self.watch=hasParam(args,""String_Node_Str"");
    self.debug=hasParam(args,""String_Node_Str"");
    self.cacheVersion=hasParam(args,""String_Node_Str"");
    if (hasParam(args,""String_Node_Str""))     self.setCacheOption(CacheOption.CLEAR_ALL);
 else     if (hasParam(args,""String_Node_Str""))     self.setCacheOption(CacheOption.CLEAR_ERRORS);
 else     self.setCacheOption(CacheOption.LEAVE);
    try {
      self.execute();
    }
 catch (    Exception e) {
      exitCode=1;
      self.log(""String_Node_Str"" + e.getMessage());
      self.log(""String_Node_Str"");
      self.log(""String_Node_Str"");
      self.log(""String_Node_Str"");
      self.log(""String_Node_Str"");
      e.printStackTrace();
      for (      StackTraceElement st : e.getStackTrace()) {
        self.filelog.append(st.toString());
      }
      exitCode=1;
    }
 finally {
      if (self.mode == IGBuildMode.MANUAL) {
        TextFile.stringToFile(buildReport(getNamedParam(args,""String_Node_Str""),getNamedParam(args,""String_Node_Str""),self.filelog.toString(),Utilities.path(self.qaDir,""String_Node_Str"")),Utilities.path(System.getProperty(""String_Node_Str""),""String_Node_Str""));
      }
    }
  }
  System.exit(exitCode);
}","public static void main(String[] args) throws Exception {
  int exitCode=0;
  if (hasParam(args,""String_Node_Str"") || args.length == 0) {
    runGUI();
    return;
  }
 else   if (hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"")|| hasParam(args,""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else   if (hasParam(args,""String_Node_Str"")) {
    IGPack2NpmConvertor conv=new IGPack2NpmConvertor();
    conv.setSource(getNamedParam(args,""String_Node_Str""));
    conv.setDest(getNamedParam(args,""String_Node_Str""));
    conv.setPackageId(getNamedParam(args,""String_Node_Str""));
    conv.setVersionIg(getNamedParam(args,""String_Node_Str""));
    conv.setLicense(getNamedParam(args,""String_Node_Str""));
    conv.execute();
  }
 else   if (hasParam(args,""String_Node_Str"")) {
    int i=1;
    for (    String ig : TextFile.fileToString(getNamedParam(args,""String_Node_Str"")).split(""String_Node_Str"")) {
      if (!ig.startsWith(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + ig);
        Publisher self=new Publisher();
        self.setConfigFile(determineActualIG(ig));
        self.setTxServer(getNamedParam(args,""String_Node_Str""));
        if (hasParam(args,""String_Node_Str""))         self.setCacheOption(CacheOption.CLEAR_ALL);
 else         if (hasParam(args,""String_Node_Str""))         self.setCacheOption(CacheOption.CLEAR_ERRORS);
 else         self.setCacheOption(CacheOption.LEAVE);
        try {
          self.execute();
        }
 catch (        Exception e) {
          exitCode=1;
          System.out.println(""String_Node_Str"" + e.getMessage());
          System.out.println(""String_Node_Str"");
          System.out.println(""String_Node_Str"");
          e.printStackTrace();
          break;
        }
        TextFile.stringToFile(buildReport(ig,null,self.filelog.toString(),Utilities.path(self.qaDir,""String_Node_Str"")),Utilities.path(System.getProperty(""String_Node_Str""),""String_Node_Str"" + Integer.toString(i) + ""String_Node_Str""));
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        i++;
      }
    }
  }
 else {
    Publisher self=new Publisher();
    System.out.println(""String_Node_Str"" + self.getToolingVersion() + ""String_Node_Str""+ Constants.VERSION+ ""String_Node_Str""+ Constants.REVISION+ ""String_Node_Str""+ nowAsString());
    System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ toMB(Runtime.getRuntime().maxMemory())+ ""String_Node_Str"");
    System.out.print(System.getProperty(""String_Node_Str""));
    for (int i=0; i < args.length; i++) {
      System.out.print(""String_Node_Str"" + args[i]);
    }
    System.out.println();
    if (hasParam(args,""String_Node_Str"")) {
      self.setSourceDir(getNamedParam(args,""String_Node_Str""));
      self.setDestDir(getNamedParam(args,""String_Node_Str""));
    }
 else     if (!hasParam(args,""String_Node_Str"") && args.length == 1 && new File(args[0]).exists()) {
      self.setConfigFile(args[0]);
    }
 else     if (hasParam(args,""String_Node_Str"")) {
      IniFile ini=new IniFile(""String_Node_Str"");
      String last=ini.getStringProperty(""String_Node_Str"",""String_Node_Str"");
      boolean ok=false;
      if (Utilities.noString(last)) {
        while (!ok) {
          System.out.print(""String_Node_Str"");
          BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
          last=reader.readLine();
          if (new File(last).exists())           ok=true;
 else           System.out.println(""String_Node_Str"" + last);
        }
      }
 else {
        while (!ok) {
          System.out.print(""String_Node_Str"" + last + ""String_Node_Str"");
          BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
          String nlast=reader.readLine();
          if (Utilities.noString(nlast))           nlast=last;
          if (new File(nlast).exists()) {
            ok=true;
            last=nlast;
          }
 else           System.out.println(""String_Node_Str"" + nlast);
        }
      }
      ini.setStringProperty(""String_Node_Str"",""String_Node_Str"",last,null);
      ini.save();
      if (new File(last).isDirectory())       self.setConfigFile(Utilities.path(last,""String_Node_Str""));
 else       self.setConfigFile(last);
    }
 else {
      self.setConfigFile(determineActualIG(getNamedParam(args,""String_Node_Str"")));
      if (Utilities.noString(self.getConfigFile()))       throw new Exception(""String_Node_Str"");
      if (!(new File(self.getConfigFile()).isAbsolute()))       self.setConfigFile(Utilities.path(System.getProperty(""String_Node_Str""),self.getConfigFile()));
    }
    self.setJekyllCommand(getNamedParam(args,""String_Node_Str""));
    self.setIgPack(getNamedParam(args,""String_Node_Str""));
    String proxy=getNamedParam(args,""String_Node_Str"");
    if (!Utilities.noString(proxy)) {
      String[] p=proxy.split(""String_Node_Str"");
      System.setProperty(""String_Node_Str"",p[0]);
      System.setProperty(""String_Node_Str"",p[1]);
    }
    self.setTxServer(getNamedParam(args,""String_Node_Str""));
    self.setPackagesFolder(getNamedParam(args,""String_Node_Str""));
    if (hasNamedParam(args,""String_Node_Str""))     self.setMode(IGBuildMode.AUTOBUILD);
    self.watch=hasParam(args,""String_Node_Str"");
    self.debug=hasParam(args,""String_Node_Str"");
    self.cacheVersion=hasParam(args,""String_Node_Str"");
    if (hasParam(args,""String_Node_Str""))     self.setCacheOption(CacheOption.CLEAR_ALL);
 else     if (hasParam(args,""String_Node_Str""))     self.setCacheOption(CacheOption.CLEAR_ERRORS);
 else     self.setCacheOption(CacheOption.LEAVE);
    try {
      self.execute();
    }
 catch (    Exception e) {
      exitCode=1;
      self.log(""String_Node_Str"" + e.getMessage());
      self.log(""String_Node_Str"");
      self.log(""String_Node_Str"");
      self.log(""String_Node_Str"");
      self.log(""String_Node_Str"");
      e.printStackTrace();
      for (      StackTraceElement st : e.getStackTrace()) {
        self.filelog.append(st.toString());
      }
      exitCode=1;
    }
 finally {
      if (self.mode == IGBuildMode.MANUAL) {
        TextFile.stringToFile(buildReport(getNamedParam(args,""String_Node_Str""),getNamedParam(args,""String_Node_Str""),self.filelog.toString(),Utilities.path(self.qaDir,""String_Node_Str"")),Utilities.path(System.getProperty(""String_Node_Str""),""String_Node_Str""));
      }
    }
  }
  System.exit(exitCode);
}",0.9883749690823646
22956,"@Override public BindingResolution resolveBinding(StructureDefinition profile,ElementDefinitionBindingComponent binding,String path){
  BindingResolution br=new BindingResolution();
  if (!binding.hasValueSet()) {
    br.url=specPath(""String_Node_Str"");
    br.display=""String_Node_Str"";
  }
 else {
    String ref=binding.getValueSet();
    if (ref.startsWith(""String_Node_Str"")) {
      br.url=specPath(""String_Node_Str"" + ref.substring(32) + ""String_Node_Str"");
      br.display=ref.substring(32);
    }
 else     if (ref.startsWith(""String_Node_Str"")) {
      ValueSet vs=context.fetchResource(ValueSet.class,makeCanonical(ref));
      if (vs == null) {
        br.url=ref;
        if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else {
          br.url=ref.substring(9) + ""String_Node_Str"";
          br.display=ref.substring(9);
          brokenLinkWarning(path,ref);
        }
      }
 else {
        br.url=vs.getUserString(""String_Node_Str"");
        br.display=vs.getName();
      }
    }
 else {
      if (ref.startsWith(""String_Node_Str"")) {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs != null) {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
 else {
          String vsr=VersionConvertorConstants.vsToRef(ref);
          if (vsr != null) {
            br.display=ref.substring(29);
            br.url=vsr;
          }
 else {
            br.display=ref.substring(29);
            br.url=ref.substring(29) + ""String_Node_Str"";
            brokenLinkWarning(path,ref);
          }
        }
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        String code=tail(ref);
        if (code.startsWith(""String_Node_Str"")) {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
 else {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
      }
 else {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs == null) {
          br.url=ref + ""String_Node_Str"";
          br.display=ref;
          brokenLinkWarning(path,ref);
        }
 else         if (ref.contains(""String_Node_Str"")) {
          br.url=vs.getUserString(""String_Node_Str"");
          if (br.url == null) {
            System.out.println(""String_Node_Str"" + ref);
            br.url=vs.getUserString(""String_Node_Str"");
          }
          br.display=vs.getName();
        }
 else {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
      }
    }
  }
  return br;
}","@Override public BindingResolution resolveBinding(StructureDefinition profile,ElementDefinitionBindingComponent binding,String path){
  BindingResolution br=new BindingResolution();
  if (!binding.hasValueSet()) {
    br.url=specPath(""String_Node_Str"");
    br.display=""String_Node_Str"";
  }
 else {
    String ref=binding.getValueSet();
    if (ref.startsWith(""String_Node_Str"")) {
      br.url=specPath(""String_Node_Str"" + ref.substring(32) + ""String_Node_Str"");
      br.display=ref.substring(32);
    }
 else     if (ref.startsWith(""String_Node_Str"")) {
      ValueSet vs=context.fetchResource(ValueSet.class,makeCanonical(ref));
      if (vs == null) {
        br.url=ref;
        if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else {
          br.url=ref.substring(9) + ""String_Node_Str"";
          br.display=ref.substring(9);
          brokenLinkWarning(path,ref);
        }
      }
 else {
        br.url=vs.getUserString(""String_Node_Str"");
        br.display=vs.getName();
      }
    }
 else {
      if (ref.startsWith(""String_Node_Str"")) {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs != null) {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
 else {
          String vsr=VersionConvertorConstants.vsToRef(ref);
          if (vsr != null) {
            br.display=ref.substring(29);
            br.url=vsr;
          }
 else {
            br.display=ref.substring(29);
            br.url=ref.substring(29) + ""String_Node_Str"";
            brokenLinkWarning(path,ref);
          }
        }
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        String code=tail(ref);
        if (code.startsWith(""String_Node_Str"")) {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
 else {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
      }
 else {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (Utilities.isAbsoluteUrl(ref) && (!ref.startsWith(""String_Node_Str"") || !ref.startsWith(""String_Node_Str""))) {
          br.url=ref;
          br.display=ref;
        }
 else         if (vs == null) {
          br.url=ref + ""String_Node_Str"";
          br.display=ref;
          brokenLinkWarning(path,ref);
        }
 else         if (ref.contains(""String_Node_Str"")) {
          br.url=vs.getUserString(""String_Node_Str"");
          if (br.url == null) {
            System.out.println(""String_Node_Str"" + ref);
            br.url=vs.getUserString(""String_Node_Str"");
          }
          br.display=vs.getName();
        }
 else {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
      }
    }
  }
  return br;
}",0.9732912119471568
22957,"private ResourceSummary getResourceSummary(String n) throws IOException {
  ResourceSummary rs=new ResourceSummary();
  JsonObject r=r3r4Outcomes.getAsJsonObject(n);
  if (r != null && (new File(Utilities.path(folders.rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",n + ""String_Node_Str"")).exists())) {
    rs.setMapped(true);
    for (    Entry<String,JsonElement> e : r.entrySet()) {
      JsonObject el=(JsonObject)e.getValue();
      rs.testCount++;
      JsonPrimitive p=el.getAsJsonPrimitive(""String_Node_Str"");
      if (!p.isBoolean())       rs.executeFailCount++;
      if (el.has(""String_Node_Str"")) {
        rs.r4ValidationFailCount++;
        rs.r4ValidationErrors=rs.r4ValidationErrors + el.getAsJsonArray(""String_Node_Str"").size();
      }
      if (el.has(""String_Node_Str""))       rs.roundTripFailCount++;
    }
  }
 else   rs.setMapped(false);
  return rs;
}","private ResourceSummary getResourceSummary(String n) throws IOException {
  ResourceSummary rs=new ResourceSummary();
  JsonObject r=r3r4Outcomes.getAsJsonObject(n);
  if (r != null && (new File(Utilities.path(folders.rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",n + ""String_Node_Str"")).exists())) {
    rs.setMapped(true);
    for (    Entry<String,JsonElement> e : r.entrySet()) {
      JsonObject el=(JsonObject)e.getValue();
      rs.testCount++;
      JsonPrimitive p=el.getAsJsonPrimitive(""String_Node_Str"");
      if (!p.isBoolean())       rs.executeFailCount++;
      if (el.has(""String_Node_Str"")) {
        rs.r4ValidationFailCount++;
        if (el.getAsJsonArray(""String_Node_Str"") != null)         rs.r4ValidationErrors=rs.r4ValidationErrors + el.getAsJsonArray(""String_Node_Str"").size();
 else         rs.r4ValidationErrors=rs.r4ValidationErrors;
      }
      if (el.has(""String_Node_Str""))       rs.roundTripFailCount++;
    }
  }
 else   rs.setMapped(false);
  return rs;
}",0.9383236689509752
22958,"private List<Variables> processSource(String ruleId,TransformContext context,Variables vars,StructureMapGroupRuleSourceComponent src,String pathForErrors) throws FHIRException {
  List<Base> items;
  if (src.getContext().equals(""String_Node_Str"")) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_SEARCH_EXPRESSION);
    if (expr == null) {
      expr=fpe.parse(src.getElement());
      src.setUserData(MAP_SEARCH_EXPRESSION,expr);
    }
    String search=fpe.evaluateToString(vars,null,new StringType(),expr);
    items=services.performSearch(context.appInfo,search);
  }
 else {
    items=new ArrayList<Base>();
    Base b=vars.get(VariableMode.INPUT,src.getContext());
    if (b == null)     throw new FHIRException(""String_Node_Str"" + src.getContext() + ""String_Node_Str""+ pathForErrors+ ""String_Node_Str""+ ruleId+ ""String_Node_Str""+ vars.summary()+ ""String_Node_Str"");
    if (!src.hasElement())     items.add(b);
 else {
      getChildrenByName(b,src.getElement(),items);
      if (items.size() == 0 && src.hasDefaultValue())       items.add(src.getDefaultValue());
    }
  }
  if (src.hasType()) {
    List<Base> remove=new ArrayList<Base>();
    for (    Base item : items) {
      if (item != null && !isType(item,src.getType())) {
        remove.add(item);
      }
    }
    items.removeAll(remove);
  }
  if (src.hasCondition()) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_WHERE_EXPRESSION);
    if (expr == null) {
      expr=fpe.parse(src.getCondition());
      src.setUserData(MAP_WHERE_EXPRESSION,expr);
    }
    List<Base> remove=new ArrayList<Base>();
    for (    Base item : items) {
      if (!fpe.evaluateToBoolean(vars,null,item,expr))       remove.add(item);
    }
    items.removeAll(remove);
  }
  if (src.hasCheck()) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_WHERE_CHECK);
    if (expr == null) {
      expr=fpe.parse(src.getCheck());
      src.setUserData(MAP_WHERE_CHECK,expr);
    }
    List<Base> remove=new ArrayList<Base>();
    for (    Base item : items) {
      if (!fpe.evaluateToBoolean(vars,null,item,expr))       throw new FHIRException(""String_Node_Str"" + ruleId + ""String_Node_Str"");
    }
  }
  if (src.hasLogMessage()) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_WHERE_LOG);
    if (expr == null) {
      expr=fpe.parse(src.getCheck());
      src.setUserData(MAP_WHERE_LOG,expr);
    }
    CommaSeparatedStringBuilder b=new CommaSeparatedStringBuilder();
    for (    Base item : items)     b.append(fpe.evaluateToString(vars,null,item,expr));
    if (b.length() > 0)     services.log(b.toString());
  }
  if (src.hasListMode() && !items.isEmpty()) {
switch (src.getListMode()) {
case FIRST:
      Base bt=items.get(0);
    items.clear();
  items.add(bt);
break;
case NOTFIRST:
if (items.size() > 0) items.remove(0);
break;
case LAST:
bt=items.get(items.size() - 1);
items.clear();
items.add(bt);
break;
case NOTLAST:
if (items.size() > 0) items.remove(items.size() - 1);
break;
case ONLYONE:
if (items.size() > 1) throw new FHIRException(""String_Node_Str"" + ruleId + ""String_Node_Str"");
break;
case NULL:
}
}
List<Variables> result=new ArrayList<Variables>();
for (Base r : items) {
Variables v=vars.copy();
if (src.hasVariable()) v.add(VariableMode.INPUT,src.getVariable(),r);
result.add(v);
}
return result;
}","private List<Variables> processSource(String ruleId,TransformContext context,Variables vars,StructureMapGroupRuleSourceComponent src,String pathForErrors) throws FHIRException {
  List<Base> items;
  if (src.getContext().equals(""String_Node_Str"")) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_SEARCH_EXPRESSION);
    if (expr == null) {
      expr=fpe.parse(src.getElement());
      src.setUserData(MAP_SEARCH_EXPRESSION,expr);
    }
    String search=fpe.evaluateToString(vars,null,new StringType(),expr);
    items=services.performSearch(context.appInfo,search);
  }
 else {
    items=new ArrayList<Base>();
    Base b=vars.get(VariableMode.INPUT,src.getContext());
    if (b == null)     throw new FHIRException(""String_Node_Str"" + src.getContext() + ""String_Node_Str""+ pathForErrors+ ""String_Node_Str""+ ruleId+ ""String_Node_Str""+ vars.summary()+ ""String_Node_Str"");
    if (!src.hasElement())     items.add(b);
 else {
      getChildrenByName(b,src.getElement(),items);
      if (items.size() == 0 && src.hasDefaultValue())       items.add(src.getDefaultValue());
    }
  }
  if (src.hasType()) {
    List<Base> remove=new ArrayList<Base>();
    for (    Base item : items) {
      if (item != null && !isType(item,src.getType())) {
        remove.add(item);
      }
    }
    items.removeAll(remove);
  }
  if (src.hasCondition()) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_WHERE_EXPRESSION);
    if (expr == null) {
      expr=fpe.parse(src.getCondition());
      src.setUserData(MAP_WHERE_EXPRESSION,expr);
    }
    List<Base> remove=new ArrayList<Base>();
    for (    Base item : items) {
      if (!fpe.evaluateToBoolean(vars,null,item,expr))       remove.add(item);
    }
    items.removeAll(remove);
  }
  if (src.hasCheck()) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_WHERE_CHECK);
    if (expr == null) {
      expr=fpe.parse(src.getCheck());
      src.setUserData(MAP_WHERE_CHECK,expr);
    }
    List<Base> remove=new ArrayList<Base>();
    for (    Base item : items) {
      if (!fpe.evaluateToBoolean(vars,null,item,expr))       throw new FHIRException(""String_Node_Str"" + ruleId + ""String_Node_Str"");
    }
  }
  if (src.hasLogMessage()) {
    ExpressionNode expr=(ExpressionNode)src.getUserData(MAP_WHERE_LOG);
    if (expr == null) {
      expr=fpe.parse(src.getLogMessage());
      src.setUserData(MAP_WHERE_LOG,expr);
    }
    CommaSeparatedStringBuilder b=new CommaSeparatedStringBuilder();
    for (    Base item : items)     b.appendIfNotNull(fpe.evaluateToString(vars,null,item,expr));
    if (b.length() > 0)     services.log(b.toString());
  }
  if (src.hasListMode() && !items.isEmpty()) {
switch (src.getListMode()) {
case FIRST:
      Base bt=items.get(0);
    items.clear();
  items.add(bt);
break;
case NOTFIRST:
if (items.size() > 0) items.remove(0);
break;
case LAST:
bt=items.get(items.size() - 1);
items.clear();
items.add(bt);
break;
case NOTLAST:
if (items.size() > 0) items.remove(items.size() - 1);
break;
case ONLYONE:
if (items.size() > 1) throw new FHIRException(""String_Node_Str"" + ruleId + ""String_Node_Str"");
break;
case NULL:
}
}
List<Variables> result=new ArrayList<Variables>();
for (Base r : items) {
Variables v=vars.copy();
if (src.hasVariable()) v.add(VariableMode.INPUT,src.getVariable(),r);
result.add(v);
}
return result;
}",0.9963985594237696
22959,"private void loadSpecInternals(ImplementationGuide ig,byte[] bs,String version,String canonical,Map<String,byte[]> files) throws Exception {
  SpecMapManager spm=new SpecMapManager(bs,version);
  ImplementationGuideManifestComponent man=ig.getManifest();
  man.setRendering(spm.getWebUrl(""String_Node_Str""));
  for (  String s : spm.getPathUrls()) {
    if (s.startsWith(canonical)) {
      String r=s.substring(canonical.length() + 1);
      ImplementationGuideManifestResourceComponent ra=getMatchingResource(r,ig);
      if (ra != null && !ra.hasRelativePath())       ra.setRelativePath(spm.getPath(s));
    }
  }
  for (  String s : spm.getImages()) {
    ig.getManifest().addImage(s);
  }
  for (  String s : spm.getTargets()) {
    if (s.contains(""String_Node_Str""))     throw new Error(""String_Node_Str"");
    ig.getManifest().addPage().setName(s);
  }
  if (spm.getPages().size() > 0)   throw new Error(""String_Node_Str"");
}","private void loadSpecInternals(ImplementationGuide ig,byte[] bs,String version,String canonical,Map<String,byte[]> files) throws Exception {
  SpecMapManager spm=new SpecMapManager(bs,version);
  ImplementationGuideManifestComponent man=ig.getManifest();
  man.setRendering(spm.getWebUrl(""String_Node_Str""));
  for (  String s : spm.getPathUrls()) {
    if (s.startsWith(canonical)) {
      String r=s.equals(canonical) ? ""String_Node_Str"" : s.substring(canonical.length() + 1);
      ImplementationGuideManifestResourceComponent ra=getMatchingResource(r,ig);
      if (ra != null && !ra.hasRelativePath())       ra.setRelativePath(spm.getPath(s));
    }
  }
  for (  String s : spm.getImages()) {
    ig.getManifest().addImage(s);
  }
  for (  String s : spm.getTargets()) {
    if (s.contains(""String_Node_Str""))     throw new Error(""String_Node_Str"");
    ig.getManifest().addPage().setName(s);
  }
  if (spm.getPages().size() > 0)   throw new Error(""String_Node_Str"");
}",0.9779643231899264
22960,"@Override public BindingResolution resolveBinding(StructureDefinition profile,ElementDefinitionBindingComponent binding,String path){
  BindingResolution br=new BindingResolution();
  if (!binding.hasValueSet()) {
    br.url=specPath(""String_Node_Str"");
    br.display=""String_Node_Str"";
  }
 else {
    String ref=binding.getValueSet();
    if (ref.startsWith(""String_Node_Str"")) {
      br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
      br.display=ref.substring(26);
    }
 else     if (ref.startsWith(""String_Node_Str"")) {
      ValueSet vs=context.fetchResource(ValueSet.class,makeCanonical(ref));
      if (vs == null) {
        br.url=ref;
        if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else {
          br.url=ref.substring(9) + ""String_Node_Str"";
          br.display=ref.substring(9);
          brokenLinkWarning(path,ref);
        }
      }
 else {
        br.url=vs.getUserString(""String_Node_Str"");
        br.display=vs.getName();
      }
    }
 else {
      if (ref.startsWith(""String_Node_Str"")) {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs != null) {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
 else {
          br.display=ref.substring(29);
          br.url=ref.substring(29) + ""String_Node_Str"";
          brokenLinkWarning(path,ref);
        }
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        String code=tail(ref);
        if (code.startsWith(""String_Node_Str"")) {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
 else {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
      }
 else {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs == null) {
          br.url=ref + ""String_Node_Str"";
          br.display=ref;
          brokenLinkWarning(path,ref);
        }
 else         if (ref.contains(""String_Node_Str"")) {
          br.url=vs.getUserString(""String_Node_Str"");
          if (br.url == null) {
            System.out.println(""String_Node_Str"" + ref);
            br.url=vs.getUserString(""String_Node_Str"");
          }
          br.display=vs.getName();
        }
 else {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
      }
    }
  }
  return br;
}","@Override public BindingResolution resolveBinding(StructureDefinition profile,ElementDefinitionBindingComponent binding,String path){
  BindingResolution br=new BindingResolution();
  if (!binding.hasValueSet()) {
    br.url=specPath(""String_Node_Str"");
    br.display=""String_Node_Str"";
  }
 else {
    String ref=binding.getValueSet();
    if (ref.startsWith(""String_Node_Str"")) {
      br.url=specPath(""String_Node_Str"" + ref.substring(32) + ""String_Node_Str"");
      br.display=ref.substring(32);
    }
 else     if (ref.startsWith(""String_Node_Str"")) {
      ValueSet vs=context.fetchResource(ValueSet.class,makeCanonical(ref));
      if (vs == null) {
        br.url=ref;
        if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else         if (ref.equals(""String_Node_Str""))         br.display=""String_Node_Str"";
 else {
          br.url=ref.substring(9) + ""String_Node_Str"";
          br.display=ref.substring(9);
          brokenLinkWarning(path,ref);
        }
      }
 else {
        br.url=vs.getUserString(""String_Node_Str"");
        br.display=vs.getName();
      }
    }
 else {
      if (ref.startsWith(""String_Node_Str"")) {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs != null) {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
 else {
          br.display=ref.substring(29);
          br.url=ref.substring(29) + ""String_Node_Str"";
          brokenLinkWarning(path,ref);
        }
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        br.url=specPath(""String_Node_Str"" + ref.substring(26) + ""String_Node_Str"");
        br.display=ref.substring(26);
      }
 else       if (ref.startsWith(""String_Node_Str"")) {
        String code=tail(ref);
        if (code.startsWith(""String_Node_Str"")) {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
 else {
          br.url=""String_Node_Str"" + code + ""String_Node_Str"";
          br.display=""String_Node_Str"" + code;
        }
      }
 else {
        ValueSet vs=context.fetchResource(ValueSet.class,ref);
        if (vs == null) {
          br.url=ref + ""String_Node_Str"";
          br.display=ref;
          brokenLinkWarning(path,ref);
        }
 else         if (ref.contains(""String_Node_Str"")) {
          br.url=vs.getUserString(""String_Node_Str"");
          if (br.url == null) {
            System.out.println(""String_Node_Str"" + ref);
            br.url=vs.getUserString(""String_Node_Str"");
          }
          br.display=vs.getName();
        }
 else {
          br.url=vs.getUserString(""String_Node_Str"");
          br.display=vs.getName();
        }
      }
    }
  }
  return br;
}",0.9993740219092332
22961,"public static String vsToRef(String url){
  if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   return ""String_Node_Str"";
}","public static String vsToRef(String url){
  if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   if (url.equals(""String_Node_Str""))   return ""String_Node_Str"";
 else   return null;
}",0.9875813128326434
22962,"private Element getFromBundle(Element bundle,String ref,String fullUrl,List<ValidationMessage> errors,String path){
  String targetUrl=null;
  String version=""String_Node_Str"";
  if (ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"")) {
    if (ref.contains(""String_Node_Str"")) {
      targetUrl=ref.substring(0,ref.indexOf(""String_Node_Str"") - 1);
      version=ref.substring(ref.indexOf(""String_Node_Str"") + 10);
    }
 else     targetUrl=ref;
  }
 else   if (fullUrl == null) {
    rule(errors,IssueType.REQUIRED,-1,-1,path,path.startsWith(""String_Node_Str""),""String_Node_Str"");
    return null;
  }
 else   if (ref.split(""String_Node_Str"").length != 2) {
    rule(errors,IssueType.INVALID,-1,-1,path,false,""String_Node_Str"" + ref);
    return null;
  }
 else {
    String base=""String_Node_Str"";
    if (fullUrl.startsWith(""String_Node_Str"")) {
      String[] parts=fullUrl.split(""String_Node_Str"");
      for (int i=0; i < parts.length - 1; i++) {
        base=base + parts[i] + ""String_Node_Str"";
      }
    }
 else {
      String[] parts;
      parts=fullUrl.split(""String_Node_Str"");
      for (int i=0; i < parts.length - 2; i++) {
        base=base + parts[i] + ""String_Node_Str"";
      }
    }
    String id=null;
    if (ref.contains(""String_Node_Str"")) {
      version=ref.substring(ref.indexOf(""String_Node_Str"") + 10);
      id=ref.substring(0,ref.indexOf(""String_Node_Str"") - 1);
    }
 else     if (base.startsWith(""String_Node_Str""))     id=ref.split(""String_Node_Str"")[1];
 else     id=ref;
    targetUrl=base + id;
  }
  List<Element> entries=new ArrayList<Element>();
  bundle.getNamedChildren(""String_Node_Str"",entries);
  Element match=null;
  for (  Element we : entries) {
    if (we.getChildValue(""String_Node_Str"").equals(targetUrl)) {
      Element r=we.getNamedChild(""String_Node_Str"");
      if (version.isEmpty()) {
        rule(errors,IssueType.FORBIDDEN,-1,-1,path,match == null,""String_Node_Str"" + ref);
        match=r;
      }
 else {
        try {
          if (r.getChildren(""String_Node_Str"").get(0).getChildValue(""String_Node_Str"").equals(version)) {
            rule(errors,IssueType.FORBIDDEN,-1,-1,path,match == null,""String_Node_Str"" + ref);
            match=r;
          }
        }
 catch (        Exception e) {
          warning(errors,IssueType.REQUIRED,-1,-1,path,r.getChildren(""String_Node_Str"").size() == 1 && r.getChildren(""String_Node_Str"").get(0).getChildValue(""String_Node_Str"") != null,""String_Node_Str"" + targetUrl + ""String_Node_Str"");
        }
      }
    }
  }
  warning(errors,IssueType.REQUIRED,-1,-1,path,match != null || !targetUrl.startsWith(""String_Node_Str""),""String_Node_Str"" + ref);
  return match;
}","private Element getFromBundle(Element bundle,String ref,String fullUrl,List<ValidationMessage> errors,String path){
  String targetUrl=null;
  String version=""String_Node_Str"";
  if (ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"")) {
    if (ref.contains(""String_Node_Str"")) {
      targetUrl=ref.substring(0,ref.indexOf(""String_Node_Str"") - 1);
      version=ref.substring(ref.indexOf(""String_Node_Str"") + 10);
    }
 else     targetUrl=ref;
  }
 else   if (fullUrl == null) {
    rule(errors,IssueType.REQUIRED,-1,-1,path,path.startsWith(""String_Node_Str""),""String_Node_Str"");
    return null;
  }
 else   if (ref.split(""String_Node_Str"").length != 2) {
    rule(errors,IssueType.INVALID,-1,-1,path,false,""String_Node_Str"" + ref);
    return null;
  }
 else {
    String base=""String_Node_Str"";
    if (fullUrl.startsWith(""String_Node_Str"")) {
      String[] parts=fullUrl.split(""String_Node_Str"");
      for (int i=0; i < parts.length - 1; i++) {
        base=base + parts[i] + ""String_Node_Str"";
      }
    }
 else {
      String[] parts;
      parts=fullUrl.split(""String_Node_Str"");
      for (int i=0; i < parts.length - 2; i++) {
        base=base + parts[i] + ""String_Node_Str"";
      }
    }
    String id=null;
    if (ref.contains(""String_Node_Str"")) {
      version=ref.substring(ref.indexOf(""String_Node_Str"") + 10);
      id=ref.substring(0,ref.indexOf(""String_Node_Str"") - 1);
    }
 else     if (base.startsWith(""String_Node_Str""))     id=ref.split(""String_Node_Str"")[1];
 else     id=ref;
    targetUrl=base + id;
  }
  List<Element> entries=new ArrayList<Element>();
  bundle.getNamedChildren(""String_Node_Str"",entries);
  Element match=null;
  for (  Element we : entries) {
    if (targetUrl.equals(we.getChildValue(""String_Node_Str""))) {
      Element r=we.getNamedChild(""String_Node_Str"");
      if (version.isEmpty()) {
        rule(errors,IssueType.FORBIDDEN,-1,-1,path,match == null,""String_Node_Str"" + ref);
        match=r;
      }
 else {
        try {
          if (version.equals(r.getChildren(""String_Node_Str"").get(0).getChildValue(""String_Node_Str""))) {
            rule(errors,IssueType.FORBIDDEN,-1,-1,path,match == null,""String_Node_Str"" + ref);
            match=r;
          }
        }
 catch (        Exception e) {
          warning(errors,IssueType.REQUIRED,-1,-1,path,r.getChildren(""String_Node_Str"").size() == 1 && r.getChildren(""String_Node_Str"").get(0).getChildValue(""String_Node_Str"") != null,""String_Node_Str"" + targetUrl + ""String_Node_Str"");
        }
      }
    }
  }
  warning(errors,IssueType.REQUIRED,-1,-1,path,match != null || !targetUrl.startsWith(""String_Node_Str""),""String_Node_Str"" + ref);
  return match;
}",0.988117341255106
22963,"public static void main(String[] args) throws Exception {
  if (hasParam(args,""String_Node_Str"")) {
    try {
      ValidationEngineTests.execute();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (args.length == 0 || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + Constants.VERSION + ""String_Node_Str""+ Constants.REVISION);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Constants.VERSION.substring(0,3) + ""String_Node_Str""+ Constants.VERSION);
    System.out.println(""String_Node_Str"" + Constants.VERSION.substring(0,3));
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else {
    String definitions=""String_Node_Str"" + Constants.VERSION;
    String map=null;
    List<String> igs=new ArrayList<String>();
    List<String> questionnaires=new ArrayList<String>();
    String txServer=""String_Node_Str"";
    boolean doNative=false;
    List<String> profiles=new ArrayList<String>();
    EngineMode mode=EngineMode.VALIDATION;
    String output=null;
    List<String> sources=new ArrayList<String>();
    Map<String,String> locations=new HashMap<String,String>();
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       definitions=args[++i];
 else       if (args[i].equals(""String_Node_Str"")) {
        String v=args[++i];
        if (""String_Node_Str"".equals(v))         v=""String_Node_Str"";
        if (""String_Node_Str"".equals(v))         v=""String_Node_Str"";
        if (""String_Node_Str"".equals(v))         v=""String_Node_Str"";
        if (v.startsWith(Constants.VERSION))         v=Constants.VERSION;
        definitions=""String_Node_Str"" + v;
      }
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       output=args[++i];
 else       if (args[i].equals(""String_Node_Str"")) {
        String p=null;
        if (i + 1 == args.length)         throw new Error(""String_Node_Str"");
 else {
          p=args[++i];
          profiles.add(p);
        }
        if (p != null && i + 1 < args.length && args[i + 1].equals(""String_Node_Str"")) {
          i++;
          if (i + 1 == args.length)           throw new Error(""String_Node_Str"");
 else           locations.put(p,args[++i]);
        }
      }
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       questionnaires.add(args[++i]);
 else       if (args[i].equals(""String_Node_Str""))       doNative=true;
 else       if (args[i].equals(""String_Node_Str"")) {
        map=args[++i];
        mode=EngineMode.TRANSFORM;
      }
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.NARRATIVE;
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.SNAPSHOT;
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       txServer=""String_Node_Str"".equals(args[++i]) ? null : args[i];
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else {
        String s=args[++i];
        if (s.startsWith(""String_Node_Str""))         definitions=s;
 else         igs.add(s);
      }
 else       if (args[i].equals(""String_Node_Str""))       if (map == null)       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       map=args[++i];
 else       throw new Exception(""String_Node_Str"");
 else       if (args[i].startsWith(""String_Node_Str""))       i++;
 else       sources.add(args[i]);
    }
    if (sources.isEmpty())     throw new Exception(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + definitions.substring(14));
    System.out.println(""String_Node_Str"" + txServer);
    ValidationEngine validator=new ValidationEngine(definitions,txServer);
    System.out.println(""String_Node_Str"" + validator.getContext().getVersion() + ""String_Node_Str"");
    for (    String src : igs) {
      System.out.println(""String_Node_Str"" + src);
      validator.loadIg(src);
    }
    validator.setQuestionnaires(questionnaires);
    validator.setNative(doNative);
    XmlParser x=new XmlParser();
    if (mode == EngineMode.TRANSFORM) {
      if (sources.size() > 1)       throw new Exception(""String_Node_Str"" + sources + ""String_Node_Str"");
      if (txServer == null)       throw new Exception(""String_Node_Str"");
      if (map == null)       throw new Exception(""String_Node_Str"");
      try {
        Resource r=validator.transform(sources.get(0),map);
        System.out.println(""String_Node_Str"");
        if (output != null) {
          FileOutputStream s=new FileOutputStream(output);
          x.setOutputStyle(OutputStyle.PRETTY);
          x.compose(s,r,true);
          s.close();
        }
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
      }
    }
 else     if (mode == EngineMode.NARRATIVE) {
      DomainResource r=validator.generate(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else     if (mode == EngineMode.SNAPSHOT) {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      StructureDefinition r=validator.snapshot(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      for (      String s : profiles) {
        if (!validator.getContext().hasResource(StructureDefinition.class,s) && !validator.getContext().hasResource(ImplementationGuide.class,s)) {
          System.out.println(""String_Node_Str"" + s);
          validator.loadProfile(locations.getOrDefault(s,s));
        }
      }
      if (profiles.size() > 0)       System.out.println(""String_Node_Str"" + sources + ""String_Node_Str""+ profiles.toString());
 else       System.out.println(""String_Node_Str"" + sources);
      Resource r=validator.validate(sources,profiles);
      if (output == null) {
        if (r instanceof Bundle)         for (        BundleEntryComponent e : ((Bundle)r).getEntry())         displayOO((OperationOutcome)e.getResource());
 else         displayOO((OperationOutcome)r);
      }
 else {
        FileOutputStream s=new FileOutputStream(output);
        x.compose(s,r,true);
        s.close();
      }
    }
  }
}","public static void main(String[] args) throws Exception {
  if (hasParam(args,""String_Node_Str"")) {
    try {
      ValidationEngineTests.execute();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (args.length == 0 || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + Constants.VERSION + ""String_Node_Str""+ Constants.REVISION);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Constants.VERSION.substring(0,3) + ""String_Node_Str""+ Constants.VERSION);
    System.out.println(""String_Node_Str"" + Constants.VERSION.substring(0,3));
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else {
    String definitions=""String_Node_Str"" + Constants.VERSION;
    String map=null;
    List<String> igs=new ArrayList<String>();
    List<String> questionnaires=new ArrayList<String>();
    String txServer=""String_Node_Str"";
    boolean doNative=false;
    List<String> profiles=new ArrayList<String>();
    EngineMode mode=EngineMode.VALIDATION;
    String output=null;
    List<String> sources=new ArrayList<String>();
    Map<String,String> locations=new HashMap<String,String>();
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       definitions=args[++i];
 else       if (args[i].equals(""String_Node_Str"")) {
        String v=args[++i];
        if (""String_Node_Str"".equals(v))         v=""String_Node_Str"";
        if (""String_Node_Str"".equals(v))         v=""String_Node_Str"";
        if (""String_Node_Str"".equals(v))         v=""String_Node_Str"";
        if (v.startsWith(Constants.VERSION))         v=Constants.VERSION;
        definitions=""String_Node_Str"" + v;
      }
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       output=args[++i];
 else       if (args[i].equals(""String_Node_Str"")) {
        String p=null;
        if (i + 1 == args.length)         throw new Error(""String_Node_Str"");
 else {
          p=args[++i];
          profiles.add(p);
        }
        if (p != null && i + 1 < args.length && args[i + 1].equals(""String_Node_Str"")) {
          i++;
          if (i + 1 == args.length)           throw new Error(""String_Node_Str"");
 else           locations.put(p,args[++i]);
        }
      }
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       questionnaires.add(args[++i]);
 else       if (args[i].equals(""String_Node_Str""))       doNative=true;
 else       if (args[i].equals(""String_Node_Str"")) {
        map=args[++i];
        mode=EngineMode.TRANSFORM;
      }
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.NARRATIVE;
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.SNAPSHOT;
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       txServer=""String_Node_Str"".equals(args[++i]) ? null : args[i];
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else {
        String s=args[++i];
        if (s.startsWith(""String_Node_Str""))         definitions=s;
 else         igs.add(s);
      }
 else       if (args[i].equals(""String_Node_Str""))       if (map == null)       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       map=args[++i];
 else       throw new Exception(""String_Node_Str"");
 else       if (args[i].startsWith(""String_Node_Str""))       i++;
 else       sources.add(args[i]);
    }
    if (sources.isEmpty())     throw new Exception(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + txServer);
    ValidationEngine validator=new ValidationEngine(definitions,txServer);
    System.out.println(""String_Node_Str"" + validator.getContext().getVersion() + ""String_Node_Str"");
    for (    String src : igs) {
      System.out.println(""String_Node_Str"" + src);
      validator.loadIg(src);
    }
    validator.setQuestionnaires(questionnaires);
    validator.setNative(doNative);
    XmlParser x=new XmlParser();
    if (mode == EngineMode.TRANSFORM) {
      if (sources.size() > 1)       throw new Exception(""String_Node_Str"" + sources + ""String_Node_Str"");
      if (txServer == null)       throw new Exception(""String_Node_Str"");
      if (map == null)       throw new Exception(""String_Node_Str"");
      try {
        Resource r=validator.transform(sources.get(0),map);
        System.out.println(""String_Node_Str"");
        if (output != null) {
          FileOutputStream s=new FileOutputStream(output);
          x.setOutputStyle(OutputStyle.PRETTY);
          x.compose(s,r,true);
          s.close();
        }
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
      }
    }
 else     if (mode == EngineMode.NARRATIVE) {
      DomainResource r=validator.generate(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else     if (mode == EngineMode.SNAPSHOT) {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      StructureDefinition r=validator.snapshot(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      for (      String s : profiles) {
        if (!validator.getContext().hasResource(StructureDefinition.class,s) && !validator.getContext().hasResource(ImplementationGuide.class,s)) {
          System.out.println(""String_Node_Str"" + s);
          validator.loadProfile(locations.getOrDefault(s,s));
        }
      }
      if (profiles.size() > 0)       System.out.println(""String_Node_Str"" + sources + ""String_Node_Str""+ profiles.toString());
 else       System.out.println(""String_Node_Str"" + sources);
      Resource r=validator.validate(sources,profiles);
      if (output == null) {
        if (r instanceof Bundle)         for (        BundleEntryComponent e : ((Bundle)r).getEntry())         displayOO((OperationOutcome)e.getResource());
 else         displayOO((OperationOutcome)r);
      }
 else {
        FileOutputStream s=new FileOutputStream(output);
        x.compose(s,r,true);
        s.close();
      }
    }
  }
}",0.996399411734875
22964,"private Map<String,byte[]> loadIgSource(String src) throws Exception {
  if (src.startsWith(""String_Node_Str"") || src.startsWith(""String_Node_Str"")) {
    String v=null;
    if (src.contains(""String_Node_Str"")) {
      v=src.substring(src.indexOf(""String_Node_Str"") + 1);
      src=src.substring(0,src.indexOf(""String_Node_Str""));
    }
    String pid=pcm.getPackageId(src);
    if (!Utilities.noString(pid))     return fetchByPackage(pid + (v == null ? ""String_Node_Str"" : ""String_Node_Str"" + v));
 else     return fetchFromUrl(src + (v == null ? ""String_Node_Str"" : ""String_Node_Str"" + v));
  }
  if (src.matches(PackageCacheManager.PACKAGE_REGEX) || src.matches(PackageCacheManager.PACKAGE_VERSION_REGEX)) {
    return fetchByPackage(src);
  }
  File f=new File(src);
  if (f.exists()) {
    if (f.isDirectory() && new File(Utilities.path(src,""String_Node_Str"")).exists())     return loadPackage(new FileInputStream(Utilities.path(src,""String_Node_Str"")),Utilities.path(src,""String_Node_Str""));
    if (f.isDirectory() && new File(Utilities.path(src,""String_Node_Str"")).exists())     return readZip(new FileInputStream(Utilities.path(src,""String_Node_Str"")));
    if (f.isDirectory() && new File(Utilities.path(src,""String_Node_Str"")).exists())     return readZip(new FileInputStream(Utilities.path(src,""String_Node_Str"")));
    if (f.isDirectory())     return scanDirectory(f);
    if (src.endsWith(""String_Node_Str""))     return loadPackage(new FileInputStream(src),src);
    if (src.endsWith(""String_Node_Str""))     return readZip(new FileInputStream(src));
    if (src.endsWith(""String_Node_Str""))     return readZip(new FileInputStream(src));
    FhirFormat fmt=checkIsResource(src);
    if (fmt != null) {
      Map<String,byte[]> res=new HashMap<String,byte[]>();
      res.put(Utilities.changeFileExt(src,""String_Node_Str"" + fmt.getExtension()),TextFile.fileToBytes(src));
      return res;
    }
  }
  throw new Exception(""String_Node_Str"" + src);
}","private Map<String,byte[]> loadIgSource(String src) throws Exception {
  if (src.startsWith(""String_Node_Str"") || src.startsWith(""String_Node_Str"")) {
    String v=null;
    if (src.contains(""String_Node_Str"")) {
      v=src.substring(src.indexOf(""String_Node_Str"") + 1);
      src=src.substring(0,src.indexOf(""String_Node_Str""));
    }
    String pid=pcm.getPackageId(src);
    if (!Utilities.noString(pid))     return fetchByPackage(pid + (v == null ? ""String_Node_Str"" : ""String_Node_Str"" + v));
 else     return fetchFromUrl(src + (v == null ? ""String_Node_Str"" : ""String_Node_Str"" + v));
  }
  if ((src.matches(PackageCacheManager.PACKAGE_REGEX) || src.matches(PackageCacheManager.PACKAGE_VERSION_REGEX)) && !src.endsWith(""String_Node_Str"")) {
    return fetchByPackage(src);
  }
  File f=new File(src);
  if (f.exists()) {
    if (f.isDirectory() && new File(Utilities.path(src,""String_Node_Str"")).exists())     return loadPackage(new FileInputStream(Utilities.path(src,""String_Node_Str"")),Utilities.path(src,""String_Node_Str""));
    if (f.isDirectory() && new File(Utilities.path(src,""String_Node_Str"")).exists())     return readZip(new FileInputStream(Utilities.path(src,""String_Node_Str"")));
    if (f.isDirectory() && new File(Utilities.path(src,""String_Node_Str"")).exists())     return readZip(new FileInputStream(Utilities.path(src,""String_Node_Str"")));
    if (f.isDirectory())     return scanDirectory(f);
    if (src.endsWith(""String_Node_Str""))     return loadPackage(new FileInputStream(src),src);
    if (src.endsWith(""String_Node_Str""))     return readZip(new FileInputStream(src));
    if (src.endsWith(""String_Node_Str""))     return readZip(new FileInputStream(src));
    FhirFormat fmt=checkIsResource(src);
    if (fmt != null) {
      Map<String,byte[]> res=new HashMap<String,byte[]>();
      res.put(Utilities.changeFileExt(src,""String_Node_Str"" + fmt.getExtension()),TextFile.fileToBytes(src));
      return res;
    }
  }
  throw new Exception(""String_Node_Str"" + src);
}",0.9904040404040404
22965,"private void generateIds(List<ElementDefinition> list,String name) throws DefinitionException {
  if (list.isEmpty())   return;
  Map<String,String> idMap=new HashMap<String,String>();
  Map<String,String> idList=new HashMap<String,String>();
  SliceList sliceInfo=new SliceList();
  for (  ElementDefinition ed : list) {
    List<String> paths=new ArrayList<String>();
    if (!ed.hasPath())     throw new DefinitionException(""String_Node_Str"" + Integer.toString(list.indexOf(ed)) + ""String_Node_Str""+ name);
    sliceInfo.seeElement(ed);
    String[] pl=ed.getPath().split(""String_Node_Str"");
    for (int i=paths.size(); i < pl.length; i++)     paths.add(pl[i]);
    String slices[]=sliceInfo.analyse(paths);
    name=null;
    StringBuilder b=new StringBuilder();
    b.append(paths.get(0));
    for (int i=1; i < paths.size(); i++) {
      b.append(""String_Node_Str"");
      String s=paths.get(i);
      String p=slices[i];
      if (p != null) {
        b.append(p);
        b.append(""String_Node_Str"");
      }
      b.append(s);
    }
    String bs=b.toString();
    idMap.put(ed.hasId() ? ed.getId() : ed.getPath(),bs);
    ed.setId(bs);
    if (idList.containsKey(bs))     throw new DefinitionException(""String_Node_Str"" + bs + ""String_Node_Str""+ idList.get(bs)+ ""String_Node_Str""+ ed.getPath()+ ""String_Node_Str""+ name);
    idList.put(bs,ed.getPath());
    if (ed.hasContentReference()) {
      String s=ed.getContentReference().substring(1);
      if (idMap.containsKey(s))       ed.setContentReference(""String_Node_Str"" + idMap.get(s));
    }
  }
}","private void generateIds(List<ElementDefinition> list,String name) throws DefinitionException {
  if (list.isEmpty())   return;
  Map<String,String> idMap=new HashMap<String,String>();
  Map<String,String> idList=new HashMap<String,String>();
  SliceList sliceInfo=new SliceList();
  for (  ElementDefinition ed : list) {
    List<String> paths=new ArrayList<String>();
    if (!ed.hasPath())     throw new DefinitionException(""String_Node_Str"" + Integer.toString(list.indexOf(ed)) + ""String_Node_Str""+ name);
    sliceInfo.seeElement(ed);
    String[] pl=ed.getPath().split(""String_Node_Str"");
    for (int i=paths.size(); i < pl.length; i++)     paths.add(pl[i]);
    String slices[]=sliceInfo.analyse(paths);
    name=null;
    StringBuilder b=new StringBuilder();
    b.append(paths.get(0));
    for (int i=1; i < paths.size(); i++) {
      b.append(""String_Node_Str"");
      String s=paths.get(i);
      String p=slices[i];
      b.append(s);
      if (p != null) {
        b.append(""String_Node_Str"");
        b.append(p);
      }
    }
    String bs=b.toString();
    idMap.put(ed.hasId() ? ed.getId() : ed.getPath(),bs);
    ed.setId(bs);
    if (idList.containsKey(bs))     throw new DefinitionException(""String_Node_Str"" + bs + ""String_Node_Str""+ idList.get(bs)+ ""String_Node_Str""+ ed.getPath()+ ""String_Node_Str""+ name);
    idList.put(bs,ed.getPath());
    if (ed.hasContentReference()) {
      String s=ed.getContentReference().substring(1);
      if (idMap.containsKey(s))       ed.setContentReference(""String_Node_Str"" + idMap.get(s));
    }
  }
}",0.9763124199743918
22966,"/** 
 * @param trimDifferential
 * @throws DefinitionException , FHIRException 
 * @throws Exception
 */
private ElementDefinition processPaths(String indent,StructureDefinitionSnapshotComponent result,StructureDefinitionSnapshotComponent base,StructureDefinitionDifferentialComponent differential,int baseCursor,int diffCursor,int baseLimit,int diffLimit,String url,String profileName,String contextPathSrc,String contextPathDst,boolean trimDifferential,String contextName,String resultPathBase,boolean slicingDone,ElementDefinition redirector) throws DefinitionException, FHIRException {
  if (DEBUG)   System.out.println(indent + ""String_Node_Str"" + resultPathBase+ ""String_Node_Str""+ baseCursor+ ""String_Node_Str""+ baseLimit+ ""String_Node_Str""+ diffCursor+ ""String_Node_Str""+ diffLimit+ ""String_Node_Str""+ slicingDone+ ""String_Node_Str"");
  ElementDefinition res=null;
  while (baseCursor <= baseLimit) {
    ElementDefinition currentBase=base.getElement().get(baseCursor);
    String cpath=fixedPathSource(contextPathSrc,currentBase.getPath(),redirector);
    if (DEBUG)     System.out.println(indent + ""String_Node_Str"" + cpath+ ""String_Node_Str""+ baseCursor+ ""String_Node_Str""+ baseLimit+ ""String_Node_Str""+ diffCursor+ ""String_Node_Str""+ diffLimit+ ""String_Node_Str""+ slicingDone+ ""String_Node_Str"");
    List<ElementDefinition> diffMatches=getDiffMatches(differential,cpath,diffCursor,diffLimit,profileName,url);
    if (!currentBase.hasSlicing()) {
      if (diffMatches.isEmpty()) {
        ElementDefinition outcome=updateURLs(url,currentBase.copy());
        outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
        updateFromBase(outcome,currentBase);
        markDerived(outcome);
        if (resultPathBase == null)         resultPathBase=outcome.getPath();
 else         if (!outcome.getPath().startsWith(resultPathBase))         throw new DefinitionException(""String_Node_Str"");
        result.getElement().add(outcome);
        if (hasInnerDiffMatches(differential,cpath,diffCursor,diffLimit,base.getElement())) {
          if (outcome.getType().size() > 1) {
            for (            TypeRefComponent t : outcome.getType()) {
              if (!t.getCode().equals(""String_Node_Str""))               throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName);
            }
          }
          StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
          if (dt == null)           throw new DefinitionException(cpath + ""String_Node_Str"" + typeCode(outcome.getType())+ ""String_Node_Str""+ profileName+ ""String_Node_Str"");
          contextName=dt.getUrl();
          int start=diffCursor;
          while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),cpath + ""String_Node_Str""))           diffCursor++;
          processPaths(indent + ""String_Node_Str"",result,dt.getSnapshot(),differential,1,start,dt.getSnapshot().getElement().size() - 1,diffCursor - 1,url,profileName,cpath,outcome.getPath(),trimDifferential,contextName,resultPathBase,false,null);
        }
        baseCursor++;
      }
 else       if (diffMatches.size() == 1 && (slicingDone || !(diffMatches.get(0).hasSlicing() || (isExtension(diffMatches.get(0)) && diffMatches.get(0).hasSliceName())))) {
        ElementDefinition template=null;
        if (diffMatches.get(0).hasType() && diffMatches.get(0).getType().size() == 1 && diffMatches.get(0).getType().get(0).hasProfile() && !diffMatches.get(0).getType().get(0).getCode().equals(""String_Node_Str"")) {
          String p=diffMatches.get(0).getType().get(0).getProfile().get(0).getValue();
          StructureDefinition sd=context.fetchResource(StructureDefinition.class,p);
          if (sd != null) {
            if (!sd.hasSnapshot()) {
              StructureDefinition sdb=context.fetchResource(StructureDefinition.class,sd.getBaseDefinition());
              if (sdb == null)               throw new DefinitionException(""String_Node_Str"" + sd.getBaseDefinition());
              generateSnapshot(sdb,sd,sd.getUrl(),sd.getName());
            }
            template=sd.getSnapshot().getElement().get(0).copy().setPath(currentBase.getPath());
            template.setSliceName(null);
            if (!diffMatches.get(0).getType().get(0).getCode().equals(""String_Node_Str"")) {
              template.setMin(currentBase.getMin());
              template.setMax(currentBase.getMax());
            }
          }
        }
        if (template == null)         template=currentBase.copy();
 else         template=overWriteWithCurrent(template,currentBase);
        ElementDefinition outcome=updateURLs(url,template);
        outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
        res=outcome;
        updateFromBase(outcome,currentBase);
        if (diffMatches.get(0).hasSliceName())         outcome.setSliceName(diffMatches.get(0).getSliceName());
        outcome.setSlicing(null);
        updateFromDefinition(outcome,diffMatches.get(0),profileName,trimDifferential,url);
        if (outcome.getPath().endsWith(""String_Node_Str"") && outcome.getType().size() == 1 && !outcome.getType().get(0).getCode().equals(""String_Node_Str""))         outcome.setPath(outcome.getPath().substring(0,outcome.getPath().length() - 3) + Utilities.capitalize(outcome.getType().get(0).getCode()));
        if (resultPathBase == null)         resultPathBase=outcome.getPath();
 else         if (!outcome.getPath().startsWith(resultPathBase))         throw new DefinitionException(""String_Node_Str"");
        result.getElement().add(outcome);
        baseCursor++;
        diffCursor=differential.getElement().indexOf(diffMatches.get(0)) + 1;
        if (differential.getElement().size() > diffCursor && outcome.getPath().contains(""String_Node_Str"") && (isDataType(outcome.getType()) || outcome.hasContentReference())) {
          if (pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str"") && !baseWalksInto(base.getElement(),baseCursor)) {
            if (outcome.getType().size() > 1) {
              if (outcome.getPath().endsWith(""String_Node_Str"") && !diffMatches.get(0).getPath().endsWith(""String_Node_Str"")) {
                String en=tail(outcome.getPath());
                String tn=tail(diffMatches.get(0).getPath());
                String t=tn.substring(en.length() - 3);
                if (isPrimitive(Utilities.uncapitalize(t)))                 t=Utilities.uncapitalize(t);
                List<TypeRefComponent> ntr=getByTypeName(outcome.getType(),t);
                if (ntr.isEmpty())                 ntr.add(new TypeRefComponent().setCode(t));
                outcome.getType().clear();
                outcome.getType().addAll(ntr);
              }
              if (outcome.getType().size() > 1)               for (              TypeRefComponent t : outcome.getType()) {
                if (!t.getCode().equals(""String_Node_Str""))                 throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName);
              }
            }
            int start=diffCursor;
            while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str""))             diffCursor++;
            if (outcome.hasContentReference()) {
              ElementDefinition tgt=getElementById(base.getElement(),outcome.getContentReference());
              if (tgt == null)               throw new DefinitionException(""String_Node_Str"" + outcome.getContentReference());
              replaceFromContentReference(outcome,tgt);
              int nbc=base.getElement().indexOf(tgt) + 1;
              int nbl=nbc;
              while (nbl < base.getElement().size() && base.getElement().get(nbl).getPath().startsWith(tgt.getPath() + ""String_Node_Str""))               nbl++;
              processPaths(indent + ""String_Node_Str"",result,base,differential,nbc,start - 1,nbl - 1,diffCursor - 1,url,profileName,tgt.getPath(),diffMatches.get(0).getPath(),trimDifferential,contextName,resultPathBase,false,outcome);
            }
 else {
              StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
              if (dt == null)               throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName+ ""String_Node_Str"");
              contextName=dt.getUrl();
              processPaths(indent + ""String_Node_Str"",result,dt.getSnapshot(),differential,1,start,dt.getSnapshot().getElement().size() - 1,diffCursor - 1,url,profileName + pathTail(diffMatches,0),diffMatches.get(0).getPath(),outcome.getPath(),trimDifferential,contextName,resultPathBase,false,null);
            }
          }
        }
      }
 else {
        if (!unbounded(currentBase) && !isSlicedToOneOnly(diffMatches.get(0)))         throw new DefinitionException(""String_Node_Str"" + currentBase.getPath() + ""String_Node_Str""+ currentBase.getSliceName()+ ""String_Node_Str""+ contextName+ ""String_Node_Str""+ url);
        if (!diffMatches.get(0).hasSlicing() && !isExtension(currentBase))         throw new DefinitionException(""String_Node_Str"" + currentBase.getPath() + ""String_Node_Str""+ url);
        int start=0;
        int nbl=findEndOfElement(base,baseCursor);
        if (diffMatches.size() > 1 && diffMatches.get(0).hasSlicing() && (nbl > baseCursor || differential.getElement().indexOf(diffMatches.get(1)) > differential.getElement().indexOf(diffMatches.get(0)) + 1)) {
          int ndc=differential.getElement().indexOf(diffMatches.get(0));
          int ndl=findEndOfElement(differential,ndc);
          processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,0),contextPathSrc,contextPathDst,trimDifferential,contextName,resultPathBase,true,null).setSlicing(diffMatches.get(0).getSlicing());
          start++;
        }
 else {
          ElementDefinition outcome=updateURLs(url,currentBase.copy());
          outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
          updateFromBase(outcome,currentBase);
          if (!diffMatches.get(0).hasSlicing())           outcome.setSlicing(makeExtensionSlicing());
 else           outcome.setSlicing(diffMatches.get(0).getSlicing().copy());
          if (!outcome.getPath().startsWith(resultPathBase))           throw new DefinitionException(""String_Node_Str"");
          result.getElement().add(outcome);
          if (!diffMatches.get(0).hasSliceName()) {
            updateFromDefinition(outcome,diffMatches.get(0),profileName,trimDifferential,url);
            if (!outcome.hasContentReference() && !outcome.hasType()) {
              throw new DefinitionException(""String_Node_Str"");
            }
            start++;
          }
 else           checkExtensionDoco(outcome);
        }
        int ndc=diffCursor;
        int ndl=diffCursor;
        for (int i=start; i < diffMatches.size(); i++) {
          ndc=differential.getElement().indexOf(diffMatches.get(i));
          ndl=findEndOfElement(differential,ndc);
          processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,i),contextPathSrc,contextPathDst,trimDifferential,contextName,resultPathBase,true,null);
        }
        baseCursor=nbl + 1;
        diffCursor=ndl + 1;
      }
    }
 else {
      String path=currentBase.getPath();
      ElementDefinition original=currentBase;
      if (diffMatches.isEmpty()) {
        while (baseCursor < base.getElement().size() && base.getElement().get(baseCursor).getPath().startsWith(path)) {
          ElementDefinition outcome=updateURLs(url,base.getElement().get(baseCursor).copy());
          outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
          if (!outcome.getPath().startsWith(resultPathBase))           throw new DefinitionException(""String_Node_Str"" + profileName + ""String_Node_Str""+ outcome.getPath()+ ""String_Node_Str""+ resultPathBase);
          result.getElement().add(outcome);
          baseCursor++;
        }
      }
 else {
        boolean closed=currentBase.getSlicing().getRules() == SlicingRules.CLOSED;
        int diffpos=0;
        boolean isExtension=cpath.endsWith(""String_Node_Str"") || cpath.endsWith(""String_Node_Str"");
        if (diffMatches.get(0).hasSlicing()) {
          ElementDefinitionSlicingComponent dSlice=diffMatches.get(0).getSlicing();
          ElementDefinitionSlicingComponent bSlice=currentBase.getSlicing();
          if (dSlice.hasOrderedElement() && bSlice.hasOrderedElement() && !orderMatches(dSlice.getOrderedElement(),bSlice.getOrderedElement()))           throw new DefinitionException(""String_Node_Str"" + summarizeSlicing(dSlice) + ""String_Node_Str""+ summarizeSlicing(bSlice)+ ""String_Node_Str""+ path+ ""String_Node_Str""+ contextName+ ""String_Node_Str"");
          if (!discriminatorMatches(dSlice.getDiscriminator(),bSlice.getDiscriminator()))           throw new DefinitionException(""String_Node_Str"" + summarizeSlicing(dSlice) + ""String_Node_Str""+ summarizeSlicing(bSlice)+ ""String_Node_Str""+ path+ ""String_Node_Str""+ contextName+ ""String_Node_Str"");
          if (!ruleMatches(dSlice.getRules(),bSlice.getRules()))           throw new DefinitionException(""String_Node_Str"" + summarizeSlicing(dSlice) + ""String_Node_Str""+ summarizeSlicing(bSlice)+ ""String_Node_Str""+ path+ ""String_Node_Str""+ contextName+ ""String_Node_Str"");
        }
        ElementDefinition outcome=updateURLs(url,currentBase.copy());
        outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
        updateFromBase(outcome,currentBase);
        if (diffMatches.get(0).hasSlicing() || !diffMatches.get(0).hasSliceName()) {
          updateFromSlicing(outcome.getSlicing(),diffMatches.get(0).getSlicing());
          updateFromDefinition(outcome,diffMatches.get(0),profileName,closed,url);
        }
 else         if (!diffMatches.get(0).hasSliceName())         diffMatches.get(0).setUserData(GENERATED_IN_SNAPSHOT,true);
        result.getElement().add(outcome);
        if (!diffMatches.get(0).hasSliceName()) {
          diffpos++;
        }
        if (diffMatches.size() > 1 && diffMatches.get(0).hasSlicing() && differential.getElement().indexOf(diffMatches.get(1)) > differential.getElement().indexOf(diffMatches.get(0)) + 1) {
          int nbl=findEndOfElement(base,baseCursor);
          int ndc=differential.getElement().indexOf(diffMatches.get(0));
          int ndl=findEndOfElement(differential,ndc);
          processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor + 1,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,0),contextPathSrc,contextPathDst,trimDifferential,contextName,resultPathBase,true,null);
        }
 else         if (currentBase.getType().get(0).getCode().equals(""String_Node_Str"")) {
          int nbl=findEndOfElement(base,baseCursor);
          for (int i=baseCursor + 1; i <= nbl; i++) {
            outcome=updateURLs(url,base.getElement().get(i).copy());
            result.getElement().add(outcome);
          }
        }
        List<ElementDefinition> baseMatches=getSiblings(base.getElement(),currentBase);
        for (        ElementDefinition baseItem : baseMatches) {
          baseCursor=base.getElement().indexOf(baseItem);
          outcome=updateURLs(url,baseItem.copy());
          updateFromBase(outcome,currentBase);
          outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
          outcome.setSlicing(null);
          if (!outcome.getPath().startsWith(resultPathBase))           throw new DefinitionException(""String_Node_Str"");
          if (diffpos < diffMatches.size() && diffMatches.get(diffpos).getSliceName().equals(outcome.getSliceName())) {
            int nbl=findEndOfElement(base,baseCursor);
            int ndc=differential.getElement().indexOf(diffMatches.get(diffpos));
            int ndl=findEndOfElement(differential,ndc);
            processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,diffpos),contextPathSrc,contextPathDst,closed,contextName,resultPathBase,true,null);
            baseCursor=nbl;
            diffCursor=ndl + 1;
            diffpos++;
          }
 else {
            result.getElement().add(outcome);
            baseCursor++;
            while (baseCursor < base.getElement().size() && base.getElement().get(baseCursor).getPath().startsWith(path) && !base.getElement().get(baseCursor).getPath().equals(path)) {
              outcome=updateURLs(url,base.getElement().get(baseCursor).copy());
              outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
              if (!outcome.getPath().startsWith(resultPathBase))               throw new DefinitionException(""String_Node_Str"");
              result.getElement().add(outcome);
              baseCursor++;
            }
            baseCursor--;
          }
        }
        if (closed && diffpos < diffMatches.size())         throw new DefinitionException(""String_Node_Str"" + profileName + ""String_Node_Str""+ path+ ""String_Node_Str""+ cpath+ ""String_Node_Str"");
        if (diffpos == diffMatches.size()) {
        }
 else {
          while (diffpos < diffMatches.size()) {
            ElementDefinition diffItem=diffMatches.get(diffpos);
            for (            ElementDefinition baseItem : baseMatches)             if (baseItem.getSliceName().equals(diffItem.getSliceName()))             throw new DefinitionException(""String_Node_Str"");
            outcome=updateURLs(url,currentBase.copy());
            outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
            updateFromBase(outcome,currentBase);
            outcome.setSlicing(null);
            if (!outcome.getPath().startsWith(resultPathBase))             throw new DefinitionException(""String_Node_Str"");
            result.getElement().add(outcome);
            updateFromDefinition(outcome,diffItem,profileName,trimDifferential,url);
            diffCursor=differential.getElement().indexOf(diffItem) + 1;
            if (!outcome.getType().isEmpty() && (differential.getElement().size() > diffCursor) && outcome.getPath().contains(""String_Node_Str"")&& isDataType(outcome.getType())) {
              if (!baseWalksInto(base.getElement(),baseCursor)) {
                if (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str"")) {
                  if (outcome.getType().size() > 1)                   for (                  TypeRefComponent t : outcome.getType()) {
                    if (!t.getCode().equals(""String_Node_Str""))                     throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName);
                  }
                  TypeRefComponent t=outcome.getType().get(0);
                  if (t.getCode().equals(""String_Node_Str"")) {
                    int baseStart=base.getElement().indexOf(currentBase) + 1;
                    int baseMax=baseStart + 1;
                    while (baseMax < base.getElement().size() && base.getElement().get(baseMax).getPath().startsWith(currentBase.getPath() + ""String_Node_Str""))                     baseMax++;
                    int start=diffCursor;
                    while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str""))                     diffCursor++;
                    processPaths(indent + ""String_Node_Str"",result,base,differential,baseStart,start - 1,baseMax - 1,diffCursor - 1,url,profileName + pathTail(diffMatches,0),base.getElement().get(0).getPath(),base.getElement().get(0).getPath(),trimDifferential,contextName,resultPathBase,false,null);
                  }
 else {
                    StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
                    if (dt == null)                     throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName+ ""String_Node_Str"");
                    contextName=dt.getUrl();
                    int start=diffCursor;
                    while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str""))                     diffCursor++;
                    processPaths(indent + ""String_Node_Str"",result,dt.getSnapshot(),differential,1,start - 1,dt.getSnapshot().getElement().size() - 1,diffCursor - 1,url,profileName + pathTail(diffMatches,0),diffMatches.get(0).getPath(),outcome.getPath(),trimDifferential,contextName,resultPathBase,false,null);
                  }
                }
 else                 if (outcome.getType().get(0).getCode().equals(""String_Node_Str"")) {
                  StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
                  for (                  ElementDefinition extEd : dt.getSnapshot().getElement()) {
                    if (extEd.getPath().contains(""String_Node_Str"")) {
                      ElementDefinition extUrlEd=updateURLs(url,extEd.copy());
                      extUrlEd.setPath(fixedPathDest(outcome.getPath(),extUrlEd.getPath(),null));
                      markDerived(extUrlEd);
                      result.getElement().add(extUrlEd);
                    }
                  }
                }
              }
            }
            diffpos++;
          }
        }
        baseCursor++;
      }
    }
  }
  int i=0;
  for (  ElementDefinition e : result.getElement()) {
    i++;
    if (e.hasMinElement() && e.getMinElement().getValue() == null)     throw new Error(""String_Node_Str"");
  }
  return res;
}","/** 
 * @param trimDifferential
 * @throws DefinitionException , FHIRException 
 * @throws Exception
 */
private ElementDefinition processPaths(String indent,StructureDefinitionSnapshotComponent result,StructureDefinitionSnapshotComponent base,StructureDefinitionDifferentialComponent differential,int baseCursor,int diffCursor,int baseLimit,int diffLimit,String url,String profileName,String contextPathSrc,String contextPathDst,boolean trimDifferential,String contextName,String resultPathBase,boolean slicingDone,ElementDefinition redirector) throws DefinitionException, FHIRException {
  if (DEBUG)   System.out.println(indent + ""String_Node_Str"" + resultPathBase+ ""String_Node_Str""+ baseCursor+ ""String_Node_Str""+ baseLimit+ ""String_Node_Str""+ diffCursor+ ""String_Node_Str""+ diffLimit+ ""String_Node_Str""+ slicingDone+ ""String_Node_Str"");
  ElementDefinition res=null;
  while (baseCursor <= baseLimit) {
    ElementDefinition currentBase=base.getElement().get(baseCursor);
    String cpath=fixedPathSource(contextPathSrc,currentBase.getPath(),redirector);
    if (DEBUG)     System.out.println(indent + ""String_Node_Str"" + cpath+ ""String_Node_Str""+ baseCursor+ ""String_Node_Str""+ baseLimit+ ""String_Node_Str""+ diffCursor+ ""String_Node_Str""+ diffLimit+ ""String_Node_Str""+ slicingDone+ ""String_Node_Str"");
    List<ElementDefinition> diffMatches=getDiffMatches(differential,cpath,diffCursor,diffLimit,profileName,url);
    if (!currentBase.hasSlicing()) {
      if (diffMatches.isEmpty()) {
        ElementDefinition outcome=updateURLs(url,currentBase.copy());
        outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
        updateFromBase(outcome,currentBase);
        markDerived(outcome);
        if (resultPathBase == null)         resultPathBase=outcome.getPath();
 else         if (!outcome.getPath().startsWith(resultPathBase))         throw new DefinitionException(""String_Node_Str"");
        result.getElement().add(outcome);
        if (hasInnerDiffMatches(differential,cpath,diffCursor,diffLimit,base.getElement())) {
          if (outcome.getType().size() > 1) {
            for (            TypeRefComponent t : outcome.getType()) {
              if (!t.getCode().equals(""String_Node_Str""))               throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName);
            }
          }
          StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
          if (dt == null)           throw new DefinitionException(cpath + ""String_Node_Str"" + typeCode(outcome.getType())+ ""String_Node_Str""+ profileName+ ""String_Node_Str"");
          contextName=dt.getUrl();
          int start=diffCursor;
          while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),cpath + ""String_Node_Str""))           diffCursor++;
          processPaths(indent + ""String_Node_Str"",result,dt.getSnapshot(),differential,1,start,dt.getSnapshot().getElement().size() - 1,diffCursor - 1,url,profileName,cpath,outcome.getPath(),trimDifferential,contextName,resultPathBase,false,null);
        }
        baseCursor++;
      }
 else       if (diffMatches.size() == 1 && (slicingDone || !(diffMatches.get(0).hasSlicing() || (isExtension(diffMatches.get(0)) && diffMatches.get(0).hasSliceName())))) {
        ElementDefinition template=null;
        if (diffMatches.get(0).hasType() && diffMatches.get(0).getType().size() == 1 && diffMatches.get(0).getType().get(0).hasProfile() && !diffMatches.get(0).getType().get(0).getCode().equals(""String_Node_Str"")) {
          String p=diffMatches.get(0).getType().get(0).getProfile().get(0).getValue();
          StructureDefinition sd=context.fetchResource(StructureDefinition.class,p);
          if (sd != null) {
            if (!sd.hasSnapshot()) {
              StructureDefinition sdb=context.fetchResource(StructureDefinition.class,sd.getBaseDefinition());
              if (sdb == null)               throw new DefinitionException(""String_Node_Str"" + sd.getBaseDefinition());
              generateSnapshot(sdb,sd,sd.getUrl(),sd.getName());
            }
            template=sd.getSnapshot().getElement().get(0).copy().setPath(currentBase.getPath());
            template.setSliceName(null);
            if (!diffMatches.get(0).getType().get(0).getCode().equals(""String_Node_Str"")) {
              template.setMin(currentBase.getMin());
              template.setMax(currentBase.getMax());
            }
          }
        }
        if (template == null)         template=currentBase.copy();
 else         template=overWriteWithCurrent(template,currentBase);
        ElementDefinition outcome=updateURLs(url,template);
        outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
        if (res == null)         res=outcome;
        updateFromBase(outcome,currentBase);
        if (diffMatches.get(0).hasSliceName())         outcome.setSliceName(diffMatches.get(0).getSliceName());
        outcome.setSlicing(null);
        updateFromDefinition(outcome,diffMatches.get(0),profileName,trimDifferential,url);
        if (outcome.getPath().endsWith(""String_Node_Str"") && outcome.getType().size() == 1 && !outcome.getType().get(0).getCode().equals(""String_Node_Str""))         outcome.setPath(outcome.getPath().substring(0,outcome.getPath().length() - 3) + Utilities.capitalize(outcome.getType().get(0).getCode()));
        if (resultPathBase == null)         resultPathBase=outcome.getPath();
 else         if (!outcome.getPath().startsWith(resultPathBase))         throw new DefinitionException(""String_Node_Str"");
        result.getElement().add(outcome);
        baseCursor++;
        diffCursor=differential.getElement().indexOf(diffMatches.get(0)) + 1;
        if (differential.getElement().size() > diffCursor && outcome.getPath().contains(""String_Node_Str"") && (isDataType(outcome.getType()) || outcome.hasContentReference())) {
          if (pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str"") && !baseWalksInto(base.getElement(),baseCursor)) {
            if (outcome.getType().size() > 1) {
              if (outcome.getPath().endsWith(""String_Node_Str"") && !diffMatches.get(0).getPath().endsWith(""String_Node_Str"")) {
                String en=tail(outcome.getPath());
                String tn=tail(diffMatches.get(0).getPath());
                String t=tn.substring(en.length() - 3);
                if (isPrimitive(Utilities.uncapitalize(t)))                 t=Utilities.uncapitalize(t);
                List<TypeRefComponent> ntr=getByTypeName(outcome.getType(),t);
                if (ntr.isEmpty())                 ntr.add(new TypeRefComponent().setCode(t));
                outcome.getType().clear();
                outcome.getType().addAll(ntr);
              }
              if (outcome.getType().size() > 1)               for (              TypeRefComponent t : outcome.getType()) {
                if (!t.getCode().equals(""String_Node_Str""))                 throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName);
              }
            }
            int start=diffCursor;
            while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str""))             diffCursor++;
            if (outcome.hasContentReference()) {
              ElementDefinition tgt=getElementById(base.getElement(),outcome.getContentReference());
              if (tgt == null)               throw new DefinitionException(""String_Node_Str"" + outcome.getContentReference());
              replaceFromContentReference(outcome,tgt);
              int nbc=base.getElement().indexOf(tgt) + 1;
              int nbl=nbc;
              while (nbl < base.getElement().size() && base.getElement().get(nbl).getPath().startsWith(tgt.getPath() + ""String_Node_Str""))               nbl++;
              processPaths(indent + ""String_Node_Str"",result,base,differential,nbc,start - 1,nbl - 1,diffCursor - 1,url,profileName,tgt.getPath(),diffMatches.get(0).getPath(),trimDifferential,contextName,resultPathBase,false,outcome);
            }
 else {
              StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
              if (dt == null)               throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName+ ""String_Node_Str"");
              contextName=dt.getUrl();
              processPaths(indent + ""String_Node_Str"",result,dt.getSnapshot(),differential,1,start,dt.getSnapshot().getElement().size() - 1,diffCursor - 1,url,profileName + pathTail(diffMatches,0),diffMatches.get(0).getPath(),outcome.getPath(),trimDifferential,contextName,resultPathBase,false,null);
            }
          }
        }
      }
 else {
        if (!unbounded(currentBase) && !isSlicedToOneOnly(diffMatches.get(0)))         throw new DefinitionException(""String_Node_Str"" + currentBase.getPath() + ""String_Node_Str""+ currentBase.getSliceName()+ ""String_Node_Str""+ contextName+ ""String_Node_Str""+ url);
        if (!diffMatches.get(0).hasSlicing() && !isExtension(currentBase))         throw new DefinitionException(""String_Node_Str"" + currentBase.getPath() + ""String_Node_Str""+ url);
        int start=0;
        int nbl=findEndOfElement(base,baseCursor);
        if (diffMatches.size() > 1 && diffMatches.get(0).hasSlicing() && (nbl > baseCursor || differential.getElement().indexOf(diffMatches.get(1)) > differential.getElement().indexOf(diffMatches.get(0)) + 1)) {
          int ndc=differential.getElement().indexOf(diffMatches.get(0));
          int ndl=findEndOfElement(differential,ndc);
          processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,0),contextPathSrc,contextPathDst,trimDifferential,contextName,resultPathBase,true,null).setSlicing(diffMatches.get(0).getSlicing());
          start++;
        }
 else {
          ElementDefinition outcome=updateURLs(url,currentBase.copy());
          outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
          updateFromBase(outcome,currentBase);
          if (!diffMatches.get(0).hasSlicing())           outcome.setSlicing(makeExtensionSlicing());
 else           outcome.setSlicing(diffMatches.get(0).getSlicing().copy());
          if (!outcome.getPath().startsWith(resultPathBase))           throw new DefinitionException(""String_Node_Str"");
          result.getElement().add(outcome);
          if (!diffMatches.get(0).hasSliceName()) {
            updateFromDefinition(outcome,diffMatches.get(0),profileName,trimDifferential,url);
            if (!outcome.hasContentReference() && !outcome.hasType()) {
              throw new DefinitionException(""String_Node_Str"");
            }
            start++;
          }
 else           checkExtensionDoco(outcome);
        }
        int ndc=diffCursor;
        int ndl=diffCursor;
        for (int i=start; i < diffMatches.size(); i++) {
          ndc=differential.getElement().indexOf(diffMatches.get(i));
          ndl=findEndOfElement(differential,ndc);
          processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,i),contextPathSrc,contextPathDst,trimDifferential,contextName,resultPathBase,true,null);
        }
        baseCursor=nbl + 1;
        diffCursor=ndl + 1;
      }
    }
 else {
      String path=currentBase.getPath();
      ElementDefinition original=currentBase;
      if (diffMatches.isEmpty()) {
        while (baseCursor < base.getElement().size() && base.getElement().get(baseCursor).getPath().startsWith(path)) {
          ElementDefinition outcome=updateURLs(url,base.getElement().get(baseCursor).copy());
          outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
          if (!outcome.getPath().startsWith(resultPathBase))           throw new DefinitionException(""String_Node_Str"" + profileName + ""String_Node_Str""+ outcome.getPath()+ ""String_Node_Str""+ resultPathBase);
          result.getElement().add(outcome);
          baseCursor++;
        }
      }
 else {
        boolean closed=currentBase.getSlicing().getRules() == SlicingRules.CLOSED;
        int diffpos=0;
        boolean isExtension=cpath.endsWith(""String_Node_Str"") || cpath.endsWith(""String_Node_Str"");
        if (diffMatches.get(0).hasSlicing()) {
          ElementDefinitionSlicingComponent dSlice=diffMatches.get(0).getSlicing();
          ElementDefinitionSlicingComponent bSlice=currentBase.getSlicing();
          if (dSlice.hasOrderedElement() && bSlice.hasOrderedElement() && !orderMatches(dSlice.getOrderedElement(),bSlice.getOrderedElement()))           throw new DefinitionException(""String_Node_Str"" + summarizeSlicing(dSlice) + ""String_Node_Str""+ summarizeSlicing(bSlice)+ ""String_Node_Str""+ path+ ""String_Node_Str""+ contextName+ ""String_Node_Str"");
          if (!discriminatorMatches(dSlice.getDiscriminator(),bSlice.getDiscriminator()))           throw new DefinitionException(""String_Node_Str"" + summarizeSlicing(dSlice) + ""String_Node_Str""+ summarizeSlicing(bSlice)+ ""String_Node_Str""+ path+ ""String_Node_Str""+ contextName+ ""String_Node_Str"");
          if (!ruleMatches(dSlice.getRules(),bSlice.getRules()))           throw new DefinitionException(""String_Node_Str"" + summarizeSlicing(dSlice) + ""String_Node_Str""+ summarizeSlicing(bSlice)+ ""String_Node_Str""+ path+ ""String_Node_Str""+ contextName+ ""String_Node_Str"");
        }
        ElementDefinition outcome=updateURLs(url,currentBase.copy());
        outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
        updateFromBase(outcome,currentBase);
        if (diffMatches.get(0).hasSlicing() || !diffMatches.get(0).hasSliceName()) {
          updateFromSlicing(outcome.getSlicing(),diffMatches.get(0).getSlicing());
          updateFromDefinition(outcome,diffMatches.get(0),profileName,closed,url);
        }
 else         if (!diffMatches.get(0).hasSliceName())         diffMatches.get(0).setUserData(GENERATED_IN_SNAPSHOT,true);
        result.getElement().add(outcome);
        if (!diffMatches.get(0).hasSliceName()) {
          diffpos++;
        }
        if (diffMatches.size() > 1 && diffMatches.get(0).hasSlicing() && differential.getElement().indexOf(diffMatches.get(1)) > differential.getElement().indexOf(diffMatches.get(0)) + 1) {
          int nbl=findEndOfElement(base,baseCursor);
          int ndc=differential.getElement().indexOf(diffMatches.get(0));
          int ndl=findEndOfElement(differential,ndc);
          processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor + 1,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,0),contextPathSrc,contextPathDst,trimDifferential,contextName,resultPathBase,true,null);
        }
 else         if (currentBase.getType().get(0).getCode().equals(""String_Node_Str"")) {
          int nbl=findEndOfElement(base,baseCursor);
          for (int i=baseCursor + 1; i <= nbl; i++) {
            outcome=updateURLs(url,base.getElement().get(i).copy());
            result.getElement().add(outcome);
          }
        }
        List<ElementDefinition> baseMatches=getSiblings(base.getElement(),currentBase);
        for (        ElementDefinition baseItem : baseMatches) {
          baseCursor=base.getElement().indexOf(baseItem);
          outcome=updateURLs(url,baseItem.copy());
          updateFromBase(outcome,currentBase);
          outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
          outcome.setSlicing(null);
          if (!outcome.getPath().startsWith(resultPathBase))           throw new DefinitionException(""String_Node_Str"");
          if (diffpos < diffMatches.size() && diffMatches.get(diffpos).getSliceName().equals(outcome.getSliceName())) {
            int nbl=findEndOfElement(base,baseCursor);
            int ndc=differential.getElement().indexOf(diffMatches.get(diffpos));
            int ndl=findEndOfElement(differential,ndc);
            processPaths(indent + ""String_Node_Str"",result,base,differential,baseCursor,ndc,nbl,ndl,url,profileName + pathTail(diffMatches,diffpos),contextPathSrc,contextPathDst,closed,contextName,resultPathBase,true,null);
            baseCursor=nbl;
            diffCursor=ndl + 1;
            diffpos++;
          }
 else {
            result.getElement().add(outcome);
            baseCursor++;
            while (baseCursor < base.getElement().size() && base.getElement().get(baseCursor).getPath().startsWith(path) && !base.getElement().get(baseCursor).getPath().equals(path)) {
              outcome=updateURLs(url,base.getElement().get(baseCursor).copy());
              outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
              if (!outcome.getPath().startsWith(resultPathBase))               throw new DefinitionException(""String_Node_Str"");
              result.getElement().add(outcome);
              baseCursor++;
            }
            baseCursor--;
          }
        }
        if (closed && diffpos < diffMatches.size())         throw new DefinitionException(""String_Node_Str"" + profileName + ""String_Node_Str""+ path+ ""String_Node_Str""+ cpath+ ""String_Node_Str"");
        if (diffpos == diffMatches.size()) {
        }
 else {
          while (diffpos < diffMatches.size()) {
            ElementDefinition diffItem=diffMatches.get(diffpos);
            for (            ElementDefinition baseItem : baseMatches)             if (baseItem.getSliceName().equals(diffItem.getSliceName()))             throw new DefinitionException(""String_Node_Str"");
            outcome=updateURLs(url,currentBase.copy());
            outcome.setPath(fixedPathDest(contextPathDst,outcome.getPath(),redirector));
            updateFromBase(outcome,currentBase);
            outcome.setSlicing(null);
            if (!outcome.getPath().startsWith(resultPathBase))             throw new DefinitionException(""String_Node_Str"");
            result.getElement().add(outcome);
            updateFromDefinition(outcome,diffItem,profileName,trimDifferential,url);
            diffCursor=differential.getElement().indexOf(diffItem) + 1;
            if (!outcome.getType().isEmpty() && (differential.getElement().size() > diffCursor) && outcome.getPath().contains(""String_Node_Str"")&& isDataType(outcome.getType())) {
              if (!baseWalksInto(base.getElement(),baseCursor)) {
                if (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str"")) {
                  if (outcome.getType().size() > 1)                   for (                  TypeRefComponent t : outcome.getType()) {
                    if (!t.getCode().equals(""String_Node_Str""))                     throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName);
                  }
                  TypeRefComponent t=outcome.getType().get(0);
                  if (t.getCode().equals(""String_Node_Str"")) {
                    int baseStart=base.getElement().indexOf(currentBase) + 1;
                    int baseMax=baseStart + 1;
                    while (baseMax < base.getElement().size() && base.getElement().get(baseMax).getPath().startsWith(currentBase.getPath() + ""String_Node_Str""))                     baseMax++;
                    int start=diffCursor;
                    while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str""))                     diffCursor++;
                    processPaths(indent + ""String_Node_Str"",result,base,differential,baseStart,start - 1,baseMax - 1,diffCursor - 1,url,profileName + pathTail(diffMatches,0),base.getElement().get(0).getPath(),base.getElement().get(0).getPath(),trimDifferential,contextName,resultPathBase,false,null);
                  }
 else {
                    StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
                    if (dt == null)                     throw new DefinitionException(diffMatches.get(0).getPath() + ""String_Node_Str"" + differential.getElement().get(diffCursor).getPath()+ ""String_Node_Str""+ typeCode(outcome.getType())+ ""String_Node_Str""+ profileName+ ""String_Node_Str"");
                    contextName=dt.getUrl();
                    int start=diffCursor;
                    while (differential.getElement().size() > diffCursor && pathStartsWith(differential.getElement().get(diffCursor).getPath(),diffMatches.get(0).getPath() + ""String_Node_Str""))                     diffCursor++;
                    processPaths(indent + ""String_Node_Str"",result,dt.getSnapshot(),differential,1,start - 1,dt.getSnapshot().getElement().size() - 1,diffCursor - 1,url,profileName + pathTail(diffMatches,0),diffMatches.get(0).getPath(),outcome.getPath(),trimDifferential,contextName,resultPathBase,false,null);
                  }
                }
 else                 if (outcome.getType().get(0).getCode().equals(""String_Node_Str"")) {
                  StructureDefinition dt=getProfileForDataType(outcome.getType().get(0));
                  for (                  ElementDefinition extEd : dt.getSnapshot().getElement()) {
                    if (extEd.getPath().contains(""String_Node_Str"")) {
                      ElementDefinition extUrlEd=updateURLs(url,extEd.copy());
                      extUrlEd.setPath(fixedPathDest(outcome.getPath(),extUrlEd.getPath(),null));
                      markDerived(extUrlEd);
                      result.getElement().add(extUrlEd);
                    }
                  }
                }
              }
            }
            diffpos++;
          }
        }
        baseCursor++;
      }
    }
  }
  int i=0;
  for (  ElementDefinition e : result.getElement()) {
    i++;
    if (e.hasMinElement() && e.getMinElement().getValue() == null)     throw new Error(""String_Node_Str"");
  }
  return res;
}",0.9994474527572108
22967,"private void generateIds(List<ElementDefinition> list,String name) throws DefinitionException {
  if (list.isEmpty())   return;
  Map<String,String> idMap=new HashMap<String,String>();
  List<String> idList=new ArrayList<String>();
  List<String> paths=new ArrayList<String>();
  for (  ElementDefinition ed : list) {
    if (!ed.hasPath())     throw new DefinitionException(""String_Node_Str"" + Integer.toString(list.indexOf(ed)) + ""String_Node_Str""+ name);
    int depth=charCount(ed.getPath(),'.');
    String tail=tail(ed.getPath());
    if (depth > paths.size()) {
      String[] pl=ed.getPath().split(""String_Node_Str"");
      for (int i=paths.size(); i < pl.length - 1; i++)       paths.add(pl[i]);
    }
    while (depth < paths.size() && paths.size() > 0)     paths.remove(paths.size() - 1);
    String t=ed.hasSliceName() ? tail + ""String_Node_Str"" + checkName(ed.getSliceName()) : tail;
    name=null;
    StringBuilder b=new StringBuilder();
    for (    String s : paths) {
      b.append(s);
      b.append(""String_Node_Str"");
    }
    b.append(t);
    String bs=b.toString();
    idMap.put(ed.hasId() ? ed.getId() : ed.getPath(),bs);
    ed.setId(bs);
    if (idList.contains(bs))     throw new DefinitionException(""String_Node_Str"" + bs + ""String_Node_Str""+ name);
    idList.add(bs);
    paths.add(t);
    if (ed.hasContentReference()) {
      String s=ed.getContentReference().substring(1);
      if (idMap.containsKey(s))       ed.setContentReference(""String_Node_Str"" + idMap.get(s));
    }
  }
}","private void generateIds(List<ElementDefinition> list,String name) throws DefinitionException {
  if (list.isEmpty())   return;
  Map<String,String> idMap=new HashMap<String,String>();
  Map<String,String> idList=new HashMap<String,String>();
  for (  ElementDefinition ed : list) {
    List<String> paths=new ArrayList<String>();
    if (!ed.hasPath())     throw new DefinitionException(""String_Node_Str"" + Integer.toString(list.indexOf(ed)) + ""String_Node_Str""+ name);
    String tail=tail(ed.getPath());
    String[] pl=ed.getPath().split(""String_Node_Str"");
    for (int i=paths.size(); i < pl.length - 1; i++)     paths.add(pl[i]);
    String t=ed.hasSliceName() ? tail + ""String_Node_Str"" + checkName(ed.getSliceName()) : tail;
    name=null;
    StringBuilder b=new StringBuilder();
    for (    String s : paths) {
      b.append(s);
      b.append(""String_Node_Str"");
    }
    b.append(t);
    String bs=b.toString();
    idMap.put(ed.hasId() ? ed.getId() : ed.getPath(),bs);
    ed.setId(bs);
    if (idList.containsKey(bs))     throw new DefinitionException(""String_Node_Str"" + bs + ""String_Node_Str""+ idList.get(bs)+ ""String_Node_Str""+ ed.getPath()+ ""String_Node_Str""+ name);
    idList.put(bs,ed.getPath());
    paths.add(t);
    if (ed.hasContentReference()) {
      String s=ed.getContentReference().substring(1);
      if (idMap.containsKey(s))       ed.setContentReference(""String_Node_Str"" + idMap.get(s));
    }
  }
}",0.833051134439553
22968,"private void generate() throws Exception {
  forceDir(tempDir);
  forceDir(Utilities.path(tempDir,""String_Node_Str""));
  forceDir(Utilities.path(tempDir,""String_Node_Str""));
  otherFilesRun.clear();
  otherFilesRun.add(Utilities.path(outputDir,""String_Node_Str""));
  for (  String rg : regenList)   regenerate(rg);
  updateImplementationGuide();
  for (  FetchedFile f : changeList)   generateNativeOutputs(f,false);
  templateBeforeGenerate();
  for (  FetchedFile f : changeList)   generateHtmlOutputs(f,false);
  ValidationPresenter.filterMessages(errors,suppressedMessages,false);
  if (!changeList.isEmpty())   generateSummaryOutputs();
  cleanOutput(tempDir);
  templateAfterGenerate();
  if (runTool()) {
    if (!changeList.isEmpty()) {
      File df=makeSpecFile();
      npm.addFile(Category.OTHER,""String_Node_Str"",TextFile.fileToBytes(df.getAbsolutePath()));
      npm.finish();
      if (mode == null || mode == IGBuildMode.MANUAL) {
        if (cacheVersion)         pcm.addPackageToCache(publishedIg.getPackageId(),publishedIg.getVersion(),new FileInputStream(npm.filename()));
 else         pcm.addPackageToCache(publishedIg.getPackageId(),""String_Node_Str"",new FileInputStream(npm.filename()));
      }
      generateZips(df);
    }
  }
  log(""String_Node_Str"");
  List<ValidationMessage> linkmsgs=inspector.check();
  ValidationPresenter.filterMessages(linkmsgs,suppressedMessages,true);
  int bl=0;
  int lf=0;
  for (  ValidationMessage m : linkmsgs) {
    if (m.getLevel() == IssueSeverity.ERROR) {
      if (m.getType() == IssueType.NOTFOUND)       bl++;
 else       lf++;
    }
 else     if (m.getLevel() == IssueSeverity.FATAL) {
      throw new Exception(m.getMessage());
    }
  }
  log(""String_Node_Str"" + Integer.toString(inspector.total()) + ""String_Node_Str""+ checkPlural(""String_Node_Str"",inspector.total())+ ""String_Node_Str""+ Integer.toString(lf)+ ""String_Node_Str""+ checkPlural(""String_Node_Str"",lf)+ ""String_Node_Str""+ Integer.toString((lf * 100) / (inspector.total() == 0 ? 1 : inspector.total()))+ ""String_Node_Str"");
  log(""String_Node_Str"" + Integer.toString(inspector.links()) + ""String_Node_Str""+ checkPlural(""String_Node_Str"",inspector.links())+ ""String_Node_Str""+ Integer.toString(bl)+ ""String_Node_Str""+ checkPlural(""String_Node_Str"",lf)+ ""String_Node_Str""+ Integer.toString((bl * 100) / (inspector.links() == 0 ? 1 : inspector.links()))+ ""String_Node_Str"");
  errors.addAll(linkmsgs);
  for (  FetchedFile f : fileList)   ValidationPresenter.filterMessages(f.getErrors(),suppressedMessages,false);
  log(""String_Node_Str"");
  if (""String_Node_Str"".equals(ostr(configuration,""String_Node_Str"")) && linkmsgs.size() > 0)   throw new Error(""String_Node_Str"");
  ZipGenerator zip=new ZipGenerator(Utilities.path(tempDir,""String_Node_Str""));
  zip.addFolder(outputDir,""String_Node_Str"",false);
  zip.addFileSource(""String_Node_Str"",REDIRECT_SOURCE,false);
  zip.close();
  Utilities.copyFile(Utilities.path(tempDir,""String_Node_Str""),Utilities.path(outputDir,""String_Node_Str""));
  log(""String_Node_Str"");
}","private void generate() throws Exception {
  forceDir(tempDir);
  forceDir(Utilities.path(tempDir,""String_Node_Str""));
  forceDir(Utilities.path(tempDir,""String_Node_Str""));
  otherFilesRun.clear();
  otherFilesRun.add(Utilities.path(outputDir,""String_Node_Str""));
  for (  String rg : regenList)   regenerate(rg);
  updateImplementationGuide();
  for (  FetchedFile f : changeList)   generateNativeOutputs(f,false);
  templateBeforeGenerate();
  for (  FetchedFile f : changeList)   generateHtmlOutputs(f,false);
  ValidationPresenter.filterMessages(errors,suppressedMessages,false);
  if (!changeList.isEmpty())   generateSummaryOutputs();
  cleanOutput(tempDir);
  templateAfterGenerate();
  if (runTool()) {
    if (!changeList.isEmpty()) {
      File df=makeSpecFile();
      npm.addFile(Category.OTHER,""String_Node_Str"",TextFile.fileToBytes(df.getAbsolutePath()));
      npm.finish();
      File src=new File(npm.filename());
      File tgt=new File(Utilities.path(outputDir,""String_Node_Str""));
      tgt.delete();
      FileUtils.copyFile(src,tgt);
      if (mode == null || mode == IGBuildMode.MANUAL) {
        if (cacheVersion)         pcm.addPackageToCache(publishedIg.getPackageId(),publishedIg.getVersion(),new FileInputStream(npm.filename()));
 else         pcm.addPackageToCache(publishedIg.getPackageId(),""String_Node_Str"",new FileInputStream(npm.filename()));
      }
      generateZips(df);
    }
  }
  log(""String_Node_Str"");
  List<ValidationMessage> linkmsgs=inspector.check();
  ValidationPresenter.filterMessages(linkmsgs,suppressedMessages,true);
  int bl=0;
  int lf=0;
  for (  ValidationMessage m : linkmsgs) {
    if (m.getLevel() == IssueSeverity.ERROR) {
      if (m.getType() == IssueType.NOTFOUND)       bl++;
 else       lf++;
    }
 else     if (m.getLevel() == IssueSeverity.FATAL) {
      throw new Exception(m.getMessage());
    }
  }
  log(""String_Node_Str"" + Integer.toString(inspector.total()) + ""String_Node_Str""+ checkPlural(""String_Node_Str"",inspector.total())+ ""String_Node_Str""+ Integer.toString(lf)+ ""String_Node_Str""+ checkPlural(""String_Node_Str"",lf)+ ""String_Node_Str""+ Integer.toString((lf * 100) / (inspector.total() == 0 ? 1 : inspector.total()))+ ""String_Node_Str"");
  log(""String_Node_Str"" + Integer.toString(inspector.links()) + ""String_Node_Str""+ checkPlural(""String_Node_Str"",inspector.links())+ ""String_Node_Str""+ Integer.toString(bl)+ ""String_Node_Str""+ checkPlural(""String_Node_Str"",lf)+ ""String_Node_Str""+ Integer.toString((bl * 100) / (inspector.links() == 0 ? 1 : inspector.links()))+ ""String_Node_Str"");
  errors.addAll(linkmsgs);
  for (  FetchedFile f : fileList)   ValidationPresenter.filterMessages(f.getErrors(),suppressedMessages,false);
  log(""String_Node_Str"");
  if (""String_Node_Str"".equals(ostr(configuration,""String_Node_Str"")) && linkmsgs.size() > 0)   throw new Error(""String_Node_Str"");
  ZipGenerator zip=new ZipGenerator(Utilities.path(tempDir,""String_Node_Str""));
  zip.addFolder(outputDir,""String_Node_Str"",false);
  zip.addFileSource(""String_Node_Str"",REDIRECT_SOURCE,false);
  zip.close();
  Utilities.copyFile(Utilities.path(tempDir,""String_Node_Str""),Utilities.path(outputDir,""String_Node_Str""));
  log(""String_Node_Str"");
}",0.9734739533397252
22969,"public static org.hl7.fhir.dstu3.model.Resource convertResource(org.hl7.fhir.r4.model.Resource src) throws FHIRException {
  if (src == null)   return null;
  if (src instanceof org.hl7.fhir.r4.model.Parameters)   return convertParameters((org.hl7.fhir.r4.model.Parameters)src);
  if (src instanceof org.hl7.fhir.r4.model.ActivityDefinition)   return convertActivityDefinition((org.hl7.fhir.r4.model.ActivityDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.AllergyIntolerance)   return convertAllergyIntolerance((org.hl7.fhir.r4.model.AllergyIntolerance)src);
  if (src instanceof org.hl7.fhir.r4.model.Appointment)   return convertAppointment((org.hl7.fhir.r4.model.Appointment)src);
  if (src instanceof org.hl7.fhir.r4.model.AppointmentResponse)   return convertAppointmentResponse((org.hl7.fhir.r4.model.AppointmentResponse)src);
  if (src instanceof org.hl7.fhir.r4.model.AuditEvent)   return convertAuditEvent((org.hl7.fhir.r4.model.AuditEvent)src);
  if (src instanceof org.hl7.fhir.r4.model.Basic)   return convertBasic((org.hl7.fhir.r4.model.Basic)src);
  if (src instanceof org.hl7.fhir.r4.model.Binary)   return convertBinary((org.hl7.fhir.r4.model.Binary)src);
  if (src instanceof org.hl7.fhir.r4.model.BodyStructure)   return convertBodySite((org.hl7.fhir.r4.model.BodyStructure)src);
  if (src instanceof org.hl7.fhir.r4.model.Bundle)   return convertBundle((org.hl7.fhir.r4.model.Bundle)src);
  if (src instanceof org.hl7.fhir.r4.model.CapabilityStatement)   return convertCapabilityStatement((org.hl7.fhir.r4.model.CapabilityStatement)src);
  if (src instanceof org.hl7.fhir.r4.model.CareTeam)   return convertCareTeam((org.hl7.fhir.r4.model.CareTeam)src);
  if (src instanceof org.hl7.fhir.r4.model.ChargeItem)   return convertChargeItem((org.hl7.fhir.r4.model.ChargeItem)src);
  if (src instanceof org.hl7.fhir.r4.model.Claim)   return convertClaim((org.hl7.fhir.r4.model.Claim)src);
  if (src instanceof org.hl7.fhir.r4.model.ClinicalImpression)   return convertClinicalImpression((org.hl7.fhir.r4.model.ClinicalImpression)src);
  if (src instanceof org.hl7.fhir.r4.model.CodeSystem)   return convertCodeSystem((org.hl7.fhir.r4.model.CodeSystem)src);
  if (src instanceof org.hl7.fhir.r4.model.Communication)   return convertCommunication((org.hl7.fhir.r4.model.Communication)src);
  if (src instanceof org.hl7.fhir.r4.model.CompartmentDefinition)   return convertCompartmentDefinition((org.hl7.fhir.r4.model.CompartmentDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.Composition)   return convertComposition((org.hl7.fhir.r4.model.Composition)src);
  if (src instanceof org.hl7.fhir.r4.model.ConceptMap)   return convertConceptMap((org.hl7.fhir.r4.model.ConceptMap)src);
  if (src instanceof org.hl7.fhir.r4.model.Condition)   return convertCondition((org.hl7.fhir.r4.model.Condition)src);
  if (src instanceof org.hl7.fhir.r4.model.Consent)   return convertConsent((org.hl7.fhir.r4.model.Consent)src);
  if (src instanceof org.hl7.fhir.r4.model.DetectedIssue)   return convertDetectedIssue((org.hl7.fhir.r4.model.DetectedIssue)src);
  if (src instanceof org.hl7.fhir.r4.model.Device)   return convertDevice((org.hl7.fhir.r4.model.Device)src);
  if (src instanceof org.hl7.fhir.r4.model.DeviceComponent)   return convertDeviceComponent((org.hl7.fhir.r4.model.DeviceComponent)src);
  if (src instanceof org.hl7.fhir.r4.model.DeviceMetric)   return convertDeviceMetric((org.hl7.fhir.r4.model.DeviceMetric)src);
  if (src instanceof org.hl7.fhir.r4.model.DeviceUseStatement)   return convertDeviceUseStatement((org.hl7.fhir.r4.model.DeviceUseStatement)src);
  if (src instanceof org.hl7.fhir.r4.model.DiagnosticReport)   return convertDiagnosticReport((org.hl7.fhir.r4.model.DiagnosticReport)src);
  if (src instanceof org.hl7.fhir.r4.model.DocumentReference)   return convertDocumentReference((org.hl7.fhir.r4.model.DocumentReference)src);
  if (src instanceof org.hl7.fhir.r4.model.EligibilityRequest)   return convertEligibilityRequest((org.hl7.fhir.r4.model.EligibilityRequest)src);
  if (src instanceof org.hl7.fhir.r4.model.Encounter)   return convertEncounter((org.hl7.fhir.r4.model.Encounter)src);
  if (src instanceof org.hl7.fhir.r4.model.Endpoint)   return convertEndpoint((org.hl7.fhir.r4.model.Endpoint)src);
  if (src instanceof org.hl7.fhir.r4.model.EpisodeOfCare)   return convertEpisodeOfCare((org.hl7.fhir.r4.model.EpisodeOfCare)src);
  if (src instanceof org.hl7.fhir.r4.model.ExpansionProfile)   return convertExpansionProfile((org.hl7.fhir.r4.model.ExpansionProfile)src);
  if (src instanceof org.hl7.fhir.r4.model.FamilyMemberHistory)   return convertFamilyMemberHistory((org.hl7.fhir.r4.model.FamilyMemberHistory)src);
  if (src instanceof org.hl7.fhir.r4.model.Flag)   return convertFlag((org.hl7.fhir.r4.model.Flag)src);
  if (src instanceof org.hl7.fhir.r4.model.Goal)   return convertGoal((org.hl7.fhir.r4.model.Goal)src);
  if (src instanceof org.hl7.fhir.r4.model.GraphDefinition)   return convertGraphDefinition((org.hl7.fhir.r4.model.GraphDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.Group)   return convertGroup((org.hl7.fhir.r4.model.Group)src);
  if (src instanceof org.hl7.fhir.r4.model.HealthcareService)   return convertHealthcareService((org.hl7.fhir.r4.model.HealthcareService)src);
  if (src instanceof org.hl7.fhir.r4.model.Immunization)   return convertImmunization((org.hl7.fhir.r4.model.Immunization)src);
  if (src instanceof org.hl7.fhir.r4.model.ImplementationGuide)   return convertImplementationGuide((org.hl7.fhir.r4.model.ImplementationGuide)src);
  if (src instanceof org.hl7.fhir.r4.model.Linkage)   return convertLinkage((org.hl7.fhir.r4.model.Linkage)src);
  if (src instanceof org.hl7.fhir.r4.model.ListResource)   return convertList((org.hl7.fhir.r4.model.ListResource)src);
  if (src instanceof org.hl7.fhir.r4.model.Location)   return convertLocation((org.hl7.fhir.r4.model.Location)src);
  if (src instanceof org.hl7.fhir.r4.model.Medication)   return convertMedication((org.hl7.fhir.r4.model.Medication)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationAdministration)   return convertMedicationAdministration((org.hl7.fhir.r4.model.MedicationAdministration)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationDispense)   return convertMedicationDispense((org.hl7.fhir.r4.model.MedicationDispense)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationRequest)   return convertMedicationRequest((org.hl7.fhir.r4.model.MedicationRequest)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationStatement)   return convertMedicationStatement((org.hl7.fhir.r4.model.MedicationStatement)src);
  if (src instanceof org.hl7.fhir.r4.model.MessageDefinition)   return convertMessageDefinition((org.hl7.fhir.r4.model.MessageDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.MessageHeader)   return convertMessageHeader((org.hl7.fhir.r4.model.MessageHeader)src);
  if (src instanceof org.hl7.fhir.r4.model.NamingSystem)   return convertNamingSystem((org.hl7.fhir.r4.model.NamingSystem)src);
  if (src instanceof org.hl7.fhir.r4.model.Observation)   return convertObservation((org.hl7.fhir.r4.model.Observation)src);
  if (src instanceof org.hl7.fhir.r4.model.OperationDefinition)   return convertOperationDefinition((org.hl7.fhir.r4.model.OperationDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.OperationOutcome)   return convertOperationOutcome((org.hl7.fhir.r4.model.OperationOutcome)src);
  if (src instanceof org.hl7.fhir.r4.model.Organization)   return convertOrganization((org.hl7.fhir.r4.model.Organization)src);
  if (src instanceof org.hl7.fhir.r4.model.Patient)   return convertPatient((org.hl7.fhir.r4.model.Patient)src);
  if (src instanceof org.hl7.fhir.r4.model.PaymentNotice)   return convertPaymentNotice((org.hl7.fhir.r4.model.PaymentNotice)src);
  if (src instanceof org.hl7.fhir.r4.model.Person)   return convertPerson((org.hl7.fhir.r4.model.Person)src);
  if (src instanceof org.hl7.fhir.r4.model.Practitioner)   return convertPractitioner((org.hl7.fhir.r4.model.Practitioner)src);
  if (src instanceof org.hl7.fhir.r4.model.PractitionerRole)   return convertPractitionerRole((org.hl7.fhir.r4.model.PractitionerRole)src);
  if (src instanceof org.hl7.fhir.r4.model.ProcessRequest)   return convertProcessRequest((org.hl7.fhir.r4.model.ProcessRequest)src);
  if (src instanceof org.hl7.fhir.r4.model.Questionnaire)   return convertQuestionnaire((org.hl7.fhir.r4.model.Questionnaire)src);
  if (src instanceof org.hl7.fhir.r4.model.QuestionnaireResponse)   return convertQuestionnaireResponse((org.hl7.fhir.r4.model.QuestionnaireResponse)src);
  if (src instanceof org.hl7.fhir.r4.model.RiskAssessment)   return convertRiskAssessment((org.hl7.fhir.r4.model.RiskAssessment)src);
  if (src instanceof org.hl7.fhir.r4.model.Schedule)   return convertSchedule((org.hl7.fhir.r4.model.Schedule)src);
  if (src instanceof org.hl7.fhir.r4.model.SearchParameter)   return convertSearchParameter((org.hl7.fhir.r4.model.SearchParameter)src);
  if (src instanceof org.hl7.fhir.r4.model.Sequence)   return convertSequence((org.hl7.fhir.r4.model.Sequence)src);
  if (src instanceof org.hl7.fhir.r4.model.Slot)   return convertSlot((org.hl7.fhir.r4.model.Slot)src);
  if (src instanceof org.hl7.fhir.r4.model.Specimen)   return convertSpecimen((org.hl7.fhir.r4.model.Specimen)src);
  if (src instanceof org.hl7.fhir.r4.model.StructureDefinition)   return convertStructureDefinition((org.hl7.fhir.r4.model.StructureDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.StructureMap)   return convertStructureMap((org.hl7.fhir.r4.model.StructureMap)src);
  if (src instanceof org.hl7.fhir.r4.model.Subscription)   return convertSubscription((org.hl7.fhir.r4.model.Subscription)src);
  if (src instanceof org.hl7.fhir.r4.model.Substance)   return convertSubstance((org.hl7.fhir.r4.model.Substance)src);
  if (src instanceof org.hl7.fhir.r4.model.SupplyDelivery)   return convertSupplyDelivery((org.hl7.fhir.r4.model.SupplyDelivery)src);
  if (src instanceof org.hl7.fhir.r4.model.TestReport)   return convertTestReport((org.hl7.fhir.r4.model.TestReport)src);
  if (src instanceof org.hl7.fhir.r4.model.TestScript)   return convertTestScript((org.hl7.fhir.r4.model.TestScript)src);
  if (src instanceof org.hl7.fhir.r4.model.ValueSet)   return convertValueSet((org.hl7.fhir.r4.model.ValueSet)src);
  throw new Error(""String_Node_Str"" + src.fhirType());
}","public static org.hl7.fhir.dstu3.model.Resource convertResource(org.hl7.fhir.r4.model.Resource src) throws FHIRException {
  if (src == null)   return null;
  if (src instanceof org.hl7.fhir.r4.model.Parameters)   return convertParameters((org.hl7.fhir.r4.model.Parameters)src);
  if (src instanceof org.hl7.fhir.r4.model.ActivityDefinition)   return convertActivityDefinition((org.hl7.fhir.r4.model.ActivityDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.AllergyIntolerance)   return convertAllergyIntolerance((org.hl7.fhir.r4.model.AllergyIntolerance)src);
  if (src instanceof org.hl7.fhir.r4.model.Appointment)   return convertAppointment((org.hl7.fhir.r4.model.Appointment)src);
  if (src instanceof org.hl7.fhir.r4.model.AppointmentResponse)   return convertAppointmentResponse((org.hl7.fhir.r4.model.AppointmentResponse)src);
  if (src instanceof org.hl7.fhir.r4.model.AuditEvent)   return convertAuditEvent((org.hl7.fhir.r4.model.AuditEvent)src);
  if (src instanceof org.hl7.fhir.r4.model.Basic)   return convertBasic((org.hl7.fhir.r4.model.Basic)src);
  if (src instanceof org.hl7.fhir.r4.model.Binary)   return convertBinary((org.hl7.fhir.r4.model.Binary)src);
  if (src instanceof org.hl7.fhir.r4.model.BodyStructure)   return convertBodySite((org.hl7.fhir.r4.model.BodyStructure)src);
  if (src instanceof org.hl7.fhir.r4.model.Bundle)   return convertBundle((org.hl7.fhir.r4.model.Bundle)src);
  if (src instanceof org.hl7.fhir.r4.model.CapabilityStatement)   return convertCapabilityStatement((org.hl7.fhir.r4.model.CapabilityStatement)src);
  if (src instanceof org.hl7.fhir.r4.model.CareTeam)   return convertCareTeam((org.hl7.fhir.r4.model.CareTeam)src);
  if (src instanceof org.hl7.fhir.r4.model.Claim)   return convertClaim((org.hl7.fhir.r4.model.Claim)src);
  if (src instanceof org.hl7.fhir.r4.model.ClinicalImpression)   return convertClinicalImpression((org.hl7.fhir.r4.model.ClinicalImpression)src);
  if (src instanceof org.hl7.fhir.r4.model.CodeSystem)   return convertCodeSystem((org.hl7.fhir.r4.model.CodeSystem)src);
  if (src instanceof org.hl7.fhir.r4.model.Communication)   return convertCommunication((org.hl7.fhir.r4.model.Communication)src);
  if (src instanceof org.hl7.fhir.r4.model.CompartmentDefinition)   return convertCompartmentDefinition((org.hl7.fhir.r4.model.CompartmentDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.Composition)   return convertComposition((org.hl7.fhir.r4.model.Composition)src);
  if (src instanceof org.hl7.fhir.r4.model.ConceptMap)   return convertConceptMap((org.hl7.fhir.r4.model.ConceptMap)src);
  if (src instanceof org.hl7.fhir.r4.model.Condition)   return convertCondition((org.hl7.fhir.r4.model.Condition)src);
  if (src instanceof org.hl7.fhir.r4.model.Consent)   return convertConsent((org.hl7.fhir.r4.model.Consent)src);
  if (src instanceof org.hl7.fhir.r4.model.DetectedIssue)   return convertDetectedIssue((org.hl7.fhir.r4.model.DetectedIssue)src);
  if (src instanceof org.hl7.fhir.r4.model.Device)   return convertDevice((org.hl7.fhir.r4.model.Device)src);
  if (src instanceof org.hl7.fhir.r4.model.DeviceComponent)   return convertDeviceComponent((org.hl7.fhir.r4.model.DeviceComponent)src);
  if (src instanceof org.hl7.fhir.r4.model.DeviceMetric)   return convertDeviceMetric((org.hl7.fhir.r4.model.DeviceMetric)src);
  if (src instanceof org.hl7.fhir.r4.model.DeviceUseStatement)   return convertDeviceUseStatement((org.hl7.fhir.r4.model.DeviceUseStatement)src);
  if (src instanceof org.hl7.fhir.r4.model.DiagnosticReport)   return convertDiagnosticReport((org.hl7.fhir.r4.model.DiagnosticReport)src);
  if (src instanceof org.hl7.fhir.r4.model.DocumentReference)   return convertDocumentReference((org.hl7.fhir.r4.model.DocumentReference)src);
  if (src instanceof org.hl7.fhir.r4.model.EligibilityRequest)   return convertEligibilityRequest((org.hl7.fhir.r4.model.EligibilityRequest)src);
  if (src instanceof org.hl7.fhir.r4.model.Encounter)   return convertEncounter((org.hl7.fhir.r4.model.Encounter)src);
  if (src instanceof org.hl7.fhir.r4.model.Endpoint)   return convertEndpoint((org.hl7.fhir.r4.model.Endpoint)src);
  if (src instanceof org.hl7.fhir.r4.model.EpisodeOfCare)   return convertEpisodeOfCare((org.hl7.fhir.r4.model.EpisodeOfCare)src);
  if (src instanceof org.hl7.fhir.r4.model.ExpansionProfile)   return convertExpansionProfile((org.hl7.fhir.r4.model.ExpansionProfile)src);
  if (src instanceof org.hl7.fhir.r4.model.FamilyMemberHistory)   return convertFamilyMemberHistory((org.hl7.fhir.r4.model.FamilyMemberHistory)src);
  if (src instanceof org.hl7.fhir.r4.model.Flag)   return convertFlag((org.hl7.fhir.r4.model.Flag)src);
  if (src instanceof org.hl7.fhir.r4.model.Goal)   return convertGoal((org.hl7.fhir.r4.model.Goal)src);
  if (src instanceof org.hl7.fhir.r4.model.GraphDefinition)   return convertGraphDefinition((org.hl7.fhir.r4.model.GraphDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.Group)   return convertGroup((org.hl7.fhir.r4.model.Group)src);
  if (src instanceof org.hl7.fhir.r4.model.HealthcareService)   return convertHealthcareService((org.hl7.fhir.r4.model.HealthcareService)src);
  if (src instanceof org.hl7.fhir.r4.model.Immunization)   return convertImmunization((org.hl7.fhir.r4.model.Immunization)src);
  if (src instanceof org.hl7.fhir.r4.model.ImplementationGuide)   return convertImplementationGuide((org.hl7.fhir.r4.model.ImplementationGuide)src);
  if (src instanceof org.hl7.fhir.r4.model.Linkage)   return convertLinkage((org.hl7.fhir.r4.model.Linkage)src);
  if (src instanceof org.hl7.fhir.r4.model.ListResource)   return convertList((org.hl7.fhir.r4.model.ListResource)src);
  if (src instanceof org.hl7.fhir.r4.model.Location)   return convertLocation((org.hl7.fhir.r4.model.Location)src);
  if (src instanceof org.hl7.fhir.r4.model.Medication)   return convertMedication((org.hl7.fhir.r4.model.Medication)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationAdministration)   return convertMedicationAdministration((org.hl7.fhir.r4.model.MedicationAdministration)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationDispense)   return convertMedicationDispense((org.hl7.fhir.r4.model.MedicationDispense)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationRequest)   return convertMedicationRequest((org.hl7.fhir.r4.model.MedicationRequest)src);
  if (src instanceof org.hl7.fhir.r4.model.MedicationStatement)   return convertMedicationStatement((org.hl7.fhir.r4.model.MedicationStatement)src);
  if (src instanceof org.hl7.fhir.r4.model.MessageDefinition)   return convertMessageDefinition((org.hl7.fhir.r4.model.MessageDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.MessageHeader)   return convertMessageHeader((org.hl7.fhir.r4.model.MessageHeader)src);
  if (src instanceof org.hl7.fhir.r4.model.NamingSystem)   return convertNamingSystem((org.hl7.fhir.r4.model.NamingSystem)src);
  if (src instanceof org.hl7.fhir.r4.model.Observation)   return convertObservation((org.hl7.fhir.r4.model.Observation)src);
  if (src instanceof org.hl7.fhir.r4.model.OperationDefinition)   return convertOperationDefinition((org.hl7.fhir.r4.model.OperationDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.OperationOutcome)   return convertOperationOutcome((org.hl7.fhir.r4.model.OperationOutcome)src);
  if (src instanceof org.hl7.fhir.r4.model.Organization)   return convertOrganization((org.hl7.fhir.r4.model.Organization)src);
  if (src instanceof org.hl7.fhir.r4.model.Patient)   return convertPatient((org.hl7.fhir.r4.model.Patient)src);
  if (src instanceof org.hl7.fhir.r4.model.PaymentNotice)   return convertPaymentNotice((org.hl7.fhir.r4.model.PaymentNotice)src);
  if (src instanceof org.hl7.fhir.r4.model.Person)   return convertPerson((org.hl7.fhir.r4.model.Person)src);
  if (src instanceof org.hl7.fhir.r4.model.Practitioner)   return convertPractitioner((org.hl7.fhir.r4.model.Practitioner)src);
  if (src instanceof org.hl7.fhir.r4.model.PractitionerRole)   return convertPractitionerRole((org.hl7.fhir.r4.model.PractitionerRole)src);
  if (src instanceof org.hl7.fhir.r4.model.ProcessRequest)   return convertProcessRequest((org.hl7.fhir.r4.model.ProcessRequest)src);
  if (src instanceof org.hl7.fhir.r4.model.Questionnaire)   return convertQuestionnaire((org.hl7.fhir.r4.model.Questionnaire)src);
  if (src instanceof org.hl7.fhir.r4.model.QuestionnaireResponse)   return convertQuestionnaireResponse((org.hl7.fhir.r4.model.QuestionnaireResponse)src);
  if (src instanceof org.hl7.fhir.r4.model.RiskAssessment)   return convertRiskAssessment((org.hl7.fhir.r4.model.RiskAssessment)src);
  if (src instanceof org.hl7.fhir.r4.model.Schedule)   return convertSchedule((org.hl7.fhir.r4.model.Schedule)src);
  if (src instanceof org.hl7.fhir.r4.model.SearchParameter)   return convertSearchParameter((org.hl7.fhir.r4.model.SearchParameter)src);
  if (src instanceof org.hl7.fhir.r4.model.Sequence)   return convertSequence((org.hl7.fhir.r4.model.Sequence)src);
  if (src instanceof org.hl7.fhir.r4.model.Slot)   return convertSlot((org.hl7.fhir.r4.model.Slot)src);
  if (src instanceof org.hl7.fhir.r4.model.Specimen)   return convertSpecimen((org.hl7.fhir.r4.model.Specimen)src);
  if (src instanceof org.hl7.fhir.r4.model.StructureDefinition)   return convertStructureDefinition((org.hl7.fhir.r4.model.StructureDefinition)src);
  if (src instanceof org.hl7.fhir.r4.model.StructureMap)   return convertStructureMap((org.hl7.fhir.r4.model.StructureMap)src);
  if (src instanceof org.hl7.fhir.r4.model.Subscription)   return convertSubscription((org.hl7.fhir.r4.model.Subscription)src);
  if (src instanceof org.hl7.fhir.r4.model.Substance)   return convertSubstance((org.hl7.fhir.r4.model.Substance)src);
  if (src instanceof org.hl7.fhir.r4.model.SupplyDelivery)   return convertSupplyDelivery((org.hl7.fhir.r4.model.SupplyDelivery)src);
  if (src instanceof org.hl7.fhir.r4.model.TestReport)   return convertTestReport((org.hl7.fhir.r4.model.TestReport)src);
  if (src instanceof org.hl7.fhir.r4.model.TestScript)   return convertTestScript((org.hl7.fhir.r4.model.TestScript)src);
  if (src instanceof org.hl7.fhir.r4.model.ValueSet)   return convertValueSet((org.hl7.fhir.r4.model.ValueSet)src);
  throw new Error(""String_Node_Str"" + src.fhirType());
}",0.9941062801932368
22970,"@SuppressWarnings(""String_Node_Str"") @Override public <T extends Resource>T fetchResourceWithException(Class<T> class_,String uri) throws FHIRException {
  if (class_ == StructureDefinition.class)   uri=ProfileUtilities.sdNs(uri);
synchronized (lock) {
    if (uri.startsWith(""String_Node_Str"") || uri.startsWith(""String_Node_Str"")) {
      String version=null;
      if (uri.contains(""String_Node_Str""))       uri=uri.substring(0,uri.indexOf(""String_Node_Str""));
      if (class_ == Resource.class || class_ == null) {
        if (structures.containsKey(uri))         return (T)structures.get(uri);
        if (valueSets.containsKey(uri))         return (T)valueSets.get(uri);
        if (codeSystems.containsKey(uri))         return (T)codeSystems.get(uri);
        if (operations.containsKey(uri))         return (T)operations.get(uri);
        if (searchParameters.containsKey(uri))         return (T)searchParameters.get(uri);
        if (maps.containsKey(uri))         return (T)maps.get(uri);
        if (transforms.containsKey(uri))         return (T)transforms.get(uri);
        if (questionnaires.containsKey(uri))         return (T)questionnaires.get(uri);
        return null;
      }
 else       if (class_ == StructureDefinition.class) {
        return (T)structures.get(uri);
      }
 else       if (class_ == ValueSet.class) {
        return (T)valueSets.get(uri);
      }
 else       if (class_ == CodeSystem.class) {
        return (T)codeSystems.get(uri);
      }
 else       if (class_ == OperationDefinition.class) {
        OperationDefinition od=operations.get(uri);
        return (T)od;
      }
 else       if (class_ == SearchParameter.class) {
        SearchParameter res=searchParameters.get(uri);
        if (res == null) {
          StringBuilder b=new StringBuilder();
          for (          String s : searchParameters.keySet()) {
            b.append(s);
            b.append(""String_Node_Str"");
          }
        }
        if (res != null)         return (T)res;
      }
    }
    if (class_ == Questionnaire.class)     return (T)questionnaires.get(uri);
    if (class_ == null) {
      if (uri.matches(Constants.URI_REGEX) && !uri.contains(""String_Node_Str""))       return null;
      if (Utilities.isAbsoluteUrl(uri) || uri.startsWith(""String_Node_Str"")) {
        Resource res=findTxValueSet(uri);
        if (res != null)         return (T)res;
      }
      return null;
    }
    throw new FHIRException(""String_Node_Str"" + uri);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public <T extends Resource>T fetchResourceWithException(Class<T> class_,String uri) throws FHIRException {
  if (class_ == StructureDefinition.class)   uri=ProfileUtilities.sdNs(uri);
synchronized (lock) {
    if (uri.startsWith(""String_Node_Str"") || uri.startsWith(""String_Node_Str"")) {
      String version=null;
      if (uri.contains(""String_Node_Str""))       uri=uri.substring(0,uri.indexOf(""String_Node_Str""));
      if (class_ == Resource.class || class_ == null) {
        if (structures.containsKey(uri))         return (T)structures.get(uri);
        if (valueSets.containsKey(uri))         return (T)valueSets.get(uri);
        if (codeSystems.containsKey(uri))         return (T)codeSystems.get(uri);
        if (operations.containsKey(uri))         return (T)operations.get(uri);
        if (searchParameters.containsKey(uri))         return (T)searchParameters.get(uri);
        if (maps.containsKey(uri))         return (T)maps.get(uri);
        if (transforms.containsKey(uri))         return (T)transforms.get(uri);
        if (questionnaires.containsKey(uri))         return (T)questionnaires.get(uri);
        return null;
      }
 else       if (class_ == StructureDefinition.class) {
        return (T)structures.get(uri);
      }
 else       if (class_ == ValueSet.class) {
        return (T)valueSets.get(uri);
      }
 else       if (class_ == CodeSystem.class) {
        return (T)codeSystems.get(uri);
      }
 else       if (class_ == ConceptMap.class) {
        return (T)maps.get(uri);
      }
 else       if (class_ == OperationDefinition.class) {
        OperationDefinition od=operations.get(uri);
        return (T)od;
      }
 else       if (class_ == SearchParameter.class) {
        SearchParameter res=searchParameters.get(uri);
        if (res == null) {
          StringBuilder b=new StringBuilder();
          for (          String s : searchParameters.keySet()) {
            b.append(s);
            b.append(""String_Node_Str"");
          }
        }
        if (res != null)         return (T)res;
      }
    }
    if (class_ == Questionnaire.class)     return (T)questionnaires.get(uri);
    if (class_ == null) {
      if (uri.matches(Constants.URI_REGEX) && !uri.contains(""String_Node_Str""))       return null;
      if (Utilities.isAbsoluteUrl(uri) || uri.startsWith(""String_Node_Str"")) {
        Resource res=findTxValueSet(uri);
        if (res != null)         return (T)res;
      }
      return null;
    }
    throw new FHIRException(""String_Node_Str"" + uri);
  }
}",0.9827552031714568
22971,"public void sortDifferential(StructureDefinition base,StructureDefinition diff,String name,List<String> errors) throws FHIRException {
  final List<ElementDefinition> diffList=diff.getDifferential().getElement();
  if (diffList.isEmpty())   return;
  ElementDefinitionHolder edh=new ElementDefinitionHolder(diffList.get(0));
  boolean hasSlicing=false;
  List<String> paths=new ArrayList<String>();
  for (  ElementDefinition elt : diffList) {
    if (elt.hasSlicing() || paths.contains(elt.getPath())) {
      hasSlicing=true;
      break;
    }
    paths.add(elt.getPath());
  }
  if (!hasSlicing) {
    Collections.sort(diffList,new ElementNameCompare());
  }
  int i=1;
  processElementsIntoTree(edh,i,diff.getDifferential().getElement());
  ElementDefinitionComparer cmp=new ElementDefinitionComparer(true,base.getSnapshot().getElement(),""String_Node_Str"",0,name);
  sortElements(edh,cmp,errors);
  diffList.clear();
  writeElements(edh,diffList);
}","public void sortDifferential(StructureDefinition base,StructureDefinition diff,String name,List<String> errors) throws FHIRException {
  final List<ElementDefinition> diffList=diff.getDifferential().getElement();
  if (diffList.isEmpty())   return;
  ElementDefinitionHolder edh=null;
  int i=0;
  if (diffList.get(0).getPath().contains(""String_Node_Str"")) {
    String newPath=diffList.get(0).getPath().split(""String_Node_Str"")[0];
    ElementDefinition e=new ElementDefinition(new StringType(newPath));
    edh=new ElementDefinitionHolder(e,true);
  }
 else {
    edh=new ElementDefinitionHolder(diffList.get(0));
    i=1;
  }
  boolean hasSlicing=false;
  List<String> paths=new ArrayList<String>();
  for (  ElementDefinition elt : diffList) {
    if (elt.hasSlicing() || paths.contains(elt.getPath())) {
      hasSlicing=true;
      break;
    }
    paths.add(elt.getPath());
  }
  if (!hasSlicing) {
    Collections.sort(diffList,new ElementNameCompare());
  }
  processElementsIntoTree(edh,i,diff.getDifferential().getElement());
  ElementDefinitionComparer cmp=new ElementDefinitionComparer(true,base.getSnapshot().getElement(),""String_Node_Str"",0,name);
  sortElements(edh,cmp,errors);
  diffList.clear();
  writeElements(edh,diffList);
}",0.8568832348932304
22972,"public ValidationEngine(String src) throws Exception {
  loadDefinitions(src);
}","public ValidationEngine(String src) throws Exception {
  loadDefinitions(src);
  pcm=new PackageCacheManager(true);
}",0.8121827411167513
22973,"private PackageInfo loadPackageInfo(String path) throws IOException {
  PackageInfo pi=new PackageInfo(path);
  for (  String f : sorted(new File(path).list())) {
    if (new File(Utilities.path(path,f)).isDirectory()) {
      pi.folders.add(f);
    }
  }
  pi.npm=(JsonObject)new com.google.gson.JsonParser().parse(TextFile.fileToString(Utilities.path(path,""String_Node_Str"",""String_Node_Str"")));
  return pi;
}","private PackageInfo loadPackageInfo(String path) throws IOException {
  PackageInfo pi=new PackageInfo(path);
  for (  String f : sorted(new File(path).list())) {
    if (new File(Utilities.path(path,f)).isDirectory()) {
      pi.folders.add(f);
    }
  }
  pi.npm=(JsonObject)new com.google.gson.JsonParser().parse(TextFile.fileToString(Utilities.path(path,""String_Node_Str"",""String_Node_Str"")));
  pi.cache=new IniFile(Utilities.path(path,""String_Node_Str""));
  return pi;
}",0.927927927927928
22974,"public static void main(String[] args) throws Exception {
  if (args.length == 0) {
    runGUI();
  }
 else   if (hasParam(args,""String_Node_Str"")) {
    try {
      ValidationEngineTests.execute();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"")|| hasParam(args,""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + Constants.VERSION + ""String_Node_Str""+ Constants.REVISION);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else {
    String definitions=""String_Node_Str"";
    String map=null;
    List<String> igs=new ArrayList<String>();
    List<String> questionnaires=new ArrayList<String>();
    String txServer=""String_Node_Str"";
    boolean doNative=false;
    List<String> profiles=new ArrayList<String>();
    EngineMode mode=EngineMode.VALIDATION;
    String output=null;
    List<String> sources=new ArrayList<String>();
    Map<String,String> locations=new HashMap<String,String>();
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       definitions=args[++i];
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       output=args[++i];
 else       if (args[i].equals(""String_Node_Str"")) {
        String p=null;
        if (i + 1 == args.length)         throw new Error(""String_Node_Str"");
 else {
          p=args[++i];
          profiles.add(p);
        }
        if (p != null && i + 1 < args.length && args[i + 1].equals(""String_Node_Str"")) {
          i++;
          if (i + 1 == args.length)           throw new Error(""String_Node_Str"");
 else           locations.put(p,args[++i]);
        }
      }
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       questionnaires.add(args[++i]);
 else       if (args[i].equals(""String_Node_Str""))       doNative=true;
 else       if (args[i].equals(""String_Node_Str"")) {
        map=args[++i];
        mode=EngineMode.TRANSFORM;
      }
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.NARRATIVE;
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.SNAPSHOT;
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       txServer=""String_Node_Str"".equals(args[++i]) ? null : args[i];
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       igs.add(args[++i]);
 else       if (args[i].equals(""String_Node_Str""))       if (map == null)       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       map=args[++i];
 else       throw new Exception(""String_Node_Str"");
 else       if (args[i].startsWith(""String_Node_Str""))       i++;
 else       sources.add(args[i]);
    }
    if (sources.isEmpty())     throw new Exception(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + definitions);
    System.out.println(""String_Node_Str"" + txServer);
    ValidationEngine validator=new ValidationEngine(definitions,txServer);
    System.out.println(""String_Node_Str"" + validator.getContext().getVersion() + ""String_Node_Str"");
    for (    String src : igs) {
      System.out.println(""String_Node_Str"" + src);
      validator.loadIg(src);
    }
    validator.setQuestionnaires(questionnaires);
    validator.setNative(doNative);
    XmlParser x=new XmlParser();
    if (mode == EngineMode.TRANSFORM) {
      if (sources.size() > 1)       throw new Exception(""String_Node_Str"" + sources + ""String_Node_Str"");
      if (txServer == null)       throw new Exception(""String_Node_Str"");
      if (map == null)       throw new Exception(""String_Node_Str"");
      try {
        Resource r=validator.transform(sources.get(0),map);
        System.out.println(""String_Node_Str"");
        if (output != null) {
          FileOutputStream s=new FileOutputStream(output);
          x.setOutputStyle(OutputStyle.PRETTY);
          x.compose(s,r,true);
          s.close();
        }
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
      }
    }
 else     if (mode == EngineMode.NARRATIVE) {
      DomainResource r=validator.generate(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else     if (mode == EngineMode.SNAPSHOT) {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      StructureDefinition r=validator.snapshot(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      for (      String s : profiles) {
        if (validator.getContext().fetchResource(StructureDefinition.class,s) == null) {
          System.out.println(""String_Node_Str"" + s);
          validator.loadProfile(locations.getOrDefault(s,s));
        }
      }
      System.out.println(""String_Node_Str"");
      Resource r=validator.validate(sources,profiles);
      if (output == null) {
        if (r instanceof Bundle)         for (        BundleEntryComponent e : ((Bundle)r).getEntry())         displayOO((OperationOutcome)e.getResource());
 else         displayOO((OperationOutcome)r);
      }
 else {
        FileOutputStream s=new FileOutputStream(output);
        x.compose(s,r,true);
        s.close();
      }
    }
  }
}","public static void main(String[] args) throws Exception {
  if (args.length == 0) {
    runGUI();
  }
 else   if (hasParam(args,""String_Node_Str"")) {
    try {
      ValidationEngineTests.execute();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"") || hasParam(args,""String_Node_Str"")|| hasParam(args,""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + Constants.VERSION + ""String_Node_Str""+ Constants.REVISION);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 else {
    String definitions=""String_Node_Str"" + Constants.VERSION;
    String map=null;
    List<String> igs=new ArrayList<String>();
    List<String> questionnaires=new ArrayList<String>();
    String txServer=""String_Node_Str"";
    boolean doNative=false;
    List<String> profiles=new ArrayList<String>();
    EngineMode mode=EngineMode.VALIDATION;
    String output=null;
    List<String> sources=new ArrayList<String>();
    Map<String,String> locations=new HashMap<String,String>();
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       definitions=args[++i];
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       output=args[++i];
 else       if (args[i].equals(""String_Node_Str"")) {
        String p=null;
        if (i + 1 == args.length)         throw new Error(""String_Node_Str"");
 else {
          p=args[++i];
          profiles.add(p);
        }
        if (p != null && i + 1 < args.length && args[i + 1].equals(""String_Node_Str"")) {
          i++;
          if (i + 1 == args.length)           throw new Error(""String_Node_Str"");
 else           locations.put(p,args[++i]);
        }
      }
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       questionnaires.add(args[++i]);
 else       if (args[i].equals(""String_Node_Str""))       doNative=true;
 else       if (args[i].equals(""String_Node_Str"")) {
        map=args[++i];
        mode=EngineMode.TRANSFORM;
      }
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.NARRATIVE;
 else       if (args[i].equals(""String_Node_Str""))       mode=EngineMode.SNAPSHOT;
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       txServer=""String_Node_Str"".equals(args[++i]) ? null : args[i];
 else       if (args[i].equals(""String_Node_Str""))       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else {
        String s=args[++i];
        if (s.startsWith(""String_Node_Str""))         definitions=s;
 else         igs.add(s);
      }
 else       if (args[i].equals(""String_Node_Str""))       if (map == null)       if (i + 1 == args.length)       throw new Error(""String_Node_Str"");
 else       map=args[++i];
 else       throw new Exception(""String_Node_Str"");
 else       if (args[i].startsWith(""String_Node_Str""))       i++;
 else       sources.add(args[i]);
    }
    if (sources.isEmpty())     throw new Exception(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + definitions);
    System.out.println(""String_Node_Str"" + txServer);
    ValidationEngine validator=new ValidationEngine(definitions,txServer);
    System.out.println(""String_Node_Str"" + validator.getContext().getVersion() + ""String_Node_Str"");
    for (    String src : igs) {
      System.out.println(""String_Node_Str"" + src);
      validator.loadIg(src);
    }
    validator.setQuestionnaires(questionnaires);
    validator.setNative(doNative);
    XmlParser x=new XmlParser();
    if (mode == EngineMode.TRANSFORM) {
      if (sources.size() > 1)       throw new Exception(""String_Node_Str"" + sources + ""String_Node_Str"");
      if (txServer == null)       throw new Exception(""String_Node_Str"");
      if (map == null)       throw new Exception(""String_Node_Str"");
      try {
        Resource r=validator.transform(sources.get(0),map);
        System.out.println(""String_Node_Str"");
        if (output != null) {
          FileOutputStream s=new FileOutputStream(output);
          x.setOutputStyle(OutputStyle.PRETTY);
          x.compose(s,r,true);
          s.close();
        }
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
      }
    }
 else     if (mode == EngineMode.NARRATIVE) {
      DomainResource r=validator.generate(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else     if (mode == EngineMode.SNAPSHOT) {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      StructureDefinition r=validator.snapshot(sources.get(0));
      System.out.println(""String_Node_Str"");
      if (output != null) {
        handleOutput(r,output);
      }
    }
 else {
      if (definitions == null)       throw new Exception(""String_Node_Str"");
      for (      String s : profiles) {
        if (validator.getContext().fetchResource(StructureDefinition.class,s) == null) {
          System.out.println(""String_Node_Str"" + s);
          validator.loadProfile(locations.getOrDefault(s,s));
        }
      }
      System.out.println(""String_Node_Str"" + sources);
      Resource r=validator.validate(sources,profiles);
      if (output == null) {
        if (r instanceof Bundle)         for (        BundleEntryComponent e : ((Bundle)r).getEntry())         displayOO((OperationOutcome)e.getResource());
 else         displayOO((OperationOutcome)r);
      }
 else {
        FileOutputStream s=new FileOutputStream(output);
        x.compose(s,r,true);
        s.close();
      }
    }
  }
}",0.9904805077062556
22975,"@Override public boolean compile(String rootDir,List<String> errors,Logger logger,List<ValidationMessage> issues) throws Exception {
  logger.log(""String_Node_Str"",LogMessageType.Process);
  Manifest manifest=new Manifest();
  manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS,""String_Node_Str"");
  JarOutputStream jar=new JarOutputStream(new FileOutputStream(Utilities.path(folders.dstDir,""String_Node_Str"")),manifest);
  List<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  String importsDir=Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  jar.close();
  manifest=new Manifest();
  manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS,""String_Node_Str"");
  logger.log(""String_Node_Str"",LogMessageType.Process);
  ImplementationGuide ig=new ImplementationGuide();
  ig.setUrl(""String_Node_Str"");
  ig.setVersion(svnRevision);
  ig.setName(""String_Node_Str"");
  ig.setTitle(""String_Node_Str"");
  ig.setStatus(PublicationStatus.ACTIVE);
  ig.setLicense(SPDXLicense.CC01_0);
  ig.setPackageId(""String_Node_Str"");
  ig.setPublisher(""String_Node_Str"");
  ig.setFhirVersion(Constants.VERSION);
  NPMPackageGenerator npm=new NPMPackageGenerator(Utilities.path(folders.dstDir,""String_Node_Str""),ig.getUrl(),PackageType.TOOL,ig);
  npm.addFile(Category.TOOL,""String_Node_Str"",TextFile.fileToBytes(Utilities.path(folders.dstDir,""String_Node_Str"")));
  npm.finish();
  return true;
}","@Override public boolean compile(String rootDir,List<String> errors,Logger logger,List<ValidationMessage> issues) throws Exception {
  logger.log(""String_Node_Str"",LogMessageType.Process);
  Manifest manifest=new Manifest();
  manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS,""String_Node_Str"");
  JarOutputStream jar=new JarOutputStream(new FileOutputStream(Utilities.path(folders.dstDir,""String_Node_Str"")),manifest);
  List<String> names=new ArrayList<String>();
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  String importsDir=Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddJarToJar(jar,Utilities.path(importsDir,""String_Node_Str""),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  AddToJar(jar,new File(Utilities.path(rootDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Utilities.path(rootDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").length(),names);
  jar.close();
  manifest=new Manifest();
  manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS,""String_Node_Str"");
  logger.log(""String_Node_Str"",LogMessageType.Process);
  ImplementationGuide ig=new ImplementationGuide();
  ig.setUrl(""String_Node_Str"");
  ig.setVersion(svnRevision);
  ig.setName(""String_Node_Str"");
  ig.setTitle(""String_Node_Str"");
  ig.setStatus(PublicationStatus.ACTIVE);
  ig.setLicense(SPDXLicense.CC01_0);
  ig.setPackageId(""String_Node_Str"");
  ig.setPublisher(""String_Node_Str"");
  ig.setFhirVersion(Constants.VERSION);
  NPMPackageGenerator npm=new NPMPackageGenerator(Utilities.path(folders.dstDir,""String_Node_Str""),ig.getUrl(),PackageType.TOOL,ig);
  npm.addFile(Category.TOOL,""String_Node_Str"",TextFile.fileToBytes(Utilities.path(folders.dstDir,""String_Node_Str"")));
  npm.finish();
  return true;
}",0.9920856091851522
22976,"private List<Base> opIs(List<Base> left,List<Base> right){
  List<Base> result=new ArrayList<Base>();
  if (left.size() != 1 || right.size() != 1)   result.add(new BooleanType(false).noExtensions());
 else {
    String tn=convertToString(right);
    if (!(left.get(0) instanceof Element) || ((Element)left.get(0)).isDisallowExtensions())     result.add(new BooleanType(Utilities.capitalize(left.get(0).fhirType()).equals(tn)).noExtensions());
 else     result.add(new BooleanType(left.get(0).hasType(tn)).noExtensions());
  }
  return result;
}","private List<Base> opIs(List<Base> left,List<Base> right){
  List<Base> result=new ArrayList<Base>();
  if (left.size() != 1 || right.size() != 1)   result.add(new BooleanType(false).noExtensions());
 else {
    String tn=convertToString(right);
    if (left.get(0) instanceof org.hl7.fhir.r4.elementmodel.Element)     result.add(new BooleanType(left.get(0).hasType(tn)).noExtensions());
 else     if ((left.get(0) instanceof Element) || ((Element)left.get(0)).isDisallowExtensions())     result.add(new BooleanType(Utilities.capitalize(left.get(0).fhirType()).equals(tn)).noExtensions());
 else     result.add(new BooleanType(left.get(0).hasType(tn)).noExtensions());
  }
  return result;
}",0.8793522267206477
22977,"/** 
 * given an element definition in a profile, what element contains the differentiating fixed  for the element, given the differentiating expresssion. The expression is only allowed to  use a subset of FHIRPath
 * @param profile
 * @param element
 * @return
 * @throws PathEngineException 
 * @throws DefinitionException 
 */
public ElementDefinition evaluateDefinition(ExpressionNode expr,StructureDefinition profile,ElementDefinition element) throws DefinitionException {
  StructureDefinition sd=profile;
  ElementDefinition focus=null;
  if (expr.getKind() == Kind.Name) {
    List<ElementDefinition> childDefinitions;
    childDefinitions=ProfileUtilities.getChildMap(sd,element);
    if (childDefinitions.isEmpty()) {
      sd=fetchStructureByType(element);
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      childDefinitions=ProfileUtilities.getChildMap(sd,sd.getSnapshot().getElementFirstRep());
    }
    for (    ElementDefinition t : childDefinitions) {
      if (tailMatches(t,expr.getName())) {
        focus=t;
        break;
      }
    }
  }
 else   if (expr.getKind() == Kind.Function) {
    if (""String_Node_Str"".equals(expr.getName())) {
      if (!element.hasType())       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (element.getType().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (!element.getType().get(0).hasTarget())       throw new DefinitionException(""String_Node_Str"" + element.getId() + ""String_Node_Str""+ element.getType().get(0).getCode()+ ""String_Node_Str"");
      if (element.getType().get(0).getTargetProfile().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      sd=worker.fetchResource(StructureDefinition.class,element.getType().get(0).getTargetProfile().get(0).getValue());
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getTargetProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      focus=sd.getSnapshot().getElementFirstRep();
    }
 else     if (""String_Node_Str"".equals(expr.getName())) {
      String targetUrl=expr.getParameters().get(0).getConstant().primitiveValue();
      targetUrl=targetUrl.substring(1,targetUrl.length() - 1);
      List<ElementDefinition> childDefinitions=ProfileUtilities.getChildMap(sd,element);
      for (      ElementDefinition t : childDefinitions) {
        if (t.getPath().endsWith(""String_Node_Str"") && t.hasSliceName()) {
          sd=worker.fetchResource(StructureDefinition.class,t.getType().get(0).getProfile().get(0).getValue());
          while (sd != null && !sd.getBaseDefinition().equals(""String_Node_Str""))           sd=worker.fetchResource(StructureDefinition.class,sd.getBaseDefinition());
          if (sd.getUrl().equals(targetUrl)) {
            focus=t;
            break;
          }
        }
      }
    }
 else     throw new DefinitionException(""String_Node_Str"" + expr.getName() + ""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Group) {
    throw new DefinitionException(""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Constant) {
    throw new DefinitionException(""String_Node_Str"");
  }
  if (focus == null)   throw new DefinitionException(""String_Node_Str"");
 else   if (expr.getInner() == null)   return focus;
 else   return evaluateDefinition(expr.getInner(),sd,focus);
}","/** 
 * given an element definition in a profile, what element contains the differentiating fixed  for the element, given the differentiating expresssion. The expression is only allowed to  use a subset of FHIRPath
 * @param profile
 * @param element
 * @return
 * @throws PathEngineException 
 * @throws DefinitionException 
 */
public ElementDefinition evaluateDefinition(ExpressionNode expr,StructureDefinition profile,ElementDefinition element) throws DefinitionException {
  StructureDefinition sd=profile;
  ElementDefinition focus=null;
  if (expr.getKind() == Kind.Name) {
    List<ElementDefinition> childDefinitions;
    childDefinitions=ProfileUtilities.getChildMap(sd,element);
    if (childDefinitions.isEmpty()) {
      sd=fetchStructureByType(element);
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      childDefinitions=ProfileUtilities.getChildMap(sd,sd.getSnapshot().getElementFirstRep());
    }
    for (    ElementDefinition t : childDefinitions) {
      if (tailMatches(t,expr.getName())) {
        focus=t;
        break;
      }
    }
  }
 else   if (expr.getKind() == Kind.Function) {
    if (""String_Node_Str"".equals(expr.getName())) {
      if (!element.hasType())       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (element.getType().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (!element.getType().get(0).hasTarget())       throw new DefinitionException(""String_Node_Str"" + element.getId() + ""String_Node_Str""+ element.getType().get(0).getCode()+ ""String_Node_Str"");
      if (element.getType().get(0).getTargetProfile().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      sd=worker.fetchResource(StructureDefinition.class,element.getType().get(0).getTargetProfile().get(0).getValue());
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getTargetProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      focus=sd.getSnapshot().getElementFirstRep();
    }
 else     if (""String_Node_Str"".equals(expr.getName())) {
      String targetUrl=expr.getParameters().get(0).getConstant().primitiveValue();
      List<ElementDefinition> childDefinitions=ProfileUtilities.getChildMap(sd,element);
      for (      ElementDefinition t : childDefinitions) {
        if (t.getPath().endsWith(""String_Node_Str"") && t.hasSliceName()) {
          sd=worker.fetchResource(StructureDefinition.class,t.getType().get(0).getProfile().get(0).getValue());
          while (sd != null && !sd.getBaseDefinition().equals(""String_Node_Str""))           sd=worker.fetchResource(StructureDefinition.class,sd.getBaseDefinition());
          if (sd.getUrl().equals(targetUrl)) {
            focus=t;
            break;
          }
        }
      }
    }
 else     throw new DefinitionException(""String_Node_Str"" + expr.getName() + ""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Group) {
    throw new DefinitionException(""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Constant) {
    throw new DefinitionException(""String_Node_Str"");
  }
  if (focus == null)   throw new DefinitionException(""String_Node_Str"");
 else   if (expr.getInner() == null)   return focus;
 else   return evaluateDefinition(expr.getInner(),sd,focus);
}",0.990990990990991
22978,"public void loadIg(String src) throws IOException, FHIRException, Exception {
  String canonical=null;
  Map<String,byte[]> source=loadIgSource(src,""String_Node_Str"");
  String version=Constants.VERSION;
  if (source.containsKey(""String_Node_Str""))   version=readInfoVersion(source.get(""String_Node_Str""));
  for (  Entry<String,byte[]> t : source.entrySet()) {
    String fn=t.getKey();
    Resource r=null;
    try {
      if (version.equals(""String_Node_Str"") || version.equals(""String_Node_Str"")) {
        org.hl7.fhir.dstu3.model.Resource res;
        if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         res=new org.hl7.fhir.dstu3.formats.XmlParser().parse(new ByteArrayInputStream(t.getValue()));
 else         if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         res=new org.hl7.fhir.dstu3.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else         throw new Exception(""String_Node_Str"" + fn);
        r=VersionConvertor_30_40.convertResource(res);
      }
 else       if (version.equals(""String_Node_Str"")) {
        org.hl7.fhir.dstu2016may.model.Resource res;
        if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         res=new org.hl7.fhir.dstu2016may.formats.XmlParser().parse(new ByteArrayInputStream(t.getValue()));
 else         if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         res=new org.hl7.fhir.dstu2016may.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else         throw new Exception(""String_Node_Str"" + fn);
        r=VersionConvertor_14_40.convertResource(res);
      }
 else       if (version.equals(""String_Node_Str"")) {
        org.hl7.fhir.dstu2.model.Resource res;
        if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         res=new org.hl7.fhir.dstu2.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else         if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         res=new org.hl7.fhir.dstu2.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else         throw new Exception(""String_Node_Str"" + fn);
        VersionConvertorAdvisor40 advisor=new org.hl7.fhir.convertors.IGR2ConvertorAdvisor();
        r=new VersionConvertor_10_40(advisor).convertResource(res);
      }
 else       if (version.equals(Constants.VERSION)) {
        if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         r=new XmlParser().parse(new ByteArrayInputStream(t.getValue()));
 else         if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))         r=new JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else         if (fn.endsWith(""String_Node_Str""))         r=new StructureMapUtilities(context,null,null).parse(TextFile.bytesToString(t.getValue()));
 else         throw new Exception(""String_Node_Str"" + fn);
      }
 else       throw new Exception(""String_Node_Str"" + version);
    }
 catch (    Exception e) {
      throw new Exception(""String_Node_Str"" + fn + ""String_Node_Str""+ e.getMessage(),e);
    }
    if (r != null) {
      context.cacheResource(r);
      if (r instanceof ImplementationGuide)       canonical=((ImplementationGuide)r).getUrl();
    }
  }
  if (canonical != null)   grabNatives(source,canonical);
}","public void loadIg(String src) throws IOException, FHIRException, Exception {
  String canonical=null;
  Map<String,byte[]> source=loadIgSource(src,""String_Node_Str"");
  String version=Constants.VERSION;
  if (source.containsKey(""String_Node_Str""))   version=readInfoVersion(source.get(""String_Node_Str""));
  for (  Entry<String,byte[]> t : source.entrySet()) {
    String fn=t.getKey();
    if (!exemptFile(fn)) {
      Resource r=null;
      try {
        if (version.equals(""String_Node_Str"") || version.equals(""String_Node_Str"")) {
          org.hl7.fhir.dstu3.model.Resource res;
          if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           res=new org.hl7.fhir.dstu3.formats.XmlParser().parse(new ByteArrayInputStream(t.getValue()));
 else           if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           res=new org.hl7.fhir.dstu3.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else           throw new Exception(""String_Node_Str"" + fn);
          r=VersionConvertor_30_40.convertResource(res);
        }
 else         if (version.equals(""String_Node_Str"")) {
          org.hl7.fhir.dstu2016may.model.Resource res;
          if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           res=new org.hl7.fhir.dstu2016may.formats.XmlParser().parse(new ByteArrayInputStream(t.getValue()));
 else           if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           res=new org.hl7.fhir.dstu2016may.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else           throw new Exception(""String_Node_Str"" + fn);
          r=VersionConvertor_14_40.convertResource(res);
        }
 else         if (version.equals(""String_Node_Str"")) {
          org.hl7.fhir.dstu2.model.Resource res;
          if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           res=new org.hl7.fhir.dstu2.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else           if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           res=new org.hl7.fhir.dstu2.formats.JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else           throw new Exception(""String_Node_Str"" + fn);
          VersionConvertorAdvisor40 advisor=new org.hl7.fhir.convertors.IGR2ConvertorAdvisor();
          r=new VersionConvertor_10_40(advisor).convertResource(res);
        }
 else         if (version.equals(Constants.VERSION)) {
          if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           r=new XmlParser().parse(new ByteArrayInputStream(t.getValue()));
 else           if (fn.endsWith(""String_Node_Str"") && !fn.endsWith(""String_Node_Str""))           r=new JsonParser().parse(new ByteArrayInputStream(t.getValue()));
 else           if (fn.endsWith(""String_Node_Str""))           r=new StructureMapUtilities(context,null,null).parse(TextFile.bytesToString(t.getValue()));
 else           throw new Exception(""String_Node_Str"" + fn);
        }
 else         throw new Exception(""String_Node_Str"" + version);
      }
 catch (      Exception e) {
        throw new Exception(""String_Node_Str"" + fn + ""String_Node_Str""+ e.getMessage(),e);
      }
      if (r != null) {
        context.cacheResource(r);
        if (r instanceof ImplementationGuide)         canonical=((ImplementationGuide)r).getUrl();
      }
    }
  }
  if (canonical != null)   grabNatives(source,canonical);
}",0.9807494489346068
22979,"public static void convertTypeRefComponent(org.hl7.fhir.r4.model.ElementDefinition.TypeRefComponent src,List<org.hl7.fhir.dstu2016may.model.ElementDefinition.TypeRefComponent> list) throws FHIRException {
  if (src == null)   return;
  org.hl7.fhir.dstu2016may.model.ElementDefinition.TypeRefComponent tgt=new org.hl7.fhir.dstu2016may.model.ElementDefinition.TypeRefComponent();
  copyElement(src,tgt);
  tgt.setCode(src.getCode());
  list.add(tgt);
  if (src.hasTarget()) {
    for (    org.hl7.fhir.r4.model.UriType u : src.getTargetProfile()) {
      tgt.addProfile(u.getValue());
    }
  }
 else {
    for (    org.hl7.fhir.r4.model.UriType u : src.getProfile()) {
      tgt.addProfile(u.getValue());
    }
  }
}","public static void convertTypeRefComponent(org.hl7.fhir.r4.model.ElementDefinition.TypeRefComponent src,List<org.hl7.fhir.dstu2016may.model.ElementDefinition.TypeRefComponent> list) throws FHIRException {
  if (src == null)   return;
  org.hl7.fhir.dstu2016may.model.ElementDefinition.TypeRefComponent tgt=new org.hl7.fhir.dstu2016may.model.ElementDefinition.TypeRefComponent();
  copyElement(src,tgt);
  tgt.setCode(src.getCode());
  list.add(tgt);
  if (src.hasTarget()) {
    for (    org.hl7.fhir.r4.model.UriType u : src.getTargetProfile()) {
      tgt.addProfile(u.getValue());
    }
  }
 else {
    for (    org.hl7.fhir.r4.model.UriType u : src.getProfile()) {
      tgt.addProfile(u.getValue());
    }
  }
  for (  org.hl7.fhir.r4.model.Enumeration<org.hl7.fhir.r4.model.ElementDefinition.AggregationMode> t : src.getAggregation()) {
    org.hl7.fhir.dstu2016may.model.ElementDefinition.AggregationMode a=convertAggregationMode(t.getValue());
    if (!tgt.hasAggregation(a))     tgt.addAggregation(a);
  }
  if (src.hasVersioning())   tgt.setVersioning(convertReferenceVersionRules(src.getVersioning()));
}",0.7820862916439104
22980,"@Override public ValueSetExpansionOutcome expand(ValueSet source,ExpansionProfile profile){
  if (profile == null)   profile=makeDefaultExpansion();
  try {
    source.checkNoModifiers(""String_Node_Str"",""String_Node_Str"");
    focus=source.copy();
    focus.setExpansion(new ValueSet.ValueSetExpansionComponent());
    focus.getExpansion().setTimestampElement(DateTimeType.now());
    focus.getExpansion().setIdentifier(Factory.createUUID());
    if (!profile.getUrl().startsWith(""String_Node_Str""))     focus.getExpansion().addParameter().setName(""String_Node_Str"").setValue(new UriType(profile.getUrl()));
    if (source.hasCompose())     handleCompose(source.getCompose(),focus.getExpansion().getParameter(),profile);
    if (canBeHeirarchy) {
      for (      ValueSetExpansionContainsComponent c : roots) {
        focus.getExpansion().getContains().add(c);
      }
    }
 else {
      for (      ValueSetExpansionContainsComponent c : codes) {
        if (map.containsKey(key(c)) && !c.getAbstract()) {
          focus.getExpansion().getContains().add(c);
          c.getContains().clear();
        }
      }
    }
    if (total > 0) {
      focus.getExpansion().setTotal(total);
    }
    return new ValueSetExpansionOutcome(focus);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  NoTerminologyServiceException e) {
    return new ValueSetExpansionOutcome(new ValueSetCheckerSimple(source,factory,context),e.getMessage(),TerminologyServiceErrorClass.NOSERVICE);
  }
catch (  Exception e) {
    return new ValueSetExpansionOutcome(new ValueSetCheckerSimple(source,factory,context),e.getMessage(),TerminologyServiceErrorClass.UNKNOWN);
  }
}","@Override public ValueSetExpansionOutcome expand(ValueSet source,ExpansionProfile profile){
  if (profile == null)   profile=makeDefaultExpansion();
  try {
    source.checkNoModifiers(""String_Node_Str"",""String_Node_Str"");
    focus=source.copy();
    focus.setExpansion(new ValueSet.ValueSetExpansionComponent());
    focus.getExpansion().setTimestampElement(DateTimeType.now());
    focus.getExpansion().setIdentifier(Factory.createUUID());
    if (!profile.getUrl().startsWith(""String_Node_Str""))     focus.getExpansion().addParameter().setName(""String_Node_Str"").setValue(new UriType(profile.getUrl()));
    if (source.hasCompose())     handleCompose(source.getCompose(),focus.getExpansion().getParameter(),profile,source.getUrl());
    if (canBeHeirarchy) {
      for (      ValueSetExpansionContainsComponent c : roots) {
        focus.getExpansion().getContains().add(c);
      }
    }
 else {
      for (      ValueSetExpansionContainsComponent c : codes) {
        if (map.containsKey(key(c)) && !c.getAbstract()) {
          focus.getExpansion().getContains().add(c);
          c.getContains().clear();
        }
      }
    }
    if (total > 0) {
      focus.getExpansion().setTotal(total);
    }
    return new ValueSetExpansionOutcome(focus);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  NoTerminologyServiceException e) {
    return new ValueSetExpansionOutcome(new ValueSetCheckerSimple(source,factory,context),e.getMessage(),TerminologyServiceErrorClass.NOSERVICE);
  }
catch (  Exception e) {
    return new ValueSetExpansionOutcome(new ValueSetCheckerSimple(source,factory,context),e.getMessage(),TerminologyServiceErrorClass.UNKNOWN);
  }
}",0.9952038369304556
22981,"private void handleCompose(ValueSetComposeComponent compose,List<ValueSetExpansionParameterComponent> params,ExpansionProfile profile) throws ETooCostly, FileNotFoundException, IOException, FHIRException {
  compose.checkNoModifiers(""String_Node_Str"",""String_Node_Str"");
  for (  ConceptSetComponent inc : compose.getExclude())   excludeCodes(inc,params);
  canBeHeirarchy=!profile.getExcludeNested() && excludeKeys.isEmpty() && excludeSystems.isEmpty();
  boolean first=true;
  for (  ConceptSetComponent inc : compose.getInclude()) {
    if (first == true)     first=false;
 else     canBeHeirarchy=false;
    includeCodes(inc,params,profile);
  }
}","private void handleCompose(ValueSetComposeComponent compose,List<ValueSetExpansionParameterComponent> params,ExpansionProfile profile,String ctxt) throws ETooCostly, FileNotFoundException, IOException, FHIRException {
  compose.checkNoModifiers(""String_Node_Str"",""String_Node_Str"");
  for (  ConceptSetComponent inc : compose.getExclude())   excludeCodes(inc,params,ctxt);
  canBeHeirarchy=!profile.getExcludeNested() && excludeKeys.isEmpty() && excludeSystems.isEmpty();
  boolean first=true;
  for (  ConceptSetComponent inc : compose.getInclude()) {
    if (first == true)     first=false;
 else     canBeHeirarchy=false;
    includeCodes(inc,params,profile);
  }
}",0.9871114480667172
22982,"private Map<String,String> makeVars(FetchedResource r){
  Map<String,String> map=new HashMap<String,String>();
  if (r.getResource() != null) {
switch (r.getResource().getResourceType()) {
case StructureDefinition:
      StructureDefinition sd=(StructureDefinition)r.getResource();
    String url=sd.getBaseDefinition();
  StructureDefinition base=context.fetchResource(StructureDefinition.class,url);
if (base != null) {
  map.put(""String_Node_Str"",base.getName());
  map.put(""String_Node_Str"",base.getUserString(""String_Node_Str""));
}
 else {
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
}
map.put(""String_Node_Str"",sd.getType());
map.put(""String_Node_Str"",Utilities.pluralize(sd.getType(),2));
map.put(""String_Node_Str"",sd.getType().toLowerCase());
map.put(""String_Node_Str"",Utilities.pluralize(sd.getType(),2).toLowerCase());
return map;
default :
return null;
}
}
 else return null;
}","private Map<String,String> makeVars(FetchedResource r){
  Map<String,String> map=new HashMap<String,String>();
  if (r.getResource() != null) {
switch (r.getResource().getResourceType()) {
case StructureDefinition:
      StructureDefinition sd=(StructureDefinition)r.getResource();
    String url=sd.getBaseDefinition();
  StructureDefinition base=context.fetchResource(StructureDefinition.class,url);
if (base != null) {
  map.put(""String_Node_Str"",base.getName());
  map.put(""String_Node_Str"",base.getUserString(""String_Node_Str""));
}
 else {
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
}
map.put(""String_Node_Str"",sd.getType());
map.put(""String_Node_Str"",Utilities.pluralize(sd.getType(),2));
map.put(""String_Node_Str"",!sd.hasType() ? ""String_Node_Str"" : sd.getType().toLowerCase());
map.put(""String_Node_Str"",!sd.hasType() ? ""String_Node_Str"" : Utilities.pluralize(sd.getType(),2).toLowerCase());
return map;
default :
return null;
}
}
 else return null;
}",0.8924180327868853
22983,"private List<Base> opIs(List<Base> left,List<Base> right){
  List<Base> result=new ArrayList<Base>();
  if (left.size() != 1 || right.size() != 1)   result.add(new BooleanType(false).noExtensions());
 else {
    String tn=convertToString(right);
    result.add(new BooleanType(left.get(0).hasType(tn)).noExtensions());
  }
  return result;
}","private List<Base> opIs(List<Base> left,List<Base> right){
  List<Base> result=new ArrayList<Base>();
  if (left.size() != 1 || right.size() != 1)   result.add(new BooleanType(false).noExtensions());
 else {
    String tn=convertToString(right);
    if (!(left.get(0) instanceof Element) || ((Element)left.get(0)).isDisallowExtensions())     result.add(new BooleanType(Utilities.capitalize(left.get(0).fhirType()).equals(tn)).noExtensions());
 else     result.add(new BooleanType(left.get(0).hasType(tn)).noExtensions());
  }
  return result;
}",0.7661016949152543
22984,"public void dump() throws IOException {
  for (int i=0; i < 34; i++) {
    sheet.autoSizeColumn(i);
  }
  sheet.setColumnHidden(2,true);
  sheet.setColumnHidden(3,true);
  sheet.setColumnHidden(30,true);
  sheet.setColumnHidden(31,true);
  sheet.setColumnHidden(32,true);
  sheet.setColumnWidth(9,columnPixels(20));
  sheet.setColumnWidth(11,columnPixels(100));
  sheet.setColumnWidth(12,columnPixels(100));
  sheet.setColumnWidth(13,columnPixels(100));
  sheet.setColumnWidth(15,columnPixels(20));
  sheet.setColumnWidth(16,columnPixels(20));
  sheet.setColumnWidth(17,columnPixels(20));
  sheet.setColumnWidth(18,columnPixels(20));
  sheet.setColumnWidth(34,columnPixels(100));
  int i=titles.length - 1;
  for (  StructureDefinitionMappingComponent map : def.getMapping()) {
    i++;
    sheet.setColumnWidth(i,columnPixels(50));
    sheet.autoSizeColumn(i);
  }
  sheet.createFreezePane(2,1);
  SheetConditionalFormatting sheetCF=sheet.getSheetConditionalFormatting();
  String address=""String_Node_Str"" + Integer.valueOf(sheet.getLastRowNum());
  CellRangeAddress[] regions={CellRangeAddress.valueOf(address)};
  ConditionalFormattingRule rule1=sheetCF.createConditionalFormattingRule(""String_Node_Str"");
  PatternFormatting fill1=rule1.createPatternFormatting();
  fill1.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);
  fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);
  ConditionalFormattingRule rule2=sheetCF.createConditionalFormattingRule(""String_Node_Str"");
  FontFormatting font=rule2.createFontFormatting();
  font.setFontColorIndex(IndexedColors.GREY_25_PERCENT.index);
  font.setFontStyle(true,false);
  sheetCF.addConditionalFormatting(regions,rule1,rule2);
  sheet.setAutoFilter(new CellRangeAddress(0,sheet.getLastRowNum(),0,titles.length + def.getMapping().size() - 1));
  XSSFSheet xSheet=(XSSFSheet)sheet;
  CTAutoFilter sheetFilter=xSheet.getCTWorksheet().getAutoFilter();
  CTFilterColumn filterColumn1=sheetFilter.addNewFilterColumn();
  filterColumn1.setColId(6);
  CTCustomFilters filters=filterColumn1.addNewCustomFilters();
  CTCustomFilter filter1=filters.addNewCustomFilter();
  filter1.setOperator(STFilterOperator.NOT_EQUAL);
  filter1.setVal(""String_Node_Str"");
  CTFilterColumn filterColumn2=sheetFilter.addNewFilterColumn();
  filterColumn2.setColId(26);
  CTFilters filters2=filterColumn2.addNewFilters();
  filters2.setBlank(true);
  for (  Row row : sheet) {
    if (row.getRowNum() > 0 && (!row.getCell(6).getStringCellValue().equals(""String_Node_Str"") || !row.getCell(26).getStringCellValue().isEmpty())) {
      ((XSSFRow)row).getCTRow().setHidden(true);
    }
  }
  sheet.setActiveCell(new CellAddress(sheet.getRow(1).getCell(0)));
  wb.write(outStream);
  flush();
  close();
}","public void dump() throws IOException {
  for (int i=0; i < 34; i++) {
    sheet.autoSizeColumn(i);
  }
  sheet.setColumnHidden(2,true);
  sheet.setColumnHidden(3,true);
  sheet.setColumnHidden(30,true);
  sheet.setColumnHidden(31,true);
  sheet.setColumnHidden(32,true);
  sheet.setColumnWidth(9,columnPixels(20));
  sheet.setColumnWidth(11,columnPixels(100));
  sheet.setColumnWidth(12,columnPixels(100));
  sheet.setColumnWidth(13,columnPixels(100));
  sheet.setColumnWidth(15,columnPixels(20));
  sheet.setColumnWidth(16,columnPixels(20));
  sheet.setColumnWidth(17,columnPixels(20));
  sheet.setColumnWidth(18,columnPixels(20));
  sheet.setColumnWidth(34,columnPixels(100));
  int i=titles.length - 1;
  for (  StructureDefinitionMappingComponent map : def.getMapping()) {
    i++;
    sheet.setColumnWidth(i,columnPixels(50));
    sheet.autoSizeColumn(i);
  }
  sheet.createFreezePane(2,1);
  SheetConditionalFormatting sheetCF=sheet.getSheetConditionalFormatting();
  String address=""String_Node_Str"" + Math.max(Integer.valueOf(sheet.getLastRowNum()),2);
  CellRangeAddress[] regions={CellRangeAddress.valueOf(address)};
  ConditionalFormattingRule rule1=sheetCF.createConditionalFormattingRule(""String_Node_Str"");
  PatternFormatting fill1=rule1.createPatternFormatting();
  fill1.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.index);
  fill1.setFillPattern(PatternFormatting.SOLID_FOREGROUND);
  ConditionalFormattingRule rule2=sheetCF.createConditionalFormattingRule(""String_Node_Str"");
  FontFormatting font=rule2.createFontFormatting();
  font.setFontColorIndex(IndexedColors.GREY_25_PERCENT.index);
  font.setFontStyle(true,false);
  sheetCF.addConditionalFormatting(regions,rule1,rule2);
  sheet.setAutoFilter(new CellRangeAddress(0,sheet.getLastRowNum(),0,titles.length + def.getMapping().size() - 1));
  XSSFSheet xSheet=(XSSFSheet)sheet;
  CTAutoFilter sheetFilter=xSheet.getCTWorksheet().getAutoFilter();
  CTFilterColumn filterColumn1=sheetFilter.addNewFilterColumn();
  filterColumn1.setColId(6);
  CTCustomFilters filters=filterColumn1.addNewCustomFilters();
  CTCustomFilter filter1=filters.addNewCustomFilter();
  filter1.setOperator(STFilterOperator.NOT_EQUAL);
  filter1.setVal(""String_Node_Str"");
  CTFilterColumn filterColumn2=sheetFilter.addNewFilterColumn();
  filterColumn2.setColId(26);
  CTFilters filters2=filterColumn2.addNewFilters();
  filters2.setBlank(true);
  for (  Row row : sheet) {
    if (row.getRowNum() > 0 && (!row.getCell(6).getStringCellValue().equals(""String_Node_Str"") || !row.getCell(26).getStringCellValue().isEmpty())) {
      ((XSSFRow)row).getCTRow().setHidden(true);
    }
  }
  sheet.setActiveCell(new CellAddress(sheet.getRow(1).getCell(0)));
  wb.write(outStream);
  flush();
  close();
}",0.9978173881411422
22985,"public static boolean isAbsoluteUrl(String ref){
  return ref != null && ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"");
}","public static boolean isAbsoluteUrl(String ref){
  return ref != null && (ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"") || ref.startsWith(""String_Node_Str"")|| ref.startsWith(""String_Node_Str""));
}",0.3492063492063492
22986,"public String process(String source,String context){
switch (dialect) {
case COMMON_MARK:
    return processCommonMark(source);
default :
  throw new Error(""String_Node_Str"" + dialect.toString() + ""String_Node_Str""+ context);
}
}","public String process(String source,String context){
switch (dialect) {
case DARING_FIREBALL:
    return Processor.process(source);
case COMMON_MARK:
  return processCommonMark(source);
default :
throw new Error(""String_Node_Str"" + dialect.toString() + ""String_Node_Str""+ context);
}
}",0.8754863813229572
22987,"private boolean laterDelimitedVersion(String newVersion,String oldVersion,String delimiter){
  String[] newParts=newVersion.split(delimiter);
  String[] oldParts=oldVersion.split(delimiter);
  for (int i=0; i < newParts.length; i++) {
    if (!newParts[i].equals(oldParts[i]))     return laterVersion(newParts[i],oldParts[i]);
  }
  throw new Error(""String_Node_Str"");
}","private boolean laterDelimitedVersion(String newVersion,String oldVersion,String delimiter){
  String[] newParts=newVersion.split(delimiter);
  String[] oldParts=oldVersion.split(delimiter);
  for (int i=0; i < newParts.length; i++) {
    if (!newParts[i].equals(oldParts[i]))     return laterVersion(newParts[i],oldParts[i]);
  }
  throw new Error(""String_Node_Str"" + delimiter + ""String_Node_Str""+ newParts+ ""String_Node_Str""+ oldParts);
}",0.9124537607891492
22988,"private void processProperty(List<ElementDefinition> list,String dtn,Element prop,String param) throws FHIRFormatError {
  ElementDefinition ed=new ElementDefinition();
  String n=prop.getAttribute(""String_Node_Str"");
  PropStatus p=getPropStatus(dtn,n);
  if (p == PropStatus.IGNORE)   return;
  if (prop.hasAttribute(""String_Node_Str"") && prop.getAttribute(""String_Node_Str"").startsWith(""String_Node_Str""))   return;
  ed.setPath(dtn + ""String_Node_Str"" + n);
  seePath(ed);
  ed.setDefinition(getDefinition(prop));
  ed.setComment(getDesignComments(prop));
  ed.setLabel(XMLUtil.getNamedChildAttribute(prop,""String_Node_Str"",""String_Node_Str""));
  ed.setMin(Integer.parseInt(prop.getAttribute(""String_Node_Str"")));
  ed.setMax(prop.getAttribute(""String_Node_Str""));
  String t=getType(prop);
  if (primitiveTypes.containsKey(t) && p == PropStatus.ATTRIBUTE)   ed.addType().setCode(primitiveTypes.get(t));
 else   if (Utilities.existsInList(t,""String_Node_Str""))   ed.addType().setCode(""String_Node_Str"");
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(param);
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(param);
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(param);
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(""String_Node_Str"");
 else   if (t.equals(""String_Node_Str""))   ed.addType().setCode(""String_Node_Str"");
 else   if (""String_Node_Str"".equals(t)) {
    ed.setMax(""String_Node_Str"");
    ed.addRepresentation(PropertyRepresentation.TYPEATTR);
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addExtension().setUrl(""String_Node_Str"").setValue(new StringType(""String_Node_Str""));
  }
 else   ed.addType().setCode(t);
  if (p == PropStatus.ATTRIBUTE)   ed.addRepresentation(PropertyRepresentation.XMLATTR);
  String vs=getValueSet(dtn,n);
  if (vs != null) {
    ed.setBinding(new ElementDefinitionBindingComponent().setStrength(BindingStrength.REQUIRED).setValueSet(new Reference().setReference(""String_Node_Str"" + vs)));
    v3vs.add(vs);
  }
  list.add(ed);
}","private void processProperty(List<ElementDefinition> list,String dtn,Element prop,String param) throws FHIRFormatError {
  ElementDefinition ed=new ElementDefinition();
  String n=prop.getAttribute(""String_Node_Str"");
  PropStatus p=getPropStatus(dtn,n);
  if (p == PropStatus.IGNORE)   return;
  if (prop.hasAttribute(""String_Node_Str"") && prop.getAttribute(""String_Node_Str"").startsWith(""String_Node_Str""))   return;
  ed.setPath(dtn + ""String_Node_Str"" + n);
  seePath(ed);
  ed.setDefinition(getDefinition(prop));
  ed.setComment(getDesignComments(prop));
  ed.setLabel(XMLUtil.getNamedChildAttribute(prop,""String_Node_Str"",""String_Node_Str""));
  ed.setMin(Integer.parseInt(prop.getAttribute(""String_Node_Str"")));
  ed.setMax(prop.getAttribute(""String_Node_Str""));
  String t=getType(prop);
  if (primitiveTypes.containsKey(t) && p == PropStatus.ATTRIBUTE)   ed.addType().setCode(primitiveTypes.get(t));
 else   if (Utilities.existsInList(t,""String_Node_Str""))   ed.addType().setCode(""String_Node_Str"");
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(""String_Node_Str"" + param);
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(""String_Node_Str"" + param);
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(""String_Node_Str"" + param);
 else   if (t.equals(""String_Node_Str"") && param != null)   ed.addType().setCode(""String_Node_Str"");
 else   if (t.equals(""String_Node_Str""))   ed.addType().setCode(""String_Node_Str"");
 else   if (""String_Node_Str"".equals(t)) {
    ed.setMax(""String_Node_Str"");
    ed.addRepresentation(PropertyRepresentation.TYPEATTR);
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addExtension().setUrl(""String_Node_Str"").setValue(new StringType(""String_Node_Str""));
  }
 else   ed.addType().setCode(""String_Node_Str"" + t);
  if (p == PropStatus.ATTRIBUTE)   ed.addRepresentation(PropertyRepresentation.XMLATTR);
  String vs=getValueSet(dtn,n);
  if (vs != null) {
    ed.setBinding(new ElementDefinitionBindingComponent().setStrength(BindingStrength.REQUIRED).setValueSet(new CanonicalType(""String_Node_Str"" + vs)));
    v3vs.add(vs);
  }
  list.add(ed);
}",0.9752681111840664
22989,"private void processAttribute(List<Element> classes,List<ElementDefinition> diff,List<ElementDefinition> snapshot,Element cclss,String path,Element attr) throws FHIRFormatError {
  String n=attr.getAttribute(""String_Node_Str"");
  ElementDefinition ed=new ElementDefinition();
  ed.setPath(path + ""String_Node_Str"" + n);
  seePath(ed);
  ed.setMin(Integer.parseInt(attr.getAttribute(""String_Node_Str"")));
  ed.setMax(attr.getAttribute(""String_Node_Str""));
  if (!Utilities.noString(attr.getAttribute(""String_Node_Str"")))   ed.addExtension().setUrl(""String_Node_Str"").setValue(new UriType(attr.getAttribute(""String_Node_Str"")));
  String type=getType(attr);
  if (""String_Node_Str"".equals(attr.getAttribute(""String_Node_Str""))) {
    if (primitiveTypes.containsKey(type))     type=primitiveTypes.get(type);
 else     throw new Error(""String_Node_Str"");
    ed.addRepresentation(PropertyRepresentation.XMLATTR);
  }
  if (""String_Node_Str"".equals(type)) {
    ed.setMax(""String_Node_Str"");
    ed.addRepresentation(PropertyRepresentation.TYPEATTR);
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addExtension().setUrl(""String_Node_Str"").setValue(new StringType(""String_Node_Str""));
  }
 else   if (""String_Node_Str"".equals(type)) {
    ed.addRepresentation(PropertyRepresentation.TYPEATTR);
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
  }
 else   ed.addType().setCode(type);
  if (""String_Node_Str"".equals(attr.getAttribute(""String_Node_Str"")))   ed.setMustSupport(true);
  if (attr.hasAttribute(""String_Node_Str""))   ed.setDefaultValue(buildValue(attr.getAttribute(""String_Node_Str""),type,ed.getPath()));
  List<Element> enums=new ArrayList<Element>();
  XMLUtil.getNamedChildren(attr,""String_Node_Str"",enums);
  if (enums.size() == 1)   ed.setFixed(buildValue(enums.get(0).getTextContent(),type,ed.getPath()));
  if (enums.size() > 1) {
  }
 else   if (XMLUtil.getNamedChild(attr,""String_Node_Str"") != null) {
    Element vocab=XMLUtil.getNamedChild(attr,""String_Node_Str"");
    String cs=vocab.getAttribute(""String_Node_Str"");
    String cd=XMLUtil.getNamedChildAttribute(vocab,""String_Node_Str"",""String_Node_Str"");
    ElementDefinitionBindingComponent bd=ed.getBinding();
    bd.setStrength(cs.equals(""String_Node_Str"") ? BindingStrength.REQUIRED : BindingStrength.EXTENSIBLE);
    bd.setValueSet(new Reference(""String_Node_Str"" + cd));
    v3vs.add(cd);
  }
  diff.add(ed);
  snapshot.add(ed);
}","private void processAttribute(List<Element> classes,List<ElementDefinition> diff,List<ElementDefinition> snapshot,Element cclss,String path,Element attr) throws FHIRFormatError {
  String n=attr.getAttribute(""String_Node_Str"");
  ElementDefinition ed=new ElementDefinition();
  ed.setPath(path + ""String_Node_Str"" + n);
  seePath(ed);
  ed.setMin(Integer.parseInt(attr.getAttribute(""String_Node_Str"")));
  ed.setMax(attr.getAttribute(""String_Node_Str""));
  if (!Utilities.noString(attr.getAttribute(""String_Node_Str"")))   ed.addExtension().setUrl(""String_Node_Str"").setValue(new UriType(attr.getAttribute(""String_Node_Str"")));
  String type=getType(attr);
  if (""String_Node_Str"".equals(attr.getAttribute(""String_Node_Str""))) {
    if (primitiveTypes.containsKey(type))     type=primitiveTypes.get(type);
 else     throw new Error(""String_Node_Str"");
    ed.addRepresentation(PropertyRepresentation.XMLATTR);
  }
  if (""String_Node_Str"".equals(type)) {
    ed.setMax(""String_Node_Str"");
    ed.addRepresentation(PropertyRepresentation.TYPEATTR);
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addExtension().setUrl(""String_Node_Str"").setValue(new StringType(""String_Node_Str""));
  }
 else   if (""String_Node_Str"".equals(type)) {
    ed.addRepresentation(PropertyRepresentation.TYPEATTR);
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
    ed.addType().setCode(""String_Node_Str"");
  }
 else   ed.addType().setCode(type);
  if (""String_Node_Str"".equals(attr.getAttribute(""String_Node_Str"")))   ed.setMustSupport(true);
  if (attr.hasAttribute(""String_Node_Str""))   ed.setDefaultValue(buildValue(attr.getAttribute(""String_Node_Str""),type,ed.getPath()));
  List<Element> enums=new ArrayList<Element>();
  XMLUtil.getNamedChildren(attr,""String_Node_Str"",enums);
  if (enums.size() == 1)   ed.setFixed(buildValue(enums.get(0).getTextContent(),type,ed.getPath()));
  if (enums.size() > 1) {
  }
 else   if (XMLUtil.getNamedChild(attr,""String_Node_Str"") != null) {
    Element vocab=XMLUtil.getNamedChild(attr,""String_Node_Str"");
    String cs=vocab.getAttribute(""String_Node_Str"");
    String cd=XMLUtil.getNamedChildAttribute(vocab,""String_Node_Str"",""String_Node_Str"");
    ElementDefinitionBindingComponent bd=ed.getBinding();
    bd.setStrength(cs.equals(""String_Node_Str"") ? BindingStrength.REQUIRED : BindingStrength.EXTENSIBLE);
    bd.setValueSet(new CanonicalType(""String_Node_Str"" + cd));
    v3vs.add(cd);
  }
  diff.add(ed);
  snapshot.add(ed);
}",0.997384481255449
22990,"public void clean2(){
  definitions.getCodeSystems().clear();
  definitions.getValuesets().clear();
  conceptMaps.clear();
  profiles.clear();
  System.gc();
}","public void clean2(){
  if (definitions.getCodeSystems() != null)   definitions.getCodeSystems().clear();
  if (definitions.getValuesets() != null)   definitions.getValuesets().clear();
  System.gc();
}",0.3490304709141274
22991,"public ElementDefinitionHolder(ElementDefinition self){
  super();
  this.self=self;
  this.name=self.getPath();
  children=new ArrayList<ElementDefinitionHolder>();
}","public ElementDefinitionHolder(ElementDefinition self){
  this(self,false);
}",0.5901639344262295
22992,"private void writeElements(ElementDefinitionHolder edh,List<ElementDefinition> list){
  list.add(edh.getSelf());
  for (  ElementDefinitionHolder child : edh.getChildren()) {
    writeElements(child,list);
  }
}","private void writeElements(ElementDefinitionHolder edh,List<ElementDefinition> list){
  if (!edh.isPlaceHolder())   list.add(edh.getSelf());
  for (  ElementDefinitionHolder child : edh.getChildren()) {
    writeElements(child,list);
  }
}",0.9155555555555556
22993,"private int processElementsIntoTree(ElementDefinitionHolder edh,int i,List<ElementDefinition> list){
  String path=edh.getSelf().getPath();
  final String prefix=path + ""String_Node_Str"";
  while (i < list.size() && list.get(i).getPath().startsWith(prefix)) {
    ElementDefinitionHolder child=new ElementDefinitionHolder(list.get(i));
    edh.getChildren().add(child);
    i=processElementsIntoTree(child,i + 1,list);
  }
  return i;
}","private int processElementsIntoTree(ElementDefinitionHolder edh,int i,List<ElementDefinition> list){
  String path=edh.getSelf().getPath();
  final String prefix=path + ""String_Node_Str"";
  while (i < list.size() && list.get(i).getPath().startsWith(prefix)) {
    if (list.get(i).getPath().substring(prefix.length() + 1).contains(""String_Node_Str"")) {
      String newPath=prefix + list.get(i).getPath().substring(prefix.length()).split(""String_Node_Str"")[0];
      ElementDefinition e=new ElementDefinition(new StringType(newPath));
      ElementDefinitionHolder child=new ElementDefinitionHolder(e,true);
      edh.getChildren().add(child);
      i=processElementsIntoTree(child,i,list);
    }
 else {
      ElementDefinitionHolder child=new ElementDefinitionHolder(list.get(i));
      edh.getChildren().add(child);
      i=processElementsIntoTree(child,i + 1,list);
    }
  }
  return i;
}",0.6355421686746988
22994,"private void addNode(List<Piece> list,XhtmlNode c){
  if (c.getNodeType() == NodeType.Text)   list.add(new Piece(null,c.getContent(),null));
 else   if (c.getNodeType() == NodeType.Element) {
    if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(c.getAttribute(""String_Node_Str""),c.allText(),c.getAttribute(""String_Node_Str"")));
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      Piece p=new Piece(c.getName()).setStyle(""String_Node_Str"");
      list.add(p);
      p.getChildren().addAll(c.getChildNodes());
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      Piece p=new Piece(c.getName());
      list.add(p);
      p.getChildren().addAll(c.getChildNodes());
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     throw new Error(""String_Node_Str"" + c.getName());
  }
 else   throw new Error(""String_Node_Str"" + c.getNodeType().toString());
}","private void addNode(List<Piece> list,XhtmlNode c){
  if (c.getNodeType() == NodeType.Text)   list.add(new Piece(null,c.getContent(),null));
 else   if (c.getNodeType() == NodeType.Element) {
    if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(c.getAttribute(""String_Node_Str""),c.allText(),c.getAttribute(""String_Node_Str"")));
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      Piece p=new Piece(c.getName()).setStyle(""String_Node_Str"");
      list.add(p);
      p.getChildren().addAll(c.getChildNodes());
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      Piece p=new Piece(c.getName());
      list.add(p);
      p.getChildren().addAll(c.getChildNodes());
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")|| c.getName().equals(""String_Node_Str"")) {
      Piece p=new Piece(c.getName());
      list.add(p);
      p.getChildren().addAll(c.getChildNodes());
    }
 else {
      throw new Error(""String_Node_Str"" + c.getName());
    }
  }
 else   throw new Error(""String_Node_Str"" + c.getNodeType().toString());
}",0.9106029106029108
22995,"private XhtmlNode renderCell(XhtmlNode tr,Cell c,String name,String icon,String hint,List<Integer> indents,boolean hasChildren,String anchor,String color,int lineColor,String imagePath,int border,Set<String> outputTracker) throws IOException {
  XhtmlNode tc=tr.addTag(name);
  tc.setAttribute(""String_Node_Str"",""String_Node_Str"");
  if (indents != null) {
    tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
    tc.setAttribute(""String_Node_Str"",""String_Node_Str"" + color + ""String_Node_Str""+ border+ ""String_Node_Str""+ imagePath+ checkExists(indents,hasChildren,lineColor,outputTracker)+ ""String_Node_Str"");
    for (int i=0; i < indents.size() - 1; i++) {
switch (indents.get(i)) {
case NEW_REGULAR:
case NEW_SLICER:
case NEW_SLICE:
        tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
      break;
case CONTINUE_REGULAR:
    tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
  break;
case CONTINUE_SLICER:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_SLICE:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + indents.get(i));
}
}
if (!indents.isEmpty()) switch (indents.get(indents.size() - 1)) {
case NEW_REGULAR:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case NEW_SLICER:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case NEW_SLICE:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_REGULAR:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_SLICER:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_SLICE:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + indents.get(indents.size() - 1));
}
}
 else tc.setAttribute(""String_Node_Str"",""String_Node_Str"" + color + ""String_Node_Str""+ border+ ""String_Node_Str"");
if (!Utilities.noString(icon)) {
XhtmlNode img=tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,icon)).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"" + color + ""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
if (hint != null) img.setAttribute(""String_Node_Str"",hint);
tc.addText(""String_Node_Str"");
}
for (Piece p : c.pieces) {
if (!Utilities.noString(p.getTag())) {
XhtmlNode tag=tc.addTag(p.getTag());
if (p.attributes != null) for (String n : p.attributes.keySet()) tag.setAttribute(n,p.attributes.get(n));
if (p.getHint() != null) tag.setAttribute(""String_Node_Str"",p.getHint());
addStyle(tag,p);
}
 else if (!Utilities.noString(p.getReference())) {
XhtmlNode a=addStyle(tc.addTag(""String_Node_Str""),p);
a.setAttribute(""String_Node_Str"",p.getReference());
if (!Utilities.noString(p.getHint())) a.setAttribute(""String_Node_Str"",p.getHint());
a.addText(p.getText());
addStyle(a,p);
}
 else {
if (!Utilities.noString(p.getHint())) {
XhtmlNode s=addStyle(tc.addTag(""String_Node_Str""),p);
s.setAttribute(""String_Node_Str"",p.getHint());
s.addText(p.getText());
}
 else if (p.getStyle() != null) {
XhtmlNode s=addStyle(tc.addTag(""String_Node_Str""),p);
s.addText(p.getText());
}
 else tc.addText(p.getText());
}
}
if (!Utilities.noString(anchor)) tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",nmTokenize(anchor)).addText(""String_Node_Str"");
return tc;
}","private XhtmlNode renderCell(XhtmlNode tr,Cell c,String name,String icon,String hint,List<Integer> indents,boolean hasChildren,String anchor,String color,int lineColor,String imagePath,int border,Set<String> outputTracker) throws IOException {
  XhtmlNode tc=tr.addTag(name);
  tc.setAttribute(""String_Node_Str"",""String_Node_Str"");
  if (indents != null) {
    tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
    tc.setAttribute(""String_Node_Str"",""String_Node_Str"" + color + ""String_Node_Str""+ border+ ""String_Node_Str""+ imagePath+ checkExists(indents,hasChildren,lineColor,outputTracker)+ ""String_Node_Str"");
    for (int i=0; i < indents.size() - 1; i++) {
switch (indents.get(i)) {
case NEW_REGULAR:
case NEW_SLICER:
case NEW_SLICE:
        tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
      break;
case CONTINUE_REGULAR:
    tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
  break;
case CONTINUE_SLICER:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_SLICE:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + indents.get(i));
}
}
if (!indents.isEmpty()) switch (indents.get(indents.size() - 1)) {
case NEW_REGULAR:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case NEW_SLICER:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case NEW_SLICE:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_REGULAR:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_SLICER:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case CONTINUE_SLICE:
tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,""String_Node_Str"")).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + indents.get(indents.size() - 1));
}
}
 else tc.setAttribute(""String_Node_Str"",""String_Node_Str"" + color + ""String_Node_Str""+ border+ ""String_Node_Str"");
if (!Utilities.noString(icon)) {
XhtmlNode img=tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",srcFor(imagePath,icon)).setAttribute(""String_Node_Str"",""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"" + color + ""String_Node_Str"").setAttribute(""String_Node_Str"",""String_Node_Str"");
if (hint != null) img.setAttribute(""String_Node_Str"",hint);
tc.addText(""String_Node_Str"");
}
for (Piece p : c.pieces) {
if (!Utilities.noString(p.getTag())) {
XhtmlNode tag=tc.addTag(p.getTag());
if (p.attributes != null) for (String n : p.attributes.keySet()) tag.setAttribute(n,p.attributes.get(n));
if (p.getHint() != null) tag.setAttribute(""String_Node_Str"",p.getHint());
addStyle(tag,p);
if (p.hasChildren()) tag.getChildNodes().addAll(p.getChildren());
}
 else if (!Utilities.noString(p.getReference())) {
XhtmlNode a=addStyle(tc.addTag(""String_Node_Str""),p);
a.setAttribute(""String_Node_Str"",p.getReference());
if (!Utilities.noString(p.getHint())) a.setAttribute(""String_Node_Str"",p.getHint());
a.addText(p.getText());
addStyle(a,p);
}
 else {
if (!Utilities.noString(p.getHint())) {
XhtmlNode s=addStyle(tc.addTag(""String_Node_Str""),p);
s.setAttribute(""String_Node_Str"",p.getHint());
s.addText(p.getText());
}
 else if (p.getStyle() != null) {
XhtmlNode s=addStyle(tc.addTag(""String_Node_Str""),p);
s.addText(p.getText());
}
 else tc.addText(p.getText());
}
}
if (!Utilities.noString(anchor)) tc.addTag(""String_Node_Str"").setAttribute(""String_Node_Str"",nmTokenize(anchor)).addText(""String_Node_Str"");
return tc;
}",0.9940217391304348
22996,"private void addNode(List<Piece> list,XhtmlNode c){
  if (c.getNodeType() == NodeType.Text)   list.add(new Piece(null,c.getContent(),null));
 else   if (c.getNodeType() == NodeType.Element) {
    if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(c.getAttribute(""String_Node_Str""),c.allText(),c.getAttribute(""String_Node_Str"")));
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     throw new Error(""String_Node_Str"" + c.getName());
  }
 else   throw new Error(""String_Node_Str"" + c.getNodeType().toString());
}","private void addNode(List<Piece> list,XhtmlNode c){
  if (c.getNodeType() == NodeType.Text)   list.add(new Piece(null,c.getContent(),null));
 else   if (c.getNodeType() == NodeType.Element) {
    if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(c.getAttribute(""String_Node_Str""),c.allText(),c.getAttribute(""String_Node_Str"")));
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     if (c.getName().equals(""String_Node_Str"") || c.getName().equals(""String_Node_Str"")) {
      Piece p=new Piece(c.getName());
      list.add(p);
      p.getChildren().addAll(c.getChildNodes());
    }
 else     if (c.getName().equals(""String_Node_Str"")) {
      list.add(new Piece(null,c.allText(),null).setStyle(""String_Node_Str""));
    }
 else     throw new Error(""String_Node_Str"" + c.getName());
  }
 else   throw new Error(""String_Node_Str"" + c.getNodeType().toString());
}",0.8305676855895197
22997,"private StructureDefinition parseProfileSheet(String n,List<String> namedSheets,List<ValidationMessage> issues,boolean logical) throws Exception {
  StructureDefinition sd=new StructureDefinition();
  Map<String,ElementDefinitionConstraintComponent> invariants=new HashMap<String,ElementDefinitionConstraintComponent>();
  String name=logical ? ""String_Node_Str"" : n + ""String_Node_Str"";
  sheet=loadSheet(name);
  if (sheet != null)   invariants=readInvariants(sheet,n,name);
  sheet=loadSheet(n);
  if (sheet == null)   throw new Exception(""String_Node_Str"" + n + ""String_Node_Str"");
  for (int row=0; row < sheet.rows.size(); row++) {
    ElementDefinition e=processLine(sd,sheet,row,invariants,true,row == 0);
    if (e != null)     for (    TypeRefComponent t : e.getType()) {
      if (t.hasProfile() && !""String_Node_Str"".equals(t.getCode()) && t.getProfile().get(0).getValue().startsWith(""String_Node_Str"")) {
        if (!namedSheets.contains(t.getProfile().get(0).getValue().substring(1)))         namedSheets.add(t.getProfile().get(0).getValue().substring(1));
      }
    }
  }
  if (logical) {
    sd.setKind(StructureDefinitionKind.LOGICAL);
    sd.setId(sd.getDifferential().getElement().get(0).getPath());
    sd.getDifferential().getElementFirstRep().getType().clear();
    sd.setType(sd.getDifferential().getElementFirstRep().getPath());
    sd.setBaseDefinition(""String_Node_Str"");
    sd.setDerivation(TypeDerivationRule.SPECIALIZATION);
    sd.setAbstract(false);
  }
 else {
    sd.setKind(StructureDefinitionKind.RESOURCE);
    sd.setDerivation(TypeDerivationRule.CONSTRAINT);
    sd.setAbstract(false);
    sd.setId(n.toLowerCase());
    sd.setType(sd.getDifferential().getElementFirstRep().getPath());
    sd.getDifferential().getElementFirstRep().setSliceName(null);
    if (sd.getDifferential().getElementFirstRep().getType().size() == 1 && sd.getDifferential().getElementFirstRep().getType().get(0).hasProfile())     sd.setBaseDefinition(sd.getDifferential().getElementFirstRep().getType().get(0).getProfile().get(0).getValue());
 else     sd.setBaseDefinition(""String_Node_Str"" + sd.getType());
    if (!context.getResourceNames().contains(sd.getType()) && !context.getTypeNames().contains(sd.getType()))     throw new Exception(""String_Node_Str"" + sd.getType());
  }
  sd.getDifferential().getElementFirstRep().getType().clear();
  sd.setUrl(base + ""String_Node_Str"" + sd.getId());
  bundle.addEntry().setResource(sd).setFullUrl(sd.getUrl());
  sheet=loadSheet(n + ""String_Node_Str"");
  if (sheet != null) {
    int row=0;
    while (row < sheet.rows.size()) {
      if (sheet.getColumn(row,""String_Node_Str"").startsWith(""String_Node_Str""))       row++;
 else       row=processExtension(sheet,row,metadata(""String_Node_Str""),issues,invariants);
    }
  }
  sheet=loadSheet(n + ""String_Node_Str"");
  if (sheet != null) {
    readSearchParams(sd,sheet,true);
  }
  if (invariants != null) {
    for (    ElementDefinitionConstraintComponent inv : invariants.values()) {
      if (Utilities.noString(inv.getUserString(""String_Node_Str"")))       throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str"");
 else {
        ElementDefinition ed=findContext(sd,inv.getUserString(""String_Node_Str""),""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str"");
        ed.getConstraint().add(inv);
        if (Utilities.noString(inv.getXpath())) {
          throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str""+ inv.getHuman()+ ""String_Node_Str"");
        }
        if (Utilities.noString(inv.getExpression())) {
          throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str""+ inv.getHuman()+ ""String_Node_Str"");
        }
 else         if (inv.getXpath().contains(""String_Node_Str""))         throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str""+ inv.getHuman()+ ""String_Node_Str""+ inv.getXpath());
      }
    }
  }
  if (hasMetadata(""String_Node_Str""))   sd.setName(metadata(""String_Node_Str""));
 else   sd.setName(sd.getDifferential().getElementFirstRep().getShort());
  if (!sd.hasName())   sd.setName(""String_Node_Str"" + sd.getId());
  sd.setPublisher(metadata(""String_Node_Str""));
  if (hasMetadata(""String_Node_Str""))   sd.addContact().getTelecom().add(Factory.newContactPoint(ContactPointSystem.URL,metadata(""String_Node_Str"")));
  if (hasMetadata(""String_Node_Str""))   sd.setDateElement(Factory.newDateTime(metadata(""String_Node_Str"").substring(0,10)));
 else   sd.setDate(genDate.getTime());
  if (hasMetadata(""String_Node_Str""))   sd.setDescription(metadata(""String_Node_Str""));
  if (hasMetadata(""String_Node_Str""))   sd.setVersion(metadata(""String_Node_Str""));
  if (hasMetadata(""String_Node_Str""))   sd.setStatus(PublicationStatus.fromCode(metadata(""String_Node_Str"")));
 else   sd.setStatus(PublicationStatus.DRAFT);
  ProfileUtilities utils=new ProfileUtilities(this.context,issues,null);
  utils.setIds(sd,false);
  return sd;
}","private StructureDefinition parseProfileSheet(String n,List<String> namedSheets,List<ValidationMessage> issues,boolean logical) throws Exception {
  StructureDefinition sd=new StructureDefinition();
  Map<String,ElementDefinitionConstraintComponent> invariants=new HashMap<String,ElementDefinitionConstraintComponent>();
  String name=logical ? ""String_Node_Str"" : n + ""String_Node_Str"";
  sheet=loadSheet(name);
  if (sheet != null)   invariants=readInvariants(sheet,n,name);
  sheet=loadSheet(n);
  if (sheet == null)   throw new Exception(""String_Node_Str"" + n + ""String_Node_Str"");
  for (int row=0; row < sheet.rows.size(); row++) {
    ElementDefinition e=processLine(sd,sheet,row,invariants,true,row == 0);
    if (e != null)     for (    TypeRefComponent t : e.getType()) {
      if (t.hasProfile() && !""String_Node_Str"".equals(t.getCode()) && t.getProfile().get(0).getValue().startsWith(""String_Node_Str"")) {
        if (!namedSheets.contains(t.getProfile().get(0).getValue().substring(1)))         namedSheets.add(t.getProfile().get(0).getValue().substring(1));
      }
    }
  }
  if (logical) {
    sd.setKind(StructureDefinitionKind.LOGICAL);
    sd.setId(sd.getDifferential().getElement().get(0).getPath());
    sd.getDifferential().getElementFirstRep().getType().clear();
    sd.setType(sd.getDifferential().getElementFirstRep().getPath());
    sd.setBaseDefinition(""String_Node_Str"");
    sd.setDerivation(TypeDerivationRule.SPECIALIZATION);
    sd.setAbstract(false);
  }
 else {
    sd.setKind(StructureDefinitionKind.RESOURCE);
    sd.setDerivation(TypeDerivationRule.CONSTRAINT);
    sd.setAbstract(false);
    sd.setId(n.toLowerCase());
    sd.setType(sd.getDifferential().getElementFirstRep().getPath());
    sd.getDifferential().getElementFirstRep().setSliceName(null);
    if (sd.getDifferential().getElementFirstRep().getType().size() == 1 && sd.getDifferential().getElementFirstRep().getType().get(0).hasProfile())     sd.setBaseDefinition(sd.getDifferential().getElementFirstRep().getType().get(0).getProfile().get(0).getValue());
 else     sd.setBaseDefinition(""String_Node_Str"" + sd.getType());
    if (!context.getResourceNames().contains(sd.getType()) && !context.getTypeNames().contains(sd.getType()))     throw new Exception(""String_Node_Str"" + sd.getType());
  }
  sd.getDifferential().getElementFirstRep().getType().clear();
  sd.setUrl(base + ""String_Node_Str"" + sd.getId());
  bundle.addEntry().setResource(sd).setFullUrl(sd.getUrl());
  sheet=loadSheet(n + ""String_Node_Str"");
  if (sheet != null) {
    int row=0;
    while (row < sheet.rows.size()) {
      if (sheet.getColumn(row,""String_Node_Str"").startsWith(""String_Node_Str""))       row++;
 else       row=processExtension(sheet,row,metadata(""String_Node_Str""),issues,invariants);
    }
  }
  sheet=loadSheet(n + ""String_Node_Str"");
  if (sheet != null) {
    readSearchParams(sd,sheet,true);
  }
  if (invariants != null) {
    for (    ElementDefinitionConstraintComponent inv : invariants.values()) {
      if (Utilities.noString(inv.getUserString(""String_Node_Str"")))       throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str"");
 else {
        ElementDefinition ed=findContext(sd,inv.getUserString(""String_Node_Str""),""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str"");
        ed.getConstraint().add(inv);
        if (Utilities.noString(inv.getXpath())) {
          throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str""+ inv.getHuman()+ ""String_Node_Str"");
        }
        if (Utilities.noString(inv.getExpression())) {
          throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str""+ inv.getHuman()+ ""String_Node_Str"");
        }
 else         if (inv.getXpath().contains(""String_Node_Str""))         throw new Exception(""String_Node_Str"" + sd.getId() + ""String_Node_Str""+ inv.getId()+ ""String_Node_Str""+ inv.getHuman()+ ""String_Node_Str""+ inv.getXpath());
      }
    }
  }
  if (sd.getDifferential().getElementFirstRep().hasShort())   sd.setName(sd.getDifferential().getElementFirstRep().getShort());
 else   if (hasMetadata(""String_Node_Str""))   sd.setName(metadata(""String_Node_Str""));
 else   sd.setName(""String_Node_Str"");
  if (!sd.hasName())   sd.setName(""String_Node_Str"" + sd.getId());
  sd.setPublisher(metadata(""String_Node_Str""));
  if (hasMetadata(""String_Node_Str""))   sd.addContact().getTelecom().add(Factory.newContactPoint(ContactPointSystem.URL,metadata(""String_Node_Str"")));
  if (hasMetadata(""String_Node_Str""))   sd.setDateElement(Factory.newDateTime(metadata(""String_Node_Str"").substring(0,10)));
 else   sd.setDate(genDate.getTime());
  if (hasMetadata(""String_Node_Str""))   sd.setDescription(metadata(""String_Node_Str""));
  if (hasMetadata(""String_Node_Str""))   sd.setVersion(metadata(""String_Node_Str""));
  if (hasMetadata(""String_Node_Str""))   sd.setStatus(PublicationStatus.fromCode(metadata(""String_Node_Str"")));
 else   sd.setStatus(PublicationStatus.DRAFT);
  ProfileUtilities utils=new ProfileUtilities(this.context,issues,null);
  utils.setIds(sd,false);
  return sd;
}",0.9802317655078392
22998,"public List<XhtmlNode> getChildren(){
  return children;
}","public List<XhtmlNode> getChildren(){
  if (children == null)   children=new ArrayList<XhtmlNode>();
  return children;
}",0.6480446927374302
22999,"/** 
 * given an element definition in a profile, what element contains the differentiating fixed  for the element, given the differentiating expresssion. The expression is only allowed to  use a subset of FHIRPath
 * @param profile
 * @param element
 * @return
 * @throws PathEngineException 
 * @throws DefinitionException 
 */
public ElementDefinition evaluateDefinition(ExpressionNode expr,StructureDefinition profile,ElementDefinition element) throws DefinitionException {
  StructureDefinition sd=profile;
  ElementDefinition focus=null;
  if (expr.getKind() == Kind.Name) {
    List<ElementDefinition> childDefinitions;
    childDefinitions=ProfileUtilities.getChildMap(sd,element);
    if (childDefinitions.isEmpty()) {
      sd=fetchStructureByType(element);
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      childDefinitions=ProfileUtilities.getChildMap(sd,sd.getSnapshot().getElementFirstRep());
    }
    for (    ElementDefinition t : childDefinitions) {
      if (tailMatches(t,expr.getName())) {
        focus=t;
        break;
      }
    }
  }
 else   if (expr.getKind() == Kind.Function) {
    if (""String_Node_Str"".equals(expr.getName())) {
      if (!element.hasType())       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (element.getType().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (element.getType().get(0).getTargetProfile().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (!element.getType().get(0).hasTarget())       throw new DefinitionException(""String_Node_Str"" + element.getId() + ""String_Node_Str""+ element.getType().get(0).getCode()+ ""String_Node_Str"");
      sd=worker.fetchResource(StructureDefinition.class,element.getType().get(0).getTargetProfile().get(0).getValue());
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getTargetProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      focus=sd.getSnapshot().getElementFirstRep();
    }
 else     if (""String_Node_Str"".equals(expr.getName())) {
      String targetUrl=expr.getParameters().get(0).getConstant();
      targetUrl=targetUrl.substring(1,targetUrl.length() - 1);
      List<ElementDefinition> childDefinitions=ProfileUtilities.getChildMap(sd,element);
      for (      ElementDefinition t : childDefinitions) {
        if (t.getPath().endsWith(""String_Node_Str"") && t.hasSliceName()) {
          sd=worker.fetchResource(StructureDefinition.class,t.getType().get(0).getProfile().get(0).getValue());
          while (sd != null && !sd.getBaseDefinition().equals(""String_Node_Str""))           sd=worker.fetchResource(StructureDefinition.class,sd.getBaseDefinition());
          if (sd.getUrl().equals(targetUrl)) {
            focus=t;
            break;
          }
        }
      }
    }
 else     throw new DefinitionException(""String_Node_Str"" + expr.getName() + ""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Group) {
    throw new DefinitionException(""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Constant) {
    throw new DefinitionException(""String_Node_Str"");
  }
  if (focus == null)   throw new DefinitionException(""String_Node_Str"");
 else   if (expr.getInner() == null)   return focus;
 else   return evaluateDefinition(expr.getInner(),sd,focus);
}","/** 
 * given an element definition in a profile, what element contains the differentiating fixed  for the element, given the differentiating expresssion. The expression is only allowed to  use a subset of FHIRPath
 * @param profile
 * @param element
 * @return
 * @throws PathEngineException 
 * @throws DefinitionException 
 */
public ElementDefinition evaluateDefinition(ExpressionNode expr,StructureDefinition profile,ElementDefinition element) throws DefinitionException {
  StructureDefinition sd=profile;
  ElementDefinition focus=null;
  if (expr.getKind() == Kind.Name) {
    List<ElementDefinition> childDefinitions;
    childDefinitions=ProfileUtilities.getChildMap(sd,element);
    if (childDefinitions.isEmpty()) {
      sd=fetchStructureByType(element);
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      childDefinitions=ProfileUtilities.getChildMap(sd,sd.getSnapshot().getElementFirstRep());
    }
    for (    ElementDefinition t : childDefinitions) {
      if (tailMatches(t,expr.getName())) {
        focus=t;
        break;
      }
    }
  }
 else   if (expr.getKind() == Kind.Function) {
    if (""String_Node_Str"".equals(expr.getName())) {
      if (!element.hasType())       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (element.getType().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      if (!element.getType().get(0).hasTarget())       throw new DefinitionException(""String_Node_Str"" + element.getId() + ""String_Node_Str""+ element.getType().get(0).getCode()+ ""String_Node_Str"");
      if (element.getType().get(0).getTargetProfile().size() > 1)       throw new DefinitionException(""String_Node_Str"" + element.getId());
      sd=worker.fetchResource(StructureDefinition.class,element.getType().get(0).getTargetProfile().get(0).getValue());
      if (sd == null)       throw new DefinitionException(""String_Node_Str"" + element.getType().get(0).getTargetProfile() + ""String_Node_Str""+ element.getId()+ ""String_Node_Str"");
      focus=sd.getSnapshot().getElementFirstRep();
    }
 else     if (""String_Node_Str"".equals(expr.getName())) {
      String targetUrl=expr.getParameters().get(0).getConstant();
      targetUrl=targetUrl.substring(1,targetUrl.length() - 1);
      List<ElementDefinition> childDefinitions=ProfileUtilities.getChildMap(sd,element);
      for (      ElementDefinition t : childDefinitions) {
        if (t.getPath().endsWith(""String_Node_Str"") && t.hasSliceName()) {
          sd=worker.fetchResource(StructureDefinition.class,t.getType().get(0).getProfile().get(0).getValue());
          while (sd != null && !sd.getBaseDefinition().equals(""String_Node_Str""))           sd=worker.fetchResource(StructureDefinition.class,sd.getBaseDefinition());
          if (sd.getUrl().equals(targetUrl)) {
            focus=t;
            break;
          }
        }
      }
    }
 else     throw new DefinitionException(""String_Node_Str"" + expr.getName() + ""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Group) {
    throw new DefinitionException(""String_Node_Str"");
  }
 else   if (expr.getKind() == Kind.Constant) {
    throw new DefinitionException(""String_Node_Str"");
  }
  if (focus == null)   throw new DefinitionException(""String_Node_Str"");
 else   if (expr.getInner() == null)   return focus;
 else   return evaluateDefinition(expr.getInner(),sd,focus);
}",0.599544289376246
23000,"@Override public Base resolveReference(Object appContext,String url){
  throw new NotImplementedException(""String_Node_Str"");
}","@Override public Base resolveReference(Object appContext,String url){
  if (appContext instanceof Element) {
    Element bnd=(Element)appContext;
    if (bnd.fhirType().equals(""String_Node_Str"")) {
      for (      Element be : bnd.getChildrenByName(""String_Node_Str"")) {
        Element res=be.getNamedChild(""String_Node_Str"");
        if (res != null) {
          String fullUrl=be.getChildValue(""String_Node_Str"");
          String rt=res.fhirType();
          String id=res.getChildValue(""String_Node_Str"");
          if (url.equals(fullUrl))           return res;
          if (url.equals(rt + ""String_Node_Str"" + id))           return res;
        }
      }
    }
    return null;
  }
  throw new NotImplementedException(""String_Node_Str"" + appContext.toString() + ""String_Node_Str""+ url+ ""String_Node_Str"");
}",0.2693531283138918
