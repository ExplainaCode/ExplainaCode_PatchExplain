record_number,buggy_code,fixed_code,code_similarity
154001,"public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if (page != 0) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  return new JPEGImage(input,param);
}","public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if (page != 0) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  try {
    return new JPEGImage(input,param);
  }
 catch (  Exception e) {
    throw CodecUtils.toIOException(e);
  }
}",0.8257261410788381
154002,"public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if (page != 0) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  return new PNGImage(input,(PNGDecodeParam)param);
}","public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if (page != 0) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  try {
    return new PNGImage(input,(PNGDecodeParam)param);
  }
 catch (  Exception e) {
    throw CodecUtils.toIOException(e);
  }
}",0.8359375
154003,"public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if (page != 0) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  return new PNMImage(input);
}","public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if (page != 0) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  try {
    return new PNMImage(input);
  }
 catch (  Exception e) {
    throw CodecUtils.toIOException(e);
  }
}",0.8205128205128205
154004,"public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if ((page < 0) || (page >= getNumPages())) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  return new TIFFImage(input,(TIFFDecodeParam)param,page);
}","public RenderedImage decodeAsRenderedImage(int page) throws IOException {
  if ((page < 0) || (page >= getNumPages())) {
    throw new IOException(JaiI18N.getString(""String_Node_Str""));
  }
  try {
    return new TIFFImage(input,(TIFFDecodeParam)param,page);
  }
 catch (  Exception e) {
    throw CodecUtils.toIOException(e);
  }
}",0.8591065292096219
154005,"public int getNumPages() throws IOException {
  return TIFFDirectory.getNumDirectories(input);
}","public int getNumPages() throws IOException {
  try {
    return TIFFDirectory.getNumDirectories(input);
  }
 catch (  Exception e) {
    throw CodecUtils.toIOException(e);
  }
}",0.7007299270072993
154006,"private static ImageLayout layoutHelper(Vector sources,ImageLayout il){
  ImageLayout layout=(il == null) ? new ImageLayout() : (ImageLayout)il.clone();
  int numSources=sources.size();
  int destNumBands=totalNumBands(sources);
  int destDataType=DataBuffer.TYPE_BYTE;
  RenderedImage srci=(RenderedImage)sources.get(0);
  Rectangle destBounds=new Rectangle(srci.getMinX(),srci.getMinY(),srci.getWidth(),srci.getHeight());
  for (int i=0; i < numSources; i++) {
    srci=(RenderedImage)sources.get(i);
    destBounds=destBounds.intersection(new Rectangle(srci.getMinX(),srci.getMinY(),srci.getWidth(),srci.getHeight()));
    int typei=srci.getSampleModel().getTransferType();
    destDataType=typei > destDataType ? typei : destDataType;
  }
  SampleModel sm=layout.getSampleModel((RenderedImage)sources.get(0));
  if (sm.getNumBands() < destNumBands) {
    int[] destOffsets=new int[destNumBands];
    for (int i=0; i < destNumBands; i++) {
      destOffsets[i]=i;
    }
    sm=RasterFactory.createComponentSampleModel(sm,destDataType,destBounds.width,destBounds.height,destNumBands);
    layout.setSampleModel(sm);
  }
  ColorModel cm=layout.getColorModel(null);
  if (cm != null && !JDKWorkarounds.areCompatibleDataModels(sm,cm)) {
    layout.unsetValid(ImageLayout.COLOR_MODEL_MASK);
  }
  return layout;
}","private static ImageLayout layoutHelper(Vector sources,ImageLayout il){
  ImageLayout layout=(il == null) ? new ImageLayout() : (ImageLayout)il.clone();
  int numSources=sources.size();
  int destNumBands=totalNumBands(sources);
  int destDataType=DataBuffer.TYPE_BYTE;
  RenderedImage srci=(RenderedImage)sources.get(0);
  Rectangle destBounds=new Rectangle(srci.getMinX(),srci.getMinY(),srci.getWidth(),srci.getHeight());
  for (int i=0; i < numSources; i++) {
    srci=(RenderedImage)sources.get(i);
    destBounds=destBounds.intersection(new Rectangle(srci.getMinX(),srci.getMinY(),srci.getWidth(),srci.getHeight()));
    int typei=srci.getSampleModel().getTransferType();
    destDataType=typei > destDataType ? typei : destDataType;
  }
  SampleModel sm=layout.getSampleModel((RenderedImage)sources.get(0));
  if (sm.getNumBands() < destNumBands) {
    int[] destOffsets=new int[destNumBands];
    for (int i=0; i < destNumBands; i++) {
      destOffsets[i]=i;
    }
    int destTileWidth=sm.getWidth();
    int destTileHeight=sm.getHeight();
    if (layout.isValid(ImageLayout.TILE_WIDTH_MASK)) {
      destTileWidth=layout.getTileWidth((RenderedImage)sources.get(0));
    }
    if (layout.isValid(ImageLayout.TILE_HEIGHT_MASK)) {
      destTileHeight=layout.getTileHeight((RenderedImage)sources.get(0));
    }
    sm=RasterFactory.createComponentSampleModel(sm,destDataType,destTileWidth,destTileHeight,destNumBands);
    layout.setSampleModel(sm);
  }
  ColorModel cm=layout.getColorModel(null);
  if (cm != null && !JDKWorkarounds.areCompatibleDataModels(sm,cm)) {
    layout.unsetValid(ImageLayout.COLOR_MODEL_MASK);
  }
  return layout;
}",0.872678149273894
154007,"private void computeRectNonColorSpaceJAI(Raster src,ImageParameters srcParam,WritableRaster dest,ImageParameters dstParam,Rectangle destRect){
  if (!srcParam.isFloat() && !dstParam.isFloat()) {
    Raster s=src;
    if (s.getMinX() != destRect.x || s.getMinY() != destRect.y || s.getWidth() != destRect.width || s.getHeight() != destRect.height) {
      s=s.createChild(destRect.x,destRect.y,destRect.width,destRect.height,destRect.x,destRect.y,null);
    }
    WritableRaster d=dest;
    if (d.getMinX() != destRect.x || d.getMinY() != destRect.y || d.getWidth() != destRect.width || d.getHeight() != destRect.height) {
      d=d.createWritableChild(destRect.x,destRect.y,destRect.width,destRect.height,destRect.x,destRect.y,null);
    }
    colorConvertOp.filter(s,d);
  }
 else {
    ColorSpace srcColorSpace=srcParam.getColorModel().getColorSpace();
    ColorSpace dstColorSpace=dstParam.getColorModel().getColorSpace();
    boolean srcFloat=srcParam.isFloat();
    float srcMinValue=srcParam.getMinValue();
    float srcRange=srcParam.getRange();
    boolean dstFloat=dstParam.isFloat();
    float dstMinValue=dstParam.getMinValue();
    float dstRange=dstParam.getRange();
    int rectYMax=destRect.y + destRect.height;
    int rectXMax=destRect.x + destRect.width;
    int numComponents=srcColorSpace.getNumComponents();
    float[] srcPixel=new float[numComponents];
    float[] xyzPixel;
    float[] dstPixel;
    for (int y=destRect.y; y < rectYMax; y++) {
      for (int x=destRect.x; x < rectXMax; x++) {
        srcPixel=src.getPixel(x,y,srcPixel);
        if (!srcFloat) {
          for (int i=0; i < numComponents; i++) {
            srcPixel[i]=(srcPixel[i] - srcMinValue) / srcRange;
          }
        }
        xyzPixel=srcColorSpace.toCIEXYZ(srcPixel);
        dstPixel=dstColorSpace.fromCIEXYZ(xyzPixel);
        if (!dstFloat) {
          for (int i=0; i < numComponents; i++) {
            dstPixel[i]=(dstPixel[i] * dstRange + dstMinValue);
          }
        }
        dest.setPixel(x,y,dstPixel);
      }
    }
  }
}","private void computeRectNonColorSpaceJAI(Raster src,ImageParameters srcParam,WritableRaster dest,ImageParameters dstParam,Rectangle destRect){
  if (!srcParam.isFloat() && !dstParam.isFloat()) {
    Raster s=src;
    if (s.getMinX() != destRect.x || s.getMinY() != destRect.y || s.getWidth() != destRect.width || s.getHeight() != destRect.height) {
      s=s.createChild(destRect.x,destRect.y,destRect.width,destRect.height,destRect.x,destRect.y,null);
    }
    WritableRaster d=dest;
    if (d.getMinX() != destRect.x || d.getMinY() != destRect.y || d.getWidth() != destRect.width || d.getHeight() != destRect.height) {
      d=d.createWritableChild(destRect.x,destRect.y,destRect.width,destRect.height,destRect.x,destRect.y,null);
    }
synchronized (colorConvertOp.getClass()) {
      colorConvertOp.filter(s,d);
    }
  }
 else {
    ColorSpace srcColorSpace=srcParam.getColorModel().getColorSpace();
    ColorSpace dstColorSpace=dstParam.getColorModel().getColorSpace();
    boolean srcFloat=srcParam.isFloat();
    float srcMinValue=srcParam.getMinValue();
    float srcRange=srcParam.getRange();
    boolean dstFloat=dstParam.isFloat();
    float dstMinValue=dstParam.getMinValue();
    float dstRange=dstParam.getRange();
    int rectYMax=destRect.y + destRect.height;
    int rectXMax=destRect.x + destRect.width;
    int numComponents=srcColorSpace.getNumComponents();
    float[] srcPixel=new float[numComponents];
    float[] xyzPixel;
    float[] dstPixel;
    for (int y=destRect.y; y < rectYMax; y++) {
      for (int x=destRect.x; x < rectXMax; x++) {
        srcPixel=src.getPixel(x,y,srcPixel);
        if (!srcFloat) {
          for (int i=0; i < numComponents; i++) {
            srcPixel[i]=(srcPixel[i] - srcMinValue) / srcRange;
          }
        }
        xyzPixel=srcColorSpace.toCIEXYZ(srcPixel);
        dstPixel=dstColorSpace.fromCIEXYZ(xyzPixel);
        if (!dstFloat) {
          for (int i=0; i < numComponents; i++) {
            dstPixel[i]=(dstPixel[i] * dstRange + dstMinValue);
          }
        }
        dest.setPixel(x,y,dstPixel);
      }
    }
  }
}",0.9857522337599612
154008,"public float[] fromRGB(float[] rgbvalue){
  float C=1.0F - rgbvalue[0];
  float M=1.0F - rgbvalue[1];
  float Y=1.0F - rgbvalue[2];
  float K=Math.min(C,Math.min(M,Y));
  return new float[]{C,M,Y,K};
}","public float[] fromRGB(float[] rgbvalue){
  float C=1.0F - rgbvalue[0];
  float M=1.0F - rgbvalue[1];
  float Y=1.0F - rgbvalue[2];
  float K=Math.min(C,Math.min(M,Y));
  if (K != 1.0F) {
    float K1=1.0F - K;
    C=(C - K) / K1;
    M=(M - K) / K1;
    Y=(Y - K) / K1;
  }
  return new float[]{C,M,Y,K};
}",0.7913385826771654
154009,"public float[] toRGB(float[] colorvalue){
  float K=colorvalue[3];
  float C=colorvalue[0] - K;
  float M=colorvalue[1] - K;
  float Y=colorvalue[2] - K;
  return new float[]{1.0F - C,1.0F - M,1.0F - Y};
}","public float[] toRGB(float[] colorvalue){
  float C=colorvalue[0];
  float M=colorvalue[1];
  float Y=colorvalue[2];
  float K=colorvalue[3];
  float K1=1.0F - K;
  return new float[]{K1 * (1.0F - C),K1 * (1.0F - M),K1 * (1.0F - Y)};
}",0.3818181818181818
154010,"protected boolean validateParameters(ParameterBlock args,StringBuffer msg){
  int argNumParams=args.getNumParameters();
  if (argNumParams > 0 && args.getObjectParameter(0) instanceof Integer) {
    Object obj;
    if (argNumParams < 2) {
      obj=args.getObjectParameter(0);
      if (obj instanceof Integer) {
        args.add(obj);
      }
    }
    if (argNumParams < 3) {
      obj=args.getObjectParameter(0);
      if (obj instanceof Integer) {
        args.add(((Integer)obj).intValue() / 2);
      }
    }
    if (argNumParams < 4) {
      obj=args.getObjectParameter(1);
      if (obj instanceof Integer) {
        args.add(((Integer)obj).intValue() / 2);
      }
    }
  }
  return super.validateParameters(args,msg);
}","protected boolean validateParameters(ParameterBlock args,StringBuffer msg){
  int argNumParams=args.getNumParameters();
  if (argNumParams == 0) {
    args.add(paramDefaults[0]);
    argNumParams++;
  }
  if (argNumParams > 0 && args.getObjectParameter(0) instanceof Integer) {
    Object obj;
    if (argNumParams < 2) {
      obj=args.getObjectParameter(0);
      if (obj instanceof Integer) {
        args.add(obj);
      }
    }
    if (argNumParams < 3) {
      obj=args.getObjectParameter(0);
      if (obj instanceof Integer) {
        args.add(((Integer)obj).intValue() / 2);
      }
    }
    if (argNumParams < 4) {
      obj=args.getObjectParameter(1);
      if (obj instanceof Integer) {
        args.add(((Integer)obj).intValue() / 2);
      }
    }
  }
  return super.validateParameters(args,msg);
}",0.946208684381076
154011,"/** 
 * Returns a new WritableRaster which shares all or part of the supplied WritableRaster's DataBuffer.  The new WritableRaster will possess a reference to the supplied WritableRaster, accessible through its getParent() and getWritableParent() methods. <p> This method provides a workaround for a bug in the implementation of WritableRaster.createWritableChild in the initial relase of the Java2 platform. <p> The <code>parentX</code>, <code>parentY</code>, <code>width</code> and <code>height</code> parameters form a Rectangle in this WritableRaster's coordinate space, indicating the area of pixels to be shared.  An error will be thrown if this Rectangle is not contained with the bounds of the supplied WritableRaster. <p> The new WritableRaster may additionally be translated to a different coordinate system for the plane than that used by the supplied WritableRaster.  The childMinX and childMinY parameters give the new (x, y) coordinate of the upper-left pixel of the returned WritableRaster; the coordinate (childMinX, childMinY) in the new WritableRaster will map to the same pixel as the coordinate (parentX, parentY) in the supplied WritableRaster. <p> The new WritableRaster may be defined to contain only a subset of the bands of the supplied WritableRaster, possibly reordered, by means of the bandList parameter.  If bandList is null, it is taken to include all of the bands of the supplied WritableRaster in their current order. <p> To create a new WritableRaster that contains a subregion of the supplied WritableRaster, but shares its coordinate system and bands, this method should be called with childMinX equal to parentX, childMinY equal to parentY, and bandList equal to null.
 * @param raster     The parent WritableRaster.
 * @param parentX    X coordinate of the upper left corner of the sharedrectangle in this WritableRaster's coordinates.
 * @param parentY    Y coordinate of the upper left corner of the sharedrectangle in this WritableRaster's coordinates.
 * @param width      Width of the shared rectangle starting at(<code>parentX</code>, <code>parentY</code>).
 * @param height     Height of the shared rectangle starting at(<code>parentX</code>, <code>parentY</code>).
 * @param childMinX  X coordinate of the upper left corner ofthe returned WritableRaster.
 * @param childMinY  Y coordinate of the upper left corner ofthe returned WritableRaster.
 * @param bandList   Array of band indices, or null to use all bands.
 * @throws RasterFormatException if the subregion is outside of theraster bounds. 
 */
public static WritableRaster createWritableChild(WritableRaster raster,int parentX,int parentY,int width,int height,int childMinX,int childMinY,int bandList[]){
  if (parentX < raster.getMinX()) {
    throw new RasterFormatException(JaiI18N.getString(""String_Node_Str""));
  }
  if (parentY < raster.getMinY()) {
    throw new RasterFormatException(JaiI18N.getString(""String_Node_Str""));
  }
  if (parentX + width > raster.getWidth() + raster.getMinX()) {
    throw new RasterFormatException(JaiI18N.getString(""String_Node_Str""));
  }
  if (parentY + height > raster.getHeight() + raster.getMinY()) {
    throw new RasterFormatException(JaiI18N.getString(""String_Node_Str""));
  }
  SampleModel sampleModel=raster.getSampleModel();
  DataBuffer dataBuffer=raster.getDataBuffer();
  int sampleModelTranslateX=raster.getSampleModelTranslateX();
  int sampleModelTranslateY=raster.getSampleModelTranslateY();
  SampleModel sm;
  if (bandList != null) {
    sm=sampleModel.createCompatibleSampleModel(sampleModel.getWidth(),sampleModel.getHeight());
    sm=sm.createSubsetSampleModel(bandList);
  }
 else {
    sm=sampleModel;
  }
  int deltaX=childMinX - parentX;
  int deltaY=childMinY - parentY;
  return new WritableRasterJAI(sm,dataBuffer,new Rectangle(childMinX,childMinY,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),raster);
}","/** 
 * Returns a new WritableRaster which shares all or part of the supplied WritableRaster's DataBuffer.  The new WritableRaster will possess a reference to the supplied WritableRaster, accessible through its getParent() and getWritableParent() methods. <p> This method provides a workaround for a bug in the implementation of WritableRaster.createWritableChild in the initial relase of the Java2 platform. <p> The <code>parentX</code>, <code>parentY</code>, <code>width</code> and <code>height</code> parameters form a Rectangle in this WritableRaster's coordinate space, indicating the area of pixels to be shared.  An error will be thrown if this Rectangle is not contained with the bounds of the supplied WritableRaster. <p> The new WritableRaster may additionally be translated to a different coordinate system for the plane than that used by the supplied WritableRaster.  The childMinX and childMinY parameters give the new (x, y) coordinate of the upper-left pixel of the returned WritableRaster; the coordinate (childMinX, childMinY) in the new WritableRaster will map to the same pixel as the coordinate (parentX, parentY) in the supplied WritableRaster. <p> The new WritableRaster may be defined to contain only a subset of the bands of the supplied WritableRaster, possibly reordered, by means of the bandList parameter.  If bandList is null, it is taken to include all of the bands of the supplied WritableRaster in their current order. <p> To create a new WritableRaster that contains a subregion of the supplied WritableRaster, but shares its coordinate system and bands, this method should be called with childMinX equal to parentX, childMinY equal to parentY, and bandList equal to null.
 * @param raster     The parent WritableRaster.
 * @param parentX    X coordinate of the upper left corner of the sharedrectangle in this WritableRaster's coordinates.
 * @param parentY    Y coordinate of the upper left corner of the sharedrectangle in this WritableRaster's coordinates.
 * @param width      Width of the shared rectangle starting at(<code>parentX</code>, <code>parentY</code>).
 * @param height     Height of the shared rectangle starting at(<code>parentX</code>, <code>parentY</code>).
 * @param childMinX  X coordinate of the upper left corner ofthe returned WritableRaster.
 * @param childMinY  Y coordinate of the upper left corner ofthe returned WritableRaster.
 * @param bandList   Array of band indices, or null to use all bands.
 * @throws RasterFormatException if the subregion is outside of theraster bounds. 
 */
public static WritableRaster createWritableChild(WritableRaster raster,int parentX,int parentY,int width,int height,int childMinX,int childMinY,int bandList[]){
  return raster.createWritableChild(parentX,parentY,width,height,childMinX,childMinY,bandList);
}",0.8142198423322922
154012,"public static RenderedImage create(String type,ParameterBlock paramBlock,RenderingHints renderHints){
  ImagingListener listener=ImageUtil.getImagingListener(renderHints);
  SeekableStream source=(SeekableStream)paramBlock.getObjectParameter(0);
  ImageDecodeParam param=null;
  if (paramBlock.getNumParameters() > 1) {
    param=(ImageDecodeParam)paramBlock.getObjectParameter(1);
  }
  int page=0;
  if (paramBlock.getNumParameters() > 2) {
    page=paramBlock.getIntParameter(2);
  }
  ImageDecoder dec=ImageCodec.createImageDecoder(type,source,param);
  try {
    int bound=OpImage.OP_IO_BOUND;
    ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
    if (renderHints != null) {
      RenderingHints.Key key;
      key=JAI.KEY_OPERATION_BOUND;
      if (renderHints.containsKey(key)) {
        bound=((Integer)renderHints.get(key)).intValue();
      }
    }
    boolean canAttemptRecovery=source.canSeekBackwards();
    long streamPosition=Long.MIN_VALUE;
    if (canAttemptRecovery) {
      try {
        streamPosition=source.getFilePointer();
      }
 catch (      IOException ioe) {
        listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),ioe,CodecRIFUtil.class,false);
        canAttemptRecovery=false;
      }
    }
    OpImage image=null;
    try {
      image=new NullOpImage(dec.decodeAsRenderedImage(page),layout,renderHints,bound);
    }
 catch (    OutOfMemoryError memoryError) {
      if (canAttemptRecovery) {
        TileCache cache=image != null ? image.getTileCache() : RIFUtil.getTileCacheHint(renderHints);
        if (cache != null) {
          cache.flush();
        }
        System.gc();
        source.seek(streamPosition);
        image=new NullOpImage(dec.decodeAsRenderedImage(page),layout,renderHints,bound);
      }
 else {
        String message=JaiI18N.getString(""String_Node_Str"");
        listener.errorOccurred(message,new ImagingException(message,memoryError),CodecRIFUtil.class,false);
      }
    }
    return image;
  }
 catch (  Exception e) {
    listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),e,CodecRIFUtil.class,false);
    return null;
  }
}","public static RenderedImage create(String type,ParameterBlock paramBlock,RenderingHints renderHints){
  ImagingListener listener=ImageUtil.getImagingListener(renderHints);
  SeekableStream source=(SeekableStream)paramBlock.getObjectParameter(0);
  ImageDecodeParam param=null;
  if (paramBlock.getNumParameters() > 1) {
    param=(ImageDecodeParam)paramBlock.getObjectParameter(1);
  }
  int page=0;
  if (paramBlock.getNumParameters() > 2) {
    page=paramBlock.getIntParameter(2);
  }
  ImageDecoder dec=ImageCodec.createImageDecoder(type,source,param);
  try {
    int bound=OpImage.OP_IO_BOUND;
    ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
    if (renderHints != null) {
      RenderingHints.Key key;
      key=JAI.KEY_OPERATION_BOUND;
      if (renderHints.containsKey(key)) {
        bound=((Integer)renderHints.get(key)).intValue();
      }
    }
    boolean canAttemptRecovery=source.canSeekBackwards();
    long streamPosition=Long.MIN_VALUE;
    if (canAttemptRecovery) {
      try {
        streamPosition=source.getFilePointer();
      }
 catch (      IOException ioe) {
        listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),ioe,CodecRIFUtil.class,false);
        canAttemptRecovery=false;
      }
    }
    OpImage image=null;
    try {
      image=new DisposableNullOpImage(dec.decodeAsRenderedImage(page),layout,renderHints,bound);
    }
 catch (    OutOfMemoryError memoryError) {
      if (canAttemptRecovery) {
        TileCache cache=image != null ? image.getTileCache() : RIFUtil.getTileCacheHint(renderHints);
        if (cache != null) {
          cache.flush();
        }
        System.gc();
        source.seek(streamPosition);
        image=new DisposableNullOpImage(dec.decodeAsRenderedImage(page),layout,renderHints,bound);
      }
 else {
        String message=JaiI18N.getString(""String_Node_Str"");
        listener.errorOccurred(message,new ImagingException(message,memoryError),CodecRIFUtil.class,false);
      }
    }
    return image;
  }
 catch (  Exception e) {
    listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),e,CodecRIFUtil.class,false);
    return null;
  }
}",0.9953183520599252
154013,"/** 
 * Creates an image from a SeekableStream.
 */
public RenderedImage create(ParameterBlock paramBlock,RenderingHints renderHints){
  ImagingListener listener=ImageUtil.getImagingListener(renderHints);
  SeekableStream src=(SeekableStream)paramBlock.getObjectParameter(0);
  try {
    src.seek(0L);
  }
 catch (  IOException e) {
    listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),e,this,false);
    return null;
  }
  ImageDecodeParam param=null;
  if (paramBlock.getNumParameters() > 1) {
    param=(ImageDecodeParam)paramBlock.getObjectParameter(1);
  }
  String[] names=ImageCodec.getDecoderNames(src);
  OperationRegistry registry=JAI.getDefaultInstance().getOperationRegistry();
  int bound=OpImage.OP_IO_BOUND;
  ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
  if (renderHints != null) {
    RenderingHints.Key key;
    key=JAI.KEY_OPERATION_REGISTRY;
    if (renderHints.containsKey(key)) {
      registry=(OperationRegistry)renderHints.get(key);
    }
    key=JAI.KEY_OPERATION_BOUND;
    if (renderHints.containsKey(key)) {
      bound=((Integer)renderHints.get(key)).intValue();
    }
  }
  for (int i=0; i < names.length; i++) {
    RenderedImageFactory rif=null;
    try {
      rif=RIFRegistry.get(registry,names[i]);
    }
 catch (    IllegalArgumentException iae) {
    }
    if (rif != null) {
      RenderedImage im=RIFRegistry.create(registry,names[i],paramBlock,renderHints);
      if (im != null) {
        return im;
      }
    }
  }
  boolean canAttemptRecovery=src.canSeekBackwards();
  long streamPosition=Long.MIN_VALUE;
  if (canAttemptRecovery) {
    try {
      streamPosition=src.getFilePointer();
    }
 catch (    IOException ioe) {
      listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),ioe,this,false);
      canAttemptRecovery=false;
    }
  }
  for (int i=0; i < names.length; i++) {
    ImageDecoder dec=ImageCodec.createImageDecoder(names[i],src,param);
    RenderedImage im=null;
    try {
      im=dec.decodeAsRenderedImage();
    }
 catch (    OutOfMemoryError memoryError) {
      if (canAttemptRecovery) {
        TileCache cache=RIFUtil.getTileCacheHint(renderHints);
        if (cache != null) {
          cache.flush();
        }
        System.gc();
        try {
          src.seek(streamPosition);
          im=dec.decodeAsRenderedImage();
        }
 catch (        IOException ioe) {
          listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),ioe,this,false);
          im=null;
        }
      }
 else {
        String message=JaiI18N.getString(""String_Node_Str"");
        listener.errorOccurred(message,new ImagingException(message,memoryError),this,false);
      }
    }
catch (    IOException e) {
      listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),e,this,false);
      im=null;
    }
    if (im != null) {
      return new NullOpImage(im,layout,renderHints,bound);
    }
  }
  return null;
}","/** 
 * Creates an image from a SeekableStream.
 */
public RenderedImage create(ParameterBlock paramBlock,RenderingHints renderHints){
  ImagingListener listener=ImageUtil.getImagingListener(renderHints);
  SeekableStream src=(SeekableStream)paramBlock.getObjectParameter(0);
  try {
    src.seek(0L);
  }
 catch (  IOException e) {
    listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),e,this,false);
    return null;
  }
  ImageDecodeParam param=null;
  if (paramBlock.getNumParameters() > 1) {
    param=(ImageDecodeParam)paramBlock.getObjectParameter(1);
  }
  String[] names=ImageCodec.getDecoderNames(src);
  OperationRegistry registry=JAI.getDefaultInstance().getOperationRegistry();
  int bound=OpImage.OP_IO_BOUND;
  ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
  if (renderHints != null) {
    RenderingHints.Key key;
    key=JAI.KEY_OPERATION_REGISTRY;
    if (renderHints.containsKey(key)) {
      registry=(OperationRegistry)renderHints.get(key);
    }
    key=JAI.KEY_OPERATION_BOUND;
    if (renderHints.containsKey(key)) {
      bound=((Integer)renderHints.get(key)).intValue();
    }
  }
  for (int i=0; i < names.length; i++) {
    RenderedImageFactory rif=null;
    try {
      rif=RIFRegistry.get(registry,names[i]);
    }
 catch (    IllegalArgumentException iae) {
    }
    if (rif != null) {
      RenderedImage im=RIFRegistry.create(registry,names[i],paramBlock,renderHints);
      if (im != null) {
        return im;
      }
    }
  }
  boolean canAttemptRecovery=src.canSeekBackwards();
  long streamPosition=Long.MIN_VALUE;
  if (canAttemptRecovery) {
    try {
      streamPosition=src.getFilePointer();
    }
 catch (    IOException ioe) {
      listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),ioe,this,false);
      canAttemptRecovery=false;
    }
  }
  for (int i=0; i < names.length; i++) {
    ImageDecoder dec=ImageCodec.createImageDecoder(names[i],src,param);
    RenderedImage im=null;
    try {
      im=dec.decodeAsRenderedImage();
    }
 catch (    OutOfMemoryError memoryError) {
      if (canAttemptRecovery) {
        TileCache cache=RIFUtil.getTileCacheHint(renderHints);
        if (cache != null) {
          cache.flush();
        }
        System.gc();
        try {
          src.seek(streamPosition);
          im=dec.decodeAsRenderedImage();
        }
 catch (        IOException ioe) {
          listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),ioe,this,false);
          im=null;
        }
      }
 else {
        String message=JaiI18N.getString(""String_Node_Str"");
        listener.errorOccurred(message,new ImagingException(message,memoryError),this,false);
      }
    }
catch (    IOException e) {
      listener.errorOccurred(JaiI18N.getString(""String_Node_Str""),e,this,false);
      im=null;
    }
    if (im != null) {
      return new DisposableNullOpImage(im,layout,renderHints,bound);
    }
  }
  return null;
}",0.9982870846180198
154014,"/** 
 * Implementation of <code>PropertyChangeListener</code>. <p> When invoked with an event which is an instance of either <code>CollectionChangeEvent</code> or <code>RenderingChangeEvent</code> emitted by a <code>CollectionOp</code> or <code>RenderedOp</code> source, respectively, the node will respond by re-rendering itself while retaining any data possible.
 * @since JAI 1.1
 */
public synchronized void propertyChange(PropertyChangeEvent evt){
  if (isRenderable())   return;
  Object evtSrc=evt.getSource();
  Vector nodeSources=nodeSupport.getParameterBlock().getSources();
  String propName=evt.getPropertyName().toLowerCase();
  if (imageCollection != null && ((evt instanceof PropertyChangeEventJAI && evtSrc == this && !(evt instanceof PropertySourceChangeEvent) && nodeEventNames.contains(propName)) || ((evt instanceof CollectionChangeEvent || evt instanceof RenderingChangeEvent) && nodeSources.contains(evtSrc)))) {
    Collection theOldCollection=imageCollection;
    boolean fireEvent=false;
    if (!(imageCollection instanceof CollectionImage)) {
      fireEvent=true;
      imageCollection=null;
    }
 else     if (evtSrc == this && (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str""))) {
      fireEvent=true;
      imageCollection=null;
    }
 else     if (evt instanceof CollectionChangeEvent) {
      fireEvent=true;
      CollectionImageFactory oldCIF=((CollectionImage)theOldCollection).getImageFactory();
      if (oldCIF == null) {
        imageCollection=null;
      }
 else {
        CollectionChangeEvent ccEvent=(CollectionChangeEvent)evt;
        Vector parameters=nodeSupport.getParameterBlock().getParameters();
        parameters=ImageUtil.evaluateParameters(parameters);
        ParameterBlock oldPB=new ParameterBlock((Vector)nodeSources.clone(),parameters);
        ParameterBlock newPB=new ParameterBlock((Vector)nodeSources.clone(),parameters);
        int sourceIndex=nodeSources.indexOf(ccEvent.getSource());
        oldPB.setSource(ccEvent.getOldValue(),sourceIndex);
        newPB.setSource(ccEvent.getNewValue(),sourceIndex);
        imageCollection=oldCIF.update(oldPB,oldHints,newPB,oldHints,(CollectionImage)theOldCollection,this);
      }
    }
 else {
      CollectionImageFactory oldCIF=((CollectionImage)theOldCollection).getImageFactory();
      if (oldCIF == null || oldCIF != CIFRegistry.get(nodeSupport.getRegistry(),nodeSupport.getOperationName())) {
        imageCollection=null;
        fireEvent=true;
      }
 else {
        ParameterBlock oldPB=null;
        ParameterBlock newPB=null;
        boolean updateCollection=false;
        if (propName.equals(""String_Node_Str"")) {
          oldPB=(ParameterBlock)evt.getOldValue();
          newPB=(ParameterBlock)evt.getNewValue();
          updateCollection=true;
        }
 else         if (propName.equals(""String_Node_Str"")) {
          Vector params=nodeSupport.getParameterBlock().getParameters();
          oldPB=new ParameterBlock((Vector)evt.getOldValue(),params);
          newPB=new ParameterBlock((Vector)evt.getNewValue(),params);
          updateCollection=true;
        }
 else         if (propName.equals(""String_Node_Str"")) {
          oldPB=new ParameterBlock(nodeSources,(Vector)evt.getOldValue());
          newPB=new ParameterBlock(nodeSources,(Vector)evt.getNewValue());
          updateCollection=true;
        }
 else         if (propName.equals(""String_Node_Str"")) {
          oldPB=newPB=nodeSupport.getParameterBlock();
          updateCollection=true;
        }
 else         if (evt instanceof RenderingChangeEvent) {
          int renderingIndex=nodeSources.indexOf(evt.getSource());
          Vector oldSources=(Vector)nodeSources.clone();
          Vector newSources=(Vector)nodeSources.clone();
          oldSources.set(renderingIndex,evt.getOldValue());
          newSources.set(renderingIndex,evt.getNewValue());
          Vector params=nodeSupport.getParameterBlock().getParameters();
          oldPB=new ParameterBlock(oldSources,params);
          newPB=new ParameterBlock(newSources,params);
          updateCollection=true;
        }
        if (updateCollection) {
          fireEvent=true;
          oldPB=ImageUtil.evaluateParameters(oldPB);
          newPB=ImageUtil.evaluateParameters(newPB);
          RenderingHints newHints=nodeSupport.getRenderingHints();
          if ((imageCollection=oldCIF.update(oldPB,oldHints,newPB,newHints,(CollectionImage)theOldCollection,this)) != null) {
            oldHints=newHints;
          }
        }
      }
    }
    getCollection();
    if (fireEvent) {
      resetProperties(true);
      CollectionChangeEvent ccEvent=new CollectionChangeEvent(this,theOldCollection,imageCollection);
      eventManager.firePropertyChange(ccEvent);
      Set sinks=getSinks();
      if (sinks != null) {
        Iterator it=sinks.iterator();
        while (it.hasNext()) {
          Object sink=it.next();
          if (sink instanceof PropertyChangeListener) {
            ((PropertyChangeListener)sink).propertyChange(ccEvent);
          }
        }
      }
    }
  }
}","/** 
 * Implementation of <code>PropertyChangeListener</code>. <p> When invoked with an event which is an instance of either <code>CollectionChangeEvent</code> or <code>RenderingChangeEvent</code> emitted by a <code>CollectionOp</code> or <code>RenderedOp</code> source, respectively, the node will respond by re-rendering itself while retaining any data possible.
 * @since JAI 1.1
 */
public synchronized void propertyChange(PropertyChangeEvent evt){
  if (isRenderable())   return;
  Object evtSrc=evt.getSource();
  Vector nodeSources=nodeSupport.getParameterBlock().getSources();
  String propName=evt.getPropertyName().toLowerCase(Locale.ENGLISH);
  if (imageCollection != null && ((evt instanceof PropertyChangeEventJAI && evtSrc == this && !(evt instanceof PropertySourceChangeEvent) && nodeEventNames.contains(propName)) || ((evt instanceof CollectionChangeEvent || evt instanceof RenderingChangeEvent) && nodeSources.contains(evtSrc)))) {
    Collection theOldCollection=imageCollection;
    boolean fireEvent=false;
    if (!(imageCollection instanceof CollectionImage)) {
      fireEvent=true;
      imageCollection=null;
    }
 else     if (evtSrc == this && (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str""))) {
      fireEvent=true;
      imageCollection=null;
    }
 else     if (evt instanceof CollectionChangeEvent) {
      fireEvent=true;
      CollectionImageFactory oldCIF=((CollectionImage)theOldCollection).getImageFactory();
      if (oldCIF == null) {
        imageCollection=null;
      }
 else {
        CollectionChangeEvent ccEvent=(CollectionChangeEvent)evt;
        Vector parameters=nodeSupport.getParameterBlock().getParameters();
        parameters=ImageUtil.evaluateParameters(parameters);
        ParameterBlock oldPB=new ParameterBlock((Vector)nodeSources.clone(),parameters);
        ParameterBlock newPB=new ParameterBlock((Vector)nodeSources.clone(),parameters);
        int sourceIndex=nodeSources.indexOf(ccEvent.getSource());
        oldPB.setSource(ccEvent.getOldValue(),sourceIndex);
        newPB.setSource(ccEvent.getNewValue(),sourceIndex);
        imageCollection=oldCIF.update(oldPB,oldHints,newPB,oldHints,(CollectionImage)theOldCollection,this);
      }
    }
 else {
      CollectionImageFactory oldCIF=((CollectionImage)theOldCollection).getImageFactory();
      if (oldCIF == null || oldCIF != CIFRegistry.get(nodeSupport.getRegistry(),nodeSupport.getOperationName())) {
        imageCollection=null;
        fireEvent=true;
      }
 else {
        ParameterBlock oldPB=null;
        ParameterBlock newPB=null;
        boolean updateCollection=false;
        if (propName.equals(""String_Node_Str"")) {
          oldPB=(ParameterBlock)evt.getOldValue();
          newPB=(ParameterBlock)evt.getNewValue();
          updateCollection=true;
        }
 else         if (propName.equals(""String_Node_Str"")) {
          Vector params=nodeSupport.getParameterBlock().getParameters();
          oldPB=new ParameterBlock((Vector)evt.getOldValue(),params);
          newPB=new ParameterBlock((Vector)evt.getNewValue(),params);
          updateCollection=true;
        }
 else         if (propName.equals(""String_Node_Str"")) {
          oldPB=new ParameterBlock(nodeSources,(Vector)evt.getOldValue());
          newPB=new ParameterBlock(nodeSources,(Vector)evt.getNewValue());
          updateCollection=true;
        }
 else         if (propName.equals(""String_Node_Str"")) {
          oldPB=newPB=nodeSupport.getParameterBlock();
          updateCollection=true;
        }
 else         if (evt instanceof RenderingChangeEvent) {
          int renderingIndex=nodeSources.indexOf(evt.getSource());
          Vector oldSources=(Vector)nodeSources.clone();
          Vector newSources=(Vector)nodeSources.clone();
          oldSources.set(renderingIndex,evt.getOldValue());
          newSources.set(renderingIndex,evt.getNewValue());
          Vector params=nodeSupport.getParameterBlock().getParameters();
          oldPB=new ParameterBlock(oldSources,params);
          newPB=new ParameterBlock(newSources,params);
          updateCollection=true;
        }
        if (updateCollection) {
          fireEvent=true;
          oldPB=ImageUtil.evaluateParameters(oldPB);
          newPB=ImageUtil.evaluateParameters(newPB);
          RenderingHints newHints=nodeSupport.getRenderingHints();
          if ((imageCollection=oldCIF.update(oldPB,oldHints,newPB,newHints,(CollectionImage)theOldCollection,this)) != null) {
            oldHints=newHints;
          }
        }
      }
    }
    getCollection();
    if (fireEvent) {
      resetProperties(true);
      CollectionChangeEvent ccEvent=new CollectionChangeEvent(this,theOldCollection,imageCollection);
      eventManager.firePropertyChange(ccEvent);
      Set sinks=getSinks();
      if (sinks != null) {
        Iterator it=sinks.iterator();
        while (it.hasNext()) {
          Object sink=it.next();
          if (sink instanceof PropertyChangeListener) {
            ((PropertyChangeListener)sink).propertyChange(ccEvent);
          }
        }
      }
    }
  }
}",0.9986234021632252
154015,"/** 
 * Implementation of <code>PropertyChangeListener</code>. <p> When invoked with an event which is an instance of <code>RenderingChangeEvent</code> or <code>CollectionChangeEvent</code> emitted by a <code>RenderedOp</code> or <code>CollectionOp</code>, respectively, the node will respond by re-rendering itself while retaining any tiles possible.  It will respond to an ""InvalidRegion"" event emitted by a source <code>RenderedImage</code> in a manner similar to that applied for <code>RenderingChangeEvent</code>s.
 * @see TiledImage#propertyChange
 * @since JAI 1.1
 */
public synchronized void propertyChange(PropertyChangeEvent evt){
  Object evtSrc=evt.getSource();
  Vector nodeSources=nodeSupport.getParameterBlock().getSources();
  String propName=evt.getPropertyName().toLowerCase();
  if (theImage != null && ((evt instanceof PropertyChangeEventJAI && evtSrc == this && !(evt instanceof PropertySourceChangeEvent) && nodeEventNames.contains(propName)) || ((evt instanceof RenderingChangeEvent || evt instanceof CollectionChangeEvent || (evt instanceof PropertyChangeEventJAI && evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) && nodeSources.contains(evtSrc)))) {
    PlanarImage theOldImage=theImage;
    boolean fireEvent=false;
    Shape invalidRegion=null;
    if (evtSrc == this && (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str""))) {
      fireEvent=true;
      theImage=null;
    }
 else     if (evt instanceof RenderingChangeEvent || (evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) {
      fireEvent=true;
      Shape srcInvalidRegion=null;
      if (evt instanceof RenderingChangeEvent) {
        RenderingChangeEvent rcEvent=(RenderingChangeEvent)evt;
        srcInvalidRegion=rcEvent.getInvalidRegion();
        if (srcInvalidRegion == null) {
          srcInvalidRegion=((PlanarImage)rcEvent.getOldValue()).getBounds();
        }
      }
 else {
        srcInvalidRegion=(Shape)evt.getNewValue();
        if (srcInvalidRegion == null) {
          RenderedImage rSrc=(RenderedImage)evtSrc;
          srcInvalidRegion=new Rectangle(rSrc.getMinX(),rSrc.getMinY(),rSrc.getWidth(),rSrc.getHeight());
        }
      }
      if (!(theImage instanceof OpImage)) {
        theImage=null;
      }
 else {
        OpImage oldOpImage=(OpImage)theImage;
        Rectangle srcInvalidBounds=srcInvalidRegion.getBounds();
        if (srcInvalidBounds.isEmpty()) {
          int x=oldOpImage.tileXToX(oldOpImage.getMinTileX());
          int y=oldOpImage.tileYToY(oldOpImage.getMinTileY());
          int w=oldOpImage.getNumXTiles() * oldOpImage.getTileWidth();
          int h=oldOpImage.getNumYTiles() * oldOpImage.getTileHeight();
          Rectangle tileBounds=new Rectangle(x,y,w,h);
          Rectangle imageBounds=oldOpImage.getBounds();
          if (!tileBounds.equals(imageBounds)) {
            Area tmpArea=new Area(tileBounds);
            tmpArea.subtract(new Area(imageBounds));
            srcInvalidRegion=tmpArea;
            srcInvalidBounds=srcInvalidRegion.getBounds();
          }
        }
        boolean saveAllTiles=false;
        ArrayList validTiles=null;
        if (srcInvalidBounds.isEmpty()) {
          invalidRegion=srcInvalidRegion;
          saveAllTiles=true;
        }
 else {
          int idx=nodeSources.indexOf(evtSrc);
          Rectangle dstRegionBounds=oldOpImage.mapSourceRect(srcInvalidBounds,idx);
          if (dstRegionBounds == null) {
            dstRegionBounds=oldOpImage.getBounds();
          }
          Point[] indices=getTileIndices(dstRegionBounds);
          int numIndices=indices != null ? indices.length : 0;
          GeneralPath gp=null;
          for (int i=0; i < numIndices; i++) {
            if (i % 1000 == 0 && gp != null)             gp=new GeneralPath(new Area(gp));
            Rectangle dstRect=getTileRect(indices[i].x,indices[i].y);
            Rectangle srcRect=oldOpImage.mapDestRect(dstRect,idx);
            if (srcRect == null) {
              gp=null;
              break;
            }
            if (srcInvalidRegion.intersects(srcRect)) {
              if (gp == null) {
                gp=new GeneralPath(dstRect);
              }
 else {
                gp.append(dstRect,false);
              }
            }
 else {
              if (validTiles == null) {
                validTiles=new ArrayList();
              }
              validTiles.add(indices[i]);
            }
          }
          invalidRegion=(gp == null) ? null : new Area(gp);
        }
        theImage=null;
        TileCache oldCache=oldOpImage.getTileCache();
        if (oldCache != null && (saveAllTiles || validTiles != null)) {
          createRendering();
          if (theImage instanceof OpImage && ((OpImage)theImage).getTileCache() != null) {
            OpImage newOpImage=(OpImage)theImage;
            TileCache newCache=newOpImage.getTileCache();
            Object tileCacheMetric=newOpImage.getTileCacheMetric();
            if (saveAllTiles) {
              Raster[] tiles=oldCache.getTiles(oldOpImage);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newOpImage.XToTileX(tile.getMinX());
                int ty=newOpImage.YToTileY(tile.getMinY());
                newCache.add(newOpImage,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              int numValidTiles=validTiles.size();
              for (int i=0; i < numValidTiles; i++) {
                Point tileIndex=(Point)validTiles.get(i);
                Raster tile=oldCache.getTile(oldOpImage,tileIndex.x,tileIndex.y);
                if (tile != null) {
                  newCache.add(newOpImage,tileIndex.x,tileIndex.y,tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
 else {
      ParameterBlock oldPB=null;
      ParameterBlock newPB=null;
      boolean checkInvalidRegion=false;
      if (propName.equals(""String_Node_Str"")) {
        oldPB=(ParameterBlock)evt.getOldValue();
        newPB=(ParameterBlock)evt.getNewValue();
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock((Vector)evt.getOldValue(),params);
        newPB=new ParameterBlock((Vector)evt.getNewValue(),params);
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=new ParameterBlock(nodeSources,(Vector)evt.getOldValue());
        newPB=new ParameterBlock(nodeSources,(Vector)evt.getNewValue());
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=newPB=nodeSupport.getParameterBlock();
        checkInvalidRegion=true;
      }
 else       if (evt instanceof CollectionChangeEvent) {
        int collectionIndex=nodeSources.indexOf(evtSrc);
        Vector oldSources=(Vector)nodeSources.clone();
        Vector newSources=(Vector)nodeSources.clone();
        oldSources.set(collectionIndex,evt.getOldValue());
        newSources.set(collectionIndex,evt.getNewValue());
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock(oldSources,params);
        newPB=new ParameterBlock(newSources,params);
        checkInvalidRegion=true;
      }
      if (checkInvalidRegion) {
        fireEvent=true;
        OperationRegistry registry=nodeSupport.getRegistry();
        OperationDescriptor odesc=(OperationDescriptor)registry.getDescriptor(OperationDescriptor.class,nodeSupport.getOperationName());
        oldPB=ImageUtil.evaluateParameters(oldPB);
        newPB=ImageUtil.evaluateParameters(newPB);
        invalidRegion=(Shape)odesc.getInvalidRegion(RenderedRegistryMode.MODE_NAME,oldPB,oldHints,newPB,nodeSupport.getRenderingHints(),this);
        if (invalidRegion == null || !(theImage instanceof OpImage)) {
          theImage=null;
        }
 else {
          OpImage oldRendering=(OpImage)theImage;
          theImage=null;
          createRendering();
          if (theImage instanceof OpImage && oldRendering.getTileCache() != null && ((OpImage)theImage).getTileCache() != null) {
            OpImage newRendering=(OpImage)theImage;
            TileCache oldCache=oldRendering.getTileCache();
            TileCache newCache=newRendering.getTileCache();
            Object tileCacheMetric=newRendering.getTileCacheMetric();
            if (invalidRegion.getBounds().isEmpty()) {
              int x=oldRendering.tileXToX(oldRendering.getMinTileX());
              int y=oldRendering.tileYToY(oldRendering.getMinTileY());
              int w=oldRendering.getNumXTiles() * oldRendering.getTileWidth();
              int h=oldRendering.getNumYTiles() * oldRendering.getTileHeight();
              Rectangle tileBounds=new Rectangle(x,y,w,h);
              Rectangle imageBounds=oldRendering.getBounds();
              if (!tileBounds.equals(imageBounds)) {
                Area tmpArea=new Area(tileBounds);
                tmpArea.subtract(new Area(imageBounds));
                invalidRegion=tmpArea;
              }
            }
            if (invalidRegion.getBounds().isEmpty()) {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newRendering.XToTileX(tile.getMinX());
                int ty=newRendering.YToTileY(tile.getMinY());
                newCache.add(newRendering,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                Rectangle bounds=tile.getBounds();
                if (!invalidRegion.intersects(bounds)) {
                  newCache.add(newRendering,newRendering.XToTileX(bounds.x),newRendering.YToTileY(bounds.y),tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
    createRendering();
    if (fireEvent) {
      resetProperties(true);
      RenderingChangeEvent rcEvent=new RenderingChangeEvent(this,theOldImage,theImage,invalidRegion);
      eventManager.firePropertyChange(rcEvent);
      Vector sinks=getSinks();
      if (sinks != null) {
        int numSinks=sinks.size();
        for (int i=0; i < numSinks; i++) {
          Object sink=sinks.get(i);
          if (sink instanceof PropertyChangeListener) {
            ((PropertyChangeListener)sink).propertyChange(rcEvent);
          }
        }
      }
    }
  }
}","/** 
 * Implementation of <code>PropertyChangeListener</code>. <p> When invoked with an event which is an instance of <code>RenderingChangeEvent</code> or <code>CollectionChangeEvent</code> emitted by a <code>RenderedOp</code> or <code>CollectionOp</code>, respectively, the node will respond by re-rendering itself while retaining any tiles possible.  It will respond to an ""InvalidRegion"" event emitted by a source <code>RenderedImage</code> in a manner similar to that applied for <code>RenderingChangeEvent</code>s.
 * @see TiledImage#propertyChange
 * @since JAI 1.1
 */
public synchronized void propertyChange(PropertyChangeEvent evt){
  Object evtSrc=evt.getSource();
  Vector nodeSources=nodeSupport.getParameterBlock().getSources();
  String propName=evt.getPropertyName().toLowerCase(Locale.ENGLISH);
  if (theImage != null && ((evt instanceof PropertyChangeEventJAI && evtSrc == this && !(evt instanceof PropertySourceChangeEvent) && nodeEventNames.contains(propName)) || ((evt instanceof RenderingChangeEvent || evt instanceof CollectionChangeEvent || (evt instanceof PropertyChangeEventJAI && evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) && nodeSources.contains(evtSrc)))) {
    PlanarImage theOldImage=theImage;
    boolean fireEvent=false;
    Shape invalidRegion=null;
    if (evtSrc == this && (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str""))) {
      fireEvent=true;
      theImage=null;
    }
 else     if (evt instanceof RenderingChangeEvent || (evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) {
      fireEvent=true;
      Shape srcInvalidRegion=null;
      if (evt instanceof RenderingChangeEvent) {
        RenderingChangeEvent rcEvent=(RenderingChangeEvent)evt;
        srcInvalidRegion=rcEvent.getInvalidRegion();
        if (srcInvalidRegion == null) {
          srcInvalidRegion=((PlanarImage)rcEvent.getOldValue()).getBounds();
        }
      }
 else {
        srcInvalidRegion=(Shape)evt.getNewValue();
        if (srcInvalidRegion == null) {
          RenderedImage rSrc=(RenderedImage)evtSrc;
          srcInvalidRegion=new Rectangle(rSrc.getMinX(),rSrc.getMinY(),rSrc.getWidth(),rSrc.getHeight());
        }
      }
      if (!(theImage instanceof OpImage)) {
        theImage=null;
      }
 else {
        OpImage oldOpImage=(OpImage)theImage;
        Rectangle srcInvalidBounds=srcInvalidRegion.getBounds();
        if (srcInvalidBounds.isEmpty()) {
          int x=oldOpImage.tileXToX(oldOpImage.getMinTileX());
          int y=oldOpImage.tileYToY(oldOpImage.getMinTileY());
          int w=oldOpImage.getNumXTiles() * oldOpImage.getTileWidth();
          int h=oldOpImage.getNumYTiles() * oldOpImage.getTileHeight();
          Rectangle tileBounds=new Rectangle(x,y,w,h);
          Rectangle imageBounds=oldOpImage.getBounds();
          if (!tileBounds.equals(imageBounds)) {
            Area tmpArea=new Area(tileBounds);
            tmpArea.subtract(new Area(imageBounds));
            srcInvalidRegion=tmpArea;
            srcInvalidBounds=srcInvalidRegion.getBounds();
          }
        }
        boolean saveAllTiles=false;
        ArrayList validTiles=null;
        if (srcInvalidBounds.isEmpty()) {
          invalidRegion=srcInvalidRegion;
          saveAllTiles=true;
        }
 else {
          int idx=nodeSources.indexOf(evtSrc);
          Rectangle dstRegionBounds=oldOpImage.mapSourceRect(srcInvalidBounds,idx);
          if (dstRegionBounds == null) {
            dstRegionBounds=oldOpImage.getBounds();
          }
          Point[] indices=getTileIndices(dstRegionBounds);
          int numIndices=indices != null ? indices.length : 0;
          GeneralPath gp=null;
          for (int i=0; i < numIndices; i++) {
            if (i % 1000 == 0 && gp != null)             gp=new GeneralPath(new Area(gp));
            Rectangle dstRect=getTileRect(indices[i].x,indices[i].y);
            Rectangle srcRect=oldOpImage.mapDestRect(dstRect,idx);
            if (srcRect == null) {
              gp=null;
              break;
            }
            if (srcInvalidRegion.intersects(srcRect)) {
              if (gp == null) {
                gp=new GeneralPath(dstRect);
              }
 else {
                gp.append(dstRect,false);
              }
            }
 else {
              if (validTiles == null) {
                validTiles=new ArrayList();
              }
              validTiles.add(indices[i]);
            }
          }
          invalidRegion=(gp == null) ? null : new Area(gp);
        }
        theImage=null;
        TileCache oldCache=oldOpImage.getTileCache();
        if (oldCache != null && (saveAllTiles || validTiles != null)) {
          createRendering();
          if (theImage instanceof OpImage && ((OpImage)theImage).getTileCache() != null) {
            OpImage newOpImage=(OpImage)theImage;
            TileCache newCache=newOpImage.getTileCache();
            Object tileCacheMetric=newOpImage.getTileCacheMetric();
            if (saveAllTiles) {
              Raster[] tiles=oldCache.getTiles(oldOpImage);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newOpImage.XToTileX(tile.getMinX());
                int ty=newOpImage.YToTileY(tile.getMinY());
                newCache.add(newOpImage,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              int numValidTiles=validTiles.size();
              for (int i=0; i < numValidTiles; i++) {
                Point tileIndex=(Point)validTiles.get(i);
                Raster tile=oldCache.getTile(oldOpImage,tileIndex.x,tileIndex.y);
                if (tile != null) {
                  newCache.add(newOpImage,tileIndex.x,tileIndex.y,tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
 else {
      ParameterBlock oldPB=null;
      ParameterBlock newPB=null;
      boolean checkInvalidRegion=false;
      if (propName.equals(""String_Node_Str"")) {
        oldPB=(ParameterBlock)evt.getOldValue();
        newPB=(ParameterBlock)evt.getNewValue();
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock((Vector)evt.getOldValue(),params);
        newPB=new ParameterBlock((Vector)evt.getNewValue(),params);
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=new ParameterBlock(nodeSources,(Vector)evt.getOldValue());
        newPB=new ParameterBlock(nodeSources,(Vector)evt.getNewValue());
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=newPB=nodeSupport.getParameterBlock();
        checkInvalidRegion=true;
      }
 else       if (evt instanceof CollectionChangeEvent) {
        int collectionIndex=nodeSources.indexOf(evtSrc);
        Vector oldSources=(Vector)nodeSources.clone();
        Vector newSources=(Vector)nodeSources.clone();
        oldSources.set(collectionIndex,evt.getOldValue());
        newSources.set(collectionIndex,evt.getNewValue());
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock(oldSources,params);
        newPB=new ParameterBlock(newSources,params);
        checkInvalidRegion=true;
      }
      if (checkInvalidRegion) {
        fireEvent=true;
        OperationRegistry registry=nodeSupport.getRegistry();
        OperationDescriptor odesc=(OperationDescriptor)registry.getDescriptor(OperationDescriptor.class,nodeSupport.getOperationName());
        oldPB=ImageUtil.evaluateParameters(oldPB);
        newPB=ImageUtil.evaluateParameters(newPB);
        invalidRegion=(Shape)odesc.getInvalidRegion(RenderedRegistryMode.MODE_NAME,oldPB,oldHints,newPB,nodeSupport.getRenderingHints(),this);
        if (invalidRegion == null || !(theImage instanceof OpImage)) {
          theImage=null;
        }
 else {
          OpImage oldRendering=(OpImage)theImage;
          theImage=null;
          createRendering();
          if (theImage instanceof OpImage && oldRendering.getTileCache() != null && ((OpImage)theImage).getTileCache() != null) {
            OpImage newRendering=(OpImage)theImage;
            TileCache oldCache=oldRendering.getTileCache();
            TileCache newCache=newRendering.getTileCache();
            Object tileCacheMetric=newRendering.getTileCacheMetric();
            if (invalidRegion.getBounds().isEmpty()) {
              int x=oldRendering.tileXToX(oldRendering.getMinTileX());
              int y=oldRendering.tileYToY(oldRendering.getMinTileY());
              int w=oldRendering.getNumXTiles() * oldRendering.getTileWidth();
              int h=oldRendering.getNumYTiles() * oldRendering.getTileHeight();
              Rectangle tileBounds=new Rectangle(x,y,w,h);
              Rectangle imageBounds=oldRendering.getBounds();
              if (!tileBounds.equals(imageBounds)) {
                Area tmpArea=new Area(tileBounds);
                tmpArea.subtract(new Area(imageBounds));
                invalidRegion=tmpArea;
              }
            }
            if (invalidRegion.getBounds().isEmpty()) {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newRendering.XToTileX(tile.getMinX());
                int ty=newRendering.YToTileY(tile.getMinY());
                newCache.add(newRendering,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                Rectangle bounds=tile.getBounds();
                if (!invalidRegion.intersects(bounds)) {
                  newCache.add(newRendering,newRendering.XToTileX(bounds.x),newRendering.YToTileY(bounds.y),tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
    createRendering();
    if (fireEvent) {
      resetProperties(true);
      RenderingChangeEvent rcEvent=new RenderingChangeEvent(this,theOldImage,theImage,invalidRegion);
      eventManager.firePropertyChange(rcEvent);
      Vector sinks=getSinks();
      if (sinks != null) {
        int numSinks=sinks.size();
        for (int i=0; i < numSinks; i++) {
          Object sink=sinks.get(i);
          if (sink instanceof PropertyChangeListener) {
            ((PropertyChangeListener)sink).propertyChange(rcEvent);
          }
        }
      }
    }
  }
}",0.9993543626637152
154016,"/** 
 * Implementation of <code>PropertyChangeListener</code>. <p> When invoked with an event which is an instance of <code>RenderingChangeEvent</code> the node will respond by re-rendering itself while retaining any tiles possible.
 */
public synchronized void propertyChange(PropertyChangeEvent evt){
  Object evtSrc=evt.getSource();
  Vector nodeSources=nodeSupport.getParameterBlock().getSources();
  String propName=evt.getPropertyName().toLowerCase();
  if (theImage != null && ((evt instanceof PropertyChangeEventJAI && evtSrc == this && !(evt instanceof PropertySourceChangeEvent) && nodeEventNames.contains(propName)) || ((evt instanceof RenderingChangeEvent || evt instanceof CollectionChangeEvent || (evt instanceof PropertyChangeEventJAI && evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) && nodeSources.contains(evtSrc)))) {
    PlanarImage theOldImage=theImage;
    boolean shouldFireEvent=false;
    Shape invalidRegion=null;
    if (evtSrc == this && (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str""))) {
      shouldFireEvent=true;
      theImage=null;
    }
 else     if (evt instanceof RenderingChangeEvent || (evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) {
      shouldFireEvent=true;
      Shape srcInvalidRegion=null;
      if (evt instanceof RenderingChangeEvent) {
        RenderingChangeEvent rcEvent=(RenderingChangeEvent)evt;
        srcInvalidRegion=rcEvent.getInvalidRegion();
        if (srcInvalidRegion == null) {
          srcInvalidRegion=((PlanarImage)rcEvent.getOldValue()).getBounds();
        }
      }
 else {
        srcInvalidRegion=(Shape)evt.getNewValue();
        if (srcInvalidRegion == null) {
          RenderedImage rSrc=(RenderedImage)evtSrc;
          srcInvalidRegion=new Rectangle(rSrc.getMinX(),rSrc.getMinY(),rSrc.getWidth(),rSrc.getHeight());
        }
      }
      if (!(theImage instanceof PlanarImageServerProxy)) {
        theImage=null;
      }
 else {
        PlanarImageServerProxy oldPISP=(PlanarImageServerProxy)theImage;
        Rectangle srcInvalidBounds=srcInvalidRegion.getBounds();
        if (srcInvalidBounds.isEmpty()) {
          int x=oldPISP.tileXToX(oldPISP.getMinTileX());
          int y=oldPISP.tileYToY(oldPISP.getMinTileY());
          int w=oldPISP.getNumXTiles() * oldPISP.getTileWidth();
          int h=oldPISP.getNumYTiles() * oldPISP.getTileHeight();
          Rectangle tileBounds=new Rectangle(x,y,w,h);
          Rectangle imageBounds=oldPISP.getBounds();
          if (!tileBounds.equals(imageBounds)) {
            Area tmpArea=new Area(tileBounds);
            tmpArea.subtract(new Area(imageBounds));
            srcInvalidRegion=tmpArea;
            srcInvalidBounds=srcInvalidRegion.getBounds();
          }
        }
        boolean saveAllTiles=false;
        ArrayList validTiles=null;
        if (srcInvalidBounds.isEmpty()) {
          invalidRegion=srcInvalidRegion;
          saveAllTiles=true;
        }
 else {
          int idx=nodeSources.indexOf(evtSrc);
          Rectangle dstRegionBounds=oldPISP.mapSourceRect(srcInvalidBounds,idx);
          if (dstRegionBounds == null) {
            dstRegionBounds=oldPISP.getBounds();
          }
          Point[] indices=getTileIndices(dstRegionBounds);
          int numIndices=indices != null ? indices.length : 0;
          GeneralPath gp=null;
          for (int i=0; i < numIndices; i++) {
            if (i % 1000 == 0 && gp != null)             gp=new GeneralPath(new Area(gp));
            Rectangle dstRect=getTileRect(indices[i].x,indices[i].y);
            Rectangle srcRect=oldPISP.mapDestRect(dstRect,idx);
            if (srcRect == null) {
              gp=null;
              break;
            }
            if (srcInvalidRegion.intersects(srcRect)) {
              if (gp == null) {
                gp=new GeneralPath(dstRect);
              }
 else {
                gp.append(dstRect,false);
              }
            }
 else {
              if (validTiles == null) {
                validTiles=new ArrayList();
              }
              validTiles.add(indices[i]);
            }
          }
          invalidRegion=(gp == null) ? null : new Area(gp);
        }
        TileCache oldCache=oldPISP.getTileCache();
        theImage=null;
        if (oldCache != null && (saveAllTiles || validTiles != null)) {
          newEventRendering(protocolName,oldPISP,(PropertyChangeEventJAI)evt);
          if (theImage instanceof PlanarImageServerProxy && ((PlanarImageServerProxy)theImage).getTileCache() != null) {
            PlanarImageServerProxy newPISP=(PlanarImageServerProxy)theImage;
            TileCache newCache=newPISP.getTileCache();
            Object tileCacheMetric=newPISP.getTileCacheMetric();
            if (saveAllTiles) {
              Raster[] tiles=oldCache.getTiles(oldPISP);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newPISP.XToTileX(tile.getMinX());
                int ty=newPISP.YToTileY(tile.getMinY());
                newCache.add(newPISP,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              int numValidTiles=validTiles.size();
              for (int i=0; i < numValidTiles; i++) {
                Point tileIndex=(Point)validTiles.get(i);
                Raster tile=oldCache.getTile(oldPISP,tileIndex.x,tileIndex.y);
                if (tile != null) {
                  newCache.add(newPISP,tileIndex.x,tileIndex.y,tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
 else {
      ParameterBlock oldPB=null;
      ParameterBlock newPB=null;
      String oldServerName=serverName;
      String newServerName=serverName;
      boolean checkInvalidRegion=false;
      if (propName.equals(""String_Node_Str"")) {
        if (theImage instanceof PlanarImageServerProxy) {
          newEventRendering(protocolName,(PlanarImageServerProxy)theImage,(PropertyChangeEventJAI)evt);
        }
 else {
          theImage=null;
          createRendering();
        }
        shouldFireEvent=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=(ParameterBlock)evt.getOldValue();
        newPB=(ParameterBlock)evt.getNewValue();
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock((Vector)evt.getOldValue(),params);
        newPB=new ParameterBlock((Vector)evt.getNewValue(),params);
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=new ParameterBlock(nodeSources,(Vector)evt.getOldValue());
        newPB=new ParameterBlock(nodeSources,(Vector)evt.getNewValue());
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=newPB=nodeSupport.getParameterBlock();
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=newPB=nodeSupport.getParameterBlock();
        oldServerName=(String)evt.getOldValue();
        newServerName=(String)evt.getNewValue();
        checkInvalidRegion=true;
      }
 else       if (evt instanceof CollectionChangeEvent) {
        int collectionIndex=nodeSources.indexOf(evtSrc);
        Vector oldSources=(Vector)nodeSources.clone();
        Vector newSources=(Vector)nodeSources.clone();
        oldSources.set(collectionIndex,evt.getOldValue());
        newSources.set(collectionIndex,evt.getNewValue());
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock(oldSources,params);
        newPB=new ParameterBlock(newSources,params);
        checkInvalidRegion=true;
      }
      if (checkInvalidRegion) {
        shouldFireEvent=true;
        OperationRegistry registry=nodeSupport.getRegistry();
        RemoteDescriptor odesc=(RemoteDescriptor)registry.getDescriptor(RemoteDescriptor.class,protocolName);
        oldPB=ImageUtil.evaluateParameters(oldPB);
        newPB=ImageUtil.evaluateParameters(newPB);
        invalidRegion=(Shape)odesc.getInvalidRegion(""String_Node_Str"",oldServerName,oldPB,oldHints,newServerName,newPB,nodeSupport.getRenderingHints(),this);
        if (invalidRegion == null || !(theImage instanceof PlanarImageServerProxy)) {
          theImage=null;
        }
 else {
          PlanarImageServerProxy oldRendering=(PlanarImageServerProxy)theImage;
          newEventRendering(protocolName,oldRendering,(PropertyChangeEventJAI)evt);
          if (theImage instanceof PlanarImageServerProxy && oldRendering.getTileCache() != null && ((PlanarImageServerProxy)theImage).getTileCache() != null) {
            PlanarImageServerProxy newRendering=(PlanarImageServerProxy)theImage;
            TileCache oldCache=oldRendering.getTileCache();
            TileCache newCache=newRendering.getTileCache();
            Object tileCacheMetric=newRendering.getTileCacheMetric();
            if (invalidRegion.getBounds().isEmpty()) {
              int x=oldRendering.tileXToX(oldRendering.getMinTileX());
              int y=oldRendering.tileYToY(oldRendering.getMinTileY());
              int w=oldRendering.getNumXTiles() * oldRendering.getTileWidth();
              int h=oldRendering.getNumYTiles() * oldRendering.getTileHeight();
              Rectangle tileBounds=new Rectangle(x,y,w,h);
              Rectangle imageBounds=oldRendering.getBounds();
              if (!tileBounds.equals(imageBounds)) {
                Area tmpArea=new Area(tileBounds);
                tmpArea.subtract(new Area(imageBounds));
                invalidRegion=tmpArea;
              }
            }
            if (invalidRegion.getBounds().isEmpty()) {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newRendering.XToTileX(tile.getMinX());
                int ty=newRendering.YToTileY(tile.getMinY());
                newCache.add(newRendering,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                Rectangle bounds=tile.getBounds();
                if (!invalidRegion.intersects(bounds)) {
                  newCache.add(newRendering,newRendering.XToTileX(bounds.x),newRendering.YToTileY(bounds.y),tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
    if (theOldImage instanceof PlanarImageServerProxy && theImage == null) {
      newEventRendering(protocolName,(PlanarImageServerProxy)theOldImage,(PropertyChangeEventJAI)evt);
    }
 else {
      createRendering();
    }
    if (shouldFireEvent) {
      resetProperties(true);
      RenderingChangeEvent rcEvent=new RenderingChangeEvent(this,theOldImage,theImage,invalidRegion);
      eventManager.firePropertyChange(rcEvent);
      Vector sinks=getSinks();
      if (sinks != null) {
        int numSinks=sinks.size();
        for (int i=0; i < numSinks; i++) {
          Object sink=sinks.get(i);
          if (sink instanceof PropertyChangeListener) {
            ((PropertyChangeListener)sink).propertyChange(rcEvent);
          }
        }
      }
    }
  }
}","/** 
 * Implementation of <code>PropertyChangeListener</code>. <p> When invoked with an event which is an instance of <code>RenderingChangeEvent</code> the node will respond by re-rendering itself while retaining any tiles possible.
 */
public synchronized void propertyChange(PropertyChangeEvent evt){
  Object evtSrc=evt.getSource();
  Vector nodeSources=nodeSupport.getParameterBlock().getSources();
  String propName=evt.getPropertyName().toLowerCase(Locale.ENGLISH);
  if (theImage != null && ((evt instanceof PropertyChangeEventJAI && evtSrc == this && !(evt instanceof PropertySourceChangeEvent) && nodeEventNames.contains(propName)) || ((evt instanceof RenderingChangeEvent || evt instanceof CollectionChangeEvent || (evt instanceof PropertyChangeEventJAI && evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) && nodeSources.contains(evtSrc)))) {
    PlanarImage theOldImage=theImage;
    boolean shouldFireEvent=false;
    Shape invalidRegion=null;
    if (evtSrc == this && (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str""))) {
      shouldFireEvent=true;
      theImage=null;
    }
 else     if (evt instanceof RenderingChangeEvent || (evtSrc instanceof RenderedImage && propName.equals(""String_Node_Str""))) {
      shouldFireEvent=true;
      Shape srcInvalidRegion=null;
      if (evt instanceof RenderingChangeEvent) {
        RenderingChangeEvent rcEvent=(RenderingChangeEvent)evt;
        srcInvalidRegion=rcEvent.getInvalidRegion();
        if (srcInvalidRegion == null) {
          srcInvalidRegion=((PlanarImage)rcEvent.getOldValue()).getBounds();
        }
      }
 else {
        srcInvalidRegion=(Shape)evt.getNewValue();
        if (srcInvalidRegion == null) {
          RenderedImage rSrc=(RenderedImage)evtSrc;
          srcInvalidRegion=new Rectangle(rSrc.getMinX(),rSrc.getMinY(),rSrc.getWidth(),rSrc.getHeight());
        }
      }
      if (!(theImage instanceof PlanarImageServerProxy)) {
        theImage=null;
      }
 else {
        PlanarImageServerProxy oldPISP=(PlanarImageServerProxy)theImage;
        Rectangle srcInvalidBounds=srcInvalidRegion.getBounds();
        if (srcInvalidBounds.isEmpty()) {
          int x=oldPISP.tileXToX(oldPISP.getMinTileX());
          int y=oldPISP.tileYToY(oldPISP.getMinTileY());
          int w=oldPISP.getNumXTiles() * oldPISP.getTileWidth();
          int h=oldPISP.getNumYTiles() * oldPISP.getTileHeight();
          Rectangle tileBounds=new Rectangle(x,y,w,h);
          Rectangle imageBounds=oldPISP.getBounds();
          if (!tileBounds.equals(imageBounds)) {
            Area tmpArea=new Area(tileBounds);
            tmpArea.subtract(new Area(imageBounds));
            srcInvalidRegion=tmpArea;
            srcInvalidBounds=srcInvalidRegion.getBounds();
          }
        }
        boolean saveAllTiles=false;
        ArrayList validTiles=null;
        if (srcInvalidBounds.isEmpty()) {
          invalidRegion=srcInvalidRegion;
          saveAllTiles=true;
        }
 else {
          int idx=nodeSources.indexOf(evtSrc);
          Rectangle dstRegionBounds=oldPISP.mapSourceRect(srcInvalidBounds,idx);
          if (dstRegionBounds == null) {
            dstRegionBounds=oldPISP.getBounds();
          }
          Point[] indices=getTileIndices(dstRegionBounds);
          int numIndices=indices != null ? indices.length : 0;
          GeneralPath gp=null;
          for (int i=0; i < numIndices; i++) {
            if (i % 1000 == 0 && gp != null)             gp=new GeneralPath(new Area(gp));
            Rectangle dstRect=getTileRect(indices[i].x,indices[i].y);
            Rectangle srcRect=oldPISP.mapDestRect(dstRect,idx);
            if (srcRect == null) {
              gp=null;
              break;
            }
            if (srcInvalidRegion.intersects(srcRect)) {
              if (gp == null) {
                gp=new GeneralPath(dstRect);
              }
 else {
                gp.append(dstRect,false);
              }
            }
 else {
              if (validTiles == null) {
                validTiles=new ArrayList();
              }
              validTiles.add(indices[i]);
            }
          }
          invalidRegion=(gp == null) ? null : new Area(gp);
        }
        TileCache oldCache=oldPISP.getTileCache();
        theImage=null;
        if (oldCache != null && (saveAllTiles || validTiles != null)) {
          newEventRendering(protocolName,oldPISP,(PropertyChangeEventJAI)evt);
          if (theImage instanceof PlanarImageServerProxy && ((PlanarImageServerProxy)theImage).getTileCache() != null) {
            PlanarImageServerProxy newPISP=(PlanarImageServerProxy)theImage;
            TileCache newCache=newPISP.getTileCache();
            Object tileCacheMetric=newPISP.getTileCacheMetric();
            if (saveAllTiles) {
              Raster[] tiles=oldCache.getTiles(oldPISP);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newPISP.XToTileX(tile.getMinX());
                int ty=newPISP.YToTileY(tile.getMinY());
                newCache.add(newPISP,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              int numValidTiles=validTiles.size();
              for (int i=0; i < numValidTiles; i++) {
                Point tileIndex=(Point)validTiles.get(i);
                Raster tile=oldCache.getTile(oldPISP,tileIndex.x,tileIndex.y);
                if (tile != null) {
                  newCache.add(newPISP,tileIndex.x,tileIndex.y,tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
 else {
      ParameterBlock oldPB=null;
      ParameterBlock newPB=null;
      String oldServerName=serverName;
      String newServerName=serverName;
      boolean checkInvalidRegion=false;
      if (propName.equals(""String_Node_Str"")) {
        if (theImage instanceof PlanarImageServerProxy) {
          newEventRendering(protocolName,(PlanarImageServerProxy)theImage,(PropertyChangeEventJAI)evt);
        }
 else {
          theImage=null;
          createRendering();
        }
        shouldFireEvent=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=(ParameterBlock)evt.getOldValue();
        newPB=(ParameterBlock)evt.getNewValue();
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock((Vector)evt.getOldValue(),params);
        newPB=new ParameterBlock((Vector)evt.getNewValue(),params);
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=new ParameterBlock(nodeSources,(Vector)evt.getOldValue());
        newPB=new ParameterBlock(nodeSources,(Vector)evt.getNewValue());
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=newPB=nodeSupport.getParameterBlock();
        checkInvalidRegion=true;
      }
 else       if (propName.equals(""String_Node_Str"")) {
        oldPB=newPB=nodeSupport.getParameterBlock();
        oldServerName=(String)evt.getOldValue();
        newServerName=(String)evt.getNewValue();
        checkInvalidRegion=true;
      }
 else       if (evt instanceof CollectionChangeEvent) {
        int collectionIndex=nodeSources.indexOf(evtSrc);
        Vector oldSources=(Vector)nodeSources.clone();
        Vector newSources=(Vector)nodeSources.clone();
        oldSources.set(collectionIndex,evt.getOldValue());
        newSources.set(collectionIndex,evt.getNewValue());
        Vector params=nodeSupport.getParameterBlock().getParameters();
        oldPB=new ParameterBlock(oldSources,params);
        newPB=new ParameterBlock(newSources,params);
        checkInvalidRegion=true;
      }
      if (checkInvalidRegion) {
        shouldFireEvent=true;
        OperationRegistry registry=nodeSupport.getRegistry();
        RemoteDescriptor odesc=(RemoteDescriptor)registry.getDescriptor(RemoteDescriptor.class,protocolName);
        oldPB=ImageUtil.evaluateParameters(oldPB);
        newPB=ImageUtil.evaluateParameters(newPB);
        invalidRegion=(Shape)odesc.getInvalidRegion(""String_Node_Str"",oldServerName,oldPB,oldHints,newServerName,newPB,nodeSupport.getRenderingHints(),this);
        if (invalidRegion == null || !(theImage instanceof PlanarImageServerProxy)) {
          theImage=null;
        }
 else {
          PlanarImageServerProxy oldRendering=(PlanarImageServerProxy)theImage;
          newEventRendering(protocolName,oldRendering,(PropertyChangeEventJAI)evt);
          if (theImage instanceof PlanarImageServerProxy && oldRendering.getTileCache() != null && ((PlanarImageServerProxy)theImage).getTileCache() != null) {
            PlanarImageServerProxy newRendering=(PlanarImageServerProxy)theImage;
            TileCache oldCache=oldRendering.getTileCache();
            TileCache newCache=newRendering.getTileCache();
            Object tileCacheMetric=newRendering.getTileCacheMetric();
            if (invalidRegion.getBounds().isEmpty()) {
              int x=oldRendering.tileXToX(oldRendering.getMinTileX());
              int y=oldRendering.tileYToY(oldRendering.getMinTileY());
              int w=oldRendering.getNumXTiles() * oldRendering.getTileWidth();
              int h=oldRendering.getNumYTiles() * oldRendering.getTileHeight();
              Rectangle tileBounds=new Rectangle(x,y,w,h);
              Rectangle imageBounds=oldRendering.getBounds();
              if (!tileBounds.equals(imageBounds)) {
                Area tmpArea=new Area(tileBounds);
                tmpArea.subtract(new Area(imageBounds));
                invalidRegion=tmpArea;
              }
            }
            if (invalidRegion.getBounds().isEmpty()) {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                int tx=newRendering.XToTileX(tile.getMinX());
                int ty=newRendering.YToTileY(tile.getMinY());
                newCache.add(newRendering,tx,ty,tile,tileCacheMetric);
              }
            }
 else {
              Raster[] tiles=oldCache.getTiles(oldRendering);
              int numTiles=tiles == null ? 0 : tiles.length;
              for (int i=0; i < numTiles; i++) {
                Raster tile=tiles[i];
                Rectangle bounds=tile.getBounds();
                if (!invalidRegion.intersects(bounds)) {
                  newCache.add(newRendering,newRendering.XToTileX(bounds.x),newRendering.YToTileY(bounds.y),tile,tileCacheMetric);
                }
              }
            }
          }
        }
      }
    }
    if (theOldImage instanceof PlanarImageServerProxy && theImage == null) {
      newEventRendering(protocolName,(PlanarImageServerProxy)theOldImage,(PropertyChangeEventJAI)evt);
    }
 else {
      createRendering();
    }
    if (shouldFireEvent) {
      resetProperties(true);
      RenderingChangeEvent rcEvent=new RenderingChangeEvent(this,theOldImage,theImage,invalidRegion);
      eventManager.firePropertyChange(rcEvent);
      Vector sinks=getSinks();
      if (sinks != null) {
        int numSinks=sinks.size();
        for (int i=0; i < numSinks; i++) {
          Object sink=sinks.get(i);
          if (sink instanceof PropertyChangeListener) {
            ((PropertyChangeListener)sink).propertyChange(rcEvent);
          }
        }
      }
    }
  }
}",0.9993987287407662
154017,"/** 
 * Stores the parameter by reference in the internal name.
 * @throws IllegalArgumentException if <code>name</code> is<code>null</code>.
 */
public void setName(String name){
  if (name == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  this.name=name;
  lowerCaseName=name.toLowerCase();
}","/** 
 * Stores the parameter by reference in the internal name.
 * @throws IllegalArgumentException if <code>name</code> is<code>null</code>.
 */
public void setName(String name){
  if (name == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  this.name=name;
  lowerCaseName=name.toLowerCase(Locale.ENGLISH);
}",0.9797687861271676
154018,"protected Rectangle backwardMapRect(Rectangle destRect,int sourceIndex){
  if (destRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  Point2D p1=mapDestPoint(new Point2D.Double(destRect.x,destRect.y));
  Point2D p2=mapDestPoint(new Point2D.Double(destRect.x + destRect.width - 1,destRect.y + destRect.height - 1));
  int x1=(int)Math.floor(p1.getX());
  int y1=(int)Math.floor(p1.getY());
  int x2=(int)Math.floor(p2.getX());
  int y2=(int)Math.floor(p2.getY());
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}","protected Rectangle backwardMapRect(Rectangle destRect,int sourceIndex){
  if (destRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  Point2D p1=mapDestPoint(new Point2D.Double(destRect.x,destRect.y));
  Point2D p2=mapDestPoint(new Point2D.Double(destRect.x + destRect.width - 1,destRect.y + destRect.height - 1));
  int x1=(int)Math.floor(p1.getX());
  int y1=(int)Math.floor(p1.getY());
  int x2=(int)Math.ceil(p2.getX());
  int y2=(int)Math.ceil(p2.getY());
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}",0.986784140969163
154019,"protected Rectangle forwardMapRect(Rectangle sourceRect,int sourceIndex){
  if (sourceRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  Point2D p1=mapSourcePoint(new Point2D.Double(sourceRect.x,sourceRect.y));
  Point2D p2=mapSourcePoint(new Point2D.Double(sourceRect.x + sourceRect.width - 1,sourceRect.y + sourceRect.height - 1));
  int x1=(int)Math.floor(p1.getX());
  int y1=(int)Math.floor(p1.getY());
  int x2=(int)Math.floor(p2.getX());
  int y2=(int)Math.floor(p2.getY());
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}","protected Rectangle forwardMapRect(Rectangle sourceRect,int sourceIndex){
  if (sourceRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  Point2D p1=mapSourcePoint(new Point2D.Double(sourceRect.x,sourceRect.y));
  Point2D p2=mapSourcePoint(new Point2D.Double(sourceRect.x + sourceRect.width - 1,sourceRect.y + sourceRect.height - 1));
  int x1=(int)Math.floor(p1.getX());
  int y1=(int)Math.floor(p1.getY());
  int x2=(int)Math.ceil(p2.getX());
  int y2=(int)Math.ceil(p2.getY());
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}",0.9871428571428572
154020,"public boolean isFormatRecognized(byte[] header){
  return ((header[0] == (byte)0) && (header[1] & 0x9f) == 0 && (header[2] & 0x7f) != 0);
}","public boolean isFormatRecognized(byte[] header){
  return ((header[0] == (byte)0) && header[1] == 0 && ((header[2] & 0x8f) != 0 || (header[2] & 0x7f) != 0));
}",0.8733333333333333
154021,"/** 
 * Returns JAI version information as a <code>String</code>
 * @since JAI 1.1
 */
public static final String getBuildVersion(){
  try {
    InputStream is=JAI.class.getResourceAsStream(""String_Node_Str"");
    BufferedReader reader=new BufferedReader(new InputStreamReader(is));
    StringWriter sw=new StringWriter();
    BufferedWriter writer=new BufferedWriter(sw);
    String str;
    boolean append=false;
    while ((str=reader.readLine()) != null) {
      if (append)       writer.newLine();
      writer.write(str);
      append=true;
    }
    writer.close();
    return sw.getBuffer().toString();
  }
 catch (  Exception e) {
    return JaiI18N.getString(""String_Node_Str"");
  }
}","/** 
 * Returns JAI version information as a <code>String</code>
 * @since JAI 1.1
 */
public static final String getBuildVersion(){
  try {
    InputStream is=JAI.class.getResourceAsStream(""String_Node_Str"");
    if (is == null)     is=PropertyUtil.getFileFromClasspath(""String_Node_Str"");
    BufferedReader reader=new BufferedReader(new InputStreamReader(is));
    StringWriter sw=new StringWriter();
    BufferedWriter writer=new BufferedWriter(sw);
    String str;
    boolean append=false;
    while ((str=reader.readLine()) != null) {
      if (append)       writer.newLine();
      writer.write(str);
      append=true;
    }
    writer.close();
    return sw.getBuffer().toString();
  }
 catch (  Exception e) {
    return JaiI18N.getString(""String_Node_Str"");
  }
}",0.944860449285228
154022,"private static void setUseMlib(){
  boolean disableMediaLib=false;
  try {
    disableMediaLib=Boolean.getBoolean(""String_Node_Str"");
  }
 catch (  java.security.AccessControlException e) {
  }
  if (disableMediaLib) {
    useMlibVar=false;
    return;
  }
  try {
    SecurityManager securityManager=System.getSecurityManager();
    if (securityManager != null && MediaLibAccessor.class.getClassLoader() != null) {
      String osName=System.getProperty(""String_Node_Str"");
      String osArch=System.getProperty(""String_Node_Str"");
      if ((osName.equals(""String_Node_Str"") || osName.equals(""String_Node_Str"")) && osArch.equals(""String_Node_Str"")) {
        FilePermission fp=new FilePermission(""String_Node_Str"",""String_Node_Str"");
        securityManager.checkPermission(fp);
      }
    }
    Boolean result=(Boolean)AccessController.doPrivileged(new PrivilegedAction(){
      public Object run(){
        return new Boolean(Image.isAvailable());
      }
    }
);
    useMlibVar=result.booleanValue();
    if (!useMlibVar) {
      System.err.println(JaiI18N.getString(""String_Node_Str""));
    }
  }
 catch (  NoClassDefFoundError ncdfe) {
    useMlibVar=false;
    System.err.println(JaiI18N.getString(""String_Node_Str""));
  }
catch (  ClassFormatError cfe) {
    useMlibVar=false;
    System.err.println(JaiI18N.getString(""String_Node_Str""));
  }
catch (  SecurityException se) {
    useMlibVar=false;
    System.err.println(JaiI18N.getString(""String_Node_Str""));
  }
  if (useMlibVar == false)   return;
}","private static void setUseMlib(){
  boolean disableMediaLib=false;
  try {
    disableMediaLib=Boolean.getBoolean(""String_Node_Str"");
  }
 catch (  java.security.AccessControlException e) {
  }
  if (disableMediaLib) {
    useMlibVar=false;
    return;
  }
  try {
    SecurityManager securityManager=System.getSecurityManager();
    if (securityManager != null && MediaLibAccessor.class.getClassLoader() != null) {
      String osName=System.getProperty(""String_Node_Str"");
      String osArch=System.getProperty(""String_Node_Str"");
      if ((osName.equals(""String_Node_Str"") || osName.equals(""String_Node_Str"")) && osArch.equals(""String_Node_Str"")) {
        FilePermission fp=new FilePermission(""String_Node_Str"",""String_Node_Str"");
        securityManager.checkPermission(fp);
      }
    }
    Boolean result=(Boolean)AccessController.doPrivileged(new PrivilegedAction(){
      public Object run(){
        return new Boolean(Image.isAvailable());
      }
    }
);
    useMlibVar=result.booleanValue();
    if (!useMlibVar) {
      forwardToListener(JaiI18N.getString(""String_Node_Str""),new MediaLibLoadException());
    }
  }
 catch (  NoClassDefFoundError ncdfe) {
    useMlibVar=false;
    forwardToListener(JaiI18N.getString(""String_Node_Str""),ncdfe);
  }
catch (  ClassFormatError cfe) {
    useMlibVar=false;
    forwardToListener(JaiI18N.getString(""String_Node_Str""),cfe);
  }
catch (  SecurityException se) {
    useMlibVar=false;
    forwardToListener(JaiI18N.getString(""String_Node_Str""),se);
  }
  if (useMlibVar == false)   return;
}",0.9409461663947798
154023,"/** 
 * Force the destination image to be single-banded.
 */
private static ImageLayout layoutHelper(ImageLayout layout,RenderedImage source,LookupTableJAI colorMap){
  ImageLayout il=layout == null ? new ImageLayout() : (ImageLayout)layout.clone();
  il.setMinX(source.getMinX());
  il.setMinY(source.getMinY());
  il.setWidth(source.getWidth());
  il.setHeight(source.getHeight());
  SampleModel sm=il.getSampleModel(source);
  if (colorMap.getNumBands() == 1 && colorMap.getNumEntries() == 2 && !ImageUtil.isBinary(il.getSampleModel(source))) {
    sm=new MultiPixelPackedSampleModel(DataBuffer.TYPE_BYTE,il.getTileWidth(source),il.getTileHeight(source),1);
    il.setSampleModel(sm);
  }
  if (sm.getNumBands() != 1) {
    sm=RasterFactory.createComponentSampleModel(sm,sm.getTransferType(),sm.getWidth(),sm.getHeight(),1);
    il.setSampleModel(sm);
    ColorModel cm=il.getColorModel(null);
    if (cm != null && !JDKWorkarounds.areCompatibleDataModels(sm,cm)) {
      il.unsetValid(ImageLayout.COLOR_MODEL_MASK);
    }
  }
  if ((layout == null || !il.isValid(ImageLayout.COLOR_MODEL_MASK)) && source.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE && sm.getDataType() == DataBuffer.TYPE_BYTE && colorMap.getDataType() == DataBuffer.TYPE_BYTE && colorMap.getNumBands() == 3) {
    ColorModel cm=source.getColorModel();
    if (cm == null || (cm != null && cm.getColorSpace().isCS_sRGB())) {
      int size=colorMap.getNumEntries();
      byte[][] cmap=new byte[3][256];
      for (int i=0; i < 3; i++) {
        byte[] band=cmap[i];
        byte[] data=colorMap.getByteData(i);
        int offset=colorMap.getOffset(i);
        int end=offset + size;
        for (int j=0; j < offset; j++) {
          band[j]=(byte)0;
        }
        for (int j=offset; j < end; j++) {
          band[j]=data[j - offset];
        }
        for (int j=end; j < 256; j++) {
          band[j]=(byte)0xFF;
        }
      }
      il.setColorModel(new IndexColorModel(8,256,cmap[0],cmap[1],cmap[2]));
    }
  }
  return il;
}","/** 
 * Force the destination image to be single-banded.
 */
private static ImageLayout layoutHelper(ImageLayout layout,RenderedImage source,LookupTableJAI colorMap){
  ImageLayout il=layout == null ? new ImageLayout() : (ImageLayout)layout.clone();
  il.setMinX(source.getMinX());
  il.setMinY(source.getMinY());
  il.setWidth(source.getWidth());
  il.setHeight(source.getHeight());
  SampleModel sm=il.getSampleModel(source);
  if (colorMap.getNumBands() == 1 && colorMap.getNumEntries() == 2 && !ImageUtil.isBinary(il.getSampleModel(source))) {
    sm=new MultiPixelPackedSampleModel(DataBuffer.TYPE_BYTE,il.getTileWidth(source),il.getTileHeight(source),1);
    il.setSampleModel(sm);
  }
  if (sm.getNumBands() != 1) {
    sm=RasterFactory.createComponentSampleModel(sm,sm.getTransferType(),sm.getWidth(),sm.getHeight(),1);
    il.setSampleModel(sm);
    ColorModel cm=il.getColorModel(null);
    if (cm != null && !JDKWorkarounds.areCompatibleDataModels(sm,cm)) {
      il.unsetValid(ImageLayout.COLOR_MODEL_MASK);
    }
  }
  int numColorMapBands=colorMap.getNumBands();
  int maxIndex=0;
  for (int i=0; i < numColorMapBands; i++) {
    maxIndex=Math.max(colorMap.getOffset(i) + colorMap.getNumEntries() - 1,maxIndex);
  }
  if ((maxIndex > 255 && sm.getDataType() == DataBuffer.TYPE_BYTE) || (maxIndex > 65535 && sm.getDataType() != DataBuffer.TYPE_INT)) {
    int dataType=maxIndex > 65535 ? DataBuffer.TYPE_INT : DataBuffer.TYPE_USHORT;
    sm=RasterFactory.createComponentSampleModel(sm,dataType,sm.getWidth(),sm.getHeight(),1);
    il.setSampleModel(sm);
    ColorModel cm=il.getColorModel(null);
    if (cm != null && !JDKWorkarounds.areCompatibleDataModels(sm,cm)) {
      il.unsetValid(ImageLayout.COLOR_MODEL_MASK);
    }
  }
  if ((layout == null || !il.isValid(ImageLayout.COLOR_MODEL_MASK)) && source.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE && (sm.getDataType() == DataBuffer.TYPE_BYTE || sm.getDataType() == DataBuffer.TYPE_USHORT) && colorMap.getDataType() == DataBuffer.TYPE_BYTE && colorMap.getNumBands() == 3) {
    ColorModel cm=source.getColorModel();
    if (cm == null || (cm != null && cm.getColorSpace().isCS_sRGB())) {
      int size=colorMap.getNumEntries();
      byte[][] cmap=new byte[3][maxIndex + 1];
      for (int i=0; i < 3; i++) {
        byte[] band=cmap[i];
        byte[] data=colorMap.getByteData(i);
        int offset=colorMap.getOffset(i);
        int end=offset + size;
        for (int j=offset; j < end; j++) {
          band[j]=data[j - offset];
        }
      }
      int numBits=sm.getDataType() == DataBuffer.TYPE_BYTE ? 8 : 16;
      il.setColorModel(new IndexColorModel(numBits,maxIndex + 1,cmap[0],cmap[1],cmap[2]));
    }
  }
  return il;
}",0.7649419218585005
154024,"/** 
 * Creates an image from a String containing a file name.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImagingListener listener=ImageUtil.getImagingListener(hints);
  try {
    String fileName=(String)args.getObjectParameter(0);
    SeekableStream src=new FileSeekableStream(fileName);
    ImageDecodeParam param=null;
    if (args.getNumParameters() > 1) {
      param=(ImageDecodeParam)args.getObjectParameter(1);
    }
    ParameterBlock newArgs=new ParameterBlock();
    newArgs.add(src);
    newArgs.add(param);
    RenderingHints.Key key=JAI.KEY_OPERATION_BOUND;
    int bound=OpImage.OP_IO_BOUND;
    if (hints == null) {
      hints=new RenderingHints(key,new Integer(bound));
    }
 else     if (!hints.containsKey(key)) {
      hints=(RenderingHints)hints.clone();
      hints.put(key,new Integer(bound));
    }
    OperationRegistry registry=(OperationRegistry)hints.get(JAI.KEY_OPERATION_REGISTRY);
    RenderedImage image=RIFRegistry.create(registry,""String_Node_Str"",newArgs,hints);
    return image == null ? null : new StreamImage(image,src);
  }
 catch (  FileNotFoundException e) {
    String message=JaiI18N.getString(""String_Node_Str"") + args.getObjectParameter(0);
    listener.errorOccurred(message,e,this,false);
    return null;
  }
catch (  Exception e) {
    String message=JaiI18N.getString(""String_Node_Str"");
    listener.errorOccurred(message,e,this,false);
    return null;
  }
}","/** 
 * Creates an image from a String containing a file name.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImagingListener listener=ImageUtil.getImagingListener(hints);
  try {
    String fileName=(String)args.getObjectParameter(0);
    SeekableStream src=null;
    try {
      src=new FileSeekableStream(fileName);
    }
 catch (    FileNotFoundException fnfe) {
      InputStream is=this.getClass().getClassLoader().getResourceAsStream(fileName);
      if (is != null)       src=SeekableStream.wrapInputStream(is,true);
    }
    ImageDecodeParam param=null;
    if (args.getNumParameters() > 1) {
      param=(ImageDecodeParam)args.getObjectParameter(1);
    }
    ParameterBlock newArgs=new ParameterBlock();
    newArgs.add(src);
    newArgs.add(param);
    RenderingHints.Key key=JAI.KEY_OPERATION_BOUND;
    int bound=OpImage.OP_IO_BOUND;
    if (hints == null) {
      hints=new RenderingHints(key,new Integer(bound));
    }
 else     if (!hints.containsKey(key)) {
      hints=(RenderingHints)hints.clone();
      hints.put(key,new Integer(bound));
    }
    OperationRegistry registry=(OperationRegistry)hints.get(JAI.KEY_OPERATION_REGISTRY);
    RenderedImage image=RIFRegistry.create(registry,""String_Node_Str"",newArgs,hints);
    return image == null ? null : new StreamImage(image,src);
  }
 catch (  FileNotFoundException e) {
    String message=JaiI18N.getString(""String_Node_Str"") + args.getObjectParameter(0);
    listener.errorOccurred(message,e,this,false);
    return null;
  }
catch (  Exception e) {
    String message=JaiI18N.getString(""String_Node_Str"");
    listener.errorOccurred(message,e,this,false);
    return null;
  }
}",0.9240102171136654
154025,"/** 
 * Validates the input parameters. <p> In addition to the standard checks performed by the superclass method, this method by default checks that the source file exists and is readable. This check may be bypassed by setting the <code>checkFileLocally</code> parameter to <code>FALSE</code>
 */
protected boolean validateParameters(ParameterBlock args,StringBuffer msg){
  if (!super.validateParameters(args,msg)) {
    return false;
  }
  Boolean checkFile=(Boolean)args.getObjectParameter(2);
  if (checkFile.booleanValue()) {
    String filename=(String)args.getObjectParameter(0);
    File f=new File(filename);
    if (!f.exists()) {
      msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
      return false;
    }
    if (!f.canRead()) {
      msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
      return false;
    }
  }
  return true;
}","/** 
 * Validates the input parameters. <p> In addition to the standard checks performed by the superclass method, this method by default checks that the source file exists and is readable. This check may be bypassed by setting the <code>checkFileLocally</code> parameter to <code>FALSE</code>
 */
protected boolean validateParameters(ParameterBlock args,StringBuffer msg){
  if (!super.validateParameters(args,msg)) {
    return false;
  }
  Boolean checkFile=(Boolean)args.getObjectParameter(2);
  if (checkFile.booleanValue()) {
    String filename=(String)args.getObjectParameter(0);
    File f=new File(filename);
    boolean fileExists=f.exists();
    if (!fileExists) {
      InputStream is=getClass().getResourceAsStream(filename);
      if (is == null) {
        msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
        return false;
      }
    }
 else {
      if (!f.canRead()) {
        msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
        return false;
      }
    }
  }
  return true;
}",0.9202334630350194
154026,"/** 
 * Performs bicubic affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int mlibInterpType=Constants.MLIB_BICUBIC;
  if (interp instanceof InterpolationBicubic2) {
    mlibInterpType=Constants.MLIB_BICUBIC2;
  }
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs bicubic affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int mlibInterpType=Constants.MLIB_BICUBIC;
  if (interp instanceof InterpolationBicubic2) {
    mlibInterpType=Constants.MLIB_BICUBIC2;
  }
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
MlibUtils.clampImage(dstML[0],getColorModel());
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.9893285904846598
154027,"/** 
 * Performs bilinear affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs bilinear affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
MlibUtils.clampImage(dstML[0],getColorModel());
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.9888059701492538
154028,"/** 
 * Performs nearest-neighbour affine transformation on a specified rectangle.  The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  InterpolationTable jtable=(InterpolationTable)interp;
  mediaLibImageInterpTable mlibInterpTable;
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
  srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.AffineTable(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_DOUBLE:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs nearest-neighbour affine transformation on a specified rectangle.  The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  InterpolationTable jtable=(InterpolationTable)interp;
  mediaLibImageInterpTable mlibInterpTable;
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
  srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.AffineTable(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
MlibUtils.clampImage(dstML[0],getColorModel());
break;
case DataBuffer.TYPE_FLOAT:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_DOUBLE:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.9930695928385792
154029,"/** 
 * Scale the given rectangle by the specified scale and translation  factors. The sources are cobbled.
 * @param sources   an array of sources, guarantee to provide allnecessary source data for computing the rectangle.
 * @param dest      a tile that contains the rectangle to be computed.
 * @param destRect  the rectangle within this OpImage to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int mlibInterpType=Constants.MLIB_BICUBIC;
  if (interp instanceof InterpolationBicubic2) {
    mlibInterpType=Constants.MLIB_BICUBIC2;
  }
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double mlibScaleX=(double)scaleXRationalNum / (double)scaleXRationalDenom;
  double mlibScaleY=(double)scaleYRationalNum / (double)scaleYRationalDenom;
  long tempDenomX=scaleXRationalDenom * transXRationalDenom;
  long tempDenomY=scaleYRationalDenom * transYRationalDenom;
  long tempNumerX=(srcRect.x * scaleXRationalNum * transXRationalDenom) + (transXRationalNum * scaleXRationalDenom) - (destRect.x * tempDenomX);
  long tempNumerY=(srcRect.y * scaleYRationalNum * transYRationalDenom) + (transYRationalNum * scaleYRationalDenom) - (destRect.y * tempDenomY);
  double tx=(double)tempNumerX / (double)tempDenomX;
  double ty=(double)tempNumerY / (double)tempDenomY;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
  Image.ZoomTranslate(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslate_Fp(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.clampDataArrays();
dstAccessor.copyDataToRaster();
}
}","/** 
 * Scale the given rectangle by the specified scale and translation  factors. The sources are cobbled.
 * @param sources   an array of sources, guarantee to provide allnecessary source data for computing the rectangle.
 * @param dest      a tile that contains the rectangle to be computed.
 * @param destRect  the rectangle within this OpImage to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int mlibInterpType=Constants.MLIB_BICUBIC;
  if (interp instanceof InterpolationBicubic2) {
    mlibInterpType=Constants.MLIB_BICUBIC2;
  }
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double mlibScaleX=(double)scaleXRationalNum / (double)scaleXRationalDenom;
  double mlibScaleY=(double)scaleYRationalNum / (double)scaleYRationalDenom;
  long tempDenomX=scaleXRationalDenom * transXRationalDenom;
  long tempDenomY=scaleYRationalDenom * transYRationalDenom;
  long tempNumerX=(srcRect.x * scaleXRationalNum * transXRationalDenom) + (transXRationalNum * scaleXRationalDenom) - (destRect.x * tempDenomX);
  long tempNumerY=(srcRect.y * scaleYRationalNum * transYRationalDenom) + (transYRationalNum * scaleYRationalDenom) - (destRect.y * tempDenomY);
  double tx=(double)tempNumerX / (double)tempDenomX;
  double ty=(double)tempNumerY / (double)tempDenomY;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
  Image.ZoomTranslate(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
  MlibUtils.clampImage(dstML[i],getColorModel());
}
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslate_Fp(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.clampDataArrays();
dstAccessor.copyDataToRaster();
}
}",0.9901497241922774
154030,"/** 
 * Scale a given rectangle by the specified scale and translation factors. The sources are cobbled.
 * @param sources   an array of sources, guarantee to provide allnecessary source data for computing the rectangle.
 * @param dest      a tile that contains the rectangle to be computed.
 * @param destRect  the rectangle within this OpImage to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double mlibScaleX=(double)scaleXRationalNum / (double)scaleXRationalDenom;
  double mlibScaleY=(double)scaleYRationalNum / (double)scaleYRationalDenom;
  long tempDenomX=scaleXRationalDenom * transXRationalDenom;
  long tempDenomY=scaleYRationalDenom * transYRationalDenom;
  long tempNumerX=(srcRect.x * scaleXRationalNum * transXRationalDenom) + (transXRationalNum * scaleXRationalDenom) - (destRect.x * tempDenomX);
  long tempNumerY=(srcRect.y * scaleYRationalNum * transYRationalDenom) + (transYRationalNum * scaleYRationalDenom) - (destRect.y * tempDenomY);
  double tx=(double)tempNumerX / (double)tempDenomX;
  double ty=(double)tempNumerY / (double)tempDenomY;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
  Image.ZoomTranslate(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslate_Fp(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.clampDataArrays();
dstAccessor.copyDataToRaster();
}
}","/** 
 * Scale a given rectangle by the specified scale and translation factors. The sources are cobbled.
 * @param sources   an array of sources, guarantee to provide allnecessary source data for computing the rectangle.
 * @param dest      a tile that contains the rectangle to be computed.
 * @param destRect  the rectangle within this OpImage to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double mlibScaleX=(double)scaleXRationalNum / (double)scaleXRationalDenom;
  double mlibScaleY=(double)scaleYRationalNum / (double)scaleYRationalDenom;
  long tempDenomX=scaleXRationalDenom * transXRationalDenom;
  long tempDenomY=scaleYRationalDenom * transYRationalDenom;
  long tempNumerX=(srcRect.x * scaleXRationalNum * transXRationalDenom) + (transXRationalNum * scaleXRationalDenom) - (destRect.x * tempDenomX);
  long tempNumerY=(srcRect.y * scaleYRationalNum * transYRationalDenom) + (transYRationalNum * scaleYRationalDenom) - (destRect.y * tempDenomY);
  double tx=(double)tempNumerX / (double)tempDenomX;
  double ty=(double)tempNumerY / (double)tempDenomY;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
  Image.ZoomTranslate(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
  MlibUtils.clampImage(dstML[i],getColorModel());
}
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslate_Fp(dstML[i],srcML[i],mlibScaleX,mlibScaleY,tx,ty,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.clampDataArrays();
dstAccessor.copyDataToRaster();
}
}",0.9896308585649108
154031,"/** 
 * Scale the given rectangle by the specified scale and translation  factors. The sources are cobbled.
 * @param sources   an array of sources, guarantee to provide allnecessary source data for computing the rectangle.
 * @param dest      a tile that contains the rectangle to be computed.
 * @param destRect  the rectangle within this OpImage to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  InterpolationTable jtable=(InterpolationTable)interp;
  mediaLibImageInterpTable mlibInterpTable;
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  float mlibScaleX=(float)scaleXRationalNum / (float)scaleXRationalDenom;
  float mlibScaleY=(float)scaleYRationalNum / (float)scaleYRationalDenom;
  float tempDX=(float)(srcRect.x * scaleXRationalNum) / (float)scaleXRationalDenom;
  float tempDY=(float)(srcRect.y * scaleYRationalNum) / (float)scaleYRationalDenom;
  float tx=transX - destRect.x + tempDX;
  float ty=transY - destRect.y + tempDY;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
  srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslateTable(dstML[i],srcML[i],(double)mlibScaleX,(double)mlibScaleY,(double)tx,(double)ty,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_FLOAT:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslateTable_Fp(dstML[i],srcML[i],(double)mlibScaleX,(double)mlibScaleY,(double)tx,(double)ty,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_DOUBLE:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslateTable_Fp(dstML[i],srcML[i],(double)mlibScaleX,(double)mlibScaleY,(double)tx,(double)ty,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.clampDataArrays();
dstAccessor.copyDataToRaster();
}
}","/** 
 * Scale the given rectangle by the specified scale and translation  factors. The sources are cobbled.
 * @param sources   an array of sources, guarantee to provide allnecessary source data for computing the rectangle.
 * @param dest      a tile that contains the rectangle to be computed.
 * @param destRect  the rectangle within this OpImage to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  InterpolationTable jtable=(InterpolationTable)interp;
  mediaLibImageInterpTable mlibInterpTable;
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  float mlibScaleX=(float)scaleXRationalNum / (float)scaleXRationalDenom;
  float mlibScaleY=(float)scaleYRationalNum / (float)scaleYRationalDenom;
  float tempDX=(float)(srcRect.x * scaleXRationalNum) / (float)scaleXRationalDenom;
  float tempDY=(float)(srcRect.y * scaleYRationalNum) / (float)scaleYRationalDenom;
  float tx=transX - destRect.x + tempDX;
  float ty=transY - destRect.y + tempDY;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
  srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslateTable(dstML[i],srcML[i],(double)mlibScaleX,(double)mlibScaleY,(double)tx,(double)ty,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
MlibUtils.clampImage(dstML[i],getColorModel());
}
break;
case DataBuffer.TYPE_FLOAT:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslateTable_Fp(dstML[i],srcML[i],(double)mlibScaleX,(double)mlibScaleY,(double)tx,(double)ty,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_DOUBLE:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
for (int i=0; i < dstML.length; i++) {
Image.ZoomTranslateTable_Fp(dstML[i],srcML[i],(double)mlibScaleX,(double)mlibScaleY,(double)tx,(double)ty,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.clampDataArrays();
dstAccessor.copyDataToRaster();
}
}",0.993105429474289
154032,"/** 
 * Performs the ""grid warp"" operation on a rectangular region of the image.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  Raster source=sources[0];
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (setBackground)     for (int i=0; i < dstMLI.length; i++) {
      Image.GridWarp2(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
    }
 else     for (int i=0; i < dstMLI.length; i++) {
      Image.GridWarp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
    }
  break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
  Image.GridWarp2_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
  Image.GridWarp_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}","/** 
 * Performs the ""grid warp"" operation on a rectangular region of the image.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  Raster source=sources[0];
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (setBackground)     for (int i=0; i < dstMLI.length; i++) {
      Image.GridWarp2(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
    }
 else     for (int i=0; i < dstMLI.length; i++) {
      Image.GridWarp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
      MlibUtils.clampImage(dstMLI[i],getColorModel());
    }
  break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
  Image.GridWarp2_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
  Image.GridWarp_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}",0.9864298050826548
154033,"/** 
 * Performs the ""grid warp"" operation on a rectangular region of the image.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  Raster source=sources[0];
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (mlibInterpTableI == null) {
      InterpolationTable jtable=(InterpolationTable)interp;
      mlibInterpTableI=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
    }
  if (setBackground)   for (int i=0; i < dstMLI.length; i++) {
    Image.GridWarpTable2(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
  }
 else   for (int i=0; i < dstMLI.length; i++) {
    Image.GridWarpTable(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE);
  }
break;
case DataBuffer.TYPE_FLOAT:
if (mlibInterpTableF == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableF=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable2_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableF,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableF,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_DOUBLE:
if (mlibInterpTableD == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableD=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable2_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}","/** 
 * Performs the ""grid warp"" operation on a rectangular region of the image.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  Raster source=sources[0];
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (mlibInterpTableI == null) {
      InterpolationTable jtable=(InterpolationTable)interp;
      mlibInterpTableI=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
    }
  if (setBackground)   for (int i=0; i < dstMLI.length; i++) {
    Image.GridWarpTable2(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
  }
 else   for (int i=0; i < dstMLI.length; i++) {
    Image.GridWarpTable(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE);
    MlibUtils.clampImage(dstMLI[i],getColorModel());
  }
break;
case DataBuffer.TYPE_FLOAT:
if (mlibInterpTableF == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableF=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable2_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableF,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableF,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_DOUBLE:
if (mlibInterpTableD == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableD=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable2_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.GridWarpTable_Fp(dstMLI[i],srcMLI[i],xWarpPos,yWarpPos,source.getMinX(),source.getMinY(),xStart - destRect.x,xStep,xNumCells,yStart - destRect.y,yStep,yNumCells,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}",0.9930764206401044
154034,"/** 
 * Performs the ""Warp"" operation on a rectangular region of the same.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (setBackground)     for (int i=0; i < dstMLI.length; i++) {
      Image.PolynomialWarp2(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
    }
 else     for (int i=0; i < dstMLI.length; i++) {
      Image.PolynomialWarp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
    }
  break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
  Image.PolynomialWarp2_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
  Image.PolynomialWarp_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}","/** 
 * Performs the ""Warp"" operation on a rectangular region of the same.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (setBackground)     for (int i=0; i < dstMLI.length; i++) {
      Image.PolynomialWarp2(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
    }
 else     for (int i=0; i < dstMLI.length; i++) {
      Image.PolynomialWarp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
      MlibUtils.clampImage(dstMLI[i],getColorModel());
    }
  break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
  Image.PolynomialWarp2_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
  Image.PolynomialWarp_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,filter,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}",0.9862808680468944
154035,"/** 
 * Performs the ""Warp"" operation on a rectangular region of the same.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (mlibInterpTableI == null) {
      InterpolationTable jtable=(InterpolationTable)interp;
      mlibInterpTableI=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
    }
  if (setBackground)   for (int i=0; i < dstMLI.length; i++) {
    Image.PolynomialWarpTable2(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
  }
 else   for (int i=0; i < dstMLI.length; i++) {
    Image.PolynomialWarpTable(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE);
  }
break;
case DataBuffer.TYPE_FLOAT:
if (mlibInterpTableF == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableF=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable2_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_DOUBLE:
if (mlibInterpTableD == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableD=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable2_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}","/** 
 * Performs the ""Warp"" operation on a rectangular region of the same.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcMA=new MediaLibAccessor(source,source.getBounds(),formatTag);
  MediaLibAccessor dstMA=new MediaLibAccessor(dest,destRect,formatTag);
  mediaLibImage[] srcMLI=srcMA.getMediaLibImages();
  mediaLibImage[] dstMLI=dstMA.getMediaLibImages();
switch (dstMA.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    if (mlibInterpTableI == null) {
      InterpolationTable jtable=(InterpolationTable)interp;
      mlibInterpTableI=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
    }
  if (setBackground)   for (int i=0; i < dstMLI.length; i++) {
    Image.PolynomialWarpTable2(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
  }
 else   for (int i=0; i < dstMLI.length; i++) {
    Image.PolynomialWarpTable(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableI,Constants.MLIB_EDGE_DST_NO_WRITE);
    MlibUtils.clampImage(dstMLI[i],getColorModel());
  }
break;
case DataBuffer.TYPE_FLOAT:
if (mlibInterpTableF == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableF=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable2_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
case DataBuffer.TYPE_DOUBLE:
if (mlibInterpTableD == null) {
InterpolationTable jtable=(InterpolationTable)interp;
mlibInterpTableD=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
}
if (setBackground) for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable2_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
}
 else for (int i=0; i < dstMLI.length; i++) {
Image.PolynomialWarpTable_Fp(dstMLI[i],srcMLI[i],xCoeffs,yCoeffs,destRect.x,destRect.y,source.getMinX(),source.getMinY(),preScaleX,preScaleY,postScaleX,postScaleY,mlibInterpTableD,Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstMA.isDataCopy()) {
dstMA.clampDataArrays();
dstMA.copyDataToRaster();
}
}",0.99302172481896
154036,"/** 
 * Creates an rotate operation.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(hints);
  Interpolation interp=(Interpolation)args.getObjectParameter(3);
  double[] backgroundValues=(double[])args.getObjectParameter(4);
  RenderedImage source=args.getRenderedSource(0);
  if (!MediaLibAccessor.isMediaLibCompatible(args,layout) || !MediaLibAccessor.hasSameNumBands(args,layout) || source.getTileWidth() >= 32768 || source.getTileHeight() >= 32768) {
    return null;
  }
  BorderExtender extender=RIFUtil.getBorderExtenderHint(hints);
  float x_center=args.getFloatParameter(0);
  float y_center=args.getFloatParameter(1);
  float angle=args.getFloatParameter(2);
  double tmp_angle=180.0F * angle / Math.PI;
  double rnd_angle=Math.round(tmp_angle);
  if (Math.abs(rnd_angle - tmp_angle) < 0.0001) {
    int dangle=(int)rnd_angle % 360;
    if (dangle < 0) {
      dangle+=360;
    }
    if (dangle == 0) {
      return new MlibCopyOpImage(source,hints,layout);
    }
    int ix_center=(int)Math.round(x_center);
    int iy_center=(int)Math.round(y_center);
    if (((dangle % 90) == 0) && (Math.abs(x_center - ix_center) < 0.0001) && (Math.abs(y_center - iy_center) < 0.0001)) {
      int transType=-1;
      int rotMinX=0;
      int rotMinY=0;
      int sourceMinX=source.getMinX();
      int sourceMinY=source.getMinY();
      int sourceMaxX=sourceMinX + source.getWidth();
      int sourceMaxY=sourceMinY + source.getHeight();
      if (dangle == 90) {
        transType=4;
        rotMinX=ix_center - (sourceMaxY - iy_center);
        rotMinY=iy_center - (ix_center - sourceMinX);
      }
 else       if (dangle == 180) {
        transType=5;
        rotMinX=2 * ix_center - sourceMaxX;
        rotMinY=2 * iy_center - sourceMaxY;
      }
 else {
        transType=6;
        rotMinX=ix_center - (iy_center - sourceMinY);
        rotMinY=iy_center - (sourceMaxX - ix_center);
      }
      RenderedImage trans=new MlibTransposeOpImage(source,hints,layout,transType);
      int imMinX=trans.getMinX();
      int imMinY=trans.getMinY();
      if (layout == null) {
        return new TranslateIntOpImage(trans,hints,rotMinX - imMinX,rotMinY - imMinY);
      }
 else {
        ParameterBlock pbScale=new ParameterBlock();
        pbScale.addSource(trans);
        pbScale.add(0F);
        pbScale.add(0F);
        pbScale.add(rotMinX - imMinX);
        pbScale.add(rotMinY - imMinY);
        pbScale.add(interp);
        return JAI.create(""String_Node_Str"",pbScale,hints);
      }
    }
  }
  AffineTransform transform=AffineTransform.getRotateInstance(angle,x_center,y_center);
  if (interp instanceof InterpolationNearest) {
    return new MlibAffineNearestOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else   if (interp instanceof InterpolationBilinear) {
    return new MlibAffineBilinearOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else   if (interp instanceof InterpolationBicubic || interp instanceof InterpolationBicubic2) {
    return new MlibAffineBicubicOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else   if (interp instanceof InterpolationTable) {
    return new MlibAffineTableOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else {
    return null;
  }
}","/** 
 * Creates an rotate operation.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(hints);
  Interpolation interp=(Interpolation)args.getObjectParameter(3);
  double[] backgroundValues=(double[])args.getObjectParameter(4);
  RenderedImage source=args.getRenderedSource(0);
  if (!MediaLibAccessor.isMediaLibCompatible(args,layout) || !MediaLibAccessor.hasSameNumBands(args,layout) || source.getTileWidth() >= 32768 || source.getTileHeight() >= 32768) {
    return null;
  }
  BorderExtender extender=RIFUtil.getBorderExtenderHint(hints);
  float x_center=args.getFloatParameter(0);
  float y_center=args.getFloatParameter(1);
  float angle=args.getFloatParameter(2);
  double tmp_angle=180.0F * angle / Math.PI;
  double rnd_angle=Math.round(tmp_angle);
  AffineTransform transform=AffineTransform.getRotateInstance(angle,x_center,y_center);
  if (Math.abs(rnd_angle - tmp_angle) < 0.0001) {
    int dangle=(int)rnd_angle % 360;
    if (dangle < 0) {
      dangle+=360;
    }
    if (dangle == 0) {
      return new MlibCopyOpImage(source,hints,layout);
    }
    int ix_center=(int)Math.round(x_center);
    int iy_center=(int)Math.round(y_center);
    if (((dangle % 90) == 0) && (Math.abs(x_center - ix_center) < 0.0001) && (Math.abs(y_center - iy_center) < 0.0001)) {
      int transType=-1;
      int rotMinX=0;
      int rotMinY=0;
      int sourceMinX=source.getMinX();
      int sourceMinY=source.getMinY();
      int sourceMaxX=sourceMinX + source.getWidth();
      int sourceMaxY=sourceMinY + source.getHeight();
      if (dangle == 90) {
        transType=4;
        rotMinX=ix_center - (sourceMaxY - iy_center);
        rotMinY=iy_center - (ix_center - sourceMinX);
      }
 else       if (dangle == 180) {
        transType=5;
        rotMinX=2 * ix_center - sourceMaxX;
        rotMinY=2 * iy_center - sourceMaxY;
      }
 else {
        transType=6;
        rotMinX=ix_center - (iy_center - sourceMinY);
        rotMinY=iy_center - (sourceMaxX - ix_center);
      }
      RenderedImage trans=new MlibTransposeOpImage(source,hints,layout,transType);
      int imMinX=trans.getMinX();
      int imMinY=trans.getMinY();
      if (layout == null) {
        OpImage intermediateImage=new TranslateIntOpImage(trans,hints,rotMinX - imMinX,rotMinY - imMinY);
        try {
          return new PointMapperOpImage(intermediateImage,hints,transform);
        }
 catch (        NoninvertibleTransformException nite) {
          return intermediateImage;
        }
      }
 else {
        ParameterBlock pbScale=new ParameterBlock();
        pbScale.addSource(trans);
        pbScale.add(0F);
        pbScale.add(0F);
        pbScale.add(rotMinX - imMinX);
        pbScale.add(rotMinY - imMinY);
        pbScale.add(interp);
        PlanarImage intermediateImage=JAI.create(""String_Node_Str"",pbScale,hints).getRendering();
        try {
          return new PointMapperOpImage(intermediateImage,hints,transform);
        }
 catch (        NoninvertibleTransformException nite) {
          return intermediateImage;
        }
      }
    }
  }
  if (interp instanceof InterpolationNearest) {
    return new MlibAffineNearestOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else   if (interp instanceof InterpolationBilinear) {
    return new MlibAffineBilinearOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else   if (interp instanceof InterpolationBicubic || interp instanceof InterpolationBicubic2) {
    return new MlibAffineBicubicOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else   if (interp instanceof InterpolationTable) {
    return new MlibAffineTableOpImage(source,extender,hints,layout,transform,interp,backgroundValues);
  }
 else {
    return null;
  }
}",0.908159024795678
154037,"/** 
 * Creates a MlibDilate3PlusOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibDilate3PlusOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,config,true,extender,1,1,1,1);
}","/** 
 * Creates a MlibDilate3PlusOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibDilate3PlusOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,configHelper(config),true,extender,1,1,1,1);
}",0.9890282131661442
154038,"/** 
 * Creates a MlibDilate3SquareOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibDilate3SquareOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,config,true,extender,1,1,1,1);
}","/** 
 * Creates a MlibDilate3SquareOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibDilate3SquareOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,configHelper(config),true,extender,1,1,1,1);
}",0.9890965732087228
154039,"/** 
 * Creates a MlibErode3PlusOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibErode3PlusOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,config,true,extender,1,1,1,1);
}","/** 
 * Creates a MlibErode3PlusOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibErode3PlusOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,configHelper(config),true,extender,1,1,1,1);
}",0.9889937106918238
154040,"/** 
 * Creates a MlibErode3SquareOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibErode3SquareOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,config,true,extender,1,1,1,1);
}","/** 
 * Creates a MlibErode3SquareOpImage given the image source The image dimensions are derived from the source image.  The tile grid layout, SampleModel, and ColorModel may optionally be specified by an ImageLayout object.
 * @param source a RenderedImage.
 * @param extender a BorderExtender, or null.or null.  If null, a default cache will be used.
 * @param layout an ImageLayout optionally containing the tile grid layout,SampleModel, and ColorModel, or null.
 */
public MlibErode3SquareOpImage(RenderedImage source,BorderExtender extender,Map config,ImageLayout layout){
  super(source,layout,configHelper(config),true,extender,1,1,1,1);
}",0.9890625
154041,"/** 
 * pack kernel into integers by row, aligned to the right; extra bits on the left are filled with 0 bits
 * @params  kernel - the given kernel (already rotated)
 * @returns an integer array of ints from packed kernel data
 */
private final int[] packKernel(KernelJAI kernel){
  int kw=kernel.getWidth();
  int kh=kernel.getHeight();
  int kwPack=(31 + kw) / 32;
  int kerPacked[]=new int[kwPack * kh];
  float[] kdata=kernel.getKernelData();
  for (int j=0; j < kw; j++) {
    int m=j;
    int lastCol=kwPack - 1;
    bitShiftMatrixLeft(kerPacked,kh,kwPack);
    for (int i=0; i < kh; i++, lastCol+=kwPack, m+=kh) {
      if (kdata[m] > .9F) {
        kerPacked[lastCol]|=0x1;
      }
    }
  }
  return kerPacked;
}","/** 
 * pack kernel into integers by row, aligned to the right; extra bits on the left are filled with 0 bits
 * @params  kernel - the given kernel (already rotated)
 * @returns an integer array of ints from packed kernel data
 */
private final int[] packKernel(KernelJAI kernel){
  int kw=kernel.getWidth();
  int kh=kernel.getHeight();
  int kwPack=(31 + kw) / 32;
  int kerPacked[]=new int[kwPack * kh];
  float[] kdata=kernel.getKernelData();
  for (int j=0; j < kw; j++) {
    int m=j;
    int lastCol=kwPack - 1;
    bitShiftMatrixLeft(kerPacked,kh,kwPack);
    for (int i=0; i < kh; i++, lastCol+=kwPack, m+=kw) {
      if (kdata[m] > .9F) {
        kerPacked[lastCol]|=0x1;
      }
    }
  }
  return kerPacked;
}",0.9986130374479888
154042,"/** 
 * pack kernel into integers by row, aligned to the right; extra bits on the left are filled with 0 bits
 * @params  kernel - the given kernel (already rotated)
 * @returns an integer array of ints from packed kernel data
 */
private final int[] packKernel(KernelJAI kernel){
  int kw=kernel.getWidth();
  int kh=kernel.getHeight();
  int kwPack=(31 + kw) / 32;
  int kerPacked[]=new int[kwPack * kh];
  float[] kdata=kernel.getKernelData();
  for (int j=0; j < kw; j++) {
    int m=j;
    int lastCol=kwPack - 1;
    bitShiftMatrixLeft(kerPacked,kh,kwPack);
    for (int i=0; i < kh; i++, lastCol+=kwPack, m+=kh) {
      if (kdata[m] > .9F) {
        kerPacked[lastCol]|=0x1;
      }
    }
  }
  return kerPacked;
}","/** 
 * pack kernel into integers by row, aligned to the right; extra bits on the left are filled with 0 bits
 * @params  kernel - the given kernel (already rotated)
 * @returns an integer array of ints from packed kernel data
 */
private final int[] packKernel(KernelJAI kernel){
  int kw=kernel.getWidth();
  int kh=kernel.getHeight();
  int kwPack=(31 + kw) / 32;
  int kerPacked[]=new int[kwPack * kh];
  float[] kdata=kernel.getKernelData();
  for (int j=0; j < kw; j++) {
    int m=j;
    int lastCol=kwPack - 1;
    bitShiftMatrixLeft(kerPacked,kh,kwPack);
    for (int i=0; i < kh; i++, lastCol+=kwPack, m+=kw) {
      if (kdata[m] > .9F) {
        kerPacked[lastCol]|=0x1;
      }
    }
  }
  return kerPacked;
}",0.9986130374479888
154043,"/** 
 * Encodes a RenderedImage and writes the output to the OutputStream associated with this ImageEncoder.
 */
public void encode(RenderedImage im) throws IOException {
  SampleModel sampleModel=im.getSampleModel();
  ColorModel colorModel=im.getColorModel();
  int numBands=colorModel.getNumColorComponents();
  int transType=sampleModel.getTransferType();
  if (((transType != DataBuffer.TYPE_BYTE) && !CodecUtils.isPackedByteImage(im)) || ((numBands != 1) && (numBands != 3))) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int cspaceType=colorModel.getColorSpace().getType();
  if (cspaceType != ColorSpace.TYPE_GRAY && cspaceType != ColorSpace.TYPE_RGB) {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  BufferedImage bi;
  if (im instanceof BufferedImage) {
    bi=(BufferedImage)im;
  }
 else {
    Raster ras;
    if (im.getNumXTiles() == 1 && im.getNumYTiles() == 1) {
      ras=im.getTile(im.getMinTileX(),im.getMinTileY());
    }
 else {
      WritableRaster target=sampleModel.getSampleSize(0) == 8 ? Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,im.getWidth(),im.getHeight(),sampleModel.getNumBands(),new Point(im.getMinX(),im.getMinY())) : null;
      ras=im.copyData(target);
    }
    WritableRaster wRas;
    if (ras instanceof WritableRaster) {
      wRas=(WritableRaster)ras;
    }
 else {
      wRas=Raster.createWritableRaster(ras.getSampleModel(),ras.getDataBuffer(),new Point(ras.getSampleModelTranslateX(),ras.getSampleModelTranslateY()));
    }
    if (wRas.getMinX() != 0 || wRas.getMinY() != 0 || wRas.getWidth() != im.getWidth() || wRas.getHeight() != im.getHeight())     wRas=wRas.createWritableChild(wRas.getMinX(),wRas.getMinY(),im.getWidth(),im.getHeight(),0,0,null);
    bi=new BufferedImage(colorModel,wRas,false,null);
  }
  if (colorModel instanceof IndexColorModel) {
    IndexColorModel icm=(IndexColorModel)colorModel;
    bi=icm.convertToIntDiscrete(bi.getRaster(),false);
    if (bi.getSampleModel().getNumBands() == 4) {
      WritableRaster rgbaRas=bi.getRaster();
      WritableRaster rgbRas=rgbaRas.createWritableChild(0,0,bi.getWidth(),bi.getHeight(),0,0,new int[]{0,1,2});
      PackedColorModel pcm=(PackedColorModel)bi.getColorModel();
      int bits=pcm.getComponentSize(0) + pcm.getComponentSize(1) + pcm.getComponentSize(2);
      DirectColorModel dcm=new DirectColorModel(bits,pcm.getMask(0),pcm.getMask(1),pcm.getMask(2));
      bi=new BufferedImage(dcm,rgbRas,false,null);
    }
  }
  com.sun.image.codec.jpeg.JPEGEncodeParam j2dEP=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(bi);
  if (jaiEP != null) {
    modifyEncodeParam(jaiEP,j2dEP,numBands);
  }
  com.sun.image.codec.jpeg.JPEGImageEncoder encoder;
  encoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(output,j2dEP);
  try {
    encoder.encode(bi);
  }
 catch (  IOException e) {
    String message=JaiI18N.getString(""String_Node_Str"");
    ImagingListenerProxy.errorOccurred(message,new ImagingException(message,e),this,false);
  }
}","/** 
 * Encodes a RenderedImage and writes the output to the OutputStream associated with this ImageEncoder.
 */
public void encode(RenderedImage im) throws IOException {
  SampleModel sampleModel=im.getSampleModel();
  ColorModel colorModel=im.getColorModel();
  int numBands=colorModel.getNumColorComponents();
  int transType=sampleModel.getTransferType();
  if (((transType != DataBuffer.TYPE_BYTE) && !CodecUtils.isPackedByteImage(im)) || ((numBands != 1) && (numBands != 3))) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int cspaceType=colorModel.getColorSpace().getType();
  if (cspaceType != ColorSpace.TYPE_GRAY && cspaceType != ColorSpace.TYPE_RGB) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  BufferedImage bi;
  if (im instanceof BufferedImage) {
    bi=(BufferedImage)im;
  }
 else {
    Raster ras;
    if (im.getNumXTiles() == 1 && im.getNumYTiles() == 1) {
      ras=im.getTile(im.getMinTileX(),im.getMinTileY());
    }
 else {
      WritableRaster target=sampleModel.getSampleSize(0) == 8 ? Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,im.getWidth(),im.getHeight(),sampleModel.getNumBands(),new Point(im.getMinX(),im.getMinY())) : null;
      ras=im.copyData(target);
    }
    WritableRaster wRas;
    if (ras instanceof WritableRaster) {
      wRas=(WritableRaster)ras;
    }
 else {
      wRas=Raster.createWritableRaster(ras.getSampleModel(),ras.getDataBuffer(),new Point(ras.getSampleModelTranslateX(),ras.getSampleModelTranslateY()));
    }
    if (wRas.getMinX() != 0 || wRas.getMinY() != 0 || wRas.getWidth() != im.getWidth() || wRas.getHeight() != im.getHeight())     wRas=wRas.createWritableChild(wRas.getMinX(),wRas.getMinY(),im.getWidth(),im.getHeight(),0,0,null);
    bi=new BufferedImage(colorModel,wRas,false,null);
  }
  if (colorModel instanceof IndexColorModel) {
    IndexColorModel icm=(IndexColorModel)colorModel;
    bi=icm.convertToIntDiscrete(bi.getRaster(),false);
    if (bi.getSampleModel().getNumBands() == 4) {
      WritableRaster rgbaRas=bi.getRaster();
      WritableRaster rgbRas=rgbaRas.createWritableChild(0,0,bi.getWidth(),bi.getHeight(),0,0,new int[]{0,1,2});
      PackedColorModel pcm=(PackedColorModel)bi.getColorModel();
      int bits=pcm.getComponentSize(0) + pcm.getComponentSize(1) + pcm.getComponentSize(2);
      DirectColorModel dcm=new DirectColorModel(bits,pcm.getMask(0),pcm.getMask(1),pcm.getMask(2));
      bi=new BufferedImage(dcm,rgbRas,false,null);
    }
  }
  com.sun.image.codec.jpeg.JPEGEncodeParam j2dEP=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(bi);
  if (jaiEP != null) {
    modifyEncodeParam(jaiEP,j2dEP,numBands);
  }
  com.sun.image.codec.jpeg.JPEGImageEncoder encoder;
  encoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(output,j2dEP);
  try {
    encoder.encode(bi);
  }
 catch (  IOException e) {
    String message=JaiI18N.getString(""String_Node_Str"");
    ImagingListenerProxy.errorOccurred(message,new ImagingException(message,e),this,false);
  }
}",0.996869335969682
154044,"public void decode2D(byte[] buffer,byte compData[],int startX,int height,long tiffT4Options){
  this.data=compData;
  compression=3;
  bitPointer=0;
  bytePointer=0;
  int scanlineStride=(w + 7) / 8;
  int a0, a1, b1, b2;
  int[] b=new int[2];
  int entry, code, bits, color;
  boolean isWhite;
  int currIndex=0;
  int temp[];
  oneD=(int)(tiffT4Options & 0x01);
  uncompressedMode=(int)((tiffT4Options & 0x02) >> 1);
  fillBits=(int)((tiffT4Options & 0x04) >> 2);
  if (readEOL(true) != 1) {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  int lineOffset=0;
  int bitOffset;
  decodeNextScanline(buffer,lineOffset,startX);
  lineOffset+=scanlineStride;
  for (int lines=1; lines < height; lines++) {
    if (readEOL(false) == 0) {
      temp=prevChangingElems;
      prevChangingElems=currChangingElems;
      currChangingElems=temp;
      currIndex=0;
      a0=-1;
      isWhite=true;
      bitOffset=startX;
      lastChangingElement=0;
      while (bitOffset < w) {
        getNextChangingElement(a0,isWhite,b);
        b1=b[0];
        b2=b[1];
        entry=nextLesserThan8Bits(7);
        entry=(int)(twoDCodes[entry] & 0xff);
        code=(entry & 0x78) >>> 3;
        bits=entry & 0x07;
        if (code == 0) {
          if (!isWhite) {
            setToBlack(buffer,lineOffset,bitOffset,b2 - bitOffset);
          }
          bitOffset=a0=b2;
          updatePointer(7 - bits);
        }
 else         if (code == 1) {
          updatePointer(7 - bits);
          int number;
          if (isWhite) {
            number=decodeWhiteCodeWord();
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
            number=decodeBlackCodeWord();
            setToBlack(buffer,lineOffset,bitOffset,number);
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
          }
 else {
            number=decodeBlackCodeWord();
            setToBlack(buffer,lineOffset,bitOffset,number);
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
            number=decodeWhiteCodeWord();
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
          }
          a0=bitOffset;
        }
 else         if (code <= 8) {
          a1=b1 + (code - 5);
          currChangingElems[currIndex++]=a1;
          if (!isWhite) {
            setToBlack(buffer,lineOffset,bitOffset,a1 - bitOffset);
          }
          bitOffset=a0=a1;
          isWhite=!isWhite;
          updatePointer(7 - bits);
        }
 else {
          throw new Error(JaiI18N.getString(""String_Node_Str""));
        }
      }
      currChangingElems[currIndex++]=bitOffset;
      changingElemSize=currIndex;
    }
 else {
      decodeNextScanline(buffer,lineOffset,startX);
    }
    lineOffset+=scanlineStride;
  }
}","public void decode2D(byte[] buffer,byte compData[],int startX,int height,long tiffT4Options){
  this.data=compData;
  compression=3;
  bitPointer=0;
  bytePointer=0;
  int scanlineStride=(w + 7) / 8;
  int a0, a1, b1, b2;
  int[] b=new int[2];
  int entry, code, bits, color;
  boolean isWhite;
  int currIndex=0;
  int temp[];
  oneD=(int)(tiffT4Options & 0x01);
  uncompressedMode=(int)((tiffT4Options & 0x02) >> 1);
  fillBits=(int)((tiffT4Options & 0x04) >> 2);
  if (readEOL(true) != 1) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int lineOffset=0;
  int bitOffset;
  decodeNextScanline(buffer,lineOffset,startX);
  lineOffset+=scanlineStride;
  for (int lines=1; lines < height; lines++) {
    if (readEOL(false) == 0) {
      temp=prevChangingElems;
      prevChangingElems=currChangingElems;
      currChangingElems=temp;
      currIndex=0;
      a0=-1;
      isWhite=true;
      bitOffset=startX;
      lastChangingElement=0;
      while (bitOffset < w) {
        getNextChangingElement(a0,isWhite,b);
        b1=b[0];
        b2=b[1];
        entry=nextLesserThan8Bits(7);
        entry=(int)(twoDCodes[entry] & 0xff);
        code=(entry & 0x78) >>> 3;
        bits=entry & 0x07;
        if (code == 0) {
          if (!isWhite) {
            setToBlack(buffer,lineOffset,bitOffset,b2 - bitOffset);
          }
          bitOffset=a0=b2;
          updatePointer(7 - bits);
        }
 else         if (code == 1) {
          updatePointer(7 - bits);
          int number;
          if (isWhite) {
            number=decodeWhiteCodeWord();
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
            number=decodeBlackCodeWord();
            setToBlack(buffer,lineOffset,bitOffset,number);
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
          }
 else {
            number=decodeBlackCodeWord();
            setToBlack(buffer,lineOffset,bitOffset,number);
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
            number=decodeWhiteCodeWord();
            bitOffset+=number;
            currChangingElems[currIndex++]=bitOffset;
          }
          a0=bitOffset;
        }
 else         if (code <= 8) {
          a1=b1 + (code - 5);
          currChangingElems[currIndex++]=a1;
          if (!isWhite) {
            setToBlack(buffer,lineOffset,bitOffset,a1 - bitOffset);
          }
          bitOffset=a0=a1;
          isWhite=!isWhite;
          updatePointer(7 - bits);
        }
 else {
          throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
        }
      }
      currChangingElems[currIndex++]=bitOffset;
      changingElemSize=currIndex;
    }
 else {
      decodeNextScanline(buffer,lineOffset,startX);
    }
    lineOffset+=scanlineStride;
  }
}",0.9932838458819372
154045,"private int nextNBits(int bitsToGet){
  byte b, next, next2next;
  int l=data.length - 1;
  int bp=this.bytePointer;
  if (fillOrder == 1) {
    b=data[bp];
    if (bp == l) {
      next=0x00;
      next2next=0x00;
    }
 else     if ((bp + 1) == l) {
      next=data[bp + 1];
      next2next=0x00;
    }
 else {
      next=data[bp + 1];
      next2next=data[bp + 2];
    }
  }
 else   if (fillOrder == 2) {
    b=flipTable[data[bp] & 0xff];
    if (bp == l) {
      next=0x00;
      next2next=0x00;
    }
 else     if ((bp + 1) == l) {
      next=flipTable[data[bp + 1] & 0xff];
      next2next=0x00;
    }
 else {
      next=flipTable[data[bp + 1] & 0xff];
      next2next=flipTable[data[bp + 2] & 0xff];
    }
  }
 else {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  int bitsLeft=8 - bitPointer;
  int bitsFromNextByte=bitsToGet - bitsLeft;
  int bitsFromNext2NextByte=0;
  if (bitsFromNextByte > 8) {
    bitsFromNext2NextByte=bitsFromNextByte - 8;
    bitsFromNextByte=8;
  }
  bytePointer++;
  int i1=(b & table1[bitsLeft]) << (bitsToGet - bitsLeft);
  int i2=(next & table2[bitsFromNextByte]) >>> (8 - bitsFromNextByte);
  int i3=0;
  if (bitsFromNext2NextByte != 0) {
    i2<<=bitsFromNext2NextByte;
    i3=(next2next & table2[bitsFromNext2NextByte]) >>> (8 - bitsFromNext2NextByte);
    i2|=i3;
    bytePointer++;
    bitPointer=bitsFromNext2NextByte;
  }
 else {
    if (bitsFromNextByte == 8) {
      bitPointer=0;
      bytePointer++;
    }
 else {
      bitPointer=bitsFromNextByte;
    }
  }
  int i=i1 | i2;
  return i;
}","private int nextNBits(int bitsToGet){
  byte b, next, next2next;
  int l=data.length - 1;
  int bp=this.bytePointer;
  if (fillOrder == 1) {
    b=data[bp];
    if (bp == l) {
      next=0x00;
      next2next=0x00;
    }
 else     if ((bp + 1) == l) {
      next=data[bp + 1];
      next2next=0x00;
    }
 else {
      next=data[bp + 1];
      next2next=data[bp + 2];
    }
  }
 else   if (fillOrder == 2) {
    b=flipTable[data[bp] & 0xff];
    if (bp == l) {
      next=0x00;
      next2next=0x00;
    }
 else     if ((bp + 1) == l) {
      next=flipTable[data[bp + 1] & 0xff];
      next2next=0x00;
    }
 else {
      next=flipTable[data[bp + 1] & 0xff];
      next2next=flipTable[data[bp + 2] & 0xff];
    }
  }
 else {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int bitsLeft=8 - bitPointer;
  int bitsFromNextByte=bitsToGet - bitsLeft;
  int bitsFromNext2NextByte=0;
  if (bitsFromNextByte > 8) {
    bitsFromNext2NextByte=bitsFromNextByte - 8;
    bitsFromNextByte=8;
  }
  bytePointer++;
  int i1=(b & table1[bitsLeft]) << (bitsToGet - bitsLeft);
  int i2=(next & table2[bitsFromNextByte]) >>> (8 - bitsFromNextByte);
  int i3=0;
  if (bitsFromNext2NextByte != 0) {
    i2<<=bitsFromNext2NextByte;
    i3=(next2next & table2[bitsFromNext2NextByte]) >>> (8 - bitsFromNext2NextByte);
    i2|=i3;
    bytePointer++;
    bitPointer=bitsFromNext2NextByte;
  }
 else {
    if (bitsFromNextByte == 8) {
      bitPointer=0;
      bytePointer++;
    }
 else {
      bitPointer=bitsFromNextByte;
    }
  }
  int i=i1 | i2;
  return i;
}",0.9939161063080372
154046,"private int readEOL(boolean isFirstEOL){
  if (oneD == 0) {
    if (!seekEOL()) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
  }
  if (fillBits == 0) {
    int next12Bits=nextNBits(12);
    if (isFirstEOL && next12Bits == 0) {
      if (nextNBits(4) == 1) {
        fillBits=1;
        return 1;
      }
    }
    if (next12Bits != 1) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
  }
 else   if (fillBits == 1) {
    int bitsLeft=8 - bitPointer;
    if (nextNBits(bitsLeft) != 0) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
    if (bitsLeft < 4) {
      if (nextNBits(8) != 0) {
        throw new Error(JaiI18N.getString(""String_Node_Str""));
      }
    }
    int next8=nextNBits(8);
    if (isFirstEOL && (next8 & 0xf0) == 0x10) {
      fillBits=0;
      updatePointer(4);
    }
 else {
      while (next8 != 1) {
        if (next8 != 0) {
          throw new Error(JaiI18N.getString(""String_Node_Str""));
        }
        next8=nextNBits(8);
      }
    }
  }
  if (oneD == 0) {
    return 1;
  }
 else {
    return nextLesserThan8Bits(1);
  }
}","private int readEOL(boolean isFirstEOL){
  if (oneD == 0) {
    if (!seekEOL()) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
  }
  if (fillBits == 0) {
    int next12Bits=nextNBits(12);
    if (isFirstEOL && next12Bits == 0) {
      if (nextNBits(4) == 1) {
        fillBits=1;
        return 1;
      }
    }
    if (next12Bits != 1) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
  }
 else   if (fillBits == 1) {
    int bitsLeft=8 - bitPointer;
    if (nextNBits(bitsLeft) != 0) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
    if (bitsLeft < 4) {
      if (nextNBits(8) != 0) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
    }
    int next8=nextNBits(8);
    if (isFirstEOL && (next8 & 0xf0) == 0x10) {
      fillBits=0;
      updatePointer(4);
    }
 else {
      while (next8 != 1) {
        if (next8 != 0) {
          throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
        }
        next8=nextNBits(8);
      }
    }
  }
  if (oneD == 0) {
    return 1;
  }
 else {
    return nextLesserThan8Bits(1);
  }
}",0.9586056644880174
154047,"private int nextLesserThan8Bits(int bitsToGet){
  byte b, next;
  int l=data.length - 1;
  int bp=this.bytePointer;
  if (fillOrder == 1) {
    b=data[bp];
    if (bp == l) {
      next=0x00;
    }
 else {
      next=data[bp + 1];
    }
  }
 else   if (fillOrder == 2) {
    b=flipTable[data[bp] & 0xff];
    if (bp == l) {
      next=0x00;
    }
 else {
      next=flipTable[data[bp + 1] & 0xff];
    }
  }
 else {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  int bitsLeft=8 - bitPointer;
  int bitsFromNextByte=bitsToGet - bitsLeft;
  int shift=bitsLeft - bitsToGet;
  int i1, i2;
  if (shift >= 0) {
    i1=(b & table1[bitsLeft]) >>> shift;
    bitPointer+=bitsToGet;
    if (bitPointer == 8) {
      bitPointer=0;
      bytePointer++;
    }
  }
 else {
    i1=(b & table1[bitsLeft]) << (-shift);
    i2=(next & table2[bitsFromNextByte]) >>> (8 - bitsFromNextByte);
    i1|=i2;
    bytePointer++;
    bitPointer=bitsFromNextByte;
  }
  return i1;
}","private int nextLesserThan8Bits(int bitsToGet){
  byte b, next;
  int l=data.length - 1;
  int bp=this.bytePointer;
  if (fillOrder == 1) {
    b=data[bp];
    if (bp == l) {
      next=0x00;
    }
 else {
      next=data[bp + 1];
    }
  }
 else   if (fillOrder == 2) {
    b=flipTable[data[bp] & 0xff];
    if (bp == l) {
      next=0x00;
    }
 else {
      next=flipTable[data[bp + 1] & 0xff];
    }
  }
 else {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int bitsLeft=8 - bitPointer;
  int bitsFromNextByte=bitsToGet - bitsLeft;
  int shift=bitsLeft - bitsToGet;
  int i1, i2;
  if (shift >= 0) {
    i1=(b & table1[bitsLeft]) >>> shift;
    bitPointer+=bitsToGet;
    if (bitPointer == 8) {
      bitPointer=0;
      bytePointer++;
    }
  }
 else {
    i1=(b & table1[bitsLeft]) << (-shift);
    i2=(next & table2[bitsFromNextByte]) >>> (8 - bitsFromNextByte);
    i1|=i2;
    bytePointer++;
    bitPointer=bitsFromNextByte;
  }
  return i1;
}",0.9902713773681516
154048,"private int decodeBlackCodeWord(){
  int current, entry, bits, isT, twoBits, code=-1;
  int runLength=0;
  boolean isWhite=false;
  while (!isWhite) {
    current=nextLesserThan8Bits(4);
    entry=initBlack[current];
    isT=entry & 0x0001;
    bits=(entry >>> 1) & 0x000f;
    code=(entry >>> 5) & 0x07ff;
    if (code == 100) {
      current=nextNBits(9);
      entry=black[current];
      isT=entry & 0x0001;
      bits=(entry >>> 1) & 0x000f;
      code=(entry >>> 5) & 0x07ff;
      if (bits == 12) {
        updatePointer(5);
        current=nextLesserThan8Bits(4);
        entry=additionalMakeup[current];
        bits=(entry >>> 1) & 0x07;
        code=(entry >>> 4) & 0x0fff;
        runLength+=code;
        updatePointer(4 - bits);
      }
 else       if (bits == 15) {
        throw new Error(JaiI18N.getString(""String_Node_Str""));
      }
 else {
        runLength+=code;
        updatePointer(9 - bits);
        if (isT == 0) {
          isWhite=true;
        }
      }
    }
 else     if (code == 200) {
      current=nextLesserThan8Bits(2);
      entry=twoBitBlack[current];
      code=(entry >>> 5) & 0x07ff;
      runLength+=code;
      bits=(entry >>> 1) & 0x0f;
      updatePointer(2 - bits);
      isWhite=true;
    }
 else {
      runLength+=code;
      updatePointer(4 - bits);
      isWhite=true;
    }
  }
  return runLength;
}","private int decodeBlackCodeWord(){
  int current, entry, bits, isT, twoBits, code=-1;
  int runLength=0;
  boolean isWhite=false;
  while (!isWhite) {
    current=nextLesserThan8Bits(4);
    entry=initBlack[current];
    isT=entry & 0x0001;
    bits=(entry >>> 1) & 0x000f;
    code=(entry >>> 5) & 0x07ff;
    if (code == 100) {
      current=nextNBits(9);
      entry=black[current];
      isT=entry & 0x0001;
      bits=(entry >>> 1) & 0x000f;
      code=(entry >>> 5) & 0x07ff;
      if (bits == 12) {
        updatePointer(5);
        current=nextLesserThan8Bits(4);
        entry=additionalMakeup[current];
        bits=(entry >>> 1) & 0x07;
        code=(entry >>> 4) & 0x0fff;
        runLength+=code;
        updatePointer(4 - bits);
      }
 else       if (bits == 15) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
 else {
        runLength+=code;
        updatePointer(9 - bits);
        if (isT == 0) {
          isWhite=true;
        }
      }
    }
 else     if (code == 200) {
      current=nextLesserThan8Bits(2);
      entry=twoBitBlack[current];
      code=(entry >>> 5) & 0x07ff;
      runLength+=code;
      bits=(entry >>> 1) & 0x0f;
      updatePointer(2 - bits);
      isWhite=true;
    }
 else {
      runLength+=code;
      updatePointer(4 - bits);
      isWhite=true;
    }
  }
  return runLength;
}",0.993001841620626
154049,"public void decodeNextScanline(byte[] buffer,int lineOffset,int bitOffset){
  int bits=0, code=0, isT=0;
  int current, entry, twoBits;
  boolean isWhite=true;
  int dstEnd=0;
  changingElemSize=0;
  while (bitOffset < w) {
    while (isWhite) {
      current=nextNBits(10);
      entry=white[current];
      isT=entry & 0x0001;
      bits=(entry >>> 1) & 0x0f;
      if (bits == 12) {
        twoBits=nextLesserThan8Bits(2);
        current=((current << 2) & 0x000c) | twoBits;
        entry=additionalMakeup[current];
        bits=(entry >>> 1) & 0x07;
        code=(entry >>> 4) & 0x0fff;
        bitOffset+=code;
        updatePointer(4 - bits);
      }
 else       if (bits == 0) {
        throw new Error(JaiI18N.getString(""String_Node_Str""));
      }
 else       if (bits == 15) {
        updatePointer(12);
        return;
      }
 else {
        code=(entry >>> 5) & 0x07ff;
        bitOffset+=code;
        updatePointer(10 - bits);
        if (isT == 0) {
          isWhite=false;
          currChangingElems[changingElemSize++]=bitOffset;
        }
      }
    }
    if (bitOffset == w) {
      if (compression == 2) {
        advancePointer();
      }
      break;
    }
    while (isWhite == false) {
      current=nextLesserThan8Bits(4);
      entry=initBlack[current];
      isT=entry & 0x0001;
      bits=(entry >>> 1) & 0x000f;
      code=(entry >>> 5) & 0x07ff;
      if (code == 100) {
        current=nextNBits(9);
        entry=black[current];
        isT=entry & 0x0001;
        bits=(entry >>> 1) & 0x000f;
        code=(entry >>> 5) & 0x07ff;
        if (bits == 12) {
          updatePointer(5);
          current=nextLesserThan8Bits(4);
          entry=additionalMakeup[current];
          bits=(entry >>> 1) & 0x07;
          code=(entry >>> 4) & 0x0fff;
          setToBlack(buffer,lineOffset,bitOffset,code);
          bitOffset+=code;
          updatePointer(4 - bits);
        }
 else         if (bits == 15) {
          updatePointer(12);
          return;
        }
 else {
          setToBlack(buffer,lineOffset,bitOffset,code);
          bitOffset+=code;
          updatePointer(9 - bits);
          if (isT == 0) {
            isWhite=true;
            currChangingElems[changingElemSize++]=bitOffset;
          }
        }
      }
 else       if (code == 200) {
        current=nextLesserThan8Bits(2);
        entry=twoBitBlack[current];
        code=(entry >>> 5) & 0x07ff;
        bits=(entry >>> 1) & 0x0f;
        setToBlack(buffer,lineOffset,bitOffset,code);
        bitOffset+=code;
        updatePointer(2 - bits);
        isWhite=true;
        currChangingElems[changingElemSize++]=bitOffset;
      }
 else {
        setToBlack(buffer,lineOffset,bitOffset,code);
        bitOffset+=code;
        updatePointer(4 - bits);
        isWhite=true;
        currChangingElems[changingElemSize++]=bitOffset;
      }
    }
    if (bitOffset == w) {
      if (compression == 2) {
        advancePointer();
      }
      break;
    }
  }
  currChangingElems[changingElemSize++]=bitOffset;
}","public void decodeNextScanline(byte[] buffer,int lineOffset,int bitOffset){
  int bits=0, code=0, isT=0;
  int current, entry, twoBits;
  boolean isWhite=true;
  int dstEnd=0;
  changingElemSize=0;
  while (bitOffset < w) {
    while (isWhite) {
      current=nextNBits(10);
      entry=white[current];
      isT=entry & 0x0001;
      bits=(entry >>> 1) & 0x0f;
      if (bits == 12) {
        twoBits=nextLesserThan8Bits(2);
        current=((current << 2) & 0x000c) | twoBits;
        entry=additionalMakeup[current];
        bits=(entry >>> 1) & 0x07;
        code=(entry >>> 4) & 0x0fff;
        bitOffset+=code;
        updatePointer(4 - bits);
      }
 else       if (bits == 0) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
 else       if (bits == 15) {
        updatePointer(12);
        return;
      }
 else {
        code=(entry >>> 5) & 0x07ff;
        bitOffset+=code;
        updatePointer(10 - bits);
        if (isT == 0) {
          isWhite=false;
          currChangingElems[changingElemSize++]=bitOffset;
        }
      }
    }
    if (bitOffset == w) {
      if (compression == 2) {
        advancePointer();
      }
      break;
    }
    while (isWhite == false) {
      current=nextLesserThan8Bits(4);
      entry=initBlack[current];
      isT=entry & 0x0001;
      bits=(entry >>> 1) & 0x000f;
      code=(entry >>> 5) & 0x07ff;
      if (code == 100) {
        current=nextNBits(9);
        entry=black[current];
        isT=entry & 0x0001;
        bits=(entry >>> 1) & 0x000f;
        code=(entry >>> 5) & 0x07ff;
        if (bits == 12) {
          updatePointer(5);
          current=nextLesserThan8Bits(4);
          entry=additionalMakeup[current];
          bits=(entry >>> 1) & 0x07;
          code=(entry >>> 4) & 0x0fff;
          setToBlack(buffer,lineOffset,bitOffset,code);
          bitOffset+=code;
          updatePointer(4 - bits);
        }
 else         if (bits == 15) {
          updatePointer(12);
          return;
        }
 else {
          setToBlack(buffer,lineOffset,bitOffset,code);
          bitOffset+=code;
          updatePointer(9 - bits);
          if (isT == 0) {
            isWhite=true;
            currChangingElems[changingElemSize++]=bitOffset;
          }
        }
      }
 else       if (code == 200) {
        current=nextLesserThan8Bits(2);
        entry=twoBitBlack[current];
        code=(entry >>> 5) & 0x07ff;
        bits=(entry >>> 1) & 0x0f;
        setToBlack(buffer,lineOffset,bitOffset,code);
        bitOffset+=code;
        updatePointer(2 - bits);
        isWhite=true;
        currChangingElems[changingElemSize++]=bitOffset;
      }
 else {
        setToBlack(buffer,lineOffset,bitOffset,code);
        bitOffset+=code;
        updatePointer(4 - bits);
        isWhite=true;
        currChangingElems[changingElemSize++]=bitOffset;
      }
    }
    if (bitOffset == w) {
      if (compression == 2) {
        advancePointer();
      }
      break;
    }
  }
  currChangingElems[changingElemSize++]=bitOffset;
}",0.9968652037617556
154050,"public synchronized void decodeT6(byte[] buffer,byte[] compData,int startX,int height,long tiffT6Options){
  this.data=compData;
  compression=4;
  bitPointer=0;
  bytePointer=0;
  int scanlineStride=(w + 7) / 8;
  int bufferOffset=0;
  int a0, a1, b1, b2;
  int entry, code, bits;
  byte color;
  boolean isWhite;
  int currIndex;
  int temp[];
  int[] b=new int[2];
  uncompressedMode=(int)((tiffT6Options & 0x02) >> 1);
  int[] cce=currChangingElems;
  changingElemSize=0;
  cce[changingElemSize++]=w;
  cce[changingElemSize++]=w;
  int lineOffset=0;
  int bitOffset;
  for (int lines=0; lines < height; lines++) {
    a0=-1;
    isWhite=true;
    temp=prevChangingElems;
    prevChangingElems=currChangingElems;
    cce=currChangingElems=temp;
    currIndex=0;
    bitOffset=startX;
    lastChangingElement=0;
    while (bitOffset < w) {
      getNextChangingElement(a0,isWhite,b);
      b1=b[0];
      b2=b[1];
      entry=nextLesserThan8Bits(7);
      entry=(int)(twoDCodes[entry] & 0xff);
      code=(entry & 0x78) >>> 3;
      bits=entry & 0x07;
      if (code == 0) {
        if (!isWhite) {
          if (b2 > w) {
            b2=w;
          }
          setToBlack(buffer,lineOffset,bitOffset,b2 - bitOffset);
        }
        bitOffset=a0=b2;
        updatePointer(7 - bits);
      }
 else       if (code == 1) {
        updatePointer(7 - bits);
        int number;
        if (isWhite) {
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeBlackCodeWord();
          if (number > w - bitOffset) {
            number=w - bitOffset;
          }
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
 else {
          number=decodeBlackCodeWord();
          if (number > w - bitOffset) {
            number=w - bitOffset;
          }
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
        a0=bitOffset;
      }
 else       if (code <= 8) {
        a1=b1 + (code - 5);
        cce[currIndex++]=a1;
        if (!isWhite) {
          if (a1 > w) {
            a1=w;
          }
          setToBlack(buffer,lineOffset,bitOffset,a1 - bitOffset);
        }
        bitOffset=a0=a1;
        isWhite=!isWhite;
        updatePointer(7 - bits);
      }
 else       if (code == 11) {
        if (nextLesserThan8Bits(3) != 7) {
          throw new Error(JaiI18N.getString(""String_Node_Str""));
        }
        int zeros=0;
        boolean exit=false;
        while (!exit) {
          while (nextLesserThan8Bits(1) != 1) {
            zeros++;
          }
          if (zeros > 5) {
            zeros=zeros - 6;
            if (!isWhite && (zeros > 0)) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            if (zeros > 0) {
              isWhite=true;
            }
            if (nextLesserThan8Bits(1) == 0) {
              if (!isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=true;
            }
 else {
              if (isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=false;
            }
            exit=true;
          }
          if (zeros == 5) {
            if (!isWhite) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            isWhite=true;
          }
 else {
            bitOffset+=zeros;
            cce[currIndex++]=bitOffset;
            setToBlack(buffer,lineOffset,bitOffset,1);
            ++bitOffset;
            isWhite=false;
          }
        }
      }
 else {
        throw new Error(JaiI18N.getString(""String_Node_Str""));
      }
    }
    if (currIndex <= w)     cce[currIndex++]=bitOffset;
    changingElemSize=currIndex;
    lineOffset+=scanlineStride;
  }
}","public synchronized void decodeT6(byte[] buffer,byte[] compData,int startX,int height,long tiffT6Options){
  this.data=compData;
  compression=4;
  bitPointer=0;
  bytePointer=0;
  int scanlineStride=(w + 7) / 8;
  int bufferOffset=0;
  int a0, a1, b1, b2;
  int entry, code, bits;
  byte color;
  boolean isWhite;
  int currIndex;
  int temp[];
  int[] b=new int[2];
  uncompressedMode=(int)((tiffT6Options & 0x02) >> 1);
  int[] cce=currChangingElems;
  changingElemSize=0;
  cce[changingElemSize++]=w;
  cce[changingElemSize++]=w;
  int lineOffset=0;
  int bitOffset;
  for (int lines=0; lines < height; lines++) {
    a0=-1;
    isWhite=true;
    temp=prevChangingElems;
    prevChangingElems=currChangingElems;
    cce=currChangingElems=temp;
    currIndex=0;
    bitOffset=startX;
    lastChangingElement=0;
    while (bitOffset < w) {
      getNextChangingElement(a0,isWhite,b);
      b1=b[0];
      b2=b[1];
      entry=nextLesserThan8Bits(7);
      entry=(int)(twoDCodes[entry] & 0xff);
      code=(entry & 0x78) >>> 3;
      bits=entry & 0x07;
      if (code == 0) {
        if (!isWhite) {
          if (b2 > w) {
            b2=w;
          }
          setToBlack(buffer,lineOffset,bitOffset,b2 - bitOffset);
        }
        bitOffset=a0=b2;
        updatePointer(7 - bits);
      }
 else       if (code == 1) {
        updatePointer(7 - bits);
        int number;
        if (isWhite) {
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeBlackCodeWord();
          if (number > w - bitOffset) {
            number=w - bitOffset;
          }
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
 else {
          number=decodeBlackCodeWord();
          if (number > w - bitOffset) {
            number=w - bitOffset;
          }
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
        a0=bitOffset;
      }
 else       if (code <= 8) {
        a1=b1 + (code - 5);
        cce[currIndex++]=a1;
        if (!isWhite) {
          if (a1 > w) {
            a1=w;
          }
          setToBlack(buffer,lineOffset,bitOffset,a1 - bitOffset);
        }
        bitOffset=a0=a1;
        isWhite=!isWhite;
        updatePointer(7 - bits);
      }
 else       if (code == 11) {
        if (nextLesserThan8Bits(3) != 7) {
          throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
        }
        int zeros=0;
        boolean exit=false;
        while (!exit) {
          while (nextLesserThan8Bits(1) != 1) {
            zeros++;
          }
          if (zeros > 5) {
            zeros=zeros - 6;
            if (!isWhite && (zeros > 0)) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            if (zeros > 0) {
              isWhite=true;
            }
            if (nextLesserThan8Bits(1) == 0) {
              if (!isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=true;
            }
 else {
              if (isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=false;
            }
            exit=true;
          }
          if (zeros == 5) {
            if (!isWhite) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            isWhite=true;
          }
 else {
            bitOffset+=zeros;
            cce[currIndex++]=bitOffset;
            setToBlack(buffer,lineOffset,bitOffset,1);
            ++bitOffset;
            isWhite=false;
          }
        }
      }
 else {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
    }
    if (currIndex <= w)     cce[currIndex++]=bitOffset;
    changingElemSize=currIndex;
    lineOffset+=scanlineStride;
  }
}",0.9952923686818632
154051,"private int decodeWhiteCodeWord(){
  int current, entry, bits, isT, twoBits, code=-1;
  int runLength=0;
  boolean isWhite=true;
  while (isWhite) {
    current=nextNBits(10);
    entry=white[current];
    isT=entry & 0x0001;
    bits=(entry >>> 1) & 0x0f;
    if (bits == 12) {
      twoBits=nextLesserThan8Bits(2);
      current=((current << 2) & 0x000c) | twoBits;
      entry=additionalMakeup[current];
      bits=(entry >>> 1) & 0x07;
      code=(entry >>> 4) & 0x0fff;
      runLength+=code;
      updatePointer(4 - bits);
    }
 else     if (bits == 0) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
 else     if (bits == 15) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
 else {
      code=(entry >>> 5) & 0x07ff;
      runLength+=code;
      updatePointer(10 - bits);
      if (isT == 0) {
        isWhite=false;
      }
    }
  }
  return runLength;
}","private int decodeWhiteCodeWord(){
  int current, entry, bits, isT, twoBits, code=-1;
  int runLength=0;
  boolean isWhite=true;
  while (isWhite) {
    current=nextNBits(10);
    entry=white[current];
    isT=entry & 0x0001;
    bits=(entry >>> 1) & 0x0f;
    if (bits == 12) {
      twoBits=nextLesserThan8Bits(2);
      current=((current << 2) & 0x000c) | twoBits;
      entry=additionalMakeup[current];
      bits=(entry >>> 1) & 0x07;
      code=(entry >>> 4) & 0x0fff;
      runLength+=code;
      updatePointer(4 - bits);
    }
 else     if (bits == 0) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
 else     if (bits == 15) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
 else {
      code=(entry >>> 5) & 0x07ff;
      runLength+=code;
      updatePointer(10 - bits);
      if (isT == 0) {
        isWhite=false;
      }
    }
  }
  return runLength;
}",0.97928026172301
154052,"private int encode(RenderedImage im,TIFFEncodeParam encodeParam,int ifdOffset,boolean isLast) throws IOException {
  if (CodecUtils.isPackedByteImage(im)) {
    ColorModel sourceCM=im.getColorModel();
    ColorModel destCM=RasterFactory.createComponentColorModel(DataBuffer.TYPE_BYTE,sourceCM.getColorSpace(),sourceCM.hasAlpha(),sourceCM.isAlphaPremultiplied(),sourceCM.getTransparency());
    Point origin=new Point(im.getMinX(),im.getMinY());
    WritableRaster raster=Raster.createWritableRaster(destCM.createCompatibleSampleModel(im.getWidth(),im.getHeight()),origin);
    raster.setRect(im.getData());
    im=new SingleTileRenderedImage(raster,destCM);
  }
  int compression=encodeParam.getCompression();
  boolean isTiled=encodeParam.getWriteTiled();
  int minX=im.getMinX();
  int minY=im.getMinY();
  int width=im.getWidth();
  int height=im.getHeight();
  SampleModel sampleModel=im.getSampleModel();
  int sampleSize[]=sampleModel.getSampleSize();
  for (int i=1; i < sampleSize.length; i++) {
    if (sampleSize[i] != sampleSize[0]) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
  }
  int numBands=sampleModel.getNumBands();
  if ((sampleSize[0] == 1 || sampleSize[0] == 4) && numBands != 1) {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  int dataType=sampleModel.getDataType();
switch (dataType) {
case DataBuffer.TYPE_BYTE:
    if (sampleSize[0] != 1 && sampleSize[0] != 4 && sampleSize[0] != 8) {
      throw new Error(JaiI18N.getString(""String_Node_Str""));
    }
  break;
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_USHORT:
if (sampleSize[0] != 16) {
  throw new Error(JaiI18N.getString(""String_Node_Str""));
}
break;
case DataBuffer.TYPE_INT:
case DataBuffer.TYPE_FLOAT:
if (sampleSize[0] != 32) {
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
break;
default :
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
boolean dataTypeIsShort=dataType == DataBuffer.TYPE_SHORT || dataType == DataBuffer.TYPE_USHORT;
ColorModel colorModel=im.getColorModel();
if (colorModel != null && colorModel instanceof IndexColorModel && dataType != DataBuffer.TYPE_BYTE) {
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
IndexColorModel icm=null;
int sizeOfColormap=0;
int colormap[]=null;
int imageType=TIFF_UNSUPPORTED;
int numExtraSamples=0;
int extraSampleType=EXTRA_SAMPLE_UNSPECIFIED;
if (colorModel instanceof IndexColorModel) {
icm=(IndexColorModel)colorModel;
int mapSize=icm.getMapSize();
if (sampleSize[0] == 1 && numBands == 1) {
if (mapSize != 2) {
throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
}
byte r[]=new byte[mapSize];
icm.getReds(r);
byte g[]=new byte[mapSize];
icm.getGreens(g);
byte b[]=new byte[mapSize];
icm.getBlues(b);
if ((r[0] & 0xff) == 0 && (r[1] & 0xff) == 255 && (g[0] & 0xff) == 0 && (g[1] & 0xff) == 255 && (b[0] & 0xff) == 0 && (b[1] & 0xff) == 255) {
imageType=TIFF_BILEVEL_BLACK_IS_ZERO;
}
 else if ((r[0] & 0xff) == 255 && (r[1] & 0xff) == 0 && (g[0] & 0xff) == 255 && (g[1] & 0xff) == 0 && (b[0] & 0xff) == 255 && (b[1] & 0xff) == 0) {
imageType=TIFF_BILEVEL_WHITE_IS_ZERO;
}
 else {
imageType=TIFF_PALETTE;
}
}
 else if (numBands == 1) {
imageType=TIFF_PALETTE;
}
}
 else if (colorModel == null) {
if (sampleSize[0] == 1 && numBands == 1) {
imageType=TIFF_BILEVEL_BLACK_IS_ZERO;
}
 else {
imageType=TIFF_GENERIC;
if (numBands > 1) {
numExtraSamples=numBands - 1;
}
}
}
 else {
ColorSpace colorSpace=colorModel.getColorSpace();
switch (colorSpace.getType()) {
case ColorSpace.TYPE_CMYK:
imageType=TIFF_CMYK;
break;
case ColorSpace.TYPE_GRAY:
imageType=TIFF_GRAY;
break;
case ColorSpace.TYPE_Lab:
imageType=TIFF_CIELAB;
break;
case ColorSpace.TYPE_RGB:
if (compression == COMP_JPEG_TTN2 && encodeParam.getJPEGCompressRGBToYCbCr()) {
imageType=TIFF_YCBCR;
}
 else {
imageType=TIFF_RGB;
}
break;
case ColorSpace.TYPE_YCbCr:
imageType=TIFF_YCBCR;
break;
default :
imageType=TIFF_GENERIC;
break;
}
if (imageType == TIFF_GENERIC) {
numExtraSamples=numBands - 1;
}
 else if (numBands > 1) {
numExtraSamples=numBands - colorSpace.getNumComponents();
}
if (numExtraSamples == 1 && colorModel.hasAlpha()) {
extraSampleType=colorModel.isAlphaPremultiplied() ? EXTRA_SAMPLE_ASSOCIATED_ALPHA : EXTRA_SAMPLE_UNASSOCIATED_ALPHA;
}
}
if (imageType == TIFF_UNSUPPORTED) {
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
if (compression == COMP_JPEG_TTN2) {
if (imageType == TIFF_PALETTE) {
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
 else if (!(sampleSize[0] == 8 && (imageType == TIFF_GRAY || imageType == TIFF_RGB || imageType == TIFF_YCBCR))) {
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
}
if ((imageType != TIFF_BILEVEL_WHITE_IS_ZERO && imageType != TIFF_BILEVEL_BLACK_IS_ZERO) && (compression == COMP_GROUP3_1D || compression == COMP_GROUP3_2D || compression == COMP_GROUP4)) {
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
int photometricInterpretation=-1;
switch (imageType) {
case TIFF_BILEVEL_WHITE_IS_ZERO:
photometricInterpretation=0;
break;
case TIFF_BILEVEL_BLACK_IS_ZERO:
photometricInterpretation=1;
break;
case TIFF_GRAY:
case TIFF_GENERIC:
photometricInterpretation=1;
break;
case TIFF_PALETTE:
photometricInterpretation=3;
icm=(IndexColorModel)colorModel;
sizeOfColormap=icm.getMapSize();
byte r[]=new byte[sizeOfColormap];
icm.getReds(r);
byte g[]=new byte[sizeOfColormap];
icm.getGreens(g);
byte b[]=new byte[sizeOfColormap];
icm.getBlues(b);
int redIndex=0, greenIndex=sizeOfColormap;
int blueIndex=2 * sizeOfColormap;
colormap=new int[sizeOfColormap * 3];
for (int i=0; i < sizeOfColormap; i++) {
colormap[redIndex++]=(r[i] << 8) & 0xffff;
colormap[greenIndex++]=(g[i] << 8) & 0xffff;
colormap[blueIndex++]=(b[i] << 8) & 0xffff;
}
sizeOfColormap*=3;
break;
case TIFF_RGB:
photometricInterpretation=2;
break;
case TIFF_CMYK:
photometricInterpretation=5;
break;
case TIFF_YCBCR:
photometricInterpretation=6;
break;
case TIFF_CIELAB:
photometricInterpretation=8;
break;
default :
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
int tileWidth;
int tileHeight;
if (isTiled) {
tileWidth=encodeParam.getTileWidth() > 0 ? encodeParam.getTileWidth() : im.getTileWidth();
tileHeight=encodeParam.getTileHeight() > 0 ? encodeParam.getTileHeight() : im.getTileHeight();
}
 else {
tileWidth=width;
tileHeight=encodeParam.getTileHeight() > 0 ? encodeParam.getTileHeight() : DEFAULT_ROWS_PER_STRIP;
}
JPEGEncodeParam jep=null;
if (compression == COMP_JPEG_TTN2) {
jep=encodeParam.getJPEGEncodeParam();
int maxSubH=jep.getHorizontalSubsampling(0);
int maxSubV=jep.getVerticalSubsampling(0);
for (int i=1; i < numBands; i++) {
int subH=jep.getHorizontalSubsampling(i);
if (subH > maxSubH) {
maxSubH=subH;
}
int subV=jep.getVerticalSubsampling(i);
if (subV > maxSubV) {
maxSubV=subV;
}
}
int factorV=8 * maxSubV;
tileHeight=(int)((float)tileHeight / (float)factorV + 0.5F) * factorV;
if (tileHeight < factorV) {
tileHeight=factorV;
}
if (isTiled) {
int factorH=8 * maxSubH;
tileWidth=(int)((float)tileWidth / (float)factorH + 0.5F) * factorH;
if (tileWidth < factorH) {
tileWidth=factorH;
}
}
}
int numTiles;
if (isTiled) {
numTiles=((width + tileWidth - 1) / tileWidth) * ((height + tileHeight - 1) / tileHeight);
}
 else {
numTiles=(int)Math.ceil((double)height / (double)tileHeight);
}
long tileByteCounts[]=new long[numTiles];
long bytesPerRow=(long)Math.ceil((sampleSize[0] / 8.0) * tileWidth * numBands);
long bytesPerTile=bytesPerRow * tileHeight;
for (int i=0; i < numTiles; i++) {
tileByteCounts[i]=bytesPerTile;
}
if (!isTiled) {
long lastStripRows=height - (tileHeight * (numTiles - 1));
tileByteCounts[numTiles - 1]=lastStripRows * bytesPerRow;
}
long totalBytesOfData=bytesPerTile * (numTiles - 1) + tileByteCounts[numTiles - 1];
long tileOffsets[]=new long[numTiles];
SortedSet fields=new TreeSet();
fields.add(new TIFFField(TIFFImageDecoder.TIFF_IMAGE_WIDTH,TIFFField.TIFF_LONG,1,(Object)(new long[]{(long)width})));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_IMAGE_LENGTH,TIFFField.TIFF_LONG,1,new long[]{(long)height}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_BITS_PER_SAMPLE,TIFFField.TIFF_SHORT,numBands,intsToChars(sampleSize)));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_COMPRESSION,TIFFField.TIFF_SHORT,1,new char[]{(char)compression}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_PHOTOMETRIC_INTERPRETATION,TIFFField.TIFF_SHORT,1,new char[]{(char)photometricInterpretation}));
if (!isTiled) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_STRIP_OFFSETS,TIFFField.TIFF_LONG,numTiles,(long[])tileOffsets));
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_SAMPLES_PER_PIXEL,TIFFField.TIFF_SHORT,1,new char[]{(char)numBands}));
if (!isTiled) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_ROWS_PER_STRIP,TIFFField.TIFF_LONG,1,new long[]{(long)tileHeight}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_STRIP_BYTE_COUNTS,TIFFField.TIFF_LONG,numTiles,(long[])tileByteCounts));
}
if (colormap != null) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_COLORMAP,TIFFField.TIFF_SHORT,sizeOfColormap,intsToChars(colormap)));
}
if (isTiled) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_WIDTH,TIFFField.TIFF_LONG,1,new long[]{(long)tileWidth}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_LENGTH,TIFFField.TIFF_LONG,1,new long[]{(long)tileHeight}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_OFFSETS,TIFFField.TIFF_LONG,numTiles,(long[])tileOffsets));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_BYTE_COUNTS,TIFFField.TIFF_LONG,numTiles,(long[])tileByteCounts));
}
if (numExtraSamples > 0) {
int[] extraSamples=new int[numExtraSamples];
for (int i=0; i < numExtraSamples; i++) {
extraSamples[i]=extraSampleType;
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_EXTRA_SAMPLES,TIFFField.TIFF_SHORT,numExtraSamples,intsToChars(extraSamples)));
}
if (dataType != DataBuffer.TYPE_BYTE) {
int[] sampleFormat=new int[numBands];
if (dataType == DataBuffer.TYPE_FLOAT) {
sampleFormat[0]=3;
}
 else if (dataType == DataBuffer.TYPE_USHORT) {
sampleFormat[0]=1;
}
 else {
sampleFormat[0]=2;
}
for (int b=1; b < numBands; b++) {
sampleFormat[b]=sampleFormat[0];
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_SAMPLE_FORMAT,TIFFField.TIFF_SHORT,numBands,intsToChars(sampleFormat)));
}
boolean inverseFill=encodeParam.getReverseFillOrder();
boolean T4encode2D=encodeParam.getT4Encode2D();
boolean T4PadEOLs=encodeParam.getT4PadEOLs();
TIFFFaxEncoder faxEncoder=null;
if ((imageType == TIFF_BILEVEL_BLACK_IS_ZERO || imageType == TIFF_BILEVEL_WHITE_IS_ZERO) && (compression == COMP_GROUP3_1D || compression == COMP_GROUP3_2D || compression == COMP_GROUP4)) {
faxEncoder=new TIFFFaxEncoder(inverseFill);
fields.add(new TIFFField(TIFFImageDecoder.TIFF_FILL_ORDER,TIFFField.TIFF_SHORT,1,new char[]{inverseFill ? (char)2 : (char)1}));
if (compression == COMP_GROUP3_2D) {
long T4Options=0x00000000;
if (T4encode2D) {
T4Options|=0x00000001;
}
if (T4PadEOLs) {
T4Options|=0x00000004;
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_T4_OPTIONS,TIFFField.TIFF_LONG,1,new long[]{T4Options}));
}
 else if (compression == COMP_GROUP4) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_T6_OPTIONS,TIFFField.TIFF_LONG,1,new long[]{(long)0x00000000}));
}
}
com.sun.image.codec.jpeg.JPEGEncodeParam jpegEncodeParam=null;
com.sun.image.codec.jpeg.JPEGImageEncoder jpegEncoder=null;
int jpegColorID=0;
if (compression == COMP_JPEG_TTN2) {
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_UNKNOWN;
switch (imageType) {
case TIFF_GRAY:
case TIFF_PALETTE:
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_GRAY;
break;
case TIFF_RGB:
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_RGB;
break;
case TIFF_YCBCR:
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_YCbCr;
break;
}
Raster tile00=im.getTile(0,0);
jpegEncodeParam=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(tile00,jpegColorID);
JPEGImageEncoder.modifyEncodeParam(jep,jpegEncodeParam,numBands);
if (jep.getWriteImageOnly()) {
jpegEncodeParam.setImageInfoValid(false);
jpegEncodeParam.setTableInfoValid(true);
ByteArrayOutputStream tableStream=new ByteArrayOutputStream();
jpegEncoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(tableStream,jpegEncodeParam);
jpegEncoder.encode(tile00);
byte[] tableData=tableStream.toByteArray();
fields.add(new TIFFField(TIFF_JPEG_TABLES,TIFFField.TIFF_UNDEFINED,tableData.length,tableData));
jpegEncoder=null;
}
}
if (imageType == TIFF_YCBCR) {
int subsampleH=1;
int subsampleV=1;
if (compression == COMP_JPEG_TTN2) {
subsampleH=jep.getHorizontalSubsampling(0);
subsampleV=jep.getVerticalSubsampling(0);
for (int i=1; i < numBands; i++) {
int subH=jep.getHorizontalSubsampling(i);
if (subH > subsampleH) {
subsampleH=subH;
}
int subV=jep.getVerticalSubsampling(i);
if (subV > subsampleV) {
subsampleV=subV;
}
}
}
fields.add(new TIFFField(TIFF_YCBCR_SUBSAMPLING,TIFFField.TIFF_SHORT,2,new char[]{(char)subsampleH,(char)subsampleV}));
fields.add(new TIFFField(TIFF_YCBCR_POSITIONING,TIFFField.TIFF_SHORT,1,new char[]{compression == COMP_JPEG_TTN2 ? (char)1 : (char)2}));
long[][] refbw;
if (compression == COMP_JPEG_TTN2) {
refbw=new long[][]{{0,1},{255,1},{128,1},{255,1},{128,1},{255,1}};
}
 else {
refbw=new long[][]{{15,1},{235,1},{128,1},{240,1},{128,1},{240,1}};
}
fields.add(new TIFFField(TIFF_REF_BLACK_WHITE,TIFFField.TIFF_RATIONAL,6,refbw));
}
TIFFField[] extraFields=encodeParam.getExtraFields();
if (extraFields != null) {
ArrayList extantTags=new ArrayList(fields.size());
Iterator fieldIter=fields.iterator();
while (fieldIter.hasNext()) {
TIFFField fld=(TIFFField)fieldIter.next();
extantTags.add(new Integer(fld.getTag()));
}
int numExtraFields=extraFields.length;
for (int i=0; i < numExtraFields; i++) {
TIFFField fld=extraFields[i];
Integer tagValue=new Integer(fld.getTag());
if (!extantTags.contains(tagValue)) {
fields.add(fld);
extantTags.add(tagValue);
}
}
}
int dirSize=getDirectorySize(fields);
tileOffsets[0]=ifdOffset + dirSize;
OutputStream outCache=null;
byte[] compressBuf=null;
File tempFile=null;
int nextIFDOffset=0;
boolean skipByte=false;
Deflater deflater=null;
int deflateLevel=Deflater.DEFAULT_COMPRESSION;
boolean jpegRGBToYCbCr=false;
if (compression == COMP_NONE) {
int numBytesPadding=0;
if (sampleSize[0] == 16 && tileOffsets[0] % 2 != 0) {
numBytesPadding=1;
tileOffsets[0]++;
}
 else if (sampleSize[0] == 32 && tileOffsets[0] % 4 != 0) {
numBytesPadding=(int)(4 - tileOffsets[0] % 4);
tileOffsets[0]+=numBytesPadding;
}
for (int i=1; i < numTiles; i++) {
tileOffsets[i]=tileOffsets[i - 1] + tileByteCounts[i - 1];
}
if (!isLast) {
nextIFDOffset=(int)(tileOffsets[0] + totalBytesOfData);
if (nextIFDOffset % 2 != 0) {
nextIFDOffset++;
skipByte=true;
}
}
writeDirectory(ifdOffset,fields,nextIFDOffset);
if (numBytesPadding != 0) {
for (int padding=0; padding < numBytesPadding; padding++) {
output.write((byte)0);
}
}
}
 else {
if ((output instanceof SeekableOutputStream)) {
((SeekableOutputStream)output).seek(tileOffsets[0]);
}
 else {
outCache=output;
try {
tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
tempFile.deleteOnExit();
RandomAccessFile raFile=new RandomAccessFile(tempFile,""String_Node_Str"");
output=new SeekableOutputStream(raFile);
}
 catch (Exception e) {
tempFile=null;
output=new ByteArrayOutputStream((int)totalBytesOfData);
}
}
int bufSize=0;
switch (compression) {
case COMP_GROUP3_1D:
bufSize=(int)Math.ceil((((tileWidth + 1) / 2) * 9 + 2) / 8.0);
break;
case COMP_GROUP3_2D:
case COMP_GROUP4:
bufSize=(int)Math.ceil((((tileWidth + 1) / 2) * 9 + 2) / 8.0);
bufSize=tileHeight * (bufSize + 2) + 12;
break;
case COMP_PACKBITS:
bufSize=(int)(bytesPerTile + ((bytesPerRow + 127) / 128) * tileHeight);
break;
case COMP_JPEG_TTN2:
bufSize=0;
if (imageType == TIFF_YCBCR && colorModel != null && colorModel.getColorSpace().getType() == ColorSpace.TYPE_RGB) {
jpegRGBToYCbCr=true;
}
break;
case COMP_DEFLATE:
bufSize=(int)bytesPerTile;
deflater=new Deflater(encodeParam.getDeflateLevel());
break;
default :
bufSize=0;
}
if (bufSize != 0) {
compressBuf=new byte[bufSize];
}
}
int[] pixels=null;
float[] fpixels=null;
boolean checkContiguous=((sampleSize[0] == 1 && sampleModel instanceof MultiPixelPackedSampleModel && dataType == DataBuffer.TYPE_BYTE) || (sampleSize[0] == 8 && sampleModel instanceof ComponentSampleModel));
byte[] bpixels=null;
if (compression != COMP_JPEG_TTN2) {
if (dataType == DataBuffer.TYPE_BYTE) {
bpixels=new byte[tileHeight * tileWidth * numBands];
}
 else if (dataTypeIsShort) {
bpixels=new byte[2 * tileHeight * tileWidth* numBands];
}
 else if (dataType == DataBuffer.TYPE_INT || dataType == DataBuffer.TYPE_FLOAT) {
bpixels=new byte[4 * tileHeight * tileWidth* numBands];
}
}
int lastRow=minY + height;
int lastCol=minX + width;
int tileNum=0;
for (int row=minY; row < lastRow; row+=tileHeight) {
int rows=isTiled ? tileHeight : Math.min(tileHeight,lastRow - row);
int size=rows * tileWidth * numBands;
for (int col=minX; col < lastCol; col+=tileWidth) {
Raster src=im.getData(new Rectangle(col,row,tileWidth,rows));
boolean useDataBuffer=false;
if (compression != COMP_JPEG_TTN2) {
if (checkContiguous) {
if (sampleSize[0] == 8) {
ComponentSampleModel csm=(ComponentSampleModel)src.getSampleModel();
int[] bankIndices=csm.getBankIndices();
int[] bandOffsets=csm.getBandOffsets();
int pixelStride=csm.getPixelStride();
int lineStride=csm.getScanlineStride();
if (pixelStride != numBands || lineStride != bytesPerRow) {
useDataBuffer=false;
}
 else {
useDataBuffer=true;
for (int i=0; useDataBuffer && i < numBands; i++) {
if (bankIndices[i] != 0 || bandOffsets[i] != i) {
useDataBuffer=false;
}
}
}
}
 else {
MultiPixelPackedSampleModel mpp=(MultiPixelPackedSampleModel)src.getSampleModel();
if (mpp.getNumBands() == 1 && mpp.getDataBitOffset() == 0 && mpp.getPixelBitStride() == 1) {
useDataBuffer=true;
}
}
}
if (!useDataBuffer) {
if (dataType == DataBuffer.TYPE_FLOAT) {
fpixels=src.getPixels(col,row,tileWidth,rows,fpixels);
}
 else {
pixels=src.getPixels(col,row,tileWidth,rows,pixels);
}
}
}
int index;
int pixel=0;
;
int k=0;
switch (sampleSize[0]) {
case 1:
if (useDataBuffer) {
byte[] btmp=((DataBufferByte)src.getDataBuffer()).getData();
MultiPixelPackedSampleModel mpp=(MultiPixelPackedSampleModel)src.getSampleModel();
int lineStride=mpp.getScanlineStride();
int inOffset=mpp.getOffset(col - src.getSampleModelTranslateX(),row - src.getSampleModelTranslateY());
if (lineStride == (int)bytesPerRow) {
System.arraycopy(btmp,inOffset,bpixels,0,(int)bytesPerRow * rows);
}
 else {
int outOffset=0;
for (int j=0; j < rows; j++) {
System.arraycopy(btmp,inOffset,bpixels,outOffset,(int)bytesPerRow);
inOffset+=lineStride;
outOffset+=(int)bytesPerRow;
}
}
}
 else {
index=0;
for (int i=0; i < rows; i++) {
for (int j=0; j < tileWidth / 8; j++) {
pixel=(pixels[index++] << 7) | (pixels[index++] << 6) | (pixels[index++] << 5)| (pixels[index++] << 4)| (pixels[index++] << 3)| (pixels[index++] << 2)| (pixels[index++] << 1)| pixels[index++];
bpixels[k++]=(byte)pixel;
}
if (tileWidth % 8 > 0) {
pixel=0;
for (int j=0; j < tileWidth % 8; j++) {
pixel|=(pixels[index++] << (7 - j));
}
bpixels[k++]=(byte)pixel;
}
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,rows * ((tileWidth + 7) / 8));
}
 else if (compression == COMP_GROUP3_1D) {
int rowStride=(tileWidth + 7) / 8;
int rowOffset=0;
int numCompressedBytes=0;
for (int tileRow=0; tileRow < rows; tileRow++) {
int numCompressedBytesInRow=faxEncoder.encodeRLE(bpixels,rowOffset,0,tileWidth,compressBuf);
output.write(compressBuf,0,numCompressedBytesInRow);
rowOffset+=rowStride;
numCompressedBytes+=numCompressedBytesInRow;
}
tileByteCounts[tileNum++]=numCompressedBytes;
}
 else if (compression == COMP_GROUP3_2D) {
int numCompressedBytes=faxEncoder.encodeT4(!T4encode2D,T4PadEOLs,bpixels,(tileWidth + 7) / 8,0,tileWidth,rows,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_GROUP4) {
int numCompressedBytes=faxEncoder.encodeT6(bpixels,(tileWidth + 7) / 8,0,tileWidth,rows,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 4:
index=0;
for (int i=0; i < rows; i++) {
for (int j=0; j < tileWidth / 2; j++) {
pixel=(pixels[index++] << 4) | pixels[index++];
bpixels[k++]=(byte)pixel;
}
if ((tileWidth % 2) == 1) {
pixel=pixels[index++] << 4;
bpixels[k++]=(byte)pixel;
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,rows * ((tileWidth + 1) / 2));
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 8:
if (compression != COMP_JPEG_TTN2) {
if (useDataBuffer) {
byte[] btmp=((DataBufferByte)src.getDataBuffer()).getData();
ComponentSampleModel csm=(ComponentSampleModel)src.getSampleModel();
int inOffset=csm.getOffset(col - src.getSampleModelTranslateX(),row - src.getSampleModelTranslateY());
int lineStride=csm.getScanlineStride();
if (lineStride == (int)bytesPerRow) {
System.arraycopy(btmp,inOffset,bpixels,0,(int)bytesPerRow * rows);
}
 else {
int outOffset=0;
for (int j=0; j < rows; j++) {
System.arraycopy(btmp,inOffset,bpixels,outOffset,(int)bytesPerRow);
inOffset+=lineStride;
outOffset+=(int)bytesPerRow;
}
}
}
 else {
for (int i=0; i < size; i++) {
bpixels[i]=(byte)pixels[i];
}
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,size);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_JPEG_TTN2) {
long startPos=getOffset(output);
if (jpegEncoder == null || jpegEncodeParam.getWidth() != src.getWidth() || jpegEncodeParam.getHeight() != src.getHeight()) {
jpegEncodeParam=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(src,jpegColorID);
JPEGImageEncoder.modifyEncodeParam(jep,jpegEncodeParam,numBands);
jpegEncoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(output,jpegEncodeParam);
}
if (jpegRGBToYCbCr) {
WritableRaster wRas=null;
if (src instanceof WritableRaster) {
wRas=(WritableRaster)src;
}
 else {
wRas=src.createCompatibleWritableRaster();
wRas.setRect(src);
}
if (wRas.getMinX() != 0 || wRas.getMinY() != 0) {
wRas=wRas.createWritableTranslatedChild(0,0);
}
BufferedImage bi=new BufferedImage(colorModel,wRas,false,null);
jpegEncoder.encode(bi);
}
 else {
jpegEncoder.encode(src.createTranslatedChild(0,0));
}
long endPos=getOffset(output);
tileByteCounts[tileNum++]=(int)(endPos - startPos);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 16:
int ls=0;
for (int i=0; i < size; i++) {
short value=(short)pixels[i];
bpixels[ls++]=(byte)((value & 0xff00) >> 8);
bpixels[ls++]=(byte)(value & 0x00ff);
}
if (compression == COMP_NONE) {
output.write(bpixels,0,size * 2);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 32:
if (dataType == DataBuffer.TYPE_INT) {
int li=0;
for (int i=0; i < size; i++) {
int value=pixels[i];
bpixels[li++]=(byte)((value & 0xff000000) >> 24);
bpixels[li++]=(byte)((value & 0x00ff0000) >> 16);
bpixels[li++]=(byte)((value & 0x0000ff00) >> 8);
bpixels[li++]=(byte)(value & 0x000000ff);
}
}
 else {
int lf=0;
for (int i=0; i < size; i++) {
int value=Float.floatToIntBits(fpixels[i]);
bpixels[lf++]=(byte)((value & 0xff000000) >> 24);
bpixels[lf++]=(byte)((value & 0x00ff0000) >> 16);
bpixels[lf++]=(byte)((value & 0x0000ff00) >> 8);
bpixels[lf++]=(byte)(value & 0x000000ff);
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,size * 4);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
}
}
}
if (compression == COMP_NONE) {
if (skipByte) {
output.write((byte)0);
}
}
 else {
int totalBytes=0;
for (int i=1; i < numTiles; i++) {
int numBytes=(int)tileByteCounts[i - 1];
totalBytes+=numBytes;
tileOffsets[i]=tileOffsets[i - 1] + numBytes;
}
totalBytes+=(int)tileByteCounts[numTiles - 1];
nextIFDOffset=isLast ? 0 : ifdOffset + dirSize + totalBytes;
if (nextIFDOffset % 2 != 0) {
nextIFDOffset++;
skipByte=true;
}
if (outCache == null) {
if (skipByte) {
output.write((byte)0);
}
SeekableOutputStream sos=(SeekableOutputStream)output;
long savePos=sos.getFilePointer();
sos.seek(ifdOffset);
writeDirectory(ifdOffset,fields,nextIFDOffset);
sos.seek(savePos);
}
 else if (tempFile != null) {
output.close();
FileInputStream fileStream=new FileInputStream(tempFile);
output=outCache;
writeDirectory(ifdOffset,fields,nextIFDOffset);
byte[] copyBuffer=new byte[8192];
int bytesCopied=0;
while (bytesCopied < totalBytes) {
int bytesRead=fileStream.read(copyBuffer);
if (bytesRead == -1) {
break;
}
output.write(copyBuffer,0,bytesRead);
bytesCopied+=bytesRead;
}
fileStream.close();
tempFile.delete();
if (skipByte) {
output.write((byte)0);
}
}
 else if (output instanceof ByteArrayOutputStream) {
ByteArrayOutputStream memoryStream=(ByteArrayOutputStream)output;
output=outCache;
writeDirectory(ifdOffset,fields,nextIFDOffset);
memoryStream.writeTo(output);
if (skipByte) {
output.write((byte)0);
}
}
 else {
throw new IllegalStateException();
}
}
return nextIFDOffset;
}","private int encode(RenderedImage im,TIFFEncodeParam encodeParam,int ifdOffset,boolean isLast) throws IOException {
  if (CodecUtils.isPackedByteImage(im)) {
    ColorModel sourceCM=im.getColorModel();
    ColorModel destCM=RasterFactory.createComponentColorModel(DataBuffer.TYPE_BYTE,sourceCM.getColorSpace(),sourceCM.hasAlpha(),sourceCM.isAlphaPremultiplied(),sourceCM.getTransparency());
    Point origin=new Point(im.getMinX(),im.getMinY());
    WritableRaster raster=Raster.createWritableRaster(destCM.createCompatibleSampleModel(im.getWidth(),im.getHeight()),origin);
    raster.setRect(im.getData());
    im=new SingleTileRenderedImage(raster,destCM);
  }
  int compression=encodeParam.getCompression();
  boolean isTiled=encodeParam.getWriteTiled();
  int minX=im.getMinX();
  int minY=im.getMinY();
  int width=im.getWidth();
  int height=im.getHeight();
  SampleModel sampleModel=im.getSampleModel();
  int sampleSize[]=sampleModel.getSampleSize();
  for (int i=1; i < sampleSize.length; i++) {
    if (sampleSize[i] != sampleSize[0]) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
  }
  int numBands=sampleModel.getNumBands();
  if ((sampleSize[0] == 1 || sampleSize[0] == 4) && numBands != 1) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int dataType=sampleModel.getDataType();
switch (dataType) {
case DataBuffer.TYPE_BYTE:
    if (sampleSize[0] != 1 && sampleSize[0] != 4 && sampleSize[0] != 8) {
      throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
    }
  break;
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_USHORT:
if (sampleSize[0] != 16) {
  throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
break;
case DataBuffer.TYPE_INT:
case DataBuffer.TYPE_FLOAT:
if (sampleSize[0] != 32) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
boolean dataTypeIsShort=dataType == DataBuffer.TYPE_SHORT || dataType == DataBuffer.TYPE_USHORT;
ColorModel colorModel=im.getColorModel();
if (colorModel != null && colorModel instanceof IndexColorModel && dataType != DataBuffer.TYPE_BYTE) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
IndexColorModel icm=null;
int sizeOfColormap=0;
int colormap[]=null;
int imageType=TIFF_UNSUPPORTED;
int numExtraSamples=0;
int extraSampleType=EXTRA_SAMPLE_UNSPECIFIED;
if (colorModel instanceof IndexColorModel) {
icm=(IndexColorModel)colorModel;
int mapSize=icm.getMapSize();
if (sampleSize[0] == 1 && numBands == 1) {
if (mapSize != 2) {
throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
}
byte r[]=new byte[mapSize];
icm.getReds(r);
byte g[]=new byte[mapSize];
icm.getGreens(g);
byte b[]=new byte[mapSize];
icm.getBlues(b);
if ((r[0] & 0xff) == 0 && (r[1] & 0xff) == 255 && (g[0] & 0xff) == 0 && (g[1] & 0xff) == 255 && (b[0] & 0xff) == 0 && (b[1] & 0xff) == 255) {
imageType=TIFF_BILEVEL_BLACK_IS_ZERO;
}
 else if ((r[0] & 0xff) == 255 && (r[1] & 0xff) == 0 && (g[0] & 0xff) == 255 && (g[1] & 0xff) == 0 && (b[0] & 0xff) == 255 && (b[1] & 0xff) == 0) {
imageType=TIFF_BILEVEL_WHITE_IS_ZERO;
}
 else {
imageType=TIFF_PALETTE;
}
}
 else if (numBands == 1) {
imageType=TIFF_PALETTE;
}
}
 else if (colorModel == null) {
if (sampleSize[0] == 1 && numBands == 1) {
imageType=TIFF_BILEVEL_BLACK_IS_ZERO;
}
 else {
imageType=TIFF_GENERIC;
if (numBands > 1) {
numExtraSamples=numBands - 1;
}
}
}
 else {
ColorSpace colorSpace=colorModel.getColorSpace();
switch (colorSpace.getType()) {
case ColorSpace.TYPE_CMYK:
imageType=TIFF_CMYK;
break;
case ColorSpace.TYPE_GRAY:
imageType=TIFF_GRAY;
break;
case ColorSpace.TYPE_Lab:
imageType=TIFF_CIELAB;
break;
case ColorSpace.TYPE_RGB:
if (compression == COMP_JPEG_TTN2 && encodeParam.getJPEGCompressRGBToYCbCr()) {
imageType=TIFF_YCBCR;
}
 else {
imageType=TIFF_RGB;
}
break;
case ColorSpace.TYPE_YCbCr:
imageType=TIFF_YCBCR;
break;
default :
imageType=TIFF_GENERIC;
break;
}
if (imageType == TIFF_GENERIC) {
numExtraSamples=numBands - 1;
}
 else if (numBands > 1) {
numExtraSamples=numBands - colorSpace.getNumComponents();
}
if (numExtraSamples == 1 && colorModel.hasAlpha()) {
extraSampleType=colorModel.isAlphaPremultiplied() ? EXTRA_SAMPLE_ASSOCIATED_ALPHA : EXTRA_SAMPLE_UNASSOCIATED_ALPHA;
}
}
if (imageType == TIFF_UNSUPPORTED) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (compression == COMP_JPEG_TTN2) {
if (imageType == TIFF_PALETTE) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
 else if (!(sampleSize[0] == 8 && (imageType == TIFF_GRAY || imageType == TIFF_RGB || imageType == TIFF_YCBCR))) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
}
if ((imageType != TIFF_BILEVEL_WHITE_IS_ZERO && imageType != TIFF_BILEVEL_BLACK_IS_ZERO) && (compression == COMP_GROUP3_1D || compression == COMP_GROUP3_2D || compression == COMP_GROUP4)) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
int photometricInterpretation=-1;
switch (imageType) {
case TIFF_BILEVEL_WHITE_IS_ZERO:
photometricInterpretation=0;
break;
case TIFF_BILEVEL_BLACK_IS_ZERO:
photometricInterpretation=1;
break;
case TIFF_GRAY:
case TIFF_GENERIC:
photometricInterpretation=1;
break;
case TIFF_PALETTE:
photometricInterpretation=3;
icm=(IndexColorModel)colorModel;
sizeOfColormap=icm.getMapSize();
byte r[]=new byte[sizeOfColormap];
icm.getReds(r);
byte g[]=new byte[sizeOfColormap];
icm.getGreens(g);
byte b[]=new byte[sizeOfColormap];
icm.getBlues(b);
int redIndex=0, greenIndex=sizeOfColormap;
int blueIndex=2 * sizeOfColormap;
colormap=new int[sizeOfColormap * 3];
for (int i=0; i < sizeOfColormap; i++) {
colormap[redIndex++]=(r[i] << 8) & 0xffff;
colormap[greenIndex++]=(g[i] << 8) & 0xffff;
colormap[blueIndex++]=(b[i] << 8) & 0xffff;
}
sizeOfColormap*=3;
break;
case TIFF_RGB:
photometricInterpretation=2;
break;
case TIFF_CMYK:
photometricInterpretation=5;
break;
case TIFF_YCBCR:
photometricInterpretation=6;
break;
case TIFF_CIELAB:
photometricInterpretation=8;
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
int tileWidth;
int tileHeight;
if (isTiled) {
tileWidth=encodeParam.getTileWidth() > 0 ? encodeParam.getTileWidth() : im.getTileWidth();
tileHeight=encodeParam.getTileHeight() > 0 ? encodeParam.getTileHeight() : im.getTileHeight();
}
 else {
tileWidth=width;
tileHeight=encodeParam.getTileHeight() > 0 ? encodeParam.getTileHeight() : DEFAULT_ROWS_PER_STRIP;
}
JPEGEncodeParam jep=null;
if (compression == COMP_JPEG_TTN2) {
jep=encodeParam.getJPEGEncodeParam();
int maxSubH=jep.getHorizontalSubsampling(0);
int maxSubV=jep.getVerticalSubsampling(0);
for (int i=1; i < numBands; i++) {
int subH=jep.getHorizontalSubsampling(i);
if (subH > maxSubH) {
maxSubH=subH;
}
int subV=jep.getVerticalSubsampling(i);
if (subV > maxSubV) {
maxSubV=subV;
}
}
int factorV=8 * maxSubV;
tileHeight=(int)((float)tileHeight / (float)factorV + 0.5F) * factorV;
if (tileHeight < factorV) {
tileHeight=factorV;
}
if (isTiled) {
int factorH=8 * maxSubH;
tileWidth=(int)((float)tileWidth / (float)factorH + 0.5F) * factorH;
if (tileWidth < factorH) {
tileWidth=factorH;
}
}
}
int numTiles;
if (isTiled) {
numTiles=((width + tileWidth - 1) / tileWidth) * ((height + tileHeight - 1) / tileHeight);
}
 else {
numTiles=(int)Math.ceil((double)height / (double)tileHeight);
}
long tileByteCounts[]=new long[numTiles];
long bytesPerRow=(long)Math.ceil((sampleSize[0] / 8.0) * tileWidth * numBands);
long bytesPerTile=bytesPerRow * tileHeight;
for (int i=0; i < numTiles; i++) {
tileByteCounts[i]=bytesPerTile;
}
if (!isTiled) {
long lastStripRows=height - (tileHeight * (numTiles - 1));
tileByteCounts[numTiles - 1]=lastStripRows * bytesPerRow;
}
long totalBytesOfData=bytesPerTile * (numTiles - 1) + tileByteCounts[numTiles - 1];
long tileOffsets[]=new long[numTiles];
SortedSet fields=new TreeSet();
fields.add(new TIFFField(TIFFImageDecoder.TIFF_IMAGE_WIDTH,TIFFField.TIFF_LONG,1,(Object)(new long[]{(long)width})));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_IMAGE_LENGTH,TIFFField.TIFF_LONG,1,new long[]{(long)height}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_BITS_PER_SAMPLE,TIFFField.TIFF_SHORT,numBands,intsToChars(sampleSize)));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_COMPRESSION,TIFFField.TIFF_SHORT,1,new char[]{(char)compression}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_PHOTOMETRIC_INTERPRETATION,TIFFField.TIFF_SHORT,1,new char[]{(char)photometricInterpretation}));
if (!isTiled) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_STRIP_OFFSETS,TIFFField.TIFF_LONG,numTiles,(long[])tileOffsets));
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_SAMPLES_PER_PIXEL,TIFFField.TIFF_SHORT,1,new char[]{(char)numBands}));
if (!isTiled) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_ROWS_PER_STRIP,TIFFField.TIFF_LONG,1,new long[]{(long)tileHeight}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_STRIP_BYTE_COUNTS,TIFFField.TIFF_LONG,numTiles,(long[])tileByteCounts));
}
if (colormap != null) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_COLORMAP,TIFFField.TIFF_SHORT,sizeOfColormap,intsToChars(colormap)));
}
if (isTiled) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_WIDTH,TIFFField.TIFF_LONG,1,new long[]{(long)tileWidth}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_LENGTH,TIFFField.TIFF_LONG,1,new long[]{(long)tileHeight}));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_OFFSETS,TIFFField.TIFF_LONG,numTiles,(long[])tileOffsets));
fields.add(new TIFFField(TIFFImageDecoder.TIFF_TILE_BYTE_COUNTS,TIFFField.TIFF_LONG,numTiles,(long[])tileByteCounts));
}
if (numExtraSamples > 0) {
int[] extraSamples=new int[numExtraSamples];
for (int i=0; i < numExtraSamples; i++) {
extraSamples[i]=extraSampleType;
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_EXTRA_SAMPLES,TIFFField.TIFF_SHORT,numExtraSamples,intsToChars(extraSamples)));
}
if (dataType != DataBuffer.TYPE_BYTE) {
int[] sampleFormat=new int[numBands];
if (dataType == DataBuffer.TYPE_FLOAT) {
sampleFormat[0]=3;
}
 else if (dataType == DataBuffer.TYPE_USHORT) {
sampleFormat[0]=1;
}
 else {
sampleFormat[0]=2;
}
for (int b=1; b < numBands; b++) {
sampleFormat[b]=sampleFormat[0];
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_SAMPLE_FORMAT,TIFFField.TIFF_SHORT,numBands,intsToChars(sampleFormat)));
}
boolean inverseFill=encodeParam.getReverseFillOrder();
boolean T4encode2D=encodeParam.getT4Encode2D();
boolean T4PadEOLs=encodeParam.getT4PadEOLs();
TIFFFaxEncoder faxEncoder=null;
if ((imageType == TIFF_BILEVEL_BLACK_IS_ZERO || imageType == TIFF_BILEVEL_WHITE_IS_ZERO) && (compression == COMP_GROUP3_1D || compression == COMP_GROUP3_2D || compression == COMP_GROUP4)) {
faxEncoder=new TIFFFaxEncoder(inverseFill);
fields.add(new TIFFField(TIFFImageDecoder.TIFF_FILL_ORDER,TIFFField.TIFF_SHORT,1,new char[]{inverseFill ? (char)2 : (char)1}));
if (compression == COMP_GROUP3_2D) {
long T4Options=0x00000000;
if (T4encode2D) {
T4Options|=0x00000001;
}
if (T4PadEOLs) {
T4Options|=0x00000004;
}
fields.add(new TIFFField(TIFFImageDecoder.TIFF_T4_OPTIONS,TIFFField.TIFF_LONG,1,new long[]{T4Options}));
}
 else if (compression == COMP_GROUP4) {
fields.add(new TIFFField(TIFFImageDecoder.TIFF_T6_OPTIONS,TIFFField.TIFF_LONG,1,new long[]{(long)0x00000000}));
}
}
com.sun.image.codec.jpeg.JPEGEncodeParam jpegEncodeParam=null;
com.sun.image.codec.jpeg.JPEGImageEncoder jpegEncoder=null;
int jpegColorID=0;
if (compression == COMP_JPEG_TTN2) {
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_UNKNOWN;
switch (imageType) {
case TIFF_GRAY:
case TIFF_PALETTE:
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_GRAY;
break;
case TIFF_RGB:
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_RGB;
break;
case TIFF_YCBCR:
jpegColorID=com.sun.image.codec.jpeg.JPEGDecodeParam.COLOR_ID_YCbCr;
break;
}
Raster tile00=im.getTile(0,0);
jpegEncodeParam=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(tile00,jpegColorID);
JPEGImageEncoder.modifyEncodeParam(jep,jpegEncodeParam,numBands);
if (jep.getWriteImageOnly()) {
jpegEncodeParam.setImageInfoValid(false);
jpegEncodeParam.setTableInfoValid(true);
ByteArrayOutputStream tableStream=new ByteArrayOutputStream();
jpegEncoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(tableStream,jpegEncodeParam);
jpegEncoder.encode(tile00);
byte[] tableData=tableStream.toByteArray();
fields.add(new TIFFField(TIFF_JPEG_TABLES,TIFFField.TIFF_UNDEFINED,tableData.length,tableData));
jpegEncoder=null;
}
}
if (imageType == TIFF_YCBCR) {
int subsampleH=1;
int subsampleV=1;
if (compression == COMP_JPEG_TTN2) {
subsampleH=jep.getHorizontalSubsampling(0);
subsampleV=jep.getVerticalSubsampling(0);
for (int i=1; i < numBands; i++) {
int subH=jep.getHorizontalSubsampling(i);
if (subH > subsampleH) {
subsampleH=subH;
}
int subV=jep.getVerticalSubsampling(i);
if (subV > subsampleV) {
subsampleV=subV;
}
}
}
fields.add(new TIFFField(TIFF_YCBCR_SUBSAMPLING,TIFFField.TIFF_SHORT,2,new char[]{(char)subsampleH,(char)subsampleV}));
fields.add(new TIFFField(TIFF_YCBCR_POSITIONING,TIFFField.TIFF_SHORT,1,new char[]{compression == COMP_JPEG_TTN2 ? (char)1 : (char)2}));
long[][] refbw;
if (compression == COMP_JPEG_TTN2) {
refbw=new long[][]{{0,1},{255,1},{128,1},{255,1},{128,1},{255,1}};
}
 else {
refbw=new long[][]{{15,1},{235,1},{128,1},{240,1},{128,1},{240,1}};
}
fields.add(new TIFFField(TIFF_REF_BLACK_WHITE,TIFFField.TIFF_RATIONAL,6,refbw));
}
TIFFField[] extraFields=encodeParam.getExtraFields();
if (extraFields != null) {
ArrayList extantTags=new ArrayList(fields.size());
Iterator fieldIter=fields.iterator();
while (fieldIter.hasNext()) {
TIFFField fld=(TIFFField)fieldIter.next();
extantTags.add(new Integer(fld.getTag()));
}
int numExtraFields=extraFields.length;
for (int i=0; i < numExtraFields; i++) {
TIFFField fld=extraFields[i];
Integer tagValue=new Integer(fld.getTag());
if (!extantTags.contains(tagValue)) {
fields.add(fld);
extantTags.add(tagValue);
}
}
}
int dirSize=getDirectorySize(fields);
tileOffsets[0]=ifdOffset + dirSize;
OutputStream outCache=null;
byte[] compressBuf=null;
File tempFile=null;
int nextIFDOffset=0;
boolean skipByte=false;
Deflater deflater=null;
int deflateLevel=Deflater.DEFAULT_COMPRESSION;
boolean jpegRGBToYCbCr=false;
if (compression == COMP_NONE) {
int numBytesPadding=0;
if (sampleSize[0] == 16 && tileOffsets[0] % 2 != 0) {
numBytesPadding=1;
tileOffsets[0]++;
}
 else if (sampleSize[0] == 32 && tileOffsets[0] % 4 != 0) {
numBytesPadding=(int)(4 - tileOffsets[0] % 4);
tileOffsets[0]+=numBytesPadding;
}
for (int i=1; i < numTiles; i++) {
tileOffsets[i]=tileOffsets[i - 1] + tileByteCounts[i - 1];
}
if (!isLast) {
nextIFDOffset=(int)(tileOffsets[0] + totalBytesOfData);
if (nextIFDOffset % 2 != 0) {
nextIFDOffset++;
skipByte=true;
}
}
writeDirectory(ifdOffset,fields,nextIFDOffset);
if (numBytesPadding != 0) {
for (int padding=0; padding < numBytesPadding; padding++) {
output.write((byte)0);
}
}
}
 else {
if ((output instanceof SeekableOutputStream)) {
((SeekableOutputStream)output).seek(tileOffsets[0]);
}
 else {
outCache=output;
try {
tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
tempFile.deleteOnExit();
RandomAccessFile raFile=new RandomAccessFile(tempFile,""String_Node_Str"");
output=new SeekableOutputStream(raFile);
}
 catch (Exception e) {
tempFile=null;
output=new ByteArrayOutputStream((int)totalBytesOfData);
}
}
int bufSize=0;
switch (compression) {
case COMP_GROUP3_1D:
bufSize=(int)Math.ceil((((tileWidth + 1) / 2) * 9 + 2) / 8.0);
break;
case COMP_GROUP3_2D:
case COMP_GROUP4:
bufSize=(int)Math.ceil((((tileWidth + 1) / 2) * 9 + 2) / 8.0);
bufSize=tileHeight * (bufSize + 2) + 12;
break;
case COMP_PACKBITS:
bufSize=(int)(bytesPerTile + ((bytesPerRow + 127) / 128) * tileHeight);
break;
case COMP_JPEG_TTN2:
bufSize=0;
if (imageType == TIFF_YCBCR && colorModel != null && colorModel.getColorSpace().getType() == ColorSpace.TYPE_RGB) {
jpegRGBToYCbCr=true;
}
break;
case COMP_DEFLATE:
bufSize=(int)bytesPerTile;
deflater=new Deflater(encodeParam.getDeflateLevel());
break;
default :
bufSize=0;
}
if (bufSize != 0) {
compressBuf=new byte[bufSize];
}
}
int[] pixels=null;
float[] fpixels=null;
boolean checkContiguous=((sampleSize[0] == 1 && sampleModel instanceof MultiPixelPackedSampleModel && dataType == DataBuffer.TYPE_BYTE) || (sampleSize[0] == 8 && sampleModel instanceof ComponentSampleModel));
byte[] bpixels=null;
if (compression != COMP_JPEG_TTN2) {
if (dataType == DataBuffer.TYPE_BYTE) {
bpixels=new byte[tileHeight * tileWidth * numBands];
}
 else if (dataTypeIsShort) {
bpixels=new byte[2 * tileHeight * tileWidth* numBands];
}
 else if (dataType == DataBuffer.TYPE_INT || dataType == DataBuffer.TYPE_FLOAT) {
bpixels=new byte[4 * tileHeight * tileWidth* numBands];
}
}
int lastRow=minY + height;
int lastCol=minX + width;
int tileNum=0;
for (int row=minY; row < lastRow; row+=tileHeight) {
int rows=isTiled ? tileHeight : Math.min(tileHeight,lastRow - row);
int size=rows * tileWidth * numBands;
for (int col=minX; col < lastCol; col+=tileWidth) {
Raster src=im.getData(new Rectangle(col,row,tileWidth,rows));
boolean useDataBuffer=false;
if (compression != COMP_JPEG_TTN2) {
if (checkContiguous) {
if (sampleSize[0] == 8) {
ComponentSampleModel csm=(ComponentSampleModel)src.getSampleModel();
int[] bankIndices=csm.getBankIndices();
int[] bandOffsets=csm.getBandOffsets();
int pixelStride=csm.getPixelStride();
int lineStride=csm.getScanlineStride();
if (pixelStride != numBands || lineStride != bytesPerRow) {
useDataBuffer=false;
}
 else {
useDataBuffer=true;
for (int i=0; useDataBuffer && i < numBands; i++) {
if (bankIndices[i] != 0 || bandOffsets[i] != i) {
useDataBuffer=false;
}
}
}
}
 else {
MultiPixelPackedSampleModel mpp=(MultiPixelPackedSampleModel)src.getSampleModel();
if (mpp.getNumBands() == 1 && mpp.getDataBitOffset() == 0 && mpp.getPixelBitStride() == 1) {
useDataBuffer=true;
}
}
}
if (!useDataBuffer) {
if (dataType == DataBuffer.TYPE_FLOAT) {
fpixels=src.getPixels(col,row,tileWidth,rows,fpixels);
}
 else {
pixels=src.getPixels(col,row,tileWidth,rows,pixels);
}
}
}
int index;
int pixel=0;
;
int k=0;
switch (sampleSize[0]) {
case 1:
if (useDataBuffer) {
byte[] btmp=((DataBufferByte)src.getDataBuffer()).getData();
MultiPixelPackedSampleModel mpp=(MultiPixelPackedSampleModel)src.getSampleModel();
int lineStride=mpp.getScanlineStride();
int inOffset=mpp.getOffset(col - src.getSampleModelTranslateX(),row - src.getSampleModelTranslateY());
if (lineStride == (int)bytesPerRow) {
System.arraycopy(btmp,inOffset,bpixels,0,(int)bytesPerRow * rows);
}
 else {
int outOffset=0;
for (int j=0; j < rows; j++) {
System.arraycopy(btmp,inOffset,bpixels,outOffset,(int)bytesPerRow);
inOffset+=lineStride;
outOffset+=(int)bytesPerRow;
}
}
}
 else {
index=0;
for (int i=0; i < rows; i++) {
for (int j=0; j < tileWidth / 8; j++) {
pixel=(pixels[index++] << 7) | (pixels[index++] << 6) | (pixels[index++] << 5)| (pixels[index++] << 4)| (pixels[index++] << 3)| (pixels[index++] << 2)| (pixels[index++] << 1)| pixels[index++];
bpixels[k++]=(byte)pixel;
}
if (tileWidth % 8 > 0) {
pixel=0;
for (int j=0; j < tileWidth % 8; j++) {
pixel|=(pixels[index++] << (7 - j));
}
bpixels[k++]=(byte)pixel;
}
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,rows * ((tileWidth + 7) / 8));
}
 else if (compression == COMP_GROUP3_1D) {
int rowStride=(tileWidth + 7) / 8;
int rowOffset=0;
int numCompressedBytes=0;
for (int tileRow=0; tileRow < rows; tileRow++) {
int numCompressedBytesInRow=faxEncoder.encodeRLE(bpixels,rowOffset,0,tileWidth,compressBuf);
output.write(compressBuf,0,numCompressedBytesInRow);
rowOffset+=rowStride;
numCompressedBytes+=numCompressedBytesInRow;
}
tileByteCounts[tileNum++]=numCompressedBytes;
}
 else if (compression == COMP_GROUP3_2D) {
int numCompressedBytes=faxEncoder.encodeT4(!T4encode2D,T4PadEOLs,bpixels,(tileWidth + 7) / 8,0,tileWidth,rows,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_GROUP4) {
int numCompressedBytes=faxEncoder.encodeT6(bpixels,(tileWidth + 7) / 8,0,tileWidth,rows,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 4:
index=0;
for (int i=0; i < rows; i++) {
for (int j=0; j < tileWidth / 2; j++) {
pixel=(pixels[index++] << 4) | pixels[index++];
bpixels[k++]=(byte)pixel;
}
if ((tileWidth % 2) == 1) {
pixel=pixels[index++] << 4;
bpixels[k++]=(byte)pixel;
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,rows * ((tileWidth + 1) / 2));
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 8:
if (compression != COMP_JPEG_TTN2) {
if (useDataBuffer) {
byte[] btmp=((DataBufferByte)src.getDataBuffer()).getData();
ComponentSampleModel csm=(ComponentSampleModel)src.getSampleModel();
int inOffset=csm.getOffset(col - src.getSampleModelTranslateX(),row - src.getSampleModelTranslateY());
int lineStride=csm.getScanlineStride();
if (lineStride == (int)bytesPerRow) {
System.arraycopy(btmp,inOffset,bpixels,0,(int)bytesPerRow * rows);
}
 else {
int outOffset=0;
for (int j=0; j < rows; j++) {
System.arraycopy(btmp,inOffset,bpixels,outOffset,(int)bytesPerRow);
inOffset+=lineStride;
outOffset+=(int)bytesPerRow;
}
}
}
 else {
for (int i=0; i < size; i++) {
bpixels[i]=(byte)pixels[i];
}
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,size);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_JPEG_TTN2) {
long startPos=getOffset(output);
if (jpegEncoder == null || jpegEncodeParam.getWidth() != src.getWidth() || jpegEncodeParam.getHeight() != src.getHeight()) {
jpegEncodeParam=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(src,jpegColorID);
JPEGImageEncoder.modifyEncodeParam(jep,jpegEncodeParam,numBands);
jpegEncoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(output,jpegEncodeParam);
}
if (jpegRGBToYCbCr) {
WritableRaster wRas=null;
if (src instanceof WritableRaster) {
wRas=(WritableRaster)src;
}
 else {
wRas=src.createCompatibleWritableRaster();
wRas.setRect(src);
}
if (wRas.getMinX() != 0 || wRas.getMinY() != 0) {
wRas=wRas.createWritableTranslatedChild(0,0);
}
BufferedImage bi=new BufferedImage(colorModel,wRas,false,null);
jpegEncoder.encode(bi);
}
 else {
jpegEncoder.encode(src.createTranslatedChild(0,0));
}
long endPos=getOffset(output);
tileByteCounts[tileNum++]=(int)(endPos - startPos);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 16:
int ls=0;
for (int i=0; i < size; i++) {
short value=(short)pixels[i];
bpixels[ls++]=(byte)((value & 0xff00) >> 8);
bpixels[ls++]=(byte)(value & 0x00ff);
}
if (compression == COMP_NONE) {
output.write(bpixels,0,size * 2);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
case 32:
if (dataType == DataBuffer.TYPE_INT) {
int li=0;
for (int i=0; i < size; i++) {
int value=pixels[i];
bpixels[li++]=(byte)((value & 0xff000000) >> 24);
bpixels[li++]=(byte)((value & 0x00ff0000) >> 16);
bpixels[li++]=(byte)((value & 0x0000ff00) >> 8);
bpixels[li++]=(byte)(value & 0x000000ff);
}
}
 else {
int lf=0;
for (int i=0; i < size; i++) {
int value=Float.floatToIntBits(fpixels[i]);
bpixels[lf++]=(byte)((value & 0xff000000) >> 24);
bpixels[lf++]=(byte)((value & 0x00ff0000) >> 16);
bpixels[lf++]=(byte)((value & 0x0000ff00) >> 8);
bpixels[lf++]=(byte)(value & 0x000000ff);
}
}
if (compression == COMP_NONE) {
output.write(bpixels,0,size * 4);
}
 else if (compression == COMP_PACKBITS) {
int numCompressedBytes=compressPackBits(bpixels,rows,(int)bytesPerRow,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
 else if (compression == COMP_DEFLATE) {
int numCompressedBytes=deflate(deflater,bpixels,compressBuf);
tileByteCounts[tileNum++]=numCompressedBytes;
output.write(compressBuf,0,numCompressedBytes);
}
break;
}
}
}
if (compression == COMP_NONE) {
if (skipByte) {
output.write((byte)0);
}
}
 else {
int totalBytes=0;
for (int i=1; i < numTiles; i++) {
int numBytes=(int)tileByteCounts[i - 1];
totalBytes+=numBytes;
tileOffsets[i]=tileOffsets[i - 1] + numBytes;
}
totalBytes+=(int)tileByteCounts[numTiles - 1];
nextIFDOffset=isLast ? 0 : ifdOffset + dirSize + totalBytes;
if (nextIFDOffset % 2 != 0) {
nextIFDOffset++;
skipByte=true;
}
if (outCache == null) {
if (skipByte) {
output.write((byte)0);
}
SeekableOutputStream sos=(SeekableOutputStream)output;
long savePos=sos.getFilePointer();
sos.seek(ifdOffset);
writeDirectory(ifdOffset,fields,nextIFDOffset);
sos.seek(savePos);
}
 else if (tempFile != null) {
output.close();
FileInputStream fileStream=new FileInputStream(tempFile);
output=outCache;
writeDirectory(ifdOffset,fields,nextIFDOffset);
byte[] copyBuffer=new byte[8192];
int bytesCopied=0;
while (bytesCopied < totalBytes) {
int bytesRead=fileStream.read(copyBuffer);
if (bytesRead == -1) {
break;
}
output.write(copyBuffer,0,bytesRead);
bytesCopied+=bytesRead;
}
fileStream.close();
tempFile.delete();
if (skipByte) {
output.write((byte)0);
}
}
 else if (output instanceof ByteArrayOutputStream) {
ByteArrayOutputStream memoryStream=(ByteArrayOutputStream)output;
output=outCache;
writeDirectory(ifdOffset,fields,nextIFDOffset);
memoryStream.writeTo(output);
if (skipByte) {
output.write((byte)0);
}
}
 else {
throw new IllegalStateException();
}
}
return nextIFDOffset;
}",0.9957445220053008
154053,"private void writeValuesAsFourBytes(TIFFField field) throws IOException {
  int dataType=field.getType();
  int count=field.getCount();
switch (dataType) {
case TIFFField.TIFF_BYTE:
case TIFFField.TIFF_SBYTE:
case TIFFField.TIFF_UNDEFINED:
    byte bytes[]=field.getAsBytes();
  for (int i=0; i < count; i++) {
    output.write(bytes[i]);
  }
for (int i=0; i < (4 - count); i++) {
  output.write(0);
}
break;
case TIFFField.TIFF_SHORT:
char shorts[]=field.getAsChars();
for (int i=0; i < count; i++) {
writeUnsignedShort(shorts[i]);
}
for (int i=0; i < (2 - count); i++) {
writeUnsignedShort(0);
}
break;
case TIFFField.TIFF_SSHORT:
short sshorts[]=field.getAsShorts();
for (int i=0; i < count; i++) {
writeUnsignedShort(sshorts[i]);
}
for (int i=0; i < (2 - count); i++) {
writeUnsignedShort(0);
}
break;
case TIFFField.TIFF_LONG:
writeLong(field.getAsLong(0));
break;
case TIFFField.TIFF_SLONG:
writeLong(field.getAsInt(0));
break;
case TIFFField.TIFF_FLOAT:
writeLong(Float.floatToIntBits(field.getAsFloat(0)));
break;
case TIFFField.TIFF_ASCII:
int asciiByteCount=0;
for (int i=0; i < count; i++) {
byte[] stringBytes=field.getAsString(i).getBytes();
output.write(stringBytes);
asciiByteCount+=stringBytes.length;
if (stringBytes[stringBytes.length - 1] != (byte)0) {
output.write(0);
asciiByteCount++;
}
}
for (int i=0; i < (4 - asciiByteCount); i++) {
output.write(0);
}
break;
default :
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
}","private void writeValuesAsFourBytes(TIFFField field) throws IOException {
  int dataType=field.getType();
  int count=field.getCount();
switch (dataType) {
case TIFFField.TIFF_BYTE:
case TIFFField.TIFF_SBYTE:
case TIFFField.TIFF_UNDEFINED:
    byte bytes[]=field.getAsBytes();
  for (int i=0; i < count; i++) {
    output.write(bytes[i]);
  }
for (int i=0; i < (4 - count); i++) {
  output.write(0);
}
break;
case TIFFField.TIFF_SHORT:
char shorts[]=field.getAsChars();
for (int i=0; i < count; i++) {
writeUnsignedShort(shorts[i]);
}
for (int i=0; i < (2 - count); i++) {
writeUnsignedShort(0);
}
break;
case TIFFField.TIFF_SSHORT:
short sshorts[]=field.getAsShorts();
for (int i=0; i < count; i++) {
writeUnsignedShort(sshorts[i]);
}
for (int i=0; i < (2 - count); i++) {
writeUnsignedShort(0);
}
break;
case TIFFField.TIFF_LONG:
writeLong(field.getAsLong(0));
break;
case TIFFField.TIFF_SLONG:
writeLong(field.getAsInt(0));
break;
case TIFFField.TIFF_FLOAT:
writeLong(Float.floatToIntBits(field.getAsFloat(0)));
break;
case TIFFField.TIFF_ASCII:
int asciiByteCount=0;
for (int i=0; i < count; i++) {
byte[] stringBytes=field.getAsString(i).getBytes();
output.write(stringBytes);
asciiByteCount+=stringBytes.length;
if (stringBytes[stringBytes.length - 1] != (byte)0) {
output.write(0);
asciiByteCount++;
}
}
for (int i=0; i < (4 - asciiByteCount); i++) {
output.write(0);
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
}",0.9934819897084048
154054,"private void writeValues(TIFFField field) throws IOException {
  int dataType=field.getType();
  int count=field.getCount();
switch (dataType) {
case TIFFField.TIFF_BYTE:
case TIFFField.TIFF_SBYTE:
case TIFFField.TIFF_UNDEFINED:
    byte bytes[]=field.getAsBytes();
  for (int i=0; i < count; i++) {
    output.write(bytes[i]);
  }
break;
case TIFFField.TIFF_SHORT:
char shorts[]=field.getAsChars();
for (int i=0; i < count; i++) {
writeUnsignedShort(shorts[i]);
}
break;
case TIFFField.TIFF_SSHORT:
short sshorts[]=field.getAsShorts();
for (int i=0; i < count; i++) {
writeUnsignedShort(sshorts[i]);
}
break;
case TIFFField.TIFF_LONG:
long longs[]=field.getAsLongs();
for (int i=0; i < count; i++) {
writeLong(longs[i]);
}
break;
case TIFFField.TIFF_SLONG:
int slongs[]=field.getAsInts();
for (int i=0; i < count; i++) {
writeLong(slongs[i]);
}
break;
case TIFFField.TIFF_FLOAT:
float[] floats=field.getAsFloats();
for (int i=0; i < count; i++) {
int intBits=Float.floatToIntBits(floats[i]);
writeLong(intBits);
}
break;
case TIFFField.TIFF_DOUBLE:
double[] doubles=field.getAsDoubles();
for (int i=0; i < count; i++) {
long longBits=Double.doubleToLongBits(doubles[i]);
writeLong((int)(longBits >> 32));
writeLong((int)(longBits & 0xffffffff));
}
break;
case TIFFField.TIFF_RATIONAL:
long rationals[][]=field.getAsRationals();
for (int i=0; i < count; i++) {
writeLong(rationals[i][0]);
writeLong(rationals[i][1]);
}
break;
case TIFFField.TIFF_SRATIONAL:
int srationals[][]=field.getAsSRationals();
for (int i=0; i < count; i++) {
writeLong(srationals[i][0]);
writeLong(srationals[i][1]);
}
break;
case TIFFField.TIFF_ASCII:
for (int i=0; i < count; i++) {
byte[] stringBytes=field.getAsString(i).getBytes();
output.write(stringBytes);
if (stringBytes[stringBytes.length - 1] != (byte)0) {
output.write(0);
}
}
break;
default :
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
}","private void writeValues(TIFFField field) throws IOException {
  int dataType=field.getType();
  int count=field.getCount();
switch (dataType) {
case TIFFField.TIFF_BYTE:
case TIFFField.TIFF_SBYTE:
case TIFFField.TIFF_UNDEFINED:
    byte bytes[]=field.getAsBytes();
  for (int i=0; i < count; i++) {
    output.write(bytes[i]);
  }
break;
case TIFFField.TIFF_SHORT:
char shorts[]=field.getAsChars();
for (int i=0; i < count; i++) {
writeUnsignedShort(shorts[i]);
}
break;
case TIFFField.TIFF_SSHORT:
short sshorts[]=field.getAsShorts();
for (int i=0; i < count; i++) {
writeUnsignedShort(sshorts[i]);
}
break;
case TIFFField.TIFF_LONG:
long longs[]=field.getAsLongs();
for (int i=0; i < count; i++) {
writeLong(longs[i]);
}
break;
case TIFFField.TIFF_SLONG:
int slongs[]=field.getAsInts();
for (int i=0; i < count; i++) {
writeLong(slongs[i]);
}
break;
case TIFFField.TIFF_FLOAT:
float[] floats=field.getAsFloats();
for (int i=0; i < count; i++) {
int intBits=Float.floatToIntBits(floats[i]);
writeLong(intBits);
}
break;
case TIFFField.TIFF_DOUBLE:
double[] doubles=field.getAsDoubles();
for (int i=0; i < count; i++) {
long longBits=Double.doubleToLongBits(doubles[i]);
writeLong((int)(longBits >> 32));
writeLong((int)(longBits & 0xffffffff));
}
break;
case TIFFField.TIFF_RATIONAL:
long rationals[][]=field.getAsRationals();
for (int i=0; i < count; i++) {
writeLong(rationals[i][0]);
writeLong(rationals[i][1]);
}
break;
case TIFFField.TIFF_SRATIONAL:
int srationals[][]=field.getAsSRationals();
for (int i=0; i < count; i++) {
writeLong(srationals[i][0]);
writeLong(srationals[i][1]);
}
break;
case TIFFField.TIFF_ASCII:
for (int i=0; i < count; i++) {
byte[] stringBytes=field.getAsString(i).getBytes();
output.write(stringBytes);
if (stringBytes[stringBytes.length - 1] != (byte)0) {
output.write(0);
}
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
}",0.994982836017956
154055,"/** 
 * Performs bicubic affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int mlibInterpType=Constants.MLIB_BICUBIC;
  if (interp instanceof InterpolationBicubic2) {
    mlibInterpType=Constants.MLIB_BICUBIC2;
  }
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs bicubic affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  int mlibInterpType=Constants.MLIB_BICUBIC;
  if (interp instanceof InterpolationBicubic2) {
    mlibInterpType=Constants.MLIB_BICUBIC2;
  }
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpType,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.99571975670196
154056,"/** 
 * Performs bilinear affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs bilinear affine transformation on a specified rectangle.  The sources are cobbled and extended.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_BILINEAR,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.9950342870655
154057,"/** 
 * Performs nearest-neighbour affine transformation on a specified rectangle.  The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs nearest-neighbour affine transformation on a specified rectangle.  The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    srcML=srcAccessor.getMediaLibImages();
  dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.Affine(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.Affine2_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.Affine_Fp(dstML[0],srcML[0],medialib_tr,Constants.MLIB_NEAREST,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.995015428435794
154058,"/** 
 * Performs nearest-neighbour affine transformation on a specified rectangle.  The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  InterpolationTable jtable=(InterpolationTable)interp;
  mediaLibImageInterpTable mlibInterpTable;
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
  srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.AffineTable(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_DOUBLE:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new Error(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs nearest-neighbour affine transformation on a specified rectangle.  The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  InterpolationTable jtable=(InterpolationTable)interp;
  mediaLibImageInterpTable mlibInterpTable;
  Raster source=sources[0];
  Rectangle srcRect=source.getBounds();
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag);
  double[] medialib_tr=(double[])this.medialib_tr.clone();
  medialib_tr[2]=m_transform[0] * srcRect.x + m_transform[1] * srcRect.y + m_transform[2] - destRect.x;
  medialib_tr[5]=m_transform[3] * srcRect.x + m_transform[4] * srcRect.y + m_transform[5] - destRect.y;
  mediaLibImage srcML[], dstML[];
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
    mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_INT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableData(),jtable.getVerticalTableData());
  srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,intBackgroundValues);
 else Image.AffineTable(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_FLOAT:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_FLOAT,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataFloat(),jtable.getVerticalTableDataFloat());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
case DataBuffer.TYPE_DOUBLE:
mlibInterpTable=new mediaLibImageInterpTable(Constants.MLIB_DOUBLE,jtable.getWidth(),jtable.getHeight(),jtable.getLeftPadding(),jtable.getTopPadding(),jtable.getSubsampleBitsH(),jtable.getSubsampleBitsV(),jtable.getPrecisionBits(),jtable.getHorizontalTableDataDouble(),jtable.getVerticalTableDataDouble());
srcML=srcAccessor.getMediaLibImages();
dstML=dstAccessor.getMediaLibImages();
if (setBackground) Image.AffineTable2_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE,backgroundValues);
 else Image.AffineTable_Fp(dstML[0],srcML[0],medialib_tr,mlibInterpTable,Constants.MLIB_EDGE_DST_NO_WRITE);
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.9972331440221348
154059,"/** 
 * Constructs an <code>CompositeOpImage</code>.
 * @param source1             The foreground source image.
 * @param source2             The background source image.
 * @param layout              The destination image layout.
 * @param source1Alpha        The alpha image that overrides thealpha for source1; may not be null.
 * @param source2Alpha        The alpha image that overrides the alpha forsource2; may be null, in which case source2 is considered completely opaque.
 * @param alphaPremultiplied  Indicates whether alpha has beenpremultiplied to both sources.
 * @param alphaFirst          If true, alpha is the first band (band 0) indestination image; if false, alpha is the last band.
 */
public CompositeOpImage(RenderedImage source1,RenderedImage source2,Map config,ImageLayout layout,RenderedImage source1Alpha,RenderedImage source2Alpha,boolean alphaPremultiplied,boolean alphaFirst){
  super(source1,source2,layout,config,true);
  this.source1Alpha=source1Alpha;
  this.source2Alpha=source2Alpha;
  this.alphaPremultiplied=alphaPremultiplied;
  SampleModel sm=source1.getSampleModel();
  int dtype=sm.getTransferType();
  int bands=sm.getNumBands() + 1;
  if (sampleModel.getTransferType() != dtype || sampleModel.getNumBands() != bands) {
    sampleModel=RasterFactory.createComponentSampleModel(sampleModel,dtype,tileWidth,tileHeight,bands);
    if (colorModel != null && !JDKWorkarounds.areCompatibleDataModels(sampleModel,colorModel)) {
      colorModel=ImageUtil.getCompatibleColorModel(sampleModel,config);
    }
  }
  aOffset=alphaFirst ? 0 : bands - 1;
  cOffset=alphaFirst ? 1 : 0;
switch (dtype) {
case DataBuffer.TYPE_BYTE:
    maxValue=0xFF;
  maxValueByte=(byte)0xFF;
break;
case DataBuffer.TYPE_USHORT:
maxValue=0xFFFF;
maxValueShort=(short)0xFFFF;
break;
case DataBuffer.TYPE_SHORT:
maxValue=Short.MAX_VALUE;
maxValueShort=Short.MAX_VALUE;
break;
case DataBuffer.TYPE_INT:
maxValue=Integer.MAX_VALUE;
break;
default :
}
invMaxValue=1.0F / maxValue;
}","/** 
 * Constructs an <code>CompositeOpImage</code>.
 * @param source1             The foreground source image.
 * @param source2             The background source image.
 * @param layout              The destination image layout.
 * @param source1Alpha        The alpha image that overrides thealpha for source1; may not be null.
 * @param source2Alpha        The alpha image that overrides the alpha forsource2; may be null, in which case source2 is considered completely opaque.
 * @param alphaPremultiplied  Indicates whether alpha has beenpremultiplied to both sources.
 * @param alphaFirst          If true, alpha is the first band (band 0) indestination image; if false, alpha is the last band.
 */
public CompositeOpImage(RenderedImage source1,RenderedImage source2,Map config,ImageLayout layout,RenderedImage source1Alpha,RenderedImage source2Alpha,boolean alphaPremultiplied,boolean alphaFirst){
  super(source1,source2,layout,config,true);
  this.source1Alpha=source1Alpha;
  this.source2Alpha=source2Alpha;
  this.alphaPremultiplied=alphaPremultiplied;
  SampleModel sm=source1.getSampleModel();
  ColorModel cm=source1.getColorModel();
  int dtype=sm.getTransferType();
  int bands;
  if (cm instanceof IndexColorModel) {
    bands=cm.getNumComponents();
  }
 else {
    bands=sm.getNumBands();
  }
  bands+=1;
  if (sampleModel.getTransferType() != dtype || sampleModel.getNumBands() != bands) {
    sampleModel=RasterFactory.createComponentSampleModel(sampleModel,dtype,tileWidth,tileHeight,bands);
    if (colorModel != null && !JDKWorkarounds.areCompatibleDataModels(sampleModel,colorModel)) {
      colorModel=ImageUtil.getCompatibleColorModel(sampleModel,config);
    }
  }
  aOffset=alphaFirst ? 0 : bands - 1;
  cOffset=alphaFirst ? 1 : 0;
switch (dtype) {
case DataBuffer.TYPE_BYTE:
    maxValue=0xFF;
  maxValueByte=(byte)0xFF;
break;
case DataBuffer.TYPE_USHORT:
maxValue=0xFFFF;
maxValueShort=(short)0xFFFF;
break;
case DataBuffer.TYPE_SHORT:
maxValue=Short.MAX_VALUE;
maxValueShort=Short.MAX_VALUE;
break;
case DataBuffer.TYPE_INT:
maxValue=Integer.MAX_VALUE;
break;
default :
}
invMaxValue=1.0F / maxValue;
}",0.960213488597768
154060,"/** 
 * Validates the input parameters. <p> In addition to the standard checks performed by the superclass method, this method by default checks that the source file exists and is readable. This check may be bypassed by setting the <code>checkFileLocally</code> parameter to <code>FALSE</code>
 */
protected boolean validateParameters(ParameterBlock args,StringBuffer msg){
  if (!super.validateParameters(args,msg)) {
    return false;
  }
  Boolean checkFile=(Boolean)args.getObjectParameter(2);
  if (checkFile.booleanValue()) {
    String filename=(String)args.getObjectParameter(0);
    File f=new File(filename);
    boolean fileExists=f.exists();
    if (!fileExists) {
      InputStream is=getClass().getResourceAsStream(filename);
      if (is == null) {
        msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
        return false;
      }
    }
 else {
      if (!f.canRead()) {
        msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
        return false;
      }
    }
  }
  return true;
}","/** 
 * Validates the input parameters. <p> In addition to the standard checks performed by the superclass method, this method by default checks that the source file exists and is readable. This check may be bypassed by setting the <code>checkFileLocally</code> parameter to <code>FALSE</code>
 */
protected boolean validateParameters(ParameterBlock args,StringBuffer msg){
  if (!super.validateParameters(args,msg)) {
    return false;
  }
  Boolean checkFile=(Boolean)args.getObjectParameter(2);
  if (checkFile.booleanValue()) {
    String filename=(String)args.getObjectParameter(0);
    File f=new File(filename);
    boolean fileExists=f.exists();
    if (!fileExists) {
      InputStream is=this.getClass().getClassLoader().getResourceAsStream(filename);
      if (is == null) {
        msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
        return false;
      }
    }
 else {
      if (!f.canRead()) {
        msg.append(""String_Node_Str"" + filename + ""String_Node_Str""+ JaiI18N.getString(""String_Node_Str""));
        return false;
      }
    }
  }
  return true;
}",0.990152193375112
154061,"/** 
 * Sets the compression level for DEFLATE-compressed data which should either be <code>java.util.Deflater.DEFAULT_COMPRESSION</code> or a value in the range [1,9] where larger values indicate more compression. The default setting is <code>Deflater.DEFAULT_COMPRESSION</code>.  This setting is ignored if the compression type is not DEFLATE.
 */
public void setDeflateLevel(int deflateLevel){
  if (deflateLevel < 1 && deflateLevel > 9 && deflateLevel != Deflater.DEFAULT_COMPRESSION) {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  this.deflateLevel=deflateLevel;
}","/** 
 * Sets the compression level for DEFLATE-compressed data which should either be <code>java.util.Deflater.DEFAULT_COMPRESSION</code> or a value in the range [1,9] where larger values indicate more compression. The default setting is <code>Deflater.DEFAULT_COMPRESSION</code>.  This setting is ignored if the compression type is not DEFLATE.
 * @throws IllegalArgumentException if <code>deflateLevel</code> isnot in the range <code>[1,&nbsp;9]</code> and is not {@link Deflater#DEFAULT_COMPRESSION}.
 */
public void setDeflateLevel(int deflateLevel){
  if (deflateLevel < 1 && deflateLevel > 9 && deflateLevel != Deflater.DEFAULT_COMPRESSION) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  this.deflateLevel=deflateLevel;
}",0.6878228782287823
154062,"/** 
 * Specifies the type of compression to be used.  The compression type specified will be honored only if it is compatible with the image being written out.  Currently only PackBits, JPEG, and DEFLATE compression schemes are supported. <p> If <code>compression</code> is set to any value but <code>COMPRESSION_NONE</code> and the <code>OutputStream</code> supplied to the <code>ImageEncoder</code> is not a <code>SeekableOutputStream</code>, then the encoder will use either a temporary file or a memory cache when compressing the data depending on whether the file system is accessible.  Compression will therefore be more efficient if a <code>SeekableOutputStream</code> is supplied.
 * @param compression    The compression type.
 */
public void setCompression(int compression){
switch (compression) {
case COMPRESSION_NONE:
case COMPRESSION_GROUP3_1D:
case COMPRESSION_GROUP3_2D:
case COMPRESSION_GROUP4:
case COMPRESSION_PACKBITS:
case COMPRESSION_JPEG_TTN2:
case COMPRESSION_DEFLATE:
    break;
default :
  throw new Error(JaiI18N.getString(""String_Node_Str""));
}
this.compression=compression;
}","/** 
 * Specifies the type of compression to be used.  The compression type specified will be honored only if it is compatible with the image being written out.  Currently only PackBits, JPEG, and DEFLATE compression schemes are supported. <p> If <code>compression</code> is set to any value but <code>COMPRESSION_NONE</code> and the <code>OutputStream</code> supplied to the <code>ImageEncoder</code> is not a <code>SeekableOutputStream</code>, then the encoder will use either a temporary file or a memory cache when compressing the data depending on whether the file system is accessible.  Compression will therefore be more efficient if a <code>SeekableOutputStream</code> is supplied.
 * @param compression    The compression type.
 * @throws IllegalArgumentException if <code>compression</code> isnot one of the defined <code>COMPRESSION_*</code> constants.
 */
public void setCompression(int compression){
switch (compression) {
case COMPRESSION_NONE:
case COMPRESSION_GROUP3_1D:
case COMPRESSION_GROUP3_2D:
case COMPRESSION_GROUP4:
case COMPRESSION_PACKBITS:
case COMPRESSION_JPEG_TTN2:
case COMPRESSION_DEFLATE:
    break;
default :
  throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
}
this.compression=compression;
}",0.933786078098472
154063,"/** 
 * Constructs a TIFFImage that acquires its data from a given SeekableStream and reads from a particular IFD of the stream. The index of the first IFD is 0.
 * @param stream the SeekableStream to read from.
 * @param param an instance of TIFFDecodeParam, or null.
 * @param directory the index of the IFD to read from.
 */
public TIFFImage(SeekableStream stream,TIFFDecodeParam param,int directory) throws IOException {
  this.stream=stream;
  if (param == null) {
    param=new TIFFDecodeParam();
  }
  decodePaletteAsShorts=param.getDecodePaletteAsShorts();
  TIFFDirectory dir=param.getIFDOffset() == null ? new TIFFDirectory(stream,directory) : new TIFFDirectory(stream,param.getIFDOffset().longValue(),directory);
  properties.put(""String_Node_Str"",dir);
  TIFFField sfield=dir.getField(TIFFImageDecoder.TIFF_SAMPLES_PER_PIXEL);
  int samplesPerPixel=sfield == null ? 1 : (int)sfield.getAsLong(0);
  TIFFField planarConfigurationField=dir.getField(TIFFImageDecoder.TIFF_PLANAR_CONFIGURATION);
  char[] planarConfiguration=planarConfigurationField == null ? new char[]{1} : planarConfigurationField.getAsChars();
  if (planarConfiguration[0] != 1 && samplesPerPixel != 1) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  TIFFField bitsField=dir.getField(TIFFImageDecoder.TIFF_BITS_PER_SAMPLE);
  char[] bitsPerSample=null;
  if (bitsField != null) {
    bitsPerSample=bitsField.getAsChars();
  }
 else {
    bitsPerSample=new char[]{1};
    for (int i=1; i < bitsPerSample.length; i++) {
      if (bitsPerSample[i] != bitsPerSample[0]) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
    }
  }
  sampleSize=(int)bitsPerSample[0];
  TIFFField sampleFormatField=dir.getField(TIFFImageDecoder.TIFF_SAMPLE_FORMAT);
  char[] sampleFormat=null;
  if (sampleFormatField != null) {
    sampleFormat=sampleFormatField.getAsChars();
    for (int l=1; l < sampleFormat.length; l++) {
      if (sampleFormat[l] != sampleFormat[0]) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
    }
  }
 else {
    sampleFormat=new char[]{1};
  }
  boolean isValidDataFormat=false;
switch (sampleSize) {
case 1:
case 4:
case 8:
    if (sampleFormat[0] != 3) {
      dataType=DataBuffer.TYPE_BYTE;
      isValidDataFormat=true;
    }
  break;
case 16:
if (sampleFormat[0] != 3) {
  dataType=sampleFormat[0] == 2 ? DataBuffer.TYPE_SHORT : DataBuffer.TYPE_USHORT;
  isValidDataFormat=true;
}
break;
case 32:
dataType=sampleFormat[0] == 3 ? DataBuffer.TYPE_FLOAT : DataBuffer.TYPE_INT;
isValidDataFormat=true;
break;
}
if (!isValidDataFormat) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
TIFFField compField=dir.getField(TIFFImageDecoder.TIFF_COMPRESSION);
compression=compField == null ? COMP_NONE : compField.getAsInt(0);
TIFFField photoInterpField=dir.getField(TIFFImageDecoder.TIFF_PHOTOMETRIC_INTERPRETATION);
int photometricType;
if (photoInterpField != null) {
photometricType=(int)photoInterpField.getAsLong(0);
}
 else {
if (dir.getField(TIFFImageDecoder.TIFF_COLORMAP) != null) {
photometricType=3;
}
 else if (sampleSize == 1) {
if (compression == COMP_FAX_G3_1D || compression == COMP_FAX_G3_2D || compression == COMP_FAX_G4_2D) {
photometricType=0;
}
 else {
photometricType=1;
}
}
 else if (samplesPerPixel == 3 || samplesPerPixel == 4) {
photometricType=2;
}
 else {
photometricType=1;
}
}
imageType=TYPE_UNSUPPORTED;
switch (photometricType) {
case 0:
isWhiteZero=true;
case 1:
if (sampleSize == 1 && samplesPerPixel == 1) {
imageType=TYPE_BILEVEL;
}
 else if (sampleSize == 4 && samplesPerPixel == 1) {
imageType=TYPE_GRAY_4BIT;
}
 else if (sampleSize % 8 == 0) {
if (samplesPerPixel == 1) {
imageType=TYPE_GRAY;
}
 else if (samplesPerPixel == 2) {
imageType=TYPE_GRAY_ALPHA;
}
 else {
imageType=TYPE_GENERIC;
}
}
break;
case 2:
if (sampleSize % 8 == 0) {
if (samplesPerPixel == 3) {
imageType=TYPE_RGB;
}
 else if (samplesPerPixel == 4) {
imageType=TYPE_RGB_ALPHA;
}
 else {
imageType=TYPE_GENERIC;
}
}
break;
case 3:
if (samplesPerPixel == 1 && (sampleSize == 4 || sampleSize == 8 || sampleSize == 16)) {
imageType=TYPE_PALETTE;
}
break;
case 4:
if (sampleSize == 1 && samplesPerPixel == 1) {
imageType=TYPE_BILEVEL;
}
break;
case 6:
if (compression == COMP_JPEG_TTN2 && sampleSize == 8 && samplesPerPixel == 3) {
colorConvertJPEG=param.getJPEGDecompressYCbCrToRGB();
imageType=colorConvertJPEG ? TYPE_RGB : TYPE_GENERIC;
}
 else {
TIFFField chromaField=dir.getField(TIFF_YCBCR_SUBSAMPLING);
if (chromaField != null) {
chromaSubH=chromaField.getAsInt(0);
chromaSubV=chromaField.getAsInt(1);
}
 else {
chromaSubH=chromaSubV=2;
}
if (chromaSubH * chromaSubV == 1) {
imageType=TYPE_GENERIC;
}
 else if (sampleSize == 8 && samplesPerPixel == 3) {
imageType=TYPE_YCBCR_SUB;
}
}
break;
default :
if (sampleSize % 8 == 0) {
imageType=TYPE_GENERIC;
}
}
if (imageType == TYPE_UNSUPPORTED) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
minX=minY=0;
width=(int)(getField(dir,TIFFImageDecoder.TIFF_IMAGE_WIDTH,""String_Node_Str"").getAsLong(0));
height=(int)(getField(dir,TIFFImageDecoder.TIFF_IMAGE_LENGTH,""String_Node_Str"").getAsLong(0));
numBands=samplesPerPixel;
TIFFField efield=dir.getField(TIFFImageDecoder.TIFF_EXTRA_SAMPLES);
int extraSamples=efield == null ? 0 : (int)efield.getAsLong(0);
if (dir.getField(TIFFImageDecoder.TIFF_TILE_OFFSETS) != null) {
isTiled=true;
tileWidth=(int)(getField(dir,TIFFImageDecoder.TIFF_TILE_WIDTH,""String_Node_Str"").getAsLong(0));
tileHeight=(int)(getField(dir,TIFFImageDecoder.TIFF_TILE_LENGTH,""String_Node_Str"").getAsLong(0));
tileOffsets=(getField(dir,TIFFImageDecoder.TIFF_TILE_OFFSETS,""String_Node_Str"")).getAsLongs();
tileByteCounts=getFieldAsLongs(getField(dir,TIFFImageDecoder.TIFF_TILE_BYTE_COUNTS,""String_Node_Str""));
}
 else {
isTiled=false;
tileWidth=dir.getField(TIFFImageDecoder.TIFF_TILE_WIDTH) != null ? (int)dir.getFieldAsLong(TIFFImageDecoder.TIFF_TILE_WIDTH) : width;
TIFFField field=dir.getField(TIFFImageDecoder.TIFF_ROWS_PER_STRIP);
if (field == null) {
tileHeight=dir.getField(TIFFImageDecoder.TIFF_TILE_LENGTH) != null ? (int)dir.getFieldAsLong(TIFFImageDecoder.TIFF_TILE_LENGTH) : height;
}
 else {
long l=field.getAsLong(0);
long infinity=1;
infinity=(infinity << 32) - 1;
if (l == infinity || l > height) {
tileHeight=height;
}
 else {
tileHeight=(int)l;
}
}
TIFFField tileOffsetsField=getField(dir,TIFFImageDecoder.TIFF_STRIP_OFFSETS,""String_Node_Str"");
tileOffsets=getFieldAsLongs(tileOffsetsField);
TIFFField tileByteCountsField=dir.getField(TIFFImageDecoder.TIFF_STRIP_BYTE_COUNTS);
if (tileByteCountsField == null) {
int totalBytes=((sampleSize + 7) / 8) * numBands * width* height;
int bytesPerStrip=((sampleSize + 7) / 8) * numBands * width* tileHeight;
int cumulativeBytes=0;
tileByteCounts=new long[tileOffsets.length];
for (int i=0; i < tileOffsets.length; i++) {
tileByteCounts[i]=Math.min(totalBytes - cumulativeBytes,bytesPerStrip);
cumulativeBytes+=bytesPerStrip;
}
if (compression != COMP_NONE) {
this.stream=new NoEOFStream(stream);
}
}
 else {
tileByteCounts=getFieldAsLongs(tileByteCountsField);
}
int maxBytes=width * height * numBands* ((sampleSize + 7) / 8);
if (tileByteCounts.length == 1 && compression == COMP_NONE && tileByteCounts[0] > maxBytes) {
tileByteCounts[0]=maxBytes;
}
}
tilesX=(width + tileWidth - 1) / tileWidth;
tilesY=(height + tileHeight - 1) / tileHeight;
tileSize=tileWidth * tileHeight * numBands;
isBigEndian=dir.isBigEndian();
TIFFField fillOrderField=dir.getField(TIFFImageDecoder.TIFF_FILL_ORDER);
if (fillOrderField != null) {
fillOrder=fillOrderField.getAsInt(0);
}
 else {
fillOrder=1;
}
switch (compression) {
case COMP_NONE:
case COMP_PACKBITS:
break;
case COMP_DEFLATE:
inflater=new Inflater();
break;
case COMP_FAX_G3_1D:
case COMP_FAX_G3_2D:
case COMP_FAX_G4_2D:
if (sampleSize != 1) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (compression == 3) {
TIFFField t4OptionsField=dir.getField(TIFFImageDecoder.TIFF_T4_OPTIONS);
if (t4OptionsField != null) {
tiffT4Options=t4OptionsField.getAsLong(0);
}
 else {
tiffT4Options=0;
}
}
if (compression == 4) {
TIFFField t6OptionsField=dir.getField(TIFFImageDecoder.TIFF_T6_OPTIONS);
if (t6OptionsField != null) {
tiffT6Options=t6OptionsField.getAsLong(0);
}
 else {
tiffT6Options=0;
}
}
decoder=new TIFFFaxDecoder(fillOrder,tileWidth,tileHeight);
break;
case COMP_LZW:
TIFFField predictorField=dir.getField(TIFFImageDecoder.TIFF_PREDICTOR);
if (predictorField == null) {
predictor=1;
}
 else {
predictor=predictorField.getAsInt(0);
if (predictor != 1 && predictor != 2) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (predictor == 2 && sampleSize != 8) {
throw new RuntimeException(sampleSize + JaiI18N.getString(""String_Node_Str""));
}
}
lzwDecoder=new TIFFLZWDecoder(tileWidth,predictor,samplesPerPixel);
break;
case COMP_JPEG_OLD:
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
case COMP_JPEG_TTN2:
if (!(sampleSize == 8 && ((imageType == TYPE_GRAY && samplesPerPixel == 1) || (imageType == TYPE_PALETTE && samplesPerPixel == 1) || (imageType == TYPE_RGB && samplesPerPixel == 3)))) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dir.isTagPresent(TIFF_JPEG_TABLES)) {
TIFFField jpegTableField=dir.getField(TIFF_JPEG_TABLES);
byte[] jpegTable=jpegTableField.getAsBytes();
ByteArrayInputStream tableStream=new ByteArrayInputStream(jpegTable);
JPEGImageDecoder decoder=JPEGCodec.createJPEGDecoder(tableStream);
decoder.decodeAsRaster();
decodeParam=decoder.getJPEGDecodeParam();
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
switch (imageType) {
case TYPE_BILEVEL:
case TYPE_GRAY_4BIT:
sampleModel=new MultiPixelPackedSampleModel(dataType,tileWidth,tileHeight,sampleSize);
if (imageType == TYPE_BILEVEL) {
byte[] map=new byte[]{(byte)(isWhiteZero ? 255 : 0),(byte)(isWhiteZero ? 0 : 255)};
colorModel=new IndexColorModel(1,2,map,map,map);
}
 else {
colorModel=ImageCodec.createGrayIndexColorModel(sampleModel,!isWhiteZero);
}
break;
case TYPE_GRAY:
case TYPE_GRAY_ALPHA:
case TYPE_RGB:
case TYPE_RGB_ALPHA:
int[] RGBOffsets=new int[numBands];
if (compression == COMP_JPEG_TTN2) {
for (int i=0; i < numBands; i++) {
RGBOffsets[i]=numBands - 1 - i;
}
}
 else {
for (int i=0; i < numBands; i++) {
RGBOffsets[i]=i;
}
}
sampleModel=createPixelInterleavedSampleModel(dataType,tileWidth,tileHeight,numBands,numBands * tileWidth,RGBOffsets);
if (imageType == TYPE_GRAY || imageType == TYPE_RGB) {
colorModel=ImageCodec.createComponentColorModel(sampleModel);
}
 else {
int transparency=Transparency.OPAQUE;
if (extraSamples == 1 || extraSamples == 2) {
transparency=Transparency.TRANSLUCENT;
}
colorModel=createAlphaComponentColorModel(dataType,numBands,extraSamples == 1,transparency);
}
break;
case TYPE_GENERIC:
case TYPE_YCBCR_SUB:
int[] bandOffsets=new int[numBands];
for (int i=0; i < numBands; i++) {
bandOffsets[i]=i;
}
sampleModel=createPixelInterleavedSampleModel(dataType,tileWidth,tileHeight,numBands,numBands * tileWidth,bandOffsets);
colorModel=null;
break;
case TYPE_PALETTE:
TIFFField cfield=getField(dir,TIFFImageDecoder.TIFF_COLORMAP,""String_Node_Str"");
colormap=cfield.getAsChars();
if (decodePaletteAsShorts) {
numBands=3;
if (dataType == DataBuffer.TYPE_BYTE) {
dataType=DataBuffer.TYPE_USHORT;
}
sampleModel=RasterFactory.createPixelInterleavedSampleModel(dataType,tileWidth,tileHeight,numBands);
colorModel=ImageCodec.createComponentColorModel(sampleModel);
}
 else {
numBands=1;
if (sampleSize == 4) {
sampleModel=new MultiPixelPackedSampleModel(DataBuffer.TYPE_BYTE,tileWidth,tileHeight,sampleSize);
}
 else if (sampleSize == 8) {
sampleModel=RasterFactory.createPixelInterleavedSampleModel(DataBuffer.TYPE_BYTE,tileWidth,tileHeight,numBands);
}
 else if (sampleSize == 16) {
dataType=DataBuffer.TYPE_USHORT;
sampleModel=RasterFactory.createPixelInterleavedSampleModel(DataBuffer.TYPE_USHORT,tileWidth,tileHeight,numBands);
}
int bandLength=colormap.length / 3;
byte r[]=new byte[bandLength];
byte g[]=new byte[bandLength];
byte b[]=new byte[bandLength];
int gIndex=bandLength;
int bIndex=bandLength * 2;
if (dataType == DataBuffer.TYPE_SHORT) {
for (int i=0; i < bandLength; i++) {
r[i]=param.decodeSigned16BitsTo8Bits((short)colormap[i]);
g[i]=param.decodeSigned16BitsTo8Bits((short)colormap[gIndex + i]);
b[i]=param.decodeSigned16BitsTo8Bits((short)colormap[bIndex + i]);
}
}
 else {
for (int i=0; i < bandLength; i++) {
r[i]=param.decode16BitsTo8Bits(colormap[i] & 0xffff);
g[i]=param.decode16BitsTo8Bits(colormap[gIndex + i] & 0xffff);
b[i]=param.decode16BitsTo8Bits(colormap[bIndex + i] & 0xffff);
}
}
colorModel=new IndexColorModel(sampleSize,bandLength,r,g,b);
}
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}","/** 
 * Constructs a TIFFImage that acquires its data from a given SeekableStream and reads from a particular IFD of the stream. The index of the first IFD is 0.
 * @param stream the SeekableStream to read from.
 * @param param an instance of TIFFDecodeParam, or null.
 * @param directory the index of the IFD to read from.
 */
public TIFFImage(SeekableStream stream,TIFFDecodeParam param,int directory) throws IOException {
  this.stream=stream;
  if (param == null) {
    param=new TIFFDecodeParam();
  }
  decodePaletteAsShorts=param.getDecodePaletteAsShorts();
  TIFFDirectory dir=param.getIFDOffset() == null ? new TIFFDirectory(stream,directory) : new TIFFDirectory(stream,param.getIFDOffset().longValue(),directory);
  properties.put(""String_Node_Str"",dir);
  TIFFField sfield=dir.getField(TIFFImageDecoder.TIFF_SAMPLES_PER_PIXEL);
  int samplesPerPixel=sfield == null ? 1 : (int)sfield.getAsLong(0);
  TIFFField planarConfigurationField=dir.getField(TIFFImageDecoder.TIFF_PLANAR_CONFIGURATION);
  char[] planarConfiguration=planarConfigurationField == null ? new char[]{1} : planarConfigurationField.getAsChars();
  if (planarConfiguration[0] != 1 && samplesPerPixel != 1) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  TIFFField bitsField=dir.getField(TIFFImageDecoder.TIFF_BITS_PER_SAMPLE);
  char[] bitsPerSample=null;
  if (bitsField != null) {
    bitsPerSample=bitsField.getAsChars();
  }
 else {
    bitsPerSample=new char[]{1};
    for (int i=1; i < bitsPerSample.length; i++) {
      if (bitsPerSample[i] != bitsPerSample[0]) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
    }
  }
  sampleSize=(int)bitsPerSample[0];
  TIFFField sampleFormatField=dir.getField(TIFFImageDecoder.TIFF_SAMPLE_FORMAT);
  char[] sampleFormat=null;
  if (sampleFormatField != null) {
    sampleFormat=sampleFormatField.getAsChars();
    for (int l=1; l < sampleFormat.length; l++) {
      if (sampleFormat[l] != sampleFormat[0]) {
        throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
      }
    }
  }
 else {
    sampleFormat=new char[]{1};
  }
  boolean isValidDataFormat=false;
switch (sampleSize) {
case 1:
case 4:
case 8:
    if (sampleFormat[0] != 3) {
      dataType=DataBuffer.TYPE_BYTE;
      isValidDataFormat=true;
    }
  break;
case 16:
if (sampleFormat[0] != 3) {
  dataType=sampleFormat[0] == 2 ? DataBuffer.TYPE_SHORT : DataBuffer.TYPE_USHORT;
  isValidDataFormat=true;
}
break;
case 32:
dataType=sampleFormat[0] == 3 ? DataBuffer.TYPE_FLOAT : DataBuffer.TYPE_INT;
isValidDataFormat=true;
break;
}
if (!isValidDataFormat) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
TIFFField compField=dir.getField(TIFFImageDecoder.TIFF_COMPRESSION);
compression=compField == null ? COMP_NONE : compField.getAsInt(0);
TIFFField photoInterpField=dir.getField(TIFFImageDecoder.TIFF_PHOTOMETRIC_INTERPRETATION);
int photometricType;
if (photoInterpField != null) {
photometricType=(int)photoInterpField.getAsLong(0);
}
 else {
if (dir.getField(TIFFImageDecoder.TIFF_COLORMAP) != null) {
photometricType=3;
}
 else if (sampleSize == 1) {
if (compression == COMP_FAX_G3_1D || compression == COMP_FAX_G3_2D || compression == COMP_FAX_G4_2D) {
photometricType=0;
}
 else {
photometricType=1;
}
}
 else if (samplesPerPixel == 3 || samplesPerPixel == 4) {
photometricType=2;
}
 else {
photometricType=1;
}
}
imageType=TYPE_UNSUPPORTED;
switch (photometricType) {
case 0:
isWhiteZero=true;
case 1:
if (sampleSize == 1 && samplesPerPixel == 1) {
imageType=TYPE_BILEVEL;
}
 else if (sampleSize == 4 && samplesPerPixel == 1) {
imageType=TYPE_GRAY_4BIT;
}
 else if (sampleSize % 8 == 0) {
if (samplesPerPixel == 1) {
imageType=TYPE_GRAY;
}
 else if (samplesPerPixel == 2) {
imageType=TYPE_GRAY_ALPHA;
}
 else {
imageType=TYPE_GENERIC;
}
}
break;
case 2:
if (sampleSize % 8 == 0) {
if (samplesPerPixel == 3) {
imageType=TYPE_RGB;
}
 else if (samplesPerPixel == 4) {
imageType=TYPE_RGB_ALPHA;
}
 else {
imageType=TYPE_GENERIC;
}
}
break;
case 3:
if (samplesPerPixel == 1 && (sampleSize == 4 || sampleSize == 8 || sampleSize == 16)) {
imageType=TYPE_PALETTE;
}
break;
case 4:
if (sampleSize == 1 && samplesPerPixel == 1) {
imageType=TYPE_BILEVEL;
}
break;
case 5:
if (sampleSize == 8 && samplesPerPixel == 4) {
imageType=TYPE_CMYK;
}
case 6:
if (compression == COMP_JPEG_TTN2 && sampleSize == 8 && samplesPerPixel == 3) {
colorConvertJPEG=param.getJPEGDecompressYCbCrToRGB();
imageType=colorConvertJPEG ? TYPE_RGB : TYPE_GENERIC;
}
 else {
TIFFField chromaField=dir.getField(TIFF_YCBCR_SUBSAMPLING);
if (chromaField != null) {
chromaSubH=chromaField.getAsInt(0);
chromaSubV=chromaField.getAsInt(1);
}
 else {
chromaSubH=chromaSubV=2;
}
if (chromaSubH * chromaSubV == 1) {
imageType=TYPE_GENERIC;
}
 else if (sampleSize == 8 && samplesPerPixel == 3) {
imageType=TYPE_YCBCR_SUB;
}
}
break;
default :
if (sampleSize % 8 == 0) {
imageType=TYPE_GENERIC;
}
}
if (imageType == TYPE_UNSUPPORTED) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
minX=minY=0;
width=(int)(getField(dir,TIFFImageDecoder.TIFF_IMAGE_WIDTH,""String_Node_Str"").getAsLong(0));
height=(int)(getField(dir,TIFFImageDecoder.TIFF_IMAGE_LENGTH,""String_Node_Str"").getAsLong(0));
numBands=samplesPerPixel;
TIFFField efield=dir.getField(TIFFImageDecoder.TIFF_EXTRA_SAMPLES);
int extraSamples=efield == null ? 0 : (int)efield.getAsLong(0);
if (dir.getField(TIFFImageDecoder.TIFF_TILE_OFFSETS) != null) {
isTiled=true;
tileWidth=(int)(getField(dir,TIFFImageDecoder.TIFF_TILE_WIDTH,""String_Node_Str"").getAsLong(0));
tileHeight=(int)(getField(dir,TIFFImageDecoder.TIFF_TILE_LENGTH,""String_Node_Str"").getAsLong(0));
tileOffsets=(getField(dir,TIFFImageDecoder.TIFF_TILE_OFFSETS,""String_Node_Str"")).getAsLongs();
tileByteCounts=getFieldAsLongs(getField(dir,TIFFImageDecoder.TIFF_TILE_BYTE_COUNTS,""String_Node_Str""));
}
 else {
isTiled=false;
tileWidth=dir.getField(TIFFImageDecoder.TIFF_TILE_WIDTH) != null ? (int)dir.getFieldAsLong(TIFFImageDecoder.TIFF_TILE_WIDTH) : width;
TIFFField field=dir.getField(TIFFImageDecoder.TIFF_ROWS_PER_STRIP);
if (field == null) {
tileHeight=dir.getField(TIFFImageDecoder.TIFF_TILE_LENGTH) != null ? (int)dir.getFieldAsLong(TIFFImageDecoder.TIFF_TILE_LENGTH) : height;
}
 else {
long l=field.getAsLong(0);
long infinity=1;
infinity=(infinity << 32) - 1;
if (l == infinity || l > height) {
tileHeight=height;
}
 else {
tileHeight=(int)l;
}
}
TIFFField tileOffsetsField=getField(dir,TIFFImageDecoder.TIFF_STRIP_OFFSETS,""String_Node_Str"");
tileOffsets=getFieldAsLongs(tileOffsetsField);
TIFFField tileByteCountsField=dir.getField(TIFFImageDecoder.TIFF_STRIP_BYTE_COUNTS);
if (tileByteCountsField == null) {
int totalBytes=((sampleSize + 7) / 8) * numBands * width* height;
int bytesPerStrip=((sampleSize + 7) / 8) * numBands * width* tileHeight;
int cumulativeBytes=0;
tileByteCounts=new long[tileOffsets.length];
for (int i=0; i < tileOffsets.length; i++) {
tileByteCounts[i]=Math.min(totalBytes - cumulativeBytes,bytesPerStrip);
cumulativeBytes+=bytesPerStrip;
}
if (compression != COMP_NONE) {
this.stream=new NoEOFStream(stream);
}
}
 else {
tileByteCounts=getFieldAsLongs(tileByteCountsField);
}
int maxBytes=width * height * numBands* ((sampleSize + 7) / 8);
if (tileByteCounts.length == 1 && compression == COMP_NONE && tileByteCounts[0] > maxBytes) {
tileByteCounts[0]=maxBytes;
}
}
tilesX=(width + tileWidth - 1) / tileWidth;
tilesY=(height + tileHeight - 1) / tileHeight;
tileSize=tileWidth * tileHeight * numBands;
isBigEndian=dir.isBigEndian();
TIFFField fillOrderField=dir.getField(TIFFImageDecoder.TIFF_FILL_ORDER);
if (fillOrderField != null) {
fillOrder=fillOrderField.getAsInt(0);
}
 else {
fillOrder=1;
}
switch (compression) {
case COMP_NONE:
case COMP_PACKBITS:
break;
case COMP_DEFLATE:
inflater=new Inflater();
break;
case COMP_FAX_G3_1D:
case COMP_FAX_G3_2D:
case COMP_FAX_G4_2D:
if (sampleSize != 1) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (compression == 3) {
TIFFField t4OptionsField=dir.getField(TIFFImageDecoder.TIFF_T4_OPTIONS);
if (t4OptionsField != null) {
tiffT4Options=t4OptionsField.getAsLong(0);
}
 else {
tiffT4Options=0;
}
}
if (compression == 4) {
TIFFField t6OptionsField=dir.getField(TIFFImageDecoder.TIFF_T6_OPTIONS);
if (t6OptionsField != null) {
tiffT6Options=t6OptionsField.getAsLong(0);
}
 else {
tiffT6Options=0;
}
}
decoder=new TIFFFaxDecoder(fillOrder,tileWidth,tileHeight);
break;
case COMP_LZW:
TIFFField predictorField=dir.getField(TIFFImageDecoder.TIFF_PREDICTOR);
if (predictorField == null) {
predictor=1;
}
 else {
predictor=predictorField.getAsInt(0);
if (predictor != 1 && predictor != 2) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (predictor == 2 && sampleSize != 8) {
throw new RuntimeException(sampleSize + JaiI18N.getString(""String_Node_Str""));
}
}
lzwDecoder=new TIFFLZWDecoder(tileWidth,predictor,samplesPerPixel);
break;
case COMP_JPEG_OLD:
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
case COMP_JPEG_TTN2:
if (!(sampleSize == 8 && ((imageType == TYPE_GRAY && samplesPerPixel == 1) || (imageType == TYPE_PALETTE && samplesPerPixel == 1) || (imageType == TYPE_RGB && samplesPerPixel == 3)))) {
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dir.isTagPresent(TIFF_JPEG_TABLES)) {
TIFFField jpegTableField=dir.getField(TIFF_JPEG_TABLES);
byte[] jpegTable=jpegTableField.getAsBytes();
ByteArrayInputStream tableStream=new ByteArrayInputStream(jpegTable);
JPEGImageDecoder decoder=JPEGCodec.createJPEGDecoder(tableStream);
decoder.decodeAsRaster();
decodeParam=decoder.getJPEGDecodeParam();
}
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
switch (imageType) {
case TYPE_BILEVEL:
case TYPE_GRAY_4BIT:
sampleModel=new MultiPixelPackedSampleModel(dataType,tileWidth,tileHeight,sampleSize);
if (imageType == TYPE_BILEVEL) {
byte[] map=new byte[]{(byte)(isWhiteZero ? 255 : 0),(byte)(isWhiteZero ? 0 : 255)};
colorModel=new IndexColorModel(1,2,map,map,map);
}
 else {
colorModel=ImageCodec.createGrayIndexColorModel(sampleModel,!isWhiteZero);
}
break;
case TYPE_GRAY:
case TYPE_GRAY_ALPHA:
case TYPE_RGB:
case TYPE_RGB_ALPHA:
case TYPE_CMYK:
int[] RGBOffsets=new int[numBands];
if (compression == COMP_JPEG_TTN2) {
for (int i=0; i < numBands; i++) {
RGBOffsets[i]=numBands - 1 - i;
}
}
 else {
for (int i=0; i < numBands; i++) {
RGBOffsets[i]=i;
}
}
sampleModel=createPixelInterleavedSampleModel(dataType,tileWidth,tileHeight,numBands,numBands * tileWidth,RGBOffsets);
if (imageType == TYPE_GRAY || imageType == TYPE_RGB) {
colorModel=ImageCodec.createComponentColorModel(sampleModel);
}
 else if (imageType == TYPE_CMYK) {
colorModel=ImageCodec.createComponentColorModel(sampleModel,new SimpleCMYKColorSpace());
}
 else {
int transparency=Transparency.OPAQUE;
if (extraSamples == 1 || extraSamples == 2) {
transparency=Transparency.TRANSLUCENT;
}
colorModel=createAlphaComponentColorModel(dataType,numBands,extraSamples == 1,transparency);
}
break;
case TYPE_GENERIC:
case TYPE_YCBCR_SUB:
int[] bandOffsets=new int[numBands];
for (int i=0; i < numBands; i++) {
bandOffsets[i]=i;
}
sampleModel=createPixelInterleavedSampleModel(dataType,tileWidth,tileHeight,numBands,numBands * tileWidth,bandOffsets);
colorModel=null;
break;
case TYPE_PALETTE:
TIFFField cfield=getField(dir,TIFFImageDecoder.TIFF_COLORMAP,""String_Node_Str"");
colormap=cfield.getAsChars();
if (decodePaletteAsShorts) {
numBands=3;
if (dataType == DataBuffer.TYPE_BYTE) {
dataType=DataBuffer.TYPE_USHORT;
}
sampleModel=RasterFactory.createPixelInterleavedSampleModel(dataType,tileWidth,tileHeight,numBands);
colorModel=ImageCodec.createComponentColorModel(sampleModel);
}
 else {
numBands=1;
if (sampleSize == 4) {
sampleModel=new MultiPixelPackedSampleModel(DataBuffer.TYPE_BYTE,tileWidth,tileHeight,sampleSize);
}
 else if (sampleSize == 8) {
sampleModel=RasterFactory.createPixelInterleavedSampleModel(DataBuffer.TYPE_BYTE,tileWidth,tileHeight,numBands);
}
 else if (sampleSize == 16) {
dataType=DataBuffer.TYPE_USHORT;
sampleModel=RasterFactory.createPixelInterleavedSampleModel(DataBuffer.TYPE_USHORT,tileWidth,tileHeight,numBands);
}
int bandLength=colormap.length / 3;
byte r[]=new byte[bandLength];
byte g[]=new byte[bandLength];
byte b[]=new byte[bandLength];
int gIndex=bandLength;
int bIndex=bandLength * 2;
if (dataType == DataBuffer.TYPE_SHORT) {
for (int i=0; i < bandLength; i++) {
r[i]=param.decodeSigned16BitsTo8Bits((short)colormap[i]);
g[i]=param.decodeSigned16BitsTo8Bits((short)colormap[gIndex + i]);
b[i]=param.decodeSigned16BitsTo8Bits((short)colormap[bIndex + i]);
}
}
 else {
for (int i=0; i < bandLength; i++) {
r[i]=param.decode16BitsTo8Bits(colormap[i] & 0xffff);
g[i]=param.decode16BitsTo8Bits(colormap[gIndex + i] & 0xffff);
b[i]=param.decode16BitsTo8Bits(colormap[bIndex + i] & 0xffff);
}
}
colorModel=new IndexColorModel(sampleSize,bandLength,r,g,b);
}
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}",0.9914370955868108
154064,"/** 
 * Returns the alpha component for the specified pixel, scaled from 0 to 255.  The pixel value is specified by an array of data elements of type <code>transferType</code> passed in as an object reference.  If the <code>ColorModel</code> does not have alpha, 255 is returned.
 * @param inData The pixel from which to get the alphacomponent, specified by an array of data elements of type <code>transferType</code>.
 * @return The alpha component for the specified pixel, as an int.
 * @throws IllegalArgumentException if <code>inData</code> is<code>null</code> and the <code>colorModel</code> has alpha.
 * @throws ClassCastException If <code>inData</code> is not aprimitive array of type <code>transferType</code> and the <code>ColorModel</code> has alpha.
 * @throws ArrayIndexOutOfBoundsException if <code>inData</code>is not large enough to hold a pixel value for this <code>ColorModel</code> and the <code>ColorModel</code> has alpha.
 */
public int getAlpha(Object inData){
  if (inData == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (hasAlpha == false) {
    return 255;
  }
  if (transferType == DataBuffer.TYPE_FLOAT) {
    float[] fdata=(float[])inData;
    return (int)(fdata[numColorComponents] * 255.0F);
  }
 else {
    double[] ddata=(double[])inData;
    return (int)(ddata[numColorComponents] * 255.0);
  }
}","/** 
 * Returns the alpha component for the specified pixel, scaled from 0 to 255.  The pixel value is specified by an array of data elements of type <code>transferType</code> passed in as an object reference.  If the <code>ColorModel</code> does not have alpha, 255 is returned.
 * @param inData The pixel from which to get the alphacomponent, specified by an array of data elements of type <code>transferType</code>.
 * @return The alpha component for the specified pixel, as an int.
 * @throws IllegalArgumentException if <code>inData</code> is<code>null</code> and the <code>colorModel</code> has alpha.
 * @throws ClassCastException If <code>inData</code> is not aprimitive array of type <code>transferType</code> and the <code>ColorModel</code> has alpha.
 * @throws ArrayIndexOutOfBoundsException if <code>inData</code>is not large enough to hold a pixel value for this <code>ColorModel</code> and the <code>ColorModel</code> has alpha.
 */
public int getAlpha(Object inData){
  if (inData == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (hasAlpha == false) {
    return 255;
  }
  if (transferType == DataBuffer.TYPE_FLOAT) {
    float[] fdata=(float[])inData;
    return (int)(fdata[numColorComponents] * 255.0F + 0.5F);
  }
 else {
    double[] ddata=(double[])inData;
    return (int)(ddata[numColorComponents] * 255.0 + 0.5);
  }
}",0.995311936530833
154065,"private int getSample(Object inData,int sample){
  boolean needAlpha=(hasAlpha && isAlphaPremultiplied);
  int type=colorSpaceType;
  boolean is_sRGB=colorSpace.isCS_sRGB();
  if (type == ColorSpace.TYPE_GRAY) {
    sample=0;
    is_sRGB=true;
  }
  if (is_sRGB) {
    if (transferType == DataBuffer.TYPE_FLOAT) {
      float[] fdata=(float[])inData;
      float fsample=fdata[sample] * 255;
      if (needAlpha) {
        float falp=fdata[numColorComponents];
        if (falp == 0.0)         return 0;
 else         return clamp(fsample / falp);
      }
 else {
        return clamp(fsample);
      }
    }
 else {
      double[] ddata=(double[])inData;
      double dsample=ddata[sample] * 255.0;
      if (needAlpha) {
        double dalp=ddata[numColorComponents];
        if (dalp == 0.0)         return 0;
 else         return clamp(dsample / dalp);
      }
 else {
        return clamp(dsample);
      }
    }
  }
  float[] norm;
  float[] rgb;
  if (transferType == DataBuffer.TYPE_FLOAT) {
    float[] fdata=(float[])inData;
    if (needAlpha) {
      float falp=fdata[numColorComponents];
      if (falp == 0.0)       return 0;
      norm=new float[numColorComponents];
      for (int i=0; i < numColorComponents; i++) {
        norm[i]=fdata[i] / falp;
      }
      rgb=colorSpace.toRGB(norm);
    }
 else {
      rgb=colorSpace.toRGB(fdata);
    }
    return (int)(rgb[sample] * 255);
  }
 else {
    double[] ddata=(double[])inData;
    norm=new float[numColorComponents];
    if (needAlpha) {
      double dalp=ddata[numColorComponents];
      if (dalp == 0.0)       return 0;
      for (int i=0; i < numColorComponents; i++) {
        norm[i]=(float)(ddata[i] / dalp);
      }
      rgb=colorSpace.toRGB(norm);
    }
 else {
      for (int i=0; i < numColorComponents; i++) {
        norm[i]=(float)ddata[i];
      }
      rgb=colorSpace.toRGB(norm);
    }
    return (int)(rgb[sample] * 255);
  }
}","private int getSample(Object inData,int sample){
  boolean needAlpha=(hasAlpha && isAlphaPremultiplied);
  int type=colorSpaceType;
  boolean is_sRGB=colorSpace.isCS_sRGB();
  if (type == ColorSpace.TYPE_GRAY) {
    sample=0;
    is_sRGB=true;
  }
  if (is_sRGB) {
    if (transferType == DataBuffer.TYPE_FLOAT) {
      float[] fdata=(float[])inData;
      float fsample=fdata[sample] * 255;
      if (needAlpha) {
        float falp=fdata[numColorComponents];
        if (falp == 0.0)         return 0;
 else         return clamp(fsample / falp);
      }
 else {
        return clamp(fsample);
      }
    }
 else {
      double[] ddata=(double[])inData;
      double dsample=ddata[sample] * 255.0;
      if (needAlpha) {
        double dalp=ddata[numColorComponents];
        if (dalp == 0.0)         return 0;
 else         return clamp(dsample / dalp);
      }
 else {
        return clamp(dsample);
      }
    }
  }
  float[] norm;
  float[] rgb;
  if (transferType == DataBuffer.TYPE_FLOAT) {
    float[] fdata=(float[])inData;
    if (needAlpha) {
      float falp=fdata[numColorComponents];
      if (falp == 0.0)       return 0;
      norm=new float[numColorComponents];
      for (int i=0; i < numColorComponents; i++) {
        norm[i]=fdata[i] / falp;
      }
      rgb=colorSpace.toRGB(norm);
    }
 else {
      rgb=colorSpace.toRGB(fdata);
    }
    return (int)(rgb[sample] * 255 + 0.5F);
  }
 else {
    double[] ddata=(double[])inData;
    norm=new float[numColorComponents];
    if (needAlpha) {
      double dalp=ddata[numColorComponents];
      if (dalp == 0.0)       return 0;
      for (int i=0; i < numColorComponents; i++) {
        norm[i]=(float)(ddata[i] / dalp);
      }
      rgb=colorSpace.toRGB(norm);
    }
 else {
      for (int i=0; i < numColorComponents; i++) {
        norm[i]=(float)ddata[i];
      }
      rgb=colorSpace.toRGB(norm);
    }
    return (int)(rgb[sample] * 255 + 0.5);
  }
}",0.9966189856957088
154066,"/** 
 * Adds an array of tiles to the tile cache.
 * @param owner The <code>RenderedImage</code> that the tile belongs to.
 * @param tileIndices An array of <code>Point</code>s containing the<code>tileX</code> and <code>tileY</code> indices for each tile.
 * @param tiles The array of tile <code>Raster</code>s containing tile data.
 * @param tileCacheMetric Object which provides an ordering metricassociated with the <code>RenderedImage</code> owner.
 * @since 1.1
 */
public synchronized void addTiles(RenderedImage owner,Point[] tileIndices,Raster[] tiles,Object tileCacheMetric){
  if (memoryCapacity == 0) {
    return;
  }
  for (int i=0; i < tileIndices.length; i++) {
    int tileX=tileIndices[i].x;
    int tileY=tileIndices[i].y;
    Raster tile=tiles[i];
    Object key=SunCachedTile.hashKey(owner,tileX,tileY);
    SunCachedTile ct=(SunCachedTile)cache.get(key);
    if (ct != null) {
      ct.timeStamp=timeStamp++;
      if (ct != first) {
        if (ct == last) {
          last=ct.previous;
          last.next=null;
        }
 else {
          ct.previous.next=ct.next;
          ct.next.previous=ct.previous;
        }
        ct.previous=null;
        ct.next=first;
        first.previous=ct;
        first=ct;
      }
      hitCount++;
      if (diagnostics) {
        ct.action=UPDATE_FROM_ADD;
        setChanged();
        notifyObservers(ct);
      }
    }
 else {
      ct=new SunCachedTile(owner,tileX,tileY,tile,tileCacheMetric);
      ct.timeStamp=timeStamp++;
      ct.previous=null;
      ct.next=first;
      if (first == null && last == null) {
        first=ct;
        last=ct;
      }
 else {
        first.previous=ct;
        first=ct;
      }
      if (cache.put(ct.key,ct) == null) {
        memoryUsage+=ct.memorySize;
        tileCount++;
        if (cacheSortedSet != null) {
          cacheSortedSet.add(ct);
        }
        if (diagnostics) {
          ct.action=ADD;
          setChanged();
          notifyObservers(ct);
        }
      }
      if (memoryUsage > memoryCapacity) {
        memoryControl();
      }
    }
  }
}","/** 
 * Adds an array of tiles to the tile cache.
 * @param owner The <code>RenderedImage</code> that the tile belongs to.
 * @param tileIndices An array of <code>Point</code>s containing the<code>tileX</code> and <code>tileY</code> indices for each tile.
 * @param tiles The array of tile <code>Raster</code>s containing tile data.
 * @param tileCacheMetric Object which provides an ordering metricassociated with the <code>RenderedImage</code> owner.
 * @since 1.1
 */
public synchronized void addTiles(RenderedImage owner,Point[] tileIndices,Raster[] tiles,Object tileCacheMetric){
  if (memoryCapacity == 0) {
    return;
  }
  for (int i=0; i < tileIndices.length; i++) {
    int tileX=tileIndices[i].x;
    int tileY=tileIndices[i].y;
    Raster tile=tiles[i];
    Object key=SunCachedTile.hashKey(owner,tileX,tileY);
    SunCachedTile ct=(SunCachedTile)cache.get(key);
    if (ct != null) {
      ct.timeStamp=timeStamp++;
      if (ct != first) {
        if (ct == last) {
          last=ct.previous;
          last.next=null;
        }
 else {
          ct.previous.next=ct.next;
          ct.next.previous=ct.previous;
        }
        ct.previous=null;
        ct.next=first;
        first.previous=ct;
        first=ct;
      }
      hitCount++;
      if (diagnostics) {
        ct.action=UPDATE_FROM_ADD;
        setChanged();
        notifyObservers(ct);
      }
    }
 else {
      ct=new SunCachedTile(owner,tileX,tileY,tile,tileCacheMetric);
      if (memoryUsage + ct.memorySize > memoryCapacity && ct.memorySize > (long)(memoryCapacity * memoryThreshold)) {
        return;
      }
      ct.timeStamp=timeStamp++;
      ct.previous=null;
      ct.next=first;
      if (first == null && last == null) {
        first=ct;
        last=ct;
      }
 else {
        first.previous=ct;
        first=ct;
      }
      if (cache.put(ct.key,ct) == null) {
        memoryUsage+=ct.memorySize;
        tileCount++;
        if (cacheSortedSet != null) {
          cacheSortedSet.add(ct);
        }
        if (diagnostics) {
          ct.action=ADD;
          setChanged();
          notifyObservers(ct);
        }
      }
      if (memoryUsage > memoryCapacity) {
        memoryControl();
      }
    }
  }
}",0.9669306008383792
154067,"/** 
 * Adds a tile to the cache with an associated tile compute cost. <p> If the specified tile is already in the cache, it will not be cached again.  If by adding this tile, the cache exceeds the memory capacity, older tiles in the cache are removed to keep the cache memory usage under the specified limit.
 * @param owner            The image the tile blongs to.
 * @param tileX            The tile's X index within the image.
 * @param tileY            The tile's Y index within the image.
 * @param tile             The tile to be cached.
 * @param tileCacheMetric  Metric for prioritizing tiles
 */
public synchronized void add(RenderedImage owner,int tileX,int tileY,Raster tile,Object tileCacheMetric){
  if (memoryCapacity == 0) {
    return;
  }
  Object key=SunCachedTile.hashKey(owner,tileX,tileY);
  SunCachedTile ct=(SunCachedTile)cache.get(key);
  if (ct != null) {
    ct.timeStamp=timeStamp++;
    if (ct != first) {
      if (ct == last) {
        last=ct.previous;
        last.next=null;
      }
 else {
        ct.previous.next=ct.next;
        ct.next.previous=ct.previous;
      }
      ct.previous=null;
      ct.next=first;
      first.previous=ct;
      first=ct;
    }
    hitCount++;
    if (diagnostics) {
      ct.action=UPDATE_FROM_ADD;
      setChanged();
      notifyObservers(ct);
    }
  }
 else {
    ct=new SunCachedTile(owner,tileX,tileY,tile,tileCacheMetric);
    ct.timeStamp=timeStamp++;
    ct.previous=null;
    ct.next=first;
    if (first == null && last == null) {
      first=ct;
      last=ct;
    }
 else {
      first.previous=ct;
      first=ct;
    }
    if (cache.put(ct.key,ct) == null) {
      memoryUsage+=ct.memorySize;
      tileCount++;
      if (cacheSortedSet != null) {
        cacheSortedSet.add(ct);
      }
      if (diagnostics) {
        ct.action=ADD;
        setChanged();
        notifyObservers(ct);
      }
    }
    if (memoryUsage > memoryCapacity) {
      memoryControl();
    }
  }
}","/** 
 * Adds a tile to the cache with an associated tile compute cost. <p> If the specified tile is already in the cache, it will not be cached again.  If by adding this tile, the cache exceeds the memory capacity, older tiles in the cache are removed to keep the cache memory usage under the specified limit.
 * @param owner            The image the tile blongs to.
 * @param tileX            The tile's X index within the image.
 * @param tileY            The tile's Y index within the image.
 * @param tile             The tile to be cached.
 * @param tileCacheMetric  Metric for prioritizing tiles
 */
public synchronized void add(RenderedImage owner,int tileX,int tileY,Raster tile,Object tileCacheMetric){
  if (memoryCapacity == 0) {
    return;
  }
  Object key=SunCachedTile.hashKey(owner,tileX,tileY);
  SunCachedTile ct=(SunCachedTile)cache.get(key);
  if (ct != null) {
    ct.timeStamp=timeStamp++;
    if (ct != first) {
      if (ct == last) {
        last=ct.previous;
        last.next=null;
      }
 else {
        ct.previous.next=ct.next;
        ct.next.previous=ct.previous;
      }
      ct.previous=null;
      ct.next=first;
      first.previous=ct;
      first=ct;
    }
    hitCount++;
    if (diagnostics) {
      ct.action=UPDATE_FROM_ADD;
      setChanged();
      notifyObservers(ct);
    }
  }
 else {
    ct=new SunCachedTile(owner,tileX,tileY,tile,tileCacheMetric);
    if (memoryUsage + ct.memorySize > memoryCapacity && ct.memorySize > (long)(memoryCapacity * memoryThreshold)) {
      return;
    }
    ct.timeStamp=timeStamp++;
    ct.previous=null;
    ct.next=first;
    if (first == null && last == null) {
      first=ct;
      last=ct;
    }
 else {
      first.previous=ct;
      first=ct;
    }
    if (cache.put(ct.key,ct) == null) {
      memoryUsage+=ct.memorySize;
      tileCount++;
      if (cacheSortedSet != null) {
        cacheSortedSet.add(ct);
      }
      if (diagnostics) {
        ct.action=ADD;
        setChanged();
        notifyObservers(ct);
      }
    }
    if (memoryUsage > memoryCapacity) {
      memoryControl();
    }
  }
}",0.9664694280078896
154068,"/** 
 * A convenience method to create an instance of <code>ComponentColorModel</code> suitable for use with the given <code>SampleModel</code> and <ColorSpace</code>.  The  <code>SampleModel</code> should have a data type of <code>DataBuffer.TYPE_BYTE</code>, <code>TYPE_USHORT</code>, or <code>TYPE_INT</code> and between 1 and 4 bands.  Depending on the number of bands of the <code>SampleModel</code>, either a gray, gray+alpha, rgb, or rgb+alpha <code>ColorModel</code> is returned.
 */
public static ColorModel createComponentColorModel(SampleModel sm,ColorSpace cp){
  if (cp == null)   return createComponentColorModel(sm);
  int type=sm.getDataType();
  int bands=sm.getNumBands();
  ComponentColorModel cm=null;
  int[] bits=null;
  int transferType=-1;
  boolean hasAlpha=(bands % 2 == 0);
  int transparency=hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;
  if (type == DataBuffer.TYPE_BYTE) {
    transferType=DataBuffer.TYPE_BYTE;
switch (bands) {
case 1:
      bits=GrayBits8;
    break;
case 2:
  bits=GrayAlphaBits8;
break;
case 3:
bits=RGBBits8;
break;
case 4:
bits=RGBABits8;
break;
}
}
 else if (type == DataBuffer.TYPE_USHORT) {
transferType=DataBuffer.TYPE_USHORT;
switch (bands) {
case 1:
bits=GrayBits16;
break;
case 2:
bits=GrayAlphaBits16;
break;
case 3:
bits=RGBBits16;
break;
case 4:
bits=RGBABits16;
break;
}
}
 else if (type == DataBuffer.TYPE_INT) {
transferType=DataBuffer.TYPE_INT;
switch (bands) {
case 1:
bits=GrayBits32;
break;
case 2:
bits=GrayAlphaBits32;
break;
case 3:
bits=RGBBits32;
break;
case 4:
bits=RGBABits32;
break;
}
}
if (type == DataBuffer.TYPE_FLOAT && bands >= 1 && bands <= 4) {
cm=new FloatDoubleColorModel(cp,hasAlpha,false,transparency,DataBuffer.TYPE_FLOAT);
}
 else {
cm=new ComponentColorModel(cp,bits,hasAlpha,false,transparency,transferType);
}
return cm;
}","/** 
 * A convenience method to create an instance of <code>ComponentColorModel</code> suitable for use with the given <code>SampleModel</code> and <ColorSpace</code>.  The  <code>SampleModel</code> should have a data type of <code>DataBuffer.TYPE_BYTE</code>, <code>TYPE_USHORT</code>, or <code>TYPE_INT</code> and between 1 and 4 bands.  Depending on the number of bands of the <code>SampleModel</code>, either a gray, gray+alpha, rgb, or rgb+alpha <code>ColorModel</code> is returned.
 */
public static ColorModel createComponentColorModel(SampleModel sm,ColorSpace cp){
  if (cp == null)   return createComponentColorModel(sm);
  int type=sm.getDataType();
  int bands=sm.getNumBands();
  ComponentColorModel cm=null;
  int[] bits=null;
  int transferType=-1;
  boolean hasAlpha=(bands % 2 == 0);
  if (cp instanceof SimpleCMYKColorSpace)   hasAlpha=false;
  int transparency=hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;
  if (type == DataBuffer.TYPE_BYTE) {
    transferType=DataBuffer.TYPE_BYTE;
switch (bands) {
case 1:
      bits=GrayBits8;
    break;
case 2:
  bits=GrayAlphaBits8;
break;
case 3:
bits=RGBBits8;
break;
case 4:
bits=RGBABits8;
break;
}
}
 else if (type == DataBuffer.TYPE_USHORT) {
transferType=DataBuffer.TYPE_USHORT;
switch (bands) {
case 1:
bits=GrayBits16;
break;
case 2:
bits=GrayAlphaBits16;
break;
case 3:
bits=RGBBits16;
break;
case 4:
bits=RGBABits16;
break;
}
}
 else if (type == DataBuffer.TYPE_INT) {
transferType=DataBuffer.TYPE_INT;
switch (bands) {
case 1:
bits=GrayBits32;
break;
case 2:
bits=GrayAlphaBits32;
break;
case 3:
bits=RGBBits32;
break;
case 4:
bits=RGBABits32;
break;
}
}
if (type == DataBuffer.TYPE_FLOAT && bands >= 1 && bands <= 4) {
cm=new FloatDoubleColorModel(cp,hasAlpha,false,transparency,DataBuffer.TYPE_FLOAT);
}
 else {
cm=new ComponentColorModel(cp,bits,hasAlpha,false,transparency,transferType);
}
return cm;
}",0.9838709677419356
154069,"/** 
 * Perform scan conversion of a convex polygon.
 * @param rectList A <code>LinkedList</code>; may be null.
 * @return A <code>LinkedList</code> of <code>Rectangle</code>srepresenting the scan conversion of the convex polygon.
 */
private LinkedList scanConvex(LinkedList rectList){
  if (rectList == null) {
    rectList=new LinkedList();
  }
  int yMin=poly.ypoints[0];
  int topVertex=0;
  int n=poly.npoints;
  for (int i=1; i < n; i++) {
    if (poly.ypoints[i] < yMin) {
      yMin=poly.ypoints[i];
      topVertex=i;
    }
  }
  int leftIndex=topVertex;
  int rightIndex=topVertex;
  int numRemaining=n;
  int y=yMin;
  int intYLeft=y - 1;
  int intYRight=intYLeft;
  double[] px=intArrayToDoubleArray(poly.xpoints);
  int[] py=poly.ypoints;
  double[] leftX=new double[1];
  double[] leftDX=new double[1];
  double[] rightX=new double[1];
  double[] rightDX=new double[1];
  while (numRemaining > 0) {
    int i;
    while (intYLeft <= y && numRemaining > 0) {
      numRemaining--;
      i=leftIndex - 1;
      if (i < 0)       i=n - 1;
      intersectX(px[leftIndex],py[leftIndex],px[i],py[i],y,leftX,leftDX);
      intYLeft=py[i];
      leftIndex=i;
    }
    while (intYRight <= y && numRemaining > 0) {
      numRemaining--;
      i=rightIndex + 1;
      if (i >= n)       i=0;
      intersectX(px[rightIndex],py[rightIndex],px[i],py[i],y,rightX,rightDX);
      intYRight=py[i];
      rightIndex=i;
    }
    while (y < intYLeft && y < intYRight) {
      if (y >= clip.y && y <= clip.getMaxY()) {
        Rectangle rect;
        if (leftX[0] <= rightX[0]) {
          rect=scanSegment(y,leftX[0],rightX[0]);
        }
 else {
          rect=scanSegment(y,rightX[0],leftX[0]);
        }
        if (rect != null) {
          rectList.addLast((Object)rect);
        }
      }
      y++;
      leftX[0]+=leftDX[0];
      rightX[0]+=rightDX[0];
    }
  }
  return rectList;
}","/** 
 * Perform scan conversion of a convex polygon.
 * @param rectList A <code>LinkedList</code>; may be null.
 * @return A <code>LinkedList</code> of <code>Rectangle</code>srepresenting the scan conversion of the convex polygon.
 */
private LinkedList scanConvex(LinkedList rectList){
  if (rectList == null) {
    rectList=new LinkedList();
  }
  int yMin=poly.ypoints[0];
  int topVertex=0;
  int n=poly.npoints;
  for (int i=1; i < n; i++) {
    if (poly.ypoints[i] < yMin) {
      yMin=poly.ypoints[i];
      topVertex=i;
    }
  }
  int leftIndex=topVertex;
  int rightIndex=topVertex;
  int numRemaining=n;
  int y=yMin;
  int intYLeft=y - 1;
  int intYRight=intYLeft;
  double[] px=intArrayToDoubleArray(poly.xpoints);
  int[] py=poly.ypoints;
  double[] leftX=new double[1];
  double[] leftDX=new double[1];
  double[] rightX=new double[1];
  double[] rightDX=new double[1];
  while (numRemaining > 0) {
    int i;
    while (intYLeft <= y && numRemaining > 0) {
      numRemaining--;
      i=leftIndex - 1;
      if (i < 0)       i=n - 1;
      intersectX(px[leftIndex],py[leftIndex],px[i],py[i],y,leftX,leftDX);
      intYLeft=py[i];
      leftIndex=i;
    }
    while (intYRight <= y && numRemaining > 0) {
      numRemaining--;
      i=rightIndex + 1;
      if (i >= n)       i=0;
      intersectX(px[rightIndex],py[rightIndex],px[i],py[i],y,rightX,rightDX);
      intYRight=py[i];
      rightIndex=i;
    }
    while (y < intYLeft && y < intYRight) {
      if (y >= clip.y && y < clip.getMaxY()) {
        Rectangle rect;
        if (leftX[0] <= rightX[0]) {
          rect=scanSegment(y,leftX[0],rightX[0]);
        }
 else {
          rect=scanSegment(y,rightX[0],leftX[0]);
        }
        if (rect != null) {
          rectList.addLast((Object)rect);
        }
      }
      y++;
      leftX[0]+=leftDX[0];
      rightX[0]+=rightDX[0];
    }
  }
  return rectList;
}",0.9997350993377484
154070,"/** 
 * Reads up to <code>len</code> bytes of data from the input stream into an array of bytes.  An attempt is made to read as many as <code>len</code> bytes, but a smaller number may be read, possibly zero. The number of bytes actually read is returned as an integer. <p> This method blocks until input data is available, end of file is detected, or an exception is thrown. <p> If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown. <p> If <code>off</code> is negative, or <code>len</code> is negative, or <code>off+len</code> is greater than the length of the array <code>b</code>, then an <code>IndexOutOfBoundsException</code> is thrown. <p> If <code>len</code> is zero, then no bytes are read and <code>0</code> is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value <code>-1</code> is returned; otherwise, at least one byte is read and stored into <code>b</code>. <p> The first byte read is stored into element <code>b[off]</code>, the next one into <code>b[off+1]</code>, and so on. The number of bytes read is, at most, equal to <code>len</code>. Let <i>k</i> be the number of bytes actually read; these bytes will be stored in elements <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>, leaving elements <code>b[off+</code><i>k</i><code>]</code> through <code>b[off+len-1]</code> unaffected. <p> In every case, elements <code>b[0]</code> through <code>b[off]</code> and elements <code>b[off+len]</code> through <code>b[b.length-1]</code> are unaffected. <p> If the first byte cannot be read for any reason other than end of file, then an <code>IOException</code> is thrown. In particular, an <code>IOException</code> is thrown if the input stream has been closed.
 * @param b     the buffer into which the data is read.
 * @param off   the start offset in array <code>b</code>at which the data is written.
 * @param len   the maximum number of bytes to read.
 * @return     the total number of bytes read into the buffer, or<code>-1</code> if there is no more data because the end of the stream has been reached.
 */
public int read(byte[] b,int off,int len) throws IOException {
  if (b == null) {
    throw new NullPointerException();
  }
  if ((off < 0) || (len < 0) || (off + len > b.length)) {
    throw new IndexOutOfBoundsException();
  }
  if (len == 0) {
    return 0;
  }
  long pos=readUntil(pointer + len);
  if (pos <= pointer) {
    return -1;
  }
  byte[] buf=(byte[])data.elementAt((int)(pointer >> SECTOR_SHIFT));
  int nbytes=Math.min(len,SECTOR_SIZE - (int)(pointer & SECTOR_MASK));
  System.arraycopy(buf,(int)(pointer & SECTOR_MASK),b,off,nbytes);
  pointer+=nbytes;
  return nbytes;
}","/** 
 * Reads up to <code>len</code> bytes of data from the input stream into an array of bytes.  An attempt is made to read as many as <code>len</code> bytes, but a smaller number may be read, possibly zero. The number of bytes actually read is returned as an integer. <p> This method blocks until input data is available, end of file is detected, or an exception is thrown. <p> If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown. <p> If <code>off</code> is negative, or <code>len</code> is negative, or <code>off+len</code> is greater than the length of the array <code>b</code>, then an <code>IndexOutOfBoundsException</code> is thrown. <p> If <code>len</code> is zero, then no bytes are read and <code>0</code> is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value <code>-1</code> is returned; otherwise, at least one byte is read and stored into <code>b</code>. <p> The first byte read is stored into element <code>b[off]</code>, the next one into <code>b[off+1]</code>, and so on. The number of bytes read is, at most, equal to <code>len</code>. Let <i>k</i> be the number of bytes actually read; these bytes will be stored in elements <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>, leaving elements <code>b[off+</code><i>k</i><code>]</code> through <code>b[off+len-1]</code> unaffected. <p> In every case, elements <code>b[0]</code> through <code>b[off]</code> and elements <code>b[off+len]</code> through <code>b[b.length-1]</code> are unaffected. <p> If the first byte cannot be read for any reason other than end of file, then an <code>IOException</code> is thrown. In particular, an <code>IOException</code> is thrown if the input stream has been closed.
 * @param b     the buffer into which the data is read.
 * @param off   the start offset in array <code>b</code>at which the data is written.
 * @param len   the maximum number of bytes to read.
 * @return     the total number of bytes read into the buffer, or<code>-1</code> if there is no more data because the end of the stream has been reached.
 */
public int read(byte[] b,int off,int len) throws IOException {
  if (b == null) {
    throw new NullPointerException();
  }
  if ((off < 0) || (len < 0) || (off + len > b.length)) {
    throw new IndexOutOfBoundsException();
  }
  if (len == 0) {
    return 0;
  }
  long pos=readUntil(pointer + len);
  if (pos <= pointer) {
    return -1;
  }
  byte[] buf=(byte[])data.elementAt((int)(pointer >> SECTOR_SHIFT));
  int nbytes=Math.min((int)(pos < pointer + len ? pos - pointer : len),SECTOR_SIZE - (int)(pointer & SECTOR_MASK));
  System.arraycopy(buf,(int)(pointer & SECTOR_MASK),b,off,nbytes);
  pointer+=nbytes;
  return nbytes;
}",0.9908289875921596
154071,"/** 
 * Creates an <code>InterpAverage</code> instance having the supplied dimensions.  The <code>subsampleBitsH</code> and <code>subsampleBitsV</code> instance variables are set to 32.
 * @param blockX The width of the interpolation block.
 * @param blockY The height of the interpolation block.
 * @throws IllegalArgumentException if either parameter is non-positive.
 */
public InterpAverage(int blockX,int blockY){
  super(blockX,blockY,0,blockX - 1,0,blockY - 1,32,32);
  if (blockX <= 0 || blockY <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Creates an <code>InterpAverage</code> instance having the supplied dimensions.  The left and top padding are <code>(blockX&nbsp;-&nbsp;1)/2</code> and <code>(blockY&nbsp;-&nbsp;1)/2</code>, respectively. The <code>subsampleBitsH</code> and <code>subsampleBitsV</code> instance variables are set to 32.
 * @param blockX The width of the interpolation block.
 * @param blockY The height of the interpolation block.
 * @throws IllegalArgumentException if either parameter is non-positive.
 */
public InterpAverage(int blockX,int blockY){
  super(blockX,blockY,(blockX - 1) / 2,blockX - 1 - (blockX - 1) / 2,(blockY - 1) / 2,blockY - 1 - (blockY - 1) / 2,32,32);
  if (blockX <= 0 || blockY <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.849478390461997
154072,"private void toRGBInt(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  int[] iBuf=src.getIntData(0);
  int[] hBuf=src.getIntData(1);
  int[] sBuf=src.getIntData(2);
  double normi=1.0 / ((1l << srcComponentSize[0]) - 1);
  double normh=1.0 / ((1l << srcComponentSize[1]) - 1) * PI2;
  double norms=1.0 / ((1l << srcComponentSize[2]) - 1);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=(iBuf[iIndex] & 0xFFFFFFFFl) * normi;
      double H=(hBuf[hIndex] & 0xFFFFFFFFl) * normh;
      double S=(sBuf[sIndex] & 0xFFFFFFFFl) * norms;
      double R, G, B;
      R=G=B=I;
      if (S != 0) {
        if (H >= PI23 && H < PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}","private void toRGBInt(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  int[] iBuf=src.getIntData(0);
  int[] hBuf=src.getIntData(1);
  int[] sBuf=src.getIntData(2);
  double normi=1.0 / ((1l << srcComponentSize[0]) - 1);
  double normh=1.0 / ((1l << srcComponentSize[1]) - 1) * PI2;
  double norms=1.0 / ((1l << srcComponentSize[2]) - 1);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=(iBuf[iIndex] & 0xFFFFFFFFl) * normi;
      double H=(hBuf[hIndex] & 0xFFFFFFFFl) * normh;
      double S=(sBuf[sIndex] & 0xFFFFFFFFl) * norms;
      double R, G, B;
      R=G=B=I;
      if (S != 0) {
        if (H >= PI23 && H <= PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}",0.999791710060404
154073,"private void toRGBDouble(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  double[] iBuf=src.getDoubleData(0);
  double[] hBuf=src.getDoubleData(1);
  double[] sBuf=src.getDoubleData(2);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=iBuf[iIndex];
      double H=hBuf[hIndex];
      double S=sBuf[sIndex];
      double R, G, B;
      R=G=B=I;
      if (S != 0) {
        if (H >= PI23 && H < PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}","private void toRGBDouble(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  double[] iBuf=src.getDoubleData(0);
  double[] hBuf=src.getDoubleData(1);
  double[] sBuf=src.getDoubleData(2);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=iBuf[iIndex];
      double H=hBuf[hIndex];
      double S=sBuf[sIndex];
      double R, G, B;
      R=G=B=I;
      if (S != 0) {
        if (H >= PI23 && H <= PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}",0.9997701677775224
154074,"private void toRGBFloat(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  float[] iBuf=src.getFloatData(0);
  float[] hBuf=src.getFloatData(1);
  float[] sBuf=src.getFloatData(2);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=iBuf[iIndex];
      double H=hBuf[hIndex];
      double S=sBuf[sIndex];
      double R, G, B;
      R=G=B=I;
      if (S != 0) {
        if (H >= PI23 && H < PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}","private void toRGBFloat(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  float[] iBuf=src.getFloatData(0);
  float[] hBuf=src.getFloatData(1);
  float[] sBuf=src.getFloatData(2);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=iBuf[iIndex];
      double H=hBuf[hIndex];
      double S=sBuf[sIndex];
      double R, G, B;
      R=G=B=I;
      if (S != 0) {
        if (H >= PI23 && H <= PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}",0.9997694258704174
154075,"private void toRGBByte(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  byte[] iBuf=src.getByteData(0);
  byte[] hBuf=src.getByteData(1);
  byte[] sBuf=src.getByteData(2);
  double normi=1.0 / ((1 << srcComponentSize[0]) - 1);
  double normh=1.0 / ((1 << srcComponentSize[1]) - 1) * PI2;
  double norms=1.0 / ((1 << srcComponentSize[2]) - 1);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  boolean isByte=(dstType == DataBuffer.TYPE_BYTE);
  if (isByte) {
    generateTanTable();
  }
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=null;
  int[] dstIntPixels=null;
  if (isByte)   dstIntPixels=new int[3 * height * width];
 else   dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=(iBuf[iIndex] & 0xFF) * normi;
      int h=hBuf[hIndex] & 0xFF;
      double S=(sBuf[sIndex] & 0xFF) * norms;
      if (isByte) {
        float r, g, b;
        r=g=b=(float)I;
        if (S != 0.0) {
          if (h >= 85 && h < 170) {
            r=(float)((1 - S) * I);
            float c1=(float)(3 * I - r);
            float c2=(float)(SQRT3 * (r - I) * tanTable[h]);
            g=(float)((c1 + c2) / 2);
            b=(float)((c1 - c2) / 2);
          }
 else           if (h > 170) {
            g=(float)((1 - S) * I);
            float c1=(float)(3 * I - g);
            float c2=(float)(SQRT3 * (g - I) * tanTable[h - 85]);
            b=(c1 + c2) / 2;
            r=(c1 - c2) / 2;
          }
 else           if (h < 85) {
            b=(float)((1 - S) * I);
            float c1=(float)(3 * I - b);
            float c2=(float)(SQRT3 * (b - I) * tanTable[h + 85]);
            r=(c1 + c2) / 2;
            g=(c1 - c2) / 2;
          }
        }
        dstIntPixels[dIndex++]=(int)(((r < 0.0f) ? 0.0f : ((r > 1.0f) ? 1.0f : r)) * normr + 0.5);
        dstIntPixels[dIndex++]=(int)(((g < 0.0f) ? 0.0f : ((g > 1.0f) ? 1.0f : g)) * normg + 0.5);
        dstIntPixels[dIndex++]=(int)(((b < 0.0f) ? 0.0f : ((b > 1.0f) ? 1.0f : b)) * normb + 0.5);
      }
 else {
        double R, G, B;
        R=G=B=I;
        if (S != 0) {
          double H=h * normh;
          if (H >= PI23 && H < PI43) {
            R=(1 - S) * I;
            double c1=3 * I - R;
            double c2=SQRT3 * (R - I) * Math.tan(H);
            G=(c1 + c2) / 2;
            B=(c1 - c2) / 2;
          }
 else           if (H > PI43) {
            G=(1 - S) * I;
            double c1=3 * I - G;
            double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
            B=(c1 + c2) / 2;
            R=(c1 - c2) / 2;
          }
 else           if (H < PI23) {
            B=(1 - S) * I;
            double c1=3 * I - B;
            double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
            R=(c1 + c2) / 2;
            G=(c1 - c2) / 2;
          }
        }
        dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
        dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
        dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
      }
    }
  }
  if (isByte)   dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstIntPixels);
 else {
    convertToSigned(dstPixels,dstType);
    dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
  }
}","private void toRGBByte(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  byte[] iBuf=src.getByteData(0);
  byte[] hBuf=src.getByteData(1);
  byte[] sBuf=src.getByteData(2);
  double normi=1.0 / ((1 << srcComponentSize[0]) - 1);
  double normh=1.0 / ((1 << srcComponentSize[1]) - 1) * PI2;
  double norms=1.0 / ((1 << srcComponentSize[2]) - 1);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  boolean isByte=(dstType == DataBuffer.TYPE_BYTE);
  if (isByte) {
    generateTanTable();
  }
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=null;
  int[] dstIntPixels=null;
  if (isByte)   dstIntPixels=new int[3 * height * width];
 else   dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=(iBuf[iIndex] & 0xFF) * normi;
      int h=hBuf[hIndex] & 0xFF;
      double S=(sBuf[sIndex] & 0xFF) * norms;
      if (isByte) {
        float r, g, b;
        r=g=b=(float)I;
        if (S != 0.0) {
          if (h >= 85 && h <= 170) {
            r=(float)((1 - S) * I);
            float c1=(float)(3 * I - r);
            float c2=(float)(SQRT3 * (r - I) * tanTable[h]);
            g=(float)((c1 + c2) / 2);
            b=(float)((c1 - c2) / 2);
          }
 else           if (h > 170) {
            g=(float)((1 - S) * I);
            float c1=(float)(3 * I - g);
            float c2=(float)(SQRT3 * (g - I) * tanTable[h - 85]);
            b=(c1 + c2) / 2;
            r=(c1 - c2) / 2;
          }
 else           if (h < 85) {
            b=(float)((1 - S) * I);
            float c1=(float)(3 * I - b);
            float c2=(float)(SQRT3 * (b - I) * tanTable[h + 85]);
            r=(c1 + c2) / 2;
            g=(c1 - c2) / 2;
          }
        }
        dstIntPixels[dIndex++]=(int)(((r < 0.0f) ? 0.0f : ((r > 1.0f) ? 1.0f : r)) * normr + 0.5);
        dstIntPixels[dIndex++]=(int)(((g < 0.0f) ? 0.0f : ((g > 1.0f) ? 1.0f : g)) * normg + 0.5);
        dstIntPixels[dIndex++]=(int)(((b < 0.0f) ? 0.0f : ((b > 1.0f) ? 1.0f : b)) * normb + 0.5);
      }
 else {
        double R, G, B;
        R=G=B=I;
        if (S != 0) {
          double H=h * normh;
          if (H >= PI23 && H <= PI43) {
            R=(1 - S) * I;
            double c1=3 * I - R;
            double c2=SQRT3 * (R - I) * Math.tan(H);
            G=(c1 + c2) / 2;
            B=(c1 - c2) / 2;
          }
 else           if (H > PI43) {
            G=(1 - S) * I;
            double c1=3 * I - G;
            double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
            B=(c1 + c2) / 2;
            R=(c1 - c2) / 2;
          }
 else           if (H < PI23) {
            B=(1 - S) * I;
            double c1=3 * I - B;
            double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
            R=(c1 + c2) / 2;
            G=(c1 - c2) / 2;
          }
        }
        dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
        dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
        dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
      }
    }
  }
  if (isByte)   dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstIntPixels);
 else {
    convertToSigned(dstPixels,dstType);
    dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
  }
}",0.999746063991874
154076,"private void toRGBShort(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  short[] iBuf=src.getShortData(0);
  short[] hBuf=src.getShortData(1);
  short[] sBuf=src.getShortData(2);
  double normi=1.0 / ((1 << srcComponentSize[0]) - 1);
  double normh=1.0 / ((1 << srcComponentSize[1]) - 1) * PI2;
  double norms=1.0 / ((1 << srcComponentSize[2]) - 1);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=(iBuf[iIndex] & 0xFFFF) * normi;
      double H=(hBuf[hIndex] & 0xFFFF) * normh;
      double S=(sBuf[sIndex] & 0xFFFF) * norms;
      double R, G, B;
      R=G=B=I;
      if (S != 0.0) {
        if (H >= PI23 && H < PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}","private void toRGBShort(UnpackedImageData src,int[] srcComponentSize,WritableRaster dest,int[] destComponentSize){
  short[] iBuf=src.getShortData(0);
  short[] hBuf=src.getShortData(1);
  short[] sBuf=src.getShortData(2);
  double normi=1.0 / ((1 << srcComponentSize[0]) - 1);
  double normh=1.0 / ((1 << srcComponentSize[1]) - 1) * PI2;
  double norms=1.0 / ((1 << srcComponentSize[2]) - 1);
  double normr=1.0, normg=1.0, normb=1.0;
  int dstType=dest.getSampleModel().getDataType();
  if (dstType < DataBuffer.TYPE_FLOAT) {
    normr=(1l << destComponentSize[0]) - 1;
    normg=(1l << destComponentSize[1]) - 1;
    normb=(1l << destComponentSize[2]) - 1;
  }
  int height=dest.getHeight();
  int width=dest.getWidth();
  double[] dstPixels=new double[3 * height * width];
  int iStart=src.bandOffsets[0];
  int hStart=src.bandOffsets[1];
  int sStart=src.bandOffsets[2];
  int srcPixelStride=src.pixelStride;
  int srcLineStride=src.lineStride;
  int dIndex=0;
  for (int j=0; j < height; j++, iStart+=srcLineStride, hStart+=srcLineStride, sStart+=srcLineStride) {
    for (int i=0, iIndex=iStart, hIndex=hStart, sIndex=sStart; i < width; i++, iIndex+=srcPixelStride, hIndex+=srcPixelStride, sIndex+=srcPixelStride) {
      double I=(iBuf[iIndex] & 0xFFFF) * normi;
      double H=(hBuf[hIndex] & 0xFFFF) * normh;
      double S=(sBuf[sIndex] & 0xFFFF) * norms;
      double R, G, B;
      R=G=B=I;
      if (S != 0.0) {
        if (H >= PI23 && H <= PI43) {
          R=(1 - S) * I;
          double c1=3 * I - R;
          double c2=SQRT3 * (R - I) * Math.tan(H);
          G=(c1 + c2) / 2;
          B=(c1 - c2) / 2;
        }
 else         if (H > PI43) {
          G=(1 - S) * I;
          double c1=3 * I - G;
          double c2=SQRT3 * (G - I) * Math.tan(H - PI23);
          B=(c1 + c2) / 2;
          R=(c1 - c2) / 2;
        }
 else         if (H < PI23) {
          B=(1 - S) * I;
          double c1=3 * I - B;
          double c2=SQRT3 * (B - I) * Math.tan(H - PI43);
          R=(c1 + c2) / 2;
          G=(c1 - c2) / 2;
        }
      }
      dstPixels[dIndex++]=((R < 0) ? 0 : ((R > 1.0) ? 1.0 : R)) * normr;
      dstPixels[dIndex++]=((G < 0) ? 0 : ((G > 1.0) ? 1.0 : G)) * normg;
      dstPixels[dIndex++]=((B < 0) ? 0 : ((B > 1.0) ? 1.0 : B)) * normb;
    }
  }
  convertToSigned(dstPixels,dstType);
  dest.setPixels(dest.getMinX(),dest.getMinY(),width,height,dstPixels);
}",0.9997915363769022
154077,"private void byteLoop(Raster source,WritableRaster dest,Rectangle destRect){
  float src_rect_x1=source.getMinX();
  float src_rect_y1=source.getMinY();
  float src_rect_x2=src_rect_x1 + source.getWidth();
  float src_rect_y2=src_rect_y1 + source.getHeight();
  MultiPixelPackedSampleModel sourceSM=(MultiPixelPackedSampleModel)source.getSampleModel();
  DataBufferByte sourceDB=(DataBufferByte)source.getDataBuffer();
  int sourceTransX=source.getSampleModelTranslateX();
  int sourceTransY=source.getSampleModelTranslateY();
  int sourceDataBitOffset=sourceSM.getDataBitOffset();
  int sourceScanlineStride=sourceSM.getScanlineStride();
  MultiPixelPackedSampleModel destSM=(MultiPixelPackedSampleModel)dest.getSampleModel();
  DataBufferByte destDB=(DataBufferByte)dest.getDataBuffer();
  int destMinX=dest.getMinX();
  int destMinY=dest.getMinY();
  int destTransX=dest.getSampleModelTranslateX();
  int destTransY=dest.getSampleModelTranslateY();
  int destDataBitOffset=destSM.getDataBitOffset();
  int destScanlineStride=destSM.getScanlineStride();
  byte[] sourceData=sourceDB.getData();
  int sourceDBOffset=sourceDB.getOffset();
  byte[] destData=destDB.getData();
  int destDBOffset=destDB.getOffset();
  Point2D dst_pt=new Point2D.Float();
  Point2D src_pt=new Point2D.Float();
  int dst_min_x=destRect.x;
  int dst_min_y=destRect.y;
  int dst_max_x=destRect.x + destRect.width;
  int dst_max_y=destRect.y + destRect.height;
  int incyStride=incy * sourceScanlineStride;
  int incy1Stride=incy1 * sourceScanlineStride;
  black=((int)backgroundValues[0]) & 1;
  for (int y=dst_min_y; y < dst_max_y; y++) {
    dst_pt.setLocation((double)dst_min_x + 0.5,(double)y + 0.5);
    mapDestPoint(dst_pt,src_pt);
    float s_x=(float)src_pt.getX();
    float s_y=(float)src_pt.getY();
    int s_ix=(int)Math.floor(s_x);
    int s_iy=(int)Math.floor(s_y);
    double fracx=s_x - (double)s_ix;
    double fracy=s_y - (double)s_iy;
    int ifracx=(int)Math.floor(fracx * geom_frac_max);
    int ifracy=(int)Math.floor(fracy * geom_frac_max);
    int start_s_ix=s_ix;
    int start_s_iy=s_iy;
    int start_ifracx=ifracx;
    int start_ifracy=ifracy;
    Range clipRange=performScanlineClipping(src_rect_x1,src_rect_y1,src_rect_x2,src_rect_y2,s_ix,s_iy,ifracx,ifracy,dst_min_x,dst_max_x,0,0,0,0);
    int clipMinX=((Integer)clipRange.getMinValue()).intValue();
    int clipMaxX=((Integer)clipRange.getMaxValue()).intValue();
    if (clipMinX > clipMaxX)     continue;
    int destYOffset=(y - destTransY) * destScanlineStride + destDBOffset;
    int destXOffset=destDataBitOffset + (dst_min_x - destTransX);
    int sourceYOffset=(s_iy - sourceTransY) * sourceScanlineStride + sourceDBOffset;
    int sourceXOffset=s_ix - sourceTransX + sourceDataBitOffset;
    for (int x=dst_min_x; x < clipMinX; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 3);
        int dshift=7 - (destXOffset & 7);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(byte)delement;
      }
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMinX; x < clipMaxX; x++) {
      int sindex=sourceYOffset + (sourceXOffset >> 3);
      byte selement=sourceData[sindex];
      int val=(selement >> (7 - (sourceXOffset & 7))) & 1;
      int dindex=destYOffset + (destXOffset >> 3);
      int dshift=7 - (destXOffset & 7);
      int delement=destData[dindex];
      delement|=val << dshift;
      destData[dindex]=(byte)delement;
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMaxX; x < dst_max_x; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 3);
        int dshift=7 - (destXOffset & 7);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(byte)delement;
      }
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
  }
}","private void byteLoop(Raster source,WritableRaster dest,Rectangle destRect){
  float src_rect_x1=source.getMinX();
  float src_rect_y1=source.getMinY();
  float src_rect_x2=src_rect_x1 + source.getWidth();
  float src_rect_y2=src_rect_y1 + source.getHeight();
  MultiPixelPackedSampleModel sourceSM=(MultiPixelPackedSampleModel)source.getSampleModel();
  DataBufferByte sourceDB=(DataBufferByte)source.getDataBuffer();
  int sourceTransX=source.getSampleModelTranslateX();
  int sourceTransY=source.getSampleModelTranslateY();
  int sourceDataBitOffset=sourceSM.getDataBitOffset();
  int sourceScanlineStride=sourceSM.getScanlineStride();
  MultiPixelPackedSampleModel destSM=(MultiPixelPackedSampleModel)dest.getSampleModel();
  DataBufferByte destDB=(DataBufferByte)dest.getDataBuffer();
  int destMinX=dest.getMinX();
  int destMinY=dest.getMinY();
  int destTransX=dest.getSampleModelTranslateX();
  int destTransY=dest.getSampleModelTranslateY();
  int destDataBitOffset=destSM.getDataBitOffset();
  int destScanlineStride=destSM.getScanlineStride();
  byte[] sourceData=sourceDB.getData();
  int sourceDBOffset=sourceDB.getOffset();
  byte[] destData=destDB.getData();
  int destDBOffset=destDB.getOffset();
  Point2D dst_pt=new Point2D.Float();
  Point2D src_pt=new Point2D.Float();
  int dst_min_x=destRect.x;
  int dst_min_y=destRect.y;
  int dst_max_x=destRect.x + destRect.width;
  int dst_max_y=destRect.y + destRect.height;
  int incyStride=incy * sourceScanlineStride;
  int incy1Stride=incy1 * sourceScanlineStride;
  black=((int)backgroundValues[0]) & 1;
  for (int y=dst_min_y; y < dst_max_y; y++) {
    dst_pt.setLocation((double)dst_min_x + 0.5,(double)y + 0.5);
    mapDestPoint(dst_pt,src_pt);
    float s_x=(float)src_pt.getX();
    float s_y=(float)src_pt.getY();
    int s_ix=(int)Math.floor(s_x);
    int s_iy=(int)Math.floor(s_y);
    double fracx=s_x - (double)s_ix;
    double fracy=s_y - (double)s_iy;
    int ifracx=(int)Math.floor(fracx * geom_frac_max);
    int ifracy=(int)Math.floor(fracy * geom_frac_max);
    int start_s_ix=s_ix;
    int start_s_iy=s_iy;
    int start_ifracx=ifracx;
    int start_ifracy=ifracy;
    Range clipRange=performScanlineClipping(src_rect_x1,src_rect_y1,src_rect_x2 - 1,src_rect_y2 - 1,s_ix,s_iy,ifracx,ifracy,dst_min_x,dst_max_x,0,0,0,0);
    int clipMinX=((Integer)clipRange.getMinValue()).intValue();
    int clipMaxX=((Integer)clipRange.getMaxValue()).intValue();
    if (clipMinX > clipMaxX)     continue;
    int destYOffset=(y - destTransY) * destScanlineStride + destDBOffset;
    int destXOffset=destDataBitOffset + (dst_min_x - destTransX);
    int sourceYOffset=(s_iy - sourceTransY) * sourceScanlineStride + sourceDBOffset;
    int sourceXOffset=s_ix - sourceTransX + sourceDataBitOffset;
    for (int x=dst_min_x; x < clipMinX; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 3);
        int dshift=7 - (destXOffset & 7);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(byte)delement;
      }
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMinX; x < clipMaxX; x++) {
      int sindex=sourceYOffset + (sourceXOffset >> 3);
      byte selement=sourceData[sindex];
      int val=(selement >> (7 - (sourceXOffset & 7))) & 1;
      int dindex=destYOffset + (destXOffset >> 3);
      int dshift=7 - (destXOffset & 7);
      int delement=destData[dindex];
      delement|=val << dshift;
      destData[dindex]=(byte)delement;
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMaxX; x < dst_max_x; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 3);
        int dshift=7 - (destXOffset & 7);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(byte)delement;
      }
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
  }
}",0.9744826200522404
154078,"private void intLoop(Raster source,WritableRaster dest,Rectangle destRect){
  float src_rect_x1=source.getMinX();
  float src_rect_y1=source.getMinY();
  float src_rect_x2=src_rect_x1 + source.getWidth();
  float src_rect_y2=src_rect_y1 + source.getHeight();
  MultiPixelPackedSampleModel sourceSM=(MultiPixelPackedSampleModel)source.getSampleModel();
  DataBufferInt sourceDB=(DataBufferInt)source.getDataBuffer();
  int sourceTransX=source.getSampleModelTranslateX();
  int sourceTransY=source.getSampleModelTranslateY();
  int sourceDataBitOffset=sourceSM.getDataBitOffset();
  int sourceScanlineStride=sourceSM.getScanlineStride();
  MultiPixelPackedSampleModel destSM=(MultiPixelPackedSampleModel)dest.getSampleModel();
  DataBufferInt destDB=(DataBufferInt)dest.getDataBuffer();
  int destMinX=dest.getMinX();
  int destMinY=dest.getMinY();
  int destTransX=dest.getSampleModelTranslateX();
  int destTransY=dest.getSampleModelTranslateY();
  int destDataBitOffset=destSM.getDataBitOffset();
  int destScanlineStride=destSM.getScanlineStride();
  int[] sourceData=sourceDB.getData();
  int sourceDBOffset=sourceDB.getOffset();
  int[] destData=destDB.getData();
  int destDBOffset=destDB.getOffset();
  Point2D dst_pt=new Point2D.Float();
  Point2D src_pt=new Point2D.Float();
  int dst_min_x=destRect.x;
  int dst_min_y=destRect.y;
  int dst_max_x=destRect.x + destRect.width;
  int dst_max_y=destRect.y + destRect.height;
  int incyStride=incy * sourceScanlineStride;
  int incy1Stride=incy1 * sourceScanlineStride;
  black=((int)backgroundValues[0]) & 1;
  for (int y=dst_min_y; y < dst_max_y; y++) {
    dst_pt.setLocation((double)dst_min_x + 0.5,(double)y + 0.5);
    mapDestPoint(dst_pt,src_pt);
    float s_x=(float)src_pt.getX();
    float s_y=(float)src_pt.getY();
    int s_ix=(int)Math.floor(s_x);
    int s_iy=(int)Math.floor(s_y);
    double fracx=s_x - (double)s_ix;
    double fracy=s_y - (double)s_iy;
    int ifracx=(int)Math.floor(fracx * geom_frac_max);
    int ifracy=(int)Math.floor(fracy * geom_frac_max);
    int start_s_ix=s_ix;
    int start_s_iy=s_iy;
    int start_ifracx=ifracx;
    int start_ifracy=ifracy;
    Range clipRange=performScanlineClipping(src_rect_x1,src_rect_y1,src_rect_x2,src_rect_y2,s_ix,s_iy,ifracx,ifracy,dst_min_x,dst_max_x,0,0,0,0);
    int clipMinX=((Integer)clipRange.getMinValue()).intValue();
    int clipMaxX=((Integer)clipRange.getMaxValue()).intValue();
    if (clipMinX > clipMaxX)     continue;
    int destYOffset=(y - destTransY) * destScanlineStride + destDBOffset;
    int destXOffset=destDataBitOffset + (dst_min_x - destTransX);
    int sourceYOffset=(s_iy - sourceTransY) * sourceScanlineStride + sourceDBOffset;
    int sourceXOffset=s_ix - sourceTransX + sourceDataBitOffset;
    for (int x=dst_min_x; x < clipMinX; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 5);
        int dshift=31 - (destXOffset & 31);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(int)delement;
      }
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMinX; x < clipMaxX; x++) {
      int sindex=sourceYOffset + (sourceXOffset >> 5);
      int selement=sourceData[sindex];
      int val=(selement >> (31 - (sourceXOffset & 31))) & 1;
      int dindex=destYOffset + (destXOffset >> 5);
      int dshift=31 - (destXOffset & 31);
      int delement=destData[dindex];
      delement|=val << dshift;
      destData[dindex]=(int)delement;
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMaxX; x < dst_max_x; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 5);
        int dshift=31 - (destXOffset & 31);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(int)delement;
      }
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
  }
}","private void intLoop(Raster source,WritableRaster dest,Rectangle destRect){
  float src_rect_x1=source.getMinX();
  float src_rect_y1=source.getMinY();
  float src_rect_x2=src_rect_x1 + source.getWidth();
  float src_rect_y2=src_rect_y1 + source.getHeight();
  MultiPixelPackedSampleModel sourceSM=(MultiPixelPackedSampleModel)source.getSampleModel();
  DataBufferInt sourceDB=(DataBufferInt)source.getDataBuffer();
  int sourceTransX=source.getSampleModelTranslateX();
  int sourceTransY=source.getSampleModelTranslateY();
  int sourceDataBitOffset=sourceSM.getDataBitOffset();
  int sourceScanlineStride=sourceSM.getScanlineStride();
  MultiPixelPackedSampleModel destSM=(MultiPixelPackedSampleModel)dest.getSampleModel();
  DataBufferInt destDB=(DataBufferInt)dest.getDataBuffer();
  int destMinX=dest.getMinX();
  int destMinY=dest.getMinY();
  int destTransX=dest.getSampleModelTranslateX();
  int destTransY=dest.getSampleModelTranslateY();
  int destDataBitOffset=destSM.getDataBitOffset();
  int destScanlineStride=destSM.getScanlineStride();
  int[] sourceData=sourceDB.getData();
  int sourceDBOffset=sourceDB.getOffset();
  int[] destData=destDB.getData();
  int destDBOffset=destDB.getOffset();
  Point2D dst_pt=new Point2D.Float();
  Point2D src_pt=new Point2D.Float();
  int dst_min_x=destRect.x;
  int dst_min_y=destRect.y;
  int dst_max_x=destRect.x + destRect.width;
  int dst_max_y=destRect.y + destRect.height;
  int incyStride=incy * sourceScanlineStride;
  int incy1Stride=incy1 * sourceScanlineStride;
  black=((int)backgroundValues[0]) & 1;
  for (int y=dst_min_y; y < dst_max_y; y++) {
    dst_pt.setLocation((double)dst_min_x + 0.5,(double)y + 0.5);
    mapDestPoint(dst_pt,src_pt);
    float s_x=(float)src_pt.getX();
    float s_y=(float)src_pt.getY();
    int s_ix=(int)Math.floor(s_x);
    int s_iy=(int)Math.floor(s_y);
    double fracx=s_x - (double)s_ix;
    double fracy=s_y - (double)s_iy;
    int ifracx=(int)Math.floor(fracx * geom_frac_max);
    int ifracy=(int)Math.floor(fracy * geom_frac_max);
    int start_s_ix=s_ix;
    int start_s_iy=s_iy;
    int start_ifracx=ifracx;
    int start_ifracy=ifracy;
    Range clipRange=performScanlineClipping(src_rect_x1,src_rect_y1,src_rect_x2 - 1,src_rect_y2 - 1,s_ix,s_iy,ifracx,ifracy,dst_min_x,dst_max_x,0,0,0,0);
    int clipMinX=((Integer)clipRange.getMinValue()).intValue();
    int clipMaxX=((Integer)clipRange.getMaxValue()).intValue();
    if (clipMinX > clipMaxX)     continue;
    int destYOffset=(y - destTransY) * destScanlineStride + destDBOffset;
    int destXOffset=destDataBitOffset + (dst_min_x - destTransX);
    int sourceYOffset=(s_iy - sourceTransY) * sourceScanlineStride + sourceDBOffset;
    int sourceXOffset=s_ix - sourceTransX + sourceDataBitOffset;
    for (int x=dst_min_x; x < clipMinX; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 5);
        int dshift=31 - (destXOffset & 31);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(int)delement;
      }
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMinX; x < clipMaxX; x++) {
      int sindex=sourceYOffset + (sourceXOffset >> 5);
      int selement=sourceData[sindex];
      int val=(selement >> (31 - (sourceXOffset & 31))) & 1;
      int dindex=destYOffset + (destXOffset >> 5);
      int dshift=31 - (destXOffset & 31);
      int delement=destData[dindex];
      delement|=val << dshift;
      destData[dindex]=(int)delement;
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMaxX; x < dst_max_x; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 5);
        int dshift=31 - (destXOffset & 31);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(int)delement;
      }
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
  }
}",0.9744672295938882
154079,"private void shortLoop(Raster source,WritableRaster dest,Rectangle destRect){
  float src_rect_x1=source.getMinX();
  float src_rect_y1=source.getMinY();
  float src_rect_x2=src_rect_x1 + source.getWidth();
  float src_rect_y2=src_rect_y1 + source.getHeight();
  MultiPixelPackedSampleModel sourceSM=(MultiPixelPackedSampleModel)source.getSampleModel();
  DataBufferShort sourceDB=(DataBufferShort)source.getDataBuffer();
  int sourceTransX=source.getSampleModelTranslateX();
  int sourceTransY=source.getSampleModelTranslateY();
  int sourceDataBitOffset=sourceSM.getDataBitOffset();
  int sourceScanlineStride=sourceSM.getScanlineStride();
  MultiPixelPackedSampleModel destSM=(MultiPixelPackedSampleModel)dest.getSampleModel();
  DataBufferShort destDB=(DataBufferShort)dest.getDataBuffer();
  int destMinX=dest.getMinX();
  int destMinY=dest.getMinY();
  int destTransX=dest.getSampleModelTranslateX();
  int destTransY=dest.getSampleModelTranslateY();
  int destDataBitOffset=destSM.getDataBitOffset();
  int destScanlineStride=destSM.getScanlineStride();
  short[] sourceData=sourceDB.getData();
  int sourceDBOffset=sourceDB.getOffset();
  short[] destData=destDB.getData();
  int destDBOffset=destDB.getOffset();
  Point2D dst_pt=new Point2D.Float();
  Point2D src_pt=new Point2D.Float();
  int dst_min_x=destRect.x;
  int dst_min_y=destRect.y;
  int dst_max_x=destRect.x + destRect.width;
  int dst_max_y=destRect.y + destRect.height;
  int incyStride=incy * sourceScanlineStride;
  int incy1Stride=incy1 * sourceScanlineStride;
  black=((int)backgroundValues[0]) & 1;
  for (int y=dst_min_y; y < dst_max_y; y++) {
    dst_pt.setLocation((double)dst_min_x + 0.5,(double)y + 0.5);
    mapDestPoint(dst_pt,src_pt);
    float s_x=(float)src_pt.getX();
    float s_y=(float)src_pt.getY();
    int s_ix=(int)Math.floor(s_x);
    int s_iy=(int)Math.floor(s_y);
    double fracx=s_x - (double)s_ix;
    double fracy=s_y - (double)s_iy;
    int ifracx=(int)Math.floor(fracx * geom_frac_max);
    int ifracy=(int)Math.floor(fracy * geom_frac_max);
    int start_s_ix=s_ix;
    int start_s_iy=s_iy;
    int start_ifracx=ifracx;
    int start_ifracy=ifracy;
    Range clipRange=performScanlineClipping(src_rect_x1,src_rect_y1,src_rect_x2,src_rect_y2,s_ix,s_iy,ifracx,ifracy,dst_min_x,dst_max_x,0,0,0,0);
    int clipMinX=((Integer)clipRange.getMinValue()).intValue();
    int clipMaxX=((Integer)clipRange.getMaxValue()).intValue();
    if (clipMinX > clipMaxX)     continue;
    int destYOffset=(y - destTransY) * destScanlineStride + destDBOffset;
    int destXOffset=destDataBitOffset + (dst_min_x - destTransX);
    int sourceYOffset=(s_iy - sourceTransY) * sourceScanlineStride + sourceDBOffset;
    int sourceXOffset=s_ix - sourceTransX + sourceDataBitOffset;
    for (int x=dst_min_x; x < clipMinX; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 4);
        int dshift=15 - (destXOffset & 15);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(short)delement;
      }
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMinX; x < clipMaxX; x++) {
      int sindex=sourceYOffset + (sourceXOffset >> 4);
      short selement=sourceData[sindex];
      int val=(selement >> (15 - (sourceXOffset & 15))) & 1;
      int dindex=destYOffset + (destXOffset >> 4);
      int dshift=15 - (destXOffset & 15);
      int delement=destData[dindex];
      delement|=val << dshift;
      destData[dindex]=(short)delement;
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMaxX; x < dst_max_x; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 4);
        int dshift=15 - (destXOffset & 15);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(short)delement;
      }
      if (ifracx < ifracdx1) {
        s_ix+=incx;
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        s_ix+=incx1;
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        s_iy+=incy;
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        s_iy+=incy1;
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
  }
}","private void shortLoop(Raster source,WritableRaster dest,Rectangle destRect){
  float src_rect_x1=source.getMinX();
  float src_rect_y1=source.getMinY();
  float src_rect_x2=src_rect_x1 + source.getWidth();
  float src_rect_y2=src_rect_y1 + source.getHeight();
  MultiPixelPackedSampleModel sourceSM=(MultiPixelPackedSampleModel)source.getSampleModel();
  DataBufferShort sourceDB=(DataBufferShort)source.getDataBuffer();
  int sourceTransX=source.getSampleModelTranslateX();
  int sourceTransY=source.getSampleModelTranslateY();
  int sourceDataBitOffset=sourceSM.getDataBitOffset();
  int sourceScanlineStride=sourceSM.getScanlineStride();
  MultiPixelPackedSampleModel destSM=(MultiPixelPackedSampleModel)dest.getSampleModel();
  DataBufferShort destDB=(DataBufferShort)dest.getDataBuffer();
  int destMinX=dest.getMinX();
  int destMinY=dest.getMinY();
  int destTransX=dest.getSampleModelTranslateX();
  int destTransY=dest.getSampleModelTranslateY();
  int destDataBitOffset=destSM.getDataBitOffset();
  int destScanlineStride=destSM.getScanlineStride();
  short[] sourceData=sourceDB.getData();
  int sourceDBOffset=sourceDB.getOffset();
  short[] destData=destDB.getData();
  int destDBOffset=destDB.getOffset();
  Point2D dst_pt=new Point2D.Float();
  Point2D src_pt=new Point2D.Float();
  int dst_min_x=destRect.x;
  int dst_min_y=destRect.y;
  int dst_max_x=destRect.x + destRect.width;
  int dst_max_y=destRect.y + destRect.height;
  int incyStride=incy * sourceScanlineStride;
  int incy1Stride=incy1 * sourceScanlineStride;
  black=((int)backgroundValues[0]) & 1;
  for (int y=dst_min_y; y < dst_max_y; y++) {
    dst_pt.setLocation((double)dst_min_x + 0.5,(double)y + 0.5);
    mapDestPoint(dst_pt,src_pt);
    float s_x=(float)src_pt.getX();
    float s_y=(float)src_pt.getY();
    int s_ix=(int)Math.floor(s_x);
    int s_iy=(int)Math.floor(s_y);
    double fracx=s_x - (double)s_ix;
    double fracy=s_y - (double)s_iy;
    int ifracx=(int)Math.floor(fracx * geom_frac_max);
    int ifracy=(int)Math.floor(fracy * geom_frac_max);
    int start_s_ix=s_ix;
    int start_s_iy=s_iy;
    int start_ifracx=ifracx;
    int start_ifracy=ifracy;
    Range clipRange=performScanlineClipping(src_rect_x1,src_rect_y1,src_rect_x2 - 1,src_rect_y2 - 1,s_ix,s_iy,ifracx,ifracy,dst_min_x,dst_max_x,0,0,0,0);
    int clipMinX=((Integer)clipRange.getMinValue()).intValue();
    int clipMaxX=((Integer)clipRange.getMaxValue()).intValue();
    if (clipMinX > clipMaxX)     continue;
    int destYOffset=(y - destTransY) * destScanlineStride + destDBOffset;
    int destXOffset=destDataBitOffset + (dst_min_x - destTransX);
    int sourceYOffset=(s_iy - sourceTransY) * sourceScanlineStride + sourceDBOffset;
    int sourceXOffset=s_ix - sourceTransX + sourceDataBitOffset;
    for (int x=dst_min_x; x < clipMinX; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 4);
        int dshift=15 - (destXOffset & 15);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(short)delement;
      }
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMinX; x < clipMaxX; x++) {
      int sindex=sourceYOffset + (sourceXOffset >> 4);
      short selement=sourceData[sindex];
      int val=(selement >> (15 - (sourceXOffset & 15))) & 1;
      int dindex=destYOffset + (destXOffset >> 4);
      int dshift=15 - (destXOffset & 15);
      int delement=destData[dindex];
      delement|=val << dshift;
      destData[dindex]=(short)delement;
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
    for (int x=clipMaxX; x < dst_max_x; x++) {
      if (setBackground) {
        int dindex=destYOffset + (destXOffset >> 4);
        int dshift=15 - (destXOffset & 15);
        int delement=destData[dindex];
        delement|=black << dshift;
        destData[dindex]=(short)delement;
      }
      if (ifracx < ifracdx1) {
        ifracx+=ifracdx;
        sourceXOffset+=incx;
      }
 else {
        ifracx-=ifracdx1;
        sourceXOffset+=incx1;
      }
      if (ifracy < ifracdy1) {
        ifracy+=ifracdy;
        sourceYOffset+=incyStride;
      }
 else {
        ifracy-=ifracdy1;
        sourceYOffset+=incy1Stride;
      }
      ++destXOffset;
    }
  }
}",0.9745796637309848
154080,"/** 
 * Creates a new instance of <code>MlibHistogramOpImage</code> in the rendered layer. Any image layout information in <code>RenderingHints</code> is ignored. This method satisfies the implementation of RIF.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  if (!MediaLibAccessor.isMediaLibCompatible(args)) {
    return null;
  }
  RenderedImage src=args.getRenderedSource(0);
  int dataType=src.getSampleModel().getDataType();
  if (dataType == DataBuffer.TYPE_FLOAT || dataType == DataBuffer.TYPE_DOUBLE) {
    return null;
  }
  ROI roi=(ROI)args.getObjectParameter(0);
  if (roi != null && !roi.equals(new Rectangle(src.getMinX(),src.getMinY(),src.getWidth(),src.getHeight()))) {
    return null;
  }
  int xPeriod=args.getIntParameter(1);
  int yPeriod=args.getIntParameter(2);
  int[] numBins=(int[])args.getObjectParameter(3);
  double[] lowValueFP=(double[])args.getObjectParameter(4);
  double[] highValueFP=(double[])args.getObjectParameter(5);
  MlibHistogramOpImage op=null;
  try {
    op=new MlibHistogramOpImage(src,xPeriod,yPeriod,numBins,lowValueFP,highValueFP);
  }
 catch (  Exception e) {
    ImagingListener listener=ImageUtil.getImagingListener(hints);
    String message=JaiI18N.getString(""String_Node_Str"");
    listener.errorOccurred(message,e,this,false);
  }
  return op;
}","/** 
 * Creates a new instance of <code>MlibHistogramOpImage</code> in the rendered layer. Any image layout information in <code>RenderingHints</code> is ignored. This method satisfies the implementation of RIF.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  if (!MediaLibAccessor.isMediaLibCompatible(args)) {
    return null;
  }
  RenderedImage src=args.getRenderedSource(0);
  int dataType=src.getSampleModel().getDataType();
  if (dataType == DataBuffer.TYPE_FLOAT || dataType == DataBuffer.TYPE_DOUBLE) {
    return null;
  }
  ROI roi=(ROI)args.getObjectParameter(0);
  if (roi != null && !roi.equals(new Rectangle(src.getMinX(),src.getMinY(),src.getWidth(),src.getHeight()))) {
    return null;
  }
  int xPeriod=args.getIntParameter(1);
  int yPeriod=args.getIntParameter(2);
  int[] numBins=(int[])args.getObjectParameter(3);
  double[] lowValueFP=(double[])args.getObjectParameter(4);
  double[] highValueFP=(double[])args.getObjectParameter(5);
  int minPixelValue;
  int maxPixelValue;
switch (dataType) {
case DataBuffer.TYPE_SHORT:
    minPixelValue=Short.MIN_VALUE;
  maxPixelValue=Short.MAX_VALUE;
break;
case DataBuffer.TYPE_USHORT:
minPixelValue=0;
maxPixelValue=-((int)Short.MIN_VALUE) + Short.MAX_VALUE;
break;
case DataBuffer.TYPE_INT:
minPixelValue=Integer.MIN_VALUE;
maxPixelValue=Integer.MAX_VALUE;
break;
case DataBuffer.TYPE_BYTE:
default :
minPixelValue=0;
maxPixelValue=-((int)Byte.MIN_VALUE) + Byte.MAX_VALUE;
break;
}
for (int i=0; i < lowValueFP.length; i++) {
if (lowValueFP[i] < minPixelValue || lowValueFP[i] > maxPixelValue) {
return null;
}
}
for (int i=0; i < highValueFP.length; i++) {
if (highValueFP[i] <= minPixelValue || highValueFP[i] > (maxPixelValue + 1)) {
return null;
}
}
MlibHistogramOpImage op=null;
try {
op=new MlibHistogramOpImage(src,xPeriod,yPeriod,numBins,lowValueFP,highValueFP);
}
 catch (Exception e) {
ImagingListener listener=ImageUtil.getImagingListener(hints);
String message=JaiI18N.getString(""String_Node_Str"");
listener.errorOccurred(message,e,this,false);
}
return op;
}",0.768235294117647
154081,"/** 
 * Performs a subsampling operation on a specified rectangle. The sources are cobbled.
 * @param sources  an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest     a WritableRaster  containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  RasterFormatTag[] formatTags=getFormatTags();
  RasterAccessor dst=new RasterAccessor(dest,destRect,formatTags[1],getColorModel());
  RasterAccessor src=new RasterAccessor(sources[0],mapDestRect(destRect,0),formatTags[0],getSourceImage(0).getColorModel());
switch (dst.getDataType()) {
case DataBuffer.TYPE_BYTE:
    computeRectByte(src,dst);
  break;
case DataBuffer.TYPE_USHORT:
computeRectUShort(src,dst);
break;
case DataBuffer.TYPE_SHORT:
computeRectShort(src,dst);
break;
case DataBuffer.TYPE_INT:
computeRectInt(src,dst);
break;
case DataBuffer.TYPE_FLOAT:
computeRectFloat(src,dst);
break;
case DataBuffer.TYPE_DOUBLE:
computeRectDouble(src,dst);
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dst.isDataCopy()) {
dst.clampDataArrays();
dst.copyDataToRaster();
}
}","/** 
 * Performs a subsampling operation on a specified rectangle. The sources are cobbled.
 * @param sources  an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest     a WritableRaster  containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  RasterFormatTag[] formatTags=getFormatTags();
  RasterAccessor dst=new RasterAccessor(dest,destRect,formatTags[1],getColorModel());
  Rectangle srcRect=mapDestRect(destRect,0).intersection(sources[0].getBounds());
  RasterAccessor src=new RasterAccessor(sources[0],srcRect,formatTags[0],getSourceImage(0).getColorModel());
switch (dst.getDataType()) {
case DataBuffer.TYPE_BYTE:
    computeRectByte(src,dst);
  break;
case DataBuffer.TYPE_USHORT:
computeRectUShort(src,dst);
break;
case DataBuffer.TYPE_SHORT:
computeRectShort(src,dst);
break;
case DataBuffer.TYPE_INT:
computeRectInt(src,dst);
break;
case DataBuffer.TYPE_FLOAT:
computeRectFloat(src,dst);
break;
case DataBuffer.TYPE_DOUBLE:
computeRectDouble(src,dst);
break;
default :
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
if (dst.isDataCopy()) {
dst.clampDataArrays();
dst.copyDataToRaster();
}
}",0.929182879377432
154082,"/** 
 * Computes a tile of the destination image in the destination color space.
 * @param sources   Cobbled sources, guaranteed to provide all thesource data necessary for computing the rectangle.
 * @param dest      The tile containing the rectangle to be computed.
 * @param destRect  The rectangle within the tile to be computed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  WritableRaster tempRas=null;
switch (caseNumber) {
case 1:
    tempRas=computeRectColorSpaceJAIToRGB(sources[0],srcParam,null,tempParam);
  computeRectColorSpaceJAIFromRGB(tempRas,tempParam,dest,dstParam);
break;
case 2:
tempRas=computeRectColorSpaceJAIToRGB(sources[0],srcParam,null,tempParam);
computeRectNonColorSpaceJAI(tempRas,tempParam,dest,dstParam,destRect);
break;
case 3:
computeRectColorSpaceJAIToRGB(sources[0],srcParam,dest,dstParam);
break;
case 4:
tempRas=createTempWritableRaster(sources[0]);
computeRectNonColorSpaceJAI(sources[0],srcParam,tempRas,tempParam,destRect);
computeRectColorSpaceJAIFromRGB(tempRas,tempParam,dest,dstParam);
break;
case 5:
computeRectColorSpaceJAIFromRGB(sources[0],srcParam,dest,dstParam);
break;
case 6:
computeRectNonColorSpaceJAI(sources[0],srcParam,dest,dstParam,destRect);
default :
break;
}
}","/** 
 * Computes a tile of the destination image in the destination color space.
 * @param sources   Cobbled sources, guaranteed to provide all thesource data necessary for computing the rectangle.
 * @param dest      The tile containing the rectangle to be computed.
 * @param destRect  The rectangle within the tile to be computed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  WritableRaster tempRas=null;
  Raster source=sources[0];
  if (!destRect.equals(source.getBounds())) {
    source=source.createChild(destRect.x,destRect.y,destRect.width,destRect.height,destRect.x,destRect.y,null);
  }
switch (caseNumber) {
case 1:
    tempRas=computeRectColorSpaceJAIToRGB(source,srcParam,null,tempParam);
  computeRectColorSpaceJAIFromRGB(tempRas,tempParam,dest,dstParam);
break;
case 2:
tempRas=computeRectColorSpaceJAIToRGB(source,srcParam,null,tempParam);
computeRectNonColorSpaceJAI(tempRas,tempParam,dest,dstParam,destRect);
break;
case 3:
computeRectColorSpaceJAIToRGB(source,srcParam,dest,dstParam);
break;
case 4:
tempRas=createTempWritableRaster(source);
computeRectNonColorSpaceJAI(source,srcParam,tempRas,tempParam,destRect);
computeRectColorSpaceJAIFromRGB(tempRas,tempParam,dest,dstParam);
break;
case 5:
computeRectColorSpaceJAIFromRGB(source,srcParam,dest,dstParam);
break;
case 6:
computeRectNonColorSpaceJAI(source,srcParam,dest,dstParam,destRect);
default :
break;
}
}",0.9191994069681244
154083,"/** 
 * Performs convolution on a specified rectangle. The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=mapDestRect(destRect,0);
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag,true);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag,true);
  int numBands=getSampleModel().getNumBands();
  mediaLibImage[] srcML=srcAccessor.getMediaLibImages();
  mediaLibImage[] dstML=dstAccessor.getMediaLibImages();
  for (int i=0; i < dstML.length; i++) {
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
      if (shift == -1) {
        setShift(formatTag);
      }
    if (kw == 3) {
      Image.Conv3x3(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
 else {
      Image.Conv5x5(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
  break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
if (kw == 3) {
  Image.Conv3x3_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
 else {
  Image.Conv5x5_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}","/** 
 * Performs convolution on a specified rectangle. The sources are cobbled.
 * @param sources an array of source Rasters, guaranteed to provide allnecessary source data for computing the output.
 * @param dest a WritableRaster tile containing the area to be computed.
 * @param destRect the rectangle within dest to be processed.
 */
protected void computeRect(Raster[] sources,WritableRaster dest,Rectangle destRect){
  Raster source=sources[0];
  Rectangle srcRect=mapDestRect(destRect,0);
  int formatTag=MediaLibAccessor.findCompatibleTag(sources,dest);
  MediaLibAccessor srcAccessor=new MediaLibAccessor(source,srcRect,formatTag,true);
  MediaLibAccessor dstAccessor=new MediaLibAccessor(dest,destRect,formatTag,true);
  int numBands=getSampleModel().getNumBands();
  mediaLibImage[] srcML=srcAccessor.getMediaLibImages();
  mediaLibImage[] dstML=dstAccessor.getMediaLibImages();
  for (int i=0; i < dstML.length; i++) {
switch (dstAccessor.getDataType()) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_INT:
      if (shift == -1) {
        setShift(formatTag);
      }
    if (kw == 2) {
      Image.Conv2x2(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
 else     if (kw == 3) {
      Image.Conv3x3(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
 else     if (kw == 4) {
      Image.Conv4x4(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
 else     if (kw == 5) {
      Image.Conv5x5(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
 else     if (kw == 7) {
      Image.Conv7x7(dstML[i],srcML[i],intkData,shift,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
    }
  break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
if (kw == 2) {
  Image.Conv2x2_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
 else if (kw == 3) {
  Image.Conv3x3_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
 else if (kw == 4) {
  Image.Conv4x4_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
 else if (kw == 5) {
  Image.Conv5x5_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
 else if (kw == 7) {
  Image.Conv7x7_Fp(dstML[i],srcML[i],doublekData,((1 << numBands) - 1),Constants.MLIB_EDGE_DST_NO_WRITE);
}
break;
default :
String className=this.getClass().getName();
throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
}
}
if (dstAccessor.isDataCopy()) {
dstAccessor.copyDataToRaster();
}
}",0.8191214470284238
154084,"/** 
 * Return min of <code>maxOffset</code> or offset of first pixel different from pixel at <code>bitOffset</code>.
 */
private int nextState(byte[] data,int base,int bitOffset,int maxOffset){
  if (data == null) {
    return maxOffset;
  }
  int next=base + (bitOffset >>> 3);
  int end=base + (maxOffset >>> 3);
  if (end == data.length) {
    end--;
  }
  int extra=bitOffset & 0x7;
  int testbyte;
  if ((data[next] & (0x80 >>> extra)) != 0) {
    testbyte=~(data[next]) & (0xff >>> extra);
    while (next < end) {
      if (testbyte != 0) {
        break;
      }
      testbyte=~(data[++next]) & 0xff;
    }
  }
 else {
    if ((testbyte=(data[next] & (0xff >>> extra))) != 0) {
      bitOffset=(next - base) * 8 + byteTable[testbyte];
      return ((bitOffset < maxOffset) ? bitOffset : maxOffset);
    }
    while (next < end) {
      if ((testbyte=data[++next] & 0xff) != 0) {
        bitOffset=(next - base) * 8 + byteTable[testbyte];
        return ((bitOffset < maxOffset) ? bitOffset : maxOffset);
      }
    }
  }
  bitOffset=(next - base) * 8 + byteTable[testbyte];
  return ((bitOffset < maxOffset) ? bitOffset : maxOffset);
}","/** 
 * Return min of <code>maxOffset</code> or offset of first pixel different from pixel at <code>bitOffset</code>.
 */
private int nextState(byte[] data,int base,int bitOffset,int maxOffset){
  if (data == null) {
    return maxOffset;
  }
  int next=base + (bitOffset >>> 3);
  if (next >= data.length) {
    return maxOffset;
  }
  int end=base + (maxOffset >>> 3);
  if (end == data.length) {
    end--;
  }
  int extra=bitOffset & 0x7;
  int testbyte;
  if ((data[next] & (0x80 >>> extra)) != 0) {
    testbyte=~(data[next]) & (0xff >>> extra);
    while (next < end) {
      if (testbyte != 0) {
        break;
      }
      testbyte=~(data[++next]) & 0xff;
    }
  }
 else {
    if ((testbyte=(data[next] & (0xff >>> extra))) != 0) {
      bitOffset=(next - base) * 8 + byteTable[testbyte];
      return ((bitOffset < maxOffset) ? bitOffset : maxOffset);
    }
    while (next < end) {
      if ((testbyte=data[++next] & 0xff) != 0) {
        bitOffset=(next - base) * 8 + byteTable[testbyte];
        return ((bitOffset < maxOffset) ? bitOffset : maxOffset);
      }
    }
  }
  bitOffset=(next - base) * 8 + byteTable[testbyte];
  return ((bitOffset < maxOffset) ? bitOffset : maxOffset);
}",0.9765658287175116
154085,"private void initialize(SeekableStream stream) throws IOException {
  long nextTagOffset;
  int i, j;
  IFDOffset=stream.getFilePointer();
  numEntries=readUnsignedShort(stream);
  fields=new TIFFField[numEntries];
  for (i=0; i < numEntries; i++) {
    int tag=readUnsignedShort(stream);
    int type=readUnsignedShort(stream);
    int count=(int)(readUnsignedInt(stream));
    int value=0;
    nextTagOffset=stream.getFilePointer() + 4;
    try {
      if (count * sizeOfType[type] > 4) {
        value=(int)(readUnsignedInt(stream));
        stream.seek(value);
      }
    }
 catch (    ArrayIndexOutOfBoundsException ae) {
      System.err.println(tag + ""String_Node_Str"" + JaiI18N.getString(""String_Node_Str""));
      stream.seek(nextTagOffset);
      continue;
    }
    fieldIndex.put(new Integer(tag),new Integer(i));
    Object obj=null;
switch (type) {
case TIFFField.TIFF_BYTE:
case TIFFField.TIFF_SBYTE:
case TIFFField.TIFF_UNDEFINED:
case TIFFField.TIFF_ASCII:
      byte[] bvalues=new byte[count];
    stream.readFully(bvalues,0,count);
  if (type == TIFFField.TIFF_ASCII) {
    int index=0, prevIndex=0;
    Vector v=new Vector();
    while (index < count) {
      while ((index < count) && (bvalues[index++] != 0))       ;
      v.add(new String(bvalues,prevIndex,(index - prevIndex)));
      prevIndex=index;
    }
    count=v.size();
    String strings[]=new String[count];
    for (int c=0; c < count; c++) {
      strings[c]=(String)v.elementAt(c);
    }
    obj=strings;
  }
 else {
    obj=bvalues;
  }
break;
case TIFFField.TIFF_SHORT:
char[] cvalues=new char[count];
for (j=0; j < count; j++) {
cvalues[j]=(char)(readUnsignedShort(stream));
}
obj=cvalues;
break;
case TIFFField.TIFF_LONG:
long[] lvalues=new long[count];
for (j=0; j < count; j++) {
lvalues[j]=readUnsignedInt(stream);
}
obj=lvalues;
break;
case TIFFField.TIFF_RATIONAL:
long[][] llvalues=new long[count][2];
for (j=0; j < count; j++) {
llvalues[j][0]=readUnsignedInt(stream);
llvalues[j][1]=readUnsignedInt(stream);
}
obj=llvalues;
break;
case TIFFField.TIFF_SSHORT:
short[] svalues=new short[count];
for (j=0; j < count; j++) {
svalues[j]=readShort(stream);
}
obj=svalues;
break;
case TIFFField.TIFF_SLONG:
int[] ivalues=new int[count];
for (j=0; j < count; j++) {
ivalues[j]=readInt(stream);
}
obj=ivalues;
break;
case TIFFField.TIFF_SRATIONAL:
int[][] iivalues=new int[count][2];
for (j=0; j < count; j++) {
iivalues[j][0]=readInt(stream);
iivalues[j][1]=readInt(stream);
}
obj=iivalues;
break;
case TIFFField.TIFF_FLOAT:
float[] fvalues=new float[count];
for (j=0; j < count; j++) {
fvalues[j]=readFloat(stream);
}
obj=fvalues;
break;
case TIFFField.TIFF_DOUBLE:
double[] dvalues=new double[count];
for (j=0; j < count; j++) {
dvalues[j]=readDouble(stream);
}
obj=dvalues;
break;
default :
System.err.println(JaiI18N.getString(""String_Node_Str""));
break;
}
fields[i]=new TIFFField(tag,type,count,obj);
stream.seek(nextTagOffset);
}
nextIFDOffset=readUnsignedInt(stream);
}","private void initialize(SeekableStream stream) throws IOException {
  long nextTagOffset;
  int i, j;
  IFDOffset=stream.getFilePointer();
  numEntries=readUnsignedShort(stream);
  fields=new TIFFField[numEntries];
  for (i=0; i < numEntries; i++) {
    int tag=readUnsignedShort(stream);
    int type=readUnsignedShort(stream);
    int count=(int)(readUnsignedInt(stream));
    int value=0;
    nextTagOffset=stream.getFilePointer() + 4;
    try {
      if (count * sizeOfType[type] > 4) {
        value=(int)(readUnsignedInt(stream));
        stream.seek(value);
      }
    }
 catch (    ArrayIndexOutOfBoundsException ae) {
      System.err.println(tag + ""String_Node_Str"" + JaiI18N.getString(""String_Node_Str""));
      stream.seek(nextTagOffset);
      continue;
    }
    fieldIndex.put(new Integer(tag),new Integer(i));
    Object obj=null;
    try {
switch (type) {
case TIFFField.TIFF_BYTE:
case TIFFField.TIFF_SBYTE:
case TIFFField.TIFF_UNDEFINED:
case TIFFField.TIFF_ASCII:
        byte[] bvalues=new byte[count];
      stream.readFully(bvalues,0,count);
    if (type == TIFFField.TIFF_ASCII) {
      int index=0, prevIndex=0;
      Vector v=new Vector();
      while (index < count) {
        while ((index < count) && (bvalues[index++] != 0))         ;
        v.add(new String(bvalues,prevIndex,(index - prevIndex)));
        prevIndex=index;
      }
      count=v.size();
      String strings[]=new String[count];
      for (int c=0; c < count; c++) {
        strings[c]=(String)v.elementAt(c);
      }
      obj=strings;
    }
 else {
      obj=bvalues;
    }
  break;
case TIFFField.TIFF_SHORT:
char[] cvalues=new char[count];
for (j=0; j < count; j++) {
cvalues[j]=(char)(readUnsignedShort(stream));
}
obj=cvalues;
break;
case TIFFField.TIFF_LONG:
long[] lvalues=new long[count];
for (j=0; j < count; j++) {
lvalues[j]=readUnsignedInt(stream);
}
obj=lvalues;
break;
case TIFFField.TIFF_RATIONAL:
long[][] llvalues=new long[count][2];
for (j=0; j < count; j++) {
llvalues[j][0]=readUnsignedInt(stream);
llvalues[j][1]=readUnsignedInt(stream);
}
obj=llvalues;
break;
case TIFFField.TIFF_SSHORT:
short[] svalues=new short[count];
for (j=0; j < count; j++) {
svalues[j]=readShort(stream);
}
obj=svalues;
break;
case TIFFField.TIFF_SLONG:
int[] ivalues=new int[count];
for (j=0; j < count; j++) {
ivalues[j]=readInt(stream);
}
obj=ivalues;
break;
case TIFFField.TIFF_SRATIONAL:
int[][] iivalues=new int[count][2];
for (j=0; j < count; j++) {
iivalues[j][0]=readInt(stream);
iivalues[j][1]=readInt(stream);
}
obj=iivalues;
break;
case TIFFField.TIFF_FLOAT:
float[] fvalues=new float[count];
for (j=0; j < count; j++) {
fvalues[j]=readFloat(stream);
}
obj=fvalues;
break;
case TIFFField.TIFF_DOUBLE:
double[] dvalues=new double[count];
for (j=0; j < count; j++) {
dvalues[j]=readDouble(stream);
}
obj=dvalues;
break;
default :
System.err.println(JaiI18N.getString(""String_Node_Str""));
break;
}
fields[i]=new TIFFField(tag,type,count,obj);
}
 catch (EOFException eofe) {
if (tag <= 532 || tag == 33432) {
throw eofe;
}
fieldIndex.remove(new Integer(tag));
}
stream.seek(nextTagOffset);
}
nextIFDOffset=readUnsignedInt(stream);
}",0.9629872256796592
154086,"/** 
 * Defines a checkerboard image of several grey shades. 
 */
public CheckerboardOpImage(int minX,int minY,int width,int height,SampleModel sampleModel,TileCache cache,ImageLayout layout,int checkerSize,int numColors){
  super(minX,minY,width,height,sampleModel,cache,layout);
  if (numColors < 2) {
    numColors=2;
  }
  this.checkerSize=checkerSize;
  this.numColors=numColors;
switch (sampleModel.getTransferType()) {
case DataBuffer.TYPE_BYTE:
    increment=255 / (numColors - 1);
  break;
case DataBuffer.TYPE_USHORT:
increment=65535 / (numColors - 1);
break;
case DataBuffer.TYPE_SHORT:
increment=Short.MAX_VALUE / (numColors - 1);
break;
case DataBuffer.TYPE_INT:
increment=Integer.MAX_VALUE / (numColors - 1);
break;
}
}","/** 
 * Defines a checkerboard image of several grey shades. 
 */
public CheckerboardOpImage(int minX,int minY,int width,int height,SampleModel sampleModel,Map configuration,ImageLayout layout,int checkerSize,int numColors){
  super(layout,configuration,sampleModel,minX,minY,width,height);
  if (numColors < 2) {
    numColors=2;
  }
  this.checkerSize=checkerSize;
  this.numColors=numColors;
switch (sampleModel.getTransferType()) {
case DataBuffer.TYPE_BYTE:
    increment=255 / (numColors - 1);
  break;
case DataBuffer.TYPE_USHORT:
increment=65535 / (numColors - 1);
break;
case DataBuffer.TYPE_SHORT:
increment=Short.MAX_VALUE / (numColors - 1);
break;
case DataBuffer.TYPE_INT:
increment=Integer.MAX_VALUE / (numColors - 1);
break;
}
}",0.9390243902439024
154087,"public static OpImage createRandomOpImage(ImageLayout layout){
  return new RandomOpImage(0,0,800,800,RasterFactory.createPixelInterleavedSampleModel(DataBuffer.TYPE_BYTE,200,200,3),null,layout);
}","public static OpImage createRandomOpImage(Map configuration,ImageLayout layout){
  return new RandomOpImage(0,0,800,800,RasterFactory.createPixelInterleavedSampleModel(DataBuffer.TYPE_BYTE,200,200,3),configuration,layout);
}",0.9168646080760094
154088,"/** 
 * Print out the pixel values of the destination image within a specific rectangle, and all of its source image(s) pixel values within the cooresponding rectangle obtained by calling <code>OpImage.mapDestRect()</code>.
 * @param dst      The destination image to be tested.
 * @param dstRect  The rectangle of interest within dst.
 */
public static void testOpImage(OpImage dst,Rectangle dstRect){
  for (int i=0; i < dst.getNumSources(); i++) {
    PlanarImage src=dst.getSource(i);
    Rectangle srcRect=dst.mapDestRect(dstRect,i);
    String message=""String_Node_Str"" + (i + 1) + ""String_Node_Str"";
    printPixels(message,src,srcRect);
  }
  printPixels(""String_Node_Str"",dst,dstRect);
}","/** 
 * Print out the pixel values of the destination image within a specific rectangle, and all of its source image(s) pixel values within the cooresponding rectangle obtained by calling <code>OpImage.mapDestRect()</code>.
 * @param dst      The destination image to be tested.
 * @param dstRect  The rectangle of interest within dst.
 */
public static void testOpImage(OpImage dst,Rectangle dstRect){
  for (int i=0; i < dst.getNumSources(); i++) {
    PlanarImage src=dst.getSourceImage(i);
    Rectangle srcRect=dst.mapDestRect(dstRect,i);
    String message=""String_Node_Str"" + (i + 1) + ""String_Node_Str"";
    printPixels(message,src,srcRect);
  }
  printPixels(""String_Node_Str"",dst,dstRect);
}",0.9964209019327128
154089,"public RampOpImage(int minX,int minY,int width,int height,SampleModel sampleModel,TileCache cache,ImageLayout layout){
  super(minX,minY,width,height,sampleModel,cache,layout);
}","public RampOpImage(int minX,int minY,int width,int height,SampleModel sampleModel,Map configuration,ImageLayout layout){
  super(layout,configuration,sampleModel,minX,minY,width,height);
}",0.7759562841530054
154090,"public RandomOpImage(int minX,int minY,int width,int height,SampleModel sampleModel,TileCache cache,ImageLayout layout){
  super(minX,minY,width,height,sampleModel,cache,layout);
switch (this.transtype=sampleModel.getTransferType()) {
case DataBuffer.TYPE_BYTE:
    maxValue=255;
  break;
case DataBuffer.TYPE_USHORT:
maxValue=65535;
break;
case DataBuffer.TYPE_SHORT:
maxValue=Short.MAX_VALUE;
break;
case DataBuffer.TYPE_INT:
maxValue=Integer.MAX_VALUE;
break;
}
for (int y=getMinTileY(); y <= getMaxTileY(); y++) {
for (int x=getMinTileX(); x <= getMaxTileX(); x++) {
getTile(x,y);
}
}
}","public RandomOpImage(int minX,int minY,int width,int height,SampleModel sampleModel,Map configuration,ImageLayout layout){
  super(layout,configuration,sampleModel,minX,minY,width,height);
switch (this.transtype=sampleModel.getTransferType()) {
case DataBuffer.TYPE_BYTE:
    maxValue=255;
  break;
case DataBuffer.TYPE_USHORT:
maxValue=65535;
break;
case DataBuffer.TYPE_SHORT:
maxValue=Short.MAX_VALUE;
break;
case DataBuffer.TYPE_INT:
maxValue=Integer.MAX_VALUE;
break;
}
for (int y=getMinTileY(); y <= getMaxTileY(); y++) {
for (int x=getMinTileX(); x <= getMaxTileX(); x++) {
getTile(x,y);
}
}
}",0.9243697478991596
154091,"/** 
 * Creates a new instance of RandomOpImage in the rendered layer. This method satisfies the implementation of RIF.
 */
public RenderedImage create(ParameterBlock paramBlock,RenderingHints renderHints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
  TileCache cache=RIFUtil.getTileCacheHint(renderHints);
  return new RandomOpImage(cache,OpImageTester.setLayout(layout));
}","/** 
 * Creates a new instance of RandomOpImage in the rendered layer. This method satisfies the implementation of RIF.
 */
public RenderedImage create(ParameterBlock paramBlock,RenderingHints renderHints){
  ImageLayout layout=(renderHints == null) ? null : (ImageLayout)renderHints.get(JAI.KEY_IMAGE_LAYOUT);
  return OpImageTester.createRandomOpImage(renderHints,layout);
}",0.6207792207792208
154092,"public synchronized void decodeT6(byte[] buffer,byte[] compData,int startX,int height,long tiffT6Options){
  this.data=compData;
  compression=4;
  bitPointer=0;
  bytePointer=0;
  int scanlineStride=(w + 7) / 8;
  int bufferOffset=0;
  int a0, a1, b1, b2;
  int entry, code, bits;
  byte color;
  boolean isWhite;
  int currIndex;
  int temp[];
  int[] b=new int[2];
  uncompressedMode=(int)((tiffT6Options & 0x02) >> 1);
  int[] cce=currChangingElems;
  changingElemSize=0;
  cce[changingElemSize++]=w;
  cce[changingElemSize++]=w;
  int lineOffset=0;
  int bitOffset;
  for (int lines=0; lines < height; lines++) {
    a0=-1;
    isWhite=true;
    temp=prevChangingElems;
    prevChangingElems=currChangingElems;
    cce=currChangingElems=temp;
    currIndex=0;
    bitOffset=startX;
    lastChangingElement=0;
    while (bitOffset < w) {
      getNextChangingElement(a0,isWhite,b);
      b1=b[0];
      b2=b[1];
      entry=nextLesserThan8Bits(7);
      entry=(int)(twoDCodes[entry] & 0xff);
      code=(entry & 0x78) >>> 3;
      bits=entry & 0x07;
      if (code == 0) {
        if (!isWhite) {
          setToBlack(buffer,lineOffset,bitOffset,b2 - bitOffset);
        }
        bitOffset=a0=b2;
        updatePointer(7 - bits);
      }
 else       if (code == 1) {
        updatePointer(7 - bits);
        int number;
        if (isWhite) {
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeBlackCodeWord();
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
 else {
          number=decodeBlackCodeWord();
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
        a0=bitOffset;
      }
 else       if (code <= 8) {
        a1=b1 + (code - 5);
        cce[currIndex++]=a1;
        if (!isWhite) {
          setToBlack(buffer,lineOffset,bitOffset,a1 - bitOffset);
        }
        bitOffset=a0=a1;
        isWhite=!isWhite;
        updatePointer(7 - bits);
      }
 else       if (code == 11) {
        if (nextLesserThan8Bits(3) != 7) {
          throw new Error(JaiI18N.getString(""String_Node_Str""));
        }
        int zeros=0;
        boolean exit=false;
        while (!exit) {
          while (nextLesserThan8Bits(1) != 1) {
            zeros++;
          }
          if (zeros > 5) {
            zeros=zeros - 6;
            if (!isWhite && (zeros > 0)) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            if (zeros > 0) {
              isWhite=true;
            }
            if (nextLesserThan8Bits(1) == 0) {
              if (!isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=true;
            }
 else {
              if (isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=false;
            }
            exit=true;
          }
          if (zeros == 5) {
            if (!isWhite) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            isWhite=true;
          }
 else {
            bitOffset+=zeros;
            cce[currIndex++]=bitOffset;
            setToBlack(buffer,lineOffset,bitOffset,1);
            ++bitOffset;
            isWhite=false;
          }
        }
      }
 else {
        throw new Error(JaiI18N.getString(""String_Node_Str""));
      }
    }
    if (currIndex <= w)     cce[currIndex++]=bitOffset;
    changingElemSize=currIndex;
    lineOffset+=scanlineStride;
  }
}","public synchronized void decodeT6(byte[] buffer,byte[] compData,int startX,int height,long tiffT6Options){
  this.data=compData;
  compression=4;
  bitPointer=0;
  bytePointer=0;
  int scanlineStride=(w + 7) / 8;
  int bufferOffset=0;
  int a0, a1, b1, b2;
  int entry, code, bits;
  byte color;
  boolean isWhite;
  int currIndex;
  int temp[];
  int[] b=new int[2];
  uncompressedMode=(int)((tiffT6Options & 0x02) >> 1);
  int[] cce=currChangingElems;
  changingElemSize=0;
  cce[changingElemSize++]=w;
  cce[changingElemSize++]=w;
  int lineOffset=0;
  int bitOffset;
  for (int lines=0; lines < height; lines++) {
    a0=-1;
    isWhite=true;
    temp=prevChangingElems;
    prevChangingElems=currChangingElems;
    cce=currChangingElems=temp;
    currIndex=0;
    bitOffset=startX;
    lastChangingElement=0;
    while (bitOffset < w) {
      getNextChangingElement(a0,isWhite,b);
      b1=b[0];
      b2=b[1];
      entry=nextLesserThan8Bits(7);
      entry=(int)(twoDCodes[entry] & 0xff);
      code=(entry & 0x78) >>> 3;
      bits=entry & 0x07;
      if (code == 0) {
        if (!isWhite) {
          if (b2 > w) {
            b2=w;
          }
          setToBlack(buffer,lineOffset,bitOffset,b2 - bitOffset);
        }
        bitOffset=a0=b2;
        updatePointer(7 - bits);
      }
 else       if (code == 1) {
        updatePointer(7 - bits);
        int number;
        if (isWhite) {
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeBlackCodeWord();
          if (number > w - bitOffset) {
            number=w - bitOffset;
          }
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
 else {
          number=decodeBlackCodeWord();
          if (number > w - bitOffset) {
            number=w - bitOffset;
          }
          setToBlack(buffer,lineOffset,bitOffset,number);
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
          number=decodeWhiteCodeWord();
          bitOffset+=number;
          cce[currIndex++]=bitOffset;
        }
        a0=bitOffset;
      }
 else       if (code <= 8) {
        a1=b1 + (code - 5);
        cce[currIndex++]=a1;
        if (!isWhite) {
          if (a1 > w) {
            a1=w;
          }
          setToBlack(buffer,lineOffset,bitOffset,a1 - bitOffset);
        }
        bitOffset=a0=a1;
        isWhite=!isWhite;
        updatePointer(7 - bits);
      }
 else       if (code == 11) {
        if (nextLesserThan8Bits(3) != 7) {
          throw new Error(JaiI18N.getString(""String_Node_Str""));
        }
        int zeros=0;
        boolean exit=false;
        while (!exit) {
          while (nextLesserThan8Bits(1) != 1) {
            zeros++;
          }
          if (zeros > 5) {
            zeros=zeros - 6;
            if (!isWhite && (zeros > 0)) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            if (zeros > 0) {
              isWhite=true;
            }
            if (nextLesserThan8Bits(1) == 0) {
              if (!isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=true;
            }
 else {
              if (isWhite) {
                cce[currIndex++]=bitOffset;
              }
              isWhite=false;
            }
            exit=true;
          }
          if (zeros == 5) {
            if (!isWhite) {
              cce[currIndex++]=bitOffset;
            }
            bitOffset+=zeros;
            isWhite=true;
          }
 else {
            bitOffset+=zeros;
            cce[currIndex++]=bitOffset;
            setToBlack(buffer,lineOffset,bitOffset,1);
            ++bitOffset;
            isWhite=false;
          }
        }
      }
 else {
        throw new Error(JaiI18N.getString(""String_Node_Str""));
      }
    }
    if (currIndex <= w)     cce[currIndex++]=bitOffset;
    changingElemSize=currIndex;
    lineOffset+=scanlineStride;
  }
}",0.963963963963964
154093,"/** 
 * Creates a new instance of <code>FormatOpImage</code> in the rendered layer.
 * @param args   The source image and data type
 * @param hints  Contains destination image layout.
 */
public RenderedImage create(ParameterBlock args,RenderingHints renderHints){
  RenderedImage src=args.getRenderedSource(0);
  Integer datatype=(Integer)args.getObjectParameter(0);
  int type=datatype.intValue();
  ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
  if (layout == null && type == src.getSampleModel().getDataType()) {
    return src;
  }
  if (layout == null) {
    layout=new ImageLayout(src);
  }
 else {
    layout=(ImageLayout)layout.clone();
  }
  boolean isDataTypeChange=false;
  SampleModel sampleModel=layout.getSampleModel(src);
  if (sampleModel.getDataType() != type) {
    int tileWidth=layout.getTileWidth(src);
    int tileHeight=layout.getTileHeight(src);
    int numBands=src.getSampleModel().getNumBands();
    SampleModel csm=RasterFactory.createComponentSampleModel(sampleModel,type,tileWidth,tileHeight,numBands);
    layout.setSampleModel(csm);
    isDataTypeChange=true;
  }
  ColorModel colorModel=layout.getColorModel(null);
  if (colorModel != null && !JDKWorkarounds.areCompatibleDataModels(layout.getSampleModel(src),colorModel)) {
    layout.unsetValid(ImageLayout.COLOR_MODEL_MASK);
  }
  if (layout.getSampleModel(src) == src.getSampleModel() && layout.getMinX(src) == src.getMinX() && layout.getMinY(src) == src.getMinY() && layout.getWidth(src) == src.getWidth() && layout.getHeight(src) == src.getHeight() && layout.getTileWidth(src) == src.getTileWidth() && layout.getTileHeight(src) == src.getTileHeight() && layout.getTileGridXOffset(src) == src.getTileGridXOffset() && layout.getTileGridYOffset(src) == src.getTileGridYOffset()) {
    if (layout.getColorModel(src) == src.getColorModel()) {
      return src;
    }
 else {
      RenderingHints hints=renderHints;
      if (hints != null && hints.containsKey(JAI.KEY_TILE_CACHE)) {
        hints=new RenderingHints(renderHints);
        hints.remove(JAI.KEY_TILE_CACHE);
      }
      return new NullOpImage(src,layout,hints,OpImage.OP_IO_BOUND);
    }
  }
  if (isDataTypeChange == true) {
    if (renderHints == null) {
      renderHints=new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,Boolean.TRUE);
    }
 else     if (!renderHints.containsKey(JAI.KEY_REPLACE_INDEX_COLOR_MODEL)) {
      renderHints.put(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,Boolean.TRUE);
    }
  }
  return new CopyOpImage(src,renderHints,layout);
}","/** 
 * Creates a new instance of <code>FormatOpImage</code> in the rendered layer.
 * @param args   The source image and data type
 * @param hints  Contains destination image layout.
 */
public RenderedImage create(ParameterBlock args,RenderingHints renderHints){
  RenderedImage src=args.getRenderedSource(0);
  Integer datatype=(Integer)args.getObjectParameter(0);
  int type=datatype.intValue();
  ImageLayout layout=RIFUtil.getImageLayoutHint(renderHints);
  if (layout == null && type == src.getSampleModel().getDataType()) {
    return src;
  }
  if (layout == null) {
    layout=new ImageLayout(src);
  }
 else {
    layout=(ImageLayout)layout.clone();
  }
  boolean isDataTypeChange=false;
  SampleModel sampleModel=layout.getSampleModel(src);
  if (sampleModel.getDataType() != type) {
    int tileWidth=layout.getTileWidth(src);
    int tileHeight=layout.getTileHeight(src);
    int numBands=src.getSampleModel().getNumBands();
    SampleModel csm=RasterFactory.createComponentSampleModel(sampleModel,type,tileWidth,tileHeight,numBands);
    layout.setSampleModel(csm);
    isDataTypeChange=true;
  }
  ColorModel colorModel=layout.getColorModel(null);
  if (colorModel != null && !JDKWorkarounds.areCompatibleDataModels(layout.getSampleModel(src),colorModel)) {
    layout.unsetValid(ImageLayout.COLOR_MODEL_MASK);
  }
  if (layout.getSampleModel(src) == src.getSampleModel() && layout.getMinX(src) == src.getMinX() && layout.getMinY(src) == src.getMinY() && layout.getWidth(src) == src.getWidth() && layout.getHeight(src) == src.getHeight() && layout.getTileWidth(src) == src.getTileWidth() && layout.getTileHeight(src) == src.getTileHeight() && layout.getTileGridXOffset(src) == src.getTileGridXOffset() && layout.getTileGridYOffset(src) == src.getTileGridYOffset()) {
    if (layout.getColorModel(src) == src.getColorModel()) {
      return src;
    }
 else {
      RenderingHints hints=renderHints;
      if (hints != null && hints.containsKey(JAI.KEY_TILE_CACHE)) {
        hints=new RenderingHints((Map)renderHints);
        hints.remove(JAI.KEY_TILE_CACHE);
      }
      return new NullOpImage(src,layout,hints,OpImage.OP_IO_BOUND);
    }
  }
  if (isDataTypeChange == true) {
    if (renderHints == null) {
      renderHints=new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,Boolean.TRUE);
    }
 else     if (!renderHints.containsKey(JAI.KEY_REPLACE_INDEX_COLOR_MODEL)) {
      renderHints.put(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,Boolean.TRUE);
    }
  }
  return new CopyOpImage(src,renderHints,layout);
}",0.9990104888185236
154094,"/** 
 * Merge one <code>RenderingHints</code> into another.
 * @param defaultHints The default <code>RenderingHints</code>.
 * @param hints The superseding <code>RenderingHints</code>; hints inthis mapping take precedence over any in <code>defaultHints</code>.
 */
static RenderingHints mergeRenderingHints(RenderingHints defaultHints,RenderingHints hints){
  RenderingHints mergedHints;
  if (hints == null || hints.isEmpty()) {
    mergedHints=defaultHints;
  }
 else   if (defaultHints == null || defaultHints.isEmpty()) {
    mergedHints=hints;
  }
 else {
    mergedHints=new RenderingHints(defaultHints);
    mergedHints.add(hints);
  }
  return mergedHints;
}","/** 
 * Merge one <code>RenderingHints</code> into another.
 * @param defaultHints The default <code>RenderingHints</code>.
 * @param hints The superseding <code>RenderingHints</code>; hints inthis mapping take precedence over any in <code>defaultHints</code>.
 */
static RenderingHints mergeRenderingHints(RenderingHints defaultHints,RenderingHints hints){
  RenderingHints mergedHints;
  if (hints == null || hints.isEmpty()) {
    mergedHints=defaultHints;
  }
 else   if (defaultHints == null || defaultHints.isEmpty()) {
    mergedHints=hints;
  }
 else {
    mergedHints=new RenderingHints((Map)defaultHints);
    mergedHints.add(hints);
  }
  return mergedHints;
}",0.9962602842183994
154095,"/** 
 * Creates a <code>RemoteRenderedOp</code> which represents the named operation to be performed remotely, using the source(s) and/or parameter(s) specified in the <code>ParameterBlock</code>, and applying the specified hints to the destination. This method should only be used when the final result returned is a single <code>RemoteRenderedImage</code>. <p> The supplied operation name is validated against the names of the <code>OperationDescriptor</code>s returned from the <code>getServerSupportedOperationList()</code> method. The source(s) and/or parameter(s) in the <code>ParameterBlock</code> are validated against the named operation's descriptor, both in their numbers and types. Additional restrictions placed on the sources and parameters by an individual operation are also validated by calling its <code>OperationDescriptor.validateArguments()</code> method. <p>Parameters are allowed to have a <code>null</code> input value, if that particular parameter has a default value specified in its operation's descriptor.  In this case, the default value will replace the <code>null</code> input. <p>Unspecified tailing parameters are allowed, if these parameters have default values specified in the operation's descriptor. However, if a parameter, which has a default value, is followed by one or more parameters that have no default values, this parameter must be specified in the <code>ParameterBlock</code>, even if it only has a value of code>null</code>. <p> The rendering hints associated with this instance of <code>RemoteJAI</code> are overlaid with the hints passed to this method.  That is, the set of keys will be the union of the keys from the instance's hints and the hints parameter. If the same key exists in both places, the value from the hints parameter will be used.
 * @param opName The name of the operation.
 * @param args   The source(s) and/or parameter(s) for the operation.
 * @param hints  The hints for the operation.
 * @throws IllegalArgumentException if <code>opName</code> is<code>null</code>.
 * @throws IllegalArgumentException if <code>args</code> is<code>null</code>.
 * @throws IllegalArgumentException if no<code>OperationDescriptor</code> is available from the server with the specified operation name.
 * @throws IllegalArgumentException if the<code>OperationDescriptor</code> for the specified operation name on the server does not support the ""rendered"" registry mode.
 * @throws IllegalArgumentException if the specified operation doesnot produce a <code>java.awt.image.RenderedImage</code>.
 * @throws IllegalArgumentException if the specified operation isunable to handle the sources and parameters specified in <code>args</code>.
 * @return  A <code>RemoteRenderedOp</code> that represents the namedoperation to be performed remotely, or <code>null</code> if the specified operation is in the ""immediate"" mode and the rendering of the <code>PlanarImage</code> failed.
 */
public RemoteRenderedOp create(String opName,ParameterBlock args,RenderingHints hints){
  if (opName == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (args == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  getServerSupportedOperationList();
  OperationDescriptor odesc=(OperationDescriptor)odHash.get(new CaselessStringKey(opName));
  if (odesc == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (!odesc.isModeSupported(""String_Node_Str"")) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (!RenderedImage.class.isAssignableFrom(odesc.getDestClass(""String_Node_Str""))) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  StringBuffer msg=new StringBuffer();
  args=(ParameterBlock)args.clone();
  if (!odesc.validateArguments(""String_Node_Str"",args,msg)) {
    throw new IllegalArgumentException(msg.toString());
  }
  RenderingHints mergedHints;
  if (hints == null) {
    mergedHints=renderingHints;
  }
 else   if (renderingHints.isEmpty()) {
    mergedHints=hints;
  }
 else {
    mergedHints=new RenderingHints(renderingHints);
    mergedHints.add(hints);
  }
  RemoteRenderedOp op=new RemoteRenderedOp(operationRegistry,protocolName,serverName,opName,args,mergedHints);
  if (odesc.isImmediate()) {
    PlanarImage im=null;
    im=op.getRendering();
    if (im == null) {
      return null;
    }
  }
  return op;
}","/** 
 * Creates a <code>RemoteRenderedOp</code> which represents the named operation to be performed remotely, using the source(s) and/or parameter(s) specified in the <code>ParameterBlock</code>, and applying the specified hints to the destination. This method should only be used when the final result returned is a single <code>RemoteRenderedImage</code>. <p> The supplied operation name is validated against the names of the <code>OperationDescriptor</code>s returned from the <code>getServerSupportedOperationList()</code> method. The source(s) and/or parameter(s) in the <code>ParameterBlock</code> are validated against the named operation's descriptor, both in their numbers and types. Additional restrictions placed on the sources and parameters by an individual operation are also validated by calling its <code>OperationDescriptor.validateArguments()</code> method. <p>Parameters are allowed to have a <code>null</code> input value, if that particular parameter has a default value specified in its operation's descriptor.  In this case, the default value will replace the <code>null</code> input. <p>Unspecified tailing parameters are allowed, if these parameters have default values specified in the operation's descriptor. However, if a parameter, which has a default value, is followed by one or more parameters that have no default values, this parameter must be specified in the <code>ParameterBlock</code>, even if it only has a value of code>null</code>. <p> The rendering hints associated with this instance of <code>RemoteJAI</code> are overlaid with the hints passed to this method.  That is, the set of keys will be the union of the keys from the instance's hints and the hints parameter. If the same key exists in both places, the value from the hints parameter will be used.
 * @param opName The name of the operation.
 * @param args   The source(s) and/or parameter(s) for the operation.
 * @param hints  The hints for the operation.
 * @throws IllegalArgumentException if <code>opName</code> is<code>null</code>.
 * @throws IllegalArgumentException if <code>args</code> is<code>null</code>.
 * @throws IllegalArgumentException if no<code>OperationDescriptor</code> is available from the server with the specified operation name.
 * @throws IllegalArgumentException if the<code>OperationDescriptor</code> for the specified operation name on the server does not support the ""rendered"" registry mode.
 * @throws IllegalArgumentException if the specified operation doesnot produce a <code>java.awt.image.RenderedImage</code>.
 * @throws IllegalArgumentException if the specified operation isunable to handle the sources and parameters specified in <code>args</code>.
 * @return  A <code>RemoteRenderedOp</code> that represents the namedoperation to be performed remotely, or <code>null</code> if the specified operation is in the ""immediate"" mode and the rendering of the <code>PlanarImage</code> failed.
 */
public RemoteRenderedOp create(String opName,ParameterBlock args,RenderingHints hints){
  if (opName == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (args == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  getServerSupportedOperationList();
  OperationDescriptor odesc=(OperationDescriptor)odHash.get(new CaselessStringKey(opName));
  if (odesc == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (!odesc.isModeSupported(""String_Node_Str"")) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  if (!RenderedImage.class.isAssignableFrom(odesc.getDestClass(""String_Node_Str""))) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  StringBuffer msg=new StringBuffer();
  args=(ParameterBlock)args.clone();
  if (!odesc.validateArguments(""String_Node_Str"",args,msg)) {
    throw new IllegalArgumentException(msg.toString());
  }
  RenderingHints mergedHints;
  if (hints == null) {
    mergedHints=renderingHints;
  }
 else   if (renderingHints.isEmpty()) {
    mergedHints=hints;
  }
 else {
    mergedHints=new RenderingHints((Map)renderingHints);
    mergedHints.add(hints);
  }
  RemoteRenderedOp op=new RemoteRenderedOp(operationRegistry,protocolName,serverName,opName,args,mergedHints);
  if (odesc.isImmediate()) {
    PlanarImage im=null;
    im=op.getRendering();
    if (im == null) {
      return null;
    }
  }
  return op;
}",0.9994406533169258
154096,"/** 
 * Overrides the <code>RenderableOp</code> method to return a <code>RemoteRenderedImage</code> that represents the remote rendering of this image using a given <code>RenderContext</code>.  This is the most general way to obtain a rendering of a <code>RemoteRenderableOp</code>. <p> This method does not validate sources and parameters supplied in the <code>ParameterBlock</code> against the specification of the operation this node represents.  It is the caller's responsibility to ensure that the data in the <code>ParameterBlock</code> are suitable for this operation. Otherwise, some kind of exception or error will occur. <p> <code>RemoteJAI.createRenderable()</code> is the method that does the validation.  Therefore, it is strongly recommended that all <code>RemoteRenderableOp</code>s are created using <code>RemoteJAI.createRenderable()</code>. <p> The <code>RenderContext</code> may contain a <code>Shape</code> that represents the area-of-interest (aoi).  If the aoi is specifed, it is still legal to return an image that's larger than this aoi. Therefore, by default, the aoi, if specified, is ignored at the rendering. <p> The <code>RenderingHints</code> in the <code>RenderContext</code> may contain negotiation preferences specified under the <code>KEY_NEGOTIATION_PREFERENCES</code> key. These preferences can be ignored by the rendering if it so chooses.
 * @param renderContext the RenderContext to use to produce the rendering.
 * @return a RemoteRenderedImage containing the rendered data.
 */
public RenderedImage createRendering(RenderContext renderContext){
  findRemoteCRIF();
  ParameterBlock renderedPB=(ParameterBlock)nodeSupport.getParameterBlock().clone();
  RenderContext rcIn=renderContext;
  RenderingHints nodeHints=nodeSupport.getRenderingHints();
  if (nodeHints != null) {
    RenderingHints hints=renderContext.getRenderingHints();
    RenderingHints mergedHints;
    if (hints == null) {
      mergedHints=nodeHints;
    }
 else     if (nodeHints == null || nodeHints.isEmpty()) {
      mergedHints=hints;
    }
 else {
      mergedHints=new RenderingHints(nodeHints);
      mergedHints.add(hints);
    }
    if (mergedHints != hints) {
      rcIn=new RenderContext(renderContext.getTransform(),renderContext.getAreaOfInterest(),mergedHints);
    }
  }
  Vector sources=nodeSupport.getParameterBlock().getSources();
  try {
    if (sources != null) {
      Vector renderedSources=new Vector();
      for (int i=0; i < sources.size(); i++) {
        RenderedImage rdrdImage=null;
        Object source=sources.elementAt(i);
        if (source instanceof RenderableImage) {
          RenderContext rcOut=remoteCRIF.mapRenderContext(serverName,nodeSupport.getOperationName(),i,renderContext,nodeSupport.getParameterBlock(),this);
          RenderableImage src=(RenderableImage)source;
          rdrdImage=src.createRendering(rcOut);
        }
 else         if (source instanceof RenderedOp) {
          rdrdImage=((RenderedOp)source).getRendering();
        }
 else         if (source instanceof RenderedImage) {
          rdrdImage=(RenderedImage)source;
        }
        if (rdrdImage == null) {
          return null;
        }
        renderedSources.addElement(rdrdImage);
      }
      if (renderedSources.size() > 0) {
        renderedPB.setSources(renderedSources);
      }
    }
    RenderedImage rendering=remoteCRIF.create(serverName,nodeSupport.getOperationName(),renderContext,renderedPB);
    if (rendering instanceof RenderedOp) {
      rendering=((RenderedOp)rendering).getRendering();
    }
    linkToRemoteOp=rendering;
    if (rendering != null && rendering instanceof WritablePropertySource) {
      String[] propertyNames=getPropertyNames();
      if (propertyNames != null) {
        WritablePropertySource wps=(WritablePropertySource)rendering;
        for (int j=0; j < propertyNames.length; j++) {
          String name=propertyNames[j];
          Object value=getProperty(name);
          if (value != null && value != java.awt.Image.UndefinedProperty) {
            wps.setProperty(name,value);
          }
        }
      }
    }
    return rendering;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    return null;
  }
}","/** 
 * Overrides the <code>RenderableOp</code> method to return a <code>RemoteRenderedImage</code> that represents the remote rendering of this image using a given <code>RenderContext</code>.  This is the most general way to obtain a rendering of a <code>RemoteRenderableOp</code>. <p> This method does not validate sources and parameters supplied in the <code>ParameterBlock</code> against the specification of the operation this node represents.  It is the caller's responsibility to ensure that the data in the <code>ParameterBlock</code> are suitable for this operation. Otherwise, some kind of exception or error will occur. <p> <code>RemoteJAI.createRenderable()</code> is the method that does the validation.  Therefore, it is strongly recommended that all <code>RemoteRenderableOp</code>s are created using <code>RemoteJAI.createRenderable()</code>. <p> The <code>RenderContext</code> may contain a <code>Shape</code> that represents the area-of-interest (aoi).  If the aoi is specifed, it is still legal to return an image that's larger than this aoi. Therefore, by default, the aoi, if specified, is ignored at the rendering. <p> The <code>RenderingHints</code> in the <code>RenderContext</code> may contain negotiation preferences specified under the <code>KEY_NEGOTIATION_PREFERENCES</code> key. These preferences can be ignored by the rendering if it so chooses.
 * @param renderContext the RenderContext to use to produce the rendering.
 * @return a RemoteRenderedImage containing the rendered data.
 */
public RenderedImage createRendering(RenderContext renderContext){
  findRemoteCRIF();
  ParameterBlock renderedPB=(ParameterBlock)nodeSupport.getParameterBlock().clone();
  RenderContext rcIn=renderContext;
  RenderingHints nodeHints=nodeSupport.getRenderingHints();
  if (nodeHints != null) {
    RenderingHints hints=renderContext.getRenderingHints();
    RenderingHints mergedHints;
    if (hints == null) {
      mergedHints=nodeHints;
    }
 else     if (nodeHints == null || nodeHints.isEmpty()) {
      mergedHints=hints;
    }
 else {
      mergedHints=new RenderingHints((Map)nodeHints);
      mergedHints.add(hints);
    }
    if (mergedHints != hints) {
      rcIn=new RenderContext(renderContext.getTransform(),renderContext.getAreaOfInterest(),mergedHints);
    }
  }
  Vector sources=nodeSupport.getParameterBlock().getSources();
  try {
    if (sources != null) {
      Vector renderedSources=new Vector();
      for (int i=0; i < sources.size(); i++) {
        RenderedImage rdrdImage=null;
        Object source=sources.elementAt(i);
        if (source instanceof RenderableImage) {
          RenderContext rcOut=remoteCRIF.mapRenderContext(serverName,nodeSupport.getOperationName(),i,renderContext,nodeSupport.getParameterBlock(),this);
          RenderableImage src=(RenderableImage)source;
          rdrdImage=src.createRendering(rcOut);
        }
 else         if (source instanceof RenderedOp) {
          rdrdImage=((RenderedOp)source).getRendering();
        }
 else         if (source instanceof RenderedImage) {
          rdrdImage=(RenderedImage)source;
        }
        if (rdrdImage == null) {
          return null;
        }
        renderedSources.addElement(rdrdImage);
      }
      if (renderedSources.size() > 0) {
        renderedPB.setSources(renderedSources);
      }
    }
    RenderedImage rendering=remoteCRIF.create(serverName,nodeSupport.getOperationName(),renderContext,renderedPB);
    if (rendering instanceof RenderedOp) {
      rendering=((RenderedOp)rendering).getRendering();
    }
    linkToRemoteOp=rendering;
    if (rendering != null && rendering instanceof WritablePropertySource) {
      String[] propertyNames=getPropertyNames();
      if (propertyNames != null) {
        WritablePropertySource wps=(WritablePropertySource)rendering;
        for (int j=0; j < propertyNames.length; j++) {
          String name=propertyNames[j];
          Object value=getProperty(name);
          if (value != null && value != java.awt.Image.UndefinedProperty) {
            wps.setProperty(name,value);
          }
        }
      }
    }
    return rendering;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    return null;
  }
}",0.999404123465618
154097,"protected Rectangle backwardMapRect(Rectangle destRect,int sourceIndex){
  if (destRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  int x1=sourceMinX + (int)Math.floor((destRect.x - minX) / scaleX + 0.5);
  int y1=sourceMinY + (int)Math.floor((destRect.y - minY) / scaleY + 0.5);
  int x2=x1 + (destRect.width - 1) * blockX;
  int y2=y1 + (destRect.height - 1) * blockY;
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}","protected Rectangle backwardMapRect(Rectangle destRect,int sourceIndex){
  if (destRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  Point2D p1=mapDestPoint(new Point2D.Double(destRect.x,destRect.y));
  Point2D p2=mapDestPoint(new Point2D.Double(destRect.x + destRect.width - 1,destRect.y + destRect.height - 1));
  int x1=(int)Math.floor(p1.getX());
  int y1=(int)Math.floor(p1.getY());
  int x2=(int)Math.floor(p2.getX());
  int y2=(int)Math.floor(p2.getY());
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}",0.6059654631083202
154098,"protected Rectangle forwardMapRect(Rectangle sourceRect,int sourceIndex){
  if (sourceRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  return new Rectangle(minX + (int)Math.floor((sourceRect.x - sourceMinX) * scaleX),minY + (int)Math.floor((sourceRect.y - sourceMinY) * scaleY),(int)Math.ceil(sourceRect.width * scaleX),(int)Math.ceil(sourceRect.height * scaleY));
}","protected Rectangle forwardMapRect(Rectangle sourceRect,int sourceIndex){
  if (sourceRect == null) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
 else   if (sourceIndex != 0) {
    throw new IllegalArgumentException(JaiI18N.getString(""String_Node_Str""));
  }
  Point2D p1=mapSourcePoint(new Point2D.Double(sourceRect.x,sourceRect.y));
  Point2D p2=mapSourcePoint(new Point2D.Double(sourceRect.x + sourceRect.width - 1,sourceRect.y + sourceRect.height - 1));
  int x1=(int)Math.floor(p1.getX());
  int y1=(int)Math.floor(p1.getY());
  int x2=(int)Math.floor(p2.getX());
  int y2=(int)Math.floor(p2.getY());
  return new Rectangle(x1,y1,x2 - x1 + 1,y2 - y1 + 1);
}",0.5113636363636364
154099,"public Point2D mapSourcePoint(Point2D sourcePt){
  if (sourcePt == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Point2D pt=(Point2D)sourcePt.clone();
  pt.setLocation(minX + (sourcePt.getX() - sourceMinX) * scaleX,minY + (sourcePt.getY() - sourceMinY) * scaleY);
  return pt;
}","public Point2D mapSourcePoint(Point2D sourcePt){
  if (sourcePt == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Point2D pt=(Point2D)sourcePt.clone();
  pt.setLocation(minX + (sourcePt.getX() + 0.5 - sourceMinX) * scaleX - 0.5,minY + (sourcePt.getY() + 0.5 - sourceMinY) * scaleY - 0.5);
  return pt;
}",0.9621451104100948
154100,"public Point2D mapDestPoint(Point2D destPt){
  if (destPt == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Point2D pt=(Point2D)destPt.clone();
  pt.setLocation(sourceMinX + (destPt.getX() - minX) / scaleX,sourceMinY + (destPt.getY() - minY) / scaleY);
  return pt;
}","public Point2D mapDestPoint(Point2D destPt){
  if (destPt == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Point2D pt=(Point2D)destPt.clone();
  pt.setLocation(sourceMinX + (destPt.getX() + 0.5 - minX) / scaleX - 0.5,sourceMinY + (destPt.getY() + 0.5 - minY) / scaleY - 0.5);
  return pt;
}",0.960655737704918
154101,"/** 
 * Computes a tile.  A new <code>WritableRaster</code> is created to represent the requested tile.  Its width and height are equal to this image's tile width and tile height respectively.  If the requested tile lies outside of the image's boundary, or if the backward mapped and padded tile region does not intersect all sources, the created raster is returned with all of its pixels set to 0. <p> Whether or not this method performs source cobbling is determined by the <code>cobbleSources</code> variable set at construction time. If <code>cobbleSources</code> is <code>true</code>, cobbling is performed on the source for areas that intersect multiple tiles, and <code>computeRect(Raster[], WritableRaster, Rectangle)</code> is called to perform the actual computation.  Otherwise, <code>computeRect(PlanarImage[], WritableRaster, Rectangle)</code> is called to perform the actual computation.
 * @param tileX The X index of the tile.
 * @param tileY The Y index of the tile.
 * @return The tile as a <code>Raster</code>.
 */
public Raster computeTile(int tileX,int tileY){
  Point org=new Point(tileXToX(tileX),tileYToY(tileY));
  WritableRaster dest=createWritableRaster(sampleModel,org);
  Rectangle destRect=getTileRect(tileX,tileY).intersection(getBounds());
  if (destRect.isEmpty()) {
    if (setBackground) {
      ImageUtil.fillBackground(dest,destRect,backgroundValues);
    }
    return dest;
  }
  int numSources=getNumSources();
  if (cobbleSources) {
    Raster[] rasterSources=new Raster[numSources];
    for (int i=0; i < numSources; i++) {
      PlanarImage source=getSource(i);
      Rectangle srcRect=mapDestRect(destRect,i);
      if (srcRect == null) {
        srcRect=source.getBounds();
      }
 else       if (!srcRect.intersects(source.getBounds())) {
        if (setBackground) {
          ImageUtil.fillBackground(dest,destRect,backgroundValues);
        }
        return dest;
      }
      rasterSources[i]=extender != null ? source.getExtendedData(srcRect,extender) : source.getData(srcRect);
    }
    computeRect(rasterSources,dest,destRect);
    for (int i=0; i < numSources; i++) {
      Raster sourceData=rasterSources[i];
      if (sourceData != null) {
        PlanarImage source=getSourceImage(i);
        if (source.overlapsMultipleTiles(sourceData.getBounds())) {
          recycleTile(sourceData);
        }
      }
    }
  }
 else {
    PlanarImage[] imageSources=new PlanarImage[numSources];
    for (int i=0; i < numSources; i++) {
      imageSources[i]=getSource(i);
    }
    computeRect(imageSources,dest,destRect);
  }
  return dest;
}","/** 
 * Computes a tile.  A new <code>WritableRaster</code> is created to represent the requested tile.  Its width and height are equal to this image's tile width and tile height respectively.  If the requested tile lies outside of the image's boundary, or if the backward mapped and padded tile region does not intersect all sources, the created raster is returned with all of its pixels set to 0. <p> Whether or not this method performs source cobbling is determined by the <code>cobbleSources</code> variable set at construction time. If <code>cobbleSources</code> is <code>true</code>, cobbling is performed on the source for areas that intersect multiple tiles, and <code>computeRect(Raster[], WritableRaster, Rectangle)</code> is called to perform the actual computation.  Otherwise, <code>computeRect(PlanarImage[], WritableRaster, Rectangle)</code> is called to perform the actual computation.
 * @param tileX The X index of the tile.
 * @param tileY The Y index of the tile.
 * @return The tile as a <code>Raster</code>.
 */
public Raster computeTile(int tileX,int tileY){
  Point org=new Point(tileXToX(tileX),tileYToY(tileY));
  WritableRaster dest=createWritableRaster(sampleModel,org);
  Rectangle destRect=getTileRect(tileX,tileY).intersection(getBounds());
  if (destRect.isEmpty()) {
    if (setBackground) {
      ImageUtil.fillBackground(dest,destRect,backgroundValues);
    }
    return dest;
  }
  int numSources=getNumSources();
  if (cobbleSources) {
    Raster[] rasterSources=new Raster[numSources];
    for (int i=0; i < numSources; i++) {
      PlanarImage source=getSource(i);
      Rectangle srcBounds=source.getBounds();
      Rectangle srcRect=mapDestRect(destRect,i);
      if (srcRect == null) {
        srcRect=srcBounds;
      }
 else {
        if (extender == null && !srcBounds.contains(srcRect)) {
          srcRect=srcBounds.intersection(srcRect);
        }
        if (!srcRect.intersects(srcBounds)) {
          if (setBackground) {
            ImageUtil.fillBackground(dest,destRect,backgroundValues);
          }
          return dest;
        }
      }
      rasterSources[i]=extender != null ? source.getExtendedData(srcRect,extender) : source.getData(srcRect);
    }
    computeRect(rasterSources,dest,destRect);
    for (int i=0; i < numSources; i++) {
      Raster sourceData=rasterSources[i];
      if (sourceData != null) {
        PlanarImage source=getSourceImage(i);
        if (source.overlapsMultipleTiles(sourceData.getBounds())) {
          recycleTile(sourceData);
        }
      }
    }
  }
 else {
    PlanarImage[] imageSources=new PlanarImage[numSources];
    for (int i=0; i < numSources; i++) {
      imageSources[i]=getSource(i);
    }
    computeRect(imageSources,dest,destRect);
  }
  return dest;
}",0.9527720739219712
154102,"private byte[] decodePackbits(byte data[],int arraySize,byte[] dst){
  if (dst == null) {
    dst=new byte[arraySize];
  }
  int srcCount=0, dstCount=0;
  byte repeat, b;
  try {
    while (dstCount < arraySize) {
      b=data[srcCount++];
      if (b >= 0 && b <= 127) {
        for (int i=0; i < (b + 1); i++) {
          dst[dstCount++]=data[srcCount++];
        }
      }
 else       if (b <= -1 && b >= -127) {
        repeat=data[srcCount++];
        for (int i=0; i < (-b + 1); i++) {
          dst[dstCount++]=repeat;
        }
      }
 else {
        srcCount++;
      }
    }
  }
 catch (  java.lang.ArrayIndexOutOfBoundsException ae) {
    String message=JaiI18N.getString(""String_Node_Str"");
    ImagingListenerProxy.errorOccurred(message,new ImagingException(message,ae),this,false);
  }
  return dst;
}","private byte[] decodePackbits(byte data[],int arraySize,byte[] dst){
  if (dst == null) {
    dst=new byte[arraySize];
  }
  int srcCount=0, dstCount=0;
  int srcArraySize=data.length;
  byte repeat, b;
  try {
    while (dstCount < arraySize && srcCount < srcArraySize) {
      b=data[srcCount++];
      if (b >= 0 && b <= 127) {
        for (int i=0; i < (b + 1); i++) {
          dst[dstCount++]=data[srcCount++];
        }
      }
 else       if (b <= -1 && b >= -127) {
        repeat=data[srcCount++];
        for (int i=0; i < (-b + 1); i++) {
          dst[dstCount++]=repeat;
        }
      }
 else {
        srcCount++;
      }
    }
  }
 catch (  java.lang.ArrayIndexOutOfBoundsException ae) {
    String message=JaiI18N.getString(""String_Node_Str"");
    ImagingListenerProxy.errorOccurred(message,new ImagingException(message,ae),this,false);
  }
  return dst;
}",0.965109402720284
154103,"/** 
 * Creates a new instance of <code>MlibConvolveOpImage</code> in the rendered image mode.
 * @param args  The source image and convolution kernel.
 * @param hints  May contain rendering hints and destination image layout.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(hints);
  if (!MediaLibAccessor.isMediaLibCompatible(args,layout) || !MediaLibAccessor.hasSameNumBands(args,layout)) {
    return null;
  }
  BorderExtender extender=RIFUtil.getBorderExtenderHint(hints);
  RenderedImage source=args.getRenderedSource(0);
  KernelJAI unRotatedKernel=(KernelJAI)args.getObjectParameter(0);
  KernelJAI kJAI=unRotatedKernel.getRotatedKernel();
  int kWidth=kJAI.getWidth();
  int kHeight=kJAI.getHeight();
  if (kWidth < 2 || kHeight < 2) {
    return null;
  }
  boolean centered=(kWidth == kJAI.getXOrigin() * 2 + 1) && (kHeight == kJAI.getYOrigin() * 2 + 1);
  if (kJAI.isSeparable() && kWidth >= 3 && kWidth <= 7 && kWidth == kHeight) {
    return new MlibSeparableConvolveOpImage(source,extender,hints,layout,kJAI);
  }
 else   if ((kWidth == 3 && kHeight == 3) || (kWidth == 5 && kHeight == 5)) {
    return new MlibConvolve3x3Or5x5OpImage(source,extender,hints,layout,kJAI);
  }
 else {
    return new MlibConvolveOpImage(source,extender,hints,layout,kJAI);
  }
}","/** 
 * Creates a new instance of <code>MlibConvolveOpImage</code> in the rendered image mode.
 * @param args  The source image and convolution kernel.
 * @param hints  May contain rendering hints and destination image layout.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(hints);
  if (!MediaLibAccessor.isMediaLibCompatible(args,layout) || !MediaLibAccessor.hasSameNumBands(args,layout)) {
    return null;
  }
  BorderExtender extender=RIFUtil.getBorderExtenderHint(hints);
  RenderedImage source=args.getRenderedSource(0);
  KernelJAI unRotatedKernel=(KernelJAI)args.getObjectParameter(0);
  KernelJAI kJAI=unRotatedKernel.getRotatedKernel();
  int kWidth=kJAI.getWidth();
  int kHeight=kJAI.getHeight();
  if (kWidth < 2 || kHeight < 2) {
    return null;
  }
  if (kJAI.isSeparable() && (kWidth == kHeight) && (kWidth == 3 || kWidth == 5 || kWidth == 7)) {
    return new MlibSeparableConvolveOpImage(source,extender,hints,layout,kJAI);
  }
 else   if ((kWidth == kHeight) && (kWidth == 2 || kWidth == 3 || kWidth == 4 || kWidth == 5 || kWidth == 7)) {
    return new MlibConvolveNxNOpImage(source,extender,hints,layout,kJAI);
  }
 else {
    return new MlibConvolveOpImage(source,extender,hints,layout,kJAI);
  }
}",0.7016616314199395
154104,"/** 
 * Creates a new instance of <code>MlibConvolveOpImage</code> in the rendered image mode.
 * @param args  The source image and convolution kernel.
 * @param hints  May contain rendering hints and destination image layout.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(hints);
  if (!MediaLibAccessor.isMediaLibCompatible(args,layout) || !MediaLibAccessor.hasSameNumBands(args,layout)) {
    return null;
  }
  BorderExtender extender=RIFUtil.getBorderExtenderHint(hints);
  RenderedImage source=args.getRenderedSource(0);
  KernelJAI unRotatedKernel=ImageUtil.getUnsharpMaskEquivalentKernel((KernelJAI)args.getObjectParameter(0),args.getFloatParameter(1));
  KernelJAI kJAI=unRotatedKernel.getRotatedKernel();
  int kWidth=kJAI.getWidth();
  int kHeight=kJAI.getHeight();
  if (kWidth < 2 || kHeight < 2) {
    return null;
  }
  if (kJAI.isSeparable() && kWidth >= 3 && kWidth <= 7 && kWidth == kHeight) {
    return new MlibSeparableConvolveOpImage(source,extender,hints,layout,kJAI);
  }
 else   if ((kWidth == 3 && kHeight == 3) || (kWidth == 5 && kHeight == 5)) {
    return new MlibConvolve3x3Or5x5OpImage(source,extender,hints,layout,kJAI);
  }
 else {
    return new MlibConvolveOpImage(source,extender,hints,layout,kJAI);
  }
}","/** 
 * Creates a new instance of <code>MlibConvolveOpImage</code> in the rendered image mode.
 * @param args  The source image and convolution kernel.
 * @param hints  May contain rendering hints and destination image layout.
 */
public RenderedImage create(ParameterBlock args,RenderingHints hints){
  ImageLayout layout=RIFUtil.getImageLayoutHint(hints);
  if (!MediaLibAccessor.isMediaLibCompatible(args,layout) || !MediaLibAccessor.hasSameNumBands(args,layout)) {
    return null;
  }
  BorderExtender extender=RIFUtil.getBorderExtenderHint(hints);
  RenderedImage source=args.getRenderedSource(0);
  KernelJAI unRotatedKernel=ImageUtil.getUnsharpMaskEquivalentKernel((KernelJAI)args.getObjectParameter(0),args.getFloatParameter(1));
  KernelJAI kJAI=unRotatedKernel.getRotatedKernel();
  int kWidth=kJAI.getWidth();
  int kHeight=kJAI.getHeight();
  if (kWidth < 2 || kHeight < 2) {
    return null;
  }
  if (kJAI.isSeparable() && kWidth >= 3 && kWidth <= 7 && kWidth == kHeight) {
    return new MlibSeparableConvolveOpImage(source,extender,hints,layout,kJAI);
  }
 else   if ((kWidth == 3 && kHeight == 3) || (kWidth == 5 && kHeight == 5)) {
    return new MlibConvolveNxNOpImage(source,extender,hints,layout,kJAI);
  }
 else {
    return new MlibConvolveOpImage(source,extender,hints,layout,kJAI);
  }
}",0.9965792474344356
154105,"/** 
 * Encodes a RenderedImage and writes the output to the OutputStream associated with this ImageEncoder.
 */
public void encode(RenderedImage im) throws IOException {
  SampleModel sampleModel=im.getSampleModel();
  ColorModel colorModel=im.getColorModel();
  int numBands=colorModel.getNumColorComponents();
  int transType=sampleModel.getTransferType();
  if (((transType != DataBuffer.TYPE_BYTE) && !CodecUtils.isPackedByteImage(im)) || ((numBands != 1) && (numBands != 3))) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int cspaceType=colorModel.getColorSpace().getType();
  if (cspaceType != ColorSpace.TYPE_GRAY && cspaceType != ColorSpace.TYPE_RGB) {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  BufferedImage bi;
  if (im instanceof BufferedImage) {
    bi=(BufferedImage)im;
  }
 else {
    Raster ras;
    if (im.getNumXTiles() == 1 && im.getNumYTiles() == 1) {
      ras=im.getTile(im.getMinTileX(),im.getMinTileY());
    }
 else {
      ras=im.getData();
    }
    WritableRaster wRas;
    if (ras instanceof WritableRaster) {
      wRas=(WritableRaster)ras;
    }
 else {
      wRas=Raster.createWritableRaster(ras.getSampleModel(),ras.getDataBuffer(),new Point(ras.getSampleModelTranslateX(),ras.getSampleModelTranslateY()));
    }
    if (wRas.getMinX() != 0 || wRas.getMinY() != 0 || wRas.getWidth() != im.getWidth() || wRas.getHeight() != im.getHeight())     wRas=wRas.createWritableChild(wRas.getMinX(),wRas.getMinY(),im.getWidth(),im.getHeight(),0,0,null);
    bi=new BufferedImage(colorModel,wRas,false,null);
  }
  if (colorModel instanceof IndexColorModel) {
    IndexColorModel icm=(IndexColorModel)colorModel;
    bi=icm.convertToIntDiscrete(bi.getRaster(),false);
  }
  com.sun.image.codec.jpeg.JPEGEncodeParam j2dEP=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(bi);
  if (jaiEP != null) {
    modifyEncodeParam(jaiEP,j2dEP,numBands);
  }
  com.sun.image.codec.jpeg.JPEGImageEncoder encoder;
  encoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(output,j2dEP);
  try {
    encoder.encode(bi);
  }
 catch (  IOException e) {
    String message=JaiI18N.getString(""String_Node_Str"");
    ImagingListenerProxy.errorOccurred(message,new ImagingException(message,e),this,false);
  }
}","/** 
 * Encodes a RenderedImage and writes the output to the OutputStream associated with this ImageEncoder.
 */
public void encode(RenderedImage im) throws IOException {
  SampleModel sampleModel=im.getSampleModel();
  ColorModel colorModel=im.getColorModel();
  int numBands=colorModel.getNumColorComponents();
  int transType=sampleModel.getTransferType();
  if (((transType != DataBuffer.TYPE_BYTE) && !CodecUtils.isPackedByteImage(im)) || ((numBands != 1) && (numBands != 3))) {
    throw new RuntimeException(JaiI18N.getString(""String_Node_Str""));
  }
  int cspaceType=colorModel.getColorSpace().getType();
  if (cspaceType != ColorSpace.TYPE_GRAY && cspaceType != ColorSpace.TYPE_RGB) {
    throw new Error(JaiI18N.getString(""String_Node_Str""));
  }
  BufferedImage bi;
  if (im instanceof BufferedImage) {
    bi=(BufferedImage)im;
  }
 else {
    Raster ras;
    if (im.getNumXTiles() == 1 && im.getNumYTiles() == 1) {
      ras=im.getTile(im.getMinTileX(),im.getMinTileY());
    }
 else {
      ras=im.getData();
    }
    WritableRaster wRas;
    if (ras instanceof WritableRaster) {
      wRas=(WritableRaster)ras;
    }
 else {
      wRas=Raster.createWritableRaster(ras.getSampleModel(),ras.getDataBuffer(),new Point(ras.getSampleModelTranslateX(),ras.getSampleModelTranslateY()));
    }
    if (wRas.getMinX() != 0 || wRas.getMinY() != 0 || wRas.getWidth() != im.getWidth() || wRas.getHeight() != im.getHeight())     wRas=wRas.createWritableChild(wRas.getMinX(),wRas.getMinY(),im.getWidth(),im.getHeight(),0,0,null);
    bi=new BufferedImage(colorModel,wRas,false,null);
  }
  if (colorModel instanceof IndexColorModel) {
    IndexColorModel icm=(IndexColorModel)colorModel;
    bi=icm.convertToIntDiscrete(bi.getRaster(),false);
    if (bi.getSampleModel().getNumBands() == 4) {
      WritableRaster rgbaRas=bi.getRaster();
      WritableRaster rgbRas=rgbaRas.createWritableChild(0,0,bi.getWidth(),bi.getHeight(),0,0,new int[]{0,1,2});
      PackedColorModel pcm=(PackedColorModel)bi.getColorModel();
      int bits=pcm.getComponentSize(0) + pcm.getComponentSize(1) + pcm.getComponentSize(2);
      DirectColorModel dcm=new DirectColorModel(bits,pcm.getMask(0),pcm.getMask(1),pcm.getMask(2));
      bi=new BufferedImage(dcm,rgbRas,false,null);
    }
  }
  com.sun.image.codec.jpeg.JPEGEncodeParam j2dEP=com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(bi);
  if (jaiEP != null) {
    modifyEncodeParam(jaiEP,j2dEP,numBands);
  }
  com.sun.image.codec.jpeg.JPEGImageEncoder encoder;
  encoder=com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(output,j2dEP);
  try {
    encoder.encode(bi);
  }
 catch (  IOException e) {
    String message=JaiI18N.getString(""String_Node_Str"");
    ImagingListenerProxy.errorOccurred(message,new ImagingException(message,e),this,false);
  }
}",0.8976223226567106
154106,"/** 
 * Returns one of the available statistics as a property. 
 */
public Object getProperty(String name){
  int numBands=sampleModel.getNumBands();
  if (""String_Node_Str"".equals(name)) {
    if (colorMap == null)     train();
    return colorMap;
  }
  return super.getProperty(name);
}","/** 
 * Returns one of the available statistics as a property. 
 */
public Object getProperty(String name){
  int numBands=sampleModel.getNumBands();
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    if (colorMap == null)     train();
    return colorMap;
  }
  return super.getProperty(name);
}",0.931372549019608
154107,"protected synchronized void train(){
  PlanarImage source=getSourceImage(0);
  if (roi == null)   roi=new ROIShape(source.getBounds());
  int minTileX=source.getMinTileX();
  int maxTileX=source.getMaxTileX();
  int minTileY=source.getMinTileY();
  int maxTileY=source.getMaxTileY();
  int xStart=source.getMinX();
  int yStart=source.getMinY();
  histogram=new HistogramHash(histogramSize);
  while (true) {
    histogram.init();
    int oldbits=bits;
    mask=(255 << 8 - bits) & 255;
    mask=mask | (mask << 8) | (mask << 16);
    for (int y=minTileY; y <= maxTileY; y++) {
      for (int x=minTileX; x <= maxTileX; x++) {
        Rectangle tileRect=source.getTileRect(x,y);
        if (roi.intersects(tileRect)) {
          if (checkForSkippedTiles && tileRect.x >= xStart && tileRect.y >= yStart) {
            int offsetX=(xPeriod - ((tileRect.x - xStart) % xPeriod)) % xPeriod;
            int offsetY=(yPeriod - ((tileRect.y - yStart) % yPeriod)) % yPeriod;
            if (offsetX >= tileRect.width || offsetY >= tileRect.height) {
              continue;
            }
          }
          computeHistogram(source.getData(tileRect));
          if (histogram.isFull())           break;
        }
      }
      if (histogram.isFull())       break;
    }
    if (oldbits == bits) {
      counts=histogram.getCounts();
      colors=histogram.getColors();
      break;
    }
  }
  medianCut(maxColorNum);
  setProperty(""String_Node_Str"",colorMap);
}","protected synchronized void train(){
  PlanarImage source=getSourceImage(0);
  if (roi == null)   roi=new ROIShape(source.getBounds());
  int minTileX=source.getMinTileX();
  int maxTileX=source.getMaxTileX();
  int minTileY=source.getMinTileY();
  int maxTileY=source.getMaxTileY();
  int xStart=source.getMinX();
  int yStart=source.getMinY();
  histogram=new HistogramHash(histogramSize);
  while (true) {
    histogram.init();
    int oldbits=bits;
    mask=(255 << 8 - bits) & 255;
    mask=mask | (mask << 8) | (mask << 16);
    for (int y=minTileY; y <= maxTileY; y++) {
      for (int x=minTileX; x <= maxTileX; x++) {
        Rectangle tileRect=source.getTileRect(x,y);
        if (roi.intersects(tileRect)) {
          if (checkForSkippedTiles && tileRect.x >= xStart && tileRect.y >= yStart) {
            int offsetX=(xPeriod - ((tileRect.x - xStart) % xPeriod)) % xPeriod;
            int offsetY=(yPeriod - ((tileRect.y - yStart) % yPeriod)) % yPeriod;
            if (offsetX >= tileRect.width || offsetY >= tileRect.height) {
              continue;
            }
          }
          computeHistogram(source.getData(tileRect));
          if (histogram.isFull())           break;
        }
      }
      if (histogram.isFull())       break;
    }
    if (oldbits == bits) {
      counts=histogram.getCounts();
      colors=histogram.getColors();
      break;
    }
  }
  medianCut(maxColorNum);
  setProperty(""String_Node_Str"",colorMap);
  setProperty(""String_Node_Str"",colorMap);
}",0.9854483925549916
154108,"protected synchronized void train(){
  network=new int[maxColorNum][];
  for (int i=0; i < maxColorNum; i++) {
    network[i]=new int[4];
    int[] p=network[i];
    p[0]=p[1]=p[2]=(i << (netbiasshift + 8)) / maxColorNum;
    freq[i]=intbias / maxColorNum;
    bias[i]=0;
  }
  PlanarImage source=getSourceImage(0);
  Rectangle rect=source.getBounds();
  if (roi != null)   rect=roi.getBounds();
  RandomIter iterator=RandomIterFactory.create(source,rect);
  int samplefac=xPeriod * yPeriod;
  int startX=rect.x / xPeriod;
  int startY=rect.y / yPeriod;
  int offsetX=rect.x % xPeriod;
  int offsetY=rect.y % yPeriod;
  int pixelsPerLine=(rect.width - 1) / xPeriod + 1;
  int numSamples=pixelsPerLine * ((rect.height - 1) / yPeriod + 1);
  if (numSamples < minpicturebytes)   samplefac=1;
  alphadec=30 + ((samplefac - 1) / 3);
  int pix=0;
  int delta=numSamples / ncycles;
  int alpha=initalpha;
  int radius=initradius;
  int rad=radius >> radiusbiasshift;
  if (rad <= 1)   rad=0;
  for (int i=0; i < rad; i++)   radpower[i]=alpha * (((rad * rad - i * i) * radbias) / (rad * rad));
  int step;
  if (numSamples < minpicturebytes)   step=3;
 else   if ((numSamples % prime1) != 0)   step=3 * prime1;
 else {
    if ((numSamples % prime2) != 0)     step=3 * prime2;
 else {
      if ((numSamples % prime3) != 0)       step=3 * prime3;
 else       step=3 * prime4;
    }
  }
  int[] pixel=new int[3];
  for (int i=0; i < numSamples; ) {
    int y=(pix / pixelsPerLine + startY) * yPeriod + offsetY;
    int x=(pix % pixelsPerLine + startX) * xPeriod + offsetX;
    try {
      iterator.getPixel(x,y,pixel);
    }
 catch (    Exception e) {
      continue;
    }
    int b=pixel[2] << netbiasshift;
    int g=pixel[1] << netbiasshift;
    int r=pixel[0] << netbiasshift;
    int j=contest(b,g,r);
    altersingle(alpha,j,b,g,r);
    if (rad != 0)     alterneigh(rad,j,b,g,r);
    pix+=step;
    if (pix >= numSamples)     pix-=numSamples;
    i++;
    if (i % delta == 0) {
      alpha-=alpha / alphadec;
      radius-=radius / radiusdec;
      rad=radius >> radiusbiasshift;
      if (rad <= 1)       rad=0;
      for (j=0; j < rad; j++)       radpower[j]=alpha * (((rad * rad - j * j) * radbias) / (rad * rad));
    }
  }
  unbiasnet();
  inxbuild();
  createLUT();
  setProperty(""String_Node_Str"",colorMap);
}","protected synchronized void train(){
  network=new int[maxColorNum][];
  for (int i=0; i < maxColorNum; i++) {
    network[i]=new int[4];
    int[] p=network[i];
    p[0]=p[1]=p[2]=(i << (netbiasshift + 8)) / maxColorNum;
    freq[i]=intbias / maxColorNum;
    bias[i]=0;
  }
  PlanarImage source=getSourceImage(0);
  Rectangle rect=source.getBounds();
  if (roi != null)   rect=roi.getBounds();
  RandomIter iterator=RandomIterFactory.create(source,rect);
  int samplefac=xPeriod * yPeriod;
  int startX=rect.x / xPeriod;
  int startY=rect.y / yPeriod;
  int offsetX=rect.x % xPeriod;
  int offsetY=rect.y % yPeriod;
  int pixelsPerLine=(rect.width - 1) / xPeriod + 1;
  int numSamples=pixelsPerLine * ((rect.height - 1) / yPeriod + 1);
  if (numSamples < minpicturebytes)   samplefac=1;
  alphadec=30 + ((samplefac - 1) / 3);
  int pix=0;
  int delta=numSamples / ncycles;
  int alpha=initalpha;
  int radius=initradius;
  int rad=radius >> radiusbiasshift;
  if (rad <= 1)   rad=0;
  for (int i=0; i < rad; i++)   radpower[i]=alpha * (((rad * rad - i * i) * radbias) / (rad * rad));
  int step;
  if (numSamples < minpicturebytes)   step=3;
 else   if ((numSamples % prime1) != 0)   step=3 * prime1;
 else {
    if ((numSamples % prime2) != 0)     step=3 * prime2;
 else {
      if ((numSamples % prime3) != 0)       step=3 * prime3;
 else       step=3 * prime4;
    }
  }
  int[] pixel=new int[3];
  for (int i=0; i < numSamples; ) {
    int y=(pix / pixelsPerLine + startY) * yPeriod + offsetY;
    int x=(pix % pixelsPerLine + startX) * xPeriod + offsetX;
    try {
      iterator.getPixel(x,y,pixel);
    }
 catch (    Exception e) {
      continue;
    }
    int b=pixel[2] << netbiasshift;
    int g=pixel[1] << netbiasshift;
    int r=pixel[0] << netbiasshift;
    int j=contest(b,g,r);
    altersingle(alpha,j,b,g,r);
    if (rad != 0)     alterneigh(rad,j,b,g,r);
    pix+=step;
    if (pix >= numSamples)     pix-=numSamples;
    i++;
    if (i % delta == 0) {
      alpha-=alpha / alphadec;
      radius-=radius / radiusdec;
      rad=radius >> radiusbiasshift;
      if (rad <= 1)       rad=0;
      for (j=0; j < rad; j++)       radpower[j]=alpha * (((rad * rad - j * j) * radbias) / (rad * rad));
    }
  }
  unbiasnet();
  inxbuild();
  createLUT();
  setProperty(""String_Node_Str"",colorMap);
  setProperty(""String_Node_Str"",colorMap);
}",0.9907863724019712
154109,"protected synchronized void train(){
  Cube cube=new Cube(getSourceImage(0),maxColorNum);
  cube.constructTree();
  cube.reduction();
  cube.assignment();
  colorMap=new LookupTableJAI(cube.colormap);
  setProperty(""String_Node_Str"",colorMap);
}","protected synchronized void train(){
  Cube cube=new Cube(getSourceImage(0),maxColorNum);
  cube.constructTree();
  cube.reduction();
  cube.assignment();
  colorMap=new LookupTableJAI(cube.colormap);
  setProperty(""String_Node_Str"",colorMap);
  setProperty(""String_Node_Str"",colorMap);
}",0.9193245778611632
154110,public double getX();,public int getX();,0.7692307692307693
154111,public void setY(double y);,public void setY(int y);,0.8235294117647058
154112,public double getY();,public int getY();,0.7692307692307693
154113,public void setX(double x);,public void setX(int x);,0.8235294117647058
154114,"/** 
 * Set the value of y
 * @param y new value of y
 */
@Override public void setY(double y){
  double oldY=this.y;
  this.y=y;
  this.firePropertyChange(PROP_Y,oldY,y);
}","/** 
 * Set the value of y
 * @param y new value of y
 */
@Override public void setY(int y){
  double oldY=this.y;
  this.y=y;
  this.firePropertyChange(PROP_Y,oldY,y);
}",0.9737609329446064
154115,"/** 
 * Get the value of x
 * @return the value of x
 */
@Override public double getX(){
  return x;
}","/** 
 * Get the value of x
 * @return the value of x
 */
@Override public int getX(){
  return x;
}",0.9552238805970148
154116,"/** 
 * Get the value of y
 * @return the value of y
 */
@Override public double getY(){
  return y;
}","/** 
 * Get the value of y
 * @return the value of y
 */
@Override public int getY(){
  return y;
}",0.9552238805970148
154117,"/** 
 * Set the value of x
 */
@Override public void setX(double x){
  double oldX=this.x;
  this.x=x;
  this.firePropertyChange(PROP_X,oldX,x);
}","/** 
 * Set the value of x
 */
@Override public void setX(int x){
  double oldX=this.x;
  this.x=x;
  this.firePropertyChange(PROP_X,oldX,x);
}",0.9688581314878892
154118,"private void addGraphElementsFromTransferable(Transferable transferable,Point point){
  Node[] nodes=NodeTransfer.nodes(transferable,NodeTransfer.DND_COPY_OR_MOVE);
  for (  Node node : nodes) {
    GraphElementType type=node.getLookup().lookup(GraphElementType.class);
    GraphElementFactory factory=Lookup.getDefault().lookup(GraphElementFactory.class);
    GraphElement elem=factory.createGraphElement(type);
    elem.setX(point.getX());
    elem.setY(point.getY());
    version.add(elem);
  }
}","private void addGraphElementsFromTransferable(Transferable transferable,Point point){
  Node[] nodes=NodeTransfer.nodes(transferable,NodeTransfer.DND_COPY_OR_MOVE);
  for (  Node node : nodes) {
    GraphElementType type=node.getLookup().lookup(GraphElementType.class);
    GraphElementFactory factory=Lookup.getDefault().lookup(GraphElementFactory.class);
    GraphElement elem=factory.createGraphElement(type);
    elem.setX(point.x);
    elem.setY(point.y);
    version.add(elem);
  }
}",0.98582995951417
154119,"public void setVersion(CowGraphVersion version){
  this.version=version;
  this.version.addPropertyChangeListener(this);
}","public void setVersion(CowGraphVersion version){
  unsubscribeFromVersionChanges();
  this.version=version;
  subscribeToVersionChanges();
}",0.7175572519083969
154120,"@Override protected Widget attachNodeWidget(GraphElement node){
  Widget widget=GraphElementWidgetFactory.createWidget(this,node);
  mainLayer.addChild(widget);
  return widget;
}","@Override protected Widget attachNodeWidget(GraphElement node){
  Widget widget=WidgetFactory.createWidget(this,node);
  mainLayer.addChild(widget);
  return widget;
}",0.9653179190751444
154121,"public CircleWidget(Scene scene,Circle element){
  super(scene);
  this.element=element;
  setBorder(BorderFactory.createEmptyBorder());
  getActions().addAction(ActionFactory.createResizeAction(new CircleResizeStrategy(),null));
  getActions().addAction(ActionFactory.createMoveAction());
  getActions().addAction(ActionFactory.createSelectAction(new SelectProvider(){
    @Override public boolean isAimingAllowed(    Widget widget,    Point localLocation,    boolean invertSelection){
      return true;
    }
    @Override public boolean isSelectionAllowed(    Widget widget,    Point localLocation,    boolean invertSelection){
      return true;
    }
    @Override public void select(    Widget widget,    Point localLocation,    boolean invertSelection){
      if (invertSelection) {
        setBorder(BorderFactory.createEmptyBorder());
      }
 else {
        setBorder(BorderFactory.createLineBorder(2));
      }
    }
  }
));
  WidgetAction hoverAction=ActionFactory.createHoverAction(new TwoStateHoverProvider(){
    @Override public void unsetHovering(    Widget widget){
      setBorder(BorderFactory.createEmptyBorder());
    }
    @Override public void setHovering(    Widget widget){
      setBorder(BorderFactory.createResizeBorder(BOUNDS_INSET - 1,Color.BLACK,false));
    }
  }
);
  getActions().addAction(hoverAction);
  getScene().getActions().addAction(hoverAction);
  dependency=new GraphElementWidgetDependency(this,element);
  dependency.updateWidget();
  addDependency(dependency);
}","public CircleWidget(Scene scene,Circle element){
  super(scene);
  this.element=element;
  setBorder(BorderFactory.createEmptyBorder());
  getActions().addAction(ActionFactory.createResizeAction(new CircleResizeStrategy(),null));
  getActions().addAction(ActionFactory.createMoveAction());
  getActions().addAction(ActionFactory.createSelectAction(new SelectProvider(){
    @Override public boolean isAimingAllowed(    Widget widget,    Point localLocation,    boolean invertSelection){
      return true;
    }
    @Override public boolean isSelectionAllowed(    Widget widget,    Point localLocation,    boolean invertSelection){
      return true;
    }
    @Override public void select(    Widget widget,    Point localLocation,    boolean invertSelection){
      if (invertSelection) {
        setBorder(BorderFactory.createEmptyBorder());
      }
 else {
        setBorder(BorderFactory.createLineBorder(2));
      }
    }
  }
));
  WidgetAction hoverAction=ActionFactory.createHoverAction(new TwoStateHoverProvider(){
    @Override public void unsetHovering(    Widget widget){
      setBorder(BorderFactory.createEmptyBorder());
    }
    @Override public void setHovering(    Widget widget){
      setBorder(BorderFactory.createResizeBorder(BOUNDS_INSET - 1,Color.BLACK,false));
    }
  }
);
  getActions().addAction(hoverAction);
  getScene().getActions().addAction(hoverAction);
  dependency=new CircleDependency(this,element);
  dependency.updateWidget();
  addDependency(dependency);
}",0.9607712765957448
154122,"public Rectangle boundsSuggested(final Widget widget,final Rectangle originalBounds,final Rectangle suggestedBounds,final ResizeProvider.ControlPoint controlPoint){
  final Rectangle result=new Rectangle(suggestedBounds);
  final double deltaW=Math.abs(suggestedBounds.getWidth() - originalBounds.getWidth());
  final double deltaH=Math.abs(suggestedBounds.getHeight() - originalBounds.getHeight());
  if (deltaW >= deltaH) {
    result.height=result.width;
  }
 else {
    result.width=result.height;
  }
  result.x=0;
  result.y=0;
  return result;
}","@Override public Rectangle boundsSuggested(final Widget widget,final Rectangle originalBounds,final Rectangle suggestedBounds,final ResizeProvider.ControlPoint controlPoint){
  final Rectangle result=new Rectangle(suggestedBounds);
  final double deltaW=Math.abs(suggestedBounds.getWidth() - originalBounds.getWidth());
  final double deltaH=Math.abs(suggestedBounds.getHeight() - originalBounds.getHeight());
  if (deltaW >= deltaH) {
    result.height=result.width;
  }
 else {
    result.width=result.height;
  }
  result.x=0;
  result.y=0;
  return result;
}",0.9910233393177738
154123,"public boolean add(CowGraphVersion version){
  firePropertyChange(PROP_VERSIONS,null,version);
  return versions.add(version);
}","public boolean add(CowGraphVersion version){
  boolean added=versions.add(version);
  firePropertyChange(PROP_VERSIONS,null,version);
  return added;
}",0.7956989247311828
154124,"public boolean remove(CowGraphVersion version){
  firePropertyChange(PROP_VERSIONS,version,null);
  return versions.remove(version);
}","public boolean remove(CowGraphVersion version){
  boolean removed=versions.remove(version);
  firePropertyChange(PROP_VERSIONS,version,null);
  return removed;
}",0.7864406779661017
154125,"@Override protected void notifyAdded(){
  super.notifyAdded();
  subscribeToVersionChanges();
}","@Override protected void notifyAdded(){
  active=true;
  super.notifyAdded();
  subscribeToVersionChanges();
}",0.926829268292683
154126,"@Override protected void notifyRemoved(){
  super.notifyRemoved();
  unsubscribeFromVersionChanges();
}","@Override protected void notifyRemoved(){
  active=false;
  super.notifyRemoved();
  unsubscribeFromVersionChanges();
}",0.927927927927928
154127,"/** 
 * Has to be called before scene gets visible!!!
 */
public void setVersion(CowGraphVersion version){
  unsubscribeFromVersionChanges();
  this.version=version;
  if (isVisible()) {
    subscribeToVersionChanges();
  }
}","/** 
 * Has to be called before scene gets visible!!!
 */
public void setVersion(CowGraphVersion version){
  unsubscribeFromVersionChanges();
  this.version=version;
  if (active) {
    subscribeToVersionChanges();
  }
}",0.9617977528089888
154128,"public GraphElement remove(int index){
  GraphElement elem=elements.remove(index);
  firePropertyElementAdded(Property.ELEMENTS_REMOVED.name(),elem);
  return elem;
}","public GraphElement remove(int index){
  GraphElement elem=elements.remove(index);
  firePropertyElementRemoved(Property.ELEMENTS_REMOVED.name(),elem);
  return elem;
}",0.9760479041916168
154129,"/** 
 * Return a proper URL with lowercase scheme, lowercase domain, stripped hash - used to compare against other previously seen URLs
 * @param href A relative or absolute URL
 * @param context Null or an absolute URL to use when href is relative
 * @return
 */
public static URL getCanonicalURL(String href,String context){
  try {
    URI normalized;
    if (context != null) {
      normalized=new URI(context);
      if (normalized.getPath().equals(""String_Node_Str""))       context+=""String_Node_Str"";
      normalized=new URI(context).resolve(href);
    }
 else {
      normalized=new URI(href);
    }
    normalized=normalized.normalize();
    return new URI(normalized.getScheme().toLowerCase(),normalized.getUserInfo(),normalized.getHost(),normalized.getPort(),normalized.getPath(),normalized.getQuery(),null).toURL();
  }
 catch (  URISyntaxException e) {
    LogFactory.getLog(URLCanonicalizer.class).error(""String_Node_Str"" + href + ""String_Node_Str""+ context,e);
    return null;
  }
catch (  MalformedURLException e) {
    LogFactory.getLog(URLCanonicalizer.class).error(""String_Node_Str"" + href + ""String_Node_Str""+ context,e);
    return null;
  }
catch (  IllegalArgumentException e) {
    LogFactory.getLog(URLCanonicalizer.class).error(""String_Node_Str"" + href + ""String_Node_Str""+ context,e);
    return null;
  }
}","/** 
 * Return a proper URL with lowercase scheme, lowercase domain, stripped hash - used to compare against other previously seen URLs
 * @param href A relative or absolute URL
 * @param context Null or an absolute URL to use when href is relative
 * @return
 */
public static URL getCanonicalURL(String href,String context){
  try {
    URI normalized;
    if (context != null) {
      normalized=new URI(context);
      if (normalized.getPath().equals(""String_Node_Str""))       context+=""String_Node_Str"";
      normalized=new URI(context).resolve(href);
    }
 else {
      normalized=new URI(href);
    }
    normalized=normalized.normalize();
    return new URI(normalized.getScheme().toLowerCase(),normalized.getUserInfo(),normalized.getHost(),normalized.getPort(),normalized.getPath().equals(""String_Node_Str"") ? ""String_Node_Str"" : normalized.getPath(),normalized.getQuery(),null).toURL();
  }
 catch (  URISyntaxException e) {
    LogFactory.getLog(URLCanonicalizer.class).error(""String_Node_Str"" + href + ""String_Node_Str""+ context,e);
    return null;
  }
catch (  MalformedURLException e) {
    LogFactory.getLog(URLCanonicalizer.class).error(""String_Node_Str"" + href + ""String_Node_Str""+ context,e);
    return null;
  }
catch (  IllegalArgumentException e) {
    LogFactory.getLog(URLCanonicalizer.class).error(""String_Node_Str"" + href + ""String_Node_Str""+ context,e);
    return null;
  }
}",0.974845060153117
154130,"public HTMLParser(ICrawlerSettings config){
  bulletParser=new BulletParser();
  textExtractor=new TextExtractor();
  linkExtractor=new HTMLLinkExtractor();
  maxOutLinks=config.getMaxOutlinks();
  linkExtractor.setIncludeImagesSources(config.getIncludeImages());
}","public HTMLParser(ICrawlerSettings config){
  this.config=config;
  maxOutLinks=config.getMaxOutlinks();
}",0.5013477088948787
154131,"@Override public void parse(Page page){
  urls=new HashMap<>();
  String htmlContent=page.getHTML();
  String contextURL=page.getWebURL().getURL();
  char[] chars=htmlContent.toCharArray();
  bulletParser.setCallback(textExtractor);
  bulletParser.parse(chars);
  page.setText(textExtractor.text.toString().trim());
  page.setTitle(textExtractor.title.toString().trim());
  bulletParser.setCallback(linkExtractor);
  bulletParser.parse(chars);
  String href;
  String baseURL=linkExtractor.base();
  if (baseURL != null) {
    contextURL=baseURL;
  }
  int urlCount=0;
  if (linkExtractor.metaRefresh() != null) {
    href=parseLink(linkExtractor.metaRefresh(),contextURL);
    if (href != null) {
      urls.put(href,null);
      urlCount++;
    }
  }
  for (  Map.Entry<String,String> link : linkExtractor.urls.entrySet()) {
    href=parseLink(link.getKey(),contextURL);
    if (href != null) {
      urls.put(href,link.getValue());
      if (++urlCount > maxOutLinks) {
        break;
      }
    }
  }
}","@Override public void parse(Page page){
  final BulletParser bulletParser=new BulletParser();
  final TextExtractor textExtractor=new TextExtractor();
  final HTMLLinkExtractor linkExtractor=new HTMLLinkExtractor();
  linkExtractor.setIncludeImagesSources(config.getIncludeImages());
  urls=new HashMap<>();
  String htmlContent=page.getHTML();
  String contextURL=page.getWebURL().getURL();
  char[] chars=htmlContent.toCharArray();
  bulletParser.setCallback(textExtractor);
  bulletParser.parse(chars);
  page.setText(textExtractor.text.toString().trim());
  page.setTitle(textExtractor.title.toString().trim());
  bulletParser.setCallback(linkExtractor);
  bulletParser.parse(chars);
  String href;
  String baseURL=linkExtractor.base();
  if (baseURL != null) {
    contextURL=baseURL;
  }
  int urlCount=0;
  if (linkExtractor.metaRefresh() != null) {
    href=parseLink(linkExtractor.metaRefresh(),contextURL);
    if (href != null) {
      urls.put(href,null);
      urlCount++;
    }
  }
  for (  Map.Entry<String,String> link : linkExtractor.urls.entrySet()) {
    href=parseLink(link.getKey(),contextURL);
    if (href != null) {
      urls.put(href,link.getValue());
      if (++urlCount > maxOutLinks) {
        break;
      }
    }
  }
}",0.8511957484499557
154132,"public void parse(String htmlContent,String contextURL){
  urls=new HashSet<String>();
  char[] chars=htmlContent.toCharArray();
  bulletParser.setCallback(textExtractor);
  bulletParser.parse(chars);
  text=textExtractor.text.toString().trim();
  title=textExtractor.title.toString().trim();
  bulletParser.setCallback(linkExtractor);
  bulletParser.parse(chars);
  Iterator<String> it=linkExtractor.urls.iterator();
  int urlCount=0;
  while (it.hasNext()) {
    String href=it.next();
    href=href.trim();
    if (href.length() == 0) {
      continue;
    }
    String hrefWithoutProtocol=href.toLowerCase();
    if (href.startsWith(""String_Node_Str"")) {
      hrefWithoutProtocol=href.substring(7);
    }
    if (hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0 && hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0) {
      URL url=URLCanonicalizer.getCanonicalURL(href,contextURL);
      if (url != null) {
        urls.add(url.toExternalForm());
        urlCount++;
        if (urlCount > MAX_OUT_LINKS) {
          break;
        }
      }
    }
  }
}","public void parse(String htmlContent,String contextURL){
  urls=new HashSet<String>();
  char[] chars=htmlContent.toCharArray();
  bulletParser.setCallback(textExtractor);
  bulletParser.parse(chars);
  text=textExtractor.text.toString().trim();
  title=textExtractor.title.toString().trim();
  bulletParser.setCallback(linkExtractor);
  bulletParser.parse(chars);
  Iterator<String> it=linkExtractor.urls.iterator();
  String baseURL=linkExtractor.base();
  if (baseURL != null) {
    contextURL=baseURL;
  }
  int urlCount=0;
  while (it.hasNext()) {
    String href=it.next();
    href=href.trim();
    if (href.length() == 0) {
      continue;
    }
    String hrefWithoutProtocol=href.toLowerCase();
    if (href.startsWith(""String_Node_Str"")) {
      hrefWithoutProtocol=href.substring(7);
    }
    if (hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0 && hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0) {
      URL url=URLCanonicalizer.getCanonicalURL(href,contextURL);
      if (url != null) {
        urls.add(url.toExternalForm());
        urlCount++;
        if (urlCount > MAX_OUT_LINKS) {
          break;
        }
      }
    }
  }
}",0.9584837545126352
154133,"public static int fetch(Page page,boolean ignoreIfBinary){
  String toFetchURL=page.getWebURL().getURL();
  HttpGet get=null;
  HttpEntity entity=null;
  try {
    get=new HttpGet(toFetchURL);
synchronized (mutex) {
      long now=(new Date()).getTime();
      if (now - startOfPeriod > 10000) {
        logger.info(""String_Node_Str"" + processedCount / ((now - startOfPeriod) / 1000));
        processedCount=0;
        startOfPeriod=now;
      }
      processedCount++;
      if (now - lastFetchTime < politenessDelay) {
        Thread.sleep(politenessDelay - (now - lastFetchTime));
      }
      lastFetchTime=(new Date()).getTime();
    }
    HttpResponse response=httpclient.execute(get);
    entity=response.getEntity();
    if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
      if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NOT_FOUND) {
        logger.info(""String_Node_Str"" + response.getStatusLine().toString() + ""String_Node_Str""+ toFetchURL);
      }
 else       if (show404Pages) {
        logger.info(""String_Node_Str"" + toFetchURL + ""String_Node_Str""+ page.getWebURL().getParentDocid()+ ""String_Node_Str"");
      }
      return response.getStatusLine().getStatusCode();
    }
    String uri=get.getURI().toString();
    if (!uri.equals(toFetchURL)) {
      if (!URLCanonicalizer.getCanonicalURL(uri).equals(toFetchURL)) {
        int newdocid=DocIDServer.getDocID(uri);
        if (newdocid != -1) {
          if (newdocid > 0) {
            return PageFetchStatus.RedirectedPageIsSeen;
          }
          WebURL webURL=new WebURL();
          webURL.setURL(uri);
          webURL.setDocid(-newdocid);
          page.setWebURL(webURL);
        }
      }
    }
    if (entity != null) {
      long size=entity.getContentLength();
      if (size == -1) {
        Header length=response.getLastHeader(""String_Node_Str"");
        if (length == null) {
          length=response.getLastHeader(""String_Node_Str"");
        }
        if (length != null) {
          size=Integer.parseInt(length.getValue());
        }
 else {
          size=-1;
        }
      }
      if (size > MAX_DOWNLOAD_SIZE) {
        entity.consumeContent();
        return PageFetchStatus.PageTooBig;
      }
      boolean isBinary=false;
      Header type=entity.getContentType();
      if (type != null && type.getValue().toLowerCase().contains(""String_Node_Str"")) {
        isBinary=true;
        if (ignoreIfBinary) {
          return PageFetchStatus.PageIsBinary;
        }
      }
      if (page.load(entity.getContent(),(int)size,isBinary)) {
        return PageFetchStatus.OK;
      }
 else {
        return PageFetchStatus.PageLoadError;
      }
    }
 else {
      get.abort();
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ toFetchURL+ ""String_Node_Str""+ page.getWebURL().getParentDocid()+ ""String_Node_Str"");
    return PageFetchStatus.FatalTransportError;
  }
catch (  IllegalStateException e) {
  }
catch (  Exception e) {
    if (e.getMessage() == null) {
      logger.error(""String_Node_Str"" + page.getWebURL().getURL());
    }
 else {
      logger.error(e.getMessage() + ""String_Node_Str"" + page.getWebURL().getURL());
    }
  }
 finally {
    try {
      if (entity != null) {
        entity.consumeContent();
      }
 else       if (get != null) {
        get.abort();
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return PageFetchStatus.UnknownError;
}","public static int fetch(Page page,boolean ignoreIfBinary){
  String toFetchURL=page.getWebURL().getURL();
  HttpGet get=null;
  HttpEntity entity=null;
  try {
    get=new HttpGet(toFetchURL);
synchronized (mutex) {
      long now=(new Date()).getTime();
      if (now - startOfPeriod > 10000) {
        logger.info(""String_Node_Str"" + processedCount / ((now - startOfPeriod) / 1000));
        processedCount=0;
        startOfPeriod=now;
      }
      processedCount++;
      if (now - lastFetchTime < politenessDelay) {
        Thread.sleep(politenessDelay - (now - lastFetchTime));
      }
      lastFetchTime=(new Date()).getTime();
    }
    HttpResponse response=httpclient.execute(get);
    entity=response.getEntity();
    int statusCode=response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
      if (statusCode != HttpStatus.SC_NOT_FOUND) {
        if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {
          Header header=response.getFirstHeader(""String_Node_Str"");
          if (header != null) {
            String movedToUrl=header.getValue();
            page.getWebURL().setURL(movedToUrl);
          }
 else {
            page.getWebURL().setURL(null);
          }
          return PageFetchStatus.Moved;
        }
        logger.info(""String_Node_Str"" + response.getStatusLine().toString() + ""String_Node_Str""+ toFetchURL);
      }
 else       if (show404Pages) {
        logger.info(""String_Node_Str"" + toFetchURL + ""String_Node_Str""+ page.getWebURL().getParentDocid()+ ""String_Node_Str"");
      }
      return response.getStatusLine().getStatusCode();
    }
    String uri=get.getURI().toString();
    if (!uri.equals(toFetchURL)) {
      if (!URLCanonicalizer.getCanonicalURL(uri).equals(toFetchURL)) {
        int newdocid=DocIDServer.getDocID(uri);
        if (newdocid != -1) {
          if (newdocid > 0) {
            return PageFetchStatus.RedirectedPageIsSeen;
          }
          WebURL webURL=new WebURL();
          webURL.setURL(uri);
          webURL.setDocid(-newdocid);
          page.setWebURL(webURL);
        }
      }
    }
    if (entity != null) {
      long size=entity.getContentLength();
      if (size == -1) {
        Header length=response.getLastHeader(""String_Node_Str"");
        if (length == null) {
          length=response.getLastHeader(""String_Node_Str"");
        }
        if (length != null) {
          size=Integer.parseInt(length.getValue());
        }
 else {
          size=-1;
        }
      }
      if (size > MAX_DOWNLOAD_SIZE) {
        entity.consumeContent();
        return PageFetchStatus.PageTooBig;
      }
      boolean isBinary=false;
      Header type=entity.getContentType();
      if (type != null && type.getValue().toLowerCase().contains(""String_Node_Str"")) {
        isBinary=true;
        if (ignoreIfBinary) {
          return PageFetchStatus.PageIsBinary;
        }
      }
      if (page.load(entity.getContent(),(int)size,isBinary)) {
        return PageFetchStatus.OK;
      }
 else {
        return PageFetchStatus.PageLoadError;
      }
    }
 else {
      get.abort();
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ toFetchURL+ ""String_Node_Str""+ page.getWebURL().getParentDocid()+ ""String_Node_Str"");
    return PageFetchStatus.FatalTransportError;
  }
catch (  IllegalStateException e) {
  }
catch (  Exception e) {
    if (e.getMessage() == null) {
      logger.error(""String_Node_Str"" + page.getWebURL().getURL());
    }
 else {
      logger.error(e.getMessage() + ""String_Node_Str"" + page.getWebURL().getURL());
    }
  }
 finally {
    try {
      if (entity != null) {
        entity.consumeContent();
      }
 else       if (get != null) {
        get.abort();
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return PageFetchStatus.UnknownError;
}",0.924736984084165
154134,"private int preProcessPage(WebURL curURL){
  if (curURL == null) {
    return -1;
  }
  Page page=new Page(curURL);
  int statusCode=PageFetcher.fetch(page,IGNORE_BINARY_CONTENT);
  curURL=page.getWebURL();
  int docid=curURL.getDocid();
  if (statusCode != PageFetchStatus.OK) {
    if (statusCode == PageFetchStatus.PageTooBig) {
      logger.error(""String_Node_Str"" + curURL.getURL());
    }
    return statusCode;
  }
  try {
    if (!page.isBinary()) {
      htmlParser.parse(page.getHTML(),curURL.getURL());
      page.setText(htmlParser.getText());
      page.setTitle(htmlParser.getTitle());
      if (page.getText() == null) {
        return PageFetchStatus.NotInTextFormat;
      }
      Iterator<String> it=htmlParser.getLinks().iterator();
      ArrayList<WebURL> toSchedule=new ArrayList<WebURL>();
      ArrayList<WebURL> toList=new ArrayList<WebURL>();
      while (it.hasNext()) {
        String url=it.next();
        if (url != null) {
          int newdocid=DocIDServer.getDocID(url);
          if (newdocid > 0) {
            if (newdocid != docid) {
              WebURL webURL=new WebURL();
              webURL.setURL(url);
              webURL.setDocid(newdocid);
              toList.add(webURL);
            }
          }
 else {
            WebURL webURL=new WebURL();
            webURL.setURL(url);
            webURL.setDocid(-newdocid);
            toList.add(webURL);
            if (shouldVisit(webURL)) {
              if (MAX_CRAWL_DEPTH == -1 || curURL.getDepth() < MAX_CRAWL_DEPTH) {
                webURL.setParentDocid(docid);
                webURL.setDepth((short)(curURL.getDepth() + 1));
                toSchedule.add(webURL);
              }
            }
          }
        }
      }
      Frontier.scheduleAll(toSchedule);
      page.setURLs(toList);
    }
    visit(page);
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.error(e.getMessage() + ""String_Node_Str"" + curURL.getURL());
  }
  return PROCESS_OK;
}","private int preProcessPage(WebURL curURL){
  if (curURL == null) {
    return -1;
  }
  Page page=new Page(curURL);
  int statusCode=PageFetcher.fetch(page,IGNORE_BINARY_CONTENT);
  curURL=page.getWebURL();
  int docid=curURL.getDocid();
  if (statusCode != PageFetchStatus.OK) {
    if (statusCode == PageFetchStatus.Moved) {
      if (FOLLOW_REDIRECTS) {
        String movedToUrl=curURL.getURL();
        if (movedToUrl == null) {
          return PageFetchStatus.MovedToUnknownLocation;
        }
        movedToUrl=URLCanonicalizer.getCanonicalURL(movedToUrl);
        int newdocid=DocIDServer.getDocID(movedToUrl);
        if (newdocid > 0) {
          return PageFetchStatus.RedirectedPageIsSeen;
        }
 else {
          WebURL webURL=new WebURL();
          webURL.setURL(movedToUrl);
          webURL.setDocid(-newdocid);
          if (shouldVisit(webURL)) {
            webURL.setParentDocid(curURL.getParentDocid());
            webURL.setDepth((short)(curURL.getDepth()));
            Frontier.schedule(webURL);
          }
        }
      }
      return PageFetchStatus.Moved;
    }
 else     if (statusCode == PageFetchStatus.PageTooBig) {
      logger.error(""String_Node_Str"" + curURL.getURL());
    }
    return statusCode;
  }
  try {
    if (!page.isBinary()) {
      htmlParser.parse(page.getHTML(),curURL.getURL());
      page.setText(htmlParser.getText());
      page.setTitle(htmlParser.getTitle());
      if (page.getText() == null) {
        return PageFetchStatus.NotInTextFormat;
      }
      Iterator<String> it=htmlParser.getLinks().iterator();
      ArrayList<WebURL> toSchedule=new ArrayList<WebURL>();
      ArrayList<WebURL> toList=new ArrayList<WebURL>();
      while (it.hasNext()) {
        String url=it.next();
        if (url != null) {
          int newdocid=DocIDServer.getDocID(url);
          if (newdocid > 0) {
            if (newdocid != docid) {
              WebURL webURL=new WebURL();
              webURL.setURL(url);
              webURL.setDocid(newdocid);
              toList.add(webURL);
            }
          }
 else {
            WebURL webURL=new WebURL();
            webURL.setURL(url);
            webURL.setDocid(-newdocid);
            toList.add(webURL);
            if (shouldVisit(webURL)) {
              if (MAX_CRAWL_DEPTH == -1 || curURL.getDepth() < MAX_CRAWL_DEPTH) {
                webURL.setParentDocid(docid);
                webURL.setDepth((short)(curURL.getDepth() + 1));
                toSchedule.add(webURL);
              }
            }
          }
        }
      }
      Frontier.scheduleAll(toSchedule);
      page.setURLs(toList);
    }
    visit(page);
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.error(e.getMessage() + ""String_Node_Str"" + curURL.getURL());
  }
  return PROCESS_OK;
}",0.8270519262981575
154135,"public static void main(String[] args) throws Exception {
  if (args.length < 2) {
    System.out.println(""String_Node_Str"");
    return;
  }
  String rootFolder=args[0];
  int numberOfCrawlers=Integer.parseInt(args[1]);
  CrawlController controller=new CrawlController(rootFolder);
  controller.addSeed(""String_Node_Str"");
  controller.setPolitenessDelay(200);
  controller.setMaximumCrawlDepth(1);
  controller.start(MyCrawler.class,numberOfCrawlers);
}","public static void main(String[] args) throws Exception {
  if (args.length < 2) {
    System.out.println(""String_Node_Str"");
    return;
  }
  String rootFolder=args[0];
  int numberOfCrawlers=Integer.parseInt(args[1]);
  CrawlController controller=new CrawlController(rootFolder);
  controller.addSeed(""String_Node_Str"");
  controller.setPolitenessDelay(200);
  controller.setMaximumCrawlDepth(3);
  controller.start(MyCrawler.class,numberOfCrawlers);
}",0.9978021978021978
154136,"public void parse(String htmlContent,String contextURL){
  urls=new HashSet<String>();
  char[] chars=htmlContent.toCharArray();
  bulletParser.setCallback(textExtractor);
  bulletParser.parse(chars);
  text=textExtractor.text.toString().trim();
  title=textExtractor.title.toString().trim();
  bulletParser.setCallback(linkExtractor);
  bulletParser.parse(chars);
  Iterator<String> it=linkExtractor.urls.iterator();
  int urlCount=0;
  while (it.hasNext()) {
    String href=it.next();
    href=href.trim();
    if (href.length() == 0) {
      continue;
    }
    String hrefWithoutProtocol=href;
    if (href.startsWith(""String_Node_Str"")) {
      hrefWithoutProtocol=href.substring(7);
    }
    if (hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0 && hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0) {
      urls.add(URLCanonicalizer.getCanonicalURL(href,contextURL).toExternalForm());
      urlCount++;
      if (urlCount > MAX_OUT_LINKS) {
        break;
      }
    }
  }
}","public void parse(String htmlContent,String contextURL){
  urls=new HashSet<String>();
  char[] chars=htmlContent.toCharArray();
  bulletParser.setCallback(textExtractor);
  bulletParser.parse(chars);
  text=textExtractor.text.toString().trim();
  title=textExtractor.title.toString().trim();
  bulletParser.setCallback(linkExtractor);
  bulletParser.parse(chars);
  Iterator<String> it=linkExtractor.urls.iterator();
  int urlCount=0;
  while (it.hasNext()) {
    String href=it.next();
    href=href.trim();
    if (href.length() == 0) {
      continue;
    }
    String hrefWithoutProtocol=href.toLowerCase();
    if (href.startsWith(""String_Node_Str"")) {
      hrefWithoutProtocol=href.substring(7);
    }
    if (hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0 && hrefWithoutProtocol.indexOf(""String_Node_Str"") < 0) {
      URL url=URLCanonicalizer.getCanonicalURL(href,contextURL);
      if (url != null) {
        urls.add(url.toExternalForm());
        urlCount++;
        if (urlCount > MAX_OUT_LINKS) {
          break;
        }
      }
    }
  }
}",0.9541015625
154137,"/** 
 * @param action
 * @param target
 * @param targetRootStr
 * @param targetPrefixStr prefix for new nodes in target - if this prefix equals the prefix of a term's ID, don't generate a new ID for the term copy
 */
private void processAttachAction(Node action,TaxonStore target,String targetRootStr,String targetPrefixStr){
  @SuppressWarnings(""String_Node_Str"") List<String> columns=(List<String>)Collections.EMPTY_LIST;
  Map<Integer,String> synPrefixes=new HashMap<Integer,String>();
  final String formatStr=getAttribute(action,ATTACHFORMATSTR);
  final String sourceRootStr=getAttribute(action,ATTACHROOTSTR);
  final String targetParentStr=getAttribute(action,ATTACHPARENTSTR);
  final String sourcePrefixStr=getAttribute(action,ATTACHPREFIXSTR);
  final String preserveIDsStr=getAttribute(action,PRESERVEIDSSTR);
  final String preserveSynonymsStr=getAttribute(action,PRESERVESYNONYMSSTR);
  NodeList childNodes=action.getChildNodes();
  if (childNodes.getLength() > 0) {
    columns=processChildNodesOfAttach(childNodes,synPrefixes);
  }
  Merger m=getMerger(formatStr,columns,synPrefixes);
  if (!m.canAttach()) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  if (!m.canPreserveID() && (sourcePrefixStr != null) && (!sourcePrefixStr.equals(targetPrefixStr))) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  String sourceStr=action.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
  File sourceFile=getSourceFile(sourceStr);
  logger.info(""String_Node_Str"" + sourceStr);
  if (targetPrefixStr == null) {
    logger.warn(""String_Node_Str"");
    targetPrefixStr=sourceFile.getName();
  }
  m.setPreserveID(processBooleanAttribute(getAttribute(action,PRESERVEIDSSTR)));
  m.setPreserveSynonyms(processSynonymSourceAttribute(getAttribute(action,PRESERVESYNONYMSSTR)));
  m.setSource(sourceFile);
  m.setTarget(target);
  m.attach(targetParentStr,sourceRootStr,sourcePrefixStr);
}","/** 
 * @param action
 * @param target
 * @param targetRootStr
 * @param targetPrefixStr prefix for new nodes in target - if this prefix equals the prefix of a term's ID, don't generate a new ID for the term copy
 */
private void processAttachAction(Node action,TaxonStore target,String targetRootStr,String targetPrefixStr){
  @SuppressWarnings(""String_Node_Str"") List<String> columns=(List<String>)Collections.EMPTY_LIST;
  Map<Integer,String> synPrefixes=new HashMap<Integer,String>();
  final String formatStr=getAttribute(action,ATTACHFORMATSTR);
  final String sourceRootStr=getAttribute(action,ATTACHROOTSTR);
  final String targetParentStr=getAttribute(action,ATTACHPARENTSTR);
  final String sourcePrefixStr=getAttribute(action,ATTACHPREFIXSTR);
  final String preserveIDsStr=getAttribute(action,PRESERVEIDSSTR);
  final String preserveSynonymsStr=getAttribute(action,PRESERVESYNONYMSSTR);
  NodeList childNodes=action.getChildNodes();
  if (childNodes.getLength() > 0) {
    columns=processChildNodesOfAttach(childNodes,synPrefixes);
  }
  Merger m=getMerger(formatStr,columns,synPrefixes);
  if (!m.canAttach()) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  if (!m.canPreserveID() && (sourcePrefixStr != null) && (!sourcePrefixStr.equals(targetPrefixStr))) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  if (m.canPreserveID() && null != preserveIDsStr) {
    if (""String_Node_Str"".equalsIgnoreCase(preserveIDsStr) || ""String_Node_Str"".equalsIgnoreCase(preserveIDsStr))     m.setPreserveID(true);
 else     m.setPreserveID(false);
  }
  String sourceStr=action.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
  File sourceFile=getSourceFile(sourceStr);
  logger.info(""String_Node_Str"" + sourceStr);
  if (targetPrefixStr == null) {
    logger.warn(""String_Node_Str"");
    targetPrefixStr=sourceFile.getName();
  }
  m.setPreserveSynonyms(processSynonymSourceAttribute(getAttribute(action,PRESERVESYNONYMSSTR)));
  m.setSource(sourceFile);
  m.setTarget(target);
  m.attach(targetParentStr,sourceRootStr,sourcePrefixStr);
}",0.9100169779286928
154138,"/** 
 * This processes the options file, builds the target and loops through the actions (attach, trim, merge) which are child elements of the root taxonomy element
 * @throws IOException
 * @throws ParserConfigurationException
 * @throws SAXException
 */
public void build() throws IOException, ParserConfigurationException, SAXException {
  NodeList parseList=parseXMLOptionsFile();
  if (parseList.getLength() != 1) {
    logger.fatal(""String_Node_Str"" + optionsFile.getCanonicalPath());
    return;
  }
  final Node taxonomyRoot=parseList.item(0);
  final String targetStr=getAttribute(taxonomyRoot,TARGETTAXONOMYSTR);
  final String targetFormatStr=getAttribute(taxonomyRoot,TARGETFORMATSTR);
  final String targetRootStr=getAttribute(taxonomyRoot,TARGETROOTSTR);
  final String targetPrefixStr=getAttribute(taxonomyRoot,PREFIXITEMSTR);
  final String targetFilterPrefixStr=getAttribute(taxonomyRoot,FILTERPREFIXITEMSTR);
  final TaxonStore target=getStore(targetStr,targetPrefixStr,targetFormatStr);
  logger.info(""String_Node_Str"" + targetStr + ""String_Node_Str""+ targetFormatStr+ ""String_Node_Str"");
  NodeList actions=taxonomyRoot.getChildNodes();
  for (int i=0; i < actions.getLength(); i++) {
    processChildNode(actions.item(i),target,targetRootStr,targetFormatStr,targetPrefixStr);
  }
  for (  String reportStr : target.countTerms()) {
    logger.info(reportStr);
  }
  saveTarget(targetFormatStr,targetFilterPrefixStr,target);
}","/** 
 * This processes the options file, builds the target and loops through the actions (attach, trim, merge) which are child elements of the root taxonomy element
 * @throws IOException
 * @throws ParserConfigurationException
 * @throws SAXException
 */
public void build() throws IOException, ParserConfigurationException, SAXException {
  NodeList parseList=parseXMLOptionsFile();
  if (parseList.getLength() != 1) {
    logger.fatal(""String_Node_Str"" + optionsFile.getCanonicalPath());
    return;
  }
  final Node taxonomyRoot=parseList.item(0);
  final String targetStr=getAttribute(taxonomyRoot,TARGETTAXONOMYSTR);
  final String targetFormatStr=getAttribute(taxonomyRoot,TARGETFORMATSTR);
  final String targetRootStr=getAttribute(taxonomyRoot,TARGETROOTSTR);
  final String targetPrefixStr=getAttribute(taxonomyRoot,PREFIXITEMSTR);
  final String targetFilterPrefixStr=getAttribute(taxonomyRoot,FILTERPREFIXITEMSTR);
  final TaxonStore target=getStore(targetStr,targetPrefixStr,targetFormatStr);
  logger.info(""String_Node_Str"" + targetStr + ""String_Node_Str""+ targetFormatStr+ ""String_Node_Str"");
  NodeList actions=taxonomyRoot.getChildNodes();
  for (int i=0; i < actions.getLength(); i++) {
    logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str"") + ""String_Node_Str""+ target.getTermbyName(""String_Node_Str""));
    processChildNode(actions.item(i),target,targetRootStr,targetFormatStr,targetPrefixStr);
    logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str"") + ""String_Node_Str""+ target.getTermbyName(""String_Node_Str""));
  }
  for (  String reportStr : target.countTerms()) {
    logger.info(reportStr);
  }
  saveTarget(targetFormatStr,targetFilterPrefixStr,target);
}",0.9122474747474748
154139,"private void processFamilyColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String familyName=stripDagger(it.getName(KnownField.FAMILY));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.FAMILY));
    if (familyName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(familyName)) {
      if (familyName != null) {
        logger.info(""String_Node_Str"" + familyName);
        if (target.getTermbyName(familyName) == null) {
          final Term familyTerm=target.addTerm(familyName);
          target.setRankFromName(familyTerm,KnownField.FAMILY.getCannonicalName());
          if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(it.getName(KnownField.ORDER)) != null) {
            final String parentName=it.getName(KnownField.ORDER);
            target.attachParent(familyTerm,target.getTermbyName(parentName));
          }
 else           if (attachTerm != null)           target.attachParent(familyTerm,attachTerm);
          if (isExtinct) {
            target.setExtinct(familyTerm);
          }
        }
      }
    }
  }
}","private void processFamilyColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String familyName=stripDagger(it.getName(KnownField.FAMILY));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.FAMILY));
    if (familyName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(familyName)) {
      if (familyName != null) {
        if (target.getTermbyName(familyName) == null) {
          final Term familyTerm=target.addTerm(familyName);
          logger.info(""String_Node_Str"" + familyName + ""String_Node_Str""+ familyTerm.getID());
          target.setRankFromName(familyTerm,KnownField.FAMILY.getCannonicalName());
          if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(it.getName(KnownField.ORDER)) != null) {
            final String parentName=it.getName(KnownField.ORDER);
            target.attachParent(familyTerm,target.getTermbyName(parentName));
          }
 else           if (attachTerm != null)           target.attachParent(familyTerm,attachTerm);
          if (isExtinct) {
            target.setExtinct(familyTerm);
          }
        }
      }
    }
  }
}",0.8783542039355993
154140,"@Override public void attach(String attachment,String cladeRoot,String prefix){
  ItemList items=reader.processCatalog(source,true);
  Term attachTerm=null;
  if (!""String_Node_Str"".equals(attachment)) {
    attachTerm=target.getTermbyName(attachment);
    if (attachTerm == null) {
      if (!target.isEmpty()) {
        System.err.println(""String_Node_Str"" + source.getAbsolutePath() + ""String_Node_Str""+ attachment+ ""String_Node_Str""+ target);
        return;
      }
 else {
        attachTerm=target.addTerm(attachment);
        logger.info(""String_Node_Str"" + attachment + ""String_Node_Str"");
      }
    }
  }
  if (items.hasColumn(KnownField.CLASS)) {
    processClassColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.ORDER)) {
    processOrderColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.FAMILY)) {
    processFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SUBFAMILY)) {
    processSubFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.GENUS)) {
    processGenusColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SPECIES)) {
    processSpeciesColumn(items,attachTerm);
  }
}","@Override public void attach(String attachment,String cladeRoot,String prefix){
  ItemList items=reader.processCatalog(source,true);
  Term attachTerm=null;
  if (!""String_Node_Str"".equals(attachment)) {
    attachTerm=target.getTermbyName(attachment);
    if (attachTerm == null) {
      if (!target.isEmpty()) {
        System.err.println(""String_Node_Str"" + source.getAbsolutePath() + ""String_Node_Str""+ attachment+ ""String_Node_Str""+ target);
        return;
      }
 else {
        attachTerm=target.addTerm(attachment);
        logger.info(""String_Node_Str"" + attachment + ""String_Node_Str"");
      }
    }
  }
  if (items.hasColumn(KnownField.CLASS)) {
    processClassColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.ORDER)) {
    processOrderColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.FAMILY)) {
    processFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SUBFAMILY)) {
    processSubFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.GENUS)) {
    processGenusColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SPECIES)) {
    processSpeciesColumn(items,attachTerm);
  }
  logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str"").getID());
}",0.9652317880794702
154141,"private Term copyTerm(OBOClass sourceClass,String prefix){
  Term targetTerm=null;
  String[] idFields=sourceClass.getID().split(""String_Node_Str"");
  if (idFields.length == 2) {
    if (idFields[0].equals(prefix)) {
      targetTerm=target.addTermbyID(sourceClass.getID(),sourceClass.getName());
      if (sourceClass.getDbxrefs() != null) {
        for (        Dbxref d : sourceClass.getDbxrefs()) {
          target.addXRefToTerm(targetTerm,d.getDatabase(),d.getDatabaseID());
        }
      }
      if (sourceClass.getSynonyms() != null) {
        for (        Synonym s : sourceClass.getSynonyms()) {
          SynonymI newSyn=null;
          if (s.getXrefs() != null && !s.getXrefs().isEmpty()) {
            Iterator<Dbxref> xIter=s.getXrefs().iterator();
            if (xIter.hasNext()) {
              Dbxref d=xIter.next();
              newSyn=target.makeSynonymWithXref(s.getText(),d.getDatabase(),d.getDatabaseID());
            }
          }
 else {
            newSyn=target.makeSynonym(s.getText());
          }
          if (newSyn != null)           targetTerm.addSynonym(newSyn);
        }
      }
      if (sourceUtils.isExtinct(sourceClass))       sourceUtils.setExtinct(targetTerm.asOBOClass());
    }
 else {
      targetTerm=target.addTerm(sourceClass.getName());
      target.addXRefToTerm(targetTerm,idFields[0],idFields[1]);
    }
  }
 else {
    logger.warn(""String_Node_Str"" + sourceClass.getID() + ""String_Node_Str"");
  }
  return targetTerm;
}","private Term copyTerm(OBOClass sourceClass,String prefix){
  Term targetTerm=null;
  if (preserveID) {
    targetTerm=target.addTermbyID(sourceClass.getID(),sourceClass.getName());
  }
 else {
    String[] idFields=sourceClass.getID().split(""String_Node_Str"");
    if (idFields.length == 2) {
      targetTerm=target.addTerm(sourceClass.getName());
      target.addXRefToTerm(targetTerm,idFields[0],idFields[1]);
    }
 else {
      logger.warn(""String_Node_Str"" + sourceClass.getID() + ""String_Node_Str"");
      targetTerm=target.addTerm(sourceClass.getName());
    }
  }
  if (sourceClass.getDbxrefs() != null) {
    for (    Dbxref d : sourceClass.getDbxrefs()) {
      target.addXRefToTerm(targetTerm,d.getDatabase(),d.getDatabaseID());
    }
  }
  if (sourceClass.getSynonyms() != null) {
    for (    Synonym s : sourceClass.getSynonyms()) {
      SynonymI newSyn=null;
      if (s.getXrefs() != null && !s.getXrefs().isEmpty()) {
        Iterator<Dbxref> xIter=s.getXrefs().iterator();
        if (xIter.hasNext()) {
          Dbxref d=xIter.next();
          newSyn=target.makeSynonymWithXref(s.getText(),d.getDatabase(),d.getDatabaseID());
        }
      }
 else {
        newSyn=target.makeSynonym(s.getText());
      }
      if (newSyn != null)       targetTerm.addSynonym(newSyn);
    }
  }
  if (sourceUtils.isExtinct(sourceClass))   sourceUtils.setExtinct(targetTerm.asOBOClass());
  return targetTerm;
}",0.725828729281768
154142,"private void addChildren(OBOClass sourceParent,Term targetParent,TaxonStore target,String prefix){
  final Collection<Link> childLinks=sourceParent.getChildren();
  for (  Link l : childLinks) {
    OBOProperty lType=l.getType();
    if (OBOUtils.ISA_PROPERTY.equals(lType.getID())) {
      OBOClass childClass=(OBOClass)l.getChild();
      Term childTerm=copyTerm(childClass,prefix);
      if (sourceUtils.getRankString(childClass) != null)       target.setRankFromName(childTerm,sourceUtils.getRankString(childClass));
      for (      Synonym syn : childClass.getSynonyms()) {
        String synText=syn.getText();
        Collection<Dbxref> xrefs=syn.getXrefs();
        if (xrefs != null && !xrefs.isEmpty()) {
          for (          Dbxref xref : xrefs) {
            SynonymI newSyn=target.makeSynonymWithXref(synText,xref.getDatabase(),xref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
        }
 else {
          SynonymI newSyn=target.makeSynonym(synText);
          childTerm.addSynonym(newSyn);
        }
      }
      target.attachParent(childTerm,targetParent);
      addChildren(childClass,childTerm,target,prefix);
    }
  }
}","private void addChildren(OBOClass sourceParent,Term targetParent,TaxonStore target,String prefix){
  final Collection<Link> childLinks=sourceParent.getChildren();
  for (  Link l : childLinks) {
    OBOProperty lType=l.getType();
    if (OBOUtils.ISA_PROPERTY.equals(lType.getID())) {
      OBOClass childClass=(OBOClass)l.getChild();
      Term childTerm=copyTerm(childClass,prefix);
      if (""String_Node_Str"".equals(childTerm.asOBOClass().getName())) {
        System.out.println(""String_Node_Str"" + target.getTermbyName(""String_Node_Str""));
        System.out.println(""String_Node_Str"" + target.getTermbyName(""String_Node_Str""));
      }
      if (sourceUtils.getRankString(childClass) != null)       target.setRankFromName(childTerm,sourceUtils.getRankString(childClass));
      for (      Synonym syn : childClass.getSynonyms()) {
        String synText=syn.getText();
        Collection<Dbxref> xrefs=syn.getXrefs();
        if (xrefs != null && !xrefs.isEmpty()) {
          for (          Dbxref xref : xrefs) {
            SynonymI newSyn=target.makeSynonymWithXref(synText,xref.getDatabase(),xref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
        }
 else {
          SynonymI newSyn=target.makeSynonym(synText);
          childTerm.addSynonym(newSyn);
        }
      }
      target.attachParent(childTerm,targetParent);
      addChildren(childClass,childTerm,target,prefix);
    }
  }
}",0.9007692307692308
154143,"/** 
 * @param targetParentName name of parent node for attached clade
 * @param sourceRootName name of root node (child of parent) for attached clade
 * @param prefix default prefix for target ontology
 */
@Override public void attach(String targetParentName,String sourceRootName,String prefix){
  logger.info(""String_Node_Str"" + sourceFile);
  sourceUtils=new OBOUtils(sourceFile.getAbsolutePath());
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + target.getTerms().size());
  logger.info(""String_Node_Str"" + sourceUtils.getTerms().size());
  if (targetParentName == null)   copyRootToTarget(sourceRootName,prefix);
 else   if (targetParentName.equalsIgnoreCase(sourceRootName)) {
    OBOClass sourceRoot=sourceUtils.lookupTermByName(sourceRootName);
    Term targetParent=target.getTermbyName(targetParentName);
    Term targetRoot=copyTerm(sourceRoot,prefix);
    logger.info(""String_Node_Str"" + targetParent);
    logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str""+ target.getTermbyName(targetParentName));
    logger.info(""String_Node_Str"" + target.getTerms().size());
    checkTarget(""String_Node_Str"");
    logger.info(""String_Node_Str"" + targetParent);
    logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str""+ target.getTermbyName(targetParentName));
    logger.info(""String_Node_Str"" + targetRoot + ""String_Node_Str""+ targetRoot.getLabel());
    target.attachParent(targetRoot,targetParent);
    addChildren(sourceRoot,targetRoot,target,prefix);
    logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str""+ target.getTermbyName(""String_Node_Str""));
    logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str""));
    logger.info(""String_Node_Str"" + target.getTerms().size());
    checkTarget(""String_Node_Str"");
  }
}","/** 
 * @param targetParentName name of parent node for attached clade
 * @param sourceRootName name of root node (child of parent) for attached clade
 * @param prefix default prefix for target ontology
 */
@Override public void attach(String targetParentName,String sourceRootName,String prefix){
  logger.info(""String_Node_Str"" + sourceFile);
  sourceUtils=new OBOUtils(sourceFile.getAbsolutePath());
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + target.getTerms().size());
  logger.info(""String_Node_Str"" + sourceUtils.getTerms().size());
  if (targetParentName == null)   copyRootToTarget(sourceRootName,prefix);
 else   if (!targetParentName.equalsIgnoreCase(sourceRootName)) {
    OBOClass sourceRoot=sourceUtils.lookupTermByName(sourceRootName);
    Term targetParent=target.getTermbyName(targetParentName);
    Term targetRoot=copyTerm(sourceRoot,prefix);
    logger.info(""String_Node_Str"" + targetParent);
    logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str""+ target.getTermbyName(targetParentName));
    logger.info(""String_Node_Str"" + target.getTerms().size());
    logger.info(""String_Node_Str"" + targetParent);
    logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str""+ target.getTermbyName(targetParentName));
    logger.info(""String_Node_Str"" + targetRoot + ""String_Node_Str""+ targetRoot.getLabel());
    target.attachParent(targetRoot,targetParent);
    addChildren(sourceRoot,targetRoot,target,prefix);
    logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str""+ target.getTermbyName(targetParentName));
    logger.info(""String_Node_Str"" + target.getTerms().size());
  }
}",0.9469740634005764
154144,"public OBOClass lookupTermByName(String termName){
  if (dirtyTermSets) {
    terms=TermUtil.getTerms(theSession);
    termNames=getAllTermNamesHash(terms);
    termIDs=getAllTermIDsHash(terms);
    dirtyTermSets=false;
  }
  if (termName == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  return termNames.get(termName);
}","public OBOClass lookupTermByName(String termName){
  if (dirtyTermSets) {
    terms=TermUtil.getTerms(theSession);
    termNames=getAllTermNamesHash(terms);
    termIDs=getAllTermIDsHash(terms);
    dirtyTermSets=false;
  }
  if (termName == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  OBOClass result;
  result=termNames.get(termName);
  if (result == null)   logger.info(""String_Node_Str"");
  for (  IdentifiedObject io : theSession.getLinkDatabase().getObjects()) {
    if (io.getName().equals(termName)) {
      logger.info(""String_Node_Str"" + termName + ""String_Node_Str""+ io);
      logger.info(""String_Node_Str"" + io.getType() + ""String_Node_Str""+ ((ObsoletableObject)io).isObsolete());
      termNames.put(termName,((OBOClass)io));
      logger.info(""String_Node_Str"" + termNames.get(termName));
      return ((OBOClass)io);
    }
  }
  logger.info(""String_Node_Str"");
  return termNames.get(termName);
}",0.4838963079340141
154145,"protected void removeNode(OBOClass target){
  theSession.removeObject(target);
}","protected void removeNode(OBOClass target){
  theSession.removeObject(target);
  dirtyTermSets=true;
}",0.8791208791208791
154146,"@Override public void setPreserveID(boolean v){
  throw new RuntimeException(""String_Node_Str"");
}","@Override public void setPreserveID(boolean v){
  if (v)   throw new RuntimeException(""String_Node_Str"");
}",0.9560975609756096
154147,"private void processSpeciesColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    if (it.getName(KnownField.SPECIES) != null) {
      if (it.hasColumn(KnownField.GENUS) && target.getTermbyName(it.getName(KnownField.GENUS)) != null) {
        final String parentName=stripDagger(it.getName(KnownField.GENUS));
        final boolean isExtinct=daggerPrefix(it.getName(KnownField.SPECIES));
        final String childName=stripDagger(it.getName(KnownField.SPECIES));
        final String speciesName=parentName + ""String_Node_Str"" + childName;
        Term speciesTerm;
        if (target.getTermbyName(speciesName) == null) {
          speciesTerm=target.addTerm(speciesName);
          target.setRankFromName(speciesTerm,KnownField.SPECIES.getCannonicalName());
          target.attachParent(speciesTerm,target.getTermbyName(parentName));
        }
 else {
          speciesTerm=target.getTermbyName(speciesName);
        }
        if (isExtinct) {
          target.setExtinct(speciesTerm);
        }
        if (items.hasColumn(KnownField.XREF)) {
        }
        addSpeciesSynonyms(it,speciesTerm);
      }
    }
  }
}","private void processSpeciesColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    if (it.getName(KnownField.SPECIES) != null) {
      if (it.hasColumn(KnownField.GENUS) && target.getTermbyName(stripDagger(it.getName(KnownField.GENUS))) != null) {
        final String parentName=stripDagger(it.getName(KnownField.GENUS));
        final boolean isExtinct=daggerPrefix(it.getName(KnownField.SPECIES));
        final String childName=stripDagger(it.getName(KnownField.SPECIES));
        final String speciesName=parentName + ""String_Node_Str"" + childName;
        Term speciesTerm;
        if (target.getTermbyName(speciesName) == null) {
          speciesTerm=target.addTerm(speciesName);
          target.setRankFromName(speciesTerm,KnownField.SPECIES.getCannonicalName());
          target.attachParent(speciesTerm,target.getTermbyName(parentName));
        }
 else {
          speciesTerm=target.getTermbyName(speciesName);
        }
        if (isExtinct) {
          target.setExtinct(speciesTerm);
        }
        if (items.hasColumn(KnownField.XREF)) {
        }
        addSpeciesSynonyms(it,speciesTerm);
      }
    }
  }
}",0.994413407821229
154148,"private void processSubFamilyColumn(ItemList items,Term attachTerm){
  for (  Item it : items.getContents()) {
    final String subFamilyName=stripDagger(it.getName(KnownField.SUBFAMILY));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.SUBFAMILY));
    if (subFamilyName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(subFamilyName)) {
      if (target.getTermbyName(subFamilyName) == null) {
        final Term subFamilyTerm=target.addTerm(subFamilyName);
        target.setRankFromName(subFamilyTerm,KnownField.SUBFAMILY.getCannonicalName());
        if (it.hasColumn(KnownField.FAMILY) && target.getTermbyName(it.getName(KnownField.FAMILY)) != null) {
          final String parentName=it.getName(KnownField.FAMILY);
          target.attachParent(subFamilyTerm,target.getTermbyName(parentName));
        }
 else         if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(it.getName(KnownField.ORDER)) != null) {
          final String parentName=it.getName(KnownField.ORDER);
          target.attachParent(subFamilyTerm,target.getTermbyName(parentName));
        }
 else         if (attachTerm != null)         target.attachParent(subFamilyTerm,attachTerm);
        if (isExtinct) {
          target.setExtinct(subFamilyTerm);
        }
      }
    }
  }
}","private void processSubFamilyColumn(ItemList items,Term attachTerm){
  for (  Item it : items.getContents()) {
    final String subFamilyName=stripDagger(it.getName(KnownField.SUBFAMILY));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.SUBFAMILY));
    if (subFamilyName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(subFamilyName)) {
      if (target.getTermbyName(subFamilyName) == null) {
        final Term subFamilyTerm=target.addTerm(subFamilyName);
        target.setRankFromName(subFamilyTerm,KnownField.SUBFAMILY.getCannonicalName());
        if (it.hasColumn(KnownField.FAMILY) && target.getTermbyName(stripDagger(it.getName(KnownField.FAMILY))) != null) {
          final String parentName=stripDagger(it.getName(KnownField.FAMILY));
          target.attachParent(subFamilyTerm,target.getTermbyName(parentName));
        }
 else         if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(stripDagger(it.getName(KnownField.ORDER))) != null) {
          final String parentName=stripDagger(it.getName(KnownField.ORDER));
          target.attachParent(subFamilyTerm,target.getTermbyName(parentName));
        }
 else         if (attachTerm != null)         target.attachParent(subFamilyTerm,attachTerm);
        if (isExtinct) {
          target.setExtinct(subFamilyTerm);
        }
      }
    }
  }
}",0.9801526717557252
154149,"private void processOrderColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String orderName=stripDagger(it.getName(KnownField.ORDER));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.FAMILY));
    if (orderName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(orderName)) {
      Term orderTerm=target.getTermbyName(orderName);
      if (orderTerm == null) {
        orderTerm=target.addTerm(orderName);
        target.setRankFromName(orderTerm,KnownField.ORDER.getCannonicalName());
        if (it.hasColumn(KnownField.CLASS) && target.getTermbyName(it.getName(KnownField.CLASS)) != null) {
          final String parentName=it.getName(KnownField.CLASS);
          target.attachParent(orderTerm,target.getTermbyName(parentName));
        }
 else         if (attachTerm != null)         target.attachParent(orderTerm,attachTerm);
        if (isExtinct) {
          target.setExtinct(orderTerm);
        }
      }
    }
  }
}","private void processOrderColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String orderName=stripDagger(it.getName(KnownField.ORDER));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.FAMILY));
    if (orderName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(orderName)) {
      Term orderTerm=target.getTermbyName(orderName);
      if (orderTerm == null) {
        orderTerm=target.addTerm(orderName);
        target.setRankFromName(orderTerm,KnownField.ORDER.getCannonicalName());
        if (it.hasColumn(KnownField.CLASS) && target.getTermbyName(stripDagger(it.getName(KnownField.CLASS))) != null) {
          final String parentName=stripDagger(it.getName(KnownField.CLASS));
          target.attachParent(orderTerm,target.getTermbyName(parentName));
        }
 else         if (attachTerm != null)         target.attachParent(orderTerm,attachTerm);
        if (isExtinct) {
          target.setExtinct(orderTerm);
        }
      }
    }
  }
}",0.986986986986987
154150,"private void processFamilyColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String familyName=stripDagger(it.getName(KnownField.FAMILY));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.FAMILY));
    if (familyName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(familyName)) {
      if (familyName != null) {
        if (target.getTermbyName(familyName) == null) {
          final Term familyTerm=target.addTerm(familyName);
          logger.info(""String_Node_Str"" + familyName + ""String_Node_Str""+ familyTerm.getID());
          target.setRankFromName(familyTerm,KnownField.FAMILY.getCannonicalName());
          if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(it.getName(KnownField.ORDER)) != null) {
            final String parentName=it.getName(KnownField.ORDER);
            target.attachParent(familyTerm,target.getTermbyName(parentName));
          }
 else           if (attachTerm != null)           target.attachParent(familyTerm,attachTerm);
          if (isExtinct) {
            target.setExtinct(familyTerm);
          }
        }
      }
    }
  }
}","private void processFamilyColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String familyName=stripDagger(it.getName(KnownField.FAMILY));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.FAMILY));
    if (familyName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(familyName)) {
      if (familyName != null) {
        if (target.getTermbyName(familyName) == null) {
          final Term familyTerm=target.addTerm(familyName);
          logger.info(""String_Node_Str"" + familyName + ""String_Node_Str""+ familyTerm.getID());
          target.setRankFromName(familyTerm,KnownField.FAMILY.getCannonicalName());
          if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(stripDagger(it.getName(KnownField.ORDER))) != null) {
            final String parentName=stripDagger(it.getName(KnownField.ORDER));
            target.attachParent(familyTerm,target.getTermbyName(parentName));
          }
 else           if (attachTerm != null)           target.attachParent(familyTerm,attachTerm);
          if (isExtinct) {
            target.setExtinct(familyTerm);
          }
        }
      }
    }
  }
}",0.9887152777777778
154151,"private void processGenusColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String genusName=stripDagger(it.getName(KnownField.GENUS));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.GENUS));
    if (genusName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(genusName)) {
      if (genusName != null && target.getTermbyName(genusName) == null) {
        final Term genusTerm=target.addTerm(genusName);
        target.setRankFromName(genusTerm,KnownField.GENUS.getCannonicalName());
        if (it.hasColumn(KnownField.SUBFAMILY) && target.getTermbyName(it.getName(KnownField.SUBFAMILY)) != null) {
          final String parentName=it.getName(KnownField.SUBFAMILY);
          target.attachParent(genusTerm,target.getTermbyName(parentName));
        }
 else         if (it.hasColumn(KnownField.FAMILY) && target.getTermbyName(it.getName(KnownField.FAMILY)) != null) {
          final String parentName=it.getName(KnownField.FAMILY);
          target.attachParent(genusTerm,target.getTermbyName(parentName));
        }
 else         if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(it.getName(KnownField.ORDER)) != null) {
          final String parentName=it.getName(KnownField.ORDER);
          target.attachParent(genusTerm,target.getTermbyName(parentName));
        }
 else         if (attachTerm != null)         target.attachParent(genusTerm,attachTerm);
        if (isExtinct) {
          target.setExtinct(genusTerm);
        }
      }
    }
  }
}","private void processGenusColumn(ItemList items,Term attachTerm){
  for (  final Item it : items.getContents()) {
    final String genusName=stripDagger(it.getName(KnownField.GENUS));
    final boolean isExtinct=daggerPrefix(it.getName(KnownField.GENUS));
    if (genusName.length() > 0 && !INCERTAESEDIS.equalsIgnoreCase(genusName)) {
      if (genusName != null && target.getTermbyName(genusName) == null) {
        final Term genusTerm=target.addTerm(genusName);
        target.setRankFromName(genusTerm,KnownField.GENUS.getCannonicalName());
        if (it.hasColumn(KnownField.SUBFAMILY) && target.getTermbyName(stripDagger(it.getName(KnownField.SUBFAMILY))) != null) {
          final String parentName=stripDagger(it.getName(KnownField.SUBFAMILY));
          target.attachParent(genusTerm,target.getTermbyName(parentName));
        }
 else         if (it.hasColumn(KnownField.FAMILY) && target.getTermbyName(stripDagger(it.getName(KnownField.FAMILY))) != null) {
          final String parentName=stripDagger(it.getName(KnownField.FAMILY));
          target.attachParent(genusTerm,target.getTermbyName(parentName));
        }
 else         if (it.hasColumn(KnownField.ORDER) && target.getTermbyName(stripDagger(it.getName(KnownField.ORDER))) != null) {
          final String parentName=stripDagger(it.getName(KnownField.ORDER));
          target.attachParent(genusTerm,target.getTermbyName(parentName));
        }
 else         if (attachTerm != null)         target.attachParent(genusTerm,attachTerm);
        if (isExtinct) {
          target.setExtinct(genusTerm);
        }
      }
    }
  }
}",0.9750798722044728
154152,"@Override public void attach(String attachment,String cladeRoot,String prefix){
  ItemList items=reader.processCatalog(source,true);
  Term attachTerm=null;
  if (!""String_Node_Str"".equals(attachment)) {
    attachTerm=target.getTermbyName(attachment);
    if (attachTerm == null) {
      if (!target.isEmpty()) {
        System.err.println(""String_Node_Str"" + source.getAbsolutePath() + ""String_Node_Str""+ attachment+ ""String_Node_Str""+ target);
        return;
      }
 else {
        attachTerm=target.addTerm(attachment);
        logger.info(""String_Node_Str"" + attachment + ""String_Node_Str"");
      }
    }
  }
  if (items.hasColumn(KnownField.CLASS)) {
    processClassColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.ORDER)) {
    processOrderColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.FAMILY)) {
    processFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SUBFAMILY)) {
    processSubFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.GENUS)) {
    processGenusColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SPECIES)) {
    processSpeciesColumn(items,attachTerm);
  }
  logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str"").getID());
}","/** 
 * @param targetParentName name of parent node for attached clade
 * @param sourceRootName name of root node (child of parent) for attached clade
 * @param prefix prefix for newly generated terms
 */
@Override public void attach(String targetParentName,String sourceRootName,String prefix){
  ItemList items=reader.processCatalog(source,true);
  Term attachTerm=null;
  if (!""String_Node_Str"".equals(targetParentName)) {
    attachTerm=target.getTermbyName(targetParentName);
    if (attachTerm == null) {
      if (!target.isEmpty()) {
        System.err.println(""String_Node_Str"" + source.getAbsolutePath() + ""String_Node_Str""+ targetParentName+ ""String_Node_Str""+ target);
        return;
      }
 else {
        attachTerm=target.addTerm(targetParentName);
        logger.info(""String_Node_Str"" + targetParentName + ""String_Node_Str"");
      }
    }
  }
  if (items.hasColumn(KnownField.CLASS)) {
    processClassColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.ORDER)) {
    processOrderColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.FAMILY)) {
    processFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SUBFAMILY)) {
    processSubFamilyColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.GENUS)) {
    processGenusColumn(items,attachTerm);
  }
  if (items.hasColumn(KnownField.SPECIES)) {
    processSpeciesColumn(items,attachTerm);
  }
  logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str"").getID());
}",0.8638018936635106
154153,"/** 
 * wrapper to call save the OBOSession to the Store's targetFile
 */
@Override public void saveStore(){
  u.saveOBOSession(targetFile);
}","/** 
 * wrapper to call save the OBOSession to the Store's targetFile
 */
@Override public void saveStore(){
  logger.info(""String_Node_Str"" + getTermbyName(""String_Node_Str""));
  u.saveOBOSession(targetFile);
}",0.8045325779036827
154154,"private void processMergeAction(Node action,TaxonStore target,String targetPrefixStr){
  final Map<Integer,String> synPrefixes=new HashMap<Integer,String>();
  final List<ColumnType> columns=processAttachElement(action,synPrefixes);
  final String formatStr=getAttribute(action,""String_Node_Str"");
  final Merger m=getMerger(formatStr,columns,synPrefixes);
  final String sourceStr=getAttribute(action,""String_Node_Str"");
  final String mergePrefix=getAttribute(action,PREFIXITEMSTR);
  final String subAction=getAttribute(action,SUBACTIONSTR);
  if (!""String_Node_Str"".equals(sourceStr)) {
    m.setSource(getSourceFile(sourceStr));
    logger.info(""String_Node_Str"" + sourceStr);
  }
 else   m.setSource(null);
  m.setTarget(target);
  if (subAction == null) {
    m.setSubAction(""String_Node_Str"");
  }
 else {
    m.setSubAction(subAction.toUpperCase());
  }
  if (mergePrefix == null) {
    m.merge(targetPrefixStr);
  }
 else {
    m.merge(mergePrefix);
  }
}","private void processMergeAction(Node action,TaxonStore target,String targetPrefixStr){
  final Map<Integer,String> synPrefixes=new HashMap<Integer,String>();
  final List<ColumnType> columns=processAttachElement(action,synPrefixes);
  final String formatStr=getAttribute(action,""String_Node_Str"");
  final Merger m=getMerger(formatStr,columns,synPrefixes);
  final String sourceStr=getAttribute(action,""String_Node_Str"");
  final String mergePrefix=getAttribute(action,PREFIXITEMSTR);
  final String subAction=getAttribute(action,SUBACTIONSTR);
  final String uriTemplate=getAttribute(action,URITEMPLATESTR);
  if (!""String_Node_Str"".equals(sourceStr)) {
    m.setSource(getSourceFile(sourceStr));
    logger.info(""String_Node_Str"" + sourceStr);
  }
 else   m.setSource(null);
  m.setTarget(target);
  if (subAction == null) {
    m.setSubAction(""String_Node_Str"");
  }
 else {
    m.setSubAction(subAction.toUpperCase());
  }
  if (uriTemplate != null) {
    m.setURITemplate(uriTemplate);
  }
  if (mergePrefix == null) {
    m.merge(targetPrefixStr);
  }
 else {
    m.merge(mergePrefix);
  }
}",0.935984481086324
154155,"private ColumnType processColumnElement(Node column,int index,Map<Integer,String> synPrefixes){
  if (column.getAttributes().getLength() > 0) {
    String newName;
    if (column.getAttributes().getNamedItem(""String_Node_Str"") != null)     newName=column.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
 else     newName=""String_Node_Str"" + Integer.toString(index);
    ColumnType col=new ColumnType(newName);
    if (column.getAttributes().getNamedItem(PREFIXITEMSTR) != null) {
      String synPrefix=column.getAttributes().getNamedItem(PREFIXITEMSTR).getNodeValue();
      synPrefixes.put(index,synPrefix);
    }
    if (column.getAttributes().getNamedItem(""String_Node_Str"") != null) {
      col.setType(column.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue());
    }
    return col;
  }
 else   throw new RuntimeException(""String_Node_Str"" + index + ""String_Node_Str"");
}","private ColumnType processColumnElement(Node column,int index,Map<Integer,String> synPrefixes){
  if (column.getAttributes().getNamedItem(""String_Node_Str"") != null) {
    final ColumnType col=new ColumnType(column.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue());
    if (column.getAttributes().getNamedItem(""String_Node_Str"") != null)     col.setName(column.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue());
 else     col.setName(""String_Node_Str"" + Integer.toString(index));
    if (column.getAttributes().getNamedItem(PREFIXITEMSTR) != null) {
      String synPrefix=column.getAttributes().getNamedItem(PREFIXITEMSTR).getNodeValue();
      synPrefixes.put(index,synPrefix);
    }
    return col;
  }
 else   throw new RuntimeException(""String_Node_Str"" + index + ""String_Node_Str"");
}",0.5916473317865429
154156,"private List<ColumnType> processChildNodesOfAttach(NodeList childNodes,Map<Integer,String> synPrefixes){
  List<ColumnType> result=new ArrayList<ColumnType>();
  for (int i=0; i < childNodes.getLength(); i++) {
    Node child=childNodes.item(i);
    String childName=child.getNodeName();
    if (COLUMNSYNTAXSTR.equals(childName)) {
      NodeList columnElements=child.getChildNodes();
      for (int j=0; j < columnElements.getLength(); j++) {
        final Node column=columnElements.item(j);
        if (column.getNodeType() == Node.ELEMENT_NODE) {
          result.add(processColumnElement(column,j,synPrefixes));
        }
      }
    }
 else     if (Node.TEXT_NODE != child.getNodeType()) {
      logger.warn(""String_Node_Str"" + child);
    }
  }
  return result;
}","private List<ColumnType> processChildNodesOfAttach(NodeList childNodes,Map<Integer,String> synPrefixes){
  List<ColumnType> result=new ArrayList<ColumnType>();
  for (int i=0; i < childNodes.getLength(); i++) {
    Node child=childNodes.item(i);
    String childName=child.getNodeName();
    if (COLUMNSYNTAXSTR.equals(childName)) {
      int columnCount=0;
      NodeList columnElements=child.getChildNodes();
      for (int j=0; j < columnElements.getLength(); j++) {
        final Node column=columnElements.item(j);
        if (column.getNodeType() == Node.ELEMENT_NODE) {
          result.add(processColumnElement(column,columnCount,synPrefixes));
          columnCount++;
        }
      }
    }
 else     if (Node.TEXT_NODE != child.getNodeType()) {
      logger.warn(""String_Node_Str"" + child);
    }
  }
  return result;
}",0.961298377028714
154157,"private void mergeXrefs(ItemList items){
  for (  Item item : items.getContents()) {
  }
}","private void mergeXrefs(ItemList items){
  int termCount=0;
  final ColumnType c=reader.getColumn(KnownField.SPECIES);
  if (c == null)   return;
  for (  Item item : items.getContents()) {
    final String genus=item.getFieldValue(KnownField.GENUS);
    String species=item.getFieldValue(KnownField.SPECIES);
    if (species.indexOf(' ') != -1) {
      species=species.substring(0,species.indexOf(' '));
    }
    final Term matchingTerm=target.getTermbyName(genus + ""String_Node_Str"" + species);
    if (matchingTerm != null) {
      termCount++;
      String finalURI=expandURI(item);
      logger.info(""String_Node_Str"" + finalURI);
      int colonpos=finalURI.indexOf(':');
      String rest=finalURI.substring(colonpos + 1);
      target.addXRefToTerm(matchingTerm,""String_Node_Str"",rest);
    }
  }
}",0.1850613154960981
154158,"@Override public void merge(String prefix){
  logger.info(""String_Node_Str"" + sourceFile);
  sourceUtils=new OBOUtils(sourceFile.getAbsolutePath());
  logger.info(""String_Node_Str"");
  int termCount=0;
  int synCount=0;
  target.updateIDGenerator(prefix);
  Collection<OBOClass> allTerms=sourceUtils.getTerms();
  for (  OBOClass term : allTerms) {
    Term matchingTerm=target.getTermbyName(term.getName());
    if (matchingTerm != null) {
      termCount++;
      for (      Synonym syn : term.getSynonyms()) {
        if (syn.getSynonymType().equals(sourceUtils.getCommonNameType())) {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeCommonNameWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
 else {
            SynonymI newSyn=target.makeCommonName(syn.getText());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
        }
 else {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeSynonymWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
 else {
            SynonymI newSyn=target.makeSynonym(syn.getText());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
        }
      }
    }
    if (termCount % 1000 == 0) {
      logger.info(""String_Node_Str"" + termCount + ""String_Node_Str""+ synCount+ ""String_Node_Str"");
    }
  }
}","@Override public void merge(String prefix){
  logger.info(""String_Node_Str"" + sourceFile);
  sourceUtils=new OBOUtils(sourceFile.getAbsolutePath());
  logger.info(""String_Node_Str"");
  int termCount=0;
  int synCount=0;
  target.updateIDGenerator(prefix);
  Collection<OBOClass> allTerms=sourceUtils.getTerms();
  for (  OBOClass term : allTerms) {
    Term matchingTerm=target.getTermbyName(term.getName());
    if (matchingTerm != null) {
      termCount++;
      for (      Synonym syn : term.getSynonyms()) {
        if (sourceUtils.getCommonNameType().equals(syn.getSynonymType())) {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeCommonNameWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
 else {
            SynonymI newSyn=target.makeCommonName(syn.getText());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
        }
 else {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeSynonymWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
 else {
            SynonymI newSyn=target.makeSynonym(syn.getText());
            matchingTerm.addSynonym(newSyn);
            synCount++;
          }
        }
      }
    }
    if (termCount % 1000 == 0) {
      logger.info(""String_Node_Str"" + termCount + ""String_Node_Str""+ synCount+ ""String_Node_Str"");
    }
  }
}",0.9779236276849642
154159,"private void addChildren(OBOClass sourceParent,Term targetParent,TaxonStore target,String prefix){
  final Collection<Link> childLinks=sourceParent.getChildren();
  for (  Link l : childLinks) {
    OBOProperty lType=l.getType();
    if (OBOUtils.ISA_PROPERTY.equals(lType.getID())) {
      OBOClass childClass=(OBOClass)l.getChild();
      Term childTerm=copyTerm(childClass,prefix);
      if (sourceUtils.getRankString(childClass) != null)       target.setRankFromName(childTerm,sourceUtils.getRankString(childClass));
      for (      Synonym syn : childClass.getSynonyms()) {
        if (syn.getSynonymType().equals(sourceUtils.getCommonNameType())) {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeCommonNameWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
 else {
            SynonymI newSyn=target.makeCommonName(syn.getText());
            childTerm.addSynonym(newSyn);
          }
        }
 else {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeSynonymWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
 else {
            SynonymI newSyn=target.makeSynonym(syn.getText());
            childTerm.addSynonym(newSyn);
          }
        }
      }
      target.attachParent(childTerm,targetParent);
      addChildren(childClass,childTerm,target,prefix);
    }
  }
}","private void addChildren(OBOClass sourceParent,Term targetParent,TaxonStore target,String prefix){
  final Collection<Link> childLinks=sourceParent.getChildren();
  for (  Link l : childLinks) {
    OBOProperty lType=l.getType();
    if (OBOUtils.ISA_PROPERTY.equals(lType.getID())) {
      OBOClass childClass=(OBOClass)l.getChild();
      Term childTerm=copyTerm(childClass,prefix);
      if (sourceUtils.getRankString(childClass) != null)       target.setRankFromName(childTerm,sourceUtils.getRankString(childClass));
      for (      Synonym syn : childClass.getSynonyms()) {
        if (sourceUtils.getCommonNameType().equals(syn.getSynonymType())) {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeCommonNameWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
 else {
            SynonymI newSyn=target.makeCommonName(syn.getText());
            childTerm.addSynonym(newSyn);
          }
        }
 else {
          if (!syn.getXrefs().isEmpty()) {
            final Dbxref ref=syn.getXrefs().iterator().next();
            SynonymI newSyn=target.makeSynonymWithXref(syn.getText(),ref.getDatabase(),ref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
 else {
            SynonymI newSyn=target.makeSynonym(syn.getText());
            childTerm.addSynonym(newSyn);
          }
        }
      }
      target.attachParent(childTerm,targetParent);
      addChildren(childClass,childTerm,target,prefix);
    }
  }
}",0.976918278228322
154160,"/** 
 * @param action
 * @param target
 * @param targetRootStr
 * @param targetPrefixStr prefix for new nodes in target - if this prefix equals the prefix of a term's ID, don't generate a new ID for the term copy
 */
private void processAttachAction(Node action,TaxonStore target,String targetRootStr,String targetPrefixStr){
  @SuppressWarnings(""String_Node_Str"") List<String> columns=(List<String>)Collections.EMPTY_LIST;
  Map<Integer,String> synPrefixes=new HashMap<Integer,String>();
  final String formatStr=getAttribute(action,ATTACHFORMATSTR);
  final String cladeRootStr=getAttribute(action,ATTACHROOTSTR);
  final String sourceParentStr=getAttribute(action,ATTACHPARENTSTR);
  final String sourcePrefixStr=getAttribute(action,ATTACHPREFIXSTR);
  NodeList childNodes=action.getChildNodes();
  if (childNodes.getLength() > 0) {
    columns=processChildNodesOfAttach(childNodes,synPrefixes);
  }
  Merger m=getMerger(formatStr,columns,synPrefixes);
  if (!m.canAttach()) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  if (!m.canPreserveID() && (sourcePrefixStr != null) && (!sourcePrefixStr.equals(targetPrefixStr))) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  String sourceURLStr=action.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
  File sourceFile=getSourceFile(sourceURLStr);
  logger.info(""String_Node_Str"" + sourceURLStr);
  if (targetPrefixStr == null) {
    logger.warn(""String_Node_Str"");
    targetPrefixStr=sourceFile.getName();
  }
  m.setSource(sourceFile);
  m.setTarget(target);
  if (sourceParentStr != null) {
    if (cladeRootStr != null)     m.attach(sourceParentStr,cladeRootStr,targetPrefixStr);
 else     m.attach(sourceParentStr,sourceParentStr,targetPrefixStr);
  }
 else {
    if (cladeRootStr != null)     m.attach(targetRootStr,cladeRootStr,targetPrefixStr);
 else     m.attach(targetRootStr,targetRootStr,targetPrefixStr);
  }
}","/** 
 * @param action
 * @param target
 * @param targetRootStr
 * @param targetPrefixStr prefix for new nodes in target - if this prefix equals the prefix of a term's ID, don't generate a new ID for the term copy
 */
private void processAttachAction(Node action,TaxonStore target,String targetRootStr,String targetPrefixStr){
  @SuppressWarnings(""String_Node_Str"") List<String> columns=(List<String>)Collections.EMPTY_LIST;
  Map<Integer,String> synPrefixes=new HashMap<Integer,String>();
  final String formatStr=getAttribute(action,ATTACHFORMATSTR);
  final String cladeRootStr=getAttribute(action,ATTACHROOTSTR);
  final String sourceParentStr=getAttribute(action,ATTACHPARENTSTR);
  final String sourcePrefixStr=getAttribute(action,ATTACHPREFIXSTR);
  NodeList childNodes=action.getChildNodes();
  if (childNodes.getLength() > 0) {
    columns=processChildNodesOfAttach(childNodes,synPrefixes);
  }
  Merger m=getMerger(formatStr,columns,synPrefixes);
  if (!m.canAttach()) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  if (!m.canPreserveID() && (sourcePrefixStr != null) && (!sourcePrefixStr.equals(targetPrefixStr))) {
    throw new RuntimeException(""String_Node_Str"" + formatStr + ""String_Node_Str"");
  }
  String sourceURLStr=action.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
  File sourceFile=getSourceFile(sourceURLStr);
  logger.info(""String_Node_Str"" + sourceURLStr);
  if (targetPrefixStr == null) {
    logger.warn(""String_Node_Str"");
    targetPrefixStr=sourceFile.getName();
  }
  m.setSource(sourceFile);
  m.setTarget(target);
  if (sourceParentStr != null) {
    if (cladeRootStr != null)     m.attach(sourceParentStr,cladeRootStr,sourcePrefixStr);
 else     m.attach(sourceParentStr,sourceParentStr,sourcePrefixStr);
  }
 else {
    if (cladeRootStr != null)     m.attach(targetRootStr,cladeRootStr,sourcePrefixStr);
 else     m.attach(targetRootStr,targetRootStr,sourcePrefixStr);
  }
}",0.9878357830714648
154161,"private void addChildren(OBOClass parentClass,Term parentTerm,TaxonStore target,String prefix){
  final Collection<Link> childLinks=parentClass.getChildren();
  for (  Link l : childLinks) {
    OBOProperty lType=l.getType();
    if (OBOUtils.ISA_PROPERTY.equals(lType.getID())) {
      OBOClass childClass=(OBOClass)l.getChild();
      Term childTerm=null;
      String[] idFields=childClass.getID().split(""String_Node_Str"");
      if (idFields.length == 2) {
        if (idFields[0].equals(prefix)) {
          childTerm=target.addTermbyID(childClass.getID(),childClass.getName());
          if (childClass.getDbxrefs() != null) {
            for (            Dbxref d : childClass.getDbxrefs()) {
              target.addXRefToTerm(childTerm,d.getDatabase(),d.getDatabaseID());
            }
          }
          if (childClass.getSynonyms() != null) {
            for (            Synonym s : childClass.getSynonyms()) {
              SynonymI newSyn=null;
              if (s.getXrefs() != null && !s.getXrefs().isEmpty()) {
                Iterator<Dbxref> xIter=s.getXrefs().iterator();
                if (xIter.hasNext()) {
                  Dbxref d=xIter.next();
                  newSyn=target.makeSynonymWithXref(s.getText(),d.getDatabase(),d.getDatabaseID());
                }
              }
 else {
                newSyn=target.makeSynonym(s.getText());
              }
              if (newSyn != null)               childTerm.addSynonym(newSyn);
            }
          }
        }
 else {
          childTerm=target.addTerm(childClass.getName());
          target.addXRefToTerm(childTerm,idFields[0],idFields[1]);
        }
      }
 else {
        logger.warn(""String_Node_Str"" + childClass.getID() + ""String_Node_Str"");
      }
      if (u.getRankString(childClass) != null)       target.setRankFromName(childTerm,u.getRankString(childClass));
      for (      Synonym syn : childClass.getSynonyms()) {
        String synText=syn.getText();
        Collection<Dbxref> xrefs=syn.getXrefs();
        if (xrefs != null && !xrefs.isEmpty()) {
          for (          Dbxref xref : xrefs) {
            SynonymI newSyn=target.makeSynonymWithXref(synText,xref.getDatabase(),xref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
        }
 else {
          SynonymI newSyn=target.makeSynonym(synText);
          childTerm.addSynonym(newSyn);
        }
      }
      target.attachParent(childTerm,parentTerm);
      addChildren(childClass,childTerm,target,prefix);
    }
  }
}","private void addChildren(OBOClass parentClass,Term parentTerm,TaxonStore target,String prefix){
  final Collection<Link> childLinks=parentClass.getChildren();
  for (  Link l : childLinks) {
    OBOProperty lType=l.getType();
    if (OBOUtils.ISA_PROPERTY.equals(lType.getID())) {
      OBOClass childClass=(OBOClass)l.getChild();
      Term childTerm=copyTerm(childClass,prefix);
      if (u.getRankString(childClass) != null)       target.setRankFromName(childTerm,u.getRankString(childClass));
      for (      Synonym syn : childClass.getSynonyms()) {
        String synText=syn.getText();
        Collection<Dbxref> xrefs=syn.getXrefs();
        if (xrefs != null && !xrefs.isEmpty()) {
          for (          Dbxref xref : xrefs) {
            SynonymI newSyn=target.makeSynonymWithXref(synText,xref.getDatabase(),xref.getDatabaseID());
            childTerm.addSynonym(newSyn);
          }
        }
 else {
          SynonymI newSyn=target.makeSynonym(synText);
          childTerm.addSynonym(newSyn);
        }
      }
      target.attachParent(childTerm,parentTerm);
      addChildren(childClass,childTerm,target,prefix);
    }
  }
}",0.3289617486338798
154162,"/** 
 * @param attachment name of parent node for attached clade
 * @param cladeRoot name of root node (child of parent) for attached clade
 * @param prefix default prefix for target ontology
 */
@Override public void attach(String attachment,String cladeRoot,String prefix){
  logger.info(""String_Node_Str"" + source);
  u=new OBOUtils(source.getAbsolutePath());
  logger.info(""String_Node_Str"");
  Term parentTerm=null;
  OBOClass cladeClass=u.lookupTermByName(cladeRoot);
  parentTerm=target.getTermbyName(attachment);
  if (parentTerm == null) {
    if (!target.isEmpty()) {
      logger.error(""String_Node_Str"" + source.getAbsolutePath() + ""String_Node_Str""+ attachment+ ""String_Node_Str""+ target);
      return;
    }
 else {
      OBOClass attachmentClass=u.lookupTermByName(attachment);
      if (attachmentClass != null) {
        parentTerm=target.addTermbyID(attachmentClass.getID(),attachment);
      }
 else {
        parentTerm=target.addTerm(attachment);
      }
      logger.info(""String_Node_Str"" + attachment + ""String_Node_Str"");
    }
  }
  if (cladeClass == null) {
    logger.error(""String_Node_Str"" + cladeRoot + ""String_Node_Str"");
    return;
  }
  Term cladeTerm=null;
  String[] idFields=cladeClass.getID().split(""String_Node_Str"");
  if (idFields.length == 2) {
    if (idFields[0].equals(prefix)) {
      cladeTerm=target.addTermbyID(cladeClass.getID(),cladeClass.getName());
      if (cladeClass.getDbxrefs() != null) {
        for (        Dbxref d : cladeClass.getDbxrefs()) {
          target.addXRefToTerm(cladeTerm,d.getDatabase(),d.getDatabaseID());
        }
      }
      if (cladeClass.getSynonyms() != null) {
        for (        Synonym s : cladeClass.getSynonyms()) {
          SynonymI newSyn=null;
          if (s.getXrefs() != null && !s.getXrefs().isEmpty()) {
            Iterator<Dbxref> xIter=s.getXrefs().iterator();
            if (xIter.hasNext()) {
              Dbxref d=xIter.next();
              newSyn=target.makeSynonymWithXref(s.getText(),d.getDatabase(),d.getDatabaseID());
            }
          }
 else {
            newSyn=target.makeSynonym(s.getText());
          }
          if (newSyn != null)           cladeTerm.addSynonym(newSyn);
        }
      }
    }
 else {
      cladeTerm=target.addTerm(cladeClass.getName());
      target.addXRefToTerm(cladeTerm,idFields[0],idFields[1]);
    }
  }
 else {
    logger.warn(""String_Node_Str"" + cladeClass.getID() + ""String_Node_Str"");
  }
  if (cladeTerm != null) {
    if (u.getRankString(cladeClass) != null)     target.setRankFromName(cladeTerm,u.getRankString(cladeClass));
    target.attachParent(cladeTerm,parentTerm);
    addChildren(cladeClass,cladeTerm,target,prefix);
  }
}","/** 
 * @param attachment name of parent node for attached clade
 * @param cladeRoot name of root node (child of parent) for attached clade
 * @param prefix default prefix for target ontology
 */
@Override public void attach(String attachment,String cladeRoot,String prefix){
  logger.info(""String_Node_Str"" + source);
  u=new OBOUtils(source.getAbsolutePath());
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + target.getTerms().size());
  Term parentTerm=null;
  OBOClass cladeClass=u.lookupTermByName(cladeRoot);
  parentTerm=target.getTermbyName(attachment);
  if (parentTerm == null) {
    if (!target.isEmpty()) {
      logger.error(""String_Node_Str"" + source.getAbsolutePath() + ""String_Node_Str""+ attachment+ ""String_Node_Str""+ target);
      return;
    }
 else {
      OBOClass attachmentClass=u.lookupTermByName(attachment);
      if (attachmentClass != null) {
        parentTerm=target.addTermbyID(attachmentClass.getID(),attachment);
      }
 else {
        parentTerm=target.addTerm(attachment);
      }
      logger.info(""String_Node_Str"" + attachment + ""String_Node_Str"");
    }
  }
  if (cladeClass == null) {
    logger.warn(""String_Node_Str"" + cladeRoot + ""String_Node_Str"");
    cladeClass=parentTerm.asOBOClass();
  }
  logger.info(""String_Node_Str"" + target.getTermbyName(""String_Node_Str""));
  for (  Term t : target.getTerms()) {
    if (""String_Node_Str"".equals(t.getLabel())) {
      logger.info(""String_Node_Str"");
    }
  }
  Term cladeTerm=copyTerm(cladeClass,prefix);
  if (cladeTerm != null) {
    if (u.getRankString(cladeClass) != null)     target.setRankFromName(cladeTerm,u.getRankString(cladeClass));
    if (!cladeTerm.getID().equals(parentTerm.getID()))     target.attachParent(cladeTerm,parentTerm);
    addChildren(cladeClass,cladeTerm,target,prefix);
  }
}",0.5820035460992907
154163,"/** 
 * Note: this returns a String->String table because the only reference to the parent taxon is the name - the id adjacent to the parent name is not for the parent.
 * @param itemList
 * @return
 */
Map<String,Set<String>> buildTree(List<PBDBItem> itemList){
  if (itemList == null)   throw new RuntimeException(""String_Node_Str"");
  Map<String,Set<String>> result=new HashMap<String,Set<String>>();
  for (  PBDBItem item : itemList) {
    if (item.isValid()) {
      String name=item.getName();
      String parentName=item.getParentName();
      if (result.containsKey(parentName)) {
        Set<String> children=result.get(parentName);
        children.add(name);
      }
 else {
        Set<String> children=new HashSet<String>();
        children.add(name);
        result.put(parentName,children);
      }
    }
  }
  return result;
}","/** 
 * Note: this returns a String->String table because the only reference to the parent taxon is the name - the id adjacent to the parent name is not for the parent.
 * @param itemList
 * @return
 */
Map<String,String> buildTree(List<PBDBItem> itemList){
  if (itemList == null)   throw new RuntimeException(""String_Node_Str"");
  Map<String,String> result=new HashMap<String,String>();
  for (  PBDBItem item : itemList) {
    if (item.isValid()) {
      String name=item.getName();
      String parentName=item.getParentName();
      if (result.containsKey(name)) {
        throw new RuntimeException(""String_Node_Str"");
      }
 else {
        result.put(name,parentName);
      }
    }
  }
  return result;
}",0.7273893521488134
154164,"/** 
 * @param parent ignored in this merger
 * @param cladeRoot ignored in this merger - each term provides it's own parentage
 */
@Override public void attach(String parent,String cladeRoot,String prefix){
  if (target == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (source == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final File taxonUnitsFile=new File(source.getAbsolutePath() + '/' + TAXONUNITSFILENAME);
  final File synonymLinksFile=new File(source.getAbsolutePath() + '/' + SYNONYMLINKSFILENAME);
  List<PBDBItem> itemList=null;
  try {
    itemList=buildPBDBList(taxonUnitsFile);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + taxonUnitsFile);
    e.printStackTrace();
  }
  Map<Integer,Integer> synonymMap;
  try {
    synonymMap=buildSynonymLinks(synonymLinksFile);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + synonymLinksFile);
  }
  Map<String,Set<String>> taxonTree=buildTree(itemList);
}","/** 
 * @param defaultParent generally ignored, except if no names in a term's lineage resolves
 * @param cladeRoot ignored in this merger
 */
@Override public void attach(String defaultParent,String cladeRoot,String prefix){
  if (target == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (source == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final File taxonUnitsFile=new File(source.getAbsolutePath() + '/' + TAXONUNITSFILENAME);
  final File synonymLinksFile=new File(source.getAbsolutePath() + '/' + SYNONYMLINKSFILENAME);
  final Term defaultParentTaxon=target.getTerm(defaultParent);
  List<PBDBItem> itemList=null;
  try {
    itemList=buildPBDBList(taxonUnitsFile);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + taxonUnitsFile);
    e.printStackTrace();
  }
  Map<Integer,Integer> synonymMap;
  try {
    synonymMap=buildSynonymLinks(synonymLinksFile);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + synonymLinksFile);
  }
  Map<String,String> taxonTree=buildTree(itemList);
  Map<String,Term> termDictionary=new HashMap<String,Term>();
  for (  Term t : target.getTerms()) {
    termDictionary.put(t.getLabel(),t);
  }
  for (  String tName : taxonTree.keySet()) {
    System.out.println(""String_Node_Str"" + tName);
    if (!termDictionary.containsKey(tName)) {
      Term newTerm=target.addTerm(tName);
      termDictionary.put(tName,newTerm);
    }
  }
  for (  String tName : taxonTree.keySet()) {
    Term child=termDictionary.get(tName);
    Term parent=termDictionary.get(taxonTree.get(tName));
    if (parent == null) {
      parent=defaultParentTaxon;
    }
    if (!parent.getChildren().contains(child)) {
      target.attachParent(child,parent);
    }
  }
  for (  PBDBItem item : itemList) {
    if (item.isValid()) {
    }
 else {
    }
  }
}",0.6322039818372337
154165,"protected static void send(Message message,String template,Map<String,Object> params){
  String bodyHtml=null;
  String bodyText=""String_Node_Str"";
  try {
    Template templateHtml=TemplateLoader.load(template + ""String_Node_Str"");
    bodyHtml=templateHtml.render(params);
    message.setHtmlBody(bodyHtml);
  }
 catch (  TemplateNotFoundException e) {
    Logger.debug(""String_Node_Str"",e);
  }
  try {
    Template templateText=TemplateLoader.load(template + ""String_Node_Str"");
    bodyText=templateText.render(params);
    message.setTextBody(bodyText);
  }
 catch (  TemplateNotFoundException e) {
    Logger.debug(""String_Node_Str"",e);
  }
  if (StringUtils.isNotEmpty(bodyHtml) || StringUtils.isNotEmpty(bodyText)) {
    Logger.debug(""String_Node_Str"");
    try {
      getMailService().send(message);
    }
 catch (    IOException e) {
      Logger.error(""String_Node_Str"",e);
    }
catch (    ApiDeadlineExceededException e) {
      Logger.error(""String_Node_Str"",e);
    }
  }
}","protected static void send(Message message,String template,Map<String,Object> params){
  String bodyHtml=null;
  String bodyText=""String_Node_Str"";
  try {
    Template templateHtml=TemplateLoader.load(template + ""String_Node_Str"");
    bodyHtml=templateHtml.render(params);
    message.setHtmlBody(bodyHtml);
  }
 catch (  TemplateNotFoundException e) {
    Logger.error(""String_Node_Str"",e);
  }
  try {
    Template templateText=TemplateLoader.load(template + ""String_Node_Str"");
    bodyText=templateText.render(params);
    message.setTextBody(bodyText);
  }
 catch (  TemplateNotFoundException e) {
    Logger.error(""String_Node_Str"",e);
  }
  if (StringUtils.isNotEmpty(bodyHtml) || StringUtils.isNotEmpty(bodyText)) {
    Logger.debug(""String_Node_Str"");
    try {
      getMailService().send(message);
    }
 catch (    IOException e) {
      Logger.error(""String_Node_Str"",e);
    }
catch (    ApiDeadlineExceededException e) {
      Logger.error(""String_Node_Str"",e);
    }
  }
}",0.7535353535353535
154166,"public static void authenticate(@Required String username,String password) throws Throwable {
  Boolean allowed=(Boolean)Security.authenticate(username,password);
  if (validation.hasErrors() || !allowed) {
    flash.keep(""String_Node_Str"");
    flash.error(Messages.get(""String_Node_Str""));
    params.flash();
  }
 else {
    User user=User.findByEmail(username);
    Logger.debug(""String_Node_Str"" + username + ""String_Node_Str""+ user.email);
    if (user != null) {
      user.createUserSession();
    }
  }
  Secure.redirectToOriginalURL();
}","public static void authenticate(@Required String username,String password) throws Throwable {
  Boolean allowed=(Boolean)Security.authenticate(username,password);
  if (validation.hasErrors() || !allowed) {
    Logger.debug(""String_Node_Str"" + validation.hasErrors() + ""String_Node_Str""+ allowed);
    flash.keep(""String_Node_Str"");
    flash.error(Messages.get(""String_Node_Str""));
    params.flash();
  }
 else {
    User user=User.findByEmail(username);
    Logger.debug(""String_Node_Str"" + username + ""String_Node_Str""+ user.email);
    if (user != null) {
      user.createUserSession();
    }
  }
  Secure.redirectToOriginalURL();
}",0.9232067510548524
154167,"public static void index(){
  if (session.contains(""String_Node_Str"") && User.findById(Long.valueOf(session.get(""String_Node_Str""))) != null) {
    Cities.index();
  }
  render();
}","public static void index(){
  if (Security.isConnected()) {
    Cities.index();
  }
 else {
    render();
  }
}",0.5753424657534246
154168,"public static void edit(Long id){
  Logger.debug(""String_Node_Str"" + id);
  Deal deal=Deal.findById(id);
  render(deal);
}","public static void edit(Long id){
  Logger.debug(""String_Node_Str"" + id);
  User user=User.findByEmail(Security.connected());
  Deal deal=Deal.findById(id);
  if (deal != null && deal.owner != null && deal.owner.equals(user)) {
    render(deal,user);
  }
 else {
    notFound();
  }
}",0.5320197044334976
154169,"public static void index(){
  User owner=User.findByEmail(Security.connected());
  List<Deal> deals=Deal.findActiveDealsByOwner(owner);
  Logger.debug(""String_Node_Str"" + deals.size());
  render(deals);
}","public static void index(){
  User user=User.findByEmail(Security.connected());
  List<Deal> deals=Deal.findActiveDealsByOwner(user);
  render(deals,user);
}",0.8199445983379502
154170,"public static void updateAccount(User user){
  validation.email(""String_Node_Str"",user.email);
  validation.required(""String_Node_Str"",user.firstName);
  validation.required(""String_Node_Str"",user.lastName);
  validation.required(""String_Node_Str"",user.password);
  Logger.debug(""String_Node_Str"" + user.email);
  User dbUser=User.findById(Long.valueOf(session.get(""String_Node_Str"")));
  user.password=DigestUtils.md5Hex(user.password);
  dbUser.updateDetails(user);
  if (!validation.hasErrors()) {
    dbUser.update();
    flash.success(Messages.get(""String_Node_Str""));
  }
 else {
    flash.error(Messages.get(""String_Node_Str""));
    params.flash();
    validation.keep();
    Logger.debug(""String_Node_Str"" + validation.errorsMap().toString());
  }
  redirect(""String_Node_Str"");
}","public static void updateAccount(User user,String returnUrl){
  validation.email(""String_Node_Str"",user.email);
  validation.required(""String_Node_Str"",user.firstName);
  validation.required(""String_Node_Str"",user.lastName);
  validation.required(""String_Node_Str"",user.password);
  Logger.debug(""String_Node_Str"" + user.email);
  User dbUser=User.findById(Long.valueOf(session.get(""String_Node_Str"")));
  user.password=DigestUtils.md5Hex(user.password);
  dbUser.updateDetails(user);
  if (!validation.hasErrors()) {
    dbUser.update();
    flash.success(Messages.get(""String_Node_Str""));
  }
 else {
    flash.error(Messages.get(""String_Node_Str""));
    params.flash();
    validation.keep();
    Logger.debug(""String_Node_Str"" + validation.errorsMap().toString());
  }
  redirect(returnUrl);
}",0.972870662460568
154171,"protected static void send(Message message,String template,Map<String,Object> params){
  String bodyHtml=null;
  String bodyText=""String_Node_Str"";
  try {
    Template templateHtml=TemplateLoader.load(template + ""String_Node_Str"");
    bodyHtml=templateHtml.render(params);
    message.setHtmlBody(bodyHtml);
  }
 catch (  TemplateNotFoundException e) {
    Logger.error(""String_Node_Str"",e);
  }
  try {
    Template templateText=TemplateLoader.load(template + ""String_Node_Str"");
    bodyText=templateText.render(params);
    message.setTextBody(bodyText);
  }
 catch (  TemplateNotFoundException e) {
    Logger.error(""String_Node_Str"",e);
  }
  if (StringUtils.isNotEmpty(bodyHtml) || StringUtils.isNotEmpty(bodyText)) {
    Logger.debug(""String_Node_Str"");
    try {
      getMailService().send(message);
    }
 catch (    IOException e) {
      Logger.error(""String_Node_Str"",e);
    }
catch (    ApiDeadlineExceededException e) {
      Logger.error(""String_Node_Str"",e);
    }
  }
}","protected static void send(Message message,String template,Map<String,Object> params){
  String bodyHtml=null;
  String bodyText=""String_Node_Str"";
  try {
    Template templateHtml=TemplateLoader.load(template + ""String_Node_Str"");
    bodyHtml=templateHtml.render(params);
    message.setHtmlBody(bodyHtml);
  }
 catch (  TemplateNotFoundException e) {
    Logger.info(""String_Node_Str"",e);
  }
  try {
    Template templateText=TemplateLoader.load(template + ""String_Node_Str"");
    bodyText=templateText.render(params);
    message.setTextBody(bodyText);
  }
 catch (  TemplateNotFoundException e) {
    Logger.error(""String_Node_Str"",e);
  }
  if (StringUtils.isNotEmpty(bodyHtml) || StringUtils.isNotEmpty(bodyText)) {
    try {
      Logger.debug(""String_Node_Str"",bodyHtml);
      getMailService().send(message);
    }
 catch (    IOException e) {
      Logger.error(""String_Node_Str"",e);
    }
catch (    ApiDeadlineExceededException e) {
      Logger.error(""String_Node_Str"",e);
    }
  }
}",0.9778894472361808
154172,"/** 
 * Search for the nearest city and return the active deals
 * @param lat
 * @param lng
 */
public static void findCityDealsByLatLong(@Required double lat,@Required double lng,@Required @As(""String_Node_Str"") Date checkin,@Required int nights){
  if (validation.hasErrors()) {
    renderJSON(null);
  }
 else {
    List<City> cities=City.findActiveCities();
    City city=GeoHelper.getNearestCity(lat,lng,cities);
    Logger.debug(""String_Node_Str"",lat,lng,city);
    renderJSON(DealsService.findTonightDealsByCityV3(city));
  }
}","/** 
 * Search for the nearest city and return the active deals
 * @param lat
 * @param lng
 */
public static void findCityDealsByLatLong(@Required double lat,@Required double lng,@Required @As(""String_Node_Str"") Date checkin,@Required int nights){
  if (validation.hasErrors()) {
    renderJSON(null);
  }
 else {
    List<City> cities=City.findActiveCities();
    City city=GeoHelper.getNearestCity(lat,lng,cities);
    Logger.debug(""String_Node_Str"",lat,lng,city);
    renderJSON(DealsService.findDealsByCityAndDateV3(city,checkin,nights));
  }
}",0.9732225300092336
154173,"/** 
 * Search for a city by name and return the active deals
 * @param name
 */
public static void findCityDealsByCityName(@Required String name,@Required @As(""String_Node_Str"") Date checkin,@Required int nights){
  if (validation.hasErrors()) {
    renderJSON(null);
  }
 else {
    City city=City.findByUrl(name.toLowerCase());
    Logger.debug(""String_Node_Str"",name,city);
    renderJSON(DealsService.findTonightDealsByCityV3(city));
  }
}","/** 
 * Search for a city by name and return the active deals
 * @param name
 */
public static void findCityDealsByCityName(@Required String name,@Required @As(""String_Node_Str"") Date checkin,@Required int nights){
  if (validation.hasErrors()) {
    renderJSON(null);
  }
 else {
    City city=City.findByUrl(name.toLowerCase());
    Logger.debug(""String_Node_Str"",name,city);
    renderJSON(DealsService.findDealsByCityAndDateV3(city,checkin,nights));
  }
}",0.9678848283499446
154174,"/** 
 * V3 Limits the deals number per city zone to the MAXDEALS
 * @param dealsMap
 * @return Returns a DealsCityDTO with all the active deals in all the zones of a city.
 */
private static List<DealsCityDTO> findCityZonesWithActiveDeals(LinkedHashMap<City,List<Deal>> dealsMap,Boolean noLimits,Boolean hideAppOnly){
  List<DealsCityDTO> cityZones=new ArrayList<DealsCityDTO>();
  for (  City city : dealsMap.keySet()) {
    List<Deal> zoneDeals=selectMaxDeals(dealsMap.get(city),noLimits,hideAppOnly);
    if (zoneDeals.size() > 0) {
      List<DealDTOV3> dealsDtos=new ArrayList<DealDTOV3>();
      for (      Deal deal : zoneDeals) {
        dealsDtos.add(new DealDTOV3(deal));
      }
      DealsCityDTO dealsCity=new DealsCityDTO(city,dealsDtos);
      cityZones.add(dealsCity);
    }
  }
  return cityZones;
}","/** 
 * V3 Limits the deals number per city zone to the MAXDEALS
 * @param dealsMap
 * @return Returns a DealsCityDTO with all the active deals in all the zones of a city.
 */
private static List<CityZoneDTO> findCityZonesWithActiveDeals(LinkedHashMap<City,List<Deal>> dealsMap,Boolean noLimits,Boolean hideAppOnly){
  List<CityZoneDTO> cityZones=new ArrayList<CityZoneDTO>();
  for (  City city : dealsMap.keySet()) {
    List<Deal> zoneDeals=selectMaxDeals(dealsMap.get(city),noLimits,hideAppOnly);
    if (zoneDeals.size() > 0) {
      List<DealDTOV3> dealsDtos=new ArrayList<DealDTOV3>();
      for (      Deal deal : zoneDeals) {
        dealsDtos.add(new DealDTOV3(deal));
      }
      CityZoneDTO dealsCity=new CityZoneDTO(city,dealsDtos);
      cityZones.add(dealsCity);
    }
  }
  return cityZones;
}",0.947756607252612
154175,"/** 
 * V3 Check each deal limit hour to show it as active or not. Also limits the deals number per city zone to the MAXDEALS
 * @param dealsMap
 * @param hour
 * @return Returns a DealsCityDTO with all the active deals in all the zones of a city at a given hour.
 */
private static List<DealsCityDTO> findCityZonesWithActiveDealsByNight(LinkedHashMap<City,List<Deal>> dealsMap,Integer hour,Boolean noLimits,Boolean hideAppOnly){
  List<DealsCityDTO> cityZones=new ArrayList<DealsCityDTO>();
  Logger.debug(""String_Node_Str"" + hour);
  for (  City city : dealsMap.keySet()) {
    List<Deal> zoneDeals=selectMaxDealsByHour(dealsMap.get(city),hour,noLimits,hideAppOnly);
    if (zoneDeals.size() > 0) {
      List<DealDTOV3> dealsDtos=new ArrayList<DealDTOV3>();
      for (      Deal deal : zoneDeals) {
        dealsDtos.add(new DealDTOV3(deal));
      }
      DealsCityDTO dealsCity=new DealsCityDTO(city,dealsDtos);
      cityZones.add(dealsCity);
    }
  }
  return cityZones;
}","/** 
 * V3 Check each deal limit hour to show it as active or not. Also limits the deals number per city zone to the MAXDEALS
 * @param dealsMap
 * @param hour
 * @return Returns a DealsCityDTO with all the active deals in all the zones of a city at a given hour.
 */
private static List<CityZoneDTO> findCityZonesWithActiveDealsByNight(LinkedHashMap<City,List<Deal>> dealsMap,Integer hour,Boolean noLimits,Boolean hideAppOnly){
  List<CityZoneDTO> cityZones=new ArrayList<CityZoneDTO>();
  Logger.debug(""String_Node_Str"" + hour);
  for (  City city : dealsMap.keySet()) {
    List<Deal> zoneDeals=selectMaxDealsByHour(dealsMap.get(city),hour,noLimits,hideAppOnly);
    if (zoneDeals.size() > 0) {
      List<DealDTOV3> dealsDtos=new ArrayList<DealDTOV3>();
      for (      Deal deal : zoneDeals) {
        dealsDtos.add(new DealDTOV3(deal));
      }
      CityZoneDTO dealsCity=new CityZoneDTO(city,dealsDtos);
      cityZones.add(dealsCity);
    }
  }
  return cityZones;
}",0.9565661727133368
154176,"/** 
 * Version 3. Cities can have root cities and zones.
 * @param city
 * @param noLimits 
 * @return all the active deals by city base on current time
 */
public static List<DealsCityDTO> findCityZonesDeals(City city,Boolean noLimits,Boolean hideAppOnly){
  if (city != null) {
    if (!city.isRootCityWithZones()) {
      String root=city.root;
      city=City.findByUrl(root);
    }
switch (DateHelper.getCurrentStateByCityHour(city.utcOffset)) {
case (DateHelper.CITY_CLOSED):
      Logger.info(""String_Node_Str"");
    return new ArrayList<DealsCityDTO>();
case (DateHelper.CITY_OPEN_DAY):
  LinkedHashMap<City,List<Deal>> dealsMap=findAllActiveDealsByCityV2(city);
Logger.info(""String_Node_Str"");
return findCityZonesWithActiveDeals(dealsMap,noLimits,hideAppOnly);
case (DateHelper.CITY_OPEN_NIGHT):
LinkedHashMap<City,List<Deal>> dealsMapAll=findAllActiveDealsByCityV2(city);
Integer hour=DateHelper.getCurrentHour(city.utcOffset);
Logger.debug(""String_Node_Str"" + hour);
return findCityZonesWithActiveDealsByNight(dealsMapAll,hour,noLimits,hideAppOnly);
default :
Logger.error(""String_Node_Str"");
return new ArrayList<DealsCityDTO>();
}
}
 else {
Logger.error(""String_Node_Str"");
return null;
}
}","/** 
 * Version 3. Cities can have root cities and zones.
 * @param city
 * @param noLimits 
 * @return all the active deals by city base on current time
 */
public static CityRootDTO findCityZonesDeals(City city,Boolean noLimits,Boolean hideAppOnly){
  if (city != null) {
    if (!city.isRootCityWithZones()) {
      String root=city.root;
      city=City.findByUrl(root);
    }
switch (DateHelper.getCurrentStateByCityHour(city.utcOffset)) {
case (DateHelper.CITY_CLOSED):
      Logger.info(""String_Node_Str"");
    return null;
case (DateHelper.CITY_OPEN_DAY):
  LinkedHashMap<City,List<Deal>> dealsMap=findAllActiveDealsByCityV2(city);
Logger.info(""String_Node_Str"");
List<CityZoneDTO> zones=findCityZonesWithActiveDeals(dealsMap,noLimits,hideAppOnly);
return new CityRootDTO(city,zones);
case (DateHelper.CITY_OPEN_NIGHT):
LinkedHashMap<City,List<Deal>> dealsMapAll=findAllActiveDealsByCityV2(city);
Integer hour=DateHelper.getCurrentHour(city.utcOffset);
Logger.debug(""String_Node_Str"" + hour);
List<CityZoneDTO> zonesNight=findCityZonesWithActiveDealsByNight(dealsMapAll,hour,noLimits,hideAppOnly);
return new CityRootDTO(city,zonesNight);
default :
Logger.error(""String_Node_Str"");
return null;
}
}
 else {
Logger.error(""String_Node_Str"");
return null;
}
}",0.8003240178209802
154177,"public static List<DealsCityDTO> findTonightDealsByCityV3(City city){
  Boolean noLimits=Boolean.FALSE;
  Boolean hideAppOnly=Boolean.TRUE;
  List<DealsCityDTO> deals=findCityZonesDeals(city,noLimits,hideAppOnly);
  return deals;
}","public static CityRootDTO findTonightDealsByCityV3(City city,int nights){
  if (nights > MAX_NIGHTS) {
    Logger.debug(""String_Node_Str"",nights);
    return null;
  }
 else {
    Boolean noLimits=Boolean.FALSE;
    Boolean hideAppOnly=Boolean.TRUE;
    return findCityZonesDeals(city,noLimits,hideAppOnly);
  }
}",0.6654411764705882
154178,"private static void doHotUsaReservation(Booking booking){
  String localizador=HotUsaApiHelper.reservation(booking);
  if (localizador != null) {
    Logger.debug(""String_Node_Str"" + localizador);
    booking.code=localizador;
    booking.update();
  }
 else {
    validation.addError(""String_Node_Str"",Messages.get(""String_Node_Str""));
    renderBookingError(booking);
  }
}","private static void doHotUsaReservation(Booking booking){
  String localizador=HotUsaApiHelper.reservation(booking);
  if (localizador != null) {
    Logger.debug(""String_Node_Str"" + localizador);
    booking.code=localizador;
    booking.needConfirmation=Boolean.TRUE;
    booking.update();
  }
 else {
    validation.addError(""String_Node_Str"",Messages.get(""String_Node_Str""));
    renderBookingError(booking);
  }
}",0.9457755359394704
154179,"private static void validateAndSave(@Valid Booking booking){
  booking.validate();
  if (!validation.hasErrors()) {
    Logger.debug(""String_Node_Str"");
    booking.insert();
    booking.deal=Deal.findById(booking.deal.id);
    booking.user=User.findById(booking.user.id);
    booking.deal.isHotUsa=booking.deal.isHotUsa != null ? booking.deal.isHotUsa : Boolean.FALSE;
    if (booking.deal.isHotUsa) {
      doHotUsaReservation(booking);
    }
 else {
      updateDealRooms(booking.deal.id,booking.rooms);
    }
    Mails.hotelBookingConfirmation(booking);
    Mails.userBookingConfirmation(booking);
    String json=JsonHelper.jsonExcludeFieldsWithoutExposeAnnotation(new BookingStatusMessage(Http.StatusCode.CREATED,""String_Node_Str"",Messages.get(""String_Node_Str""),booking));
    renderJSON(json);
  }
 else {
    renderBookingError(booking);
  }
}","private static void validateAndSave(@Valid Booking booking){
  booking.validate();
  if (!validation.hasErrors()) {
    Logger.debug(""String_Node_Str"");
    booking.insert();
    booking.deal=Deal.findById(booking.deal.id);
    booking.user=User.findById(booking.user.id);
    booking.deal.isHotUsa=booking.deal.isHotUsa != null ? booking.deal.isHotUsa : Boolean.FALSE;
    if (booking.deal.isHotUsa) {
      doHotUsaReservation(booking);
    }
 else {
      updateDealRooms(booking.deal.id,booking.rooms);
      Mails.hotelBookingConfirmation(booking);
      Mails.userBookingConfirmation(booking);
    }
    String json=JsonHelper.jsonExcludeFieldsWithoutExposeAnnotation(new BookingStatusMessage(Http.StatusCode.CREATED,""String_Node_Str"",Messages.get(""String_Node_Str""),booking));
    renderJSON(json);
  }
 else {
    renderBookingError(booking);
  }
}",0.8934426229508197
154180,"private static String reservationRequest(Booking booking){
  String request=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + booking.deal.hotelCode + ""String_Node_Str""+ booking.creditCardName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ booking.creditCard+ ""String_Node_Str""+ ""String_Node_Str""+ booking.creditCardName+ ""String_Node_Str""+ ""String_Node_Str""+ booking.deal.bookingLine+ ""String_Node_Str""+ ""String_Node_Str"";
  return request;
}","private static String reservationRequest(Booking booking){
  Date date=getDateFromString(booking.creditCardExpiry);
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
  String dateText=sdf.format(date);
  String[] splitArr=StringUtils.split(dateText,""String_Node_Str"");
  String year=splitArr[1];
  String month=splitArr[0];
  String card=convertCardToHotUsa(booking.creditCardType);
  String request=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + booking.deal.hotelCode + ""String_Node_Str""+ booking.creditCardName+ ""String_Node_Str""+ ""String_Node_Str""+ card+ ""String_Node_Str""+ ""String_Node_Str""+ booking.creditCard+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ ""String_Node_Str""+ booking.creditCardName+ ""String_Node_Str""+ ""String_Node_Str""+ booking.deal.bookingLine+ ""String_Node_Str""+ ""String_Node_Str"";
  return request;
}",0.6915052160953801
154181,"public static void getHotelPrices(List<Deal> deals){
  String wsReq=getPriceByHotelRequest(deals);
  Logger.debug(""String_Node_Str"" + wsReq);
  Document xml=prepareRequest(wsReq);
  if (xml != null) {
    if (xml.getElementsByTagName(""String_Node_Str"") != null) {
      int hotels=xml.getElementsByTagName(""String_Node_Str"").getLength();
      Logger.debug(""String_Node_Str"" + hotels);
      for (int i=0; i < hotels; i++) {
        String hotelCode=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String priceString=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String status=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String regime=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String lin=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String pdr=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        if (status.equals(""String_Node_Str"") && regime.equals(""String_Node_Str"") && pdr.equals(""String_Node_Str"")) {
          Logger.debug(""String_Node_Str"" + hotelCode + ""String_Node_Str""+ priceString);
          Float price=Float.parseFloat(priceString);
          int quantity=1;
          Deal.updateDealByCode(hotelCode,quantity,price,lin);
        }
 else {
          Logger.debug(""String_Node_Str"");
        }
      }
    }
  }
 else {
    Logger.error(""String_Node_Str"");
  }
}","public static void getHotelPrices(List<Deal> deals){
  String wsReq=getPriceByHotelRequest(deals);
  Logger.debug(""String_Node_Str"" + wsReq);
  Document xml=prepareRequest(wsReq);
  if (xml != null) {
    if (xml.getElementsByTagName(""String_Node_Str"") != null) {
      int hotels=xml.getElementsByTagName(""String_Node_Str"").getLength();
      Logger.debug(""String_Node_Str"" + hotels);
      for (int i=0; i < hotels; i++) {
        String hotelCode=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String priceString=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String status=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String regime=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String lin=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        String pdr=xml.getElementsByTagName(""String_Node_Str"").item(i).getTextContent();
        if (status.equals(""String_Node_Str"") && regime.equals(""String_Node_Str"") && pdr.equals(""String_Node_Str"")) {
          Logger.debug(""String_Node_Str"" + hotelCode + ""String_Node_Str""+ priceString);
          Float price=Float.parseFloat(priceString);
          BigDecimal priceRounded=new BigDecimal(price);
          priceRounded=priceRounded.setScale(0,RoundingMode.UP);
          price=priceRounded.floatValue();
          int quantity=1;
          Deal.updateDealByCode(hotelCode,quantity,price,lin);
        }
 else {
          Float price=new Float(0);
          int quantity=0;
          Deal.updateDealByCode(hotelCode,quantity,price,lin);
          Logger.debug(""String_Node_Str"");
        }
      }
    }
  }
 else {
    Logger.error(""String_Node_Str"");
  }
}",0.9099378881987578
154182,"public static String reservation(Booking booking){
  String wsReq=reservationRequest(booking);
  Document xml=prepareRequest(wsReq);
  if (xml != null) {
    String status=xml.getElementsByTagName(""String_Node_Str"").item(0).getTextContent();
    Logger.debug(""String_Node_Str"" + status);
    if (status.equals(""String_Node_Str"")) {
      String localizador=xml.getElementsByTagName(""String_Node_Str"").item(0).getTextContent();
      Logger.debug(""String_Node_Str"" + localizador);
      return localizador;
    }
 else {
      Logger.error(""String_Node_Str"");
    }
  }
 else {
    Logger.error(""String_Node_Str"");
  }
  return null;
}","public static String reservation(Booking booking){
  String wsReq=reservationRequest(booking);
  Logger.debug(""String_Node_Str"" + wsReq);
  Document xml=prepareRequest(wsReq);
  if (xml != null) {
    String status=xml.getElementsByTagName(""String_Node_Str"").item(0).getTextContent();
    Logger.debug(""String_Node_Str"" + status);
    if (status.equals(""String_Node_Str"")) {
      String localizador=xml.getElementsByTagName(""String_Node_Str"").item(0).getTextContent();
      Logger.debug(""String_Node_Str"" + localizador);
      return localizador;
    }
 else {
      Logger.error(""String_Node_Str"");
    }
  }
 else {
    Logger.error(""String_Node_Str"");
  }
  return null;
}",0.9672006102212052
154183,"public static void update(String json){
  String body=json != null ? json : params.get(""String_Node_Str"");
  Logger.debug(""String_Node_Str"" + body);
  if (body != null) {
    User user=new Gson().fromJson(body,User.class);
    User dbUser=User.findById(user.id);
    dbUser.updateDetails(user);
    dbUser.update();
    renderJSON(new UserDTO(dbUser));
  }
}","public static void update(Long id){
  String body=params.get(""String_Node_Str"");
  Logger.debug(""String_Node_Str"" + body);
  if (body != null) {
    User user=new Gson().fromJson(body,User.class);
    User dbUser=User.findById(id);
    dbUser.updateDetails(user);
    dbUser.validate();
    if (!validation.hasErrors()) {
      dbUser.update();
      UserStatusMessage message=new UserStatusMessage(Http.StatusCode.OK,""String_Node_Str"",""String_Node_Str"",dbUser);
      Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
      renderJSON(message);
    }
 else {
      UserStatusMessage message=new UserStatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",validation.errors().toString(),dbUser);
      Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
      renderJSON(message);
    }
  }
}",0.5122985581000848
154184,"private static void validateAndSave(@Valid User user){
  user.validate();
  if (!validation.hasErrors()) {
    user.insert();
    UserStatusMessage message=new UserStatusMessage(Http.StatusCode.CREATED,""String_Node_Str"",""String_Node_Str"",user);
    Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
    renderJSON(message);
  }
 else {
    UserStatusMessage message=new UserStatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",""String_Node_Str"",user);
    Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
    renderJSON(message);
  }
}","private static void validateAndSave(@Valid User user){
  user.validate();
  if (!validation.hasErrors()) {
    user.insert();
    UserStatusMessage message=new UserStatusMessage(Http.StatusCode.CREATED,""String_Node_Str"",""String_Node_Str"",user);
    Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
    Mails.welcome(user);
    renderJSON(message);
  }
 else {
    UserStatusMessage message=new UserStatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",validation.errors().toString(),user);
    Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
    renderJSON(message);
  }
}",0.9388794567062818
154185,"public DealDTO(Deal deal){
  validateDeal(deal);
  this.id=deal.id;
  this.hotelName=deal.hotelName;
  this.city=deal.city;
  this.salePriceCents=deal.salePriceCents;
  this.priceCents=deal.priceCents;
  this.quantity=deal.quantity;
  this.hotelCategory=deal.hotelCategory;
  this.roomType=deal.roomType;
  this.address=deal.address;
  this.latitude=deal.latitude;
  this.longitude=deal.longitude;
  this.mainImageBig=deal.mainImageBig;
  this.mainImageSmall=deal.mainImageSmall;
  this.image1=deal.image1;
  this.image2=deal.image2;
  this.image3=deal.image3;
  this.image4=deal.image4;
  this.image5=deal.image5;
  this.description=deal.description;
  this.shortDescription=deal.shortDescription;
  this.detailText=deal.detailText;
  this.hotelText=deal.hotelText;
  this.roomText=deal.roomText;
  this.aroundText=deal.aroundText;
  this.foodDrinkText=deal.foodDrinkText;
  Logger.debug(""String_Node_Str"" + Lang.get());
  String lang=Lang.get();
  if (lang.equals(Lang.getLocale().ENGLISH)) {
    this.description=deal.descriptionEN;
    this.shortDescription=deal.shortDescriptionEN;
    this.detailText=deal.detailTextEN;
    this.hotelText=deal.hotelTextEN;
    this.roomText=deal.roomTextEN;
    this.aroundText=deal.aroundTextEN;
    this.foodDrinkText=deal.foodDrinkTextEN;
  }
 else   if (lang.equals(Lang.getLocale().FRENCH)) {
    this.description=deal.descriptionFR;
    this.shortDescription=deal.shortDescriptionFR;
    this.detailText=deal.detailTextFR;
    this.hotelText=deal.hotelTextFR;
    this.roomText=deal.roomTextFR;
    this.aroundText=deal.aroundTextFR;
    this.foodDrinkText=deal.foodDrinkTextFR;
  }
}","public DealDTO(Deal deal){
  validateDeal(deal);
  this.id=deal.id;
  this.hotelName=deal.hotelName;
  this.city=deal.city;
  this.salePriceCents=deal.salePriceCents;
  this.priceCents=deal.priceCents;
  this.quantity=deal.quantity;
  this.hotelCategory=deal.hotelCategory;
  this.roomType=deal.roomType;
  this.address=deal.address;
  this.latitude=deal.latitude;
  this.longitude=deal.longitude;
  this.mainImageBig=deal.mainImageBig;
  this.mainImageSmall=deal.mainImageSmall;
  this.image1=deal.image1;
  this.image2=deal.image2;
  this.image3=deal.image3;
  this.image4=deal.image4;
  this.image5=deal.image5;
  this.description=deal.descriptionEN;
  this.shortDescription=deal.shortDescriptionEN;
  this.detailText=deal.detailTextEN;
  this.hotelText=deal.hotelTextEN;
  this.roomText=deal.roomTextEN;
  this.aroundText=deal.aroundTextEN;
  this.foodDrinkText=deal.foodDrinkTextEN;
  String lang=Lang.get();
  Logger.debug(""String_Node_Str"" + lang);
  if (lang.equals(""String_Node_Str"")) {
    Logger.debug(""String_Node_Str"");
    this.description=deal.description;
    this.shortDescription=deal.shortDescription;
    this.detailText=deal.detailText;
    this.hotelText=deal.hotelText;
    this.roomText=deal.roomText;
    this.aroundText=deal.aroundText;
    this.foodDrinkText=deal.foodDrinkText;
  }
 else   if (lang.equals(Lang.getLocale().FRENCH.getLanguage())) {
    Logger.debug(""String_Node_Str"");
    this.description=deal.descriptionFR;
    this.shortDescription=deal.shortDescriptionFR;
    this.detailText=deal.detailTextFR;
    this.hotelText=deal.hotelTextFR;
    this.roomText=deal.roomTextFR;
    this.aroundText=deal.aroundTextFR;
    this.foodDrinkText=deal.foodDrinkTextFR;
  }
}",0.6896551724137931
154186,"public UserDTO(User user){
  validateUser(user);
  id=user.id;
  email=user.email;
  firstName=user.firstName;
  lastName=user.lastName;
  token=user.token;
  secret=user.secret;
}","public UserDTO(User user){
  validateUser(user);
  id=user.id;
  email=user.email;
  firstName=user.firstName;
  lastName=user.lastName;
  token=user.token;
  secret=user.secret;
  password=user.password;
}",0.932642487046632
154187,"private static User findByEmailAndPassword(String email,String password){
  return User.all().filter(""String_Node_Str"",email.trim().toLowerCase()).filter(""String_Node_Str"",true).filter(""String_Node_Str"",password.trim()).get();
}","public static User findByEmailAndPassword(String email,String password){
  return User.all().filter(""String_Node_Str"",email.trim().toLowerCase()).filter(""String_Node_Str"",true).filter(""String_Node_Str"",password.trim()).get();
}",0.9758241758241758
154188,"private static void validateAndSave(@Valid User user){
  if (!validation.hasErrors() && user.emailValid()) {
    user.insert();
    renderJSON(new UserStatusMessage(Http.StatusCode.CREATED,""String_Node_Str"",""String_Node_Str"",user));
  }
 else {
    renderJSON(new UserStatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",""String_Node_Str"",user));
  }
}","private static void validateAndSave(@Valid User user){
  user.validate();
  if (!validation.hasErrors()) {
    user.insert();
    UserStatusMessage message=new UserStatusMessage(Http.StatusCode.CREATED,""String_Node_Str"",""String_Node_Str"",user);
    Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
    renderJSON(message);
  }
 else {
    UserStatusMessage message=new UserStatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",""String_Node_Str"",user);
    Logger.debug(""String_Node_Str"" + new Gson().toJson(message));
    renderJSON(message);
  }
}",0.628755364806867
154189,"public DealDTO(Deal deal){
  validateDeal(deal);
  this.id=deal.id;
  this.hotelName=deal.hotelName;
  this.city=deal.city;
  this.salePriceCents=deal.salePriceCents;
  this.priceCents=deal.priceCents;
  this.quantity=deal.quantity;
  this.hotelCategory=deal.hotelCategory;
  this.roomType=deal.roomType;
  this.address=deal.address;
  this.latitude=deal.latitude;
  this.longitude=deal.longitude;
  this.mainImageBig=deal.mainImageBig;
  this.mainImageSmall=deal.mainImageSmall;
  this.image1=deal.image1;
  this.image2=deal.image2;
  this.image3=deal.image3;
  this.image4=deal.image4;
  this.image5=deal.image5;
  this.description=deal.description;
  this.shortDescription=deal.shortDescription;
  this.detailText=deal.detailText;
  this.hotelText=deal.hotelText;
  this.roomText=deal.roomText;
  this.aroundText=deal.aroundText;
  this.foodDrinkText=deal.foodDrinkText;
  String lang=Lang.get();
  if (lang.equals(Lang.getLocale().ENGLISH)) {
    this.description=deal.descriptionEN;
    this.shortDescription=deal.shortDescriptionEN;
    this.detailText=deal.detailTextEN;
    this.hotelText=deal.hotelTextEN;
    this.roomText=deal.roomTextEN;
    this.aroundText=deal.aroundTextEN;
    this.foodDrinkText=deal.foodDrinkTextEN;
  }
 else   if (lang.equals(Lang.getLocale().FRENCH)) {
    this.description=deal.descriptionFR;
    this.shortDescription=deal.shortDescriptionFR;
    this.detailText=deal.detailTextFR;
    this.hotelText=deal.hotelTextFR;
    this.roomText=deal.roomTextFR;
    this.aroundText=deal.aroundTextFR;
    this.foodDrinkText=deal.foodDrinkTextFR;
  }
}","public DealDTO(Deal deal){
  validateDeal(deal);
  this.id=deal.id;
  this.hotelName=deal.hotelName;
  this.city=deal.city;
  this.salePriceCents=deal.salePriceCents;
  this.priceCents=deal.priceCents;
  this.quantity=deal.quantity;
  this.hotelCategory=deal.hotelCategory;
  this.roomType=deal.roomType;
  this.address=deal.address;
  this.latitude=deal.latitude;
  this.longitude=deal.longitude;
  this.mainImageBig=deal.mainImageBig;
  this.mainImageSmall=deal.mainImageSmall;
  this.image1=deal.image1;
  this.image2=deal.image2;
  this.image3=deal.image3;
  this.image4=deal.image4;
  this.image5=deal.image5;
  this.description=deal.description;
  this.shortDescription=deal.shortDescription;
  this.detailText=deal.detailText;
  this.hotelText=deal.hotelText;
  this.roomText=deal.roomText;
  this.aroundText=deal.aroundText;
  this.foodDrinkText=deal.foodDrinkText;
  Logger.debug(""String_Node_Str"" + Lang.get());
  String lang=Lang.get();
  if (lang.equals(Lang.getLocale().ENGLISH)) {
    this.description=deal.descriptionEN;
    this.shortDescription=deal.shortDescriptionEN;
    this.detailText=deal.detailTextEN;
    this.hotelText=deal.hotelTextEN;
    this.roomText=deal.roomTextEN;
    this.aroundText=deal.aroundTextEN;
    this.foodDrinkText=deal.foodDrinkTextEN;
  }
 else   if (lang.equals(Lang.getLocale().FRENCH)) {
    this.description=deal.descriptionFR;
    this.shortDescription=deal.shortDescriptionFR;
    this.detailText=deal.detailTextFR;
    this.hotelText=deal.hotelTextFR;
    this.roomText=deal.roomTextFR;
    this.aroundText=deal.aroundTextFR;
    this.foodDrinkText=deal.foodDrinkTextFR;
  }
}",0.9850560398505604
154190,"@Override public void insert(){
  this.validated=true;
  this.validationCode=RandomStringUtils.randomAlphanumeric(12);
  this.token=RandomStringUtils.randomAlphanumeric(12);
  this.secret=RandomStringUtils.randomAlphanumeric(24);
  this.email=this.email.toLowerCase();
  super.insert();
}","@Override public void insert(){
  this.validated=true;
  this.validationCode=RandomStringUtils.randomAlphanumeric(12);
  this.token=RandomStringUtils.randomAlphanumeric(12);
  this.secret=RandomStringUtils.randomAlphanumeric(24);
  this.email=this.email.toLowerCase();
  this.created=Calendar.getInstance().getTime();
  super.insert();
}",0.9216
154191,"public static User findByEmail(String email){
  return User.all().filter(""String_Node_Str"",email.toLowerCase()).get();
}","public static User findByEmail(String email){
  return User.all().filter(""String_Node_Str"",email.trim().toLowerCase()).get();
}",0.97165991902834
154192,"@Test public void createIdenticalUsers(){
  new User(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").insert();
  User user=new User(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (user.emailValid()) {
    user.insert();
  }
  int count=User.all().filter(""String_Node_Str"",""String_Node_Str"").count();
  assertEquals(1,count);
}","@Test public void createIdenticalUsers(){
  new User(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").insert();
  User user=new User(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  user.validate();
  if (!Validation.hasErrors()) {
    user.insert();
  }
  int count=User.all().filter(""String_Node_Str"",""String_Node_Str"").count();
  assertEquals(1,count);
}",0.943109987357775
154193,"public static void create(String json){
  String body=json != null ? json : params.get(""String_Node_Str"");
  Logger.debug(""String_Node_Str"" + body);
  if (body != null) {
    BookingDTO bookingDto=new Gson().fromJson(body,BookingDTO.class);
    validateAndSave(bookingDto.toBooking());
  }
}","public static void create(String json){
  String body=json != null ? json : params.get(""String_Node_Str"");
  Logger.debug(""String_Node_Str"" + body);
  if (body != null) {
    BookingDTO bookingDto;
    try {
      bookingDto=new Gson().fromJson(body,BookingDTO.class);
      validateAndSave(bookingDto.toBooking());
    }
 catch (    JsonParseException e) {
      Logger.error(""String_Node_Str"",e);
      String messageJson=JsonHelper.jsonExcludeFieldsWithoutExposeAnnotation(new BookingStatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",Messages.get(""String_Node_Str""),null));
      renderJSON(messageJson);
    }
  }
}",0.6305525460455038
154194,"public static void rememberPassword(String json){
  String body=json != null ? json : params.get(""String_Node_Str"");
  Logger.debug(""String_Node_Str"" + body);
  if (body != null) {
    User user=new Gson().fromJson(body,User.class);
    user=User.findByEmail(user.email);
    if (user != null) {
      String newPassword=user.resetPassword();
      Mails.lostPassword(user,newPassword);
      renderJSON(new StatusMessage(Http.StatusCode.OK,""String_Node_Str"",Messages.get(""String_Node_Str"")));
    }
 else {
      renderJSON(new StatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",Messages.get(""String_Node_Str"")));
    }
  }
}","public static void rememberPassword(String json){
  String body=json != null ? json : params.get(""String_Node_Str"");
  Logger.debug(""String_Node_Str"" + body);
  if (body != null) {
    User user=new Gson().fromJson(body,User.class);
    user=User.findByEmail(user.email);
    if (user != null) {
      user.setPasswordResetCode();
      Mails.lostPassword(user);
      renderJSON(new StatusMessage(Http.StatusCode.OK,""String_Node_Str"",Messages.get(""String_Node_Str"")));
    }
 else {
      renderJSON(new StatusMessage(Http.StatusCode.INTERNAL_ERROR,""String_Node_Str"",Messages.get(""String_Node_Str"")));
    }
  }
}",0.902555910543131
154195,"/** 
 * Computes MD5 signature.
 * @param data The data to be signed.
 * @param key The signing key.
 * @param timestamp The timestamp
 * @param secret The private secret
 * @return The base64-encoded MD5 signature.
 * @throws java.security.SignatureException when signature generation fails
 */
public static String calculateMD5(String data,String key,long timestamp,String secret){
  String signature=data + key + timestamp+ secret;
  String dataMd5=Codec.hexMD5(signature);
  String result=Codec.encodeBASE64(dataMd5);
  return result;
}","/** 
 * Computes MD5 signature.
 * @param data The data to be signed.
 * @param key The signing key.
 * @param timestamp The timestamp
 * @param secret The private secret
 * @return The base64-encoded MD5 signature.
 * @throws java.security.SignatureException when signature generation fails
 */
public static String calculateMD5(String data,String key,long timestamp,String secret){
  String signature=data + key + timestamp+ secret;
  String result=DigestUtils.md5Hex(signature);
  return result;
}",0.8961538461538462
154196,"public void creditCardValid(){
  if (Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok && Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok && Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok) {
    if (!CreditCardHelper.validCC(this.creditCard)) {
      Validation.addError(""String_Node_Str"",Messages.get(""String_Node_Str""),creditCard);
    }
 else {
      creditCardExpiryValid();
    }
  }
}","public void creditCardValid(){
  if (Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok && Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok && Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok&& Validation.valid(""String_Node_Str"",this).message(""String_Node_Str"").ok) {
    if (!CreditCardHelper.validCC(this.creditCard)) {
      Validation.addError(""String_Node_Str"",Messages.get(""String_Node_Str""),creditCard);
    }
 else {
      creditCardExpiryValid();
    }
  }
}",0.9261880687563196
154197,"private void validateEmail(){
  if (Validation.valid(""String_Node_Str"",this).ok && User.findByEmail(this.email) != null) {
    Validation.addError(""String_Node_Str"",""String_Node_Str"");
  }
}","private void validateEmail(){
  if (Validation.valid(""String_Node_Str"",this).message(Messages.get(""String_Node_Str"")).ok && User.findByEmail(this.email) != null) {
    Validation.addError(""String_Node_Str"",Messages.get(""String_Node_Str""));
  }
}",0.7954022988505747
154198,"public static void lostPassword(User user,String newPassword){
  Message message=new Message();
  message.setSubject(""String_Node_Str"" + user.firstName);
  message.setSender(""String_Node_Str"");
  message.setTo(user.email);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",user);
  params.put(""String_Node_Str"",newPassword);
  send(message,template,params);
}","public static void lostPassword(User user){
  Message message=new Message();
  message.setSubject(Messages.get(""String_Node_Str"") + ""String_Node_Str"" + user.firstName);
  message.setSender(""String_Node_Str"");
  message.setTo(user.email);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",user);
  send(message,template,params);
}",0.8380952380952381
154199,"public static void userBookingConfirmation(Booking booking){
  Message message=new Message();
  message.setSubject(""String_Node_Str"" + booking.deal.hotelName);
  message.setSender(""String_Node_Str"");
  message.setTo(booking.user.email);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",booking.user);
  params.put(""String_Node_Str"",booking);
  send(message,template,params);
}","public static void userBookingConfirmation(Booking booking){
  Message message=new Message();
  message.setSubject(Messages.get(""String_Node_Str"") + ""String_Node_Str"" + booking.deal.hotelName);
  message.setSender(""String_Node_Str"");
  message.setTo(booking.user.email);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",booking.user);
  params.put(""String_Node_Str"",booking);
  send(message,template,params);
}",0.9638297872340426
154200,"public static void welcome(User user){
  Message message=new Message();
  message.setSubject(""String_Node_Str"" + user.firstName);
  message.setSender(""String_Node_Str"");
  message.setTo(user.email);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",user);
  send(message,template,params);
}","public static void welcome(User user){
  Message message=new Message();
  message.setSubject(Messages.get(""String_Node_Str"") + ""String_Node_Str"" + user.firstName);
  message.setSender(""String_Node_Str"");
  message.setTo(user.email);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",user);
  send(message,template,params);
}",0.9556135770234988
154201,"public static void hotelBookingConfirmation(Booking booking){
  Message message=new Message();
  message.setSubject(""String_Node_Str"" + booking.deal.hotelName);
  message.setSender(""String_Node_Str"");
  message.setTo(booking.deal.contactEmail);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",booking.user);
  params.put(""String_Node_Str"",booking);
  send(message,template,params);
}","public static void hotelBookingConfirmation(Booking booking){
  Message message=new Message();
  message.setSubject(Messages.get(""String_Node_Str"") + ""String_Node_Str"" + booking.deal.hotelName);
  message.setSender(""String_Node_Str"");
  message.setTo(booking.deal.contactEmail);
  String template=""String_Node_Str"";
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",booking.user);
  params.put(""String_Node_Str"",booking);
  send(message,template,params);
}",0.9644351464435148
154202,"/** 
 * Paint the world view.
 */
protected void paintComponent(Graphics g){
  if (!updating) {
    updating=true;
    try {
      IFuture fut=agent.scheduleStep(new UpdateStep());
      fut.addResultListener(new SwingDefaultResultListener(){
        public void customResultAvailable(        Object source,        Object result){
          AmbrosioPanel.this.drawdata=(DrawData)result;
          updating=false;
        }
        public void customExceptionOccurred(        Object source,        Exception exception){
        }
      }
);
    }
 catch (    ComponentTerminatedException e) {
    }
  }
  if (drawdata != null) {
  }
}","/** 
 * Paint the world view.
 */
protected void paintComponent(Graphics g){
  if (!updating) {
    updating=true;
    try {
      IFuture fut=agent.scheduleStep(new UpdateStep());
      fut.addResultListener(new SwingDefaultResultListener(){
        public void customResultAvailable(        Object source,        Object result){
          AmbrosioPanel.this.drawdata=(DrawData)result;
          updating=false;
        }
        public void customExceptionOccurred(        Object source,        Exception exception){
        }
      }
);
    }
 catch (    ComponentTerminatedException e) {
    }
  }
  if (drawdata != null) {
    Rectangle bounds=getBounds();
    g.setColor(Color.lightGray);
    g.fillRect(0,0,bounds.width,bounds.height);
  }
}",0.9167270094134684
154203,"/** 
 * The plan body.
 */
public void body(){
  IDF df=(IDF)SServiceProvider.getService(getScope().getServiceProvider(),IDF.class).get(this);
  IDFServiceDescription sd=df.createDFServiceDescription(""String_Node_Str"",null,null);
  IDFComponentDescription dfadesc=df.createDFComponentDescription(null,sd);
  ISearchConstraints constraints=df.createSearchConstraints(-1,0);
  IGoal ft=createGoal(""String_Node_Str"");
  ft.getParameter(""String_Node_Str"").setValue(dfadesc);
  ft.getParameter(""String_Node_Str"").setValue(constraints);
  dispatchSubgoalAndWait(ft);
  IDFComponentDescription[] cleaners=(IDFComponentDescription[])ft.getParameterSet(""String_Node_Str"").getValues();
  while (cleaners == null || cleaners.length < CleanerLocationManager.TOTAL_CLEANERS) {
    waitFor(100);
    ft=createGoal(""String_Node_Str"");
    ft.getParameter(""String_Node_Str"").setValue(dfadesc);
    ft.getParameter(""String_Node_Str"").setValue(constraints);
    dispatchSubgoalAndWait(ft);
    cleaners=(IDFComponentDescription[])ft.getParameterSet(""String_Node_Str"").getValues();
  }
  for (int i=0; i < cleaners.length; i++) {
    IMessageEvent mevent=createMessageEvent(""String_Node_Str"");
    mevent.getParameterSet(SFipa.RECEIVERS).addValue(cleaners[i].getName());
    IMessageEvent reply=null;
    try {
      reply=sendMessageAndWait(mevent,1000);
      System.out.println(reply.toString());
      Ambrosio.cleanersStatus[i]=(String)reply.getParameter(SFipa.CONTENT).getValue();
    }
 catch (    Exception e) {
      Ambrosio.cleanersStatus[i]=Status.UNKNOWN;
    }
  }
  System.out.println(""String_Node_Str"" + Ambrosio.cleanersStatus[0] + ""String_Node_Str""+ Ambrosio.cleanersStatus[1]+ ""String_Node_Str""+ Ambrosio.cleanersStatus[2]+ ""String_Node_Str""+ Ambrosio.cleanersStatus[3]+ ""String_Node_Str"");
}","/** 
 * The plan body.
 */
public void body(){
  IDF df=(IDF)SServiceProvider.getService(getScope().getServiceProvider(),IDF.class).get(this);
  IDFServiceDescription sd=df.createDFServiceDescription(""String_Node_Str"",null,null);
  IDFComponentDescription dfadesc=df.createDFComponentDescription(null,sd);
  ISearchConstraints constraints=df.createSearchConstraints(-1,0);
  IGoal ft=createGoal(""String_Node_Str"");
  ft.getParameter(""String_Node_Str"").setValue(dfadesc);
  ft.getParameter(""String_Node_Str"").setValue(constraints);
  dispatchSubgoalAndWait(ft);
  IDFComponentDescription[] cleaners=(IDFComponentDescription[])ft.getParameterSet(""String_Node_Str"").getValues();
  while (cleaners == null || cleaners.length < CleanerLocationManager.TOTAL_CLEANERS) {
    waitFor(100);
    ft=createGoal(""String_Node_Str"");
    ft.getParameter(""String_Node_Str"").setValue(dfadesc);
    ft.getParameter(""String_Node_Str"").setValue(constraints);
    dispatchSubgoalAndWait(ft);
    cleaners=(IDFComponentDescription[])ft.getParameterSet(""String_Node_Str"").getValues();
  }
  for (int i=0; i < cleaners.length; i++) {
    IMessageEvent mevent=createMessageEvent(""String_Node_Str"");
    mevent.getParameterSet(SFipa.RECEIVERS).addValue(cleaners[i].getName());
    IMessageEvent reply=null;
    try {
      reply=sendMessageAndWait(mevent,1000);
      Ambrosio.cleanersStatus[i]=(String)reply.getParameter(SFipa.CONTENT).getValue();
    }
 catch (    Exception e) {
      Ambrosio.cleanersStatus[i]=Status.UNKNOWN;
    }
  }
  System.out.println(""String_Node_Str"" + Ambrosio.cleanersStatus[0] + ""String_Node_Str""+ Ambrosio.cleanersStatus[1]+ ""String_Node_Str""+ Ambrosio.cleanersStatus[2]+ ""String_Node_Str""+ Ambrosio.cleanersStatus[3]+ ""String_Node_Str"");
}",0.9875706214689266
154204,"public void body(){
  IMessageEvent message=(IMessageEvent)getReason();
  IMessageEvent ans=getEventbase().createReply(message,""String_Node_Str"");
  double dice=Math.random();
  if (dice < 0.95) {
    ans.getParameter(SFipa.CONTENT).setValue(Status.OK);
  }
 else   if (0.95 <= dice && dice < 1.0) {
    ans.getParameter(SFipa.CONTENT).setValue(Status.ERROR);
  }
 else {
    ans.getParameter(SFipa.CONTENT).setValue(Status.OFFLINE);
  }
  sendMessage(ans);
}","public void body(){
  IMessageEvent message=(IMessageEvent)getReason();
  IMessageEvent ans=getEventbase().createReply(message,""String_Node_Str"");
  double dice=Math.random();
  if (dice < 1.0) {
    ans.getParameter(SFipa.CONTENT).setValue(Status.OK);
  }
 else   if (1.0 <= dice && dice < 1.0) {
    ans.getParameter(SFipa.CONTENT).setValue(Status.ERROR);
  }
 else {
    ans.getParameter(SFipa.CONTENT).setValue(Status.OFFLINE);
  }
  sendMessage(ans);
}",0.9890829694323144
154205,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  try {
    SAXParser parser=SAXParserFactory.newInstance().newSAXParser();
    PicasaHandler picasaHandler=new PicasaHandler();
    URL picasaFeed=new URL(""String_Node_Str"");
    parser.parse(picasaFeed.openStream(),picasaHandler);
    PicasaAlbum album=picasaHandler.getParsedAlbum();
    Log.d(""String_Node_Str"",""String_Node_Str"" + album.getAlbumImages().size() + ""String_Node_Str""+ album.getTitle()+ ""String_Node_Str""+ album.getAuthor());
  }
 catch (  SAXException saxException) {
    saxException.printStackTrace();
  }
catch (  MalformedURLException murlException) {
    murlException.printStackTrace();
  }
catch (  IOException ioe) {
    ioe.printStackTrace();
  }
catch (  ParserConfigurationException pce) {
    pce.printStackTrace();
  }
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  try {
    SAXParser parser=SAXParserFactory.newInstance().newSAXParser();
    PicasaHandler picasaHandler=new PicasaHandler();
    URL picasaFeed=new URL(""String_Node_Str"");
    parser.parse(picasaFeed.openStream(),picasaHandler);
    PicasaAlbum album=picasaHandler.getParsedAlbum();
    Log.d(""String_Node_Str"",""String_Node_Str"" + album.getAlbumImages().size() + ""String_Node_Str""+ album.getTitle()+ ""String_Node_Str""+ album.getAuthor());
    ImageAlbumDatabaseHelper databaseHelper=new ImageAlbumDatabaseHelper(getApplicationContext());
    PicasaAlbumManager albumManager=databaseHelper.getAlbumManager();
    long albumId=albumManager.addAlbum(album);
    if (albumId > 0) {
      Log.d(getClass().toString(),""String_Node_Str"");
    }
 else {
      Log.e(getClass().toString(),""String_Node_Str"");
      Log.e(getClass().toString(),""String_Node_Str"");
      System.exit(1);
    }
  }
 catch (  SAXException saxException) {
    saxException.printStackTrace();
  }
catch (  MalformedURLException murlException) {
    murlException.printStackTrace();
  }
catch (  IOException ioe) {
    ioe.printStackTrace();
  }
catch (  ParserConfigurationException pce) {
    pce.printStackTrace();
  }
}",0.8088044885627967
154206,"/** 
 * @return the primary key for the stored album or-1 if it failed
 */
protected long addAlbum(PicasaAlbum album){
  ContentValues values=new ContentValues();
  values.put(TITLE,album.getTitle());
  values.put(AUTHOR,album.getAuthor());
  values.put(PUB_DATE,album.getCreatedDate().toGMTString());
  long albumId=db.insert(ALBUM_TABLE,TITLE,values);
  if (albumId > 0 && album.getAlbumImages().size() > 0) {
    PicasaImageManager imageTable=new PicasaImageManager(this.db);
    ImageAlbumRelationshipManager imageAlbumRelationships=new ImageAlbumRelationshipManager(this.db);
    for (    PicasaImage image : album.getAlbumImages()) {
      long imageId=imageTable.addOrUpdateImage(image);
      boolean storedNewRelation=imageAlbumRelationships.addImageAlbumRelation(albumId,imageId);
      if (!storedNewRelation) {
        Log.e(""String_Node_Str"",""String_Node_Str"" + album.getTitle() + ""String_Node_Str""+ image.getThumbnailLocation());
        Log.e(""String_Node_Str"",""String_Node_Str"");
        System.exit(1);
      }
    }
  }
  return albumId;
}","/** 
 * @return the primary key for the stored album or-1 if it failed
 */
public long addAlbum(PicasaAlbum album){
  ContentValues values=new ContentValues();
  values.put(TITLE,album.getTitle());
  values.put(AUTHOR,album.getAuthor());
  values.put(PUB_DATE,album.getCreatedDate().toGMTString());
  long albumId=db.insert(ALBUM_TABLE,TITLE,values);
  if (albumId > 0 && album.getAlbumImages().size() > 0) {
    PicasaImageManager imageTable=new PicasaImageManager(this.db);
    ImageAlbumRelationshipManager imageAlbumRelationships=new ImageAlbumRelationshipManager(this.db);
    for (    PicasaImage image : album.getAlbumImages()) {
      long imageId=imageTable.addOrUpdateImage(image);
      boolean storedNewRelation=imageAlbumRelationships.addImageAlbumRelation(albumId,imageId);
      if (!storedNewRelation) {
        Log.e(""String_Node_Str"",""String_Node_Str"" + album.getTitle() + ""String_Node_Str""+ image.getThumbnailLocation());
        Log.e(""String_Node_Str"",""String_Node_Str"");
        System.exit(1);
      }
    }
  }
  return albumId;
}",0.994789199431549
154207,"private PicasaImage createImageFromCursor(Cursor cursor){
  PicasaImage image=new PicasaImage();
  image.setTitle(cursor.getString(cursor.getColumnIndex(TITLE)));
  image.setAuthor(cursor.getString(cursor.getColumnIndex(AUTHOR)));
  image.setPublicationDate(Date.valueOf(cursor.getString(cursor.getColumnIndex(PUB_DATE))));
  byte[] imageBytes=cursor.getBlob(cursor.getColumnIndex(IMAGE));
  image.setImage(BitmapFactory.decodeByteArray(imageBytes,0,imageBytes.length));
  byte[] thumbnailBytes=cursor.getBlob(cursor.getColumnIndex(IMAGE_THUMBNAIL));
  image.setThumbnail(BitmapFactory.decodeByteArray(thumbnailBytes,0,thumbnailBytes.length));
  return image;
}","private PicasaImage createImageFromCursor(Cursor cursor){
  PicasaImage image=new PicasaImage();
  image.setTitle(cursor.getString(cursor.getColumnIndex(TITLE)));
  image.setAuthor(cursor.getString(cursor.getColumnIndex(AUTHOR)));
  image.setPublicationDate(Date.valueOf(cursor.getString(cursor.getColumnIndex(PUB_DATE))));
  byte[] imageBytes=cursor.getBlob(cursor.getColumnIndex(IMAGE));
  image.setImageBytes(imageBytes);
  byte[] thumbnailBytes=cursor.getBlob(cursor.getColumnIndex(IMAGE_THUMBNAIL));
  image.setThumbnailBytes(thumbnailBytes);
  return image;
}",0.8874388254486134
154208,"protected long addImage(PicasaImage image){
  ContentValues values=new ContentValues();
  values.put(TITLE,image.getTitle());
  values.put(AUTHOR,image.getAuthor());
  values.put(PUB_DATE,image.getPublicationDate().toGMTString());
  if (image.getThumbnail() != null) {
    values.put(IMAGE_THUMBNAIL,compressToPNGBytes(image.getThumbnail()));
  }
  if (image.getImage() != null) {
    values.put(IMAGE,compressToPNGBytes(image.getImage()));
  }
  return db.insert(IMAGE_TABLE,TITLE,values);
}","protected long addImage(PicasaImage image){
  ContentValues values=new ContentValues();
  values.put(TITLE,image.getTitle());
  values.put(AUTHOR,image.getAuthor());
  values.put(PUB_DATE,image.getPublicationDate().toGMTString());
  values.put(IMAGE_THUMBNAIL,image.getThumbnailBytes());
  values.put(IMAGE,image.getImageBytes());
  return db.insert(IMAGE_TABLE,TITLE,values);
}",0.7241379310344828
154209,"public Bitmap getThumbnail(){
  return thumbnail;
}","public Bitmap getThumbnail(){
  if (thumbnail == null && thumbnailLocation != null) {
    getThumbnailBytes();
    thumbnail=BitmapFactory.decodeByteArray(thumbnailBytes,0,thumbnailBytes.length);
  }
  return thumbnail;
}",0.2573529411764705
154210,"public Bitmap getImage(){
  return image;
}","public Bitmap getImage(){
  if (image == null && imageLocation != null) {
    getImageBytes();
    image=BitmapFactory.decodeByteArray(imageBytes,0,imageBytes.length);
  }
  return image;
}",0.3706896551724138
154211,"private Integer maxScore(Role role,MachineState state,int alpha,int beta,int depth) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=Canonicalizer.stateString(state);
  Integer cacheValue;
  if (externalCache != null && (cacheValue=externalCache.get(stateString)) != null) {
    extCacheHit++;
    return cacheValue;
  }
  String alphaBetaStateString=Canonicalizer.stateStringAlphaBeta(stateString,alpha,beta);
  if (useCaching && (cacheValue=maxStateScores.get(alphaBetaStateString)) != null) {
    maxCacheHit++;
    return cacheValue;
  }
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  boolean heuristicUsed=false, nullValueReturned=false;
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (depth > maxDepth) {
    heuristicUsed=true;
    if (heuristic != null && moves.size() > 1) {
      Integer value=heuristic.getScore(state,role);
      if (value != null)       return -value;
      return null;
    }
 else {
      return null;
    }
  }
 else {
    for (    Move move : moves) {
      if (stopExecution) {
        break;
      }
      Integer value=minScore(role,move,state,alpha,beta,depth);
      if (value != null) {
        int testValue=value;
        if (value < 0) {
          testValue=-testValue;
          heuristicUsed=true;
        }
        if (testValue > bestValue)         bestValue=testValue;
        alpha=Math.max(alpha,bestValue);
        if (alpha >= beta) {
          bestValue=alpha;
          break;
        }
      }
 else {
        nullValueReturned=true;
      }
    }
    if (bestValue == 0 && nullValueReturned)     return null;
    if (bestValue == Integer.MIN_VALUE)     return null;
    if (!stopExecution && !heuristicUsed)     maxStateScores.put(alphaBetaStateString,bestValue);
    return heuristicUsed ? -bestValue : bestValue;
  }
}","private Integer maxScore(Role role,MachineState state,int alpha,int beta,int depth) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=Canonicalizer.stateString(state);
  Integer cacheValue;
  if (externalCache != null && (cacheValue=externalCache.get(stateString)) != null) {
    extCacheHit++;
    return cacheValue;
  }
  String alphaBetaStateString=Canonicalizer.stateStringAlphaBeta(stateString,alpha,beta);
  if (useCaching && (cacheValue=maxStateScores.get(alphaBetaStateString)) != null) {
    maxCacheHit++;
    return cacheValue;
  }
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  boolean heuristicUsed=false, nullValueReturned=false;
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (depth > maxDepth) {
    heuristicUsed=true;
    if (heuristic != null) {
      Integer value=heuristic.getScore(state,role);
      if (value != null)       return -value;
      return null;
    }
 else {
      return null;
    }
  }
 else {
    for (    Move move : moves) {
      if (stopExecution) {
        break;
      }
      Integer value=minScore(role,move,state,alpha,beta,depth);
      if (value != null) {
        int testValue=value;
        if (value < 0) {
          testValue=-testValue;
          heuristicUsed=true;
        }
        if (testValue > bestValue)         bestValue=testValue;
        alpha=Math.max(alpha,bestValue);
        if (alpha >= beta) {
          bestValue=alpha;
          break;
        }
      }
 else {
        nullValueReturned=true;
      }
    }
    if (bestValue == 0 && nullValueReturned)     return null;
    if (bestValue == Integer.MIN_VALUE)     return null;
    if (!stopExecution && !heuristicUsed)     maxStateScores.put(alphaBetaStateString,bestValue);
    return heuristicUsed ? -bestValue : bestValue;
  }
}",0.9949264332825976
154212,"public void updateState(MachineState state,List<Move> moves){
  for (  Proposition p : basePropositions.values()) {
    p.setValue(false);
  }
  for (  GdlSentence s : state.getContents()) {
    basePropositions.get(s.toTerm()).setValue(true);
  }
  for (  Proposition p : inputPropositions.values()) {
    p.setValue(false);
  }
  if (moves != null) {
    List<GdlTerm> does=toDoes(moves);
    for (    GdlTerm term : does) {
      Proposition p=inputPropositions.get(term);
      p.setValue(true);
    }
  }
  initProposition.setValue(false);
  for (  Proposition p : ordering) {
    if (p.getInputs().size() == 1) {
      p.setValue(p.getSingleInput().getValue());
    }
  }
  if (moves != null)   savedState=null;
 else   savedState=state;
}","public void updateState(MachineState state,List<Move> moves){
  if (savedState == null || state != savedState) {
    for (    Proposition p : basePropositions.values()) {
      p.setValue(false);
    }
    for (    GdlSentence s : state.getContents()) {
      basePropositions.get(s.toTerm()).setValue(true);
    }
  }
  for (  Proposition p : inputPropositions.values()) {
    p.setValue(false);
  }
  if (moves != null) {
    List<GdlTerm> does=toDoes(moves);
    for (    GdlTerm term : does) {
      Proposition p=inputPropositions.get(term);
      p.setValue(true);
    }
  }
  initProposition.setValue(false);
  for (  Proposition p : ordering) {
    if (p.getInputs().size() == 1) {
      p.setValue(p.getSingleInput().getValue());
    }
  }
  if (moves != null)   savedState=null;
 else   savedState=state;
}",0.9417040358744396
154213,"/** 
 * Returns the initial state. The initial state can be computed by only setting the truth value of the INIT proposition to true, and then computing the resulting state.
 */
@Override public MachineState getInitialState(){
  for (  Proposition p : propNet.getInputPropositions().values()) {
    p.setValue(false);
  }
  for (  Proposition p : propNet.getBasePropositions().values()) {
    p.setValue(false);
  }
  propNet.getInitProposition().setValue(true);
  for (  Proposition p : ordering) {
    if (p.getInputs().size() == 1) {
      p.setValue(p.getSingleInput().getValue());
    }
  }
  return getStateFromBase();
}","/** 
 * Returns the initial state. The initial state can be computed by only setting the truth value of the INIT proposition to true, and then computing the resulting state.
 */
@Override public MachineState getInitialState(){
  for (  Proposition p : inputPropositions.values()) {
    p.setValue(false);
  }
  for (  Proposition p : basePropositions.values()) {
    p.setValue(false);
  }
  propNet.getInitProposition().setValue(true);
  for (  Proposition p : ordering) {
    if (p.getInputs().size() == 1) {
      p.setValue(p.getSingleInput().getValue());
    }
  }
  return getStateFromBase();
}",0.9755301794453508
154214,"/** 
 * This should compute the topological ordering of propositions. Each component is either a proposition, logical gate, or transition. Logical gates and transitions only have propositions as inputs. The base propositions and input propositions should always be exempt from this ordering. The base propositions values are set from the MachineState that operations are performed on and the input propositions are set from the Moves that operations are performed on as well (if any).
 * @return The order in which the truth values of propositions need to be set.
 */
public List<Proposition> getOrdering(){
  List<Proposition> order=new LinkedList<Proposition>();
  List<Proposition> propositions=new ArrayList<Proposition>(propNet.getPropositions());
  Set<Proposition> visitedPropositions=new HashSet<Proposition>();
  Set<Proposition> unvisitedPropositions=new HashSet<Proposition>();
  visitedPropositions.addAll(basePropositions.values());
  visitedPropositions.addAll(inputPropositions.values());
  visitedPropositions.add(propNet.getInitProposition());
  unvisitedPropositions.addAll(propositions);
  unvisitedPropositions.removeAll(visitedPropositions);
  while (!unvisitedPropositions.isEmpty()) {
    Proposition nextProposition=null;
    for (    Proposition unvisitedProp : unvisitedPropositions) {
      Set<Proposition> inputs=new HashSet<Proposition>();
      Set<Component> toCheck=new HashSet<Component>();
      toCheck.add(unvisitedProp);
      while (!toCheck.isEmpty()) {
        Component comp=toCheck.iterator().next();
        for (        Component input : comp.getInputs()) {
          if (input instanceof Proposition)           inputs.add((Proposition)input);
 else           toCheck.add(input);
        }
      }
      if (visitedPropositions.containsAll(inputs)) {
        nextProposition=unvisitedProp;
        break;
      }
    }
    visitedPropositions.add(nextProposition);
    unvisitedPropositions.remove(nextProposition);
    order.add(nextProposition);
  }
  return order;
}","/** 
 * This should compute the topological ordering of propositions. Each component is either a proposition, logical gate, or transition. Logical gates and transitions only have propositions as inputs. The base propositions and input propositions should always be exempt from this ordering. The base propositions values are set from the MachineState that operations are performed on and the input propositions are set from the Moves that operations are performed on as well (if any).
 * @return The order in which the truth values of propositions need to be set.
 */
public List<Proposition> getOrdering(){
  List<Proposition> order=new LinkedList<Proposition>();
  List<Proposition> propositions=new ArrayList<Proposition>(propNet.getPropositions());
  Set<Proposition> visitedPropositions=new HashSet<Proposition>();
  Set<Proposition> unvisitedPropositions=new HashSet<Proposition>();
  visitedPropositions.addAll(basePropositions.values());
  visitedPropositions.addAll(inputPropositions.values());
  visitedPropositions.add(propNet.getInitProposition());
  unvisitedPropositions.addAll(propositions);
  unvisitedPropositions.removeAll(visitedPropositions);
  while (!unvisitedPropositions.isEmpty()) {
    Proposition nextProposition=null;
    for (    Proposition unvisitedProp : unvisitedPropositions) {
      Set<Proposition> inputs=new HashSet<Proposition>();
      Set<Component> toCheck=new HashSet<Component>();
      toCheck.add(unvisitedProp);
      while (!toCheck.isEmpty()) {
        Component comp=toCheck.iterator().next();
        toCheck.remove(comp);
        for (        Component input : comp.getInputs()) {
          if (input instanceof Proposition)           inputs.add((Proposition)input);
 else           toCheck.add(input);
        }
      }
      if (visitedPropositions.containsAll(inputs)) {
        nextProposition=unvisitedProp;
        break;
      }
    }
    visitedPropositions.add(nextProposition);
    unvisitedPropositions.remove(nextProposition);
    order.add(nextProposition);
  }
  return order;
}",0.917200591424347
154215,"/** 
 * Computes if the state is terminal. Should return the value of the terminal proposition for the state.
 */
@Override public boolean isTerminal(MachineState state){
  if (savedState != state)   updateState(state,null);
  System.out.println(""String_Node_Str"" + getStateFromBase());
  return terminalProposition.getValue();
}","/** 
 * Computes if the state is terminal. Should return the value of the terminal proposition for the state.
 */
@Override public boolean isTerminal(MachineState state){
  if (savedState != state)   updateState(state,null);
  return terminalProposition.getValue();
}",0.8959731543624161
154216,"/** 
 * Computes the legal moves for role in state.
 */
@Override public List<Move> getLegalMoves(MachineState state,Role role) throws MoveDefinitionException {
  System.out.println(""String_Node_Str"" + state);
  System.out.println(""String_Node_Str"" + getStateFromBase());
  if (savedState != state)   updateState(state,null);
  List<Move> moves=new ArrayList<Move>();
  for (  Proposition p : legalPropositions.get(role)) {
    System.out.println(""String_Node_Str"" + p);
    if (p.getValue()) {
      moves.add(getMoveFromProposition(p));
    }
  }
  System.out.println(""String_Node_Str"" + getStateFromBase());
  return moves;
}","/** 
 * Computes the legal moves for role in state.
 */
@Override public List<Move> getLegalMoves(MachineState state,Role role) throws MoveDefinitionException {
  if (savedState != state)   updateState(state,null);
  List<Move> moves=new ArrayList<Move>();
  for (  Proposition p : legalPropositions.get(role)) {
    if (p.getValue()) {
      moves.add(getMoveFromProposition(p));
    }
  }
  return moves;
}",0.7644787644787645
154217,"/** 
 * Computes the goal for a role in the current state. Should return the value of the goal proposition that is true for that role. If there is not exactly one goal proposition true for that role, then you should throw a GoalDefinitionException because the goal is ill-defined. 
 */
@Override public int getGoal(MachineState state,Role role) throws GoalDefinitionException {
  if (savedState != state)   updateState(state,null);
  Integer goalValue=null;
  for (  Proposition p : goalPropositions.get(role)) {
    if (p.getValue()) {
      if (goalValue != null)       throw new GoalDefinitionException(state,role);
    }
    goalValue=getGoalValue(p);
  }
  if (goalValue == null)   throw new GoalDefinitionException(state,role);
  System.out.println(""String_Node_Str"" + getStateFromBase());
  return goalValue;
}","/** 
 * Computes the goal for a role in the current state. Should return the value of the goal proposition that is true for that role. If there is not exactly one goal proposition true for that role, then you should throw a GoalDefinitionException because the goal is ill-defined. 
 */
@Override public int getGoal(MachineState state,Role role) throws GoalDefinitionException {
  if (savedState != state)   updateState(state,null);
  Integer goalValue=null;
  for (  Proposition p : goalPropositions.get(role)) {
    if (p.getValue()) {
      if (goalValue != null) {
        throw new GoalDefinitionException(state,role);
      }
      goalValue=getGoalValue(p);
    }
  }
  if (goalValue == null)   throw new GoalDefinitionException(state,role);
  return goalValue;
}",0.931904161412358
154218,"/** 
 * Computes the next state given state and the list of moves.
 */
@Override public MachineState getNextState(MachineState state,List<Move> moves) throws TransitionDefinitionException {
  updateState(state,moves);
  System.out.println(""String_Node_Str"" + getStateFromBase());
  return getStateFromBase();
}","/** 
 * Computes the next state given state and the list of moves.
 */
@Override public MachineState getNextState(MachineState state,List<Move> moves) throws TransitionDefinitionException {
  updateState(state,moves);
  return getStateFromBase();
}",0.8888888888888888
154219,"/** 
 * Initializes the PropNetStateMachine. You should compute the topological ordering here. Additionally you may compute the initial state here, at your discretion.
 */
@Override public void initialize(List<Gdl> description){
  propNet=CachedPropNetFactory.create(description);
  propNet.renderToFile(""String_Node_Str"");
  roles=propNet.getRoles();
  savedState=null;
  inputPropositions=propNet.getInputPropositions();
  basePropositions=propNet.getBasePropositions();
  legalPropositions=propNet.getLegalPropositions();
  goalPropositions=propNet.getGoalPropositions();
  initProposition=propNet.getInitProposition();
  terminalProposition=propNet.getTerminalProposition();
  ordering=getOrdering();
  System.out.println(""String_Node_Str"");
  for (  Component c : ordering) {
    System.out.println(c);
  }
}","/** 
 * Initializes the PropNetStateMachine. You should compute the topological ordering here. Additionally you may compute the initial state here, at your discretion.
 */
@Override public void initialize(List<Gdl> description){
  propNet=OptimizingPropNetFactory.create(description);
  propNet.renderToFile(new File(System.getProperty(""String_Node_Str""),""String_Node_Str"").toString());
  roles=propNet.getRoles();
  savedState=null;
  inputPropositions=propNet.getInputPropositions();
  basePropositions=propNet.getBasePropositions();
  legalPropositions=propNet.getLegalPropositions();
  goalPropositions=propNet.getGoalPropositions();
  initProposition=propNet.getInitProposition();
  terminalProposition=propNet.getTerminalProposition();
  ordering=getOrdering();
  System.out.println(""String_Node_Str"");
  for (  Component c : ordering) {
    System.out.println(c);
  }
}",0.3161634103019538
154220,"/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new ProverStateMachine();
}","/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}",0.9516728624535316
154221,"/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new ProverStateMachine();
}","/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}",0.9516728624535316
154222,"@Override public void stateMachineMetaGame(long timeout) throws TransitionDefinitionException, MoveDefinitionException, GoalDefinitionException {
  strategy=new IDSAlphaBeta(getStateMachine());
  metaStrategy=new MonteCarloMiniMax(getStateMachine(),5);
  metaStrategy.getBestMove(getCurrentState(),getRole(),timeout);
  strategy.setExternalCache(((MonteCarloMiniMax)metaStrategy).maxStateScores);
  AbstractHeuristic heuristic=new MonteCarlo(getStateMachine());
  ((MonteCarlo)heuristic).setSampleSize(3);
  strategy.setHeuristic(heuristic);
}","@Override public void stateMachineMetaGame(long timeout) throws TransitionDefinitionException, MoveDefinitionException, GoalDefinitionException {
  strategy=new IDSAlphaBeta(getStateMachine());
  metaStrategy=new MonteCarloMiniMax(getStateMachine(),5);
  metaStrategy.getBestMove(getCurrentState(),getRole(),timeout);
  strategy.setExternalCache(((MonteCarloMiniMax)metaStrategy).maxStateScores);
  AbstractHeuristic heuristic=new MonteCarlo(getStateMachine());
  ((MonteCarlo)heuristic).setSampleSize(5);
  strategy.setHeuristic(heuristic);
}",0.998158379373849
154223,"/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new ProverStateMachine();
}","/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}",0.9516728624535316
154224,"@Override public void stateMachineMetaGame(long timeout) throws TransitionDefinitionException, MoveDefinitionException, GoalDefinitionException {
  strategy=new AlphaBeta(getStateMachine(),3);
  strategy.setHeuristic(new MonteCarlo(getStateMachine()));
}","@Override public void stateMachineMetaGame(long timeout) throws TransitionDefinitionException, MoveDefinitionException, GoalDefinitionException {
  strategy=new IDSAlphaBeta(getStateMachine());
  AbstractHeuristic heuristic=new MonteCarlo(getStateMachine());
  ((MonteCarlo)heuristic).setSampleSize(5);
  strategy.setHeuristic(heuristic);
}",0.7373737373737373
154225,"/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new ProverStateMachine();
}","/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}",0.9516728624535316
154226,"/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}","@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}",0.8416666666666667
154227,"/** 
 * Computes if the state is terminal. Should return the value of the terminal proposition for the state.
 */
@Override public boolean isTerminal(MachineState state){
  return propNet.getTerminalProposition().getValue();
}","/** 
 * Computes if the state is terminal. Should return the value of the terminal proposition for the state.
 */
@Override public boolean isTerminal(MachineState state){
  updateState(state,null);
  return propNet.getTerminalProposition().getValue();
}",0.9436325678496869
154228,"/** 
 * Computes the legal moves for role in state.
 */
@Override public List<Move> getLegalMoves(MachineState state,Role role) throws MoveDefinitionException {
  List<Move> moves=new ArrayList<Move>();
  Set<Proposition> legalPropositions=propNet.getLegalPropositions().get(role);
  while (legalPropositions.iterator().hasNext()) {
    Proposition p=legalPropositions.iterator().next();
    moves.add(DumplingPropNetStateMachine.getMoveFromProposition(p));
  }
  return moves;
}","/** 
 * Computes the legal moves for role in state.
 */
@Override public List<Move> getLegalMoves(MachineState state,Role role) throws MoveDefinitionException {
  updateState(state,null);
  List<Move> moves=new ArrayList<Move>();
  for (  Proposition p : propNet.getLegalPropositions().get(role)) {
    if (p.getValue()) {
      moves.add(getMoveFromProposition(p));
    }
  }
  return moves;
}",0.6712485681557846
154229,"/** 
 * Computes the goal for a role in the current state. Should return the value of the goal proposition that is true for that role. If there is not exactly one goal proposition true for that role, then you should throw a GoalDefinitionException because the goal is ill-defined. 
 */
@Override public int getGoal(MachineState state,Role role) throws GoalDefinitionException {
  Set<Proposition> goalPropositions=propNet.getGoalPropositions().get(role);
  if (goalPropositions.size() != 1)   throw new GoalDefinitionException(state,role);
  return getGoalValue(goalPropositions.iterator().next());
}","/** 
 * Computes the goal for a role in the current state. Should return the value of the goal proposition that is true for that role. If there is not exactly one goal proposition true for that role, then you should throw a GoalDefinitionException because the goal is ill-defined. 
 */
@Override public int getGoal(MachineState state,Role role) throws GoalDefinitionException {
  updateState(state,null);
  Integer goalValue=null;
  for (  Proposition p : propNet.getGoalPropositions().get(role)) {
    if (p.getValue()) {
      if (goalValue != null)       throw new GoalDefinitionException(state,role);
    }
    goalValue=getGoalValue(p);
  }
  if (goalValue == null)   throw new GoalDefinitionException(state,role);
  return goalValue;
}",0.7293064876957495
154230,"/** 
 * Computes the next state given state and the list of moves.
 */
@Override public MachineState getNextState(MachineState state,List<Move> moves) throws TransitionDefinitionException {
  List<GdlTerm> does=toDoes(moves);
  Map<GdlTerm,Proposition> inputs=propNet.getInputPropositions();
  for (  Proposition p : inputs.values()) {
    p.setValue(false);
  }
  for (  GdlTerm term : does) {
    Proposition p=inputs.get(term);
    p.setValue(true);
  }
  for (  Proposition p : ordering) {
    if (p.getInputs().size() == 1) {
      p.setValue(p.getSingleInput().getValue());
    }
  }
  return getStateFromBase();
}","/** 
 * Computes the next state given state and the list of moves.
 */
@Override public MachineState getNextState(MachineState state,List<Move> moves) throws TransitionDefinitionException {
  updateState(state,moves);
  return getStateFromBase();
}",0.488479262672811
154231,"/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new ProverStateMachine();
}","/** 
 * Uses a ProverStateMachine
 */
@Override public StateMachine getInitialStateMachine(){
  return new DumplingPropNetStateMachine();
}",0.9516728624535316
154232,"@Override public void stateMachineMetaGame(long timeout) throws TransitionDefinitionException, MoveDefinitionException, GoalDefinitionException {
  strategy=new MiniMax(getStateMachine());
  strategy.enableCache(false);
}","@Override public void stateMachineMetaGame(long timeout) throws TransitionDefinitionException, MoveDefinitionException, GoalDefinitionException {
  strategy=new MiniMax(getStateMachine());
}",0.924574209245742
154233,"private int minScore(Role role,Move move,MachineState state,int alpha,int beta) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  int worstScore=Integer.MAX_VALUE;
  String stateString=canonicalizeStateString(state);
  String moveString=move.toString();
  Map<String,Integer> stateMoveScores=minStateScores.get(stateString);
  if (useCaching && stateMoveScores != null && stateMoveScores.get(moveString) != null)   return stateMoveScores.get(moveString);
  List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
  for (  List<Move> jointMove : allJointMoves) {
    MachineState newState=stateMachine.getNextState(state,jointMove);
    int newScore=maxScore(role,newState,alpha,beta);
    if (newScore < worstScore)     worstScore=newScore;
    beta=Math.min(beta,worstScore);
    if (beta <= alpha) {
      worstScore=beta;
      break;
    }
  }
  if (stateMoveScores == null)   minStateScores.put(stateString,(stateMoveScores=new HashMap<String,Integer>()));
  stateMoveScores.put(moveString,worstScore);
  return worstScore;
}","private int minScore(Role role,Move move,MachineState state,int alpha,int beta) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  int worstScore=Integer.MAX_VALUE;
  String stateString=canonicalizeStateString(state,alpha,beta);
  String moveString=move.toString();
  Map<String,Integer> stateMoveScores=minStateScores.get(stateString);
  if (useCaching && stateMoveScores != null && stateMoveScores.get(moveString) != null)   return stateMoveScores.get(moveString);
  List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
  for (  List<Move> jointMove : allJointMoves) {
    MachineState newState=stateMachine.getNextState(state,jointMove);
    int newScore=maxScore(role,newState,alpha,beta);
    if (newScore < worstScore)     worstScore=newScore;
    beta=Math.min(beta,worstScore);
    if (beta <= alpha) {
      worstScore=beta;
      break;
    }
  }
  if (stateMoveScores == null)   minStateScores.put(stateString,(stateMoveScores=new HashMap<String,Integer>()));
  stateMoveScores.put(moveString,worstScore);
  return worstScore;
}",0.9950068088969588
154234,"private String canonicalizeStateString(MachineState state){
  Set<String> sortedStateContents=new TreeSet<String>();
  for (  GdlSentence gdl : state.getContents())   sortedStateContents.add(gdl.toString());
  return sortedStateContents.toString();
}","private String canonicalizeStateString(MachineState state,int alpha,int beta){
  Set<String> sortedStateContents=new TreeSet<String>();
  for (  GdlSentence gdl : state.getContents()) {
    sortedStateContents.add(gdl.toString());
  }
  return alpha + ""String_Node_Str"" + beta+ ""String_Node_Str""+ sortedStateContents.toString();
}",0.8620689655172413
154235,"public AlphaBeta(StateMachine sm){
  super(sm);
  maxStateScores=new HashMap<String,Integer>();
  minStateScores=new HashMap<String,Map<String,Integer>>();
  t=new Timer(0,TimeoutHandler);
  t.setRepeats(false);
}","public AlphaBeta(StateMachine sm){
  super(sm);
  maxStateScores=new HashMap<String,Integer>();
  minStateScores=new HashMap<String,Map<String,Integer>>();
}",0.8486486486486486
154236,"public Move getBestMove(MachineState state,Role role,long timeout) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  t.setDelay((int)timeout);
  if (t.isRunning())   t.restart();
 else   t.start();
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (moves.size() == 1)   return moves.get(0);
 else {
    Move bestMove=null;
    int bestValue=Integer.MIN_VALUE;
    for (    Move move : moves) {
      int value=minScore(role,move,state,Integer.MIN_VALUE,Integer.MAX_VALUE);
      if (value > bestValue) {
        bestValue=value;
        bestMove=move;
      }
    }
    System.out.println(""String_Node_Str"" + bestValue);
    return bestMove;
  }
}","public Move getBestMove(MachineState state,Role role,long timeout) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  t=new Timer((int)(timeout - System.currentTimeMillis()),TimeoutHandler);
  t.setRepeats(false);
  t.start();
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (moves.size() == 1) {
    System.out.println(""String_Node_Str"");
    return moves.get(0);
  }
 else {
    Move bestMove=null;
    int bestValue=Integer.MIN_VALUE;
    numStatesExpanded=1;
    for (    Move move : moves) {
      int value=minScore(role,move,state,Integer.MIN_VALUE,Integer.MAX_VALUE);
      if (value > bestValue) {
        bestValue=value;
        bestMove=move;
      }
    }
    System.out.println(""String_Node_Str"" + bestValue);
    System.out.println(""String_Node_Str"" + numStatesExpanded + ""String_Node_Str"");
    return bestMove;
  }
}",0.8007542426147077
154237,"private int maxScore(Role role,MachineState state,int alpha,int beta) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state))   return stateMachine.getGoal(state,role);
  String stateString=canonicalizeStateString(state);
  if (useCaching && maxStateScores.get(stateString) != null)   return maxStateScores.get(stateString);
  int bestValue=Integer.MIN_VALUE;
  for (  Move move : stateMachine.getLegalMoves(state,role)) {
    int value=minScore(role,move,state,alpha,beta);
    if (value > bestValue)     bestValue=value;
    alpha=Math.max(alpha,bestValue);
    if (alpha >= beta) {
      bestValue=alpha;
      break;
    }
  }
  maxStateScores.put(stateString,bestValue);
  return bestValue;
}","private int maxScore(Role role,MachineState state,int alpha,int beta) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=canonicalizeStateString(state,alpha,beta);
  if (useCaching && maxStateScores.get(stateString) != null)   return maxStateScores.get(stateString);
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  for (  Move move : stateMachine.getLegalMoves(state,role)) {
    int value=minScore(role,move,state,alpha,beta);
    if (value > bestValue)     bestValue=value;
    alpha=Math.max(alpha,bestValue);
    if (alpha >= beta) {
      bestValue=alpha;
      break;
    }
  }
  maxStateScores.put(stateString,bestValue);
  return bestValue;
}",0.958203368683718
154238,"public Move getBestMove(MachineState state,Role role,long timeout) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  System.out.println(""String_Node_Str"");
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (moves.size() == 1) {
    System.out.println(""String_Node_Str"");
    return moves.get(0);
  }
 else {
    Move bestMove=null;
    int bestValue=Integer.MIN_VALUE;
    numStatesExpanded=1;
    for (    Move move : moves) {
      int value=minScore(role,move,state);
      if (value > bestValue) {
        bestValue=value;
        bestMove=move;
      }
    }
    System.out.println(""String_Node_Str"" + numStatesExpanded + ""String_Node_Str"");
    return bestMove;
  }
}","public Move getBestMove(MachineState state,Role role,long timeout) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  System.out.println(""String_Node_Str"");
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (moves.size() == 1) {
    System.out.println(""String_Node_Str"");
    return moves.get(0);
  }
 else {
    Move bestMove=null;
    int bestValue=Integer.MIN_VALUE;
    numStatesExpanded=1;
    for (    Move move : moves) {
      int value=minScore(role,move,state);
      if (value > bestValue) {
        bestValue=value;
        bestMove=move;
      }
    }
    System.out.println(""String_Node_Str"" + bestValue + ""String_Node_Str""+ ""String_Node_Str""+ numStatesExpanded+ ""String_Node_Str"");
    return bestMove;
  }
}",0.9661129568106313
154239,"public void setHeuristic(PlayerHeuristic heuristic){
  this.heuristic=heuristic;
}","public void setHeuristic(AbstractHeuristic heuristic){
  this.heuristic=heuristic;
}",0.927710843373494
154240,"private int maxScore(Role role,MachineState state,int alpha,int beta,int depth) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=canonicalizeStateString(state,alpha,beta);
  if (useCaching && maxStateScores.get(stateString) != null)   return maxStateScores.get(stateString);
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  if (depth > maxDepth) {
    if (heuristic != null) {
      Integer value=heuristic.getScore(state,role);
      if (value != null)       return value;
    }
 else {
      return Integer.MIN_VALUE;
    }
  }
 else {
    for (    Move move : stateMachine.getLegalMoves(state,role)) {
      if (stopExecution) {
        break;
      }
      int value=minScore(role,move,state,alpha,beta,depth);
      if (value > bestValue)       bestValue=value;
      alpha=Math.max(alpha,bestValue);
      if (alpha >= beta) {
        bestValue=alpha;
        break;
      }
    }
    if (!stopExecution)     maxStateScores.put(stateString,bestValue);
  }
  return bestValue;
}","private int maxScore(Role role,MachineState state,int alpha,int beta,int depth) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=canonicalizeStateString(state,alpha,beta);
  if (useCaching && maxStateScores.get(stateString) != null)   return maxStateScores.get(stateString);
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  if (depth > maxDepth) {
    if (heuristic != null) {
      Integer value=heuristic.getScore(state,role);
      if (value != null)       return value;
    }
 else {
      return 1;
    }
  }
 else {
    for (    Move move : stateMachine.getLegalMoves(state,role)) {
      if (stopExecution) {
        break;
      }
      int value=minScore(role,move,state,alpha,beta,depth);
      if (value > bestValue)       bestValue=value;
      alpha=Math.max(alpha,bestValue);
      if (alpha >= beta) {
        bestValue=alpha;
        break;
      }
    }
    if (!stopExecution)     maxStateScores.put(stateString,bestValue);
  }
  return bestValue;
}",0.992248062015504
154241,"private int minScore(Role role,Move move,MachineState state,int alpha,int beta,int depth) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  String stateString=canonicalizeStateString(state,alpha,beta);
  String moveString=move.toString();
  Map<String,Integer> stateMoveScores=minStateScores.get(stateString);
  if (useCaching && stateMoveScores != null && stateMoveScores.get(moveString) != null)   return stateMoveScores.get(moveString);
  List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
  int worstScore=Integer.MAX_VALUE;
  for (  List<Move> jointMove : allJointMoves) {
    if (stopExecution) {
      break;
    }
    MachineState newState=stateMachine.getNextState(state,jointMove);
    int newScore=maxScore(role,newState,alpha,beta,depth + 1);
    if (newScore < worstScore)     worstScore=newScore;
    beta=Math.min(beta,worstScore);
    if (beta <= alpha) {
      worstScore=beta;
      break;
    }
  }
  if (heuristic == null || depth <= maxDepth) {
    if (stateMoveScores == null)     minStateScores.put(stateString,(stateMoveScores=new HashMap<String,Integer>()));
    stateMoveScores.put(moveString,worstScore);
  }
  return worstScore;
}","private int minScore(Role role,Move move,MachineState state,int alpha,int beta,int depth) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  String stateString=canonicalizeStateString(state,alpha,beta);
  String moveString=move.toString();
  Map<String,Integer> stateMoveScores=minStateScores.get(stateString);
  if (useCaching && stateMoveScores != null && stateMoveScores.get(moveString) != null)   return stateMoveScores.get(moveString);
  List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
  int worstScore=Integer.MAX_VALUE;
  for (  List<Move> jointMove : allJointMoves) {
    if (stopExecution) {
      break;
    }
    MachineState newState=stateMachine.getNextState(state,jointMove);
    int newScore=maxScore(role,newState,alpha,beta,depth + 1);
    if (newScore < worstScore)     worstScore=newScore;
    beta=Math.min(beta,worstScore);
    if (beta <= alpha) {
      worstScore=beta;
      break;
    }
  }
  if (heuristic == null || depth <= maxDepth) {
    if (stateMoveScores == null)     minStateScores.put(stateString,(stateMoveScores=new HashMap<String,Integer>()));
    stateMoveScores.put(moveString,worstScore);
  }
  if (worstScore == Integer.MAX_VALUE)   return 1;
  return worstScore;
}",0.9796731765643684
154242,"private int maxScore(Role role,MachineState state,int alpha,int beta,int depth) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=canonicalizeStateString(state,alpha,beta);
  if (useCaching && maxStateScores.get(stateString) != null)   return maxStateScores.get(stateString);
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  if (depth > maxDepth) {
    if (heuristic != null) {
      Integer value=heuristic.getScore(state,role);
      if (value != null)       return value;
    }
 else {
      return 1;
    }
  }
 else {
    for (    Move move : stateMachine.getLegalMoves(state,role)) {
      if (stopExecution) {
        break;
      }
      int value=minScore(role,move,state,alpha,beta,depth);
      if (value > bestValue)       bestValue=value;
      alpha=Math.max(alpha,bestValue);
      if (alpha >= beta) {
        bestValue=alpha;
        break;
      }
    }
    if (!stopExecution)     maxStateScores.put(stateString,bestValue);
  }
  return bestValue;
}","private int maxScore(Role role,MachineState state,int alpha,int beta,int depth) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state)) {
    numStatesExpanded++;
    return stateMachine.getGoal(state,role);
  }
  String stateString=canonicalizeStateString(state,alpha,beta);
  if (useCaching && maxStateScores.get(stateString) != null)   return maxStateScores.get(stateString);
  numStatesExpanded++;
  int bestValue=Integer.MIN_VALUE;
  if (depth > maxDepth) {
    if (heuristic != null) {
      Integer value=heuristic.getScore(state,role);
      if (value != null)       return value;
    }
 else {
      return 1;
    }
  }
 else {
    for (    Move move : stateMachine.getLegalMoves(state,role)) {
      if (stopExecution) {
        break;
      }
      int value=minScore(role,move,state,alpha,beta,depth);
      if (value > bestValue)       bestValue=value;
      alpha=Math.max(alpha,bestValue);
      if (alpha >= beta) {
        bestValue=alpha;
        break;
      }
    }
    if (!stopExecution)     maxStateScores.put(stateString,bestValue);
  }
  if (bestValue == Integer.MIN_VALUE)   return 1;
  return bestValue;
}",0.9728353140916808
154243,"private int minScore(Role role,MachineState state) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state))   return stateMachine.getGoal(state,role);
  if (minStateScores.get(state.toString()) != null)   return minStateScores.get(state.toString());
  int worstValue=Integer.MAX_VALUE;
  for (  Move move : stateMachine.getLegalMoves(state,role)) {
    List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
    for (    List<Move> jointMove : allJointMoves) {
      MachineState newState=stateMachine.getNextState(state,jointMove);
      int newValue=maxScore(role,newState);
      if (newValue < worstValue) {
        worstValue=newValue;
      }
    }
  }
  minStateScores.put(state.toString(),worstValue);
  return worstValue;
}","private int minScore(Role role,Move move,MachineState state) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  int worstScore=Integer.MAX_VALUE;
  List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
  for (  List<Move> jointMove : allJointMoves) {
    MachineState newState=stateMachine.getNextState(state,jointMove);
    int newScore=maxScore(role,newState);
    if (newScore < worstScore) {
      worstScore=newScore;
    }
  }
  return worstScore;
}",0.3837037037037037
154244,"public MiniMax(StateMachine sm){
  super(sm);
  minStateScores=new HashMap<String,Integer>();
  maxStateScores=new HashMap<String,Integer>();
}","public MiniMax(StateMachine sm){
  super(sm);
  maxStateScores=new HashMap<String,Integer>();
}",0.7983193277310925
154245,"public Move getBestMove(MachineState state,Role role) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  minStateScores.clear();
  maxStateScores.clear();
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (moves.size() == 1) {
    return moves.get(0);
  }
 else {
    Move bestMove=null;
    int bestValue=Integer.MIN_VALUE;
    for (    Move move : stateMachine.getLegalMoves(state,role)) {
      List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
      for (      List<Move> jointMove : allJointMoves) {
        MachineState newState=stateMachine.getNextState(state,jointMove);
        int newValue=minScore(role,newState);
        if (newValue > bestValue) {
          bestValue=newValue;
          bestMove=move;
        }
      }
    }
    System.out.println(""String_Node_Str"" + bestValue);
    return bestMove;
  }
}","public Move getBestMove(MachineState state,Role role) throws MoveDefinitionException, GoalDefinitionException, TransitionDefinitionException {
  maxStateScores.clear();
  List<Move> moves=stateMachine.getLegalMoves(state,role);
  if (moves.size() == 1) {
    return moves.get(0);
  }
 else {
    Move bestMove=null;
    int bestValue=Integer.MIN_VALUE;
    for (    Move move : moves) {
      int value=minScore(role,move,state);
      if (value > bestValue) {
        bestValue=value;
        bestMove=move;
      }
    }
    System.out.println(""String_Node_Str"" + bestValue);
    return bestMove;
  }
}",0.6516556291390728
154246,"private int maxScore(Role role,MachineState state) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state))   return stateMachine.getGoal(state,role);
  int bestValue=Integer.MIN_VALUE;
  for (  Move move : stateMachine.getLegalMoves(state,role)) {
    List<List<Move>> allJointMoves=stateMachine.getLegalJointMoves(state,role,move);
    for (    List<Move> jointMove : allJointMoves) {
      MachineState newState=stateMachine.getNextState(state,jointMove);
      int newValue=minScore(role,newState);
      if (newValue > bestValue) {
        bestValue=newValue;
      }
    }
  }
  maxStateScores.put(state.toString(),bestValue);
  return bestValue;
}","private int maxScore(Role role,MachineState state) throws GoalDefinitionException, MoveDefinitionException, TransitionDefinitionException {
  if (stateMachine.isTerminal(state))   return stateMachine.getGoal(state,role);
  if (maxStateScores.get(state.toString()) != null)   return maxStateScores.get(state.toString());
  int bestValue=Integer.MIN_VALUE;
  for (  Move move : stateMachine.getLegalMoves(state,role)) {
    int value=minScore(role,move,state);
    if (value > bestValue) {
      bestValue=value;
    }
  }
  maxStateScores.put(state.toString(),bestValue);
  return bestValue;
}",0.5106382978723404
154247,"/** 
 * Returns a new Token object, by default. However, if you want, you can create and return subclass objects based on the value of ofKind. Simply add the cases to the switch for all those special cases. For example, if you have a subclass of Token called IDToken that you want to create if ofKind is ID, simply add something like : case MyParserConstants.ID : return new IDToken(); to the following switch statement. Then you can cast matchedToken variable to the appropriate type and use it in your lexical actions.
 */
public static Token newToken(int ofKind,String image){
switch (ofKind) {
case UnrealScriptParserConstants.RUNSIGNEDSHIFT:
case UnrealScriptParserConstants.RSIGNEDSHIFT:
case UnrealScriptParserConstants.GT:
    return new GTToken(ofKind,image);
default :
  return new Token(ofKind,image);
}
}","/** 
 * Returns a new Token object, by default. However, if you want, you can create and return subclass objects based on the value of ofKind. Simply add the cases to the switch for all those special cases. For example, if you have a subclass of Token called IDToken that you want to create if ofKind is ID, simply add something like : case MyParserConstants.ID : return new IDToken(); to the following switch statement. Then you can cast matchedToken variable to the appropriate type and use it in your lexical actions.
 */
public static Token newToken(int ofKind,String image){
switch (ofKind) {
case UnrealScriptParserConstants.RUNSIGNEDSHIFT:
    return new GTToken(ofKind,image,UnrealScriptParserConstants.RUNSIGNEDSHIFT);
case UnrealScriptParserConstants.RSIGNEDSHIFT:
  return new GTToken(ofKind,image,UnrealScriptParserConstants.RSIGNEDSHIFT);
case UnrealScriptParserConstants.GT:
return new GTToken(ofKind,image,UnrealScriptParserConstants.GT);
default :
return new Token(ofKind,image);
}
}",0.8033057851239669
154248,"public GTToken(int kind,String image){
  super(kind,image);
}","public GTToken(int kind,String image,int realKind){
  super(kind,image);
  this.realKind=realKind;
}",0.7577639751552795
154249,"private void connectAndJoin(){
}","private void connectAndJoin(){
  String server=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String username=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String password=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String channel=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String nickname=conf.getString(""String_Node_Str"",""String_Node_Str"");
  if (!server.equals(""String_Node_Str"") && !username.equals(""String_Node_Str"") && !password.equals(""String_Node_Str"")&& !channel.equals(""String_Node_Str"")) {
    try {
      log.info(""String_Node_Str"");
      xmppconn=new XMPPConnection(server);
      xmppconn.connect();
      if (!xmppconn.isConnected()) {
        log.error(""String_Node_Str"");
        return;
      }
      xmppconn.login(username,password);
      log.info(""String_Node_Str"");
      muc=new MultiUserChat(xmppconn,channel);
      DiscussionHistory history=new DiscussionHistory();
      history.setMaxStanzas(0);
      muc.join(nickname,""String_Node_Str"",history,2000);
      muc.addMessageListener(this);
      muc.addParticipantStatusListener(participantListener);
    }
 catch (    Exception e) {
      log.warning(""String_Node_Str"" + server);
    }
  }
 else {
    log.warning(""String_Node_Str"");
  }
}",0.0495739736638264
154250,"public void sendMUCMessage(String msg){
}","public void sendMUCMessage(String msg){
  if (xmppconn.isConnected() && muc.isJoined()) {
    muc.sendMessage(msg);
  }
}",0.5061728395061729
154251,"private void connectAndJoin(){
  String server=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String username=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String password=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String channel=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String nickname=conf.getString(""String_Node_Str"",""String_Node_Str"");
  if (!server.equals(""String_Node_Str"") && !username.equals(""String_Node_Str"") && !password.equals(""String_Node_Str"")&& !channel.equals(""String_Node_Str"")) {
    try {
      log.info(""String_Node_Str"");
      xmppconn=new XMPPConnection(server);
      xmppconn.connect();
      if (!xmppconn.isConnected()) {
        log.error(""String_Node_Str"");
        return;
      }
      xmppconn.login(username,password);
      log.info(""String_Node_Str"");
      muc=new MultiUserChat(xmppconn,channel);
      DiscussionHistory history=new DiscussionHistory();
      history.setMaxStanzas(0);
      muc.join(nickname,""String_Node_Str"",history,2000);
      muc.addMessageListener(this);
      muc.addParticipantStatusListener(participantListener);
    }
 catch (    Exception e) {
      log.warning(""String_Node_Str"" + server);
    }
  }
 else {
    log.warning(""String_Node_Str"");
  }
}","private void connectAndJoin(){
  String server=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String username=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String password=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String channel=conf.getString(""String_Node_Str"",""String_Node_Str"");
  String nickname=conf.getString(""String_Node_Str"",""String_Node_Str"");
  if (!server.equals(""String_Node_Str"") && !username.equals(""String_Node_Str"") && !password.equals(""String_Node_Str"")&& !channel.equals(""String_Node_Str"")) {
    try {
      log.info(""String_Node_Str"");
      xmppconn=new XMPPConnection(server);
      xmppconn.connect();
      if (!xmppconn.isConnected()) {
        log.warning(""String_Node_Str"");
        return;
      }
      xmppconn.login(username,password);
      log.info(""String_Node_Str"");
      muc=new MultiUserChat(xmppconn,channel);
      DiscussionHistory history=new DiscussionHistory();
      history.setMaxStanzas(0);
      muc.join(nickname,""String_Node_Str"",history,2000);
      muc.addMessageListener(this);
      muc.addParticipantStatusListener(participantListener);
    }
 catch (    Exception e) {
      log.warning(""String_Node_Str"" + server);
    }
  }
 else {
    log.warning(""String_Node_Str"");
  }
}",0.9952380952380953
154252,"public void sendMUCMessage(String msg){
  if (xmppconn.isConnected() && muc.isJoined()) {
    muc.sendMessage(msg);
  }
}","public void sendMUCMessage(String msg){
  if (xmppconn.isConnected() && muc.isJoined()) {
    try {
      muc.sendMessage(msg);
    }
 catch (    Exception e) {
      log.warning(""String_Node_Str"");
    }
  }
}",0.7129909365558912
154253,"public void processPacket(Packet p){
  if (p instanceof Message) {
    final Message message=(Message)p;
    if (message.getType() == Message.Type.groupchat) {
      if (!StringUtils.parseResource(message.getFrom()).equalsIgnoreCase(nickname)) {
        String outmsg=ChatColor.GRAY + ""String_Node_Str"" + ChatColor.DARK_GREEN+ ""String_Node_Str""+ ChatColor.GRAY+ ""String_Node_Str""+ ChatColor.WHITE+ StringUtils.parseResource(message.getFrom())+ ""String_Node_Str""+ message.getBody();
        sendMCMessage(outmsg);
        log.info(outmsg);
      }
    }
  }
}","public void processPacket(Packet p){
  if (p instanceof Message) {
    final Message message=(Message)p;
    if (message.getType() == Message.Type.groupchat) {
      if (!StringUtils.parseResource(message.getFrom()).equalsIgnoreCase(conf.getString(""String_Node_Str"",""String_Node_Str""))) {
        String outmsg=ChatColor.GRAY + ""String_Node_Str"" + ChatColor.DARK_GREEN+ ""String_Node_Str""+ ChatColor.GRAY+ ""String_Node_Str""+ ChatColor.WHITE+ StringUtils.parseResource(message.getFrom())+ ""String_Node_Str""+ message.getBody();
        sendMCMessage(outmsg);
        log.info(outmsg);
      }
    }
  }
}",0.9490940465918896
154254,"@Override public boolean performFinish(){
  IFile file=page.createNewFile();
  if (file == null)   return false;
  IContainer parent=file.getParent();
  if (parent != null && parent.exists()) {
    IFile sourceFile=parent.getFile(new Path(""String_Node_Str""));
    if (sourceFile != null && sourceFile.exists()) {
      String filename=page.getFileName();
      String append=""String_Node_Str"" + filename + ""String_Node_Str""+ filename;
      try {
        sourceFile.appendContents(new ByteArrayInputStream(append.getBytes()),false,true,null);
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
    }
  }
  return true;
}","@Override public boolean performFinish(){
  IFile file=page.createNewFile();
  if (file == null)   return false;
  IContainer parent=file.getParent();
  if (parent != null && parent.exists()) {
    IFile sourceFile=parent.getFile(new Path(parent.getName() + ""String_Node_Str""));
    if (sourceFile != null && sourceFile.exists()) {
      String filename=page.getFileName();
      String append=""String_Node_Str"" + filename + ""String_Node_Str""+ filename;
      try {
        sourceFile.appendContents(new ByteArrayInputStream(append.getBytes()),false,true,null);
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
    }
  }
  return true;
}",0.9855293221629856
154255,"@Override public boolean performFinish(){
  IFolder folder=page.createNewFolder();
  if (folder == null)   return false;
  IFile sourceFile=folder.getFile(""String_Node_Str"");
  try {
    sourceFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),false,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    return false;
  }
  IContainer parent=folder.getParent();
  if (parent != null) {
    IFile parentSourceFile=parent.getFile(new Path(""String_Node_Str""));
    if (parentSourceFile != null) {
      String newlines=""String_Node_Str"";
      if (!parentSourceFile.exists()) {
        try {
          parentSourceFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),false,null);
          newlines=""String_Node_Str"";
        }
 catch (        CoreException e) {
          e.printStackTrace();
        }
      }
      if (parentSourceFile.exists()) {
        String folderName=folder.getName();
        String append=newlines + ""String_Node_Str"" + folderName+ ""String_Node_Str""+ folder.getName()+ ""String_Node_Str"";
        try {
          parentSourceFile.appendContents(new ByteArrayInputStream(append.getBytes()),false,true,null);
        }
 catch (        CoreException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return true;
}","@Override public boolean performFinish(){
  IFolder folder=page.createNewFolder();
  if (folder == null)   return false;
  IFile sourceFile=folder.getFile(folder.getName() + ""String_Node_Str"");
  try {
    sourceFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),false,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
    return false;
  }
  IContainer parent=folder.getParent();
  if (parent != null) {
    IFile parentSourceFile=parent.getFile(new Path(parent.getName() + ""String_Node_Str""));
    if (parentSourceFile != null) {
      String newlines=""String_Node_Str"";
      if (!parentSourceFile.exists()) {
        try {
          parentSourceFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),false,null);
          newlines=""String_Node_Str"";
        }
 catch (        CoreException e) {
          e.printStackTrace();
        }
      }
      if (parentSourceFile.exists()) {
        String folderName=folder.getName();
        String append=newlines + ""String_Node_Str"" + folderName+ ""String_Node_Str""+ folder.getName()+ ""String_Node_Str""+ folderName+ ""String_Node_Str"";
        try {
          parentSourceFile.appendContents(new ByteArrayInputStream(append.getBytes()),false,true,null);
        }
 catch (        CoreException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return true;
}",0.9740698985343856
154256,"public synchronized void removeNodeFromCurrentInstances(Node node){
  nn--;
  numberOfNodesLbl.setText(String.valueOf(nn));
synchronized (model) {
    if (null != node) {
      logger.debug(""String_Node_Str"" + node + ""String_Node_Str"");
      for (int i=0; i < model.getRowCount(); i++) {
        if (((String)(model.getValueAt(i,0))).equals(node.getNodeName())) {
          model.removeRow(i);
          logger.debug(node + ""String_Node_Str"");
          return;
        }
      }
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
}","public synchronized void removeNodeFromCurrentInstances(Node node){
  nn--;
  numberOfNodesLbl.setText(String.valueOf(nn));
synchronized (model) {
    if (null != node) {
      logger.debug(""String_Node_Str"" + node + ""String_Node_Str"");
      for (int i=0; i < model.getRowCount(); i++) {
        if (((String)(model.getValueAt(i,1))).equals(node.getIP() + ""String_Node_Str"" + node.getPort())) {
          model.removeRow(i);
          logger.debug(node + ""String_Node_Str"");
          return;
        }
      }
      logger.error(""String_Node_Str"" + node);
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
}",0.9185946872322194
154257,"@Override public void initializeDataBlocks(List<Block> blocks){
  if (blocks != null & model.getRowCount() == 0) {
    for (    Block block : blocks) {
      if (StringUtils.isNotEmpty(block.getName())) {
        model.insertRow(model.getRowCount(),new Object[]{block.getName(),Size.getSizeString(block.getSize()),0,0});
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
  }
 else {
    logger.error(""String_Node_Str"");
  }
}","@Override public void initializeDataBlocks(List<Block> blocks){
  if (blocks != null & model.getRowCount() == 0) {
    for (    Block block : blocks) {
      if (StringUtils.isNotEmpty(block.getName())) {
        model.insertRow(model.getRowCount(),new Object[]{block.getName(),Size.getSizeString(block.getSize()),0,0});
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
  }
 else {
    if (blocks == null)     logger.error(""String_Node_Str"");
  }
}",0.9737991266375546
154258,"private void checkIfCanAcceptRequest(){
  if (!acceptRequest) {
    boolean found=false;
    for (    String pid : pt.keySet()) {
      if (pt.get(pid).getRequest().getDestinationNode() != null) {
        found=true;
        break;
      }
    }
    if (!found)     acceptRequest=true;
  }
  trigger(new MemoryCheckOperation(),cpu);
}","private synchronized void checkIfCanAcceptRequest(){
  if (!acceptRequest) {
    boolean found=false;
    for (    String pid : pt.keySet()) {
      if (pt.get(pid).getRequest().getDestinationNode() != null) {
        found=true;
        break;
      }
    }
    if (!found)     acceptRequest=true;
  }
  trigger(new MemoryCheckOperation(),cpu);
}",0.9809104258443464
154259,"protected double calculateAverageThroughput(){
  int throughputSum=0;
  double mean;
  for (  Integer tp : throughputCollection) {
    throughputSum+=tp;
  }
  if (throughputCollection.size() == 0)   mean=0;
 else   mean=throughputSum / throughputCollection.size();
  throughputCollection.clear();
  return mean;
}","protected double calculateAverageThroughput(){
  int throughputSum=0;
  double mean;
  for (  Integer tp : throughputCollection) {
    throughputSum+=tp;
  }
  if (throughputCollection.size() == 0)   return previousTP;
 else   mean=throughputSum / throughputCollection.size();
  previousTP=mean;
  throughputCollection.clear();
  return mean;
}",0.9361702127659576
154260,"public void activateFor(Node node){
  if (replicas.contains(node))   active=true;
 else   replicas.add(node);
}","public void activateFor(Node node){
  if (!replicas.contains(node)) {
    active=true;
    replicas.add(node);
  }
}",0.9427312775330396
154261,"public List<Block> prepareBlocksForNode(Node node){
  List<Block> blocks=new ArrayList<Block>();
  for (  ELBEntry entry : entries) {
    if (entry.getNrOfReplicas() < desireReplicateDegree) {
      entry.updateNode(node);
      blocks.add(entry.getBlock());
    }
  }
  if (blocks.size() == 0) {
    selectRandomNumberOfBlocks(blocks,node);
  }
  return blocks;
}","public List<Block> prepareBlocksForNode(Node node){
  List<Block> blocks=new ArrayList<Block>();
  for (  ELBEntry entry : entries) {
    if (entry.getNrOfReplicas() < desireReplicateDegree) {
      blocks.add(entry.getBlock());
    }
  }
  if (blocks.size() == 0) {
    selectRandomNumberOfBlocks(blocks,node);
  }
  return blocks;
}",0.9570200573065902
154262,"private void selectRandomNumberOfBlocks(List<Block> blocks,Node node){
  for (int i=0; i < entries.size(); i+=2) {
    ELBEntry entry=entries.get(i);
    entry.updateNode(node);
    blocks.add(entry.getBlock());
  }
}","private void selectRandomNumberOfBlocks(List<Block> blocks,Node node){
  for (int i=0; i < entries.size(); i+=2) {
    ELBEntry entry=entries.get(i);
    blocks.add(entry.getBlock());
  }
}",0.9310344827586208
154263,"@Override public synchronized void log(String text){
  logTextArea.append(text + ""String_Node_Str"");
  if (!logTextLocked.get())   logTextArea.setCaretPosition(logTextArea.getText().length());
 else   logTextArea.setCaretPosition(lockedPosition);
}","@Override public void log(String text){
  logTextArea.append(text + ""String_Node_Str"");
  if (!logTextLocked.get())   logTextArea.setCaretPosition(logTextArea.getText().length());
 else   logTextArea.setCaretPosition(lockedPosition);
}",0.9730848861283644
154264,"private String fticks(String msg){
  StringBuffer buf=new StringBuffer();
  String fields[]=msg.split(""String_Node_Str"");
  String principalName=fields[8];
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"").append(getFederationIdentifier());
  buf.append(""String_Node_Str"").append(getVersion());
  buf.append(""String_Node_Str"").append(fields[0]);
  buf.append(""String_Node_Str"").append(fields[3]);
  buf.append(""String_Node_Str"").append(fields[5]);
  buf.append(""String_Node_Str"").append(anonymize(principalName));
  buf.append(""String_Node_Str"").append(fields[9]);
  buf.append(""String_Node_Str"");
  return buf.toString();
}","private String fticks(String msg){
  StringBuffer buf=new StringBuffer();
  String fields[]=msg.split(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"").append(getFederationIdentifier());
  buf.append(""String_Node_Str"").append(getVersion());
  buf.append(""String_Node_Str"").append(fields[0]);
  if (fields.length > 3) {
    buf.append(""String_Node_Str"").append(fields[3]);
  }
  if (fields.length > 5) {
    buf.append(""String_Node_Str"").append(fields[5]);
  }
  if (fields.length > 8) {
    buf.append(""String_Node_Str"").append(anonymize(fields[8]));
  }
  if (fields.length > 9) {
    buf.append(""String_Node_Str"").append(fields[9]);
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}",0.2740524781341107
154265,"private Object convertFromAvroPrimitive(Object inObj,Class<?> inType){
  if (inObj == null) {
    return null;
  }
 else   if (inType == String.class) {
    String convertedObj=((Utf8)inObj).toString();
    return convertedObj;
  }
 else   if (inType == BytesWritable.class) {
    return new BytesWritable(((ByteBuffer)inObj).array());
  }
 else   if (inType.isEnum()) {
    return inObj.toString();
  }
 else {
    return inObj;
  }
}","private Object convertFromAvroPrimitive(Object inObj,Class<?> inType){
  if (inObj == null) {
    return null;
  }
 else   if (inType == String.class) {
    String convertedObj=((Utf8)inObj).toString();
    return convertedObj;
  }
 else   if (inType == BytesWritable.class) {
    ByteBuffer buffer=(ByteBuffer)inObj;
    BytesWritable result=new BytesWritable();
    result.set(buffer.array(),buffer.position(),buffer.limit());
    return result;
  }
 else   if (inType.isEnum()) {
    return inObj.toString();
  }
 else {
    return inObj;
  }
}",0.814663951120163
154266,"private Object convertFromAvroPrimitive(Object inObj,Class inType){
  Class curType=inObj.getClass();
  if (curType == Utf8.class) {
    String convertedObj=((Utf8)inObj).toString();
    return convertedObj;
  }
 else   if (curType == BytesWritable.class) {
    return new BytesWritable(((ByteBuffer)inObj).array());
  }
  return inObj;
}","private Object convertFromAvroPrimitive(Object inObj,Class inType){
  if (inType == String.class) {
    String convertedObj=((Utf8)inObj).toString();
    return convertedObj;
  }
 else   if (inType == BytesWritable.class) {
    return new BytesWritable(((ByteBuffer)inObj).array());
  }
  return inObj;
}",0.6261682242990654
154267,"private Object convertToAvroPrimitive(Object inObj,Class curType){
  if (curType == String.class) {
    Utf8 convertedObj=new Utf8((String)inObj);
    return convertedObj;
  }
 else   if (curType == BytesWritable.class) {
    ByteBuffer convertedObj=ByteBuffer.wrap(((BytesWritable)inObj).get());
    return convertedObj;
  }
 else {
    return inObj;
  }
}","private Object convertToAvroPrimitive(Object inObj,Class curType){
  if (curType == String.class) {
    Utf8 convertedObj=new Utf8((String)inObj);
    return convertedObj;
  }
 else   if (curType == BytesWritable.class) {
    BytesWritable bw=(BytesWritable)inObj;
    ByteBuffer convertedObj=ByteBuffer.wrap(bw.get(),0,bw.getSize());
    return convertedObj;
  }
 else {
    return inObj;
  }
}",0.8909574468085106
154268,"private void clearFields(){
  SpinnerNumberModel model=new SpinnerNumberModel(0,0,0,0);
  buildTypeAmountSpinner.setModel(model);
  buildTypeAmountSpinner.setVisible(false);
  projectedCosts=0;
  cartListModel.clear();
  railroadRadioButton.setEnabled(false);
  industrialRadioButton.setEnabled(false);
  residentialRadioButton.setEnabled(false);
  stadiumRadioButton.setEnabled(false);
  monopolyTowerRadioButton.setEnabled(false);
  skyscraperRadioButton.setEnabled(false);
  removeHazardRadioButton.setEnabled(false);
  railroadRadioButton.setSelected(false);
  industrialRadioButton.setSelected(false);
  residentialRadioButton.setSelected(false);
  stadiumRadioButton.setSelected(false);
  monopolyTowerRadioButton.setSelected(false);
  skyscraperRadioButton.setSelected(false);
  removeHazardRadioButton.setSelected(false);
}","private void clearFields(){
  SpinnerNumberModel model=new SpinnerNumberModel(0,0,0,0);
  buildTypeAmountSpinner.setModel(model);
  buildTypeAmountSpinner.setVisible(false);
  projectedCosts=0;
  cartListModel.clear();
  messageTextField.setText(""String_Node_Str"");
  clearRadio();
}",0.4129263913824057
154269,"public void enter(){
  System.out.println(""String_Node_Str"");
  currentPlayer=GameMaster.getInstance().getCurrentPlayer();
  playerCash=GameMaster.getInstance().getCurrentPlayer().getCash();
  playerAllowance=generateAllowance();
  allowanceRemaining=playerAllowance;
  clearFields();
  totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
  playerDistricts=new String[currentPlayer.getDistricts().size() + 1];
  comboBoxModel=new DefaultComboBoxModel(playerDistricts);
  comboBoxModel.removeAllElements();
  for (int jj=0; jj < currentPlayer.getDistricts().size() + 1; jj++) {
    if (jj == 0)     playerDistricts[jj]=""String_Node_Str"";
 else     playerDistricts[jj]=currentPlayer.getDistricts().get(jj - 1).getName();
    comboBoxModel.addElement(playerDistricts[jj]);
  }
  ownedDistrictsComboBox.setModel(comboBoxModel);
  playerCashTextField.setText(""String_Node_Str"" + playerCash + ""String_Node_Str"");
  if (allowanceRemaining == -1) {
    buildAllowanceTextField.setText(""String_Node_Str"");
  }
 else   buildAllowanceTextField.setText(allowanceRemaining + ""String_Node_Str"");
  mainFrame.setContentPane(layeredPane);
  layeredPane.revalidate();
  startMode();
}","public void enter(){
  System.out.println(""String_Node_Str"");
  currentPlayer=GameMaster.getInstance().getCurrentPlayer();
  if (currentPlayer.getDistricts().size() < 2) {
    System.out.println(currentPlayer.getDistricts().size());
    gameStateMachine.setState(gameStateMachine.getGamePlayState());
  }
  System.out.println(currentPlayer.getDistricts().size());
  playerCash=GameMaster.getInstance().getCurrentPlayer().getCash();
  playerAllowance=generateAllowance();
  allowanceRemaining=playerAllowance;
  clearFields();
  totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
  playerDistricts=new String[currentPlayer.getDistricts().size() + 1];
  comboBoxModel=new DefaultComboBoxModel(playerDistricts);
  comboBoxModel.removeAllElements();
  for (int jj=0; jj < currentPlayer.getDistricts().size() + 1; jj++) {
    if (jj == 0)     playerDistricts[jj]=""String_Node_Str"";
 else     playerDistricts[jj]=currentPlayer.getDistricts().get(jj - 1).getName();
    comboBoxModel.addElement(playerDistricts[jj]);
  }
  ownedDistrictsComboBox.setModel(comboBoxModel);
  playerCashTextField.setText(""String_Node_Str"" + playerCash + ""String_Node_Str"");
  if (allowanceRemaining == -1) {
    buildAllowanceTextField.setText(""String_Node_Str"");
  }
 else   buildAllowanceTextField.setText(allowanceRemaining + ""String_Node_Str"");
  mainFrame.setContentPane(layeredPane);
  layeredPane.revalidate();
  startMode();
}",0.9083998479665526
154270,"public BuildTypePanel(){
  setLayout(new MigLayout());
  setBorder(BorderFactory.createLineBorder(Color.gray,2));
  setPreferredSize(new Dimension(250,100));
  setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  residentialRadioButton=new ResidentialRadioButton();
  residentialTypeLabel=new JLabel(""String_Node_Str"");
  railroadRadioButton=new RailroadRadioButton();
  railroadTypeLabel=new JLabel(""String_Node_Str"");
  industrialRadioButton=new IndustrialRadioButton();
  industrialTypeLabel=new JLabel(""String_Node_Str"");
  skyscraperRadioButton=new SkyscraperRadioButton();
  skyscraperTypeLabel=new JLabel(""String_Node_Str"");
  stadiumRadioButton=new StadiumRadioButton();
  stadiumLabel=new JLabel(""String_Node_Str"");
  monopolyTowerRadioButton=new MonopolyTowerRadioButton();
  monopolyTowerLabel=new JLabel(""String_Node_Str"");
  removeHazardRadioButton=new RemoveHazardRadioButton();
  removeHazardLabel=new JLabel(""String_Node_Str"");
  residentialRadioButton.setVisible(true);
  residentialTypeLabel.setVisible(true);
  railroadRadioButton.setVisible(true);
  railroadTypeLabel.setVisible(true);
  industrialRadioButton.setVisible(true);
  industrialTypeLabel.setVisible(true);
  skyscraperRadioButton.setVisible(true);
  skyscraperTypeLabel.setVisible(true);
  stadiumRadioButton.setVisible(true);
  stadiumLabel.setVisible(true);
  monopolyTowerRadioButton.setVisible(true);
  monopolyTowerLabel.setVisible(true);
  removeHazardRadioButton.setVisible(true);
  removeHazardLabel.setVisible(true);
  add(residentialRadioButton,""String_Node_Str"");
  add(residentialTypeLabel,""String_Node_Str"");
  add(railroadRadioButton,""String_Node_Str"");
  add(railroadTypeLabel,""String_Node_Str"");
  add(industrialRadioButton,""String_Node_Str"");
  add(industrialTypeLabel,""String_Node_Str"");
  add(skyscraperRadioButton,""String_Node_Str"");
  add(skyscraperTypeLabel,""String_Node_Str"");
  add(stadiumRadioButton,""String_Node_Str"");
  add(stadiumLabel,""String_Node_Str"");
  add(monopolyTowerRadioButton,""String_Node_Str"");
  add(monopolyTowerLabel,""String_Node_Str"");
  add(removeHazardRadioButton,""String_Node_Str"");
  add(removeHazardLabel,""String_Node_Str"");
  residentialRadioButton.setEnabled(false);
  railroadRadioButton.setEnabled(false);
  industrialRadioButton.setEnabled(false);
  skyscraperRadioButton.setEnabled(false);
  stadiumRadioButton.setEnabled(false);
  monopolyTowerRadioButton.setEnabled(false);
  removeHazardRadioButton.setEnabled(false);
}","public BuildTypePanel(){
  setLayout(new MigLayout());
  setBorder(BorderFactory.createLineBorder(Color.gray,2));
  setPreferredSize(new Dimension(250,100));
  setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  residentialRadioButton=new ResidentialRadioButton();
  residentialTypeLabel=new JLabel(""String_Node_Str"");
  railroadRadioButton=new RailroadRadioButton();
  railroadTypeLabel=new JLabel(""String_Node_Str"");
  industrialRadioButton=new IndustrialRadioButton();
  industrialTypeLabel=new JLabel(""String_Node_Str"");
  skyscraperRadioButton=new SkyscraperRadioButton();
  skyscraperTypeLabel=new JLabel(""String_Node_Str"");
  stadiumRadioButton=new StadiumRadioButton();
  stadiumLabel=new JLabel(""String_Node_Str"");
  monopolyTowerRadioButton=new MonopolyTowerRadioButton();
  monopolyTowerLabel=new JLabel(""String_Node_Str"");
  removeHazardRadioButton=new RemoveHazardRadioButton();
  removeHazardLabel=new JLabel(""String_Node_Str"");
  add(residentialRadioButton,""String_Node_Str"");
  add(residentialTypeLabel,""String_Node_Str"");
  add(railroadRadioButton,""String_Node_Str"");
  add(railroadTypeLabel,""String_Node_Str"");
  add(industrialRadioButton,""String_Node_Str"");
  add(industrialTypeLabel,""String_Node_Str"");
  add(skyscraperRadioButton,""String_Node_Str"");
  add(skyscraperTypeLabel,""String_Node_Str"");
  add(stadiumRadioButton,""String_Node_Str"");
  add(stadiumLabel,""String_Node_Str"");
  add(monopolyTowerRadioButton,""String_Node_Str"");
  add(monopolyTowerLabel,""String_Node_Str"");
  add(removeHazardRadioButton,""String_Node_Str"");
  add(removeHazardLabel,""String_Node_Str"");
  clearRadio();
}",0.583781143136297
154271,"public BuildButton(){
  setText(""String_Node_Str"");
  setPreferredSize(new Dimension(100,30));
  addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      System.out.println(""String_Node_Str"");
      if (playerCash > projectedCosts) {
        currentPlayer.collect(projectedCosts);
        gameStateMachine.setState(gameStateMachine.getGamePlayState());
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
  }
);
}","public BuildButton(){
  setText(""String_Node_Str"");
  setPreferredSize(new Dimension(100,30));
  addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      System.out.println(""String_Node_Str"");
      if (playerCash > projectedCosts) {
        currentPlayer.pay(projectedCosts);
        gameStateMachine.setState(gameStateMachine.getGamePlayState());
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
  }
);
}",0.9894736842105264
154272,"private void addToCartAction(){
  if (currentlySelectedRadioButton == null)   messageTextField.setText(""String_Node_Str"");
 else {
    if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      int buildAmount=(Integer)buildTypeAmountSpinner.getValue();
      if (allowanceRemaining > 0) {
        if (playerSelectedDistrict.getTotalBlockCount() < 8) {
          if (buildAmount != 0) {
            if (buildAmount <= StructureFactory.getInstance().residentialCount) {
              cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount);
              buildList.setModel(cartListModel);
              for (int ii=0; ii < buildAmount; ii++) {
                StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
                System.out.println(""String_Node_Str"");
                playerSelectedDistrict.addResidentialBlock(1);
                System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
              }
              System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount+ ""String_Node_Str"");
              allowanceRemaining=allowanceRemaining - buildAmount;
              buildAllowanceTextField.setText(""String_Node_Str"" + allowanceRemaining + ""String_Node_Str"");
              projectedCosts=projectedCosts + playerSelectedDistrict.getResidentialCost() * buildAmount;
              totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
            }
 else             messageTextField.setText(""String_Node_Str"");
          }
 else           messageTextField.setText(""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      int buildAmount=(Integer)buildTypeAmountSpinner.getValue();
      if (allowanceRemaining > 0) {
        if (playerSelectedDistrict.getTotalBlockCount() < 8) {
          if (buildAmount != 0) {
            if (buildAmount <= StructureFactory.getInstance().industrialCount) {
              cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount);
              buildList.setModel(cartListModel);
              for (int ii=0; ii < buildAmount; ii++) {
                StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
                System.out.println(""String_Node_Str"");
                playerSelectedDistrict.addIndustrialBlock(1);
                System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
              }
              System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount+ ""String_Node_Str"");
              allowanceRemaining=allowanceRemaining - buildAmount;
              buildAllowanceTextField.setText(""String_Node_Str"" + allowanceRemaining + ""String_Node_Str"");
              projectedCosts=projectedCosts + playerSelectedDistrict.getIndustrialCost() * buildAmount;
              totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
            }
 else             messageTextField.setText(""String_Node_Str"");
          }
 else           messageTextField.setText(""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (allowanceRemaining != 0) {
        if (StructureFactory.getInstance().railroadCount != 0) {
          cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
          buildList.setModel(cartListModel);
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
          StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
          playerSelectedDistrict.addRailroad();
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
          allowanceRemaining=allowanceRemaining + 1;
          buildAllowanceTextField.setText(""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (playerSelectedDistrict.isStadiumed() == false) {
        if (StructureFactory.getInstance().stadiumCount != 0) {
          cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
          StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
          System.out.println(""String_Node_Str"");
          playerSelectedDistrict.addStadium();
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
          projectedCosts=projectedCosts + 2;
          totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (playerSelectedDistrict.isSkyScrapered() == false) {
        if (StructureFactory.getInstance().skyscraperCount != 0) {
          cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
          StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
          System.out.println(""String_Node_Str"");
          playerSelectedDistrict.addSkyscraper();
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
          projectedCosts=projectedCosts + playerSelectedDistrict.skyscraperCost;
          totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (StructureFactory.getInstance().monopolyTowerCount != 0) {
        cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
        System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
        StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
        System.out.println(""String_Node_Str"");
        playerSelectedDistrict.addMonopolyTower();
        System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
        projectedCosts=projectedCosts + 7;
        totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
      System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str"");
      projectedCosts=projectedCosts + playerSelectedDistrict.hazard.getBlockCount() * .5;
      totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
    }
  }
}","private void addToCartAction(){
  if (currentlySelectedRadioButton == null)   messageTextField.setText(""String_Node_Str"");
 else {
    if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      int buildAmount=(Integer)buildTypeAmountSpinner.getValue();
      if (allowanceRemaining > 0) {
        if (playerSelectedDistrict.getTotalBlockCount() < 8) {
          if (buildAmount != 0) {
            if (buildAmount <= StructureFactory.getInstance().residentialCount) {
              cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount);
              buildList.setModel(cartListModel);
              for (int ii=0; ii < buildAmount; ii++) {
                StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
                System.out.println(""String_Node_Str"");
                playerSelectedDistrict.addResidentialBlock(1);
                System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
              }
              System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount+ ""String_Node_Str"");
              allowanceRemaining=allowanceRemaining - buildAmount;
              buildAllowanceTextField.setText(""String_Node_Str"" + allowanceRemaining + ""String_Node_Str"");
              projectedCosts=projectedCosts + playerSelectedDistrict.getResidentialCost() * buildAmount;
              totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
              clearRadio();
            }
 else             messageTextField.setText(""String_Node_Str"");
          }
 else           messageTextField.setText(""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      int buildAmount=(Integer)buildTypeAmountSpinner.getValue();
      if (allowanceRemaining > 0) {
        if (playerSelectedDistrict.getTotalBlockCount() < 8) {
          if (buildAmount != 0) {
            if (buildAmount <= StructureFactory.getInstance().industrialCount) {
              cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount);
              buildList.setModel(cartListModel);
              for (int ii=0; ii < buildAmount; ii++) {
                StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
                System.out.println(""String_Node_Str"");
                playerSelectedDistrict.addIndustrialBlock(1);
                System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
              }
              System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str""+ buildAmount+ ""String_Node_Str"");
              allowanceRemaining=allowanceRemaining - buildAmount;
              buildAllowanceTextField.setText(""String_Node_Str"" + allowanceRemaining + ""String_Node_Str"");
              projectedCosts=projectedCosts + playerSelectedDistrict.getIndustrialCost() * buildAmount;
              totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
              clearRadio();
            }
 else             messageTextField.setText(""String_Node_Str"");
          }
 else           messageTextField.setText(""String_Node_Str"");
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (allowanceRemaining != 0) {
        if (StructureFactory.getInstance().railroadCount != 0) {
          cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
          buildList.setModel(cartListModel);
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
          StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
          playerSelectedDistrict.addRailroad();
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
          allowanceRemaining=allowanceRemaining + 1;
          buildAllowanceTextField.setText(""String_Node_Str"");
          clearRadio();
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (playerSelectedDistrict.isStadiumed() == false) {
        if (StructureFactory.getInstance().stadiumCount != 0) {
          cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
          StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
          System.out.println(""String_Node_Str"");
          playerSelectedDistrict.addStadium();
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
          projectedCosts=projectedCosts + 2;
          totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
          clearRadio();
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (playerSelectedDistrict.isSkyScrapered() == false) {
        if (StructureFactory.getInstance().skyscraperCount != 0) {
          cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
          StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
          System.out.println(""String_Node_Str"");
          playerSelectedDistrict.addSkyscraper();
          System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
          projectedCosts=projectedCosts + playerSelectedDistrict.skyscraperCost;
          totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
          clearRadio();
        }
 else         messageTextField.setText(""String_Node_Str"");
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      if (StructureFactory.getInstance().monopolyTowerCount != 0) {
        cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
        System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str""+ currentlySelectedRadioButton+ ""String_Node_Str"");
        StructureFactory.getInstance().get(StructureFactory.getInstance().getStructureByName(""String_Node_Str""));
        System.out.println(""String_Node_Str"");
        playerSelectedDistrict.addMonopolyTower();
        System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName());
        projectedCosts=projectedCosts + 7;
        totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
        clearRadio();
      }
 else       messageTextField.setText(""String_Node_Str"");
    }
 else     if (currentlySelectedRadioButton.compareToIgnoreCase(""String_Node_Str"") == 0) {
      cartListModel.addElement(playerSelectedDistrict.getName() + ""String_Node_Str"" + currentlySelectedRadioButton);
      System.out.println(""String_Node_Str"" + playerSelectedDistrict.getName() + ""String_Node_Str"");
      projectedCosts=projectedCosts + playerSelectedDistrict.hazard.getBlockCount() * .5;
      totalTextField.setText(""String_Node_Str"" + projectedCosts + ""String_Node_Str"");
    }
  }
}",0.9911242603550297
154273,"@Override public void performCard(){
  gameMaster=GameMaster.getInstance();
  gamePane=GamePane.getInstance();
  gamePane.clearMessageLayer();
  if (!failed)   gamePane.setMessagePanelText(""String_Node_Str"");
 else   gamePane.setMessagePanelText(""String_Node_Str"");
  gamePane.addMessagePanelText(""String_Node_Str"");
  gamePane.setSelectedDistrict(-1);
  JButton startAuctionButton=new JButton(""String_Node_Str"");
  startAuctionButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      startAuctionButtonPerformed();
    }
  }
);
  gamePane.addMessagePanelButton(startAuctionButton);
}","@Override public void performCard(){
  gameMaster=GameMaster.getInstance();
  gamePane=GamePane.getInstance();
  gamePane.clearMessageLayer();
  if (!failed)   gamePane.setMessagePanelText(""String_Node_Str"");
 else   gamePane.setMessagePanelText(""String_Node_Str"");
  gamePane.addMessagePanelText(""String_Node_Str"");
  gamePane.clearSelectedDistrict();
  JButton startAuctionButton=new JButton(""String_Node_Str"");
  startAuctionButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      startAuctionButtonPerformed();
    }
  }
);
  gamePane.addMessagePanelButton(startAuctionButton);
}",0.9921135646687698
154274,"protected void startAuctionButtonPerformed(){
  int selectedDistrictIndex=gamePane.getSelectedDistrict();
  Board board=gameMaster.getBoard();
  Square selectedSquare=board.getSquare(selectedDistrictIndex);
  District district;
  if (selectedSquare.getType() == SQUARETYPE.DISTRICT) {
    district=(District)selectedSquare;
    if (!district.isOwned()) {
      gamePane.clearSelectedDistrict();
      gameMaster.startAuction();
    }
 else {
      failed=true;
      performCard();
    }
  }
}","protected void startAuctionButtonPerformed(){
  int selectedDistrictIndex=gamePane.getSelectedDistrict();
  Board board=gameMaster.getBoard();
  if (selectedDistrictIndex != -1) {
    Square selectedSquare=board.getSquare(selectedDistrictIndex);
    District district;
    if (selectedSquare.getType() == SQUARETYPE.DISTRICT) {
      district=(District)selectedSquare;
      if (!district.isOwned()) {
        gameMaster.startAuction();
      }
 else {
        failed=true;
        performCard();
      }
    }
  }
 else {
    failed=true;
    performCard();
  }
}",0.7965941343424787
154275,"public ChanceDeck(){
  chanceCards=new ArrayList<ChanceCard>();
  discardPile=new ArrayList<ChanceCard>();
  chanceCards.add(new ChanceCardEasyMoney());
  chanceCards.add(new ChanceCardAuctionUnowned());
  Collections.shuffle(chanceCards);
}","public ChanceDeck(){
  chanceCards=new ArrayList<ChanceCard>();
  discardPile=new ArrayList<ChanceCard>();
  chanceCards.add(new ChanceCardEasyMoney());
  chanceCards.add(new ChanceCardAuctionUnowned());
  chanceCards.add(new ChanceCardInheritance());
  Collections.shuffle(chanceCards);
}",0.909433962264151
154276,"public void resumeTurn(){
  if (!currentPlayer.rolledDoubles) {
    if (!isBuilding) {
      gamePane.disableButton(gamePane.getRollDiceButton());
      gamePane.enableButton(gamePane.getBuildButton());
      gamePane.enableButton(gamePane.getEndTurnButton());
    }
 else {
      gamePane.disableButton(gamePane.getRollDiceButton());
      gamePane.disableButton(gamePane.getBuildButton());
      gamePane.enableButton(gamePane.getEndTurnButton());
    }
  }
 else {
    if (isBuilding) {
      gamePane.enableButton(gamePane.getRollDiceButton());
      gamePane.disableButton(gamePane.getBuildButton());
      gamePane.disableButton(gamePane.getEndTurnButton());
    }
 else {
      gamePane.disableButton(gamePane.getRollDiceButton());
      gamePane.enableButton(gamePane.getBuildButton());
      gamePane.disableButton(gamePane.getEndTurnButton());
    }
  }
}","public void resumeTurn(){
  if (!currentPlayer.rolledDoubles) {
    if (!isBuilding) {
      gamePane.disableButton(gamePane.getRollDiceButton());
      gamePane.enableButton(gamePane.getBuildButton());
      gamePane.enableButton(gamePane.getEndTurnButton());
    }
 else {
      gamePane.disableButton(gamePane.getRollDiceButton());
      gamePane.disableButton(gamePane.getBuildButton());
      gamePane.enableButton(gamePane.getEndTurnButton());
    }
  }
 else {
    if (isBuilding) {
      gamePane.disableButton(gamePane.getRollDiceButton());
      gamePane.disableButton(gamePane.getBuildButton());
      gamePane.enableButton(gamePane.getEndTurnButton());
    }
 else {
      gamePane.enableButton(gamePane.getRollDiceButton());
      gamePane.enableButton(gamePane.getBuildButton());
      gamePane.disableButton(gamePane.getEndTurnButton());
    }
  }
}",0.9913244650086755
154277,"public void roll(){
  gamePane.enableButton(gamePane.getEndTurnButton());
  int[] dice=rollDice();
  System.out.println(""String_Node_Str"" + Integer.toString(dice[0]) + ""String_Node_Str""+ Integer.toString(dice[1]));
  if (dice[0] == dice[1]) {
    System.out.println(currentPlayer.getName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Integer.toString(currentPlayer.getNumDoubles()));
    currentPlayer.setDoubles(true);
    if (currentPlayer.isInJail) {
      gamePane.setMessagePanelText(""String_Node_Str"" + currentPlayer.getName() + ""String_Node_Str"");
      currentPlayer.setIsInJail(false);
      currentPlayer.setDoubles(false);
    }
    if (currentPlayer.getNumDoubles() > 2) {
      System.out.println(""String_Node_Str"" + currentPlayer.getIndex() + ""String_Node_Str"");
      currentPlayer.setIsInJail(true);
      gamePane.disableButton(gamePane.getBuildButton());
      gamePane.setMessagePanelText(""String_Node_Str"");
      JButton button=new JButton(""String_Node_Str"");
      button.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent event){
          endTurn();
        }
      }
);
    }
    if (!currentPlayer.isInJail) {
      checkSquare(dice[0] + dice[1]);
    }
  }
 else {
    if (currentPlayer.isInJail) {
      gamePane.clearMessageLayer();
      gamePane.setMessagePanelText(""String_Node_Str"");
      currentPlayer.setIsInJail(true);
    }
 else {
      currentPlayer.setDoubles(false);
      checkSquare(dice[0] + dice[1]);
    }
  }
  gamePane.update();
}","public void roll(){
  gamePane.enableButton(gamePane.getEndTurnButton());
  int[] dice=rollDice();
  System.out.println(""String_Node_Str"" + Integer.toString(dice[0]) + ""String_Node_Str""+ Integer.toString(dice[1]));
  if (dice[0] == dice[1]) {
    System.out.println(currentPlayer.getName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Integer.toString(currentPlayer.getNumDoubles()));
    currentPlayer.setDoubles(true);
    if (currentPlayer.isInJail) {
      gamePane.setMessagePanelText(""String_Node_Str"" + currentPlayer.getName() + ""String_Node_Str"");
      currentPlayer.setIsInJail(false);
      currentPlayer.setDoubles(false);
    }
    if (currentPlayer.getNumDoubles() > 2) {
      System.out.println(""String_Node_Str"" + currentPlayer.getIndex() + ""String_Node_Str"");
      currentPlayer.setIsInJail(true);
      gamePane.disableButton(gamePane.getBuildButton());
      gamePane.setMessagePanelText(""String_Node_Str"");
      JButton button=new JButton(""String_Node_Str"");
      button.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent event){
          endTurn();
        }
      }
);
    }
    if (!currentPlayer.isInJail) {
      checkSquare(dice[0] + dice[1]);
    }
  }
 else {
    if (currentPlayer.isInJail) {
      gamePane.clearMessageLayer();
      gamePane.setMessagePanelText(""String_Node_Str"");
      currentPlayer.setIsInJail(true);
    }
 else {
      currentPlayer.setDoubles(false);
      checkSquare(dice[0] + dice[1]);
    }
  }
  resumeTurn();
  gamePane.update();
}",0.9948486799742434
154278,"public void endTurn(){
  currentPlayer.rolledDoubles=false;
  currentPlayer.numDoubles=0;
  currentPlayer=getNextPlayer();
  gamePane.clearMessageLayer();
  gamePane.update();
  startTurn();
}","public void endTurn(){
  currentPlayer=getNextPlayer();
  gamePane.clearMessageLayer();
  gamePane.update();
  startTurn();
}",0.7886435331230284
154279,"public double distancia(Entidade a){
  int x, y;
  x=a.getX() - getX();
  y=a.getY() - getY();
  return Math.sqrt(x * x - y * y);
}","public double distancia(Entidade a){
  int x, y;
  x=a.getX() - getX();
  y=a.getY() - getY();
  return Math.sqrt(x * x + y * y);
}",0.9923664122137404
154280,"private void adicionaAgentes(){
  int i;
  for (i=0; i < 30; i++) {
    adicionaEntidade(new AgenteDummy(0,0,Constants.ENTIDADE_ENERGIA_INICIAL));
    adicionaEntidade(new AgenteInimigo(Constants.LARGURA_MAPA,0,Constants.ENTIDADE_ENERGIA_INICIAL));
  }
}","private void adicionaAgentes(){
  int i;
  int x=Constants.LARGURA_TELA / 2, y=Constants.ALTURA_TELA / 2;
  for (i=0; i < 15; i++) {
    adicionaEntidade(new AgenteDummy(x,y,Constants.ENTIDADE_ENERGIA_INICIAL));
    adicionaEntidade(new AgenteInimigo(x,y,Constants.ENTIDADE_ENERGIA_INICIAL));
  }
}",0.7318840579710145
154281,"private void processaTeclado(){
  if (teclado.isKeyDown(KeyEvent.VK_UP)) {
    intervaloUpdate-=Constants.INTERVALO_UPDATE_INCREMENTO;
  }
 else   if (teclado.isKeyDown(KeyEvent.VK_DOWN)) {
    intervaloUpdate+=Constants.INTERVALO_UPDATE_INCREMENTO;
  }
 else   if (teclado.isKeyDown(KeyEvent.VK_RIGHT) || teclado.isKeyDown(KeyEvent.VK_LEFT)) {
    intervaloUpdate=Constants.INTERVALO_UPDATE;
  }
  if (teclado.isKeyDown(KeyEvent.VK_Q)) {
    termina();
  }
}","private void processaTeclado(){
  if (teclado.isKeyDown(KeyEvent.VK_UP)) {
    intervaloUpdate-=Constants.INTERVALO_UPDATE_INCREMENTO;
  }
 else   if (teclado.isKeyDown(KeyEvent.VK_DOWN)) {
    intervaloUpdate+=Constants.INTERVALO_UPDATE_INCREMENTO;
  }
 else   if (teclado.isKeyDown(KeyEvent.VK_RIGHT) || teclado.isKeyDown(KeyEvent.VK_LEFT)) {
    intervaloUpdate=Constants.INTERVALO_UPDATE;
  }
  if (teclado.isKeyDown(KeyEvent.VK_Q) || teclado.isKeyDown(KeyEvent.VK_ESCAPE)) {
    termina();
  }
  if (teclado.isKeyDown(KeyEvent.VK_D)) {
    debug=true;
  }
 else {
    debug=false;
  }
}",0.8723809523809524
154282,"private void desenhaAgente(Graphics g,Agente a){
  int i=0;
  int frameAtual=getFrameCorrente(""String_Node_Str"",a);
  long tempoAgora=System.currentTimeMillis();
  desenhaAnimacao(""String_Node_Str"",imgEnergia,g,a,200,200);
  desenhaAnimacao(""String_Node_Str"",imgMensagens,g,a,160,160);
  desenhaAnimacao(""String_Node_Str"",imgMensagens,g,a,160,160);
switch (a.getDirecao()) {
case Agente.DIREITA:
    i=2;
  break;
case Agente.ESQUERDA:
i=1;
break;
case Agente.CIMA:
i=3;
break;
case Agente.BAIXO:
i=0;
break;
default :
}
frameAtual=getFrameCorrente(""String_Node_Str"",a);
if (tempoAgora >= getTimeProximoRender(""String_Node_Str"",a)) {
setTimeProximoRender(""String_Node_Str"",a,tempoAgora + INTERVALO_RENDER_SPRITES);
incrementaFrame(""String_Node_Str"",a,frameAtual);
}
desenhaSprite(g,a.getX(),a.getY(),i,frameAtual,getTipoSprite(a));
}","private void desenhaAgente(Graphics g,Agente a){
  int i=0;
  int frameAtual=getFrameCorrente(""String_Node_Str"",a);
  long tempoAgora=System.currentTimeMillis();
  desenhaAnimacao(""String_Node_Str"",imgEnergia,g,a,200,200);
  desenhaAnimacao(""String_Node_Str"",imgMensagens,g,a,160,160);
  desenhaAnimacao(""String_Node_Str"",imgMensagens,g,a,160,160);
switch (a.getDirecao()) {
case Agente.DIREITA:
    i=2;
  break;
case Agente.ESQUERDA:
i=1;
break;
case Agente.CIMA:
i=3;
break;
case Agente.BAIXO:
i=0;
break;
default :
}
frameAtual=getFrameCorrente(""String_Node_Str"",a);
if (tempoAgora >= getTimeProximoRender(""String_Node_Str"",a)) {
setTimeProximoRender(""String_Node_Str"",a,tempoAgora + INTERVALO_RENDER_SPRITES);
incrementaFrame(""String_Node_Str"",a,frameAtual);
}
desenhaSprite(g,a.getX(),a.getY(),i,frameAtual,getTipoSprite(a));
if (arena.isDebug()) {
g.setColor(Color.GREEN);
g.fillRect(a.getX() + getTamanho(a,LARGURA) / 2 - 3,a.getY() + getTamanho(a,ALTURA) / 2 - 3,6,6);
}
}",0.918412348401323
154283,"public void agenteRecebeuEnergia(Agente a){
}","public void agenteRecebeuEnergia(Agente a){
  ativaAnimacao(""String_Node_Str"",a,500);
}",0.6818181818181818
154284,"private void desenhaPontoEnergia(Graphics g,PontoEnergia p){
  g.drawImage(imgPontosEnergia,p.getX(),p.getY(),p.getX() + 50,p.getY() + 60,55,0,90,60,null);
}","private void desenhaPontoEnergia(Graphics g,PontoEnergia p){
  g.drawImage(imgPontosEnergia,p.getX(),p.getY(),p.getX() + 50,p.getY() + 60,55,0,90,60,null);
  if (arena.isDebug()) {
    g.setColor(Color.RED);
    g.fillRect(p.getX() + getTamanho(p,LARGURA) / 2 - 3,p.getY() + getTamanho(p,ALTURA) / 2 - 3,6,6);
  }
}",0.6652542372881356
154285,"public double distancia(Entidade a){
  int x, y;
  x=a.getX() - getX();
  y=a.getY() - getY();
  return Math.sqrt(x * x + y * y);
}","public double distancia(Entidade a){
  int x, y;
  Desenhista d=getArena().getDesenhista();
  x=(a.getX() + d.getTamanho(a,Desenhista.LARGURA) / 2) - (getX() + d.getTamanho(this,Desenhista.LARGURA) / 2);
  y=(a.getY() + d.getTamanho(a,Desenhista.ALTURA) / 2) - (getY() + d.getTamanho(this,Desenhista.ALTURA) / 2);
  return Math.sqrt(x * x + y * y);
}",0.5446985446985447
154286,"public final void update(){
  if (isMorta()) {
    return;
  }
  protegeInformacoes(true);
  pensa();
  protegeInformacoes(false);
  if (!isParado()) {
    movePara(getDirecao());
    gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_ANDAR);
  }
  gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_VIVER);
  processaCombate();
}","public final void update(){
  if (isMorta()) {
    return;
  }
  protegeInformacoes(true);
  pensa();
  protegeInformacoes(false);
  if (fazerDivisao) {
    fazDivisao();
  }
  if (!isParado()) {
    movePara(getDirecao());
    gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_ANDAR);
  }
  gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_VIVER);
  processaCombate();
}",0.935672514619883
154287,"public final boolean divide(){
  if (podeDividir()) {
    gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_DIVIDIR);
    gastaEnergia(getEnergia() / 2);
    getArena().divideEntidade(this);
    return true;
  }
 else {
    return false;
  }
}","public final boolean divide(){
  if (podeDividir()) {
    fazerDivisao=true;
    return true;
  }
 else {
    fazerDivisao=false;
    return false;
  }
}",0.6122448979591837
154288,"public Agente(Integer x,Integer y,Integer energia){
  super(x,y,energia);
  setDirecao(geraDirecaoAleatoria());
  avisouMorte=false;
}","public Agente(Integer x,Integer y,Integer energia){
  super(x,y,energia);
  setDirecao(geraDirecaoAleatoria());
  avisouMorte=false;
  fazerDivisao=false;
}",0.9241379310344828
154289,"public void pensa(){
  if (!podeMoverPara(getDirecao())) {
    setDirecao(geraDirecaoAleatoria());
  }
  if (podeDividir()) {
  }
}","public void pensa(){
  if (!podeMoverPara(getDirecao())) {
    setDirecao(geraDirecaoAleatoria());
  }
  if (podeDividir() && getEnergia() >= 400) {
    divide();
  }
}",0.8762541806020067
154290,"public void divideEntidade(Entidade entidade){
  try {
    Class[] argsConstrutor=new Class[]{Integer.class,Integer.class,Integer.class};
    Class classe=entidade.getClass();
    Constructor construtor=classe.getConstructor(argsConstrutor);
    Entidade nova=(Entidade)construtor.newInstance(entidade.getX(),entidade.getY(),entidade.getEnergia());
    agendaNascimento(nova);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
  }
}","public void divideEntidade(Entidade entidade){
  try {
    Class[] argsConstrutor=new Class[]{Integer.class,Integer.class,Integer.class};
    Class classe=entidade.getClass();
    Constructor construtor=classe.getConstructor(argsConstrutor);
    Entidade nova=(Entidade)construtor.newInstance(entidade.getX(),entidade.getY(),entidade.getEnergia());
    agendaNascimento(nova);
    if (entidade instanceof Agente) {
      estatistico.contabilizaDivisao((Agente)entidade);
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
  }
}",0.9040307101727448
154291,"/** 
 * Envia uma mensagem para os agentes que esto prximos.
 * @param msg string que ser enviada como mensagem para os agentes que esto prximos. Todos os agentes que receberem a mensagem tero o mtodo recebeuMensagem() invocado. 
 */
public final void enviaMensagem(String msg){
  Agente d;
  for (  Entidade a : getArena().getEntidades()) {
    if ((a instanceof Agente) && (distancia(a) <= Constants.AGENTE_ALCANCE_MENSAGEM)) {
      d=(Agente)a;
      d.recebeuMensagem(msg,this);
    }
  }
}","/** 
 * Envia uma mensagem para os agentes que esto prximos.
 * @param msg string que ser enviada como mensagem para os agentes que esto prximos. Todos os agentes que receberem a mensagem tero o mtodo recebeuMensagem() invocado. 
 */
public final void enviaMensagem(String msg){
  Agente d;
  for (  Entidade a : getArena().getEntidades()) {
    if ((a instanceof Agente) && (distancia(a) <= Constants.AGENTE_ALCANCE_MENSAGEM)) {
      d=(Agente)a;
      d.sinalizaRecebeuMensagem(msg,this);
    }
  }
}",0.9901185770750988
154292,"private void processaCombate(){
  Agente inimigo=getInimigoJuntoComigo();
  boolean morreu=false;
  if (inimigo != null) {
    morreu=dahPancada(inimigo);
    if (morreu) {
      ganhaEnergia(Constants.ENTIDADE_COMBATE_RECOMPENSA);
      ganhouCombate();
    }
  }
}","private void processaCombate(){
  Agente inimigo=getInimigoJuntoComigo();
  boolean morreu=false;
  if (inimigo != null) {
    morreu=dahPancada(inimigo);
    if (morreu) {
      ganhaEnergia(Constants.ENTIDADE_COMBATE_RECOMPENSA);
      sinalizaGanhouCombate();
    }
  }
}",0.9814814814814816
154293,"private boolean dahPancada(Agente inimigo){
  boolean morreu;
  morreu=inimigo.gastaEnergia(Constants.ENTIDADE_COMBATE_DANO);
  if (!morreu) {
    inimigo.tomouDano(this);
  }
  return morreu;
}","private boolean dahPancada(Agente inimigo){
  boolean morreu;
  morreu=inimigo.gastaEnergia(Constants.ENTIDADE_COMBATE_DANO);
  if (!morreu) {
    inimigo.sinalizaTomouDano(this);
  }
  return morreu;
}",0.9747474747474748
154294,"private void recarregaEnergiaAgente(Agente a){
  a.ganhaEnergia(Constants.PONTO_ENERGIA_ENTREGA_TURNO);
  gastaEnergia(Constants.PONTO_ENERGIA_ENTREGA_TURNO);
  a.recebeuEnergia();
  System.out.println(""String_Node_Str"" + getId() + ""String_Node_Str""+ a);
}","private void recarregaEnergiaAgente(Agente a){
  a.ganhaEnergia(Constants.PONTO_ENERGIA_ENTREGA_TURNO);
  gastaEnergia(Constants.PONTO_ENERGIA_ENTREGA_TURNO);
  a.sinalizaRecebeuEnergia();
  System.out.println(""String_Node_Str"" + getId() + ""String_Node_Str""+ a);
}",0.9807692307692308
154295,"private Agente getInimigoJuntoComigo(){
  Agente i=null, retorno=null;
  for (  Entidade a : getArena().getEntidades()) {
    if (a instanceof Agente) {
      i=(Agente)a;
      if (i.getX() == getX() && i.getY() == getY() && isInimigo(i)) {
        retorno=i;
        break;
      }
    }
  }
  return retorno;
}","private Agente getInimigoJuntoComigo(){
  Agente i=null, retorno=null;
  for (  Entidade a : super.getArena().getEntidades()) {
    if (a instanceof Agente) {
      i=(Agente)a;
      if (i.getX() == getX() && i.getY() == getY() && isInimigo(i)) {
        retorno=i;
        break;
      }
    }
  }
  return retorno;
}",0.990506329113924
154296,"private void fazDivisao(){
  fazerDivisao=false;
  if (podeDividir()) {
    gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_DIVIDIR);
    gastaEnergia(getEnergia() / 2);
    getArena().divideEntidade(this);
  }
}","private void fazDivisao(){
  fazerDivisao=false;
  if (podeDividir()) {
    gastaEnergia(Constants.ENTIDADE_ENERGIA_GASTO_DIVIDIR);
    gastaEnergia(getEnergia() / 2);
    super.getArena().divideEntidade(this);
  }
}",0.9389671361502347
154297,"/** 
 * Envia uma mensagem para os agentes que esto prximos.
 * @param msg string que ser enviada como mensagem para os agentes que esto prximos. Todos os agentes que receberem a mensagem tero o mtodo recebeuMensagem() invocado. 
 */
public final void enviaMensagem(String msg){
  Agente d;
  for (  Entidade a : getArena().getEntidades()) {
    if ((a instanceof Agente) && (distancia(a) <= Constants.AGENTE_ALCANCE_MENSAGEM)) {
      d=(Agente)a;
      d.sinalizaRecebeuMensagem(msg,this);
    }
  }
}","/** 
 * Envia uma mensagem para os agentes que esto prximos.
 * @param msg string que ser enviada como mensagem para os agentes que esto prximos. Todos os agentes que receberem a mensagem tero o mtodo recebeuMensagem() invocado. 
 */
public final void enviaMensagem(String msg){
  Agente d;
  for (  Entidade a : super.getArena().getEntidades()) {
    if ((a instanceof Agente) && (distancia(a) <= Constants.AGENTE_ALCANCE_MENSAGEM)) {
      d=(Agente)a;
      d.sinalizaRecebeuMensagem(msg,this);
    }
  }
}",0.9941520467836256
154298,"/** 
 * Mata um agente instantaneamente (comete suicdio). A energia que o agente carregava  perdida.
 */
public final void morre(){
  if (!avisouMorte) {
    avisouMorte=true;
    getArena().removeEntidade(this);
  }
}","/** 
 * Mata um agente instantaneamente (comete suicdio). A energia que o agente carregava  perdida.
 */
public final void morre(){
  if (!avisouMorte) {
    avisouMorte=true;
    super.getArena().removeEntidade(this);
  }
}",0.9865470852017936
154299,"/** 
 * Envia uma mensagem para os agentes que esto prximos.
 * @param msg string que ser enviada como mensagem para os agentes que esto prximos. Todos os agentes que receberem a mensagem tero o mtodo recebeuMensagem() invocado. 
 */
public final void enviaMensagem(String msg){
  Agente d;
  for (  Entidade a : super.getArena().getEntidades()) {
    if ((a instanceof Agente) && (distancia(a) <= Constants.AGENTE_ALCANCE_MENSAGEM)) {
      super.getArena().getDesenhista().agenteEnviouMensagem((Agente)a,msg);
      d=(Agente)a;
      d.sinalizaRecebeuMensagem(msg,this);
    }
  }
}","/** 
 * Envia uma mensagem para os agentes que esto prximos.
 * @param msg string que ser enviada como mensagem para os agentes que esto prximos. Todos os agentes que receberem a mensagem tero o mtodo recebeuMensagem() invocado. 
 */
public final void enviaMensagem(String msg){
  Agente d;
  for (  Entidade a : super.getArena().getEntidades()) {
    if ((a instanceof Agente) && (((Agente)a).getEquipe() == getEquipe()) && (distancia(a) <= Constants.AGENTE_ALCANCE_MENSAGEM)) {
      super.getArena().getDesenhista().agenteEnviouMensagem((Agente)a,msg);
      d=(Agente)a;
      d.sinalizaRecebeuMensagem(msg,this);
    }
  }
}",0.9641693811074918
154300,"private void morrePorErroExcecao(Exception e){
  boolean status=isInfosProtegidas();
  System.out.println(""String_Node_Str"" + this);
  e.printStackTrace();
  getArena().getDesenhista().agenteMorreuPorExcecao(this,e);
  protegeInformacoes(false);
  morre();
  protegeInformacoes(status);
}","private void morrePorErroExcecao(Exception e){
  boolean status=isInfosProtegidas();
  System.out.println(""String_Node_Str"" + this);
  e.printStackTrace();
  super.getArena().getDesenhista().agenteMorreuPorExcecao(this,e);
  protegeInformacoes(false);
  morre();
  protegeInformacoes(status);
}",0.9896907216494846
154301,"@Override public void onPlayerInteract(PlayerInteractEvent event){
  Action action=event.getAction();
  Player player=event.getPlayer();
  World world=player.getWorld();
  WorldConfig worldConfig=configManager.getWorldConfig(world);
  if (event.hasItem()) {
    if (plugin.hasPermissions(player,""String_Node_Str"")) {
      if (worldConfig.lightningEnable) {
        int item=worldConfig.lightningWand;
        int count=worldConfig.lightningCount;
        if (wandManager.hasWandCount(player.getName())) {
          count=wandManager.getWandCount(player.getName());
        }
        if (item != 0) {
          if (event.getItem().getTypeId() == item) {
            Location pos=player.getTargetBlock(null,120).getLocation();
            if ((action == Action.LEFT_CLICK_BLOCK) || (action == Action.LEFT_CLICK_AIR)) {
              for (int i=0; i < count; i++) {
                world.strikeLightning(pos);
              }
            }
 else             if ((action == Action.RIGHT_CLICK_BLOCK) || (action == Action.RIGHT_CLICK_AIR)) {
              for (int i=0; i < count; i++) {
                world.strikeLightningEffect(pos);
              }
            }
          }
        }
      }
 else {
        player.sendMessage(ChatColor.RED + configManager.Lightning_is_disabled);
      }
    }
  }
}","@Override public void onPlayerInteract(PlayerInteractEvent event){
  Action action=event.getAction();
  Player player=event.getPlayer();
  World world=player.getWorld();
  WorldConfig worldConfig=configManager.getWorldConfig(world);
  if (event.hasItem()) {
    if (plugin.hasPermissions(player,""String_Node_Str"")) {
      int item=worldConfig.lightningWand;
      int count=worldConfig.lightningCount;
      if (wandManager.hasWandCount(player.getName())) {
        count=wandManager.getWandCount(player.getName());
      }
      if (item != 0) {
        if (event.getItem().getTypeId() == item) {
          if (worldConfig.lightningEnable) {
            Location pos=player.getTargetBlock(null,120).getLocation();
            if (action.equals(action.LEFT_CLICK_BLOCK) || action.equals(Action.LEFT_CLICK_AIR)) {
              for (int i=0; i < count; i++) {
                world.strikeLightning(pos);
              }
            }
 else             if (action.equals(Action.RIGHT_CLICK_BLOCK) || action.equals(Action.RIGHT_CLICK_AIR)) {
              for (int i=0; i < count; i++) {
                world.strikeLightningEffect(pos);
              }
            }
          }
 else {
            player.sendMessage(ChatColor.RED + configManager.Lightning_is_disabled);
          }
        }
      }
    }
  }
}",0.9058913542463656
154302,"@Override public void onResponseReceived(Request request,Response response){
  System.out.println(response.toString());
  System.out.println(""String_Node_Str"");
}","@Override public void onResponseReceived(Request request,Response response){
  System.out.println(response.toString());
  System.out.println(""String_Node_Str"");
  popUpPanel.hide();
  createButton.setEnabled(true);
  createButton.setText(""String_Node_Str"");
  MessageDisplayer.DisplayMessage(""String_Node_Str"");
}",0.6821052631578948
154303,"@SuppressWarnings(""String_Node_Str"") public static void doPostJson(String url,Json json,RequestCallback requestCallback){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,url);
  if (YapoolGWT.currentSession.getName() == null) {
    Window.alert(""String_Node_Str"");
  }
  builder.setHeader(""String_Node_Str"",""String_Node_Str"");
  try {
    Request response=builder.sendRequest(json.toString(),requestCallback);
  }
 catch (  RequestException e) {
    Window.alert(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
  }
}","@SuppressWarnings(""String_Node_Str"") public static void doPostJson(String url,Json json,RequestCallback requestCallback){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,url);
  if (YapoolGWT.currentSession.getName() == null) {
    Window.alert(""String_Node_Str"");
    return;
  }
  builder.setHeader(""String_Node_Str"",""String_Node_Str"");
  try {
    Request response=builder.sendRequest(json.toString(),requestCallback);
  }
 catch (  RequestException e) {
    Window.alert(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
  }
}",0.9891304347826086
154304,"public void loadSession(String jsonString){
  currentSession=new SessionObject(jsonString);
}","public void loadSession(){
  HttpInterface.doGet(""String_Node_Str"",new AbstractRequestCallback(){
    @Override public void onResponseReceived(    Request request,    Response response){
      currentSession=new SessionObject(response.getText());
      if (!componentLoaded) {
        loadComponent();
        componentLoaded=true;
      }
      if (currentSession.getName() != null) {
        setSignState(true);
      }
 else {
        setSignState(false);
      }
    }
  }
);
}",0.229965156794425
154305,"/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  HttpInterface.doGet(""String_Node_Str"",new AbstractRequestCallback(){
    @Override public void onResponseReceived(    Request request,    Response response){
      currentSession=new SessionObject(response.getText());
      loadComponent();
      if (currentSession.getName() != null) {
        setSignState(true);
      }
 else {
        setSignState(false);
      }
    }
  }
);
}","/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  loadSession();
}",0.3223443223443223
154306,"@Override public void onResponseReceived(Request request,Response response){
  currentSession=new SessionObject(response.getText());
  loadComponent();
  if (currentSession.getName() != null) {
    setSignState(true);
  }
 else {
    setSignState(false);
  }
}","@Override public void onResponseReceived(Request request,Response response){
  currentSession=new SessionObject(response.getText());
  if (currentSession.getName() != null) {
    signUnit.signIn();
    setSignState(true);
  }
 else {
    signUnit.signOut();
    setSignState(false);
  }
}",0.8795620437956204
154307,"@Override public void onResponseReceived(Request request,Response response){
  if (yapoolGWT.getSignState() == false) {
    if (SignRequestCallback.responseIsOk(response)) {
      yapoolGWT.setSignState(true);
    }
 else     if (!SignRequestCallback.responseIsOk(response)) {
      messageLabel.setVisible(true);
      messageLabel.setText(response.getText());
    }
  }
 else   if (yapoolGWT.getSignState() == true) {
    yapoolGWT.setSignState(false);
  }
}","@Override public void onResponseReceived(Request request,Response response){
  System.out.println(response.getText());
  if (yapoolGWT.getSignState() == false) {
    if (SignRequestCallback.responseIsOk(response)) {
      yapoolGWT.reloadSession();
    }
 else     if (!SignRequestCallback.responseIsOk(response)) {
      messageLabel.setVisible(true);
      messageLabel.setText(response.getText());
    }
  }
 else   if (yapoolGWT.getSignState() == true) {
    yapoolGWT.reloadSession();
  }
}",0.8900523560209425
154308,"/** 
 * Returns a list of all potentially valid moves. i.e. guaranteed to be in-range, but not necessarily valid given the board state.
 * @param board
 * @return
 */
public List<Move> allMoves(Board board){
  LinkedList<Move> potentialMoves=new LinkedList<Move>();
  if (board.getSpace(this).getUp() != null) {
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getUp()));
    if (board.getSpace(this).getUp().getRight() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getUp().getRight()));
    if (board.getSpace(this).getUp().getUp() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getUp().getUp()));
  }
  if (board.getSpace(this).getRight() != null) {
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getRight()));
    if (board.getSpace(this).getRight().getDown() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown()));
    if (board.getSpace(this).getRight().getRight() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getRight()));
  }
  if (board.getSpace(this).getDown() != null) {
    if (board.getSpace(this).getDown().getLeft() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown().getLeft()));
    if (board.getSpace(this).getDown().getDown() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown().getDown()));
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown()));
  }
  if (board.getSpace(this).getLeft() != null) {
    if (board.getSpace(this).getLeft().getUp() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getLeft().getUp()));
    if (board.getSpace(this).getLeft().getLeft() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getLeft().getLeft()));
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getLeft()));
  }
  if (board.hasWallsLeft(this)) {
    for (int col=1; col <= 8; col++) {
      for (int row=1; row <= 8; row++) {
        potentialMoves.add(new WallMove(new Wall(new Space(col,row),true)));
        potentialMoves.add(new WallMove(new Wall(new Space(col,row),false)));
      }
    }
  }
  return potentialMoves;
}","/** 
 * Returns a list of all potentially valid moves. i.e. guaranteed to be in-range, but not necessarily valid given the board state.
 * @param board
 * @return
 */
public List<Move> allMoves(Board board){
  LinkedList<Move> potentialMoves=new LinkedList<Move>();
  if (board.getSpace(this).getUp() != null) {
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getUp()));
    if (board.getSpace(this).getUp().getRight() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getUp().getRight()));
    if (board.getSpace(this).getUp().getUp() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getUp().getUp()));
  }
  if (board.getSpace(this).getRight() != null) {
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getRight()));
    if (board.getSpace(this).getRight().getDown() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getRight().getDown()));
    if (board.getSpace(this).getRight().getRight() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getRight().getRight()));
  }
  if (board.getSpace(this).getDown() != null) {
    if (board.getSpace(this).getDown().getLeft() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown().getLeft()));
    if (board.getSpace(this).getDown().getDown() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown().getDown()));
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getDown()));
  }
  if (board.getSpace(this).getLeft() != null) {
    if (board.getSpace(this).getLeft().getUp() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getLeft().getUp()));
    if (board.getSpace(this).getLeft().getLeft() != null)     potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getLeft().getLeft()));
    potentialMoves.add(new MovementMove(board.getSpace(this),board.getSpace(this).getLeft()));
  }
  if (board.hasWallsLeft(this)) {
    for (int col=1; col <= 8; col++) {
      for (int row=1; row <= 8; row++) {
        potentialMoves.add(new WallMove(new Wall(new Space(col,row),true)));
        potentialMoves.add(new WallMove(new Wall(new Space(col,row),false)));
      }
    }
  }
  return potentialMoves;
}",0.9955102040816326
154309,"/** 
 * Looks at the board and figures out what move to make. Calls negamax() for each possible move and picks the best one. If there are multiple equally best, it picks one of them at random.
 * @see quoridor.Player#getMove(quoridor.Board)
 */
public Move getMove(Board board){
  assert(this.equals(board.currentPlayer()));
  Board newBoard;
  List<Move> potentialMoves=validMoves(board);
  List<Move> bestMoves=new LinkedList<Move>();
  Collections.sort(potentialMoves,new MinimaxComparator(board.getSpace(board.players.other(this))));
  int bestCase=Integer.MIN_VALUE;
  int evaluation;
  int depth;
  startTime=System.currentTimeMillis();
  for (depth=1; depth <= maxDepth && System.currentTimeMillis() - startTime < timeOut; depth++) {
    for (    Move move : potentialMoves) {
      try {
        newBoard=board.clone();
        newBoard.makeMove(move);
        evaluation=-negamax(newBoard,Integer.MIN_VALUE + 1,Integer.MAX_VALUE,depth - 1);
        move.awesomeness=evaluation;
        if (evaluation > bestCase) {
          bestMoves.clear();
          bestMoves.add(move);
          bestCase=evaluation;
        }
 else         if (evaluation == bestCase) {
          bestMoves.add(move);
        }
      }
 catch (      Exception e) {
      }
    }
    Collections.sort(potentialMoves,new MinimaxComparator());
  }
  int pick=(int)Math.floor(bestMoves.size() * Math.random());
  System.out.println(i);
  i=0;
  return bestMoves.get(pick);
}","/** 
 * Looks at the board and figures out what move to make. Calls negamax() for each possible move and picks the best one. If there are multiple equally best, it picks one of them at random.
 * @see quoridor.Player#getMove(quoridor.Board)
 */
public Move getMove(Board board){
  assert(this.equals(board.currentPlayer()));
  Board newBoard;
  List<Move> potentialMoves=validMoves(board);
  List<Move> bestMoves=new LinkedList<Move>();
  Collections.sort(potentialMoves,new MinimaxComparator(board.getSpace(board.players.other(this))));
  int bestCase=Integer.MIN_VALUE;
  int evaluation;
  int depth;
  startTime=System.currentTimeMillis();
  for (depth=1; depth <= maxDepth && System.currentTimeMillis() - startTime < timeOut; depth++) {
    for (    Move move : potentialMoves) {
      try {
        newBoard=board.clone();
        newBoard.makeMove(move);
        evaluation=-negamax(newBoard,Integer.MIN_VALUE + 1,Integer.MAX_VALUE,depth - 1);
        move.awesomeness=evaluation;
        if (evaluation > bestCase) {
          bestMoves.clear();
          bestMoves.add(move);
          bestCase=evaluation;
        }
 else         if (evaluation == bestCase) {
          bestMoves.add(move);
        }
      }
 catch (      Exception e) {
      }
    }
    Collections.sort(potentialMoves,new MoveComparator());
  }
  int pick=(int)Math.floor(bestMoves.size() * Math.random());
  System.out.println(i);
  i=0;
  return bestMoves.get(pick);
}",0.9968976215098242
154310,"/** 
 * Checks that a jump move is valid. If the move is a regular (adjacent) move, returns true.
 * @param move
 * @return True if valid jump move
 */
private boolean jumpValid(MovementMove move){
  if (!move.isJump())   return true;
  Space middleSpace;
  Space behindSpace;
  if (move.from().row() == move.to().row()) {
    assert(Math.abs(move.from().col() - move.to().col()) == 2);
    middleSpace=new Space(Math.min(move.from().col(),move.to().col()) + 1,move.from().row());
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (move.from().col() == move.to().col()) {
    assert(Math.abs(move.from().row() - move.to().row()) == 2);
    middleSpace=new Space(move.from().col(),Math.min(move.from().row(),move.to().row()) + 1);
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (Math.abs(move.from().row() - move.to().row()) + Math.abs(move.from().col() - move.to().col()) == 2) {
    if (getSpace(players.other(move.owner)).row() == move.from().row() && getSpace(players.other(move.owner)).col() == move.to().col() || getSpace(players.other(move.owner)).col() == move.from().col() && getSpace(players.other(move.owner)).row() == move.to().row()) {
      middleSpace=getSpace(players.other(move.owner));
      if (wallIsHere(middleSpace,move.to()))       return false;
      try {
        behindSpace=new Space(2 * middleSpace.col() - move.from().col(),2 * middleSpace.row() - move.from().row());
      }
 catch (      RuntimeException e) {
        return true;
      }
      return wallIsHere(middleSpace,behindSpace);
    }
 else     return false;
  }
  return false;
}","/** 
 * Checks that a jump move is valid. If the move is a regular (adjacent) move, returns true.
 * @param move
 * @return True if valid jump move
 */
private boolean jumpValid(MovementMove move){
  if (!move.isJump())   return true;
  Space middleSpace;
  Space behindSpace;
  if (move.from().row() == move.to().row()) {
    assert(Math.abs(move.from().col() - move.to().col()) == 2);
    middleSpace=new Space(Math.min(move.from().col(),move.to().col()) + 1,move.from().row());
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (move.from().col() == move.to().col()) {
    assert(Math.abs(move.from().row() - move.to().row()) == 2);
    middleSpace=new Space(move.from().col(),Math.min(move.from().row(),move.to().row()) + 1);
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (Math.abs(move.from().row() - move.to().row()) + Math.abs(move.from().col() - move.to().col()) == 2) {
    if (getSpace(players.other(move.owner)).row() == move.from().row() && getSpace(players.other(move.owner)).col() == move.to().col() || getSpace(players.other(move.owner)).col() == move.from().col() && getSpace(players.other(move.owner)).row() == move.to().row()) {
      middleSpace=getSpace(players.other(move.owner));
      if (wallIsHere(middleSpace,move.from()))       return false;
      if (wallIsHere(middleSpace,move.to()))       return false;
      try {
        behindSpace=new Space(2 * middleSpace.col() - move.from().col(),2 * middleSpace.row() - move.from().row());
      }
 catch (      RuntimeException e) {
        return true;
      }
      return wallIsHere(middleSpace,behindSpace);
    }
 else     return false;
  }
  return false;
}",0.982483660130719
154311,"/** 
 * Looks at the board and figures out what move to make. Calls negamax() for each possible move and picks the best one. If there are multiple equally best, it picks one of them at random.
 * @see quoridor.Player#getMove(quoridor.Board)
 */
public Move getMove(Board board){
  assert(this.equals(board.currentPlayer()));
  Board newBoard;
  List<Move> potentialMoves=allMoves(board);
  List<Move> bestMoves=new LinkedList<Move>();
  Collections.sort(potentialMoves,new MinimaxComparator(board.getSpace(board.players.other(this))));
  int bestCase=Integer.MIN_VALUE;
  int evaluation;
  for (  Move move : potentialMoves) {
    try {
      newBoard=board.clone();
      newBoard.makeMove(move);
      evaluation=-negamax(newBoard,Integer.MIN_VALUE,Integer.MAX_VALUE,depth);
      if (evaluation > bestCase) {
        bestMoves.clear();
        bestMoves.add(move);
        bestCase=evaluation;
      }
 else       if (evaluation == bestCase) {
        bestMoves.add(move);
      }
    }
 catch (    Exception e) {
    }
  }
  int pick=(int)Math.floor(bestMoves.size() * Math.random());
  System.out.println(i);
  i=0;
  return bestMoves.get(pick);
}","/** 
 * Looks at the board and figures out what move to make. Calls negamax() for each possible move and picks the best one. If there are multiple equally best, it picks one of them at random.
 * @see quoridor.Player#getMove(quoridor.Board)
 */
public Move getMove(Board board){
  assert(this.equals(board.currentPlayer()));
  Board newBoard;
  List<Move> potentialMoves=allMoves(board);
  List<Move> bestMoves=new LinkedList<Move>();
  Collections.sort(potentialMoves,new MinimaxComparator(board.getSpace(board.players.other(this))));
  int bestCase=Integer.MIN_VALUE;
  int evaluation;
  for (  Move move : potentialMoves) {
    try {
      newBoard=board.clone();
      newBoard.makeMove(move);
      evaluation=-negamax(newBoard,Integer.MIN_VALUE + 1,Integer.MAX_VALUE,depth);
      if (evaluation > bestCase) {
        bestMoves.clear();
        bestMoves.add(move);
        bestCase=evaluation;
      }
 else       if (evaluation == bestCase) {
        bestMoves.add(move);
      }
    }
 catch (    Exception e) {
    }
  }
  int pick=(int)Math.floor(bestMoves.size() * Math.random());
  i=0;
  return bestMoves.get(pick);
}",0.9872974156811212
154312,"/** 
 * Does the actual moving back to the previous state. 
 */
public void undoLastMove(){
  Move move=moveList.get(moveListIndex);
  if (move instanceof MovementMove) {
    setSpace(move.owner,((MovementMove)move).from());
  }
 else   if (move instanceof WallMove) {
    this.removeWall(((WallMove)move).wall());
  }
  currentPlayer=players.other(currentPlayer);
  moveListIndex--;
}","/** 
 * Does the actual moving back to the previous state. 
 */
public void undoLastMove(){
  Move move=moveList.get(moveListIndex);
  currentPlayer=players.other(currentPlayer);
  if (move instanceof MovementMove) {
    setSpace(move.owner,((MovementMove)move).from());
  }
 else   if (move instanceof WallMove) {
    this.removeWall(((WallMove)move).wall());
  }
  moveListIndex--;
}",0.8805194805194805
154313,"@Override protected int wallsLeftWeight(){
  return 2;
}","@Override protected int wallsLeftWeight(){
  return 3;
}",0.9821428571428572
154314,"private int negamax(Board board,int alpha,int beta,int depth){
  i++;
  if (board.currentPlayer().equals(board.winner()))   return Integer.MAX_VALUE;
 else   if (board.players.other(board.currentPlayer()).equals(board.winner()))   return Integer.MIN_VALUE;
 else   if (depth == 0)   return board.currentPlayer().minMax() * evaluate(board);
  Board newBoard;
  List<Move> potentialMoves=board.currentPlayer().allMoves(board);
  int bestCase=Integer.MIN_VALUE;
  int evaluation;
  for (  Move move : potentialMoves) {
    try {
      newBoard=board.clone();
      newBoard.makeMove(move);
      evaluation=-negamax(newBoard,-beta,-alpha,depth - 1);
      if (evaluation > bestCase)       bestCase=evaluation;
      if (bestCase > alpha)       alpha=bestCase;
      if (alpha >= beta)       return alpha;
    }
 catch (    Exception e) {
    }
  }
  return bestCase;
}","private int negamax(Board board,int alpha,int beta,int depth){
  i++;
  if (board.currentPlayer().equals(board.winner()))   return Integer.MAX_VALUE;
 else   if (board.players.other(board.currentPlayer()).equals(board.winner()))   return Integer.MIN_VALUE + 1;
 else   if (depth == 0)   return board.currentPlayer().minMax() * evaluate(board);
  Board newBoard;
  List<Move> potentialMoves=board.currentPlayer().allMoves(board);
  int bestCase=Integer.MIN_VALUE;
  int evaluation;
  for (  Move move : potentialMoves) {
    try {
      newBoard=board.clone();
      newBoard.makeMove(move);
      evaluation=-negamax(newBoard,-beta,-alpha,depth - 1);
      if (evaluation > bestCase)       bestCase=evaluation;
      if (bestCase > alpha)       alpha=bestCase;
      if (alpha >= beta)       return alpha;
    }
 catch (    Exception e) {
    }
  }
  return bestCase;
}",0.9976931949250288
154315,"/** 
 * Checks that a jump move is valid. If the move is a regular (adjacent) move, returns true.
 * @param move
 * @return True if valid jump move
 */
private boolean jumpValid(MovementMove move){
  if (!move.isJump())   return true;
  Space middleSpace;
  Space behindSpace;
  if (move.from().row() == move.to().row()) {
    assert(Math.abs(move.from().col() - move.to().col()) == 2);
    middleSpace=new Space(Math.min(move.from().col(),move.to().col()) + 1,move.from().row());
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (move.from().col() == move.to().col()) {
    assert(Math.abs(move.from().row() - move.to().row()) == 2);
    middleSpace=new Space(move.from().col(),Math.min(move.from().row(),move.to().row()) + 1);
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (Math.abs(move.from().row() - move.to().row()) + Math.abs(move.from().col() - move.to().col()) == 2) {
    if (getSpace(players.other(move.owner)).row() == move.from().row() && Math.abs(getSpace(players.other(move.owner)).col() - move.from().col()) == 1 || getSpace(players.other(move.owner)).col() == move.from().col() && Math.abs(getSpace(players.other(move.owner)).row() - move.from().row()) == 1) {
      middleSpace=getSpace(players.other(move.owner));
      if (wallIsHere(middleSpace,move.to()))       return false;
      try {
        behindSpace=new Space(2 * middleSpace.col() - move.from().col(),2 * middleSpace.row() - move.from().row());
      }
 catch (      RuntimeException e) {
        return true;
      }
      return wallIsHere(middleSpace,behindSpace);
    }
 else     return false;
  }
  return false;
}","/** 
 * Checks that a jump move is valid. If the move is a regular (adjacent) move, returns true.
 * @param move
 * @return True if valid jump move
 */
private boolean jumpValid(MovementMove move){
  if (!move.isJump())   return true;
  Space middleSpace;
  Space behindSpace;
  if (move.from().row() == move.to().row()) {
    assert(Math.abs(move.from().col() - move.to().col()) == 2);
    middleSpace=new Space(Math.min(move.from().col(),move.to().col()) + 1,move.from().row());
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (move.from().col() == move.to().col()) {
    assert(Math.abs(move.from().row() - move.to().row()) == 2);
    middleSpace=new Space(move.from().col(),Math.min(move.from().row(),move.to().row()) + 1);
    if (getSpace(players.other(move.owner)).equals(middleSpace) && !wallIsHere(move.from(),middleSpace) && !wallIsHere(move.to(),middleSpace)) {
      return true;
    }
    return false;
  }
 else   if (Math.abs(move.from().row() - move.to().row()) + Math.abs(move.from().col() - move.to().col()) == 2) {
    if (getSpace(players.other(move.owner)).row() == move.from().row() && getSpace(players.other(move.owner)).col() == move.to().col() || getSpace(players.other(move.owner)).col() == move.from().col() && getSpace(players.other(move.owner)).row() == move.to().row()) {
      middleSpace=getSpace(players.other(move.owner));
      if (wallIsHere(middleSpace,move.to()))       return false;
      try {
        behindSpace=new Space(2 * middleSpace.col() - move.from().col(),2 * middleSpace.row() - move.from().row());
      }
 catch (      RuntimeException e) {
        return true;
      }
      return wallIsHere(middleSpace,behindSpace);
    }
 else     return false;
  }
  return false;
}",0.9725593667546174
154316,"/** 
 * Checks whether a placed wall will cut off the path.
 * @param wall
 * @return
 */
private boolean cutsOffPath(WallMove move){
  boolean blocks=false;
  int i;
  addWall(move.wall());
  ArrayList<Space> exits=new ArrayList<Space>();
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player2Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(getSpace(players._1())) == -1)   blocks=true;
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player1Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(getSpace(players._2())) == -1)   blocks=true;
  removeWall(move.wall());
  return blocks;
}","/** 
 * Checks whether a placed wall will cut off the path.
 * @param wall
 * @return
 */
private boolean cutsOffPath(WallMove move){
  boolean blocks=false;
  int i;
  addWall(move.wall());
  ArrayList<Space> exits=new ArrayList<Space>();
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player2Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(getSpace(players._1())) == -1)   blocks=true;
  exits.clear();
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player1Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(getSpace(players._2())) == -1)   blocks=true;
  removeWall(move.wall());
  return blocks;
}",0.9866247049567268
154317,"/** 
 * Checks whether a placed wall will cut off the path.
 * @param wall
 * @return TODO: Implementation
 */
private boolean cutsOffPath(WallMove move){
  boolean blocks=false;
  int i;
  addWall(move.wall());
  ArrayList<Space> exits=new ArrayList<Space>();
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player2Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(players._1().getSpace()) == -1)   blocks=true;
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player1Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(players._2().getSpace()) == -1)   blocks=true;
  return blocks;
}","/** 
 * Checks whether a placed wall will cut off the path.
 * @param wall
 * @return TODO: Implementation
 */
private boolean cutsOffPath(WallMove move){
  boolean blocks=false;
  int i;
  addWall(move.wall());
  ArrayList<Space> exits=new ArrayList<Space>();
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player2Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(players._1().getSpace()) == -1)   blocks=true;
  for (i=1; i <= 9; i++)   exits.add(new Space(i,player1Start.row()));
  graph.fillNodeDistances(exits);
  if (graph.getDist(players._2().getSpace()) == -1)   blocks=true;
  removeWall(move.wall());
  return blocks;
}",0.9787902592301648
154318,"/** 
 * Check that a move is valid with respect to the current board state.
 * @param move
 * @return True if the move is valid.TODO: Make it throw exceptions for invalid moves.
 */
private boolean moveValid(Move move){
  if (move instanceof MovementMove) {
    MovementMove mMove=(MovementMove)move;
    if (!wallIsHere(mMove.from(),mMove.to()) && mMove.from().equals(currentPlayer.getSpace()) && !isOccupied(mMove.to())&& (adjacentSpaces(mMove.from(),mMove.to()) || jumpValid(mMove))) {
      return true;
    }
    return false;
  }
  if (move instanceof WallMove) {
    if (!currentPlayer.hasWallsLeft()) {
      return false;
    }
    WallMove wMove=(WallMove)move;
    Wall proposedWall=wMove.wall();
    if (proposedWall.isHorizontal() && !wallIsHere(proposedWall.getSpace(),proposedWall.getSpace().getDown())) {
      return true;
    }
 else     if (!proposedWall.isHorizontal() && !wallIsHere(proposedWall.getSpace(),proposedWall.getSpace().getRight())) {
      if (cutsOffPath((WallMove)move))       return false;
      return true;
    }
  }
  return false;
}","/** 
 * Check that a move is valid with respect to the current board state.
 * @param move
 * @return True if the move is valid.TODO: Make it throw exceptions for invalid moves.
 */
private boolean moveValid(Move move){
  if (move instanceof MovementMove) {
    MovementMove mMove=(MovementMove)move;
    if (!wallIsHere(mMove.from(),mMove.to()) && mMove.from().equals(currentPlayer.getSpace()) && !isOccupied(mMove.to())&& (adjacentSpaces(mMove.from(),mMove.to()) || jumpValid(mMove))) {
      return true;
    }
    return false;
  }
  if (move instanceof WallMove) {
    if (!currentPlayer.hasWallsLeft()) {
      return false;
    }
    WallMove wMove=(WallMove)move;
    Wall proposedWall=wMove.wall();
    if (wallList.contains(new Wall(wMove.wall().getSpace(),!wMove.wall().isVertical())))     return false;
    if (proposedWall.isHorizontal() && !wallIsHere(proposedWall.getSpace(),proposedWall.getSpace().getDown()) && !wallIsHere(proposedWall.getSpace().getRight(),proposedWall.getSpace().getDown().getRight())) {
      if (cutsOffPath((WallMove)move))       return false;
      return true;
    }
 else     if (!proposedWall.isHorizontal() && !wallIsHere(proposedWall.getSpace(),proposedWall.getSpace().getRight()) && !wallIsHere(proposedWall.getSpace().getDown(),proposedWall.getSpace().getRight().getDown())) {
      if (cutsOffPath((WallMove)move))       return false;
      return true;
    }
  }
  return false;
}",0.8004798080767693
154319,"public int getDist(Space space){
  return node[space.row()][space.col()].distanceToExit;
}","public int getDist(Space space){
  return node[space.row() - 1][space.col() - 1].distanceToExit;
}",0.9574468085106383
154320,"public boolean makeMoveFromInput(String moveInput){
  Move move;
  if (moveInput.length() == MOVEMENT_MOVE) {
    try {
      move=new MovementMove(this.currentPlayer.getSpace(),new Space(moveInput));
      move.owner=currentPlayer;
    }
 catch (    Exception e) {
      return false;
    }
  }
 else   if (moveInput.length() == WALL_MOVE && moveInput.substring(2).toLowerCase() == ""String_Node_Str"" && moveInput.substring(2).toLowerCase() == ""String_Node_Str"") {
    try {
      move=new WallMove(new Wall(moveInput));
      move.owner=currentPlayer;
    }
 catch (    Exception e) {
      return false;
    }
  }
 else {
    return false;
  }
  return this.makeMove(move);
}","public boolean makeMoveFromInput(String moveInput){
  Move move;
  if (moveInput.length() == MOVEMENT_MOVE) {
    try {
      move=new MovementMove(this.currentPlayer.getSpace(),new Space(moveInput));
      move.owner=currentPlayer;
    }
 catch (    Exception e) {
      return false;
    }
  }
 else   if (moveInput.length() == WALL_MOVE && (moveInput.substring(2).equalsIgnoreCase(""String_Node_Str"") || moveInput.substring(2).equalsIgnoreCase(""String_Node_Str""))) {
    try {
      move=new WallMove(new Wall(moveInput));
      move.owner=currentPlayer;
    }
 catch (    Exception e) {
      return false;
    }
  }
 else {
    return false;
  }
  return this.makeMove(move);
}",0.9572901325478644
154321,"/** 
 * Undo the last move.	 
 */
public void undo(){
  if (moveListIndex < 0)   return;
  Move move=moveList.get(moveListIndex);
  if (move instanceof MovementMove) {
    move.owner.setSpace(((MovementMove)move).from());
  }
  if (move instanceof WallMove) {
    this.removeWall(((WallMove)move).wall());
  }
  moveListIndex--;
}","/** 
 * Undo the last move.	 
 */
public void undo(){
  if (moveListIndex < 0)   return;
  Move move=moveList.get(moveListIndex);
  if (move instanceof MovementMove) {
    move.owner.setSpace(((MovementMove)move).from());
  }
  if (move instanceof WallMove) {
    this.removeWall(((WallMove)move).wall());
  }
  currentPlayer=players.other(currentPlayer);
  moveListIndex--;
}",0.9348441926345608
154322,"/** 
 * Updates the board state with the move. Assumes that the move is valid. Used for new (validated) moves or redo.
 * @param move to be played
 */
private void applyMove(Move move){
  if (move instanceof MovementMove) {
    move.owner.setSpace(((MovementMove)move).to());
  }
  if (move instanceof WallMove) {
    this.addWall(((WallMove)move).wall());
  }
}","/** 
 * Updates the board state with the move. Assumes that the move is valid. Used for new (validated) moves or redo.
 * @param move to be played
 */
private void applyMove(Move move){
  if (move instanceof MovementMove) {
    move.owner.setSpace(((MovementMove)move).to());
  }
  if (move instanceof WallMove) {
    this.addWall(((WallMove)move).wall());
  }
  currentPlayer=players.other(currentPlayer);
}",0.9402597402597402
154323,"/** 
 * Checks if a wall exists between two given spaces.
 * @param space a, b the spaces that represent the junction being queried
 * @return true if a wall exists between these two walls.
 */
public boolean wallIsHere(Space a,Space b){
  if (!(adjacentSpaces(a,b))) {
    return false;
  }
  if ((b.col() < a.col()) || (b.row() < a.row())) {
    Space temp=a;
    a=b;
    b=temp;
  }
  LinkedList<Wall> toConsider=new LinkedList<Wall>();
  if (b.equals(a.getRight())) {
    toConsider.add(new Wall(a,true));
    if (a.getUp() != null) {
      toConsider.add(new Wall(a.getUp(),true));
    }
  }
  if (b.equals(a.getDown())) {
    toConsider.add(new Wall(a,false));
    if (a.getLeft() != null) {
      toConsider.add(new Wall(a.getLeft(),false));
    }
  }
  while (toConsider != null) {
    if (wallList.contains(toConsider.remove())) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if a wall exists between two given spaces.
 * @param space a, b the spaces that represent the junction being queried
 * @return true if a wall exists between these two walls.
 */
public boolean wallIsHere(Space a,Space b){
  if (!(adjacentSpaces(a,b))) {
    return false;
  }
  if ((b.col() < a.col()) || (b.row() < a.row())) {
    Space temp=a;
    a=b;
    b=temp;
  }
  LinkedList<Wall> toConsider=new LinkedList<Wall>();
  if (b.equals(a.getRight())) {
    if (a.getDown() != null)     toConsider.add(new Wall(a,true));
    if (a.getUp() != null)     toConsider.add(new Wall(a.getUp(),true));
  }
  if (b.equals(a.getDown())) {
    if (a.getRight() != null)     toConsider.add(new Wall(a,false));
    if (a.getLeft() != null)     toConsider.add(new Wall(a.getLeft(),false));
  }
  while (toConsider.size() > 0) {
    if (wallList.contains(toConsider.remove())) {
      return true;
    }
  }
  return false;
}",0.7169603524229075
154324,"/** 
 * this function controls the flow of game play.
 */
public boolean playGame(){
  while (!gameOver) {
    System.out.println(board);
    if (playNextTurn() == INVALID_INPUT) {
      return false;
    }
  }
  return gameOver;
}","/** 
 * This function controls the flow of game play.
 */
public boolean playGame(){
  while (!gameOver) {
    System.out.println(board);
    if (playNextTurn() == INVALID_INPUT) {
      if (validatorGame)       return false;
 else       System.out.println(""String_Node_Str"");
    }
  }
  return gameOver;
}",0.8104089219330854
154325,"/** 
 * Constructor for a default player
 * @param playerNumber can be of value 1 or 2 - for default filling of fields: name, token. 
 */
public Player(int playerNumber){
  if (playerNumber == 1) {
    name=""String_Node_Str"";
    this.space=new Space(""String_Node_Str"");
  }
 else {
    name=""String_Node_Str"";
    this.space=new Space(""String_Node_Str"");
  }
  setToken(name);
}","/** 
 * Constructor for a default player
 * @param playerNumber can be of value 1 or 2 - for default filling of fields: name, token. 
 */
public Player(int playerNumber){
  if (playerNumber == 1) {
    name=""String_Node_Str"";
    token=""String_Node_Str"";
    this.space=new Space(""String_Node_Str"");
  }
 else   if (playerNumber == 2) {
    token=""String_Node_Str"";
    name=""String_Node_Str"";
    this.space=new Space(""String_Node_Str"");
  }
 else   throw new RuntimeException(""String_Node_Str"");
}",0.8314350797266514
154326,"protected void setToken(String t){
  this.token=t;
}","protected void setToken(String t){
  if (t.length() == 0)   return;
 else   if (t.length() == 1)   token=""String_Node_Str"" + t + ""String_Node_Str"";
 else   if (t.length() == 2)   token=t + ""String_Node_Str"";
 else   if (t.length() == 3)   token=t;
 else   token=t.substring(0,3);
}",0.2402402402402402
154327,"/** 
 * obtain the space below
 * @return space below this object
 */
public Space getDown(){
  if (row == 1) {
    return null;
  }
  return new Space(col,row - 1);
}","/** 
 * obtain the space below
 * @return space below this object
 */
public Space getDown(){
  if (row == 9) {
    return null;
  }
  return new Space(col,row + 1);
}",0.9880239520958084
154328,"/** 
 * obtain the space above
 * @return space above this object
 */
public Space getUp(){
  if (row == 9) {
    return null;
  }
  return new Space(col,row + 1);
}","/** 
 * obtain the space above
 * @return space above this object
 */
public Space getUp(){
  if (row == 1) {
    return null;
  }
  return new Space(col,row - 1);
}",0.987878787878788
154329,"/** 
 */
public Wall(String command){
  assert(command.length() == VALID_INPUT);
  String wallType=command.toLowerCase().substring(WALL_TYPE);
  if (wallType.equals(""String_Node_Str"")) {
    this.vertical=false;
  }
 else   if (wallType.equals(""String_Node_Str"")) {
    this.vertical=true;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  Space space=new Space(command.substring(FIRST_CHAR,SECOND_CHAR));
  if (!validWall(space)) {
    throw new RuntimeException(""String_Node_Str"");
  }
 else {
    this.space=space;
  }
}","/** 
 */
public Wall(String command){
  assert(command.length() == VALID_INPUT);
  String wallType=command.toLowerCase().substring(WALL_TYPE);
  if (wallType.equalsIgnoreCase(""String_Node_Str"")) {
    this.vertical=false;
  }
 else   if (wallType.equalsIgnoreCase(""String_Node_Str"")) {
    this.vertical=true;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  Space space=new Space(command.substring(FIRST_CHAR,THIRD_CHAR));
  if (!validWall(space)) {
    throw new RuntimeException(""String_Node_Str"");
  }
 else {
    this.space=space;
  }
}",0.973708068902992
154330,"public boolean checkWin(){
  Player player1=players._1();
  Player player2=players._2();
  if (player1.getSpace().equals(player2Start)) {
    winner=player1;
    return true;
  }
 else   if (player2.getSpace().equals(player1Start)) {
    winner=player2;
    return true;
  }
  return false;
}","public boolean checkWin(){
  Player player1=players._1();
  Player player2=players._2();
  if (player1.getSpace().row() == player2Start.row()) {
    winner=player1;
    return true;
  }
 else   if (player2.getSpace().row() == player1Start.row()) {
    winner=player2;
    return true;
  }
  return false;
}",0.5585284280936454
154331,"/** 
 * Check that a move is valid with respect to the current board state.
 * @param move
 * @return True if the move is valid.TODO: Make it throw exceptions for invalid moves.
 */
private boolean moveValid(Move move){
  if (move instanceof MovementMove) {
    MovementMove mMove=(MovementMove)move;
    if (!mMove.from().equals(currentPlayer.getSpace()))     return false;
    if (mMove.to().equals(players.other(currentPlayer).getSpace()))     return false;
    if (mMove.isJump()) {
    }
 else {
      if (wallIsHere(mMove.from(),mMove.to()))       return false;
      return true;
    }
  }
  if (move instanceof WallMove) {
    WallMove wMove=(WallMove)move;
    if (existingWall(wMove.wall()))     return false;
    if (wallOverLap(wMove.wall()))     return false;
    if (cutsOffPath(wMove.wall()))     return false;
    if (wallList.size() >= 20)     return false;
    return true;
  }
  return true;
}","/** 
 * Check that a move is valid with respect to the current board state.
 * @param move
 * @return True if the move is valid.TODO: Make it throw exceptions for invalid moves.
 */
private boolean moveValid(Move move){
  if (move instanceof MovementMove) {
    MovementMove mMove=(MovementMove)move;
    if (!mMove.from().equals(currentPlayer.getSpace()))     return false;
    if (isOccupied(mMove.to()))     return false;
    if (mMove.isJump()) {
    }
 else {
      if (wallIsHere(mMove.from(),mMove.to()))       return false;
      return true;
    }
  }
  if (move instanceof WallMove) {
    WallMove wMove=(WallMove)move;
    if (existingWall(wMove.wall()))     return false;
    if (wallOverLap(wMove.wall()))     return false;
    if (cutsOffPath(wMove.wall()))     return false;
    if (wallList.size() >= 20)     return false;
    return true;
  }
  return true;
}",0.959731543624161
154332,"/** 
 * Checks that the move is a potentially valid quoridor move. This does NOT guarantee that the move is valid in the current game state. Also checks whether the move is a jump move.
 * @param from The Space moved from.
 * @param to The Space moved to.
 * @return True if move is valid.
 */
private boolean validate(Space from,Space to){
  if (!from.equals(to))   return false;
  if (Math.abs(from.row() - to.row()) <= 1 && Math.abs(from.col() - to.col()) <= 1) {
    if (from.row() == to.row() || from.col() == to.col())     isJump=false;
 else     isJump=true;
    return true;
  }
  if (from.row() == to.row() && Math.abs(from.col() - to.col()) == 2 || from.col() == to.col() && Math.abs(from.row() - to.row()) == 2) {
    isJump=true;
    return true;
  }
  return false;
}","/** 
 * Checks that the move is a potentially valid quoridor move. This does NOT guarantee that the move is valid in the current game state. Also checks whether the move is a jump move.
 * @param from The Space moved from.
 * @param to The Space moved to.
 * @return True if move is valid.
 */
private boolean validate(Space from,Space to){
  if (from.equals(to))   return false;
  if (Math.abs(from.row() - to.row()) <= 1 && Math.abs(from.col() - to.col()) <= 1) {
    if (from.row() == to.row() || from.col() == to.col())     isJump=false;
 else     isJump=true;
    return true;
  }
  if (from.row() == to.row() && Math.abs(from.col() - to.col()) == 2 || from.col() == to.col() && Math.abs(from.row() - to.row()) == 2) {
    isJump=true;
    return true;
  }
  return false;
}",0.9993585631815266
154333,"/** 
 * Adds an individual wall to the boards list, by constructing a new wall and appending it to the list. 
 * @param x the walls x coordinate as an int.
 * @param y the walls y coordinate as an int.
 * @param vertical if the wall is vertical or not, as a boolean. 
 */
public void addWall(int x,int y,Boolean vertical){
  wallList.add(new Wall(x,y,vertical));
}","/** 
 * Adds an individual wall to the boards list, by constructing a new wall and appending it to the list. 
 * @param x the walls x coordinate as an int.
 * @param y the walls y coordinate as an int.
 * @param vertical if the wall is vertical or not, as a boolean. 
 */
public void addWall(int x,int y,Boolean vertical){
  wallList.add(new Wall(new Space(x,y),vertical));
}",0.9851150202976996
154334,"/** 
 * A board takes Two players as a pair as defined by the Two Class.
 * @param players The Two players for the this board instance.
 */
public Board(Two<Player> players){
  this.players=players;
  wallList=new LinkedList<Wall>();
}","/** 
 * A board takes Two players as a pair as defined by the Two Class.
 * @param players The Two players for the this board instance.
 */
public Board(String player1Name,String player2Name){
  Player player1=new Player(player1Name,player1Start,""String_Node_Str"");
  Player player2=new Player(player2Name,player2Start,""String_Node_Str"");
  this.players=new Two<Player>(player1,player2);
  wallList=new LinkedList<Wall>();
}",0.6160849772382397
154335,"public static String printBoard(Board board){
  StringBuilder boardString=new StringBuilder(""String_Node_Str"");
  Space thisSpace;
  int row, col, rowNum=1;
  String hDivider=getHDivider();
  String corner=getCorner();
  int[][] wallArray=new int[9][9];
  for (row=0; row < 9; row++) {
    for (col=0; col < 9; col++) {
      wallArray[row][col]=0;
    }
  }
  for (  Wall wall : board.getWallList()) {
    row=wall.getSpace().getY();
    col=wall.getSpace().getX();
    if (wall.isVertical())     wallArray[row][col]=1;
 else     wallArray[row][col]=2;
  }
  for (row=0; row < 9; row++) {
    boardString.append(rowNum + ""String_Node_Str"");
    rowNum++;
    for (col=0; col < 9; col++) {
      thisSpace=new Space(col + 1,row + 1);
      if (board.getPlayers()._1().getSpace().equals(thisSpace))       boardString.append(board.getPlayers()._1().getToken());
 else       if (board.getPlayers()._2().getSpace().equals(thisSpace))       boardString.append(board.getPlayers()._2().getToken());
 else       boardString.append(""String_Node_Str"");
      if (col != 8) {
        if (wallArray[row][col] == 1 || row != 0 && wallArray[row - 1][col] == 1)         boardString.append(V_WALL);
 else         boardString.append(V_DIVIDER);
      }
    }
    boardString.append(""String_Node_Str"");
    if (row != 8) {
      boardString.append(""String_Node_Str"");
      for (col=0; col < 9; col++) {
        if (wallArray[row][col] == 2 || col != 0 && wallArray[row][col - 1] == 2)         boardString.append(H_WALL + H_WALL + H_WALL);
 else         boardString.append(hDivider);
        if (col != 8) {
          if (wallArray[row][col] == 1)           boardString.append(V_WALL);
 else           if (wallArray[row][col] == 2)           boardString.append(H_WALL);
 else           boardString.append(corner);
        }
      }
      boardString.append(""String_Node_Str"");
    }
  }
  boardString.append(""String_Node_Str"");
  return boardString.toString();
}","public static String printBoard(Board board){
  StringBuilder boardString=new StringBuilder(""String_Node_Str"");
  Space thisSpace;
  int row, col, rowNum=1;
  String hDivider=getHDivider();
  String corner=getCorner();
  int[][] wallArray=new int[9][9];
  for (row=0; row < 9; row++) {
    for (col=0; col < 9; col++) {
      wallArray[row][col]=0;
    }
  }
  for (  Wall wall : board.getWallList()) {
    row=wall.getSpace().getNumeric();
    col=wall.getSpace().alphaToInt();
    if (wall.isVertical())     wallArray[row][col]=1;
 else     wallArray[row][col]=2;
  }
  for (row=0; row < 9; row++) {
    boardString.append(rowNum + ""String_Node_Str"");
    rowNum++;
    for (col=0; col < 9; col++) {
      thisSpace=new Space(col + 1,row + 1);
      if (board.getPlayers()._1().getSpace().equals(thisSpace))       boardString.append(board.getPlayers()._1().getToken());
 else       if (board.getPlayers()._2().getSpace().equals(thisSpace))       boardString.append(board.getPlayers()._2().getToken());
 else       boardString.append(""String_Node_Str"");
      if (col != 8) {
        if (wallArray[row][col] == 1 || row != 0 && wallArray[row - 1][col] == 1)         boardString.append(V_WALL);
 else         boardString.append(V_DIVIDER);
      }
    }
    boardString.append(""String_Node_Str"");
    if (row != 8) {
      boardString.append(""String_Node_Str"");
      for (col=0; col < 9; col++) {
        if (wallArray[row][col] == 2 || col != 0 && wallArray[row][col - 1] == 2)         boardString.append(H_WALL + H_WALL + H_WALL);
 else         boardString.append(hDivider);
        if (col != 8) {
          if (wallArray[row][col] == 1)           boardString.append(V_WALL);
 else           if (wallArray[row][col] == 2)           boardString.append(H_WALL);
 else           boardString.append(corner);
        }
      }
      boardString.append(""String_Node_Str"");
    }
  }
  boardString.append(""String_Node_Str"");
  return boardString.toString();
}",0.98
154336,"void setupGame(){
}","void setupGame(){
  System.out.println(""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  String player1Name=getFromUser();
  System.out.print(""String_Node_Str"");
  String player2Name=getFromUser();
  board=new Board(player1Name,player2Name);
  currentPlayer=board.getPlayers()._1();
}",0.1210191082802547
154337,"@Override public void update(Observable o,Object arg){
  LogEvent le=(LogEvent)arg;
  Tools.print(le.toString() + ""String_Node_Str"" + le.getDetails());
}","@Override public void update(Observable o,Object arg){
}",0.5358851674641149
154338,"/** 
 * The Constructor
 */
public EduTLS(){
  super(""String_Node_Str"");
  SYSTEM_START=System.currentTimeMillis();
  setSize(800,600);
  setResizable(false);
  setVisible(true);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  getContentPane().setLayout(null);
  Log.get().addObserver(this);
  initializeComponents();
}","/** 
 * The Constructor
 */
public EduTLS(){
  super(""String_Node_Str"");
  SYSTEM_START=System.currentTimeMillis();
  setSize(800,600);
  setResizable(false);
  setVisible(true);
  setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
  addWindowListener(new ClosingAdapter());
  getContentPane().setLayout(null);
  Log.get().addObserver(this);
  initializeComponents();
}",0.6366279069767442
154339,"public void close(){
  listen=false;
  try {
    Tools.printerr(""String_Node_Str"");
    if (server != null && !server.isClosed())     server.close();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
  }
}","public static void close(){
  listen=false;
  try {
    Tools.printerr(""String_Node_Str"");
    if (server != null && !server.isClosed())     server.close();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
  }
}",0.9849462365591398
154340,"public ServerCertificate(byte[] certificate){
  String cert=new String(certificate,TLSEngine.ENCODING);
  int serialNumberStart=cert.indexOf(SERIAL_NUMBER_INFO) + SERIAL_NUMBER_INFO.length();
  int serialNumberEnd=cert.indexOf(NL,serialNumberStart);
  try {
    serialNumber=Integer.parseInt(cert.substring(serialNumberStart,serialNumberEnd));
  }
 catch (  NumberFormatException nfe) {
    serialNumber=-1;
  }
  int subjectStart=cert.indexOf(SUBJECT_INFO) + SUBJECT_INFO.length();
  int subjectEnd=cert.indexOf(NL,subjectStart);
  subject=cert.substring(subjectStart,subjectEnd);
  int notValidBeforeStart=cert.indexOf(VALID_NOT_BEFORE_INFO) + VALID_NOT_BEFORE_INFO.length();
  int notValidBeforeEnd=cert.indexOf(NL,notValidBeforeStart);
  int notValidAfterStart=cert.indexOf(VALID_NOT_AFTER_INFO) + VALID_NOT_AFTER_INFO.length();
  int notValidAfterEnd=cert.indexOf(NL,notValidAfterStart);
  calendar=new GregorianCalendar();
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"",Locale.US);
  try {
    notValidBefore=sdf.parse(cert.substring(notValidBeforeStart,notValidBeforeEnd));
    notValidAfter=sdf.parse(cert.substring(notValidAfterStart,notValidAfterEnd));
  }
 catch (  ParseException e) {
    notValidBefore=calendar.getTime();
    notValidAfter=calendar.getTime();
  }
  int keyAlgorithmStart=cert.indexOf(PUBLIC_KEY_ALG_INFO) + PUBLIC_KEY_ALG_INFO.length();
  int keyAlgorithmEnd=cert.indexOf(NL,keyAlgorithmStart);
  String keyInf=cert.substring(keyAlgorithmStart,keyAlgorithmEnd);
  int keyBitLengthStart=cert.indexOf(PUBLIC_KEY_INFO) + PUBLIC_KEY_INFO.length();
  keyBitLengthStart=cert.indexOf(""String_Node_Str"",keyBitLengthStart);
  int publicKeyModulusStart=cert.indexOf(MODULUS_INFO) + MODULUS_INFO.length();
  publicKeyModulusStart=cert.indexOf(NL,publicKeyModulusStart) + 2;
  int publicKeyModulusEnd=cert.indexOf(NL,publicKeyModulusStart);
  String publicModulusKey=cert.substring(publicKeyModulusStart,publicKeyModulusEnd);
  int publicExponentKeyStart=cert.indexOf(EXPONENT_INFO) + EXPONENT_INFO.length();
  int publicExponentKeyEnd=cert.indexOf(NL,publicExponentKeyStart);
  String publicExponentKey=cert.substring(publicExponentKeyStart,publicExponentKeyEnd);
  BigInteger intPublicKeyModulus, intPublicExponentKey;
  try {
    intPublicKeyModulus=new BigInteger(publicModulusKey);
    intPublicExponentKey=new BigInteger(publicExponentKey);
  }
 catch (  Exception e) {
    intPublicKeyModulus=BigInteger.ZERO;
    intPublicExponentKey=BigInteger.ZERO;
  }
  if (keyInf.equals(crypto.keyexchange.DH.ALGORITHM_NAME))   key=new crypto.keyexchange.DH(intPublicKeyModulus,intPublicExponentKey);
 else   if (keyInf.equals(crypto.keyexchange.RSA.ALGORITHM_NAME))   key=new crypto.keyexchange.RSA(intPublicKeyModulus,intPublicExponentKey);
 else   key=new crypto.keyexchange.None();
}","public ServerCertificate(byte[] certificate){
  String cert=new String(certificate,TLSEngine.ENCODING);
  int serialNumberStart=cert.indexOf(SERIAL_NUMBER_INFO) + SERIAL_NUMBER_INFO.length();
  int serialNumberEnd=cert.indexOf(NL,serialNumberStart);
  try {
    serialNumber=Integer.parseInt(cert.substring(serialNumberStart,serialNumberEnd));
  }
 catch (  Exception nfe) {
    Tools.print(""String_Node_Str"" + serialNumberStart + ""String_Node_Str""+ serialNumberEnd);
    serialNumber=-1;
  }
  int subjectStart=cert.indexOf(SUBJECT_INFO) + SUBJECT_INFO.length();
  int subjectEnd=cert.indexOf(NL,subjectStart);
  subject=cert.substring(subjectStart,subjectEnd);
  int notValidBeforeStart=cert.indexOf(VALID_NOT_BEFORE_INFO) + VALID_NOT_BEFORE_INFO.length();
  int notValidBeforeEnd=cert.indexOf(NL,notValidBeforeStart);
  int notValidAfterStart=cert.indexOf(VALID_NOT_AFTER_INFO) + VALID_NOT_AFTER_INFO.length();
  int notValidAfterEnd=cert.indexOf(NL,notValidAfterStart);
  calendar=new GregorianCalendar();
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"",Locale.US);
  try {
    notValidBefore=sdf.parse(cert.substring(notValidBeforeStart,notValidBeforeEnd));
    notValidAfter=sdf.parse(cert.substring(notValidAfterStart,notValidAfterEnd));
  }
 catch (  ParseException e) {
    notValidBefore=calendar.getTime();
    notValidAfter=calendar.getTime();
  }
  int keyAlgorithmStart=cert.indexOf(PUBLIC_KEY_ALG_INFO) + PUBLIC_KEY_ALG_INFO.length();
  int keyAlgorithmEnd=cert.indexOf(NL,keyAlgorithmStart);
  String keyInf=cert.substring(keyAlgorithmStart,keyAlgorithmEnd);
  int keyBitLengthStart=cert.indexOf(PUBLIC_KEY_INFO) + PUBLIC_KEY_INFO.length();
  keyBitLengthStart=cert.indexOf(""String_Node_Str"",keyBitLengthStart);
  int publicKeyModulusStart=cert.indexOf(MODULUS_INFO) + MODULUS_INFO.length();
  publicKeyModulusStart=cert.indexOf(NL,publicKeyModulusStart) + 2;
  int publicKeyModulusEnd=cert.indexOf(NL,publicKeyModulusStart);
  String publicModulusKey=cert.substring(publicKeyModulusStart,publicKeyModulusEnd);
  int publicExponentKeyStart=cert.indexOf(EXPONENT_INFO) + EXPONENT_INFO.length();
  int publicExponentKeyEnd=cert.indexOf(NL,publicExponentKeyStart);
  String publicExponentKey=cert.substring(publicExponentKeyStart,publicExponentKeyEnd);
  BigInteger intPublicKeyModulus, intPublicExponentKey;
  try {
    intPublicKeyModulus=new BigInteger(publicModulusKey);
    intPublicExponentKey=new BigInteger(publicExponentKey);
  }
 catch (  Exception e) {
    intPublicKeyModulus=BigInteger.ZERO;
    intPublicExponentKey=BigInteger.ZERO;
  }
  if (keyInf.equals(crypto.keyexchange.DH.ALGORITHM_NAME))   key=new crypto.keyexchange.DH(intPublicKeyModulus,intPublicExponentKey);
 else   if (keyInf.equals(crypto.keyexchange.RSA.ALGORITHM_NAME))   key=new crypto.keyexchange.RSA(intPublicKeyModulus,intPublicExponentKey);
 else   key=new crypto.keyexchange.None();
}",0.978477690288714
154341,"/** 
 * The Constructor
 */
public EduTLS(){
  super(""String_Node_Str"");
  SYSTEM_START=System.currentTimeMillis();
  setSize(800,600);
  setResizable(false);
  setVisible(true);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  getContentPane().setLayout(null);
  logevents=new ArrayList<LogEvent>();
  Log.get().addObserver(this);
  initializeComponents();
  initializeActionListeners();
}","/** 
 * The Constructor
 */
public EduTLS(){
  super(""String_Node_Str"");
  SYSTEM_START=System.currentTimeMillis();
  setSize(800,600);
  setResizable(true);
  setVisible(true);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  getContentPane().setLayout(null);
  logevents=new ArrayList<LogEvent>();
  Log.get().addObserver(this);
  initializeComponents();
  initializeActionListeners();
}",0.9910828025477708
154342,"@Override public TLSRecord read(State state){
  TLSRecord record;
  byte[] b=new byte[TLSEngine.RECORD_SIZE];
  byte[] tmp, input;
  int size=0;
  try {
    size=is.read(b);
    if (size > 0) {
      input=new byte[size];
      Tools.byteCopy(b,input);
      int contentSize=(int)(input[2] & 0xFF) * 256 + (int)(input[3] & 0xFF);
      if (contentSize == (size - TLSEngine.HEADER_SIZE)) {
        try {
          record=new TLSRecord(state,input);
          return record;
        }
 catch (        AlertException e) {
          Tools.printerr(e.getAlertDescription());
        }
      }
 else {
        Tools.printerr(""String_Node_Str"" + contentSize + ""String_Node_Str""+ size+ ""String_Node_Str""+ Tools.byteArrayToString(input));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","@Override public TLSRecord read(State state){
  TLSRecord record;
  byte[] b=new byte[TLSEngine.RECORD_SIZE];
  byte[] tmp, input;
  int size=0;
  try {
    if (!isConnected())     reconnect();
    size=is.read(b);
    if (size > 0) {
      input=new byte[size];
      Tools.byteCopy(b,input);
      int contentSize=(int)(input[2] & 0xFF) * 256 + (int)(input[3] & 0xFF);
      if (contentSize == (size - TLSEngine.HEADER_SIZE)) {
        try {
          record=new TLSRecord(state,input);
          return record;
        }
 catch (        AlertException e) {
          Tools.printerr(e.getAlertDescription());
        }
      }
 else {
        Tools.printerr(""String_Node_Str"" + contentSize + ""String_Node_Str""+ size+ ""String_Node_Str""+ Tools.byteArrayToString(input));
      }
    }
  }
 catch (  IOException e) {
    Tools.print(""String_Node_Str"");
    e.printStackTrace();
  }
  return null;
}",0.955154338963308
154343,"@Override public synchronized void write(TLSRecord record){
  try {
    os.write(record.getCiphertext());
    os.flush();
    Thread.sleep(80);
  }
 catch (  IOException e) {
    Tools.printerr(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    Tools.printerr(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
  }
}","@Override public synchronized void write(TLSRecord record){
  try {
    if (!isConnected())     reconnect();
    os.write(record.getCiphertext());
    os.flush();
    Thread.sleep(100);
  }
 catch (  IOException e) {
    Tools.printerr(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    Tools.printerr(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
  }
}",0.945273631840796
154344,"public AlertException(int level,int code,String description){
  super(description);
  this.alertDescription=description;
  this.alertLevel=level;
  this.alertCode=code;
  Log.get().add(new LogEvent(""String_Node_Str"",description));
}","public AlertException(int level,int code,String description){
  super(description);
  this.alertDescription=description;
  this.alertLevel=level;
  this.alertCode=code;
  String caller=Thread.currentThread().getStackTrace()[2].getClassName() + ""String_Node_Str"" + Thread.currentThread().getStackTrace()[2].getLineNumber();
  Log.get().add(new LogEvent(""String_Node_Str"",description + ""String_Node_Str"" + caller+ ""String_Node_Str""));
}",0.6966966966966966
154345,"public String getHandshakeLog(){
  return handshakeLog.toString();
}","public String getHandshakeLog(){
  String tmp=handshakeLog.toString();
  handshakeLog=new StringBuilder();
  return tmp;
}",0.6631578947368421
154346,"/** 
 * Receive an incoming TLSRecord
 * @param record	TLSRecord
 * @returns	Nothing
 */
public void receive(TLSRecord record) throws AlertException {
  Log.get().add(new LogEvent(""String_Node_Str"" + record.getContentTypeName(),Tools.byteArrayToString(record.getPlaintext())));
  if (record.getContentType() == ALERT) {
    Tools.printerr(""String_Node_Str"" + Tools.byteArrayToString(record.getPlaintext()));
  }
 else   if (record.getContentType() == APPLICATION) {
    if (!state.getChangeCipherSpec(state.getEntityType(true)))     throw new AlertException(AlertException.alert_fatal,AlertException.insufficient_security,""String_Node_Str"");
    if (!handshake.isFinished())     throw new AlertException(AlertException.alert_fatal,AlertException.insufficient_security,""String_Node_Str"");
    app.getMessage(record.getPlaintext());
  }
 else   if (record.getContentType() == HANDSHAKE) {
    handshake.receive(record.getPlaintext());
    while (handshake.hasMoreMessages()) {
      send(new TLSRecord(state,handshake.getNextMessage()));
    }
  }
 else {
    throw new AlertException(AlertException.alert_fatal,AlertException.illegal_parameter,""String_Node_Str"");
  }
}","/** 
 * Receive an incoming TLSRecord
 * @param record	TLSRecord
 * @returns	Nothing
 */
public void receive(TLSRecord record) throws AlertException {
  if (record.getContentType() == ALERT) {
    Tools.printerr(""String_Node_Str"" + Tools.byteArrayToString(record.getPlaintext()));
    Log.get().add(new LogEvent(""String_Node_Str"",Tools.byteArrayToString(record.getPlaintext())));
  }
 else   if (record.getContentType() == APPLICATION) {
    Log.get().add(new LogEvent(""String_Node_Str"",Tools.byteArrayToString(record.getPlaintext())));
    if (!state.getChangeCipherSpec(state.getEntityType(true)))     throw new AlertException(AlertException.alert_fatal,AlertException.insufficient_security,""String_Node_Str"");
    if (!handshake.isFinished())     throw new AlertException(AlertException.alert_fatal,AlertException.insufficient_security,""String_Node_Str"");
    app.getMessage(record.getPlaintext());
  }
 else   if (record.getContentType() == HANDSHAKE) {
    handshake.receive(record.getPlaintext());
    while (handshake.hasMoreMessages()) {
      send(new TLSRecord(state,handshake.getNextMessage()));
    }
  }
 else {
    throw new AlertException(AlertException.alert_fatal,AlertException.illegal_parameter,""String_Node_Str"");
  }
}",0.8757789779808891
154347,"private void serverHandshake() throws AlertException {
switch (type) {
case CLIENT_HELLO:
    state.addHandshakeLog(""String_Node_Str"");
  if (lastMessage != HELLO_REQUEST)   throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverRandom=new byte[RANDOM_SIZE];
genRandom(serverRandom);
clientHello=new ClientHello(content);
serverHello=new ServerHello(clientHello,serverRandom);
responseQueue.add(serverHello);
serverCertificate=new ServerCertificate(""String_Node_Str"",serverHello);
responseQueue.add(serverCertificate);
if (serverHello.getChosenCipherSuite().getKeyExchange().requireServerKeyExchange()) {
serverKeyExchange=new ServerKeyExchange(serverHello);
responseQueue.add(serverKeyExchange);
}
serverHelloDone=new ServerHelloDone();
responseQueue.add(serverHelloDone);
break;
case CERTIFICATE_VERIFY:
state.addHandshakeLog(""String_Node_Str"");
throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
case CLIENT_KEY_EXCHANGE:
state.addHandshakeLog(""String_Node_Str"");
if (lastMessage != SERVER_HELLO_DONE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
break;
case CHANGE_CIPHER_SPEC:
state.addHandshakeLog(""String_Node_Str"");
state.setChangeCipherSpecClient();
state.setCipherSuite(serverHello.getChosenCipherSuite());
break;
case FINISHED:
state.addHandshakeLog(""String_Node_Str"");
if (lastMessage != CHANGE_CIPHER_SPEC) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
if (!state.getChangeCipherSpecClient()) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
responseQueue.add(new ChangeCipherSpec());
state.setChangeCipherSpecServer();
serverFinished=new Finished();
responseQueue.add(serverFinished);
break;
default :
throw new AlertException(AlertException.alert_warning,AlertException.handshake_failure,""String_Node_Str"" + type);
}
}","private void serverHandshake() throws AlertException {
switch (type) {
case CLIENT_HELLO:
    state.addHandshakeLog(""String_Node_Str"");
  if (lastMessage != HELLO_REQUEST && lastMessage != FINISHED)   throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverRandom=new byte[RANDOM_SIZE];
genRandom(serverRandom);
clientHello=new ClientHello(content);
serverHello=new ServerHello(clientHello,serverRandom);
responseQueue.add(serverHello);
serverCertificate=new ServerCertificate(""String_Node_Str"",serverHello);
responseQueue.add(serverCertificate);
if (serverHello.getChosenCipherSuite().getKeyExchange().requireServerKeyExchange()) {
serverKeyExchange=new ServerKeyExchange(serverHello);
responseQueue.add(serverKeyExchange);
}
serverHelloDone=new ServerHelloDone();
responseQueue.add(serverHelloDone);
break;
case CERTIFICATE_VERIFY:
state.addHandshakeLog(""String_Node_Str"");
throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
case CLIENT_KEY_EXCHANGE:
state.addHandshakeLog(""String_Node_Str"");
if (lastMessage != SERVER_HELLO_DONE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
break;
case CHANGE_CIPHER_SPEC:
state.addHandshakeLog(""String_Node_Str"");
state.setChangeCipherSpecClient();
state.setCipherSuite(serverHello.getChosenCipherSuite());
break;
case FINISHED:
state.addHandshakeLog(""String_Node_Str"");
if (lastMessage != CHANGE_CIPHER_SPEC) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
if (!state.getChangeCipherSpecClient()) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
responseQueue.add(new ChangeCipherSpec());
state.setChangeCipherSpecServer();
serverFinished=new Finished();
responseQueue.add(serverFinished);
break;
default :
throw new AlertException(AlertException.alert_warning,AlertException.handshake_failure,""String_Node_Str"" + type);
}
}",0.9934892693513384
154348,"private Log(){
}","private Log(){
  events=new ArrayList<LogEvent>();
}",0.4705882352941176
154349,"public static Log get(){
  if (INSTANCE == null)   INSTANCE=new Log();
  return INSTANCE;
}","public LogEvent get(int index){
  if (index < 0 || index > events.size())   return null;
  return events.get(index);
}",0.4210526315789473
154350,"private void initializeComponents(){
  Border txtBorder=BorderFactory.createBevelBorder(BevelBorder.LOWERED);
  JPanel pnlChatArea=new JPanel();
  pnlChatArea.setBounds(202,374,572,177);
  pnlChatArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  getContentPane().add(pnlChatArea);
  pnlChatArea.setLayout(null);
  JPanel pnlChatLogArea=new JPanel();
  pnlChatLogArea.setBounds(10,21,552,114);
  pnlChatArea.add(pnlChatLogArea);
  lstModelChat=new DefaultListModel();
  JList lstChatLog=new JList(lstModelChat);
  lstChatLog.setBounds(0,0,pnlChatLogArea.getWidth(),50);
  lstChatLog.setPrototypeCellValue(""String_Node_Str"");
  lstChatLog.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  lstChatLog.setBackground(getBackground());
  lstChatLog.setBorder(BorderFactory.createEmptyBorder());
  pnlChatLogArea.add(new JScrollPane(lstChatLog));
  txtChatSendMsg=new JTextField();
  txtChatSendMsg.setBorder(txtBorder);
  txtChatSendMsg.setBounds(10,146,453,20);
  pnlChatArea.add(txtChatSendMsg);
  txtChatSendMsg.setColumns(10);
  btnSend=new JButton(""String_Node_Str"");
  btnSend.setBounds(473,146,89,23);
  btnSend.addActionListener(new ActionListenerImpl());
  pnlChatArea.add(btnSend);
  JPanel pnlLogArea=new JPanel();
  pnlLogArea.setBounds(202,11,572,362);
  pnlLogArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  getContentPane().add(pnlLogArea);
  pnlLogArea.setLayout(null);
  JPanel pnlLogList=new JPanel();
  pnlLogList.setLayout(null);
  pnlLogList.setBounds(10,21,552,149);
  pnlLogArea.add(pnlLogList);
  treeRootNode=new DefaultMutableTreeNode(""String_Node_Str"");
  lstLogTree=new JTree(treeRootNode);
  lstLogTree.setRootVisible(true);
  lstLogTree.setBounds(0,0,pnlLogList.getWidth(),pnlLogList.getHeight() - 5);
  lstLogTree.setSize(pnlLogList.getWidth(),pnlLogList.getHeight() - 5);
  lstLogTree.addTreeSelectionListener(new TreeListAction());
  JScrollPane scrollPane=new JScrollPane(lstLogTree);
  lstLogTreeModel=(DefaultTreeModel)lstLogTree.getModel();
  scrollPane.setSize(pnlLogList.getWidth(),pnlLogList.getHeight());
  pnlLogList.add(scrollPane);
  JPanel pnlLogDetailedInfo=new JPanel();
  pnlLogDetailedInfo.setBounds(10,172,552,179);
  pnlLogArea.add(pnlLogDetailedInfo);
  pnlLogDetailedInfo.setLayout(null);
  txtLogInfo=new TextArea(""String_Node_Str"",5,50,TextArea.SCROLLBARS_VERTICAL_ONLY);
  txtLogInfo.setBackground(getBackground());
  txtLogInfo.setEditable(false);
  txtLogInfo.setBounds(10,22,532,147);
  pnlLogDetailedInfo.add(txtLogInfo);
  JPanel pnlConnectionsArea=new JPanel();
  pnlConnectionsArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  pnlConnectionsArea.setBounds(10,11,182,309);
  getContentPane().add(pnlConnectionsArea);
  pnlConnectionsArea.setLayout(null);
  JLabel lblEnterHostname=new JLabel(""String_Node_Str"");
  lblEnterHostname.setBounds(10,21,162,14);
  pnlConnectionsArea.add(lblEnterHostname);
  txtAddConnection=new JTextField();
  txtAddConnection.setBorder(txtBorder);
  txtAddConnection.setBounds(10,46,92,20);
  pnlConnectionsArea.add(txtAddConnection);
  txtAddConnection.setColumns(10);
  btnAddConnection=new JButton(""String_Node_Str"");
  btnAddConnection.setBounds(111,45,61,23);
  btnAddConnection.addActionListener(new ActionListenerImpl());
  pnlConnectionsArea.add(btnAddConnection);
  JLabel lblExistingSessions=new JLabel(""String_Node_Str"");
  lblExistingSessions.setBounds(10,90,162,14);
  pnlConnectionsArea.add(lblExistingSessions);
  JSeparator separator=new JSeparator();
  separator.setBounds(10,77,162,2);
  pnlConnectionsArea.add(separator);
  JLabel lblChosenCipherSuite=new JLabel(""String_Node_Str"");
  lblChosenCipherSuite.setBounds(10,235,162,14);
  pnlConnectionsArea.add(lblChosenCipherSuite);
  lblChosenCipherSuite.setEnabled(false);
  lblActiveCipherSuite=new JLabel(""String_Node_Str"");
  lblActiveCipherSuite.setEnabled(false);
  lblActiveCipherSuite.setBounds(10,253,162,20);
  pnlConnectionsArea.add(lblActiveCipherSuite);
  lstModelSessions=new DefaultListModel();
  lstExistingSessions=new JList(lstModelSessions);
  lstExistingSessions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  lstExistingSessions.setBounds(10,124,pnlConnectionsArea.getWidth() - 20,100);
  lstExistingSessions.setPrototypeCellValue(""String_Node_Str"");
  lstExistingSessions.addMouseListener(new ListAction());
  pnlConnectionsArea.add((lstExistingSessions));
  JLabel lblSessionTimeoutInfo=new JLabel(""String_Node_Str"");
  lblSessionTimeoutInfo.setBounds(10,284,110,14);
  pnlConnectionsArea.add(lblSessionTimeoutInfo);
  lblSessionTimeout=new JLabel(""String_Node_Str"");
  lblSessionTimeout.setBounds(130,284,46,14);
  pnlConnectionsArea.add(lblSessionTimeout);
  JPanel pnlSettingsArea=new JPanel();
  pnlSettingsArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  pnlSettingsArea.setBounds(10,320,182,231);
  getContentPane().add(pnlSettingsArea);
  pnlSettingsArea.setLayout(null);
  JPanel pnlCipherSuites=new JPanel();
  pnlCipherSuites.setBounds(10,20,162,166);
  pnlSettingsArea.add(pnlCipherSuites);
  pnlCipherSuites.setLayout(null);
  JLabel lblCipherSuites=new JLabel(""String_Node_Str"");
  lblCipherSuites.setBounds(0,0,142,14);
  pnlCipherSuites.add(lblCipherSuites);
  btnPerformance=new JButton(""String_Node_Str"");
  btnPerformance.setBounds(10,197,162,23);
  btnPerformance.addActionListener(new ActionListenerImpl());
  pnlSettingsArea.add(btnPerformance);
  int i=17;
  for (  CipherSuite s : TLSEngine.allCipherSuites) {
    JCheckBox cbxCipherSuite=new JCheckBox(s.getName());
    cbxCipherSuite.setToolTipText(s.getName());
    cbxCipherSuite.setBounds(0,i,160,20);
    cbxCipherSuite.setSelected(s.isEnabled());
    cbxCipherSuite.addActionListener(new ActionListenerImpl());
    pnlCipherSuites.add(cbxCipherSuite);
    i=i + 20;
  }
  JLabel lblCompressionMethods=new JLabel(""String_Node_Str"");
  lblCompressionMethods.setBounds(0,i,160,20);
  pnlCipherSuites.add(lblCompressionMethods);
  i=i + 20;
  for (  ICompression comp : ICompression.allCompressionMethods) {
    if (!comp.getName().equals(""String_Node_Str"")) {
      JCheckBox cbxCompression=new JCheckBox(comp.getName());
      cbxCompression.setSelected(comp.isEnabled());
      cbxCompression.addActionListener(new ActionListenerImpl());
      cbxCompression.setBounds(0,i,160,20);
      pnlCipherSuites.add(cbxCompression);
      i=i + 20;
    }
  }
  addConnection(""String_Node_Str"",false);
  test();
  repaint();
}","private void initializeComponents(){
  Border txtBorder=BorderFactory.createBevelBorder(BevelBorder.LOWERED);
  JPanel pnlChatArea=new JPanel();
  pnlChatArea.setBounds(202,374,572,177);
  pnlChatArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  getContentPane().add(pnlChatArea);
  pnlChatArea.setLayout(null);
  JPanel pnlChatLogArea=new JPanel();
  pnlChatLogArea.setBounds(10,21,552,114);
  pnlChatArea.add(pnlChatLogArea);
  lstModelChat=new DefaultListModel();
  JList lstChatLog=new JList(lstModelChat);
  lstChatLog.setBounds(0,0,pnlChatLogArea.getWidth(),50);
  lstChatLog.setPrototypeCellValue(""String_Node_Str"");
  lstChatLog.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  lstChatLog.setBackground(getBackground());
  lstChatLog.setBorder(BorderFactory.createEmptyBorder());
  pnlChatLogArea.add(new JScrollPane(lstChatLog));
  txtChatSendMsg=new JTextField();
  txtChatSendMsg.setBorder(txtBorder);
  txtChatSendMsg.setBounds(10,146,453,20);
  pnlChatArea.add(txtChatSendMsg);
  txtChatSendMsg.setColumns(10);
  btnSend=new JButton(""String_Node_Str"");
  btnSend.setBounds(473,146,89,23);
  btnSend.addActionListener(new ActionListenerImpl());
  pnlChatArea.add(btnSend);
  JPanel pnlLogArea=new JPanel();
  pnlLogArea.setBounds(202,11,572,362);
  pnlLogArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  getContentPane().add(pnlLogArea);
  pnlLogArea.setLayout(null);
  JPanel pnlLogList=new JPanel();
  pnlLogList.setLayout(null);
  pnlLogList.setBounds(10,21,552,149);
  pnlLogArea.add(pnlLogList);
  treeRootNode=new DefaultMutableTreeNode(""String_Node_Str"");
  lstLogTree=new JTree(treeRootNode);
  lstLogTree.setRootVisible(true);
  lstLogTree.setBounds(0,0,pnlLogList.getWidth(),pnlLogList.getHeight() - 5);
  lstLogTree.setSize(pnlLogList.getWidth(),pnlLogList.getHeight() - 5);
  lstLogTree.addTreeSelectionListener(new TreeListAction());
  JScrollPane scrollPane=new JScrollPane(lstLogTree);
  lstLogTreeModel=(DefaultTreeModel)lstLogTree.getModel();
  scrollPane.setSize(pnlLogList.getWidth(),pnlLogList.getHeight());
  pnlLogList.add(scrollPane);
  JPanel pnlLogDetailedInfo=new JPanel();
  pnlLogDetailedInfo.setBounds(10,172,552,179);
  pnlLogArea.add(pnlLogDetailedInfo);
  pnlLogDetailedInfo.setLayout(null);
  txtLogInfo=new TextArea(""String_Node_Str"",5,50,TextArea.SCROLLBARS_VERTICAL_ONLY);
  txtLogInfo.setBackground(getBackground());
  txtLogInfo.setEditable(false);
  txtLogInfo.setBounds(10,22,532,147);
  pnlLogDetailedInfo.add(txtLogInfo);
  JPanel pnlConnectionsArea=new JPanel();
  pnlConnectionsArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  pnlConnectionsArea.setBounds(10,11,182,309);
  getContentPane().add(pnlConnectionsArea);
  pnlConnectionsArea.setLayout(null);
  JLabel lblEnterHostname=new JLabel(""String_Node_Str"");
  lblEnterHostname.setBounds(10,21,162,14);
  pnlConnectionsArea.add(lblEnterHostname);
  txtAddConnection=new JTextField();
  txtAddConnection.setBorder(txtBorder);
  txtAddConnection.setBounds(10,46,92,20);
  pnlConnectionsArea.add(txtAddConnection);
  txtAddConnection.setColumns(10);
  btnAddConnection=new JButton(""String_Node_Str"");
  btnAddConnection.setBounds(111,45,61,23);
  btnAddConnection.addActionListener(new ActionListenerImpl());
  pnlConnectionsArea.add(btnAddConnection);
  JLabel lblExistingSessions=new JLabel(""String_Node_Str"");
  lblExistingSessions.setBounds(10,90,162,14);
  pnlConnectionsArea.add(lblExistingSessions);
  JSeparator separator=new JSeparator();
  separator.setBounds(10,77,162,2);
  pnlConnectionsArea.add(separator);
  JLabel lblChosenCipherSuite=new JLabel(""String_Node_Str"");
  lblChosenCipherSuite.setBounds(10,235,162,14);
  pnlConnectionsArea.add(lblChosenCipherSuite);
  lblChosenCipherSuite.setEnabled(false);
  lblActiveCipherSuite=new JLabel(""String_Node_Str"");
  lblActiveCipherSuite.setEnabled(false);
  lblActiveCipherSuite.setBounds(10,253,162,20);
  pnlConnectionsArea.add(lblActiveCipherSuite);
  lstModelSessions=new DefaultListModel();
  lstExistingSessions=new JList(lstModelSessions);
  lstExistingSessions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  lstExistingSessions.setBounds(10,124,pnlConnectionsArea.getWidth() - 20,100);
  lstExistingSessions.setPrototypeCellValue(""String_Node_Str"");
  lstExistingSessions.addMouseListener(new ListAction());
  pnlConnectionsArea.add((lstExistingSessions));
  JLabel lblSessionTimeoutInfo=new JLabel(""String_Node_Str"");
  lblSessionTimeoutInfo.setBounds(10,284,110,14);
  pnlConnectionsArea.add(lblSessionTimeoutInfo);
  lblSessionTimeout=new JLabel(""String_Node_Str"");
  lblSessionTimeout.setBounds(130,284,46,14);
  pnlConnectionsArea.add(lblSessionTimeout);
  JPanel pnlSettingsArea=new JPanel();
  pnlSettingsArea.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  pnlSettingsArea.setBounds(10,320,182,231);
  getContentPane().add(pnlSettingsArea);
  pnlSettingsArea.setLayout(null);
  JPanel pnlCipherSuites=new JPanel();
  pnlCipherSuites.setBounds(10,20,162,166);
  pnlSettingsArea.add(pnlCipherSuites);
  pnlCipherSuites.setLayout(null);
  JLabel lblCipherSuites=new JLabel(""String_Node_Str"");
  lblCipherSuites.setBounds(0,0,142,14);
  pnlCipherSuites.add(lblCipherSuites);
  btnPerformance=new JButton(""String_Node_Str"");
  btnPerformance.setBounds(10,197,162,23);
  btnPerformance.addActionListener(new ActionListenerImpl());
  pnlSettingsArea.add(btnPerformance);
  int i=17;
  for (  CipherSuite s : TLSEngine.allCipherSuites) {
    JCheckBox cbxCipherSuite=new JCheckBox(s.getName());
    cbxCipherSuite.setToolTipText(s.getName());
    cbxCipherSuite.setBounds(0,i,160,20);
    cbxCipherSuite.setSelected(s.isEnabled());
    cbxCipherSuite.addActionListener(new ActionListenerImpl());
    pnlCipherSuites.add(cbxCipherSuite);
    i=i + 20;
  }
  JLabel lblCompressionMethods=new JLabel(""String_Node_Str"");
  lblCompressionMethods.setBounds(0,i,160,20);
  pnlCipherSuites.add(lblCompressionMethods);
  i=i + 20;
  for (  ICompression comp : ICompression.allCompressionMethods) {
    if (!comp.getName().equals(""String_Node_Str"")) {
      JCheckBox cbxCompression=new JCheckBox(comp.getName());
      cbxCompression.setSelected(comp.isEnabled());
      cbxCompression.addActionListener(new ActionListenerImpl());
      cbxCompression.setBounds(0,i,160,20);
      pnlCipherSuites.add(cbxCompression);
      i=i + 20;
    }
  }
  addConnection(""String_Node_Str"",false);
  repaint();
}",0.9992273218976976
154351,"public void resumeSession(State state){
  this.cipherSuite=state.getCipherSuite();
  preMasterSecret=state.getPreMasterSecret();
  isResumeSession=true;
  generateKeys();
}","public void resumeSession(State state){
  this.cipherSuite=state.getCipherSuite();
  preMasterSecret=state.getPreMasterSecret();
  isResumableSession=true;
  generateKeys();
}",0.9913544668587896
154352,"public boolean isResumeSession(){
  return isResumeSession;
}","public boolean isResumeSession(){
  return isResumableSession;
}",0.976
154353,"public State(IPeerCommunicator peer){
  this.peer=peer;
  cipherSuite=new CipherSuite(""String_Node_Str"",(byte)0x0,new crypto.hash.None(),new crypto.cipher.None(),new crypto.keyexchange.None());
  compressionMethod=new crypto.compression.None();
  changeCipherSpecClient=false;
  changeCipherSpecServer=false;
  isResumeSession=false;
  handshakeLog=new LogEvent(""String_Node_Str"",""String_Node_Str"" + peer.getPeerId());
  setSessionId(new byte[TLSHandshake.SESSION_SIZE]);
}","public State(IPeerCommunicator peer){
  this.peer=peer;
  cipherSuite=new CipherSuite(""String_Node_Str"",(byte)0x0,new crypto.hash.None(),new crypto.cipher.None(),new crypto.keyexchange.None());
  compressionMethod=new crypto.compression.None();
  changeCipherSpecClient=false;
  changeCipherSpecServer=false;
  isResumableSession=false;
  handshakeLog=new LogEvent(""String_Node_Str"",""String_Node_Str"" + peer.getPeerId());
  setSessionId(new byte[TLSHandshake.SESSION_SIZE]);
}",0.9968387776606956
154354,"/** 
 * Verify the received finished message 
 * @param state The current connection state
 * @param messages All handshake messages
 */
public Finished(State state,ArrayList<IHandshakeMessage> messages,byte[] value){
  Tools.print(messages.size() + ""String_Node_Str"");
  this.state=state;
  this.messages=messages;
  try {
    calculatePRF(state.getEntityType(true).toString() + ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  if (Tools.compareByteArray(prfvalue,value))   System.out.println(""String_Node_Str"");
}","/** 
 * Verify the received finished message 
 * @param state The current connection state
 * @param messages All handshake messages
 */
public Finished(State state,ArrayList<IHandshakeMessage> messages,byte[] value){
  Tools.print(messages.size() + ""String_Node_Str"");
  this.state=state;
  this.messages=messages;
  try {
    calculatePRF(state.getEntityType(true).toString() + ""String_Node_Str"");
  }
 catch (  IOException e) {
    state.addHandshakeLog(""String_Node_Str"");
  }
  if (!Tools.compareByteArray(prfvalue,value))   state.addHandshakeLog(""String_Node_Str"");
}",0.9152542372881356
154355,"private void calculatePRF(String label) throws IOException {
  Tools.print(messages.size() + ""String_Node_Str"");
  ByteArrayOutputStream buf=new ByteArrayOutputStream();
  handshakeMessages=new ArrayList<String>();
  for (  IHandshakeMessage m : messages) {
    buf.write(m.getByte());
    handshakeMessages.add(m.toString());
  }
  byte[] value=new byte[buf.size()];
  value=buf.toByteArray();
  prfvalue=new byte[state.getVerifyDataLength()];
  crypto.PRF.generate(state.getMasterSecret(),label,value,prfvalue);
}","/** 
 * Calculates the PRF value of all handshake messages, the label,  and the master secret for the current connection state 
 * @param label The label to the PRF method
 */
private void calculatePRF(String label) throws IOException {
  Tools.print(messages.size() + ""String_Node_Str"");
  ByteArrayOutputStream buf=new ByteArrayOutputStream();
  handshakeMsgString=new ArrayList<String>();
  for (  IHandshakeMessage m : messages) {
    buf.write(m.getByte());
    handshakeMsgString.add(m.toString());
  }
  byte[] value=new byte[buf.size()];
  value=buf.toByteArray();
  prfvalue=new byte[state.getVerifyDataLength()];
  crypto.PRF.generate(state.getMasterSecret(),label,value,prfvalue);
}",0.8294701986754967
154356,"public String getStringValue(){
  StringBuilder sb=new StringBuilder();
  if (state.getEntityType() == ConnectionEnd.Client)   sb.append(""String_Node_Str"");
 else   sb.append(""String_Node_Str"");
  sb.append(LogEvent.NEWLINE + LogEvent.NEWLINE);
  sb.append(""String_Node_Str"" + Tools.byteArrayToString(state.getMasterSecret()));
  sb.append(LogEvent.NEWLINE + ""String_Node_Str"" + LogEvent.NEWLINE);
  for (  String s : handshakeMessages)   sb.append(LogEvent.INDENT + s + LogEvent.NEWLINE);
  return sb.toString();
}","public String getStringValue(){
  StringBuilder sb=new StringBuilder();
  if (state.getEntityType() == ConnectionEnd.Client)   sb.append(""String_Node_Str"");
 else   sb.append(""String_Node_Str"");
  sb.append(LogEvent.NEWLINE + LogEvent.NEWLINE);
  sb.append(""String_Node_Str"" + Tools.byteArrayToString(state.getMasterSecret()));
  sb.append(LogEvent.NEWLINE + ""String_Node_Str"" + LogEvent.NEWLINE);
  for (  String s : handshakeMsgString)   sb.append(LogEvent.INDENT + s + LogEvent.NEWLINE);
  return sb.toString();
}",0.98545101842871
154357,"private void serverHandshake() throws AlertException {
switch (type) {
case CLIENT_HELLO:
    if (lastMessage != HELLO_REQUEST && lastMessage != FINISHED)     throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
  serverRandom=new byte[RANDOM_SIZE];
genRandom(serverRandom);
clientHello=new ClientHello(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",clientHello.getStringValue()));
serverHello=new ServerHello(clientHello,serverRandom);
state.setServerRandom(serverRandom);
state.setClientRandom(clientHello.getClientRandom());
if (serverHello.isSessionResume()) {
State tmpState=TLSEngine.findState(serverHello.getSessionId());
if (tmpState != null) {
state.resumeSession(tmpState);
state.addHandshakeLog(""String_Node_Str"");
}
 else {
state.addHandshakeLog(""String_Node_Str"");
genRandom(sessionId);
serverHello.setSessionId(sessionId);
}
}
sessionId=serverHello.getSessionId();
state.setSessionId(sessionId);
responseQueue.add(serverHello);
serverCertificate=new ServerCertificate(state.getPeerHost(),serverHello);
responseQueue.add(serverCertificate);
if (serverHello.getChosenCipherSuite().getKeyExchange().requireServerKeyExchange()) {
serverKeyExchange=new ServerKeyExchange(serverHello);
responseQueue.add(serverKeyExchange);
}
serverHelloDone=new ServerHelloDone();
responseQueue.add(serverHelloDone);
break;
case CERTIFICATE_VERIFY:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",""String_Node_Str""));
throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
case CLIENT_KEY_EXCHANGE:
clientKeyExchange=new ClientKeyExchange(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",clientKeyExchange.getStringValue()));
if (lastMessage != SERVER_HELLO_DONE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
break;
case CHANGE_CIPHER_SPEC:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",Tools.byteArrayToString(content)));
state.setChangeCipherSpecClient();
state.setCipherSuite(serverHello.getChosenCipherSuite());
break;
case FINISHED:
if (lastMessage != CHANGE_CIPHER_SPEC) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
if (!state.getChangeCipherSpecClient()) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
responseQueue.add(new ChangeCipherSpec());
clientFinished=new Finished(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",clientFinished.getStringValue()));
state.setChangeCipherSpecServer();
serverFinished=new Finished();
responseQueue.add(serverFinished);
break;
default :
throw new AlertException(AlertException.alert_warning,AlertException.handshake_failure,""String_Node_Str"" + type);
}
}","private void serverHandshake() throws AlertException {
switch (type) {
case CLIENT_HELLO:
    if (lastMessage != HELLO_REQUEST && lastMessage != FINISHED)     throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
  serverRandom=new byte[RANDOM_SIZE];
genRandom(serverRandom);
clientHello=new ClientHello(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",clientHello.getStringValue()));
serverHello=new ServerHello(clientHello,serverRandom);
state.setServerRandom(serverRandom);
state.setClientRandom(clientHello.getClientRandom());
if (serverHello.isSessionResume()) {
State tmpState=TLSEngine.findState(serverHello.getSessionId());
if (tmpState != null) {
state.resumeSession(tmpState);
state.addHandshakeLog(""String_Node_Str"");
}
 else {
state.addHandshakeLog(""String_Node_Str"");
genRandom(sessionId);
serverHello.setSessionId(sessionId);
}
}
sessionId=serverHello.getSessionId();
state.setSessionId(sessionId);
responseQueue.add(serverHello);
serverCertificate=new ServerCertificate(state.getPeerHost(),serverHello);
responseQueue.add(serverCertificate);
if (serverHello.getChosenCipherSuite().getKeyExchange().requireServerKeyExchange()) {
serverKeyExchange=new ServerKeyExchange(serverHello);
responseQueue.add(serverKeyExchange);
}
serverHelloDone=new ServerHelloDone();
responseQueue.add(serverHelloDone);
break;
case CERTIFICATE_VERIFY:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",""String_Node_Str""));
throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
case CLIENT_KEY_EXCHANGE:
clientKeyExchange=new ClientKeyExchange(content);
state.setPreMasterSecret(clientKeyExchange.getByte());
state.addHandshakeLog(new LogEvent(""String_Node_Str"",clientKeyExchange.getStringValue()));
if (lastMessage != SERVER_HELLO_DONE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
break;
case CHANGE_CIPHER_SPEC:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",Tools.byteArrayToString(content)));
state.setChangeCipherSpecClient();
state.setCipherSuite(serverHello.getChosenCipherSuite());
break;
case FINISHED:
if (lastMessage != CHANGE_CIPHER_SPEC) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
if (!state.getChangeCipherSpecClient()) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
responseQueue.add(new ChangeCipherSpec());
clientFinished=new Finished(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",clientFinished.getStringValue()));
state.setChangeCipherSpecServer();
serverFinished=new Finished();
responseQueue.add(serverFinished);
break;
default :
throw new AlertException(AlertException.alert_warning,AlertException.handshake_failure,""String_Node_Str"" + type);
}
}",0.9905057828413604
154358,"private void clientHandshake() throws AlertException {
switch (type) {
case HELLO_REQUEST:
    clientRandom=new byte[RANDOM_SIZE];
  genRandom(clientRandom);
state.setClientRandom(clientRandom);
State tmpState=TLSEngine.findState(state.getPeerHost());
if (tmpState != null) sessionId=tmpState.getSessionId();
clientHello=new ClientHello(clientRandom,sessionId,TLSEngine.allCipherSuites);
responseQueue.add(clientHello);
break;
case SERVER_HELLO:
if (lastMessage != CLIENT_HELLO) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverHello=new ServerHello(content);
if (!Tools.isEmptyByteArray(sessionId) && Tools.compareByteArray(sessionId,serverHello.getSessionId())) {
state.setServerRandom(serverHello.getServerRandom());
state.resumeSession(TLSEngine.findState(sessionId));
state.addHandshakeLog(""String_Node_Str"");
}
 else {
sessionId=serverHello.getSessionId();
state.setSessionId(sessionId);
}
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverHello.getStringValue()));
break;
case CERTIFICATE:
if (lastMessage != SERVER_HELLO) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverCertificate=new ServerCertificate(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverCertificate.getStringValue()));
break;
case SERVER_KEY_EXCHANGE:
if (lastMessage != CERTIFICATE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverKeyExchange=new ServerKeyExchange(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverKeyExchange.getStringValue()));
break;
case CERTIFICATE_REQUEST:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",""String_Node_Str""));
throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
case SERVER_HELLO_DONE:
if (lastMessage != SERVER_KEY_EXCHANGE && lastMessage != CERTIFICATE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverHelloDone=new ServerHelloDone();
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverHelloDone.getStringValue()));
if (serverHello.getChosenCipherSuite().getKeyExchange().requireServerKeyExchange()) clientKeyExchange=new ClientKeyExchange(serverHello.getChosenCipherSuite().getKeyExchange());
 else {
preMasterSecret=new byte[RANDOM_SIZE];
genRandom(preMasterSecret);
clientKeyExchange=new ClientKeyExchange(preMasterSecret);
}
responseQueue.add(clientKeyExchange);
responseQueue.add(new ChangeCipherSpec());
state.setChangeCipherSpecClient();
state.setCipherSuite(serverHello.getChosenCipherSuite());
clientFinished=new Finished();
responseQueue.add(clientFinished);
break;
case CHANGE_CIPHER_SPEC:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",Tools.byteArrayToString(content)));
state.setChangeCipherSpecServer();
break;
case FINISHED:
if (lastMessage != CHANGE_CIPHER_SPEC) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
if (!state.getChangeCipherSpecServer()) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
serverFinished=new Finished(content);
isFinished=true;
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverFinished.getStringValue()));
state.addHandshakeLog(""String_Node_Str"" + serverHello.getChosenCipherSuite().getName());
break;
default :
throw new AlertException(AlertException.alert_warning,AlertException.unexpected_message,""String_Node_Str"" + type);
}
}","private void clientHandshake() throws AlertException {
switch (type) {
case HELLO_REQUEST:
    clientRandom=new byte[RANDOM_SIZE];
  genRandom(clientRandom);
state.setClientRandom(clientRandom);
State tmpState=TLSEngine.findState(state.getPeerHost());
if (tmpState != null) sessionId=tmpState.getSessionId();
clientHello=new ClientHello(clientRandom,sessionId,TLSEngine.allCipherSuites);
responseQueue.add(clientHello);
break;
case SERVER_HELLO:
if (lastMessage != CLIENT_HELLO) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverHello=new ServerHello(content);
state.setServerRandom(serverHello.getServerRandom());
if (!Tools.isEmptyByteArray(sessionId) && Tools.compareByteArray(sessionId,serverHello.getSessionId())) {
state.setServerRandom(serverHello.getServerRandom());
state.resumeSession(TLSEngine.findState(sessionId));
state.addHandshakeLog(""String_Node_Str"");
}
 else {
sessionId=serverHello.getSessionId();
state.setSessionId(sessionId);
}
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverHello.getStringValue()));
break;
case CERTIFICATE:
if (lastMessage != SERVER_HELLO) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverCertificate=new ServerCertificate(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverCertificate.getStringValue()));
break;
case SERVER_KEY_EXCHANGE:
if (lastMessage != CERTIFICATE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverKeyExchange=new ServerKeyExchange(content);
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverKeyExchange.getStringValue()));
break;
case CERTIFICATE_REQUEST:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",""String_Node_Str""));
throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
case SERVER_HELLO_DONE:
if (lastMessage != SERVER_KEY_EXCHANGE && lastMessage != CERTIFICATE) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
serverHelloDone=new ServerHelloDone();
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverHelloDone.getStringValue()));
if (serverHello.getChosenCipherSuite().getKeyExchange().requireServerKeyExchange()) clientKeyExchange=new ClientKeyExchange(serverHello.getChosenCipherSuite().getKeyExchange());
 else {
preMasterSecret=new byte[RANDOM_SIZE];
genRandom(preMasterSecret);
clientKeyExchange=new ClientKeyExchange(preMasterSecret);
}
state.setPreMasterSecret(clientKeyExchange.getByte());
responseQueue.add(clientKeyExchange);
responseQueue.add(new ChangeCipherSpec());
state.setChangeCipherSpecClient();
state.setCipherSuite(serverHello.getChosenCipherSuite());
clientFinished=new Finished();
responseQueue.add(clientFinished);
break;
case CHANGE_CIPHER_SPEC:
state.addHandshakeLog(new LogEvent(""String_Node_Str"",Tools.byteArrayToString(content)));
state.setChangeCipherSpecServer();
break;
case FINISHED:
if (lastMessage != CHANGE_CIPHER_SPEC) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"" + lastMessage);
if (!state.getChangeCipherSpecServer()) throw new AlertException(AlertException.alert_fatal,AlertException.handshake_failure,""String_Node_Str"");
serverFinished=new Finished(content);
isFinished=true;
state.addHandshakeLog(new LogEvent(""String_Node_Str"",serverFinished.getStringValue()));
state.addHandshakeLog(""String_Node_Str"" + serverHello.getChosenCipherSuite().getName());
break;
default :
throw new AlertException(AlertException.alert_warning,AlertException.unexpected_message,""String_Node_Str"" + type);
}
}",0.9853040312794932
154359,"/** 
 * Given an class extending Jointed get the @Joint annotation on it.
 * @param < T > a type extending Jointed
 * @param type a class extending Jointed
 * @return the @Joint annotation on type
 */
public static synchronized <T>Joint getJoint(final Class<T> type){
  return type.getAnnotation(Joint.class);
}","/** 
 * Given an class extending get the @Joint annotation on it.
 * @param < T > a type
 * @param type a class
 * @return the @Joint annotation on type
 */
public static synchronized <T>Joint getJoint(final Class<T> type){
  return type.getAnnotation(Joint.class);
}",0.9238754325259516
154360,"/** 
 * Lookup all implementations of a class which extends T
 * @param < T > must extend Jointed
 * @param type must extend T
 * @return all implementations of type
 */
@SuppressWarnings(""String_Node_Str"") public static synchronized <T>Set<Class<T>> lookupJoints(final Class<T> type){
  Lookup.Template<T> template=new Lookup.Template<T>(type);
  Lookup.Result<T> result=Lookup.getDefault().lookup(template);
  Collection<? extends Item<T>> items=result.allItems();
  Set<Class<T>> joints=new HashSet<Class<T>>(items.size());
  for (  Item<T> item : items) {
    joints.add((Class<T>)item.getType());
  }
  return joints;
}","/** 
 * Lookup all implementations of a class which extends T
 * @param < T >
 * @param type must extend T
 * @return all implementations of type
 */
@SuppressWarnings(""String_Node_Str"") public static synchronized <T>Set<Class<T>> lookupJoints(final Class<T> type){
  Lookup.Template<T> template=new Lookup.Template<T>(type);
  Lookup.Result<T> result=Lookup.getDefault().lookup(template);
  Collection<? extends Item<T>> items=result.allItems();
  Set<Class<T>> joints=new HashSet<Class<T>>(items.size());
  for (  Item<T> item : items) {
    joints.add((Class<T>)item.getType());
  }
  return joints;
}",0.98371335504886
154361,"/** 
 * Get the Joint id of the given extension of Jointed
 * @param < T > extends Jointed
 * @param type Class extending Jointed
 * @return @Joint.id of type
 */
public static <T>String getJointId(final Class<T> type){
  Object owner=new Object();
  Joint joint=null;
synchronized (owner) {
    joint=getJoint(type);
  }
  String id=null;
  if (joint != null) {
    id=joint.id();
  }
  return id;
}","/** 
 * Get the Joint id
 * @param < T >
 * @param type Class
 * @return @Joint.id of type
 */
public static <T>String getJointId(final Class<T> type){
  Object owner=new Object();
  Joint joint=null;
synchronized (owner) {
    joint=getJoint(type);
  }
  String id=null;
  if (joint != null) {
    id=joint.id();
  }
  return id;
}",0.907103825136612
154362,"/** 
 * If you know a Joint's id you can look up that class.
 * @param < T > extends Jointed
 * @param type class extending Jointed
 * @param id Joint.id of the Jointed class instance you are looking for.
 * @return first class extending T with a matching @throws JointNotFoundException
 * @throws JointNotFoundException
 * @Joint.id
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Class<T> findByJointId(final Class<T> type,final String id) throws JointNotFoundException {
  Set<Class<T>> joints=null;
  Object owner=new Object();
synchronized (owner) {
    joints=lookupJoints(type);
  }
  Class<T> result=null;
  for (  Class<T> joint : joints) {
    if (id.equals(getJointId(joint))) {
      result=joint;
      break;
    }
  }
  if (result == null) {
    throw new JointNotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ type.getName());
  }
  return (Class<T>)result;
}","/** 
 * If you know a Joint's id you can look up that class.
 * @param < T >
 * @param type class
 * @param id Joint.id of the class instance you are looking for.
 * @return first class extending T with a matching @throws JointNotFoundException
 * @throws JointNotFoundException
 * @Joint.id
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Class<T> findByJointId(final Class<T> type,final String id) throws JointNotFoundException {
  Set<Class<T>> joints=null;
  Object owner=new Object();
synchronized (owner) {
    joints=lookupJoints(type);
  }
  Class<T> result=null;
  for (  Class<T> joint : joints) {
    if (id.equals(getJointId(joint))) {
      result=joint;
      break;
    }
  }
  if (result == null) {
    throw new JointNotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ type.getName());
  }
  return (Class<T>)result;
}",0.976027397260274
154363,"private int read() throws IOException {
  int c=(short)_reader.read();
  if (c == '\n') {
    _line++;
    _column=1;
  }
 else   if (c == '\t') {
    _column+=4 - ((_column - 1) % TABSIZE);
  }
 else {
    _column++;
  }
  return c;
}","private int read() throws IOException {
  int c=(short)_reader.read();
  if (c == '\n') {
    _line++;
    _column=1;
  }
 else   if (c == '\t') {
    _lastTab=4 - ((_column - 1) % TABSIZE);
    _column+=_lastTab;
  }
 else {
    _column++;
  }
  return c;
}",0.7545638945233266
154364,"private void unread(int c) throws IOException {
  if (c == '\t') {
    _column-=TABSIZE;
  }
 else   if (c == '\n') {
  }
 else   _column--;
  _reader.unread(c);
}","private void unread(int c) throws IOException {
  if (c == '\t') {
    _column-=_lastTab;
  }
 else   if (c == '\n') {
  }
 else   _column--;
  _reader.unread(c);
}",0.9602446483180428
154365,"public Token next() throws IOException {
  while (true) {
    int c=read();
switch (c) {
case ' ':
case '\n':
case '\r':
case '\t':
      break;
case '/':
    c=read();
switch (c) {
case '*':
    skipComment();
  break;
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
break;
case '!':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '(':
return operator(""String_Node_Str"");
case ')':
return operator(""String_Node_Str"");
case '*':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '+':
c=read();
switch (c) {
case '+':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case ',':
return operator(""String_Node_Str"");
case '-':
c=read();
switch (c) {
case '-':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '.':
return operator(""String_Node_Str"");
case ':':
return operator(""String_Node_Str"");
case ';':
return operator(""String_Node_Str"");
case '<':
c=read();
switch (c) {
case '<':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '>':
c=read();
switch (c) {
case '>':
c=read();
switch (c) {
case '>':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '?':
return operator(""String_Node_Str"");
case '%':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '&':
c=read();
switch (c) {
case '&':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '[':
return operator(""String_Node_Str"");
case ']':
return operator(""String_Node_Str"");
case '^':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '{':
return operator(""String_Node_Str"");
case '}':
return operator(""String_Node_Str"");
case '~':
return operator(""String_Node_Str"");
case '|':
c=read();
switch (c) {
case '|':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case -1:
return eof();
default :
if (isLetter(c) || c == '_') {
return lexIdentifier(c);
}
 else if (isDigit(c)) {
return lexInteger(c);
}
 else {
return error();
}
}
}
}","public Token next() throws IOException {
  while (true) {
    int c=read();
switch (c) {
case '\n':
      _line++;
    _column=1;
case ' ':
case '\r':
case '\t':
  break;
case '/':
c=read();
switch (c) {
case '*':
skipComment();
break;
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
break;
case '!':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '(':
return operator(""String_Node_Str"");
case ')':
return operator(""String_Node_Str"");
case '*':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '+':
c=read();
switch (c) {
case '+':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case ',':
return operator(""String_Node_Str"");
case '-':
c=read();
switch (c) {
case '-':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '.':
return operator(""String_Node_Str"");
case ':':
return operator(""String_Node_Str"");
case ';':
return operator(""String_Node_Str"");
case '<':
c=read();
switch (c) {
case '<':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '>':
c=read();
switch (c) {
case '>':
c=read();
switch (c) {
case '>':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '?':
return operator(""String_Node_Str"");
case '%':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '&':
c=read();
switch (c) {
case '&':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '[':
return operator(""String_Node_Str"");
case ']':
return operator(""String_Node_Str"");
case '^':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '{':
return operator(""String_Node_Str"");
case '}':
return operator(""String_Node_Str"");
case '~':
return operator(""String_Node_Str"");
case '|':
c=read();
switch (c) {
case '|':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case -1:
return eof();
default :
if (isLetter(c) || c == '_') {
return lexIdentifier(c);
}
 else if (isDigit(c)) {
return lexInteger(c);
}
 else {
return error();
}
}
}
}",0.9884559884559884
154366,"private int read() throws IOException {
  return (short)_reader.read();
}","private int read() throws IOException {
  _column++;
  return (short)_reader.read();
}",0.9182389937106918
154367,"private void unread(int c) throws IOException {
  _reader.unread(c);
}","private void unread(int c) throws IOException {
  _column--;
  _reader.unread(c);
}",0.915032679738562
154368,"private static void runSyntaxCheck(File file) throws IOException {
  Lexer lexer=new Lexer(new FileReader(file));
  Parser parser=new Parser(lexer);
  try {
    parser.parseProgram();
  }
 catch (  Parser.UnexpectedTokenException e) {
    System.out.println(""String_Node_Str"" + e.getToken());
    return;
  }
  System.out.println(""String_Node_Str"");
}","private static void runSyntaxCheck(File file) throws IOException {
  Lexer lexer=new Lexer(new FileReader(file));
  Parser parser=new Parser(lexer);
  try {
    parser.parseProgram();
  }
 catch (  Parser.UnexpectedTokenException e) {
    System.out.println(""String_Node_Str"" + e);
    return;
  }
  System.out.println(""String_Node_Str"");
}",0.984081041968162
154369,"private Token getCurrentToken(){
  return _lexer.peek(0);
}","private Token getCurrentToken(){
  _currentLookAhead=1;
  return _lexer.peek(0);
}",0.8368794326241135
154370,"private IntegerLiteral expectIntegerLiteral() throws UnexpectedTokenException {
  if (!(getCurrentToken() instanceof IntegerLiteral))   throw new UnexpectedTokenException(this);
  return (IntegerLiteral)consumeToken();
}","private IntegerLiteral expectIntegerLiteral() throws UnexpectedTokenException {
  if (!(getCurrentToken() instanceof IntegerLiteral))   throw new UnexpectedTokenException(this,""String_Node_Str"");
  return (IntegerLiteral)consumeToken();
}",0.960698689956332
154371,"private Token consumeToken(){
  try {
    return _lexer.next();
  }
 catch (  IOException e) {
    return null;
  }
}","private Token consumeToken(){
  try {
    _currentLookAhead=0;
    return _lexer.next();
  }
 catch (  IOException e) {
    return null;
  }
}",0.9034749034749034
154372,"private Token expectToken(String s) throws UnexpectedTokenException {
  if (!acceptToken(s))   throw new UnexpectedTokenException(this);
  return consumeToken();
}","private Token expectToken(String s) throws UnexpectedTokenException {
  if (!acceptToken(s))   throw new UnexpectedTokenException(this,s);
  return consumeToken();
}",0.9939024390243902
154373,"private Token expectEOF(){
  if (!getCurrentToken().isEof())   throw new UnexpectedTokenException(this);
  return consumeToken();
}","private Token expectEOF(){
  if (!getCurrentToken().isEof())   throw new UnexpectedTokenException(this,""String_Node_Str"");
  return consumeToken();
}",0.9357142857142856
154374,"private Identifier expectIdentifier() throws UnexpectedTokenException {
  if (!(getCurrentToken() instanceof Identifier))   throw new UnexpectedTokenException(this);
  return (Identifier)consumeToken();
}","private Identifier expectIdentifier() throws UnexpectedTokenException {
  if (!(getCurrentToken() instanceof Identifier))   throw new UnexpectedTokenException(this,""String_Node_Str"");
  return (Identifier)consumeToken();
}",0.9577464788732394
154375,"public UnexpectedTokenException(Parser parser){
  _token=parser.getCurrentToken();
  _line=parser.getCurrentLine();
  _column=parser.getCurrentColumn();
}","public UnexpectedTokenException(Parser parser,String expectedToken){
  init(parser);
  _expectedToken=expectedToken;
  if (expectedToken.equals(""String_Node_Str"")) {
    _column--;
  }
}",0.4823529411764706
154376,"@Override public String toString(){
  return _line + ""String_Node_Str"" + _column+ ""String_Node_Str""+ _token+ ""String_Node_Str"";
}","@Override public String toString(){
  String out=_line + ""String_Node_Str"" + _column;
  if (null != _expectedToken) {
    out+=""String_Node_Str"" + _expectedToken + ""String_Node_Str"";
  }
  out+=""String_Node_Str"" + _token + ""String_Node_Str"";
  return out;
}",0.4041450777202072
154377,"private BasicType parseBasicType(){
  if (acceptToken(""String_Node_Str""))   return new BasicType(expectToken(""String_Node_Str""));
 else   if (acceptToken(""String_Node_Str""))   return new BasicType(expectToken(""String_Node_Str""));
 else   if (acceptToken(""String_Node_Str""))   return new BasicType(expectToken(""String_Node_Str""));
 else   if (acceptIdentifier())   return new BasicType(expectIdentifier());
  throw new UnexpectedTokenException(this);
}","private BasicType parseBasicType(){
  if (acceptToken(""String_Node_Str""))   return new BasicType(expectToken(""String_Node_Str""));
 else   if (acceptToken(""String_Node_Str""))   return new BasicType(expectToken(""String_Node_Str""));
 else   if (acceptToken(""String_Node_Str""))   return new BasicType(expectToken(""String_Node_Str""));
 else   if (acceptIdentifier())   return new BasicType(expectIdentifier());
  throw new UnexpectedTokenException(this,""String_Node_Str"");
}",0.9804347826086957
154378,"public Token next() throws IOException {
  Token result=_lookAhead[_pos % _size];
  _lookAhead[_pos % _size]=_lexer.next();
  _pos+=1;
  if (_pos >= _size)   _pos=0;
  return result;
}","public Token next() throws IOException {
  int i=_pos % _size;
  Token result=_lookAhead[i];
  _currentPos=_lookAheadPos[i];
  _currentToken=_lookAhead[i];
  _lookAhead[_pos % _size]=_lexer.next();
  _lookAheadPos[_pos % _size]=new Position(_lexer.getLine(),_lexer.getColumn());
  _pos+=1;
  if (_pos >= _size) {
    _pos=0;
  }
  return result;
}",0.5649717514124294
154379,"public PeekingLexer(Lexer lexer,int size) throws IOException {
  _lexer=lexer;
  _size=size;
  _pos=0;
  _lookAhead=new Token[size];
  for (int i=0; i < size; i++) {
    _lookAhead[i]=_lexer.next();
  }
}","public PeekingLexer(Lexer lexer,int size) throws IOException {
  _lexer=lexer;
  _size=size;
  _pos=0;
  _lookAheadPos=new Position[size];
  _lookAhead=new Token[size];
  for (int i=0; i < size; i++) {
    _lookAhead[i]=_lexer.next();
    _lookAheadPos[i]=new Position(_lexer.getLine(),_lexer.getColumn());
  }
  _currentPos=_lookAheadPos[0];
  _currentToken=_lookAhead[0];
}",0.7046632124352331
154380,"private BlockStatement parseBlockStatement(){
  if (acceptToken(""String_Node_Str"") || acceptToken(""String_Node_Str"") || acceptToken(""String_Node_Str"")|| acceptToken(""String_Node_Str"")|| acceptToken(""String_Node_Str"")|| acceptToken(""String_Node_Str"",2)|| (acceptToken(""String_Node_Str"",1) && !acceptToken(""String_Node_Str"",2))) {
    return parseStatement();
  }
 else {
    return parseLocalVariableDeclarationStatement();
  }
}","private BlockStatement parseBlockStatement(){
  if (acceptToken(""String_Node_Str"") || acceptToken(""String_Node_Str"") || acceptToken(""String_Node_Str"")|| acceptToken(""String_Node_Str"")|| acceptToken(""String_Node_Str"")|| acceptPrimaryExpression())   return parseStatement();
 else   return parseLocalVariableDeclarationStatement();
}",0.8089591567852438
154381,"public Token next() throws IOException {
  while (true) {
    int c=read();
switch (c) {
case ' ':
case '\n':
case '\r':
case '\t':
      break;
case '/':
    c=read();
switch (c) {
case '*':
    skipComment();
  break;
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
break;
case '!':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '(':
return operator(""String_Node_Str"");
case ')':
return operator(""String_Node_Str"");
case '*':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '+':
c=read();
switch (c) {
case '+':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case ',':
return operator(""String_Node_Str"");
case '-':
c=read();
switch (c) {
case '-':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '.':
return operator(""String_Node_Str"");
case ':':
return operator(""String_Node_Str"");
case ';':
return operator(""String_Node_Str"");
case '<':
c=read();
switch (c) {
case '<':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '>':
c=read();
switch (c) {
case '>':
c=read();
switch (c) {
case '>':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '?':
return operator(""String_Node_Str"");
case '%':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '&':
c=read();
switch (c) {
case '&':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '[':
return operator(""String_Node_Str"");
case ']':
return operator(""String_Node_Str"");
case '^':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '{':
return operator(""String_Node_Str"");
case '}':
return operator(""String_Node_Str"");
case '~':
return operator(""String_Node_Str"");
case '|':
c=read();
switch (c) {
case '|':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case -1:
return eof();
default :
if (isLetter(c) || c == '_') {
return lexIdentifier(c);
}
 else if (isDigit(c)) {
return lexInteger(c);
}
 else {
return error();
}
}
}
}","public Token next() throws IOException {
  while (true) {
    int c=(short)read();
switch (c) {
case ' ':
case '\n':
case '\r':
case '\t':
      break;
case '/':
    c=read();
switch (c) {
case '*':
    skipComment();
  break;
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
break;
case '!':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '(':
return operator(""String_Node_Str"");
case ')':
return operator(""String_Node_Str"");
case '*':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '+':
c=read();
switch (c) {
case '+':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case ',':
return operator(""String_Node_Str"");
case '-':
c=read();
switch (c) {
case '-':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '.':
return operator(""String_Node_Str"");
case ':':
return operator(""String_Node_Str"");
case ';':
return operator(""String_Node_Str"");
case '<':
c=read();
switch (c) {
case '<':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '>':
c=read();
switch (c) {
case '>':
c=read();
switch (c) {
case '>':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '?':
return operator(""String_Node_Str"");
case '%':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '&':
c=read();
switch (c) {
case '&':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case '[':
return operator(""String_Node_Str"");
case ']':
return operator(""String_Node_Str"");
case '^':
return operator(ifThenElse('=',""String_Node_Str"",""String_Node_Str""));
case '{':
return operator(""String_Node_Str"");
case '}':
return operator(""String_Node_Str"");
case '~':
return operator(""String_Node_Str"");
case '|':
c=read();
switch (c) {
case '|':
return operator(""String_Node_Str"");
case '=':
return operator(""String_Node_Str"");
default :
unread(c);
return operator(""String_Node_Str"");
}
case -1:
return eof();
default :
if (isLetter(c) || c == '_') {
return lexIdentifier(c);
}
 else if (isDigit(c)) {
return lexInteger(c);
}
 else {
return error();
}
}
}
}",0.9987353206865404
154382,"private Token lexInteger(int c) throws IOException {
  StringBuffer name=new StringBuffer();
  name.append((char)c);
  if (c == '0') {
    return integerLiteral(name.toString());
  }
 else {
    while (true) {
      c=read();
      if (isDigit(c)) {
        name.append((char)c);
      }
 else       if (isLetter(c)) {
        return error();
      }
 else {
        unread(c);
        return integerLiteral(name.toString());
      }
    }
  }
}","private Token lexInteger(int c) throws IOException {
  StringBuffer name=new StringBuffer();
  name.append((char)c);
  if (c == '0') {
    return integerLiteral(name.toString());
  }
 else {
    while (true) {
      c=read();
      if (isDigit(c)) {
        name.append((char)c);
      }
 else {
        unread(c);
        return integerLiteral(name.toString());
      }
    }
  }
}",0.8198307134220073
154383,"private Token lexInteger(int c) throws IOException {
  StringBuffer name=new StringBuffer();
  name.append((char)c);
  if (c == '0') {
    return integerLiteral(name.toString());
  }
 else {
    while (true) {
      c=read();
      if (isDigit(c)) {
        name.append((char)c);
      }
 else {
        unread(c);
        return integerLiteral(name.toString());
      }
    }
  }
}","private Token lexInteger(int c) throws IOException {
  StringBuffer name=new StringBuffer();
  name.append((char)c);
  if (c == '0') {
    return integerLiteral(name.toString());
  }
 else {
    while (true) {
      c=read();
      if (isDigit(c)) {
        name.append((char)c);
      }
 else       if (isLetter(c)) {
        return error();
      }
 else {
        unread(c);
        return integerLiteral(name.toString());
      }
    }
  }
}",0.9238210399032648
154384,"private Token lexIdentifier(int c) throws IOException {
  StringBuffer name=new StringBuffer();
  name.append((char)c);
  while (true) {
    c=read();
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' || (c >= '0' && c <= '9')) {
      name.append((char)c);
    }
 else {
      unread(c);
      return identifier(name.toString());
    }
  }
}","private Token lexIdentifier(int c) throws IOException {
  StringBuffer name=new StringBuffer();
  name.append((char)c);
  while (true) {
    c=read();
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' || (c >= '0' && c <= '9')) {
      name.append((char)c);
    }
 else {
      unread(c);
      if (Keyword._KEYWORDS.containsKey(name.toString())) {
        return keyword(name.toString());
      }
      return identifier(name.toString());
    }
  }
}",0.8231046931407943
154385,"public String toString(){
  return _value;
}","public String toString(){
  return ""String_Node_Str"" + _value;
}",0.8148148148148148
154386,"/** 
 * Constructor function. Parses and stores input.
 * @param input The String input into stdin that this class has to parse and store.
 */
public Command(String input){
  String[] bits=input.split(""String_Node_Str"");
  if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.LOAD_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length > 1) {
      for (int j=1; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.NEW_WITH_MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      this.type=CommandType.NEW_GAME;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.SAVE_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.UNDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.REDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    printHelp();
  }
 else {
    if (bits.length > 1) {
      for (int j=0; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      Move temp=parseBit(bits[0]);
      if (temp != null) {
        moves.add(temp);
        this.type=CommandType.MOVE;
      }
 else {
        this.type=CommandType.INVALID;
        return;
      }
    }
  }
}","/** 
 * Constructor function. Parses and stores input.
 * @param input The String input into stdin that this class has to parse and store.
 */
public Command(String input){
  String[] bits=input.split(""String_Node_Str"");
  if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.LOAD_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length > 1) {
      for (int j=1; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.NEW_WITH_MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      this.type=CommandType.NEW_GAME;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.SAVE_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.UNDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.REDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    printHelp();
    this.type=CommandType.HELP;
    return;
  }
 else {
    if (bits.length > 1) {
      for (int j=0; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      Move temp=parseBit(bits[0]);
      if (temp != null) {
        moves.add(temp);
        this.type=CommandType.MOVE;
      }
 else {
        this.type=CommandType.INVALID;
        return;
      }
    }
  }
}",0.9885237350026084
154387,"public boolean undo(){
  if (moves.size() > 0) {
    if (players.other(myTurn()).type().equals(""String_Node_Str"")) {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        redoMoves.add(moves.removeLast());
      }
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        redoMoves.add(moves.removeLast());
      }
    }
 else {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        redoMoves.add(moves.removeLast());
      }
    }
    display();
    System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
    return true;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}","public boolean undo(){
  if (moves.size() > 0) {
    if (players.other(myTurn()).type().equals(""String_Node_Str"")) {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        myTurn().wall++;
        redoMoves.add(moves.removeLast());
      }
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        myTurn().wall++;
        redoMoves.add(moves.removeLast());
      }
    }
 else {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        myTurn().wall++;
        redoMoves.add(moves.removeLast());
      }
    }
    display();
    System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
    return true;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}",0.9712753734201456
154388,"/** 
 * checks if there is a wall on the opposite side of a player's opponent
 * @param m the move to be made by a player
 * @param p the player making the move
 * @return true or false
 */
public boolean oppositeBlocked(Move m,Player p){
  Player other=players.other(p);
  if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() - 1 && !isNotBlocked(new Move(other.pawn().x(),other.pawn().y() + 1,MoveType.PAWN),other))   return true;
 else   if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() + 1 && !isNotBlocked(new Move(other.pawn().x(),other.pawn().y() - 1,MoveType.PAWN),other))   return true;
 else   if (p.pawn().x() == other.pawn().x() - 1 && p.pawn().y() == other.pawn().y() && !isNotBlocked(new Move(other.pawn().x() + 1,other.pawn().y(),MoveType.PAWN),other))   return true;
 else   if (p.pawn().x() == other.pawn().x() + 1 && p.pawn().y() == other.pawn().y() && !isNotBlocked(new Move(other.pawn().x() - 1,other.pawn().y(),MoveType.PAWN),other))   return true;
 else {
    return false;
  }
}","/** 
 * checks if there is a wall on the opposite side of a player's opponent
 * @param m the move to be made by a player
 * @param p the player making the move
 * @return true or false
 */
public boolean oppositeBlocked(Move m,Player p){
  Player other=players.other(p);
  if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() - 1 && (!isNotBlocked(new Move(other.pawn().x(),other.pawn().y() + 1,MoveType.PAWN),other) || other.pawn().y() == 9))   return true;
 else   if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() + 1 && (!isNotBlocked(new Move(other.pawn().x(),other.pawn().y() - 1,MoveType.PAWN),other) || other.pawn().y() == 1))   return true;
 else   if (p.pawn().x() == other.pawn().x() - 1 && p.pawn().y() == other.pawn().y() && (!isNotBlocked(new Move(other.pawn().x() + 1,other.pawn().y(),MoveType.PAWN),other) || other.pawn().x() == 8))   return true;
 else   if (p.pawn().x() == other.pawn().x() + 1 && p.pawn().y() == other.pawn().y() && (!isNotBlocked(new Move(other.pawn().x() - 1,other.pawn().y(),MoveType.PAWN),other) || other.pawn().y() == 0))   return true;
 else {
    return false;
  }
}",0.9508644222020018
154389,"/** 
 * Simply scan the stdin to get a line the user typed.
 * @return The String the user input in the command line.
 */
public static void run(){
  Scanner input=new Scanner(System.in);
  Two<Player> players=null;
  System.out.println(""String_Node_Str"");
  String line=input.nextLine().toLowerCase();
  Command command=new Command(line);
  while (command.type().equals(CommandType.INVALID) || command.type().equals(CommandType.MOVE) || command.type().equals(CommandType.SAVE_GAME)|| command.type().equals(CommandType.UNDO)|| command.type().equals(CommandType.REDO)) {
    if (command.type().equals(CommandType.MOVE)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.SAVE_GAME)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.UNDO)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.REDO)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    line=input.nextLine().toLowerCase();
    command=new Command(line);
  }
  players=getPlayers();
  if (command.type().equals(CommandType.NEW_GAME)) {
    newGame(players);
  }
 else   if (command.type().equals(CommandType.LOAD_GAME)) {
    loadGame(command.fileName(),players);
  }
 else   if (command.type().equals(CommandType.NEW_WITH_MOVES)) {
    newGameWithMoves(command.moves(),players);
  }
}","/** 
 * Simply scan the stdin to get a line the user typed.
 * @return The String the user input in the command line.
 */
public static void run(){
  Scanner input=new Scanner(System.in);
  Two<Player> players=null;
  System.out.println(""String_Node_Str"");
  String line=input.nextLine().toLowerCase();
  Command command=new Command(line);
  while (command.type().equals(CommandType.INVALID) || command.type().equals(CommandType.MOVE) || command.type().equals(CommandType.SAVE_GAME)|| command.type().equals(CommandType.UNDO)|| command.type().equals(CommandType.REDO)|| command.type().equals(CommandType.HELP)) {
    if (command.type().equals(CommandType.MOVE)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.SAVE_GAME)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.UNDO)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.REDO)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    line=input.nextLine().toLowerCase();
    command=new Command(line);
  }
  players=getPlayers();
  if (command.type().equals(CommandType.NEW_GAME)) {
    newGame(players);
  }
 else   if (command.type().equals(CommandType.LOAD_GAME)) {
    loadGame(command.fileName(),players);
  }
 else   if (command.type().equals(CommandType.NEW_WITH_MOVES)) {
    newGameWithMoves(command.moves(),players);
  }
}",0.98583951449764
154390,"/** 
 * Makes a naive move based on the current state of the game using a heuristic
 * @return
 */
private Move naiveMove(){
  ArrayList<Move> possibleMoves=findPossibleMoves(game);
  Move move=null;
  int myValue=game.shortestPath(game.myTurn()).size();
  int playerShortestPath=game.shortestPath(game.players().other(game.myTurn())).size();
  int highestValue=(int)Double.NEGATIVE_INFINITY;
  int index=0;
  Random random=new Random();
  if (myValue >= playerShortestPath - 1 && game.myTurn().wallsLeft() != 0 && game.moves.size() > random.nextInt(4)) {
    for (int i=0; i < possibleMoves.size(); i++) {
      int value=0;
      if (possibleMoves.get(i).direction() == MoveType.HORIZONTAL || possibleMoves.get(i).direction() == MoveType.VERTICAL) {
        Game tempGame=createTempGame(game.moves);
        tempGame.move(possibleMoves.get(i),tempGame.myTurn);
        int tempShortest=tempGame.shortestPath(tempGame.myTurn).size();
        int myTempShortest=tempGame.shortestPath(tempGame.players.other(tempGame.myTurn)).size();
        value=(tempGame.shortestPath(tempGame.myTurn).size()) - (myTempShortest - myValue) - wallDistance(possibleMoves.get(i));
        if (playerShortestPath == tempShortest) {
          if (myValue == myTempShortest) {
            value=value * 1 / 2 - 20;
            System.out.println(value);
          }
        }
        if (isAdjacent(possibleMoves.get(i))) {
          value++;
        }
        if (value > highestValue) {
          highestValue=value;
          index=i;
        }
      }
      move=possibleMoves.get(index);
    }
  }
 else {
    move=game.shortestPath(game.myTurn()).get(1);
    if (!game.isValid(move,game.myTurn())) {
      move=game.shortestPath(game.myTurn()).get(2);
      if (!game.isValid(move,game.myTurn())) {
        Game tempGame=createTempGame(game.moves);
        Game tempGameTwo=createTempGame(game.moves);
        Point p=game.myTurn().pawn();
        Move tempMove=new Move(p.x() + 1,p.y(),MoveType.PAWN);
        Move tempMoveTwo=new Move(p.x() - 1,p.y(),MoveType.PAWN);
        if (tempGame.isValid(tempMove,tempGame.myTurn())) {
          move=tempMove;
          if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
            tempGame.move(tempMove,game.myTurn());
            tempGameTwo.move(tempMoveTwo,game.myTurn());
            if (tempGame.shortestPath(tempGame.players().other(tempGame.myTurn())).size() < tempGameTwo.shortestPath(tempGameTwo.players().other(tempGameTwo.myTurn())).size()) {
              move=tempMove;
            }
 else {
              move=tempMoveTwo;
            }
          }
        }
 else         if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
          move=tempMoveTwo;
        }
      }
    }
  }
  return move;
}","/** 
 * Makes a naive move based on the current state of the game using a heuristic
 * @return
 */
private Move naiveMove(){
  ArrayList<Move> possibleMoves=findPossibleMoves(game);
  Move move=null;
  int myValue=game.shortestPath(game.myTurn()).size();
  int playerShortestPath=game.shortestPath(game.players().other(game.myTurn())).size();
  int highestValue=(int)Double.NEGATIVE_INFINITY;
  int index=0;
  Random random=new Random();
  if (myValue >= playerShortestPath - 1 && game.myTurn().wallsLeft() != 0 && game.moves.size() > random.nextInt(4)) {
    for (int i=0; i < possibleMoves.size(); i++) {
      int value=0;
      if (possibleMoves.get(i).direction() == MoveType.HORIZONTAL || possibleMoves.get(i).direction() == MoveType.VERTICAL) {
        Game tempGame=createTempGame(game.moves);
        tempGame.move(possibleMoves.get(i),tempGame.myTurn);
        int tempShortest=tempGame.shortestPath(tempGame.myTurn).size();
        int myTempShortest=tempGame.shortestPath(tempGame.players.other(tempGame.myTurn)).size();
        value=(tempGame.shortestPath(tempGame.myTurn).size()) - (myTempShortest - myValue) - wallDistance(possibleMoves.get(i));
        if (playerShortestPath == tempShortest) {
          if (myValue == myTempShortest) {
            value=value * 1 / 2 - 20;
          }
        }
        if (isAdjacent(possibleMoves.get(i))) {
          value++;
        }
        if (value > highestValue) {
          highestValue=value;
          index=i;
        }
      }
      move=possibleMoves.get(index);
    }
  }
 else {
    move=game.shortestPath(game.myTurn()).get(1);
    if (!game.isValid(move,game.myTurn())) {
      move=game.shortestPath(game.myTurn()).get(2);
      if (!game.isValid(move,game.myTurn())) {
        Game tempGame=createTempGame(game.moves);
        Game tempGameTwo=createTempGame(game.moves);
        Point p=game.myTurn().pawn();
        Move tempMove=new Move(p.x() + 1,p.y(),MoveType.PAWN);
        Move tempMoveTwo=new Move(p.x() - 1,p.y(),MoveType.PAWN);
        if (tempGame.isValid(tempMove,tempGame.myTurn())) {
          move=tempMove;
          if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
            tempGame.move(tempMove,game.myTurn());
            tempGameTwo.move(tempMoveTwo,game.myTurn());
            if (tempGame.shortestPath(tempGame.players().other(tempGame.myTurn())).size() < tempGameTwo.shortestPath(tempGameTwo.players().other(tempGameTwo.myTurn())).size()) {
              move=tempMove;
            }
 else {
              move=tempMoveTwo;
            }
          }
        }
 else         if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
          move=tempMoveTwo;
        }
      }
    }
  }
  return move;
}",0.9928558344019052
154391,"/** 
 * Checks if the state of the moves is a winning game state
 * @param moves the list of all moves made so far
 * @return boolean true if it is a winning state, false if not
 */
private boolean isGoalState(LinkedList<Move> moves){
  for (int i=0; i < 9; i++) {
    if ((moves.getLast().coord().x() == i && moves.getLast().coord().y() == 1) || (moves.getLast().coord().x() == i && moves.getLast().coord().y() == 9)) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if the state of the moves is a winning game state
 * @param moves the list of all moves made so far
 * @return boolean true if it is a winning state, false if not
 */
private boolean isGoalState(LinkedList<Move> moves){
  if (!moves.isEmpty()) {
    for (int i=0; i < 9; i++) {
      if ((moves.getLast().coord().x() == i && moves.getLast().coord().y() == 1) || (moves.getLast().coord().x() == i && moves.getLast().coord().y() == 9)) {
        return true;
      }
    }
  }
  return false;
}",0.9589322381930184
154392,"public boolean redo(){
  if (redoMoves.size() > 0) {
    move(redoMoves.removeLast(),myTurn());
    display();
    System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
    return true;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}","public boolean redo(){
  if (redoMoves.size() > 0) {
    if (players.other(myTurn()).type().equals(""String_Node_Str"")) {
      move(redoMoves.removeLast(),myTurn());
      move(redoMoves.removeLast(),myTurn());
      display();
      System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
      return true;
    }
 else {
      move(redoMoves.removeLast(),myTurn());
      display();
      System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
      return true;
    }
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}",0.5979381443298969
154393,"private int minValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Pair<Integer,Move> value=null;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    return random.nextInt(1000);
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=maxValue(tempGameTwo.moves,desiredDepth + 1,alphaMax,betaMin);
    betaMin=Math.min(value._1,betaMin);
    if (alphaMax >= betaMin) {
      return betaMin;
    }
  }
  return betaMin;
}","private int minValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Pair<Integer,Move> value=null;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    return random.nextInt(1000);
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=maxValue(tempGameTwo.moves,currentSearchDepth + 1,alphaMax,betaMin);
    betaMin=Math.min(value._1,betaMin);
    if (alphaMax >= betaMin) {
      return betaMin;
    }
  }
  return betaMin;
}",0.9857142857142858
154394,"private Pair<Integer,Move> maxValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Move bestMove=null;
  int value;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    ArrayList<Move> m=findPossibleMoves(game);
    return Pair.pair(random.nextInt(1000),m.get(random.nextInt(m.size())));
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  bestMove=moveList.get(0);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=minValue(tempGameTwo.moves,desiredDepth + 1,alphaMax,betaMin);
    if (value > alphaMax) {
      alphaMax=value;
      bestMove=moveList.get(i);
    }
    if (alphaMax >= betaMin) {
      return Pair.pair(alphaMax,bestMove);
    }
  }
  return Pair.pair(alphaMax,bestMove);
}","private Pair<Integer,Move> maxValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Move bestMove=null;
  int value;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    ArrayList<Move> m=findPossibleMoves(game);
    return Pair.pair(random.nextInt(1000),m.get(random.nextInt(m.size())));
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  bestMove=moveList.get(0);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=minValue(tempGameTwo.moves,currentSearchDepth + 1,alphaMax,betaMin);
    if (value > alphaMax) {
      alphaMax=value;
      bestMove=moveList.get(i);
    }
    if (alphaMax >= betaMin) {
      return Pair.pair(alphaMax,bestMove);
    }
  }
  return Pair.pair(alphaMax,bestMove);
}",0.9891891891891892
154395,"/** 
 * Constructor function. Parses and stores input.
 * @param input The String input into stdin that this class has to parse and store.
 */
public Command(String input){
  String[] bits=input.split(""String_Node_Str"");
  if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.LOAD_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length > 1) {
      for (int j=1; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.NEW_WITH_MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      this.type=CommandType.NEW_GAME;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.SAVE_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.UNDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.REDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    printHelp();
  }
 else {
    if (bits.length > 1) {
      for (int j=0; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      Move temp=parseBit(bits[0]);
      if (temp != null) {
        moves.add(temp);
        this.type=CommandType.MOVE;
      }
 else {
        this.type=CommandType.INVALID;
        return;
      }
    }
  }
}","/** 
 * Constructor function. Parses and stores input.
 * @param input The String input into stdin that this class has to parse and store.
 */
public Command(String input){
  String[] bits=input.split(""String_Node_Str"");
  if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.LOAD_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length > 1) {
      for (int j=1; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.NEW_WITH_MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      this.type=CommandType.NEW_GAME;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    if (bits.length == 2) {
      fileName=bits[1];
      this.type=CommandType.SAVE_GAME;
    }
 else {
      System.out.println(""String_Node_Str"");
      this.type=CommandType.INVALID;
    }
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.UNDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    this.type=CommandType.REDO;
  }
 else   if (bits[0].equals(""String_Node_Str"")) {
    printHelp();
    this.type=CommandType.HELP;
    return;
  }
 else {
    if (bits.length > 1) {
      for (int j=0; j < bits.length; j++) {
        Move temp=parseBit(bits[j]);
        if (temp != null) {
          moves.add(temp);
          this.type=CommandType.MOVES;
        }
 else {
          this.type=CommandType.INVALID;
          return;
        }
      }
    }
 else {
      Move temp=parseBit(bits[0]);
      if (temp != null) {
        moves.add(temp);
        this.type=CommandType.MOVE;
      }
 else {
        this.type=CommandType.INVALID;
        return;
      }
    }
  }
}",0.9885237350026084
154396,"public boolean undo(){
  if (moves.size() > 0) {
    if (players.other(myTurn()).type().equals(""String_Node_Str"")) {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        redoMoves.add(moves.removeLast());
      }
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        redoMoves.add(moves.removeLast());
      }
    }
 else {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        redoMoves.add(moves.removeLast());
      }
    }
    display();
    System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
    return true;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}","public boolean undo(){
  if (moves.size() > 0) {
    if (players.other(myTurn()).type().equals(""String_Node_Str"")) {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        myTurn().wall++;
        redoMoves.add(moves.removeLast());
      }
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        myTurn().wall++;
        redoMoves.add(moves.removeLast());
      }
    }
 else {
      changeTurn();
      if (moves.getLast().direction().equals(MoveType.PAWN)) {
        myTurn().positions.removeLast();
        myTurn().pawn=myTurn().positions.getLast();
        redoMoves.add(moves.removeLast());
      }
 else {
        walls.removeLast();
        myTurn().wall++;
        redoMoves.add(moves.removeLast());
      }
    }
    display();
    System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
    return true;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}",0.9712753734201456
154397,"/** 
 * checks if there is a wall on the opposite side of a player's opponent
 * @param m the move to be made by a player
 * @param p the player making the move
 * @return true or false
 */
public boolean oppositeBlocked(Move m,Player p){
  Player other=players.other(p);
  if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() - 1 && !isNotBlocked(new Move(other.pawn().x(),other.pawn().y() + 1,MoveType.PAWN),other))   return true;
 else   if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() + 1 && !isNotBlocked(new Move(other.pawn().x(),other.pawn().y() - 1,MoveType.PAWN),other))   return true;
 else   if (p.pawn().x() == other.pawn().x() - 1 && p.pawn().y() == other.pawn().y() && !isNotBlocked(new Move(other.pawn().x() + 1,other.pawn().y(),MoveType.PAWN),other))   return true;
 else   if (p.pawn().x() == other.pawn().x() + 1 && p.pawn().y() == other.pawn().y() && !isNotBlocked(new Move(other.pawn().x() - 1,other.pawn().y(),MoveType.PAWN),other))   return true;
 else {
    return false;
  }
}","/** 
 * checks if there is a wall on the opposite side of a player's opponent
 * @param m the move to be made by a player
 * @param p the player making the move
 * @return true or false
 */
public boolean oppositeBlocked(Move m,Player p){
  Player other=players.other(p);
  if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() - 1 && (!isNotBlocked(new Move(other.pawn().x(),other.pawn().y() + 1,MoveType.PAWN),other) || other.pawn().y() == 9))   return true;
 else   if (p.pawn().x() == other.pawn().x() && p.pawn().y() == other.pawn().y() + 1 && (!isNotBlocked(new Move(other.pawn().x(),other.pawn().y() - 1,MoveType.PAWN),other) || other.pawn().y() == 1))   return true;
 else   if (p.pawn().x() == other.pawn().x() - 1 && p.pawn().y() == other.pawn().y() && (!isNotBlocked(new Move(other.pawn().x() + 1,other.pawn().y(),MoveType.PAWN),other) || other.pawn().x() == 8))   return true;
 else   if (p.pawn().x() == other.pawn().x() + 1 && p.pawn().y() == other.pawn().y() && (!isNotBlocked(new Move(other.pawn().x() - 1,other.pawn().y(),MoveType.PAWN),other) || other.pawn().y() == 0))   return true;
 else {
    return false;
  }
}",0.9508644222020018
154398,"/** 
 * Simply scan the stdin to get a line the user typed.
 * @return The String the user input in the command line.
 */
public static void run(){
  Scanner input=new Scanner(System.in);
  Two<Player> players=null;
  System.out.println(""String_Node_Str"");
  String line=input.nextLine().toLowerCase();
  Command command=new Command(line);
  while (command.type().equals(CommandType.INVALID) || command.type().equals(CommandType.MOVE) || command.type().equals(CommandType.SAVE_GAME)|| command.type().equals(CommandType.UNDO)|| command.type().equals(CommandType.REDO)) {
    if (command.type().equals(CommandType.MOVE)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.SAVE_GAME)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.UNDO)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.REDO)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    line=input.nextLine().toLowerCase();
    command=new Command(line);
  }
  players=getPlayers();
  if (command.type().equals(CommandType.NEW_GAME)) {
    newGame(players);
  }
 else   if (command.type().equals(CommandType.LOAD_GAME)) {
    loadGame(command.fileName(),players);
  }
 else   if (command.type().equals(CommandType.NEW_WITH_MOVES)) {
    newGameWithMoves(command.moves(),players);
  }
}","/** 
 * Simply scan the stdin to get a line the user typed.
 * @return The String the user input in the command line.
 */
public static void run(){
  Scanner input=new Scanner(System.in);
  Two<Player> players=null;
  System.out.println(""String_Node_Str"");
  String line=input.nextLine().toLowerCase();
  Command command=new Command(line);
  while (command.type().equals(CommandType.INVALID) || command.type().equals(CommandType.MOVE) || command.type().equals(CommandType.SAVE_GAME)|| command.type().equals(CommandType.UNDO)|| command.type().equals(CommandType.REDO)|| command.type().equals(CommandType.HELP)) {
    if (command.type().equals(CommandType.MOVE)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.SAVE_GAME)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.UNDO)) {
      System.out.println(""String_Node_Str"");
    }
 else     if (command.type().equals(CommandType.REDO)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    line=input.nextLine().toLowerCase();
    command=new Command(line);
  }
  players=getPlayers();
  if (command.type().equals(CommandType.NEW_GAME)) {
    newGame(players);
  }
 else   if (command.type().equals(CommandType.LOAD_GAME)) {
    loadGame(command.fileName(),players);
  }
 else   if (command.type().equals(CommandType.NEW_WITH_MOVES)) {
    newGameWithMoves(command.moves(),players);
  }
}",0.98583951449764
154399,"/** 
 * Makes a naive move based on the current state of the game using a heuristic
 * @return
 */
private Move naiveMove(){
  ArrayList<Move> possibleMoves=findPossibleMoves(game);
  Move move=null;
  int myValue=game.shortestPath(game.myTurn()).size();
  int playerShortestPath=game.shortestPath(game.players().other(game.myTurn())).size();
  int highestValue=(int)Double.NEGATIVE_INFINITY;
  int index=0;
  Random random=new Random();
  if (myValue >= playerShortestPath - 1 && game.myTurn().wallsLeft() != 0 && game.moves.size() > random.nextInt(4)) {
    for (int i=0; i < possibleMoves.size(); i++) {
      int value=0;
      if (possibleMoves.get(i).direction() == MoveType.HORIZONTAL || possibleMoves.get(i).direction() == MoveType.VERTICAL) {
        Game tempGame=createTempGame(game.moves);
        tempGame.move(possibleMoves.get(i),tempGame.myTurn);
        int tempShortest=tempGame.shortestPath(tempGame.myTurn).size();
        int myTempShortest=tempGame.shortestPath(tempGame.players.other(tempGame.myTurn)).size();
        value=(tempGame.shortestPath(tempGame.myTurn).size()) - (myTempShortest - myValue) - wallDistance(possibleMoves.get(i));
        if (playerShortestPath == tempShortest) {
          if (myValue == myTempShortest) {
            value=value * 1 / 2 - 20;
            System.out.println(value);
          }
        }
        if (isAdjacent(possibleMoves.get(i))) {
          value++;
        }
        if (value > highestValue) {
          highestValue=value;
          index=i;
        }
      }
      move=possibleMoves.get(index);
    }
  }
 else {
    move=game.shortestPath(game.myTurn()).get(1);
    if (!game.isValid(move,game.myTurn())) {
      move=game.shortestPath(game.myTurn()).get(2);
      if (!game.isValid(move,game.myTurn())) {
        Game tempGame=createTempGame(game.moves);
        Game tempGameTwo=createTempGame(game.moves);
        Point p=game.myTurn().pawn();
        Move tempMove=new Move(p.x() + 1,p.y(),MoveType.PAWN);
        Move tempMoveTwo=new Move(p.x() - 1,p.y(),MoveType.PAWN);
        if (tempGame.isValid(tempMove,tempGame.myTurn())) {
          move=tempMove;
          if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
            tempGame.move(tempMove,game.myTurn());
            tempGameTwo.move(tempMoveTwo,game.myTurn());
            if (tempGame.shortestPath(tempGame.players().other(tempGame.myTurn())).size() < tempGameTwo.shortestPath(tempGameTwo.players().other(tempGameTwo.myTurn())).size()) {
              move=tempMove;
            }
 else {
              move=tempMoveTwo;
            }
          }
        }
 else         if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
          move=tempMoveTwo;
        }
      }
    }
  }
  return move;
}","/** 
 * Makes a naive move based on the current state of the game using a heuristic
 * @return
 */
private Move naiveMove(){
  ArrayList<Move> possibleMoves=findPossibleMoves(game);
  Move move=null;
  int myValue=game.shortestPath(game.myTurn()).size();
  int playerShortestPath=game.shortestPath(game.players().other(game.myTurn())).size();
  int highestValue=(int)Double.NEGATIVE_INFINITY;
  int index=0;
  Random random=new Random();
  if (myValue >= playerShortestPath - 1 && game.myTurn().wallsLeft() != 0 && game.moves.size() > random.nextInt(4)) {
    for (int i=0; i < possibleMoves.size(); i++) {
      int value=0;
      if (possibleMoves.get(i).direction() == MoveType.HORIZONTAL || possibleMoves.get(i).direction() == MoveType.VERTICAL) {
        Game tempGame=createTempGame(game.moves);
        tempGame.move(possibleMoves.get(i),tempGame.myTurn);
        int tempShortest=tempGame.shortestPath(tempGame.myTurn).size();
        int myTempShortest=tempGame.shortestPath(tempGame.players.other(tempGame.myTurn)).size();
        value=(tempGame.shortestPath(tempGame.myTurn).size()) - (myTempShortest - myValue) - wallDistance(possibleMoves.get(i));
        if (playerShortestPath == tempShortest) {
          if (myValue == myTempShortest) {
            value=value * 1 / 2 - 20;
          }
        }
        if (isAdjacent(possibleMoves.get(i))) {
          value++;
        }
        if (value > highestValue) {
          highestValue=value;
          index=i;
        }
      }
      move=possibleMoves.get(index);
    }
  }
 else {
    move=game.shortestPath(game.myTurn()).get(1);
    if (!game.isValid(move,game.myTurn())) {
      move=game.shortestPath(game.myTurn()).get(2);
      if (!game.isValid(move,game.myTurn())) {
        Game tempGame=createTempGame(game.moves);
        Game tempGameTwo=createTempGame(game.moves);
        Point p=game.myTurn().pawn();
        Move tempMove=new Move(p.x() + 1,p.y(),MoveType.PAWN);
        Move tempMoveTwo=new Move(p.x() - 1,p.y(),MoveType.PAWN);
        if (tempGame.isValid(tempMove,tempGame.myTurn())) {
          move=tempMove;
          if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
            tempGame.move(tempMove,game.myTurn());
            tempGameTwo.move(tempMoveTwo,game.myTurn());
            if (tempGame.shortestPath(tempGame.players().other(tempGame.myTurn())).size() < tempGameTwo.shortestPath(tempGameTwo.players().other(tempGameTwo.myTurn())).size()) {
              move=tempMove;
            }
 else {
              move=tempMoveTwo;
            }
          }
        }
 else         if (tempGame.isValid(tempMoveTwo,tempGame.myTurn())) {
          move=tempMoveTwo;
        }
      }
    }
  }
  return move;
}",0.9928558344019052
154400,"/** 
 * Checks if the state of the moves is a winning game state
 * @param moves the list of all moves made so far
 * @return boolean true if it is a winning state, false if not
 */
private boolean isGoalState(LinkedList<Move> moves){
  for (int i=0; i < 9; i++) {
    if ((moves.getLast().coord().x() == i && moves.getLast().coord().y() == 1) || (moves.getLast().coord().x() == i && moves.getLast().coord().y() == 9)) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if the state of the moves is a winning game state
 * @param moves the list of all moves made so far
 * @return boolean true if it is a winning state, false if not
 */
private boolean isGoalState(LinkedList<Move> moves){
  if (!moves.isEmpty()) {
    for (int i=0; i < 9; i++) {
      if ((moves.getLast().coord().x() == i && moves.getLast().coord().y() == 1) || (moves.getLast().coord().x() == i && moves.getLast().coord().y() == 9)) {
        return true;
      }
    }
  }
  return false;
}",0.9589322381930184
154401,"public boolean redo(){
  if (redoMoves.size() > 0) {
    move(redoMoves.removeLast(),myTurn());
    display();
    System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
    return true;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}","public boolean redo(){
  if (redoMoves.size() > 0) {
    if (players.other(myTurn()).type().equals(""String_Node_Str"")) {
      move(redoMoves.removeLast(),myTurn());
      move(redoMoves.removeLast(),myTurn());
      display();
      System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
      return true;
    }
 else {
      move(redoMoves.removeLast(),myTurn());
      display();
      System.out.println(""String_Node_Str"" + myTurn().name + ""String_Node_Str"");
      return true;
    }
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}",0.5979381443298969
154402,"private int minValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Pair<Integer,Move> value=null;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    return random.nextInt(1000);
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=maxValue(tempGameTwo.moves,desiredDepth + 1,alphaMax,betaMin);
    betaMin=Math.min(value._1,betaMin);
    if (alphaMax >= betaMin) {
      return betaMin;
    }
  }
  return betaMin;
}","private int minValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Pair<Integer,Move> value=null;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    return random.nextInt(1000);
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=maxValue(tempGameTwo.moves,currentSearchDepth + 1,alphaMax,betaMin);
    betaMin=Math.min(value._1,betaMin);
    if (alphaMax >= betaMin) {
      return betaMin;
    }
  }
  return betaMin;
}",0.9857142857142858
154403,"private Pair<Integer,Move> maxValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Move bestMove=null;
  int value;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    ArrayList<Move> m=findPossibleMoves(game);
    return Pair.pair(random.nextInt(1000),m.get(random.nextInt(m.size())));
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  bestMove=moveList.get(0);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=minValue(tempGameTwo.moves,desiredDepth + 1,alphaMax,betaMin);
    if (value > alphaMax) {
      alphaMax=value;
      bestMove=moveList.get(i);
    }
    if (alphaMax >= betaMin) {
      return Pair.pair(alphaMax,bestMove);
    }
  }
  return Pair.pair(alphaMax,bestMove);
}","private Pair<Integer,Move> maxValue(LinkedList<Move> moves,int currentSearchDepth,int alphaMax,int betaMin){
  Move bestMove=null;
  int value;
  if (currentSearchDepth == desiredDepth || isGoalState(moves)) {
    Random random=new Random();
    ArrayList<Move> m=findPossibleMoves(game);
    return Pair.pair(random.nextInt(1000),m.get(random.nextInt(m.size())));
  }
  Game tempGame=createTempGame(moves);
  ArrayList<Move> moveList=findPossibleMoves(tempGame);
  bestMove=moveList.get(0);
  for (int i=0; i < moveList.size(); i++) {
    Game tempGameTwo=createTempGame(moves);
    tempGameTwo.move(moveList.get(i),tempGame.myTurn());
    value=minValue(tempGameTwo.moves,currentSearchDepth + 1,alphaMax,betaMin);
    if (value > alphaMax) {
      alphaMax=value;
      bestMove=moveList.get(i);
    }
    if (alphaMax >= betaMin) {
      return Pair.pair(alphaMax,bestMove);
    }
  }
  return Pair.pair(alphaMax,bestMove);
}",0.9891891891891892
154404,"@Override public String getElementAsString(){
  StringBuilder strBuilder=new StringBuilder();
  strBuilder.append(""String_Node_Str"" + this.name);
  for (  Map.Entry<String,String> entry : tagAttributes.entrySet()) {
    strBuilder.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
  }
  strBuilder.append(""String_Node_Str"");
  for (  LinkedList<Item> list : items.values()) {
    for (    Item item : list) {
      strBuilder.append(item.getElementAsString());
    }
  }
  if (this.content != null) {
    strBuilder.append(this.content);
  }
  strBuilder.append(""String_Node_Str"" + this.name + ""String_Node_Str"");
  return strBuilder.toString();
}","@Override public String getElementAsString(){
  StringBuilder strBuilder=new StringBuilder();
  strBuilder.append(""String_Node_Str"" + this.name);
  for (  Map.Entry<String,String> entry : tagAttributes.entrySet()) {
    strBuilder.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
  }
  strBuilder.append(""String_Node_Str"");
  for (  LinkedList<Item> list : items.values()) {
    for (    Item item : list) {
      strBuilder.append(item.getElementAsString());
    }
  }
  if (this.content != null) {
    if (this.contentCDATA) {
      strBuilder.append(""String_Node_Str"").append(this.content).append(""String_Node_Str"");
    }
 else {
      strBuilder.append(this.content);
    }
  }
  strBuilder.append(""String_Node_Str"" + this.name + ""String_Node_Str"");
  return strBuilder.toString();
}",0.8855656697009102
154405,"public Item parse(String xml) throws ParserException {
  try {
    if (xml == null)     return null;
    InputStream is=new ByteArrayInputStream(xml.getBytes(""String_Node_Str""));
    parser=parserFactory.newSAXParser();
    parser.parse(is,new ResponseParserHandler());
  }
 catch (  Exception e) {
    throw new ParserException(e);
  }
  return result;
}","public Item parse(String xml) throws ParserException {
  try {
    if (xml == null)     return null;
    InputStream is=new ByteArrayInputStream(xml.getBytes(""String_Node_Str""));
    ResponseParserHandler handler=new ResponseParserHandler();
    org.apache.xerces.parsers.SAXParser saxParser=new org.apache.xerces.parsers.SAXParser();
    saxParser.setProperty(LEXICAL_HANDLER,handler);
    saxParser.setContentHandler(handler);
    saxParser.parse(new InputSource(is));
  }
 catch (  Exception e) {
    throw new ParserException(e);
  }
  return result;
}",0.6432491767288694
154406,"/** 
 * @param ch     - The characters.
 * @param start  - The start position in the character array.
 * @param length - The number of characters to use from the character array.
 */
@Override public void characters(char[] ch,int start,int lenght) throws SAXException {
  String trimmed=new String(ch,start,lenght).trim();
  if (!trimmed.isEmpty() && !tagStack.empty()) {
    tagStack.peek().setContent(trimmed);
  }
}","/** 
 * @param ch     - The characters.
 * @param start  - The start position in the character array.
 * @param length - The number of characters to use from the character array.
 */
@Override public void characters(char[] ch,int start,int lenght) throws SAXException {
  String trimmed=new String(ch,start,lenght).trim();
  if (!trimmed.isEmpty() && !tagStack.empty()) {
    tagStack.peek().appendContent(trimmed);
  }
}",0.9892729439809296
154407,"/** 
 * @param wsdl the path or URL to the WSDL document
 * @throws XmlException
 * @throws IOException
 * @throws FrameworkException
 * @throws WSDLException
 */
public WSClient(String wsdl) throws XmlException, IOException, FrameworkException, WSDLException {
  WsdlProject project;
  try {
    project=new WsdlProject();
  }
 catch (  SoapUIException e) {
    throw new FrameworkException(e);
  }
  try {
    iface=WsdlInterfaceFactory.importWsdl(project,wsdl,true)[0];
  }
 catch (  SoapUIException e) {
    throw new WSDLException(e);
  }
  parseWsdlOperations();
  this.wsdl=wsdl;
}","/** 
 * @param wsdl the path or URL to the WSDL document
 * @throws XmlException
 * @throws IOException
 * @throws FrameworkException
 * @throws WSDLException
 */
public WSClient(String wsdl) throws XmlException, IOException, FrameworkException, WSDLException {
  if (!verifyDomainAvailability(wsdl))   throw new WSDLException(""String_Node_Str"" + wsdl + ""String_Node_Str"");
  WsdlProject project;
  try {
    project=new WsdlProject();
  }
 catch (  SoapUIException e) {
    throw new FrameworkException(e);
  }
  try {
    iface=WsdlInterfaceFactory.importWsdl(project,wsdl,true)[0];
  }
 catch (  SoapUIException e) {
    throw new WSDLException(e);
  }
  parseWsdlOperations();
  this.wsdl=wsdl;
}",0.9130434782608696
154408,"public FrameworkException(Exception originalException){
  super(originalException);
  this.originalException=originalException;
}","public FrameworkException(String message){
  super(message);
}",0.5130890052356021
154409,"public WSDLException(Exception originalException){
  super(originalException);
}","public WSDLException(String message){
  super(message);
}",0.6423357664233577
154410,"@Test public void shouldAddAndDeleteAtBook(){
  Map<String,String> parameters=new HashMap<String,String>();
  parameters.put(""String_Node_Str"",""String_Node_Str"");
  parameters.put(""String_Node_Str"",""String_Node_Str"");
  String id=client.post(""String_Node_Str"",parameters);
  String retrievedBook=client.get(""String_Node_Str"" + id);
  String expectedBook=""String_Node_Str"";
  assertEquals(expectedBook,retrievedBook);
  String deletedBook=client.delete(""String_Node_Str"" + id);
  assertEquals(deletedBook,expectedBook);
  assertEquals(""String_Node_Str"",client.get(""String_Node_Str"" + id));
}","@Test public void shouldAddAndDeleteAtBook(){
  RSClient client=new RSClient(""String_Node_Str"",""String_Node_Str"",53111);
  Map<String,String> parameters=new HashMap<String,String>();
  parameters.put(""String_Node_Str"",""String_Node_Str"");
  parameters.put(""String_Node_Str"",""String_Node_Str"");
  String id=client.post(""String_Node_Str"",parameters);
  String retrievedBook=client.get(""String_Node_Str"" + id);
  String expectedBook=""String_Node_Str"";
  assertEquals(expectedBook,retrievedBook);
  String deletedBook=client.delete(""String_Node_Str"" + id);
  assertEquals(deletedBook,expectedBook);
  assertEquals(""String_Node_Str"",client.get(""String_Node_Str"" + id));
}",0.9402390438247012
154411,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((content == null) ? 0 : content.hashCode());
  result=prime * result + ((items == null) ? 0 : items.hashCode());
  result=prime * result + ((name == null) ? 0 : name.hashCode());
  result=prime * result + ((tagParameters == null) ? 0 : tagParameters.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((content == null) ? 0 : content.hashCode());
  result=prime * result + ((items == null) ? 0 : items.hashCode());
  result=prime * result + ((name == null) ? 0 : name.hashCode());
  result=prime * result + ((tagAttributes == null) ? 0 : tagAttributes.hashCode());
  return result;
}",0.9525065963060686
154412,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  ResponseItem other=(ResponseItem)obj;
  if (content == null) {
    if (other.content != null)     return false;
  }
 else   if (!content.equals(other.content))   return false;
  if (items == null) {
    if (other.items != null)     return false;
  }
 else   if (!items.equals(other.items))   return false;
  if (name == null) {
    if (other.name != null)     return false;
  }
 else   if (!name.equals(other.name))   return false;
  if (tagParameters == null) {
    if (other.tagParameters != null)     return false;
  }
 else   if (!tagParameters.equals(other.tagParameters))   return false;
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  ResponseItem other=(ResponseItem)obj;
  if (content == null) {
    if (other.content != null)     return false;
  }
 else   if (!content.equals(other.content))   return false;
  if (items == null) {
    if (other.items != null)     return false;
  }
 else   if (!items.equals(other.items))   return false;
  if (name == null) {
    if (other.name != null)     return false;
  }
 else   if (!name.equals(other.name))   return false;
  if (tagAttributes == null) {
    if (other.tagAttributes != null)     return false;
  }
 else   if (!tagAttributes.equals(other.tagAttributes))   return false;
  return true;
}",0.9537275064267352
154413,"@Override public String toString(){
  return ""String_Node_Str"" + content + ""String_Node_Str""+ name+ ""String_Node_Str""+ tagParameters+ ""String_Node_Str""+ items+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + content + ""String_Node_Str""+ name+ ""String_Node_Str""+ tagAttributes+ ""String_Node_Str""+ items+ ""String_Node_Str"";
}",0.9666666666666668
154414,"public ResponseItem(String tagName){
  this.name=tagName;
  items=new HashMap<String,LinkedList<ResponseItem>>();
  this.tagParameters=new HashMap<String,String>();
}","public ResponseItem(String tagName){
  this.name=tagName;
  items=new HashMap<String,LinkedList<ResponseItem>>();
  this.tagAttributes=new HashMap<String,String>();
}",0.963855421686747
154415,"/** 
 * @param uri       - The Namespace URI.
 * @param localName - The local name (without prefix).
 * @param qName     - The qualified name (with prefix).
 */
@Override public void endElement(String uri,String localName,String qName) throws SAXException {
  String name=qName.split(""String_Node_Str"")[1];
  if (processing) {
    if (name.equals(opName)) {
      processing=false;
    }
 else {
      ResponseItem poped=tagStack.pop();
      if (!tagStack.empty()) {
        ResponseItem father=tagStack.peek();
        father.addItem(poped);
      }
 else {
        result=poped;
      }
    }
  }
}","/** 
 * @param uri       - The Namespace URI.
 * @param localName - The local name (without prefix).
 * @param qName     - The qualified name (with prefix).
 */
@Override public void endElement(String uri,String localName,String qName) throws SAXException {
  String name=qName.split(""String_Node_Str"")[1];
  if (processing) {
    if (name.equals(opName)) {
      processing=false;
    }
 else {
      ResponseItem poped=tagStack.pop();
      if (!tagStack.empty()) {
        ResponseItem father=tagStack.peek();
        father.addChild(poped);
      }
 else {
        result=poped;
      }
    }
  }
}",0.9925187032418952
154416,"@Test public void shouldAddAnItemWithParameters(){
  HashMap<String,String> parameters=new HashMap<String,String>();
  parameters.put(""String_Node_Str"",""String_Node_Str"");
  ResponseItem childItem=new ResponseItem(""String_Node_Str"",parameters);
  assertEquals(""String_Node_Str"",childItem.getTagParameters().get(""String_Node_Str""));
}","@Test public void shouldAddAnItemWithParameters(){
  HashMap<String,String> parameters=new HashMap<String,String>();
  parameters.put(""String_Node_Str"",""String_Node_Str"");
  ResponseItem childItem=new ResponseItem(""String_Node_Str"",parameters);
  assertEquals(""String_Node_Str"",childItem.getTagAttributes().get(""String_Node_Str""));
}",0.972972972972973
154417,"@Test public void shouldAddAnSimpleItem() throws NoSuchFieldException {
  ResponseItem childItem=new ResponseItem(""String_Node_Str"");
  childItem.setContent(""String_Node_Str"");
  item.addItem(childItem);
  assertEquals(""String_Node_Str"",item.getAttr(""String_Node_Str"").getContent());
}","@Test public void shouldAddAnSimpleItem() throws NoSuchFieldException {
  ResponseItem childItem=new ResponseItem(""String_Node_Str"");
  childItem.setContent(""String_Node_Str"");
  item.addChild(childItem);
  assertEquals(""String_Node_Str"",item.getChild(""String_Node_Str"").getContent());
}",0.9685314685314684
154418,"@Test(expected=NoSuchFieldException.class) public void shouldThrowsAnExceptionWhenTheElementNotExist() throws NoSuchFieldException {
  item.getAttr(""String_Node_Str"");
}","@Test(expected=NoSuchFieldException.class) public void shouldThrowsAnExceptionWhenTheElementNotExist() throws NoSuchFieldException {
  item.getChild(""String_Node_Str"");
}",0.9734513274336284
154419,"@Test public void shouldAddAComplexItem() throws NoSuchFieldException {
  ResponseItem coAuthorItem=new ResponseItem(""String_Node_Str"");
  ResponseItem nameItem=new ResponseItem(""String_Node_Str"");
  nameItem.setContent(""String_Node_Str"");
  coAuthorItem.addItem(nameItem);
  item.addItem(coAuthorItem);
  assertEquals(""String_Node_Str"",item.getAttr(""String_Node_Str"").getAttr(""String_Node_Str"").getContent());
}","@Test public void shouldAddAComplexItem() throws NoSuchFieldException {
  ResponseItem coAuthorItem=new ResponseItem(""String_Node_Str"");
  ResponseItem nameItem=new ResponseItem(""String_Node_Str"");
  nameItem.setContent(""String_Node_Str"");
  coAuthorItem.addChild(nameItem);
  item.addChild(coAuthorItem);
  assertEquals(""String_Node_Str"",item.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getContent());
}",0.8478260869565217
154420,"@Test public void shouldAddAComplexWithTwoSimpleItems() throws NoSuchFieldException {
  ResponseItem coAuthorItem=new ResponseItem(""String_Node_Str"");
  ResponseItem nameItemA=new ResponseItem(""String_Node_Str"");
  nameItemA.setContent(""String_Node_Str"");
  ResponseItem nameItemB=new ResponseItem(""String_Node_Str"");
  nameItemB.setContent(""String_Node_Str"");
  coAuthorItem.addItem(nameItemA);
  coAuthorItem.addItem(nameItemB);
  item.addItem(coAuthorItem);
  List<ResponseItem> coAuthors=item.getAttr(""String_Node_Str"").getAttrAsList(""String_Node_Str"");
  assertEquals(""String_Node_Str"",coAuthors.get(0).getContent());
  assertEquals(""String_Node_Str"",coAuthors.get(1).getContent());
}","@Test public void shouldAddAComplexWithTwoSimpleItems() throws NoSuchFieldException {
  ResponseItem coAuthorItem=new ResponseItem(""String_Node_Str"");
  ResponseItem nameItemA=new ResponseItem(""String_Node_Str"");
  nameItemA.setContent(""String_Node_Str"");
  ResponseItem nameItemB=new ResponseItem(""String_Node_Str"");
  nameItemB.setContent(""String_Node_Str"");
  coAuthorItem.addChild(nameItemA);
  coAuthorItem.addChild(nameItemB);
  item.addChild(coAuthorItem);
  List<ResponseItem> coAuthors=item.getChild(""String_Node_Str"").getChildAsList(""String_Node_Str"");
  assertEquals(""String_Node_Str"",coAuthors.get(0).getContent());
  assertEquals(""String_Node_Str"",coAuthors.get(1).getContent());
}",0.8893709327548807
154421,"@Test public void shouldAddTwoSimpleItemWithTheSameName() throws NoSuchFieldException {
  ResponseItem childItemA=new ResponseItem(""String_Node_Str"");
  childItemA.setContent(""String_Node_Str"");
  item.addItem(childItemA);
  ResponseItem childItemB=new ResponseItem(""String_Node_Str"");
  childItemB.setContent(""String_Node_Str"");
  item.addItem(childItemB);
  List<ResponseItem> children=item.getAttrAsList(""String_Node_Str"");
  assertEquals(""String_Node_Str"",children.get(0).getContent());
  assertEquals(""String_Node_Str"",children.get(1).getContent());
}","@Test public void shouldAddTwoSimpleItemWithTheSameName() throws NoSuchFieldException {
  ResponseItem childItemA=new ResponseItem(""String_Node_Str"");
  childItemA.setContent(""String_Node_Str"");
  item.addChild(childItemA);
  ResponseItem childItemB=new ResponseItem(""String_Node_Str"");
  childItemB.setContent(""String_Node_Str"");
  item.addChild(childItemB);
  List<ResponseItem> children=item.getChildAsList(""String_Node_Str"");
  assertEquals(""String_Node_Str"",children.get(0).getContent());
  assertEquals(""String_Node_Str"",children.get(1).getContent());
}",0.9757847533632288
154422,"@Test public void shouldGetAListWithOneElement() throws NoSuchFieldException {
  ResponseItem childItem=new ResponseItem(""String_Node_Str"");
  childItem.setContent(""String_Node_Str"");
  item.addItem(childItem);
  assertEquals(1,item.getAttrAsList(""String_Node_Str"").size());
  assertEquals(""String_Node_Str"",item.getAttr(""String_Node_Str"").getContent());
}","@Test public void shouldGetAListWithOneElement() throws NoSuchFieldException {
  ResponseItem childItem=new ResponseItem(""String_Node_Str"");
  childItem.setContent(""String_Node_Str"");
  item.addChild(childItem);
  assertEquals(1,item.getChildAsList(""String_Node_Str"").size());
  assertEquals(""String_Node_Str"",item.getChild(""String_Node_Str"").getContent());
}",0.9622377622377624
154423,"@Test public void shouldAddAComplexItemAnHaveContent() throws NoSuchFieldException {
  ResponseItem coAuthorItem=new ResponseItem(""String_Node_Str"");
  ResponseItem nameItem=new ResponseItem(""String_Node_Str"");
  nameItem.setContent(""String_Node_Str"");
  coAuthorItem.addItem(nameItem);
  item.addItem(coAuthorItem);
  item.setContent(""String_Node_Str"");
  assertEquals(""String_Node_Str"",item.getAttr(""String_Node_Str"").getAttr(""String_Node_Str"").getContent());
  assertEquals((Integer)1935,item.getContentAsInt());
}","@Test public void shouldAddAComplexItemAnHaveContent() throws NoSuchFieldException {
  ResponseItem coAuthorItem=new ResponseItem(""String_Node_Str"");
  ResponseItem nameItem=new ResponseItem(""String_Node_Str"");
  nameItem.setContent(""String_Node_Str"");
  coAuthorItem.addChild(nameItem);
  item.addChild(coAuthorItem);
  item.setContent(""String_Node_Str"");
  assertEquals(""String_Node_Str"",item.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getContent());
  assertEquals((Integer)1935,item.getContentAsInt());
}",0.8786127167630058
154424,"@Test public void shouldParseAnItemWithParameters() throws ParserConfigurationException, SAXException, NoSuchFieldException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem item=parser.parse(sampleXml);
  ResponseItem actual=item.getAttr(""String_Node_Str"");
  assertEquals(""String_Node_Str"",actual.getTagParameters().get(""String_Node_Str""));
}","@Test public void shouldParseAnItemWithParameters() throws ParserConfigurationException, SAXException, NoSuchFieldException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem item=parser.parse(sampleXml);
  ResponseItem actual=item.getChild(""String_Node_Str"");
  assertEquals(""String_Node_Str"",actual.getTagAttributes().get(""String_Node_Str""));
}",0.9770212765957448
154425,"@Test public void shouldParseASimpleXmlWithLineBreaks() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem child=new ResponseItem(""String_Node_Str"");
  child.setContent(""String_Node_Str"");
  expected.addItem(child);
  assertEquals(expected,actual);
}","@Test public void shouldParseASimpleXmlWithLineBreaks() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem child=new ResponseItem(""String_Node_Str"");
  child.setContent(""String_Node_Str"");
  expected.addChild(child);
  assertEquals(expected,actual);
}",0.9930822444273636
154426,"@Test public void shouldPaseComplexTypeListWithEmptySpaces() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem item1=new ResponseItem(""String_Node_Str"");
  ResponseItem childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item1.addItem(childA);
  ResponseItem childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item1.addItem(childB);
  ResponseItem childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item1.addItem(childC);
  ResponseItem childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item1.addItem(childD);
  expected.addItem(item1);
  ResponseItem item2=new ResponseItem(""String_Node_Str"");
  childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item2.addItem(childA);
  childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item2.addItem(childB);
  childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item2.addItem(childC);
  childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item2.addItem(childD);
  expected.addItem(item2);
  ResponseItem item3=new ResponseItem(""String_Node_Str"");
  childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item3.addItem(childA);
  childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item3.addItem(childB);
  childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item3.addItem(childC);
  childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item3.addItem(childD);
  expected.addItem(item3);
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  assertEquals(expected,actual);
}","@Test public void shouldPaseComplexTypeListWithEmptySpaces() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem item1=new ResponseItem(""String_Node_Str"");
  ResponseItem childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item1.addChild(childA);
  ResponseItem childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item1.addChild(childB);
  ResponseItem childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item1.addChild(childC);
  ResponseItem childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item1.addChild(childD);
  expected.addChild(item1);
  ResponseItem item2=new ResponseItem(""String_Node_Str"");
  childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item2.addChild(childA);
  childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item2.addChild(childB);
  childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item2.addChild(childC);
  childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item2.addChild(childD);
  expected.addChild(item2);
  ResponseItem item3=new ResponseItem(""String_Node_Str"");
  childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item3.addChild(childA);
  childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item3.addChild(childB);
  childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item3.addChild(childC);
  childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item3.addChild(childD);
  expected.addChild(item3);
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  assertEquals(expected,actual);
}",0.9358128374325136
154427,"@Test public void shouldParseAComplexTypeTest() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem item=new ResponseItem(""String_Node_Str"");
  ResponseItem childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item.addItem(childA);
  ResponseItem childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item.addItem(childB);
  ResponseItem childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item.addItem(childC);
  ResponseItem childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item.addItem(childD);
  expected.addItem(item);
  assertEquals(expected,actual);
}","@Test public void shouldParseAComplexTypeTest() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem item=new ResponseItem(""String_Node_Str"");
  ResponseItem childA=new ResponseItem(""String_Node_Str"");
  childA.setContent(""String_Node_Str"");
  item.addChild(childA);
  ResponseItem childB=new ResponseItem(""String_Node_Str"");
  childB.setContent(""String_Node_Str"");
  item.addChild(childB);
  ResponseItem childC=new ResponseItem(""String_Node_Str"");
  childC.setContent(""String_Node_Str"");
  item.addChild(childC);
  ResponseItem childD=new ResponseItem(""String_Node_Str"");
  childD.setContent(""String_Node_Str"");
  item.addChild(childD);
  expected.addChild(item);
  assertEquals(expected,actual);
}",0.98110037799244
154428,"@Test public void shouldParseASimpleXml() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem child=new ResponseItem(""String_Node_Str"");
  child.setContent(""String_Node_Str"");
  expected.addItem(child);
  assertEquals(expected,actual);
}","@Test public void shouldParseASimpleXml() throws ParserConfigurationException, SAXException {
  String sampleXml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ResponseParser parser=new ResponseParser();
  ResponseItem actual=parser.parse(sampleXml);
  ResponseItem expected=new ResponseItem(""String_Node_Str"");
  ResponseItem child=new ResponseItem(""String_Node_Str"");
  child.setContent(""String_Node_Str"");
  expected.addChild(child);
  assertEquals(expected,actual);
}",0.992930086410055
154429,"public static void main(String[] args){
  checker.captureCallStacks=false;
  Main.main(args);
}","public static void main(String[] args){
  Property.start();
  Main.main(args);
  Property.stop();
}",0.711340206185567
154430,"private static boolean isConstant(Object o){
  return o instanceof Integer || o instanceof String;
}","private static boolean isConstant(Object o){
  return o instanceof Integer || o instanceof String || o instanceof Boolean;
}",0.8928571428571429
154431,"State popEvent(){
  return new State(vertex,store,events.pop(),parent);
}","State popEvent(){
  return new State(vertex,store,events.pop(),parent,time);
}",0.9668874172185432
154432,"private State(int vertex,Treap<Binding> store,Queue<Event> events,Parent parent){
  this.vertex=vertex;
  this.store=store;
  this.events=events;
  this.parent=parent;
  this.time=1 + (parent == null ? 0 : parent.state.time);
}","private State(int vertex,Treap<Binding> store,Queue<Event> events,Parent parent,int time){
  this.vertex=vertex;
  this.store=store;
  this.events=events;
  this.parent=parent;
  this.time=time;
}",0.8841607565011821
154433,"private static void selectOldest(State[] a,int i,int j,int k){
  int ii, jj, kk;
  if (i >= k)   return;
  jj=i + random.nextInt() % (k - i);
  swap(a,i,jj);
  for (ii=jj=kk=i + 1; kk < k; ++kk) {
    if (a[kk].time <= a[i].time) {
      swap(a,jj++,kk);
    }
  }
  if (jj < k) {
    if (j < jj) {
      selectOldest(a,i,j,jj);
    }
 else {
      selectOldest(a,jj,j,k);
    }
  }
}","private static void selectOldest(State[] a,int i,int j,int k){
  int ii, jj, kk;
  if (i >= k)   return;
  jj=i + random.nextInt() % (k - i);
  swap(a,i,jj);
  for (ii=jj=kk=i + 1; kk < k; ++kk) {
    if (a[kk].time <= a[i].time) {
      swap(a,jj++,kk);
    }
  }
  swap(a,i,--jj);
  if (j < jj) {
    selectOldest(a,i,j,jj);
  }
 else   if (j > jj) {
    selectOldest(a,jj + 1,j,k);
  }
}",0.8320413436692506
154434,"static State make(int vertex,Treap<Binding> store,Queue<Event> events,Queue<Event> consumed,State parent){
  return new State(vertex,store,events,new Parent(parent,consumed));
}","static State make(int vertex,Treap<Binding> store,Queue<Event> events,Queue<Event> consumed,State parent){
  return new State(vertex,store,events,new Parent(parent,consumed),parent.time + 1);
}",0.9567567567567568
154435,"State pushEvent(Event event){
  return new State(vertex,store,events.push(event),parent);
}","State pushEvent(Event event){
  return new State(vertex,store,events.push(event),parent,time);
}",0.9732620320855616
154436,"static State start(int vertex){
  return new State(vertex,Treap.<Binding>empty(),Queue.<Event>empty(),null);
}","static State start(int vertex){
  return new State(vertex,Treap.<Binding>empty(),Queue.<Event>empty(),null,0);
}",0.990990990990991
154437,"public synchronized void check(Event event){
  if (!checkerEnabled) {
    return;
  }
  checkerEnabled=false;
  if (logState) {
    boolean first=true;
    System.out.printf(""String_Node_Str"");
    for (    State s : states) {
      System.out.printf(""String_Node_Str"",first ? ""String_Node_Str"" : ""String_Node_Str"",automaton.vertexNames[s.vertex],s.events.size(),s.store.size());
      first=false;
    }
    System.out.printf(""String_Node_Str"");
    System.out.printf(""String_Node_Str"",event.id,automaton.eventNames[event.id]);
  }
  HashSet<State> newActiveStates=new HashSet<State>(2 * states.size());
  for (  State state : states) {
    if (automaton.transitions[state.vertex].length == 0) {
      continue;
    }
    if (!automaton.isObservable(event.id,state.vertex)) {
      newActiveStates.add(state);
      continue;
    }
    state=state.pushEvent(event);
    if (state.events.size() < automaton.maximumTransitionDepths[state.vertex]) {
      newActiveStates.add(state);
      continue;
    }
    boolean anyEnabled=false;
    for (    Transition transition : automaton.transitions[state.vertex]) {
      Treap<Binding> store=state.store;
      Queue<Event> events=state.events;
      Queue<Event> consumed=Queue.empty();
      int i;
      for (i=0; i < transition.steps.length; ++i) {
        TransitionStep step=transition.steps[i];
        Event stepEvent=events.top();
        events=events.pop();
        consumed=consumed.push(stepEvent);
        if (!step.evaluateGuard(stepEvent,store)) {
          break;
        }
        store=step.action.apply(stepEvent,store);
      }
      if (i == transition.steps.length) {
        anyEnabled=true;
        State newState=State.make(transition.target,store,events,consumed,state);
        newActiveStates.add(newState);
        String msg=automaton.errorMessages[transition.target];
        if (msg != null) {
          reportError(msg,newState);
        }
      }
    }
    if (!anyEnabled) {
      newActiveStates.add(state.popEvent());
    }
  }
  boolean doGc=true;
  for (  State s : newActiveStates) {
    if (s.time < 2 * historyLength) {
      doGc=false;
      break;
    }
  }
  if (doGc) {
    ArrayDeque<State> p;
    ArrayDeque<State> q=new ArrayDeque<State>();
    for (    State s : newActiveStates) {
      q.addLast(s);
      s.time=-1;
    }
    for (int i=1; i < historyLength; ++i) {
      p=q;
      q=new ArrayDeque<State>();
      for (      State s : p) {
        if (s.parent != null && s.parent.state.time != -1) {
          q.addLast(s.parent.state);
          s.parent.state.time=-1;
        }
      }
    }
    for (    State s : newActiveStates) {
      fixTimeOfState(s);
    }
  }
  states=newActiveStates;
  checkerEnabled=true;
}","public synchronized void check(Event event){
  if (!checkerEnabled) {
    return;
  }
  checkerEnabled=false;
  if (logState) {
    boolean first=true;
    System.out.printf(""String_Node_Str"");
    for (    State s : states) {
      System.out.printf(""String_Node_Str"",first ? ""String_Node_Str"" : ""String_Node_Str"",automaton.vertexNames[s.vertex],s.vertex,s.events.size(),s.store.size());
      first=false;
    }
    System.out.printf(""String_Node_Str"");
    System.out.printf(""String_Node_Str"",event.id,automaton.eventNames[event.id]);
  }
  HashSet<State> newActiveStates=new HashSet<State>(2 * states.size());
  for (  State state : states) {
    if (automaton.transitions[state.vertex].length == 0) {
      continue;
    }
    if (!automaton.isObservable(event.id,state.vertex)) {
      newActiveStates.add(state);
      continue;
    }
    state=state.pushEvent(event);
    if (state.events.size() < automaton.maximumTransitionDepths[state.vertex]) {
      newActiveStates.add(state);
      continue;
    }
    boolean anyEnabled=false;
    for (    Transition transition : automaton.transitions[state.vertex]) {
      Treap<Binding> store=state.store;
      Queue<Event> events=state.events;
      Queue<Event> consumed=Queue.empty();
      int i;
      for (i=0; i < transition.steps.length; ++i) {
        TransitionStep step=transition.steps[i];
        Event stepEvent=events.top();
        events=events.pop();
        consumed=consumed.push(stepEvent);
        if (!step.evaluateGuard(stepEvent,store)) {
          break;
        }
        store=step.action.apply(stepEvent,store);
      }
      if (i == transition.steps.length) {
        anyEnabled=true;
        State newState=State.make(transition.target,store,events,consumed,state);
        newActiveStates.add(newState);
        String msg=automaton.errorMessages[transition.target];
        if (msg != null) {
          reportError(msg,newState);
        }
      }
    }
    if (!anyEnabled) {
      newActiveStates.add(state.popEvent());
    }
  }
  boolean doGc=true;
  for (  State s : newActiveStates) {
    if (s.time < 2 * historyLength) {
      doGc=false;
      break;
    }
  }
  if (doGc) {
    ArrayDeque<State> p;
    ArrayDeque<State> q=new ArrayDeque<State>();
    for (    State s : newActiveStates) {
      q.addLast(s);
      s.time=-1;
    }
    for (int i=1; i < historyLength; ++i) {
      p=q;
      q=new ArrayDeque<State>();
      for (      State s : p) {
        if (s.parent != null && s.parent.state.time != -1) {
          q.addLast(s.parent.state);
          s.parent.state.time=-1;
        }
      }
    }
    for (    State s : newActiveStates) {
      fixTimeOfState(s);
    }
  }
  states=newActiveStates;
  checkerEnabled=true;
}",0.9983513464004397
154438,"public boolean play(CellKey this_cell_key,Player this_player){
  assert(cell_space != null);
  assert(started);
  Cell this_cell=cell_space.get_cell_from_key(this_cell_key);
  if (this_cell != null)   return play(this_cell,this_player);
 else   return false;
}","public boolean play(CellKey this_cell_key,Player this_player){
  assert(myCellSpace != null);
  assert(started);
  Cell this_cell=myCellSpace.get_cell_from_key(this_cell_key);
  if (this_cell != null)   return play(this_cell,this_player);
 else   return false;
}",0.950191570881226
154439,"public void set_listener(GameListener this_listener){
  my_listener=this_listener;
}","public void set_listener(GameListener this_listener){
  myListener=this_listener;
}",0.9820359281437124
154440,"protected Game(){
  players=new LinkedHashSet<Player>();
  pieces=new LinkedHashSet<Piece>();
  started=false;
  my_listener=null;
}","protected Game(){
  myPlayers=new LinkedHashSet<Player>();
  pieces=new LinkedHashSet<Piece>();
  started=false;
  myListener=null;
}",0.9735849056603774
154441,protected abstract void next_player();,"protected void next_player(){
  if (playerTurn.hasNext()) {
    currentPlayer=playerTurn.next();
    if (!currentPlayer.is_alive())     next_player();
    assert(currentPlayer != null);
  }
 else   select_first_player();
}",0.2153846153846154
154442,protected abstract void select_first_player();,"protected void select_first_player(){
  playerTurn=getPlayers().iterator();
  currentPlayer=playerTurn.next();
  if (!currentPlayer.is_alive())   next_player();
  assert(currentPlayer != null);
}",0.3070539419087137
154443,"public void start(){
  assert(players.size() > 1);
  select_first_player();
  started=true;
}","public void start(){
  assert(myPlayers.size() > 1);
  select_first_player();
  started=true;
}",0.9787234042553192
154444,"public ReadOnlyCellSpace get_cell_space_view(){
  assert(cell_space != null);
  return cell_space;
}","public ReadOnlyCellSpace get_cell_space_view(){
  assert(myCellSpace != null);
  return myCellSpace;
}",0.9306930693069309
154445,public abstract Player get_current_player();,"public Player get_current_player(){
  return currentPlayer;
}",0.6666666666666666
154446,"protected void win(Player winner){
  if (my_listener != null)   my_listener.on_win(this,winner);
}","protected void win(Player winner){
  if (myListener != null) {
    myListener.on_win(this,winner);
  }
}",0.9306930693069309
154447,"public void change_owner(Player this_player){
  Player old_owner=owner;
  old_owner.loose_a_piece(this);
  owner=this_player;
  owner.win_a_piece(this);
  if (my_listener != null)   my_listener.on_owner_changed(this,old_owner,owner);
}","public void change_owner(Player this_player){
  Player old_owner=owner;
  old_owner.looseAPiece(this);
  owner=this_player;
  owner.winAPiece(this);
  if (my_listener != null)   my_listener.on_owner_changed(this,old_owner,owner);
}",0.871244635193133
154448,"public Player(String this_name){
  super(this_name);
}","public Player(String thisName){
  super(thisName);
}",0.9433962264150944
154449,"@Override public void create(){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  camera=new OrthographicCamera(500,300);
  cam=new PerspectiveCamera(67,500,300);
  meshObj=new MeshObject(0,0,10,10,10);
  meshObj2=new MeshObject(10,20,10,10,10);
  CollisionHelper.collidable.add(meshObj);
  CollisionHelper.collidable.add(meshObj2);
  spawn=new Vector2(-100,5);
  target=new Vector2(100,-5);
  font=new BitmapFont(Gdx.files.internal(""String_Node_Str""),Gdx.files.internal(""String_Node_Str""),false);
  gl=Gdx.graphics.getGL10();
  batch=new SpriteBatch();
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
}","@Override public void create(){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  camera=new OrthographicCamera(500,300);
  cam=new PerspectiveCamera(67,500,300);
  meshObj=new MeshObject(0,0,10,10,10);
  meshObj2=new MeshObject(10,20,10,10,10);
  CollisionHelper.collidable.add(meshObj);
  CollisionHelper.collidable.add(meshObj2);
  spawn=new Vector2(-50,5);
  target=new Vector2(50,-5);
  font=new BitmapFont(Gdx.files.internal(""String_Node_Str""),Gdx.files.internal(""String_Node_Str""),false);
  gl=Gdx.graphics.getGL10();
  batch=new SpriteBatch();
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
}",0.9918032786885246
154450,"@Override public void render(){
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
  camera.update();
  camera.apply(gl);
  batch.setProjectionMatrix(camera.combined);
  batch.setTransformMatrix(camera.view);
  if (Gdx.input.justTouched()) {
    wp=new WayPoint(spawn,target,false);
    wp.CalculateNextPossibleWayPoints();
  }
  if (debug) {
    VisualDebugHelper.drawPoints(gl);
  }
  meshObj.render(gl);
  meshObj2.render(gl);
  batch.begin();
  font.draw(batch,""String_Node_Str"" + Gdx.graphics.getFramesPerSecond(),-220,140);
  batch.end();
}","@Override public void render(){
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
  cam.update();
  cam.apply(gl);
  batch.setProjectionMatrix(camera.combined);
  batch.setTransformMatrix(camera.view);
  if (Gdx.input.justTouched()) {
    wp=new WayPoint(spawn,target,false);
    wp.CalculateNextPossibleWayPoints();
  }
  if (debug) {
    VisualDebugHelper.drawPoints(gl);
    VisualDebugHelper.drawLines(gl);
  }
  meshObj.render(gl);
  meshObj2.render(gl);
  batch.begin();
  font.draw(batch,""String_Node_Str"" + Gdx.graphics.getFramesPerSecond(),-220,140);
  batch.end();
}",0.9318801089918256
154451,"public void calculateHit(float dst){
  hit=new Vector2();
  hit.set(rayDir.add(start).mul(dst));
  if (debug) {
    VisualDebugHelper.addPoint(hit);
  }
}","public void calculateHit(float dst){
  hit=new Vector2();
  hit.set(rayDir.mul(dst));
  if (debug) {
    VisualDebugHelper.addPoint(hit);
  }
}",0.9629629629629628
154452,"public static void drawPoints(GL10 gl){
  gl.glPointSize(10);
  renderer.begin(GL10.GL_POINTS);
  renderer.color(1,0,0,1);
  for (  Vector2 point : points) {
    renderer.vertex(point.x,point.y,DEPTH);
  }
  renderer.end();
}","public static void drawPoints(GL10 gl){
  gl.glPointSize(5);
  renderer.begin(GL10.GL_POINTS);
  for (  Vector2 point : points) {
    renderer.color(1,0,0,1);
    renderer.vertex(point.x,point.y,DEPTH);
  }
  renderer.end();
}",0.8691796008869179
154453,"public static void addPoint(Vector2 v){
  points.add(v);
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"" + v);
}","public static void addPoint(Vector2 v){
  v=new Vector2(v);
  points.add(v);
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"" + v);
}",0.9193548387096774
154454,"public WayPoint(Vector2 position,Vector2 target,boolean isHitPoint){
  this.position=position;
  this.target=target;
  this.isHitPoint=isHitPoint;
  ri=new RayInfo();
  dirs=new ArrayList<Vector2>();
  possibleNextWaypoints=new ArrayList<WayPoint>();
  if (debug) {
    VisualDebugHelper.addPoint(position);
  }
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
}","public WayPoint(Vector2 position,Vector2 target,boolean isHitPoint){
  this.position=position;
  this.target=target;
  this.isHitPoint=isHitPoint;
  ri=new RayInfo();
  dirs=new ArrayList<Vector2>();
  possibleNextWaypoints=new ArrayList<WayPoint>();
  if (debug) {
    VisualDebugHelper.addPoint(position);
    VisualDebugHelper.addPoint(target);
  }
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
}",0.948051948051948
154455,"private Vector2 CastRay(Vector2 start,Vector2 end){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  ri.start=new Vector2(start);
  ri.end=new Vector2(end);
  float oldDst=MAX_RAY_LENGTH;
  ri.calculateDir();
  hasCollided=false;
  for (  MeshObject mesh : CollisionHelper.collidable) {
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    if (oldDst > ri.distanceToHit && RayCastHelper.IntersectLineCircle(mesh.getPosition(),mesh.getRadius(),ri)) {
      oldDst=ri.distanceToHit;
      hasCollided=true;
      Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    }
  }
  ri.calculateHit(ri.distanceToHit);
  return ri.hit;
}","private Vector2 CastRay(Vector2 start,Vector2 end){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  ri.start=new Vector2(start);
  ri.end=new Vector2(end);
  float oldDst=MAX_RAY_LENGTH;
  ri.calculateDir();
  hasCollided=false;
  for (  MeshObject mesh : CollisionHelper.collidable) {
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    if (oldDst > ri.distanceToHit && RayCastHelper.IntersectLineCircle(mesh.getPosition(),mesh.getRadius(),ri)) {
      oldDst=ri.distanceToHit;
      hasCollided=true;
      Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    }
  }
  ri.calculateHit(ri.distanceToHit);
  if (debug) {
    VisualDebugHelper.addLine(start,ri.hit);
  }
  return ri.hit;
}",0.940119760479042
154456,"private boolean doSideSteps(ArrayList<Vector2> dirs){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  for (  Vector2 dir : dirs) {
    Vector2 hit=CastRay(this.position,this.position.add(dir.mul(MAX_RAY_LENGTH)));
  }
  float currentStep=0;
  int numberOfWays=0;
  Gdx.app.log(""String_Node_Str"",ri.distanceToHit + ""String_Node_Str"" + currentStep);
  int i=0;
  while (i > 100) {
    i++;
    currentStep+=stepLength;
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    for (    Vector2 dir : dirs) {
      if (doOneSideStep(dir,currentStep)) {
        numberOfWays++;
        Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
        if (numberOfWays >= ALTERNATIVE_WAYS) {
          return true;
        }
      }
    }
  }
  if (numberOfWays >= 1) {
    return true;
  }
 else {
    return false;
  }
}","private boolean doSideSteps(ArrayList<Vector2> dirs){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  for (  Vector2 dir : dirs) {
    Vector2 hit=CastRay(this.position,this.position.add(dir));
  }
  float currentStep=0;
  int numberOfWays=0;
  Gdx.app.log(""String_Node_Str"",ri.distanceToHit + ""String_Node_Str"" + currentStep);
  int i=0;
  while (i > 100) {
    i++;
    currentStep+=stepLength;
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    for (    Vector2 dir : dirs) {
      if (doOneSideStep(dir,currentStep)) {
        numberOfWays++;
        Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
        if (numberOfWays >= ALTERNATIVE_WAYS) {
          return true;
        }
      }
    }
  }
  if (numberOfWays >= 1) {
    return true;
  }
 else {
    return false;
  }
}",0.9875930521091812
154457,"@Override public void create(){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  camera=new PerspectiveCamera(67,500,300);
  meshObj=new MeshObject(0,0,10,10,10);
  rotate=0;
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
}","@Override public void create(){
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  camera=new PerspectiveCamera(67,500,300);
  meshObj=new MeshObject(0,0,10,10,10);
  CollisionHelper.collidable.add(meshObj);
  spawn=new Vector2(-100,0);
  target=new Vector2(100,5);
  rotate=0;
  gl=Gdx.graphics.getGL10();
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
}",0.7416107382550335
154458,"@Override public void render(){
  GL10 gl=Gdx.graphics.getGL10();
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
  camera.update();
  camera.apply(gl);
  gl.glPushMatrix();
  gl.glTranslatef(meshObj.getPosition().x,meshObj.getPosition().y,-40);
  gl.glRotatef(rotate,0,1,0);
  meshObj.getMesh().render(GL10.GL_TRIANGLE_STRIP);
  gl.glPopMatrix();
  rotate++;
}","@Override public void render(){
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
  camera.update();
  camera.apply(gl);
  if (Gdx.input.justTouched()) {
    wp=new WayPoint(spawn,target,false);
    wp.CalculateNextPossibleWayPoints();
  }
  meshObj.render(gl);
  rotate++;
}",0.4498381877022653
154459,"public MeshObject(float x,float y,float width,float length,float height){
  mesh=new Mesh(false,8,14,new VertexAttribute(Usage.Position,3,""String_Node_Str""));
  mesh=generateBlock(mesh,width,length,height);
  this.position=new Vector2(x,y);
}","public MeshObject(float x,float y,float width,float length,float height){
  this.setRadius(width * 1.01f);
  mesh=new Mesh(false,8,14,new VertexAttribute(Usage.Position,3,""String_Node_Str""));
  mesh=generateBlock(mesh,width,length,height);
  this.position=new Vector2(x,y);
}",0.9361702127659576
154460,"public WayPoint(Vector2 position,WayPoint lastWp,WayPoint target,boolean isHitPoint){
}","public WayPoint(Vector2 position,Vector2 target,boolean isHitPoint){
  this.position=position;
  this.target=target;
  this.isHitPoint=isHitPoint;
  ri=new RayInfo();
  dirs=new ArrayList<Vector2>();
}",0.4375
154461,"private Vector2 CastRay(Vector2 start,Vector2 end){
  ri.start=start;
  ri.end=end;
  float oldDst=300;
  ri.calculateDir();
  for (  MeshObject mesh : collision) {
    if (oldDst > ri.distanceToHit && RayCastHelper.IntersectLineCircle(mesh.position,mesh.radius,ri)) {
      oldDst=ri.distanceToHit;
    }
  }
  ri.calculateHit(ri.distanceToHit);
  return ri.hit;
}","private Vector2 CastRay(Vector2 start,Vector2 end){
  ri.start=start;
  ri.end=end;
  float oldDst=MAX_RAY_LENGTH;
  ri.calculateDir();
  for (  MeshObject mesh : CollisionHelper.collidable) {
    if (oldDst > ri.distanceToHit && RayCastHelper.IntersectLineCircle(mesh.getPosition(),mesh.getRadius(),ri)) {
      oldDst=ri.distanceToHit;
      Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    }
  }
  ri.calculateHit(ri.distanceToHit);
  return ri.hit;
}",0.8349514563106796
154462,"public boolean CalculateNextPossibleWayPoints(){
  if (!this.isHitPoint) {
    return doForwardStep();
  }
 else {
    return doSideSteps(dirs);
  }
}","public boolean CalculateNextPossibleWayPoints(){
  if (!this.isHitPoint) {
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    return doForwardStep();
  }
 else {
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    dirs.add(new Vector2(0,1));
    dirs.add(new Vector2(0,-1));
    return doSideSteps(dirs);
  }
}",0.6342494714587738
154463,"private boolean doOneSideStep(Vector2 dir,float currentStep){
  WayPoint wp=new WayPoint(this.position.add(dir.mul(currentStep)),this,this.target,false);
  if (wp.CalculateNextPossibleWayPoints()) {
    this.possibleNextWaypoints.add(wp);
    return true;
  }
  return false;
}","private boolean doOneSideStep(Vector2 dir,float currentStep){
  WayPoint wp=new WayPoint(this.position.add(dir.mul(currentStep)),this.target,false);
  if (wp.CalculateNextPossibleWayPoints()) {
    this.possibleNextWaypoints.add(wp);
    return true;
  }
  return false;
}",0.73224043715847
154464,"private boolean doForwardStep(){
  Vector2 hit=CastRay(this.position,target.position);
  if (hit == target.position) {
    return true;
  }
  WayPoint wp=new WayPoint(hit,this,this.target,true);
  if (wp.CalculateNextPossibleWayPoints()) {
    possibleNextWaypoints.add(wp);
    return true;
  }
  return false;
}","private boolean doForwardStep(){
  Vector2 hit=CastRay(this.position,target);
  if (hit == target) {
    Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
    return true;
  }
  WayPoint wp=new WayPoint(hit,this.target,true);
  if (wp.CalculateNextPossibleWayPoints()) {
    possibleNextWaypoints.add(wp);
    return true;
  }
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"");
  return false;
}",0.8180535966149506
154465,"public boolean onCommand(CommandSender _sender,Command _command,String _label,String[] _args){
  Player player=(_sender instanceof Player) ? (Player)_sender : null;
  if (_label.equals(""String_Node_Str"")) {
    if (_args.length >= 2) {
      String commandName=_args[0];
      String playerName=_args[1];
      ArrayList<String> flags=new ArrayList<String>();
      for (int i=2; i < _args.length; i++) {
        flags.add(_args[i]);
      }
      Executioner executioner=ExecutionManager.getExecutioner(commandName);
      if (executioner != null) {
        Player target=findPlayer(playerName);
        if (target != null) {
          if (executioner.hasPermission(player)) {
            if (ExecutionManager.isExecuting(target))             ExecutionManager.release(target);
            ExecutionManager.execute(executioner,player,target,flags);
            communicationManager.message(player,""String_Node_Str"" + commandName + ""String_Node_Str""+ playerName+ ""String_Node_Str"");
          }
 else           communicationManager.error(player,""String_Node_Str"" + commandName + ""String_Node_Str"");
        }
 else         communicationManager.error(player,""String_Node_Str"" + playerName + ""String_Node_Str"");
      }
 else       communicationManager.error(player,""String_Node_Str"" + commandName + ""String_Node_Str"");
    }
 else {
      if (player != null) {
        if (permissionManager.hasStrikePermission(player))         communicationManager.command(player,""String_Node_Str"",""String_Node_Str"");
      }
    }
    return true;
  }
  return false;
}","public boolean onCommand(CommandSender _sender,Command _command,String _label,String[] _args){
  Player player=(_sender instanceof Player) ? (Player)_sender : null;
  if (_label.equals(""String_Node_Str"")) {
    if (_args.length >= 2) {
      String commandName=_args[0];
      String playerName=_args[1];
      ArrayList<String> flags=new ArrayList<String>();
      for (int i=2; i < _args.length; i++) {
        flags.add(_args[i]);
      }
      Executioner executioner=ExecutionManager.createExecutioner(commandName);
      if (executioner != null) {
        Player target=findPlayer(playerName);
        if (target != null) {
          if (executioner.hasPermission(player)) {
            ExecutionManager.add(executioner,player,target,flags);
            communicationManager.message(player,""String_Node_Str"" + commandName + ""String_Node_Str""+ playerName+ ""String_Node_Str"");
          }
 else           communicationManager.error(player,""String_Node_Str"" + commandName + ""String_Node_Str"");
        }
 else         communicationManager.error(player,""String_Node_Str"" + playerName + ""String_Node_Str"");
      }
 else       communicationManager.error(player,""String_Node_Str"" + commandName + ""String_Node_Str"");
    }
 else {
      if (player != null) {
        if (permissionManager.hasStrikePermission(player))         communicationManager.command(player,""String_Node_Str"",""String_Node_Str"");
      }
    }
    return true;
  }
  return false;
}",0.9603729603729604
154466,"private static Executioner createExecutioner(String _name){
  if (_name.equalsIgnoreCase(""String_Node_Str""))   return new Strike();
  return null;
}","public static Executioner createExecutioner(String _name){
  if (_name.equalsIgnoreCase(""String_Node_Str""))   return new Strike();
  return null;
}",0.9694915254237289
154467,"public static void killed(Player _player){
  Sentence sentence=sentences.get(_player.getName());
  if (sentence != null) {
    String message=sentence.executioner.getMessage();
    if (message != null && !sentence.flags.contains(""String_Node_Str"")) {
      message=Wrath.get().getComms().parse(message,sentence.player,sentence.target);
      Wrath.get().getComms().broadcast(null,message);
    }
    release(_player);
  }
}","public static void killed(Player _player){
  Sentence sentence=sentences.get(_player.getName());
  if (sentence != null) {
    String message=sentence.executioner.getMessage();
    if (message != null && !sentence.flags.contains(""String_Node_Str"")) {
      message=Wrath.get().getComms().parse(message,sentence.player,sentence.target);
      Wrath.get().getComms().broadcast(null,message);
    }
    remove(_player);
  }
}",0.991715976331361
154468,"/** 
 * Performs a minimax search on a subtree of the game's state space and computes the value of the best move for MIN. This method implements Alpha-Beta pruning.
 * @param state The board from which to start this portion of the search
 * @param alpha The best known utility for MAX along the current search path
 * @param beta The best known utility for MIN along the current search path
 * @return The utility of the best branch to take from this board state
 */
private int alphaBetaMinVal(Board state,double alpha,double beta){
  ++nodesVisited;
  if (state.isGameOver()) {
    int utility=heuristic.evaluate(state);
    state.setValue(utility);
    return utility;
  }
  Vector<Board> children=state.generateSuccessors();
  for (  Board b : children) {
    int child=alphaBetaMaxVal(b,alpha,beta);
    beta=Math.min(beta,child);
    if (alpha >= beta) {
      state.setValue(child);
      return child;
    }
  }
  state.setValue((int)beta);
  return (int)beta;
}","/** 
 * Performs a minimax search on a subtree of the game's state space and computes the value of the best move for MIN. This method implements Alpha-Beta pruning.
 * @param state The board from which to start this portion of the search
 * @param alpha The best known utility for MAX along the current search path
 * @param beta The best known utility for MIN along the current search path
 * @return The utility of the best branch to take from this board state
 */
private int alphaBetaMinVal(Board state,double alpha,double beta,int depth){
  ++nodesVisited;
  if (state.isGameOver() || state.getFilledPositions() >= depth || timeExpired) {
    System.out.println(""String_Node_Str"" + state.getFilledPositions());
    int utility=heuristic.evaluate(state);
    state.setValue(utility);
    return utility;
  }
  Vector<Board> children=state.generateSuccessors();
  for (  Board b : children) {
    int child=alphaBetaMaxVal(b,alpha,beta,depth);
    beta=Math.min(beta,child);
    if (alpha >= beta) {
      state.setValue(child);
      return child;
    }
  }
  state.setValue((int)beta);
  return (int)beta;
}",0.9317963496637848
154469,"/** 
 * Gets or computes the next move for this Player object, depending on whether this Player is an AI agent or not.
 * @param b The board's current state
 */
public void move(Board b){
  String move;
  if (!human) {
    move=minimax(b);
  }
 else {
    System.out.print(""String_Node_Str"");
    Scanner in=new Scanner(System.in);
    move=in.nextLine();
  }
  String[] parsed=move.split(""String_Node_Str"");
  int row=Integer.parseInt(parsed[0]);
  int col=Integer.parseInt(parsed[1]);
  b.move(player,row,col);
}","/** 
 * Gets or computes the next move for this Player object, depending on whether this Player is an AI agent or not.
 * @param b The board's current state
 */
public void move(Board b){
  String move;
  if (!human) {
    timeExpired=false;
    Timer t=new Timer();
    MoveTimer mt=new MoveTimer();
    t.schedule(mt,1000);
    move=minimax(b);
  }
 else {
    System.out.print(""String_Node_Str"");
    Scanner in=new Scanner(System.in);
    move=in.nextLine();
  }
  String[] parsed=move.split(""String_Node_Str"");
  int row=Integer.parseInt(parsed[0]);
  int col=Integer.parseInt(parsed[1]);
  b.move(player,row,col);
}",0.905726872246696
154470,"/** 
 * Performs a minimax search on a subtree of the game's state space and computes the value of the best move for MAX. This method implements Alpha-Beta pruning.
 * @param state The board from which to start this portion of the search
 * @param alpha The best known utility for MAX along the current search path
 * @param beta The best known utility for MIN along the current search path
 * @return The utility of the best branch to take from this board state
 */
private int alphaBetaMaxVal(Board state,double alpha,double beta){
  ++nodesVisited;
  if (state.isGameOver()) {
    int utility=heuristic.evaluate(state);
    state.setValue(utility);
    return utility;
  }
  Vector<Board> children=state.generateSuccessors();
  for (  Board b : children) {
    int child=alphaBetaMinVal(b,alpha,beta);
    alpha=Math.max(alpha,child);
    if (alpha >= beta) {
      state.setValue(child);
      return child;
    }
  }
  state.setValue((int)alpha);
  return (int)alpha;
}","/** 
 * Performs a minimax search on a subtree of the game's state space and computes the value of the best move for MAX. This method implements Alpha-Beta pruning.
 * @param state The board from which to start this portion of the search
 * @param alpha The best known utility for MAX along the current search path
 * @param beta The best known utility for MIN along the current search path
 * @return The utility of the best branch to take from this board state
 */
private int alphaBetaMaxVal(Board state,double alpha,double beta,int depth){
  ++nodesVisited;
  if (state.isGameOver() || state.getFilledPositions() >= depth || timeExpired) {
    System.out.println(""String_Node_Str"" + state.getFilledPositions());
    int utility=heuristic.evaluate(state);
    state.setValue(utility);
    return utility;
  }
  Vector<Board> children=state.generateSuccessors();
  for (  Board b : children) {
    int child=alphaBetaMinVal(b,alpha,beta,depth);
    alpha=Math.max(alpha,child);
    if (alpha >= beta) {
      state.setValue(child);
      return child;
    }
  }
  state.setValue((int)alpha);
  return (int)alpha;
}",0.9320574162679426
154471,"/** 
 * Uses minimax search to find the value of the best move.
 * @param currentState The current state of the board
 * @return A String representation of the best move (e.g. ""1 2"")
 */
public String minimax(Board currentState){
  int val;
  String move=""String_Node_Str"";
  if (player == 'X') {
    val=alphaBetaMaxVal(currentState,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY);
    Vector<Board> children=currentState.getSuccessors();
    for (    Board b : children) {
      if (b.getValue() == 1 && b.isGameOver()) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
    for (    Board b : children) {
      if (b.getValue() == val) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
  }
 else {
    val=alphaBetaMinVal(currentState,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY);
    Vector<Board> children=currentState.getSuccessors();
    for (    Board b : children) {
      if (b.getValue() == -1 && b.isGameOver()) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
    for (    Board b : children) {
      if (b.getValue() == val) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
  }
  return null;
}","/** 
 * Uses minimax search to find the value of the best move.
 * @param currentState The current state of the board
 * @return A String representation of the best move (e.g. ""1 2"")
 */
public String minimax(Board currentState){
  int val=-1;
  String move=""String_Node_Str"";
  if (player == 'X') {
    for (int i=1; i <= 9 && !timeExpired; ++i) {
      val=alphaBetaMaxVal(currentState,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,i);
      try {
        Thread.sleep(300);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      System.out.println(""String_Node_Str"");
    }
    Vector<Board> children=currentState.getSuccessors();
    for (    Board b : children) {
      if (b.getValue() == 1 && b.isGameOver()) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
    for (    Board b : children) {
      if (b.getValue() == val) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
  }
 else {
    for (int i=1; i <= 9; ++i) {
      val=alphaBetaMinVal(currentState,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,i);
      System.out.println(""String_Node_Str"");
    }
    Vector<Board> children=currentState.getSuccessors();
    for (    Board b : children) {
      if (b.getValue() == -1 && b.isGameOver()) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
    for (    Board b : children) {
      if (b.getValue() == val) {
        move=Board.generateMove(currentState,b);
        return move;
      }
    }
  }
  return null;
}",0.8849806542384805
154472,"/** 
 * copia los atributos a otro 
 */
protected final void copyTo(final XMPPMessageAttributes other,final Map<String,Object> model){
  other.setMessageType(getMessageType());
  other.setMessageType(getMessageType());
  other.setLangBodies(translateLangBodies());
  if (getHtmlStringMessage() != null) {
    other.setHtmlMessage(new StringResource(renderString(getHtmlStringMessage(),model)));
  }
  final List<PacketExtension> packetExtensions=new LinkedList<PacketExtension>(getExtensions());
  for (  final XMPPMessagePacketExtensionTemplate template : packetExtensionTemplates) {
    packetExtensions.add(template.render(model));
  }
  other.setExtensions(packetExtensions);
  other.setConnection(getConnection());
}","/** 
 * copia los atributos a otro 
 */
protected final void copyTo(final XMPPMessageAttributes other,final Map<String,Object> model){
  other.setMessageType(getMessageType());
  other.setMessageType(getMessageType());
  other.setLangBodies(translateLangBodies());
  if (getHtmlStringMessage() != null) {
    other.setHtmlMessage(new StringResource(renderString(getHtmlStringMessage(),model)));
  }
  final List<PacketExtension> packetExtensions=new LinkedList<PacketExtension>(getExtensions());
  for (  final XMPPMessagePacketExtensionTemplate template : packetExtensionTemplates) {
    packetExtensions.add(template.render(model));
  }
  if (packetExtensions != null) {
    other.setExtensions(packetExtensions);
  }
  other.setConnection(getConnection());
}",0.9730094466936572
154473,"/** 
 * @see StreetsDAO#getIntersection(String,String) 
 */
public final Collection<IntersectionResult> getIntersection(final String street1Param,final String street2Param){
  final Collection<IntersectionResult> ret=new ArrayList<IntersectionResult>();
  if ((street1Param != null && street1Param.length() <= 2) || (street2Param != null && street2Param.length() <= 2)) {
    return ret;
  }
  final String wildcard;
  if (street1Param.startsWith(street2Param) || street2Param.startsWith(street1Param)) {
    wildcard=""String_Node_Str"";
  }
 else {
    wildcard=""String_Node_Str"";
  }
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String street1Filtered=executeFilters(street1Param);
  String street2Filtered=executeFilters(street2Param);
  template.query(sql,new Object[]{wildcard + escapeForLike(street1Filtered,'+') + wildcard,wildcard + escapeForLike(street2Filtered,'+') + wildcard},new ResultSetExtractor(){
    /** 
 * @see ResultSetExtractor#extractData(java.sql.ResultSet) 
 */
    public Object extractData(    final ResultSet rs) throws SQLException, DataAccessException {
      while (rs.next()) {
        try {
          final Geometry geom=wktReader.read(rs.getString(""String_Node_Str""));
          if (!geom.isEmpty()) {
            if (geom instanceof Point) {
              ret.add(new IntersectionResult(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""),(Point)geom));
            }
          }
        }
 catch (        final ParseException e) {
          throw new DataRetrievalFailureException(""String_Node_Str"");
        }
      }
      return null;
    }
  }
);
  return ret;
}","/** 
 * @see StreetsDAO#getIntersection(String,String) 
 */
public final Collection<IntersectionResult> getIntersection(final String street1Param,final String street2Param){
  final Collection<IntersectionResult> ret=new ArrayList<IntersectionResult>();
  if ((street1Param != null && street1Param.length() <= 2) || (street2Param != null && street2Param.length() <= 2)) {
    return ret;
  }
  final String wildcard;
  if (street1Param.startsWith(street2Param) || street2Param.startsWith(street1Param)) {
    wildcard=""String_Node_Str"";
  }
 else {
    wildcard=""String_Node_Str"";
  }
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String street1Filtered=executeFilters(street1Param);
  String street2Filtered=executeFilters(street2Param);
  template.query(sql,new Object[]{wildcard + escapeForLike(street1Filtered,'+') + wildcard,wildcard + escapeForLike(street2Filtered,'+') + wildcard},new ResultSetExtractor(){
    /** 
 * @see ResultSetExtractor#extractData(java.sql.ResultSet) 
 */
    public Object extractData(    final ResultSet rs) throws SQLException, DataAccessException {
      while (rs.next()) {
        try {
          final Geometry geom=wktReader.read(rs.getString(""String_Node_Str""));
          if (!geom.isEmpty()) {
            if (geom instanceof Point) {
              ret.add(new IntersectionResult(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""),(Point)geom));
            }
          }
        }
 catch (        final ParseException e) {
          throw new DataRetrievalFailureException(""String_Node_Str"");
        }
      }
      return null;
    }
  }
);
  return ret;
}",0.9945197577156044
154474,"/** 
 * @see StreetsDAO#getIntersection(String,String) 
 */
public final Collection<IntersectionResult> getIntersection(final String street1Param,final String street2Param){
  final Collection<IntersectionResult> ret=new ArrayList<IntersectionResult>();
  if ((street1Param != null && street1Param.length() <= 2) || (street2Param != null && street2Param.length() <= 2)) {
    return ret;
  }
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String street1Filtered=executeFilters(street1Param);
  String street2Filtered=executeFilters(street2Param);
  template.query(sql,new Object[]{""String_Node_Str"" + escapeForLike(street1Filtered,'+') + ""String_Node_Str"",""String_Node_Str"" + escapeForLike(street2Filtered,'+') + ""String_Node_Str""},new ResultSetExtractor(){
    /** 
 * @see ResultSetExtractor#extractData(java.sql.ResultSet) 
 */
    public Object extractData(    final ResultSet rs) throws SQLException, DataAccessException {
      while (rs.next()) {
        try {
          final Geometry geom=wktReader.read(rs.getString(""String_Node_Str""));
          if (!geom.isEmpty()) {
            ret.add(new IntersectionResult(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""),(Point)geom));
          }
        }
 catch (        final ParseException e) {
          throw new DataRetrievalFailureException(""String_Node_Str"");
        }
      }
      return null;
    }
  }
);
  return ret;
}","/** 
 * @see StreetsDAO#getIntersection(String,String) 
 */
public final Collection<IntersectionResult> getIntersection(final String street1Param,final String street2Param){
  final Collection<IntersectionResult> ret=new ArrayList<IntersectionResult>();
  if ((street1Param != null && street1Param.length() <= 2) || (street2Param != null && street2Param.length() <= 2)) {
    return ret;
  }
  final String wildcard;
  if (street1Param.startsWith(street2Param) || street2Param.startsWith(street1Param)) {
    wildcard=""String_Node_Str"";
  }
 else {
    wildcard=""String_Node_Str"";
  }
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String street1Filtered=executeFilters(street1Param);
  String street2Filtered=executeFilters(street2Param);
  template.query(sql,new Object[]{wildcard + escapeForLike(street1Filtered,'+') + wildcard,wildcard + escapeForLike(street2Filtered,'+') + wildcard},new ResultSetExtractor(){
    /** 
 * @see ResultSetExtractor#extractData(java.sql.ResultSet) 
 */
    public Object extractData(    final ResultSet rs) throws SQLException, DataAccessException {
      while (rs.next()) {
        try {
          final Geometry geom=wktReader.read(rs.getString(""String_Node_Str""));
          if (!geom.isEmpty()) {
            if (geom instanceof Point) {
              ret.add(new IntersectionResult(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""),(Point)geom));
            }
          }
        }
 catch (        final ParseException e) {
          throw new DataRetrievalFailureException(""String_Node_Str"");
        }
      }
      return null;
    }
  }
);
  return ret;
}",0.8917748917748918
154475,"/** 
 * Perform adjacency checking against all other active cubes. Send the appropriate notifications if adjacencies are made or broken.
 */
public void updateAdjacencies(){
  int OFFSET_FUZZ=20;
  int DISTANCE_FUZZ=30;
  Cube cube=this.getCube();
  for (  Cube otherCube : Emulator.getCubes()) {
    if (otherCube != cube) {
      CubePanel panel=this;
      CubePanel otherPanel=otherCube.getPanel();
      if (Math.abs(panel.getX() - otherPanel.getX()) < OFFSET_FUZZ && Math.abs(panel.getY() - otherPanel.getY()) < panel.getHeight() + DISTANCE_FUZZ) {
        if (panel.getY() < otherPanel.getY()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
        }
      }
 else {
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,Cube.EDGE_BOTTOM);
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,Cube.EDGE_TOP);
      }
      if (Math.abs(panel.getY() - otherPanel.getY()) < OFFSET_FUZZ && Math.abs(panel.getX() - otherPanel.getX()) < panel.getWidth() + DISTANCE_FUZZ) {
        if (panel.getX() < otherPanel.getX()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
        }
      }
 else {
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,Cube.EDGE_RIGHT);
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,Cube.EDGE_LEFT);
      }
    }
  }
}","/** 
 * Perform adjacency checking against all other active cubes. Send the appropriate notifications if adjacencies are made or broken.
 */
public void updateAdjacencies(){
  int OFFSET_FUZZ=20;
  int DISTANCE_FUZZ=30;
  Cube cube=this.getCube();
  for (  Cube otherCube : Emulator.getCubes()) {
    if (otherCube != cube) {
      CubePanel panel=this;
      CubePanel otherPanel=otherCube.getPanel();
      if (Math.abs(panel.getX() - otherPanel.getX()) < OFFSET_FUZZ && Math.abs(panel.getY() - otherPanel.getY()) < panel.getHeight() + DISTANCE_FUZZ) {
        if (panel.getY() < otherPanel.getY()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
        }
      }
 else {
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
      }
      if (Math.abs(panel.getY() - otherPanel.getY()) < OFFSET_FUZZ && Math.abs(panel.getX() - otherPanel.getX()) < panel.getWidth() + DISTANCE_FUZZ) {
        if (panel.getX() < otherPanel.getX()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
        }
      }
 else {
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
      }
    }
  }
}",0.9729834040910844
154476,"/** 
 * Indicates to the emulator framework that this cube needs to have its virtual screen refreshed. Call after making any change that impacts the current graphics. (Usually called from within a Game subclass.)
 */
public void needsRefresh(){
  this.panel.needsRefresh();
}","/** 
 * Indicates to the emulator framework that this cube needs to have its virtual screen refreshed. Call after making any change that impacts the current graphics. (Usually called from within a Game subclass.)
 */
public void needsRefresh(){
  if (this.panel != null) {
    this.panel.needsRefresh();
  }
}",0.9417808219178082
154477,"public void rotateCounterclockwise(){
  this.rotation=(this.rotation - 1 + 4) % 4;
  this.needsRefresh();
}","public void rotateCounterclockwise(){
  this.rotation=(this.rotation - 1 + 4) % 4;
  Cube tmp=this.adjacent[EDGE_NORTH];
  this.adjacent[EDGE_NORTH]=this.adjacent[EDGE_WEST];
  this.adjacent[EDGE_WEST]=this.adjacent[EDGE_SOUTH];
  this.adjacent[EDGE_SOUTH]=this.adjacent[EDGE_EAST];
  this.adjacent[EDGE_EAST]=tmp;
  for (int i=0; i < 4; i++) {
    if (this.adjacent[i] != null) {
      this.adjacent[i].getPanel().updateAdjacencies();
    }
  }
  this.needsRefresh();
}",0.3050259965337955
154478,"public void rotateClockwise(){
  this.rotation=(this.rotation + 1) % 4;
  this.needsRefresh();
}","public void rotateClockwise(){
  this.rotation=(this.rotation + 1) % 4;
  Cube tmp=this.adjacent[EDGE_NORTH];
  this.adjacent[EDGE_NORTH]=this.adjacent[EDGE_EAST];
  this.adjacent[EDGE_EAST]=this.adjacent[EDGE_SOUTH];
  this.adjacent[EDGE_SOUTH]=this.adjacent[EDGE_WEST];
  this.adjacent[EDGE_WEST]=tmp;
  for (int i=0; i < 4; i++) {
    if (this.adjacent[i] != null) {
      this.adjacent[i].getPanel().updateAdjacencies();
    }
  }
  this.needsRefresh();
}",0.3459459459459459
154479,"/** 
 * Notify this cube that it is no longer adjacent to another Cube along an  absolute edge.
 */
public void separatedCube(Cube cube,int edge){
  assert(this.adjacent[edge] == cube || this.adjacent[edge] == null);
  this.adjacent[edge]=null;
}","/** 
 * Notify this cube that it is no longer adjacent to another Cube along an  absolute edge.
 */
public void separatedCube(Cube cube,int edge){
  assert(this.adjacent[edge] == cube);
  this.adjacent[edge]=null;
}",0.9327548806941433
154480,"@Override public void paint(Graphics g){
  super.paint(g);
  System.out.println(""String_Node_Str"" + CubePanel.this.getCube().getRotationDegrees());
  Graphics2D g2=(Graphics2D)g;
  int xt=0;
  int yt=0;
switch (CubePanel.this.getCube().getRotation()) {
case Cube.ROTATION_90:
    xt=0;
  yt=-128;
break;
case Cube.ROTATION_180:
xt=-128;
yt=-128;
break;
case Cube.ROTATION_270:
xt=-128;
yt=0;
break;
case Cube.ROTATION_0:
default :
xt=0;
yt=0;
break;
}
AffineTransform savedTransform=g2.getTransform();
g2.rotate(Math.toRadians(CubePanel.this.getCube().getRotationDegrees()));
g2.translate(xt,yt);
Emulator.getActiveGame().renderCube(CubePanel.this.cube,g2);
g2.setTransform(savedTransform);
}","@Override public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  int xt=0;
  int yt=0;
switch (CubePanel.this.getCube().getRotation()) {
case Cube.ROTATION_90:
    xt=0;
  yt=-128;
break;
case Cube.ROTATION_180:
xt=-128;
yt=-128;
break;
case Cube.ROTATION_270:
xt=-128;
yt=0;
break;
case Cube.ROTATION_0:
default :
xt=0;
yt=0;
break;
}
AffineTransform savedTransform=g2.getTransform();
g2.rotate(Math.toRadians(CubePanel.this.getCube().getRotationDegrees()));
g2.translate(xt,yt);
Emulator.getActiveGame().renderCube(CubePanel.this.cube,g2);
g2.setTransform(savedTransform);
}",0.9312741312741312
154481,"/** 
 * Perform adjacency checking against all other active cubes. Send the appropriate notifications if adjacencies are made or broken.
 */
public void updateAdjacencies(){
  int OFFSET_FUZZ=20;
  int DISTANCE_FUZZ=30;
  Cube cube=this.getCube();
  for (  Cube otherCube : Emulator.getCubes()) {
    if (otherCube != cube) {
      CubePanel panel=this;
      CubePanel otherPanel=otherCube.getPanel();
      if (Math.abs(panel.getX() - otherPanel.getX()) < OFFSET_FUZZ && Math.abs(panel.getY() - otherPanel.getY()) < panel.getHeight() + DISTANCE_FUZZ) {
        System.out.println(""String_Node_Str"");
        if (panel.getY() < otherPanel.getY()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
        }
      }
 else {
      }
      if (Math.abs(panel.getY() - otherPanel.getY()) < OFFSET_FUZZ && Math.abs(panel.getX() - otherPanel.getX()) < panel.getWidth() + DISTANCE_FUZZ) {
        System.out.println(""String_Node_Str"");
        if (panel.getX() < otherPanel.getX()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
        }
      }
 else {
      }
    }
  }
}","/** 
 * Perform adjacency checking against all other active cubes. Send the appropriate notifications if adjacencies are made or broken.
 */
public void updateAdjacencies(){
  int OFFSET_FUZZ=20;
  int DISTANCE_FUZZ=30;
  Cube cube=this.getCube();
  for (  Cube otherCube : Emulator.getCubes()) {
    if (otherCube != cube) {
      CubePanel panel=this;
      CubePanel otherPanel=otherCube.getPanel();
      if (Math.abs(panel.getX() - otherPanel.getX()) < OFFSET_FUZZ && Math.abs(panel.getY() - otherPanel.getY()) < panel.getHeight() + DISTANCE_FUZZ) {
        if (panel.getY() < otherPanel.getY()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_TOP));
        }
      }
 else {
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_TOP),otherCube,Cube.EDGE_BOTTOM);
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_BOTTOM),otherCube,Cube.EDGE_TOP);
      }
      if (Math.abs(panel.getY() - otherPanel.getY()) < OFFSET_FUZZ && Math.abs(panel.getX() - otherPanel.getX()) < panel.getWidth() + DISTANCE_FUZZ) {
        if (panel.getX() < otherPanel.getX()) {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
        }
 else {
          Emulator.foundAdjacent(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_LEFT));
          Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,otherCube.absoluteEdgeForRelative(Cube.EDGE_RIGHT));
        }
      }
 else {
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_LEFT),otherCube,Cube.EDGE_RIGHT);
        Emulator.foundSeparate(cube,cube.absoluteEdgeForRelative(Cube.EDGE_RIGHT),otherCube,Cube.EDGE_LEFT);
      }
    }
  }
}",0.6141885325558795
154482,"public static void foundAdjacent(Cube c1,int e1,Cube c2,int e2){
  System.out.println(""String_Node_Str"" + c1 + ""String_Node_Str""+ c2);
  if (activeGame != null && c1.adjacencyAlong(e1) == null && c2.adjacencyAlong(e2) == null) {
    activeGame.cubesJoined(c1,e1,c2,e2);
  }
  if (c1.adjacencyAlong(e1) == null) {
    c1.joinedCube(c2,e1);
  }
  if (c2.adjacencyAlong(e2) == null) {
    c2.joinedCube(c1,e2);
  }
}","public static void foundAdjacent(Cube c1,int e1,Cube c2,int e2){
  if (c1.adjacencyAlong(e1) == null && c2.adjacencyAlong(e2) == null) {
    if (activeGame != null) {
      activeGame.cubesJoined(c1,e1,c2,e2);
    }
    c1.joinedCube(c2,e1);
    c2.joinedCube(c1,e2);
  }
}",0.5481049562682215
154483,"public static void foundSeparate(Cube c1,int e1,Cube c2,int e2){
  System.out.println(""String_Node_Str"" + c1 + ""String_Node_Str""+ c2);
  if (activeGame != null && c1.adjacencyAlong(e1).equals(c2) && c2.adjacencyAlong(e2).equals(c1)) {
    activeGame.cubesSeparated(c1,e1,c2,e2);
  }
  if (c1.adjacencyAlong(e1) != null && c1.adjacencyAlong(e1).equals(c2)) {
    c1.separatedCube(c2,e1);
  }
  if (c2.adjacencyAlong(e2) != null && c2.adjacencyAlong(e2).equals(c1)) {
    c2.separatedCube(c1,e2);
  }
}","public static void foundSeparate(Cube c1,int e1,Cube c2,int e2){
  if (c1.adjacencyAlong(e1) == c2 && c2.adjacencyAlong(e2) == c1) {
    if (activeGame != null) {
      activeGame.cubesSeparated(c1,e1,c2,e2);
    }
    c1.separatedCube(c2,e1);
    c2.separatedCube(c1,e2);
  }
}",0.4575835475578406
154484,"public static void removeCube(Cube cube){
  cubes.remove(cube);
  emulatorFrame.removedCube(cube);
}","public static void removeCube(Cube cube){
  cubes.remove(cube);
  if (activeGame != null) {
    activeGame.removedCube(cube);
  }
  emulatorFrame.removedCube(cube);
}",0.7518796992481203
154485,"/** 
 * Do post-initialization startup. Commonly used to register games.
 */
public static void load(){
  registerGame(new NullGame());
  registerGame(new RGBStripeGame());
  registerGame(new ColorBlockGame());
}","/** 
 * Do post-initialization startup. Commonly used to register games.
 */
public static void load(){
  registerGame(new NullGame());
  registerGame(new RGBStripeGame());
  registerGame(new ColorBlockGame());
  registerGame(new AdjacencyTestGame());
  registerGame(new ProximityTestGame());
}",0.8379446640316206
154486,"/** 
 * Add a new cube to active emulation.
 */
public static void addCube(){
  Cube cube=new Cube();
  cubes.add(cube);
  emulatorFrame.addedCube(cube);
}","/** 
 * Add a new cube to active emulation.
 */
public static void addCube(){
  Cube cube=new Cube();
  cubes.add(cube);
  if (activeGame != null) {
    activeGame.addedCube(cube);
  }
  emulatorFrame.addedCube(cube);
}",0.8288770053475936
154487,"@Override public void actionPerformed(ActionEvent e){
  Emulator.quit();
}","@Override public void actionPerformed(ActionEvent e){
  System.out.println(""String_Node_Str"");
  for (  Cube cube : Emulator.getCubes()) {
    for (int i=0; i < 4; i++) {
      System.out.println(Emulator.formatCubeEdge(cube,i) + ""String_Node_Str"" + cube.adjacencyAlong(i));
    }
  }
  System.out.println(""String_Node_Str"");
}",0.3291770573566084
154488,"/** 
 * Construct a new EmulatorFrame with new workspace and control panels.
 */
public EmulatorFrame(){
  super(""String_Node_Str"");
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  this.setSize(1024,768);
  this.workspacePanel=new WorkspacePanel();
  this.controlPanel=new ControlPanel();
  this.getContentPane().add(this.workspacePanel,BorderLayout.CENTER);
  this.getContentPane().add(this.controlPanel,BorderLayout.EAST);
  this.menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  this.menuBar.add(fileMenu);
  JMenuItem quitItem=new JMenuItem(""String_Node_Str"");
  quitItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.CTRL_MASK));
  quitItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Emulator.quit();
    }
  }
);
  fileMenu.add(quitItem);
  this.setJMenuBar(this.menuBar);
}","/** 
 * Construct a new EmulatorFrame with new workspace and control panels.
 */
public EmulatorFrame(){
  super(""String_Node_Str"");
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  this.setSize(1024,768);
  this.workspacePanel=new WorkspacePanel();
  this.controlPanel=new ControlPanel();
  this.getContentPane().add(this.workspacePanel,BorderLayout.CENTER);
  this.getContentPane().add(this.controlPanel,BorderLayout.EAST);
  this.menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  this.menuBar.add(fileMenu);
  JMenuItem quitItem=new JMenuItem(""String_Node_Str"");
  quitItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.CTRL_MASK));
  quitItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Emulator.quit();
    }
  }
);
  fileMenu.add(quitItem);
  JMenu debugMenu=new JMenu(""String_Node_Str"");
  this.menuBar.add(debugMenu);
  JMenuItem adjacencyItem=new JMenuItem(""String_Node_Str"");
  adjacencyItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_D,ActionEvent.CTRL_MASK | ActionEvent.SHIFT_MASK));
  adjacencyItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
      for (      Cube cube : Emulator.getCubes()) {
        for (int i=0; i < 4; i++) {
          System.out.println(Emulator.formatCubeEdge(cube,i) + ""String_Node_Str"" + cube.adjacencyAlong(i));
        }
      }
      System.out.println(""String_Node_Str"");
    }
  }
);
  debugMenu.add(adjacencyItem);
  this.setJMenuBar(this.menuBar);
}",0.7096260938743039
154489,"@NotNull private static Expression parseOneElement(Lexer lexer){
  TokenType tokenType=lexer.getTokenType();
  if (tokenType == null) {
    throw new ParserException(UNEXPECTED_END,lexer.getPrevEnd());
  }
switch (tokenType) {
case NUMBER:
    String text=lexer.getTokenText();
  ExNumber res=new ExNumber(Double.parseDouble(text.replace(',','.')));
lexer.advance();
return res;
case SYMBOL:
if (lexer.getTokenChar() == '(') {
lexer.advance();
Expression expr=parseExpression(lexer);
if (!lexer.isSymbol(')')) throw new ParserException(CLOSED_BRACKET_NOT_FOUND,lexer.getPrevEnd());
lexer.advance();
return expr;
}
throw new ParserException(UNKNOWN_SYMBOL,lexer);
case IDENTIFIER:
{
String name=lexer.getTokenText();
lexer.advance();
if (!lexer.isSymbol('(')) return new ExVariable(name);
lexer.advance();
if (lexer.isSymbol(')')) {
lexer.advance();
return new ExFunction(name);
}
Expression argument=parseExpression(lexer);
Expression[] arguments;
if (lexer.isSymbol(',')) {
List<Expression> list=new ArrayList<Expression>();
list.add(argument);
do {
lexer.advance();
list.add(parseExpression(lexer));
}
 while (lexer.isSymbol(','));
arguments=list.toArray(new Expression[list.size()]);
}
 else if (lexer.isSymbol(')')) {
lexer.advance();
arguments=new Expression[]{argument};
}
 else {
throw new ParserException(CLOSED_BRACKET_NOT_FOUND,lexer);
}
return new ExFunction(name,arguments);
}
default :
throw new RuntimeException();
}
}","@NotNull private static Expression parseOneElement(Lexer lexer){
  TokenType tokenType=lexer.getTokenType();
  if (tokenType == null) {
    throw new ParserException(UNEXPECTED_END,lexer.getPrevEnd());
  }
switch (tokenType) {
case NUMBER:
    String text=lexer.getTokenText();
  ExNumber res=new ExNumber(Double.parseDouble(text.replace(',','.')));
lexer.advance();
return res;
case SYMBOL:
if (lexer.getTokenChar() == '(') {
lexer.advance();
Expression expr=parseExpression(lexer);
if (!lexer.isSymbol(')')) throw new ParserException(CLOSED_BRACKET_NOT_FOUND,lexer.getPrevEnd());
lexer.advance();
return expr;
}
throw new ParserException(UNKNOWN_SYMBOL,lexer);
case IDENTIFIER:
{
String name=lexer.getTokenText();
lexer.advance();
if (!lexer.isSymbol('(')) return new ExVariable(name);
lexer.advance();
if (lexer.isSymbol(')')) {
lexer.advance();
return new ExFunction(name);
}
Expression argument=parseExpression(lexer);
Expression[] arguments;
if (lexer.isSymbol(',')) {
List<Expression> list=new ArrayList<Expression>();
list.add(argument);
do {
lexer.advance();
list.add(parseExpression(lexer));
}
 while (lexer.isSymbol(','));
arguments=list.toArray(new Expression[list.size()]);
}
 else {
arguments=new Expression[]{argument};
}
if (lexer.isSymbol(')')) {
lexer.advance();
}
 else {
throw new ParserException(CLOSED_BRACKET_NOT_FOUND,lexer);
}
return new ExFunction(name,arguments);
}
default :
throw new RuntimeException();
}
}",0.9693165969316596
154490,"private static CharSequence recreateView(String text,int caret,int selectionLength,boolean hasFocus,Highlighter... highlighters){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  ColorModel colorModel=new ColorModel(text.length());
  for (  Highlighter highlighter : highlighters) {
    highlighter.highlight(text,caret,selectionLength,hasFocus,colorModel);
  }
  if (hasFocus) {
    if (selectionLength != 0) {
      colorModel.addStyle(caret,caret + selectionLength,""String_Node_Str"");
    }
 else {
      if (caret < text.length()) {
        colorModel.addStyle(caret,""String_Node_Str"");
      }
    }
  }
  for (int i=0; i < text.length(); ) {
    int next=colorModel.getNextDifferent(i);
    CharSequence style=colorModel.getStyle(i);
    if (style == null) {
      sb.append(text,i,next);
    }
 else {
      sb.append(""String_Node_Str"").append(style).append(""String_Node_Str"");
      sb.append(text,i,next);
      sb.append(""String_Node_Str"");
    }
    i=next;
  }
  if (hasFocus && caret == text.length()) {
    sb.append(""String_Node_Str"");
  }
  sb.append(' ');
  sb.append(""String_Node_Str"");
  return sb;
}","private static CharSequence recreateView(String text,int caret,int selectionLength,boolean hasFocus,Highlighter... highlighters){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  ColorModel colorModel=new ColorModel(text.length());
  for (  Highlighter highlighter : highlighters) {
    highlighter.highlight(text,caret,selectionLength,hasFocus,colorModel);
  }
  if (hasFocus) {
    if (selectionLength != 0) {
      colorModel.addStyle(caret,caret + selectionLength,""String_Node_Str"");
    }
 else {
      if (caret < text.length()) {
        colorModel.addStyle(caret,""String_Node_Str"");
      }
    }
  }
  for (int i=0; i < text.length(); ) {
    int next=colorModel.getNextDifferent(i);
    CharSequence style=colorModel.getStyle(i);
    if (style == null) {
      sb.append(text,i,next);
    }
 else {
      sb.append(""String_Node_Str"").append(style).append(""String_Node_Str"");
      sb.append(text,i,next);
      sb.append(""String_Node_Str"");
    }
    i=next;
  }
  if (hasFocus && caret == text.length()) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb;
}",0.9913119026933102
154491,"@Override public void highlight(@NotNull String text,int caret,int selectionLength,boolean hasFocus,@NotNull ColorModel model){
  if (selectionLength > 0 || !hasFocus)   return;
  if (caret > 0 && text.charAt(caret - 1) == ')') {
    int paired=findParent(text,caret - 1,-1,')','(');
    if (paired == -1) {
      model.addStyle(caret - 1,""String_Node_Str"");
    }
 else {
      model.addStyle(caret - 1,""String_Node_Str"");
      model.addStyle(paired,""String_Node_Str"");
    }
  }
  if (caret < text.length() && text.charAt(caret) == '(') {
    int paired=findParent(text,caret,1,'(',')');
    if (paired == -1) {
      model.addStyle(caret - 1,""String_Node_Str"");
    }
 else {
      model.addStyle(caret,""String_Node_Str"");
      model.addStyle(paired,""String_Node_Str"");
    }
  }
}","@Override public void highlight(@NotNull String text,int caret,int selectionLength,boolean hasFocus,@NotNull ColorModel model){
  if (selectionLength > 0 || !hasFocus)   return;
  if (caret > 0 && text.charAt(caret - 1) == ')') {
    int paired=findParent(text,caret - 1,-1,')','(');
    if (paired == -1) {
      model.addStyle(caret - 1,""String_Node_Str"");
    }
 else {
      model.addStyle(caret - 1,""String_Node_Str"");
      model.addStyle(paired,""String_Node_Str"");
    }
  }
  if (caret < text.length() && text.charAt(caret) == '(') {
    int paired=findParent(text,caret,1,'(',')');
    if (paired == -1) {
      model.addStyle(caret,""String_Node_Str"");
    }
 else {
      model.addStyle(caret,""String_Node_Str"");
      model.addStyle(paired,""String_Node_Str"");
    }
  }
}",0.9974489795918368
154492,"public int getNextDifferent(int index){
  CharSequence first=array[index];
  for (int i=index + 1; i < array.length; i++) {
    if (first == null ? array[i] != null : !first.equals(array[i])) {
      return i;
    }
  }
  return array.length;
}","public int getNextDifferent(int index){
  CharSequence first=array[index];
  for (int i=index + 1; i < array.length; i++) {
    if (first == null ? array[i] != null : !StringUtil.equals(first,array[i])) {
      return i;
    }
  }
  return array.length;
}",0.9579158316633266
154493,"@Override public final void apply(@NotNull Expression expression,Consumer<Expression> consumer){
  if (expression.getClass() != aClass)   return;
  Expression[] expressions=((AbstractMultiargumentExpression)expression).getExpressions();
  for (int i=0; i < expressions.length; i++) {
    Expression e=expressions[i];
    if (e instanceof ExNumber && ((ExNumber)e).isInteger()) {
      for (int k=i + 1; k < expressions.length; k++) {
        Expression e2=expressions[k];
        if (e2 instanceof ExNumber && ((ExNumber)e2).isInteger()) {
          double sum=sum(((ExNumber)e).getValue(),((ExNumber)e2).getValue());
          if (expressions.length == 2) {
            consumer.consume(new ExNumber(sum));
            return;
          }
          Expression[] m=new Expression[expressions.length - 1];
          m[0]=new ExNumber(sum);
          int pos=1;
          for (int j=0; j < expressions.length; j++) {
            if (j != i && j != k) {
              m[pos++]=expressions[j];
            }
          }
          consumer.consume(new ExSum(m));
        }
      }
    }
  }
}","@Override public final void apply(@NotNull Expression expression,Consumer<Expression> consumer){
  if (expression.getClass() != aClass)   return;
  AbstractMultiargumentExpression abstractExpression=(AbstractMultiargumentExpression)expression;
  Expression[] expressions=abstractExpression.getExpressions();
  for (int i=0; i < expressions.length; i++) {
    Expression e=expressions[i];
    if (e instanceof ExNumber && ((ExNumber)e).isInteger()) {
      for (int k=i + 1; k < expressions.length; k++) {
        Expression e2=expressions[k];
        if (e2 instanceof ExNumber && ((ExNumber)e2).isInteger()) {
          double sum=sum(((ExNumber)e).getValue(),((ExNumber)e2).getValue());
          if (expressions.length == 2) {
            consumer.consume(new ExNumber(sum));
            return;
          }
          Expression[] m=new Expression[expressions.length - 1];
          m[0]=new ExNumber(sum);
          int pos=1;
          for (int j=0; j < expressions.length; j++) {
            if (j != i && j != k) {
              m[pos++]=expressions[j];
            }
          }
          consumer.consume(abstractExpression.createInstance(m));
        }
      }
    }
  }
}",0.9105332745702952
154494,"@Override public final void apply(@NotNull Expression expression,Consumer<Expression> consumer){
  if (!(expression instanceof ExMul)) {
    return;
  }
  Expression[] expressions=((ExMul)expression).getExpressions();
  for (int i=0; i < expressions.length; i++) {
    Expression e=expressions[i];
    Expression e1x=getX(e);
    Expression e1Level=getLevel(e);
    for (int k=i + 1; k < expressions.length; k++) {
      Expression e2=expressions[k];
      Expression e2x=getX(e2);
      Expression e2Level=getLevel(e2);
      if (e1x.orderIndependentEquals(e2x)) {
        consumer.consume(new ExPower(e1x,newExSum(e1Level,e2Level)));
      }
    }
  }
}","@Override public final void apply(@NotNull Expression expression,Consumer<Expression> consumer){
  if (!(expression instanceof ExMul)) {
    return;
  }
  Expression[] expressions=((ExMul)expression).getExpressions();
  for (int i=0; i < expressions.length; i++) {
    Expression e=expressions[i];
    Expression e1x=getX(e);
    Expression e1Level=getLevel(e);
    for (int k=i + 1; k < expressions.length; k++) {
      Expression e2=expressions[k];
      Expression e2x=getX(e2);
      if (e1x.orderIndependentEquals(e2x)) {
        Expression e2Level=getLevel(e2);
        Expression[] ee=ArrayUtils.removeAt(expressions,k);
        ee[i]=new ExPower(e1x,newExSum(e1Level,e2Level));
        consumer.consume(ExMul.newExMul(ee));
      }
    }
  }
}",0.8321479374110953
154495,"public void testSum(){
  doTest(""String_Node_Str"",new ExNumber(4));
  doTest(""String_Node_Str"",new ExNumber(20));
  doTest(""String_Node_Str"",new ExNumber(10));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
}","public void testSum(){
  doTest(""String_Node_Str"",new ExNumber(4));
  doTest(""String_Node_Str"",new ExNumber(20));
  doTest(""String_Node_Str"",new ExNumber(10));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
  doTest(""String_Node_Str"",Parser.parseExpression(""String_Node_Str""));
}",0.960838389409818
154496,"public void appendToSum(StringBuilder sb){
  if (expressions.length == 1) {
    toString(sb);
  }
 else {
    for (int i=0; i < expressions.length; i++) {
      Expression e=expressions[i];
      if (e instanceof ExNumber && ((ExNumber)e).isNegative()) {
        sb.append('-');
        append(sb,i);
        return;
      }
    }
    sb.append('+');
    append(sb,-1);
  }
}","public void appendToSum(StringBuilder sb,boolean isFirst){
  if (expressions.length == 1) {
    toString(sb);
  }
 else {
    for (int i=0; i < expressions.length; i++) {
      Expression e=expressions[i];
      if (e instanceof ExNumber && ((ExNumber)e).isNegative()) {
        sb.append('-');
        append(sb,i);
        return;
      }
    }
    if (!isFirst) {
      sb.append('+');
    }
    append(sb,-1);
  }
}",0.9445843828715366
154497,"@Override protected void toString(StringBuilder sb){
  for (int i=0; i < expressions.length; i++) {
    Expression expression=expressions[i];
    if (expression instanceof ExNumber) {
      if (((ExNumber)expression).isNegative()) {
        expression.toString(sb);
      }
 else {
        if (i > 0) {
          sb.append('+');
        }
        expression.toString(sb,getPriority());
      }
    }
 else     if (expression instanceof ExMul) {
      ((ExMul)expression).appendToSum(sb);
    }
 else {
      if (i > 0) {
        sb.append('+');
      }
      sb.append('+');
      expression.toString(sb,getPriority());
    }
  }
}","@Override protected void toString(StringBuilder sb){
  for (int i=0; i < expressions.length; i++) {
    Expression expression=expressions[i];
    if (expression instanceof ExNumber) {
      if (((ExNumber)expression).isNegative()) {
        expression.toString(sb);
      }
 else {
        if (i > 0) {
          sb.append('+');
        }
        expression.toString(sb,getPriority());
      }
    }
 else     if (expression instanceof ExMul) {
      ((ExMul)expression).appendToSum(sb,i == 0);
    }
 else {
      if (i > 0) {
        sb.append('+');
      }
      expression.toString(sb,getPriority());
    }
  }
}",0.9767441860465116
154498,"@NotNull private static Expression getOneElement(Lexer lexer){
  TokenType tokenType=lexer.getTokenType();
  if (tokenType == null) {
    throw new ParserException(""String_Node_Str"",lexer);
  }
switch (tokenType) {
case NUMBER:
    ExNumber res=new ExNumber(Double.parseDouble(lexer.getTokenText()));
  lexer.advance();
return res;
case SYMBOL:
if (lexer.getTokenChar() == '(') {
lexer.advance();
Expression expr=getSum(lexer);
if (!lexer.isSymbol(')')) throw new ParserException(lexer);
lexer.advance();
return expr;
}
throw new ParserException(""String_Node_Str"",lexer);
case IDENTIFIER:
{
String text=lexer.getTokenText();
lexer.advance();
if (!lexer.isSymbol('(')) return new ExVariable(text);
lexer.advance();
Expression argument=getSum(lexer);
if (!lexer.isSymbol(')')) throw new ParserException(lexer);
return new ExFunction(text,argument);
}
default :
throw new RuntimeException();
}
}","@NotNull private static Expression getOneElement(Lexer lexer){
  TokenType tokenType=lexer.getTokenType();
  if (tokenType == null) {
    throw new ParserException(""String_Node_Str"",lexer);
  }
switch (tokenType) {
case NUMBER:
    ExNumber res=new ExNumber(Double.parseDouble(lexer.getTokenText()));
  lexer.advance();
return res;
case SYMBOL:
if (lexer.getTokenChar() == '(') {
lexer.advance();
Expression expr=getSum(lexer);
if (!lexer.isSymbol(')')) throw new ParserException(lexer);
lexer.advance();
return expr;
}
throw new ParserException(""String_Node_Str"",lexer);
case IDENTIFIER:
{
String text=lexer.getTokenText();
lexer.advance();
if (!lexer.isSymbol('(')) return new ExVariable(text);
lexer.advance();
Expression argument=getSum(lexer);
if (!lexer.isSymbol(')')) throw new ParserException(lexer);
lexer.advance();
return new ExFunction(text,argument);
}
default :
throw new RuntimeException();
}
}",0.9905607995558025
154499,"public void testTestCalculate(){
  doTest(""String_Node_Str"",12);
  doTest(""String_Node_Str"",3);
  doTest(""String_Node_Str"",11);
  doTest(""String_Node_Str"",11);
  doTest(""String_Node_Str"",-9);
  doTest(""String_Node_Str"",12);
  doTest(""String_Node_Str"",-4);
  doTest(""String_Node_Str"",256);
}","public void testTestCalculate(){
  doTest(""String_Node_Str"",1);
  doTest(""String_Node_Str"",1);
}",0.4974093264248704
154500,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.skeleton_activity);
  mPreview=((SurfaceView)findViewById(R.id.streamingVideo));
  holder=mPreview.getHolder();
  holder.addCallback(this);
  holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
  try {
    sock=new Socket(""String_Node_Str"",666);
    input=new DataInputStream(sock.getInputStream());
    output=new DataOutputStream(sock.getOutputStream());
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.skeleton_activity);
  mPreview=((SurfaceView)findViewById(R.id.streamingVideo));
  holder=mPreview.getHolder();
  holder.addCallback(this);
  holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
}",0.7253588516746412
154501,"@Override public void surfaceDestroyed(SurfaceHolder holder){
  try {
    output.close();
    input.close();
    sock.close();
  }
 catch (  IOException e) {
    System.out.println(e);
  }
}","@Override public void surfaceDestroyed(SurfaceHolder holder){
}",0.4980237154150198
154502,"public void destroy(){
  if (material == EnumBowMaterial.ICE) {
    int radius=3;
    int radiusSq=(int)Math.pow(radius,2.0D);
    World world=getBukkitEntity().getWorld();
    for (int x=getBukkitEntity().getLocation().getBlockX() - radius; x <= getBukkitEntity().getLocation().getBlockX() + radius; x++) {
      for (int z=getBukkitEntity().getLocation().getBlockZ() - radius; z <= getBukkitEntity().getLocation().getBlockZ() + radius; z++) {
        if (new Vector(x,getBukkitEntity().getLocation().getBlockY(),z).distanceSquared(new Vector(getBukkitEntity().getLocation().getX(),getBukkitEntity().getLocation().getY(),getBukkitEntity().getLocation().getZ())) > radiusSq) {
          continue;
        }
        if ((new Random()).nextInt(4) > 0) {
          continue;
        }
        for (int y=getBukkitEntity().getLocation().getBlockY() + radius; y >= getBukkitEntity().getLocation().getBlockY() - radius; y--) {
          int id=world.getBlockTypeIdAt(x,y,z);
          if ((id == 6) || (id == 10) || (id == 11)|| (id == 37)|| (id == 38)|| (id == 39)|| (id == 40)|| (id == 44)|| (id == 50)|| (id == 51)|| (id == 53)|| (id == 55)|| (id == 59)|| ((id >= 63) && (id <= 72))|| (id == 75)|| (id == 76)|| (id == 77)|| (id == 78)|| (id == 79)|| (id == 81)|| (id == 83)|| (id == 85)|| (id == 90)) {
            break;
          }
          if ((id == 8) || (id == 9)) {
            world.getBlockAt(x,y,z).setTypeId(79);
            break;
          }
          if (id != 0) {
            if (y == 127) {
              break;
            }
            world.getBlockAt(x,y + 1,z).setTypeId(78);
            break;
          }
        }
      }
    }
  }
 else   if (material == EnumBowMaterial.FIRE) {
    World world=getBukkitEntity().getWorld();
    world.getBlockAt((int)locX,(int)locY,(int)locZ).setType(Material.FIRE);
  }
 else   if (material == EnumBowMaterial.TNT) {
    EntityTNTPrimed tnt=new EntityTNTPrimed(this.world,locX,locY,locZ);
    tnt.a=0;
    world.addEntity(tnt);
    tnt.f_();
  }
 else   if (material == EnumBowMaterial.THUNDER) {
    World world=getBukkitEntity().getWorld();
    world.strikeLightning(new Location(world,locX,locY,locZ));
  }
 else   if (material == EnumBowMaterial.MONSTER) {
    World world=getBukkitEntity().getWorld();
    CreatureType[] types={CreatureType.CREEPER,CreatureType.SKELETON,CreatureType.SLIME,CreatureType.SPIDER,CreatureType.ZOMBIE};
    world.spawnCreature(getBukkitEntity().getLocation(),types[(new Random()).nextInt(5)]);
  }
 else   if (material == EnumBowMaterial.TREE) {
    World world=getBukkitEntity().getWorld();
    Location loc=getBukkitEntity().getLocation();
    world.generateTree(loc,TreeType.TREE);
  }
 else   if (material == EnumBowMaterial.ZEUS) {
    Location loc=getBukkitEntity().getLocation();
    World worldf=loc.getWorld();
    worldf.strikeLightning(loc);
    loc.getBlock().setType(Material.FIRE);
    EntityTNTPrimed tnt=new EntityTNTPrimed(this.world,locX,locY,locZ);
    tnt.a=0;
    world.addEntity(tnt);
    tnt.f_();
  }
}","public void destroy(){
  if (material == EnumBowMaterial.ICE) {
    int radius=3;
    int radiusSq=(int)Math.pow(radius,2.0D);
    World world=getBukkitEntity().getWorld();
    for (int x=getBukkitEntity().getLocation().getBlockX() - radius; x <= getBukkitEntity().getLocation().getBlockX() + radius; x++) {
      for (int z=getBukkitEntity().getLocation().getBlockZ() - radius; z <= getBukkitEntity().getLocation().getBlockZ() + radius; z++) {
        if (new Vector(x,getBukkitEntity().getLocation().getBlockY(),z).distanceSquared(new Vector(getBukkitEntity().getLocation().getX(),getBukkitEntity().getLocation().getY(),getBukkitEntity().getLocation().getZ())) > radiusSq) {
          continue;
        }
        if ((new Random()).nextInt(4) > 0) {
          continue;
        }
        for (int y=getBukkitEntity().getLocation().getBlockY() + radius; y >= getBukkitEntity().getLocation().getBlockY() - radius; y--) {
          int id=world.getBlockTypeIdAt(x,y,z);
          if ((id == 6) || (id == 10) || (id == 11)|| (id == 37)|| (id == 38)|| (id == 39)|| (id == 40)|| (id == 44)|| (id == 50)|| (id == 51)|| (id == 53)|| (id == 55)|| (id == 59)|| ((id >= 63) && (id <= 72))|| (id == 75)|| (id == 76)|| (id == 77)|| (id == 78)|| (id == 79)|| (id == 81)|| (id == 83)|| (id == 85)|| (id == 90)) {
            break;
          }
          if ((id == 8) || (id == 9)) {
            world.getBlockAt(x,y,z).setTypeId(79);
            break;
          }
          if (id != 0) {
            if (y == 127) {
              break;
            }
            world.getBlockAt(x,y + 1,z).setTypeId(78);
            break;
          }
        }
      }
    }
  }
 else   if (material == EnumBowMaterial.FIRE) {
    World world=getBukkitEntity().getWorld();
    world.getBlockAt((int)locX,(int)locY,(int)locZ).setType(Material.FIRE);
  }
 else   if (material == EnumBowMaterial.TNT) {
    EntityTNTPrimed tnt=new EntityTNTPrimed(this.world,locX,locY,locZ);
    tnt.a=0;
    world.addEntity(tnt);
    tnt.f_();
  }
 else   if (material == EnumBowMaterial.THUNDER) {
    World world=getBukkitEntity().getWorld();
    world.strikeLightning(new Location(world,locX,locY,locZ));
  }
 else   if (material == EnumBowMaterial.MONSTER) {
    World world=getBukkitEntity().getWorld();
    CreatureType[] types={CreatureType.CREEPER,CreatureType.SKELETON,CreatureType.SLIME,CreatureType.SPIDER,CreatureType.ZOMBIE};
    world.spawnCreature(getBukkitEntity().getLocation(),types[(new Random()).nextInt(5)]);
  }
 else   if (material == EnumBowMaterial.TREE) {
    World world=getBukkitEntity().getWorld();
    Location loc=getBukkitEntity().getLocation();
    world.generateTree(loc,TreeType.TREE);
  }
 else   if (material == EnumBowMaterial.ZEUS) {
    Location loc=getBukkitEntity().getLocation();
    World worldf=loc.getWorld();
    worldf.strikeLightning(loc);
    loc.getBlock().setType(Material.FIRE);
    EntityTNTPrimed tnt=new EntityTNTPrimed(this.world,locX,locY,locZ);
    tnt.a=0;
    world.addEntity(tnt);
    tnt.f_();
  }
 else   if (material == EnumBowMaterial.THRICE) {
    die();
  }
}",0.9893495002457808
154503,"public void onPlayerInteract(PlayerInteractEvent event){
  if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
    Player p=event.getPlayer();
    ItemStack item=p.getItemInHand();
    if (item.getType() == Material.BOW) {
      Material id=event.getClickedBlock().getType();
      Material id2=event.getClickedBlock().getRelative(0,1,0).getType();
      EnumBowMaterial bm=null;
      if (id == Material.WOOD || id == Material.LOG) {
        bm=EnumBowMaterial.STANDARD;
      }
      if (id == Material.SNOW || id == Material.ICE) {
        bm=EnumBowMaterial.ICE;
      }
      if (id2 == Material.FIRE) {
        bm=EnumBowMaterial.FIRE;
      }
      if (id == Material.TNT) {
        bm=EnumBowMaterial.TNT;
      }
      if (id == Material.REDSTONE_ORE) {
        bm=EnumBowMaterial.THUNDER;
      }
      if (id == Material.MOB_SPAWNER) {
        bm=EnumBowMaterial.MONSTER;
      }
      if (id == Material.DISPENSER) {
        bm=EnumBowMaterial.THRICE;
      }
      if (id == Material.LAPIS_BLOCK) {
        bm=EnumBowMaterial.ZOMBIE;
      }
      if (bm != null) {
        if (bm.getDataValue() == EnumBowMaterial.fromData(item.getDurability()).getDataValue()) {
          return;
        }
        item.setDurability(bm.getDataValue());
        p.sendMessage(""String_Node_Str"" + bm.getName() + ""String_Node_Str"");
      }
    }
  }
  if (event.getAction() == Action.RIGHT_CLICK_AIR || event.getAction() == Action.RIGHT_CLICK_BLOCK) {
    Player p=event.getPlayer();
    ItemStack item=p.getItemInHand();
    if (item.getType() == Material.BOW) {
      event.setUseInteractedBlock(Result.DENY);
      event.setCancelled(true);
      EnumBowMaterial material=EnumBowMaterial.fromData(item.getDurability());
      if (!Archers.Permissions.has(p,""String_Node_Str"" + material.getName().toLowerCase())) {
        return;
      }
      int has=0;
      for (      ItemStack stack : Properties.ArrowAmmo.get(material.getDataValue())) {
        int amount=0;
        for (int i=0; i < p.getInventory().getContents().length; i++) {
          if (p.getInventory().getContents()[i] == null) {
            continue;
          }
          if (p.getInventory().getContents()[i].getTypeId() == stack.getTypeId()) {
            amount+=p.getInventory().getContents()[i].getAmount();
          }
          if (amount >= stack.getAmount()) {
            ++has;
            break;
          }
        }
      }
      if (has != Properties.ArrowAmmo.get(material.getDataValue()).size())       return;
      Arrow arrow=new Arrow(p.getWorld(),p,material);
      ArrowHandler.onArrowCreate(p,arrow);
      for (      ItemStack stack : Properties.ArrowAmmo.get(material.getDataValue())) {
        CraftUpdate.removeItem(p,stack);
      }
    }
  }
}","public void onPlayerInteract(PlayerInteractEvent event){
  if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
    Player p=event.getPlayer();
    ItemStack item=p.getItemInHand();
    if (item.getType() == Material.BOW) {
      Material id=event.getClickedBlock().getType();
      Material id2=event.getClickedBlock().getRelative(0,1,0).getType();
      EnumBowMaterial bm=null;
      if (id == Material.WOOD || id == Material.LOG) {
        bm=EnumBowMaterial.STANDARD;
      }
      if (id == Material.SNOW || id == Material.ICE) {
        bm=EnumBowMaterial.ICE;
      }
      if (id2 == Material.FIRE) {
        bm=EnumBowMaterial.FIRE;
      }
      if (id == Material.TNT) {
        bm=EnumBowMaterial.TNT;
      }
      if (id == Material.REDSTONE_ORE) {
        bm=EnumBowMaterial.THUNDER;
      }
      if (id == Material.MOB_SPAWNER) {
        bm=EnumBowMaterial.MONSTER;
      }
      if (id == Material.DISPENSER) {
        bm=EnumBowMaterial.THRICE;
      }
      if (id == Material.LAPIS_BLOCK) {
        bm=EnumBowMaterial.ZOMBIE;
      }
      if (bm != null) {
        if (bm.getDataValue() == EnumBowMaterial.fromData(item.getDurability()).getDataValue()) {
          return;
        }
        item.setDurability(bm.getDataValue());
        p.sendMessage(ChatColor.DARK_GREEN + ""String_Node_Str"" + ChatColor.YELLOW+ bm.getName()+ ChatColor.DARK_GREEN+ ""String_Node_Str"");
      }
    }
  }
  if (event.getAction() == Action.RIGHT_CLICK_AIR || event.getAction() == Action.RIGHT_CLICK_BLOCK) {
    Player p=event.getPlayer();
    ItemStack item=p.getItemInHand();
    if (item.getType() == Material.BOW) {
      event.setUseInteractedBlock(Result.DENY);
      event.setCancelled(true);
      EnumBowMaterial material=EnumBowMaterial.fromData(item.getDurability());
      if (!Archers.Permissions.has(p,""String_Node_Str"" + material.getName().toLowerCase())) {
        return;
      }
      int has=0;
      for (      ItemStack stack : Properties.ArrowAmmo.get(material.getDataValue())) {
        int amount=0;
        for (int i=0; i < p.getInventory().getContents().length; i++) {
          if (p.getInventory().getContents()[i] == null) {
            continue;
          }
          if (p.getInventory().getContents()[i].getTypeId() == stack.getTypeId()) {
            amount+=p.getInventory().getContents()[i].getAmount();
          }
          if (amount >= stack.getAmount()) {
            ++has;
            break;
          }
        }
      }
      if (has != Properties.ArrowAmmo.get(material.getDataValue()).size()) {
        p.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return;
      }
      Arrow arrow=new Arrow(p.getWorld(),p,material);
      ArrowHandler.onArrowCreate(p,arrow);
      for (      ItemStack stack : Properties.ArrowAmmo.get(material.getDataValue())) {
        CraftUpdate.removeItem(p,stack);
      }
    }
  }
}",0.9714896650035638
154504,"public void onItemHeldChange(PlayerItemHeldEvent event){
  Player p=event.getPlayer();
  ItemStack item=p.getInventory().getContents()[event.getNewSlot()];
  if (item == null) {
    return;
  }
  if (item.getType() == Material.BOW) {
    p.sendMessage(""String_Node_Str"" + EnumBowMaterial.fromData(item.getDurability()).getName());
  }
}","public void onItemHeldChange(PlayerItemHeldEvent event){
  Player p=event.getPlayer();
  ItemStack item=p.getInventory().getContents()[event.getNewSlot()];
  if (item == null) {
    return;
  }
  if (item.getType() == Material.BOW) {
    p.sendMessage(ChatColor.DARK_GREEN + ""String_Node_Str"" + ChatColor.YELLOW+ EnumBowMaterial.fromData(item.getDurability()).getName());
  }
}",0.9424964936886396
154505,"public static void processDir(Path inputDir,Path outputFile,String packageName){
  areDirs(inputDir);
  G4JVisitor g4jVisitor=new G4JVisitor();
  try {
    Files.walkFileTree(inputDir,g4jVisitor);
  }
 catch (  IOException ex) {
    Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
  }
  String code=g4jVisitor.getFinalCode();
  G4J g4j=new G4J();
  code=g4j.process(code);
  code=""String_Node_Str"" + packageName + ""String_Node_Str""+ code;
  if (!Files.exists(outputFile.getParent())) {
    try {
      Files.createDirectories(outputFile.getParent());
    }
 catch (    IOException ex) {
      Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  try {
    Files.write(outputFile,code.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException ex) {
    Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  IOException ex) {
    Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
  }
}","public static void processDir(Path inputDir,Path outputFile,String packageName){
  areDirs(inputDir);
  G4JVisitor g4jVisitor=new G4JVisitor();
  try {
    Files.walkFileTree(inputDir,g4jVisitor);
  }
 catch (  IOException ex) {
    Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
  }
  String code=g4jVisitor.getFinalCode();
  G4J g4j=new G4J();
  code=g4j.process(code);
  code=""String_Node_Str"" + packageName + ""String_Node_Str""+ code;
  Path outputParent=outputFile.getParent();
  if (!Files.exists(outputFile.toAbsolutePath().getParent())) {
    try {
      Files.createDirectories(outputFile.getParent());
    }
 catch (    IOException ex) {
      Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  try {
    Files.write(outputFile,code.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException ex) {
    Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  IOException ex) {
    Logger.getLogger(G4JUtil.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.9702293801854563
154506,"public Integer start(String[] args){
  try {
    StartupHealthCheck startupHealthCheck=new StartupHealthCheck(rules());
    Jetty6WebServer webServer=new Jetty6WebServer();
    server=new NeoServerWithEmbeddedWebServer(getGraphDatabaseFactory(),new AddressResolver(),startupHealthCheck,getConfigFile(),webServer,getServerModules());
    server.start();
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        log.info(""String_Node_Str"");
        if (server != null) {
          server.stop();
        }
      }
    }
);
    return OK;
  }
 catch (  TransactionFailureException tfe) {
    tfe.printStackTrace();
    log.error(String.format(""String_Node_Str"",server.getWebServerPort()) + tfe + ""String_Node_Str""+ server.getDatabase().getLocation());
    return GRAPH_DATABASE_STARTUP_ERROR_CODE;
  }
catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"",server.getWebServerPort());
    return WEB_SERVER_STARTUP_ERROR_CODE;
  }
}","public Integer start(String[] args){
  try {
    StartupHealthCheck startupHealthCheck=new StartupHealthCheck(rules());
    Jetty6WebServer webServer=new Jetty6WebServer();
    server=new NeoServerWithEmbeddedWebServer(getGraphDatabaseFactory(),new AddressResolver(),startupHealthCheck,getConfigFile(),webServer,getServerModules());
    server.start();
    log.info(""String_Node_Str"",server.baseUri());
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        log.info(""String_Node_Str"");
        if (server != null) {
          server.stop();
        }
      }
    }
);
    return OK;
  }
 catch (  TransactionFailureException tfe) {
    tfe.printStackTrace();
    log.error(String.format(""String_Node_Str"",server.getWebServerPort()) + tfe + ""String_Node_Str""+ server.getDatabase().getLocation());
    return GRAPH_DATABASE_STARTUP_ERROR_CODE;
  }
catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"",server.getWebServerPort());
    return WEB_SERVER_STARTUP_ERROR_CODE;
  }
}",0.9755142017629774
154507,"private static void configureLogging(){
  String log4jConfigPath=System.getProperty(KEY_LOG4J_CONFIG_XML_PATH);
  if (log4jConfigPath != null) {
    DOMConfigurator.configure(log4jConfigPath);
    System.out.println(""String_Node_Str"" + log4jConfigPath);
  }
 else {
    BasicConfigurator.configure();
    System.out.println(""String_Node_Str"");
  }
}","private static void configureLogging(){
  SysOutOverSLF4J.sendSystemOutAndErrToSLF4J();
}",0.2876712328767123
154508,"Config(GraphDatabaseService graphDb,String storeDir,StoreId storeId,Map<String,String> inputParams,KernelPanicEventGenerator kpe,TxModule txModule,LockManager lockManager,LockReleaser lockReleaser,IdGeneratorFactory idGeneratorFactory,TxEventSyncHookFactory txSyncHookFactory,RelationshipTypeCreator relTypeCreator,TxIdGenerator txIdGenerator,LastCommittedTxIdSetter lastCommittedTxIdSetter,FileSystemAbstraction fileSystem,LogBufferFactory logBufferFactory){
  this.storeDir=storeDir;
  this.inputParams=inputParams;
  this.idGeneratorFactory=idGeneratorFactory;
  this.relTypeCreator=relTypeCreator;
  this.txIdGenerator=txIdGenerator;
  this.params=getDefaultParams();
  params.put(FileSystemAbstraction.class,fileSystem);
  this.txModule=txModule;
  this.lockManager=lockManager;
  this.lockReleaser=lockReleaser;
  this.idGeneratorModule=new IdGeneratorModule(new IdGenerator());
  this.readOnly=Boolean.parseBoolean((String)params.get(READ_ONLY));
  this.backupSlave=Boolean.parseBoolean((String)params.get(BACKUP_SLAVE));
  this.syncHookFactory=txSyncHookFactory;
  this.persistenceModule=new PersistenceModule();
  this.cacheManager=new AdaptiveCacheManager();
  params.put(LogBufferFactory.class,logBufferFactory);
  graphDbModule=new GraphDbModule(graphDb,cacheManager,lockManager,txModule.getTxManager(),idGeneratorModule.getIdGenerator(),readOnly);
  indexStore=new IndexStore(storeDir);
  params.put(IndexStore.class,indexStore);
  if (storeId != null)   params.put(StoreId.class,storeId);
  params.put(IdGeneratorFactory.class,idGeneratorFactory);
  params.put(TxIdGenerator.class,txIdGenerator);
  params.put(TransactionManager.class,txModule.getTxManager());
  params.put(LastCommittedTxIdSetter.class,lastCommittedTxIdSetter);
  params.put(GraphDbModule.class,graphDbModule);
}","Config(GraphDatabaseService graphDb,String storeDir,StoreId storeId,Map<String,String> inputParams,KernelPanicEventGenerator kpe,TxModule txModule,LockManager lockManager,LockReleaser lockReleaser,IdGeneratorFactory idGeneratorFactory,TxEventSyncHookFactory txSyncHookFactory,RelationshipTypeCreator relTypeCreator,TxIdGenerator txIdGenerator,LastCommittedTxIdSetter lastCommittedTxIdSetter,FileSystemAbstraction fileSystem){
  this.storeDir=storeDir;
  this.inputParams=inputParams;
  this.params=getDefaultParams();
  this.params.putAll(inputParams);
  this.idGeneratorFactory=idGeneratorFactory;
  this.relTypeCreator=relTypeCreator;
  this.txIdGenerator=txIdGenerator;
  this.txModule=txModule;
  this.lockManager=lockManager;
  this.lockReleaser=lockReleaser;
  this.idGeneratorModule=new IdGeneratorModule(new IdGenerator());
  this.readOnly=Boolean.parseBoolean((String)params.get(READ_ONLY));
  this.backupSlave=Boolean.parseBoolean((String)params.get(BACKUP_SLAVE));
  this.syncHookFactory=txSyncHookFactory;
  this.persistenceModule=new PersistenceModule();
  this.cacheManager=new AdaptiveCacheManager();
  this.params.put(FileSystemAbstraction.class,fileSystem);
  graphDbModule=new GraphDbModule(graphDb,cacheManager,lockManager,txModule.getTxManager(),idGeneratorModule.getIdGenerator(),readOnly);
  indexStore=new IndexStore(storeDir);
  params.put(IndexStore.class,indexStore);
  if (storeId != null)   params.put(StoreId.class,storeId);
  params.put(IdGeneratorFactory.class,idGeneratorFactory);
  params.put(TxIdGenerator.class,txIdGenerator);
  params.put(TransactionManager.class,txModule.getTxManager());
  params.put(LastCommittedTxIdSetter.class,lastCommittedTxIdSetter);
  params.put(GraphDbModule.class,graphDbModule);
}",0.827352359423566
154509,"public static Map<Object,Object> getDefaultParams(){
  Map<Object,Object> params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  if (osIsWindows()) {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,""String_Node_Str"");
  }
  return params;
}","public static Map<Object,Object> getDefaultParams(){
  Map<Object,Object> params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  if (osIsWindows()) {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,""String_Node_Str"");
  }
 else {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,""String_Node_Str"");
  }
  return params;
}",0.9098228663446056
154510,"public synchronized Node next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  Node nextNode=currentNode;
  currentNode=null;
  return nextNode;
}","@Override public synchronized Node next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  Node nextNode=currentNode;
  currentNode=null;
  return nextNode;
}",0.9707602339181286
154511,"public void remove(){
  throw new UnsupportedOperationException();
}","@Override public void remove(){
  throw new UnsupportedOperationException();
}",0.9315068493150684
154512,"public Iterable<Node> getAllNodes(){
  return new Iterable<Node>(){
    public Iterator<Node> iterator(){
      long highId=nodeManager.getHighestPossibleIdInUse(Node.class);
      return new AllNodesIterator(highId);
    }
  }
;
}","public Iterable<Node> getAllNodes(){
  return new Iterable<Node>(){
    @Override public Iterator<Node> iterator(){
      long highId=nodeManager.getHighestPossibleIdInUse(Node.class);
      return new AllNodesIterator(highId);
    }
  }
;
}",0.9788135593220338
154513,"public Iterator<Node> iterator(){
  long highId=nodeManager.getHighestPossibleIdInUse(Node.class);
  return new AllNodesIterator(highId);
}","@Override public Iterator<Node> iterator(){
  long highId=nodeManager.getHighestPossibleIdInUse(Node.class);
  return new AllNodesIterator(highId);
}",0.9652777777777778
154514,"public void load(){
  extensions.loadExtensions(loaded,msgLog);
}","@Override public void load(){
  extensions.loadExtensions(loaded,msgLog);
}",0.9285714285714286
154515,"public TransactionEventsSyncHook create(){
  return transactionEventHandlers.isEmpty() ? null : new TransactionEventsSyncHook(nodeManager,transactionEventHandlers,getConfig().getTxModule().getTxManager());
}","@Override public TransactionEventsSyncHook create(){
  return transactionEventHandlers.isEmpty() ? null : new TransactionEventsSyncHook(nodeManager,transactionEventHandlers,getConfig().getTxModule().getTxManager());
}",0.9764150943396226
154516,"/** 
 * A non-standard way of creating an embedded   {@link GraphDatabaseService}with a set of configuration parameters. Will most likely be removed in future releases.
 * @param storeDir the store directory for the db files
 * @param fileSystem 
 * @param config configuration parameters
 */
public EmbeddedGraphDbImpl(String storeDir,StoreId storeId,Map<String,String> inputParams,GraphDatabaseService graphDbService,LockManagerFactory lockManagerFactory,IdGeneratorFactory idGeneratorFactory,RelationshipTypeCreator relTypeCreator,TxIdGeneratorFactory txIdFactory,TxFinishHook finishHook,LastCommittedTxIdSetter lastCommittedTxIdSetter,FileSystemAbstraction fileSystem){
  this.storeDir=storeDir;
  TxModule txModule=newTxModule(inputParams,finishHook);
  LockManager lockManager=lockManagerFactory.create(txModule);
  LockReleaser lockReleaser=new LockReleaser(lockManager,txModule.getTxManager());
  final Config config=new Config(graphDbService,storeDir,storeId,inputParams,kernelPanicEventGenerator,txModule,lockManager,lockReleaser,idGeneratorFactory,new SyncHookFactory(),relTypeCreator,txIdFactory.create(txModule.getTxManager()),lastCommittedTxIdSetter,fileSystem,CommonFactories.defaultLogBufferFactory(inputParams));
  graphDbInstance=new GraphDbInstance(storeDir,true,config);
  this.msgLog=StringLogger.getLogger(storeDir);
  this.graphDbService=graphDbService;
  IndexStore indexStore=graphDbInstance.getConfig().getIndexStore();
  this.indexManager=new IndexManagerImpl(this,indexStore);
  extensions=new KernelData(){
    @Override public Version version(){
      return Version.getKernel();
    }
    @Override public Config getConfig(){
      return config;
    }
    @Override public Map<Object,Object> getConfigParams(){
      return config.getParams();
    }
    @Override public GraphDatabaseService graphDatabase(){
      return EmbeddedGraphDbImpl.this.graphDbService;
    }
  }
;
  boolean started=false;
  try {
    final KernelExtensionLoader extensionLoader;
    if (""String_Node_Str"".equalsIgnoreCase(inputParams.get(Config.LOAD_EXTENSIONS))) {
      extensionLoader=KernelExtensionLoader.DONT_LOAD;
    }
 else {
      extensionLoader=new KernelExtensionLoader(){
        private Collection<KernelExtension<?>> loaded;
        public void configureKernelExtensions(){
          loaded=extensions.loadExtensionConfigurations(msgLog);
        }
        public void initializeIndexProviders(){
          extensions.loadIndexImplementations(indexManager,msgLog);
        }
        public void load(){
          extensions.loadExtensions(loaded,msgLog);
        }
      }
;
    }
    graphDbInstance.start(graphDbService,extensionLoader);
    nodeManager=config.getGraphDbModule().getNodeManager();
    extensionLoader.load();
    started=true;
  }
 catch (  Error cause) {
    msgLog.logMessage(""String_Node_Str"",cause);
    throw cause;
  }
catch (  RuntimeException cause) {
    msgLog.logMessage(""String_Node_Str"",cause);
    throw cause;
  }
 finally {
    if (!started)     extensions.shutdown(msgLog);
  }
}","/** 
 * A non-standard way of creating an embedded   {@link GraphDatabaseService}with a set of configuration parameters. Will most likely be removed in future releases.
 * @param storeDir the store directory for the db files
 * @param fileSystem 
 * @param config configuration parameters
 */
public EmbeddedGraphDbImpl(String storeDir,StoreId storeId,Map<String,String> inputParams,GraphDatabaseService graphDbService,LockManagerFactory lockManagerFactory,IdGeneratorFactory idGeneratorFactory,RelationshipTypeCreator relTypeCreator,TxIdGeneratorFactory txIdFactory,TxFinishHook finishHook,LastCommittedTxIdSetter lastCommittedTxIdSetter,FileSystemAbstraction fileSystem){
  this.storeDir=storeDir;
  TxModule txModule=newTxModule(inputParams,finishHook);
  LockManager lockManager=lockManagerFactory.create(txModule);
  LockReleaser lockReleaser=new LockReleaser(lockManager,txModule.getTxManager());
  final Config config=new Config(graphDbService,storeDir,storeId,inputParams,kernelPanicEventGenerator,txModule,lockManager,lockReleaser,idGeneratorFactory,new SyncHookFactory(),relTypeCreator,txIdFactory.create(txModule.getTxManager()),lastCommittedTxIdSetter,fileSystem);
  config.getParams().put(LogBufferFactory.class,CommonFactories.defaultLogBufferFactory(config.getParams()));
  graphDbInstance=new GraphDbInstance(storeDir,true,config);
  this.msgLog=StringLogger.getLogger(storeDir);
  this.graphDbService=graphDbService;
  IndexStore indexStore=graphDbInstance.getConfig().getIndexStore();
  this.indexManager=new IndexManagerImpl(this,indexStore);
  extensions=new KernelData(){
    @Override public Version version(){
      return Version.getKernel();
    }
    @Override public Config getConfig(){
      return config;
    }
    @Override public Map<Object,Object> getConfigParams(){
      return config.getParams();
    }
    @Override public GraphDatabaseService graphDatabase(){
      return EmbeddedGraphDbImpl.this.graphDbService;
    }
  }
;
  boolean started=false;
  try {
    final KernelExtensionLoader extensionLoader;
    if (""String_Node_Str"".equalsIgnoreCase(inputParams.get(Config.LOAD_EXTENSIONS))) {
      extensionLoader=KernelExtensionLoader.DONT_LOAD;
    }
 else {
      extensionLoader=new KernelExtensionLoader(){
        private Collection<KernelExtension<?>> loaded;
        @Override public void configureKernelExtensions(){
          loaded=extensions.loadExtensionConfigurations(msgLog);
        }
        @Override public void initializeIndexProviders(){
          extensions.loadIndexImplementations(indexManager,msgLog);
        }
        @Override public void load(){
          extensions.loadExtensions(loaded,msgLog);
        }
      }
;
    }
    graphDbInstance.start(graphDbService,extensionLoader);
    nodeManager=config.getGraphDbModule().getNodeManager();
    extensionLoader.load();
    started=true;
  }
 catch (  Error cause) {
    msgLog.logMessage(""String_Node_Str"",cause);
    throw cause;
  }
catch (  RuntimeException cause) {
    msgLog.logMessage(""String_Node_Str"",cause);
    throw cause;
  }
 finally {
    if (!started)     extensions.shutdown(msgLog);
  }
}",0.9800615983141514
154517,"public void initializeIndexProviders(){
  extensions.loadIndexImplementations(indexManager,msgLog);
}","@Override public void initializeIndexProviders(){
  extensions.loadIndexImplementations(indexManager,msgLog);
}",0.9528301886792452
154518,"public synchronized boolean hasNext(){
  while (currentNode == null && currentNodeId <= highId) {
    try {
      currentNode=getNodeById(currentNodeId++);
    }
 catch (    NotFoundException e) {
    }
  }
  return currentNode != null;
}","@Override public synchronized boolean hasNext(){
  while (currentNode == null && currentNodeId <= highId) {
    try {
      currentNode=getNodeById(currentNodeId++);
    }
 catch (    NotFoundException e) {
    }
  }
  return currentNode != null;
}",0.9794238683127572
154519,"public void configureKernelExtensions(){
  loaded=extensions.loadExtensionConfigurations(msgLog);
}","@Override public void configureKernelExtensions(){
  loaded=extensions.loadExtensionConfigurations(msgLog);
}",0.9519230769230768
154520,"/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,KernelExtensionLoader kernelExtensionLoader){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir);
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  params.putAll(config.getInputParams());
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  kernelExtensionLoader.configureKernelExtensions();
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + File.separator + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + File.separator + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + File.separator + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + File.separator + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.initializeIndexProviders();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage(""String_Node_Str"");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage(""String_Node_Str"" + Version.getKernel());
  for (  Version componentVersion : Service.load(Version.class)) {
    logger.logMessage(componentVersion.toString());
  }
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(String.format(""String_Node_Str"",os.getName(),os.getVersion(),os.getArch(),os.getAvailableProcessors()));
  logger.logMessage(""String_Node_Str"" + runtime.getVmName());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVendor());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage(""String_Node_Str"" + runtime.getBootClassPath());
  }
  logger.logMessage(""String_Node_Str"" + runtime.getClassPath());
  logger.logMessage(""String_Node_Str"" + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage(""String_Node_Str"" + gcBean.getName() + ""String_Node_Str""+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage(""String_Node_Str"" + runtime.getInputArguments());
  logger.logMessage(""String_Node_Str"");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage(""String_Node_Str"");
  logger.flush();
  started=true;
  return Collections.unmodifiableMap(params);
}","/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,KernelExtensionLoader kernelExtensionLoader){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir);
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  kernelExtensionLoader.configureKernelExtensions();
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + File.separator + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + File.separator + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + File.separator + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + File.separator + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.initializeIndexProviders();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage(""String_Node_Str"");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage(""String_Node_Str"" + Version.getKernel());
  for (  Version componentVersion : Service.load(Version.class)) {
    logger.logMessage(componentVersion.toString());
  }
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(String.format(""String_Node_Str"",os.getName(),os.getVersion(),os.getArch(),os.getAvailableProcessors()));
  logger.logMessage(""String_Node_Str"" + runtime.getVmName());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVendor());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage(""String_Node_Str"" + runtime.getBootClassPath());
  }
  logger.logMessage(""String_Node_Str"" + runtime.getClassPath());
  logger.logMessage(""String_Node_Str"" + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage(""String_Node_Str"" + gcBean.getName() + ""String_Node_Str""+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage(""String_Node_Str"" + runtime.getInputArguments());
  logger.logMessage(""String_Node_Str"");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage(""String_Node_Str"");
  logger.flush();
  started=true;
  return Collections.unmodifiableMap(params);
}",0.9959785522788204
154521,"private void doNewMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e,true);
    reevaluateMyself(master,storeId);
  }
 catch (  ZooKeeperException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  HaCommunicationException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"",true);
    shutdown(t instanceof RuntimeException ? (RuntimeException)t : new RuntimeException(t),false);
    if (t instanceof RuntimeException) {
      throw (RuntimeException)t;
    }
    throw new RuntimeException(t);
  }
}","private void doNewMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e,true);
    reevaluateMyself(master,storeId);
  }
 catch (  ZooKeeperException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  ComException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"",true);
    shutdown(t instanceof RuntimeException ? (RuntimeException)t : new RuntimeException(t),false);
    if (t instanceof RuntimeException) {
      throw (RuntimeException)t;
    }
    throw new RuntimeException(t);
  }
}",0.99163179916318
154522,"public void pullUpdates(){
  try {
    if (masterServer == null) {
      receive(broker.getMaster().first().pullUpdates(getSlaveContext(-1)));
    }
  }
 catch (  ZooKeeperException e) {
    newMaster(null,e);
    throw e;
  }
catch (  HaCommunicationException e) {
    newMaster(null,e);
    throw e;
  }
}","public void pullUpdates(){
  try {
    if (masterServer == null) {
      receive(broker.getMaster().first().pullUpdates(getSlaveContext(-1)));
    }
  }
 catch (  ZooKeeperException e) {
    newMaster(null,e);
    throw e;
  }
catch (  ComException e) {
    newMaster(null,e);
    throw e;
  }
}",0.9800664451827242
154523,"@Override public void getWriteLock(Object resource) throws DeadlockDetectedException, IllegalResourceException {
  try {
    Node node=resource instanceof Node ? (Node)resource : null;
    Relationship relationship=resource instanceof Relationship ? (Relationship)resource : null;
    if (node == null && relationship == null) {
      super.getWriteLock(resource);
      return;
    }
    LockResult result=null;
    do {
      int eventIdentifier=getLocalTxId();
      result=node != null ? receiver.receive(broker.getMaster().first().acquireNodeWriteLock(receiver.getSlaveContext(eventIdentifier),node.getId())) : receiver.receive(broker.getMaster().first().acquireRelationshipWriteLock(receiver.getSlaveContext(eventIdentifier),relationship.getId()));
switch (result.getStatus()) {
case OK_LOCKED:
        super.getWriteLock(resource);
      return;
case DEAD_LOCKED:
    throw new DeadlockDetectedException(result.getDeadlockMessage());
}
}
 while (result.getStatus() == LockStatus.NOT_LOCKED);
}
 catch (ZooKeeperException e) {
receiver.newMaster(null,e);
throw e;
}
catch (HaCommunicationException e) {
receiver.newMaster(null,e);
throw e;
}
}","@Override public void getWriteLock(Object resource) throws DeadlockDetectedException, IllegalResourceException {
  try {
    Node node=resource instanceof Node ? (Node)resource : null;
    Relationship relationship=resource instanceof Relationship ? (Relationship)resource : null;
    if (node == null && relationship == null) {
      super.getWriteLock(resource);
      return;
    }
    LockResult result=null;
    do {
      int eventIdentifier=getLocalTxId();
      result=node != null ? receiver.receive(broker.getMaster().first().acquireNodeWriteLock(receiver.getSlaveContext(eventIdentifier),node.getId())) : receiver.receive(broker.getMaster().first().acquireRelationshipWriteLock(receiver.getSlaveContext(eventIdentifier),relationship.getId()));
switch (result.getStatus()) {
case OK_LOCKED:
        super.getWriteLock(resource);
      return;
case DEAD_LOCKED:
    throw new DeadlockDetectedException(result.getDeadlockMessage());
}
}
 while (result.getStatus() == LockStatus.NOT_LOCKED);
}
 catch (ZooKeeperException e) {
receiver.newMaster(null,e);
throw e;
}
catch (ComException e) {
receiver.newMaster(null,e);
throw e;
}
}",0.994750656167979
154524,"@Override public void getReadLock(Object resource) throws DeadlockDetectedException, IllegalResourceException {
  try {
    Node node=resource instanceof Node ? (Node)resource : null;
    Relationship relationship=resource instanceof Relationship ? (Relationship)resource : null;
    if (node == null && relationship == null) {
      super.getReadLock(resource);
      return;
    }
    LockResult result=null;
    do {
      int eventIdentifier=getLocalTxId();
      result=node != null ? receiver.receive(broker.getMaster().first().acquireNodeReadLock(receiver.getSlaveContext(eventIdentifier),node.getId())) : receiver.receive(broker.getMaster().first().acquireRelationshipReadLock(receiver.getSlaveContext(eventIdentifier),relationship.getId()));
switch (result.getStatus()) {
case OK_LOCKED:
        super.getReadLock(resource);
      return;
case DEAD_LOCKED:
    throw new DeadlockDetectedException(result.getDeadlockMessage());
}
}
 while (result.getStatus() == LockStatus.NOT_LOCKED);
}
 catch (ZooKeeperException e) {
receiver.newMaster(null,e);
throw e;
}
catch (HaCommunicationException e) {
receiver.newMaster(null,e);
throw e;
}
}","@Override public void getReadLock(Object resource) throws DeadlockDetectedException, IllegalResourceException {
  try {
    Node node=resource instanceof Node ? (Node)resource : null;
    Relationship relationship=resource instanceof Relationship ? (Relationship)resource : null;
    if (node == null && relationship == null) {
      super.getReadLock(resource);
      return;
    }
    LockResult result=null;
    do {
      int eventIdentifier=getLocalTxId();
      result=node != null ? receiver.receive(broker.getMaster().first().acquireNodeReadLock(receiver.getSlaveContext(eventIdentifier),node.getId())) : receiver.receive(broker.getMaster().first().acquireRelationshipReadLock(receiver.getSlaveContext(eventIdentifier),relationship.getId()));
switch (result.getStatus()) {
case OK_LOCKED:
        super.getReadLock(resource);
      return;
case DEAD_LOCKED:
    throw new DeadlockDetectedException(result.getDeadlockMessage());
}
}
 while (result.getStatus() == LockStatus.NOT_LOCKED);
}
 catch (ZooKeeperException e) {
receiver.newMaster(null,e);
throw e;
}
catch (ComException e) {
receiver.newMaster(null,e);
throw e;
}
}",0.9947275922671354
154525,"public int getOrCreate(TransactionManager txManager,EntityIdGenerator idGenerator,PersistenceManager persistence,RelationshipTypeHolder relTypeHolder,String name){
  try {
    int eventIdentifier=((TxManager)txManager).getEventIdentifier();
    return receiver.receive(broker.getMaster().first().createRelationshipType(receiver.getSlaveContext(eventIdentifier),name));
  }
 catch (  ZooKeeperException e) {
    receiver.newMaster(null,e);
    throw e;
  }
catch (  HaCommunicationException e) {
    receiver.newMaster(null,e);
    throw e;
  }
}","public int getOrCreate(TransactionManager txManager,EntityIdGenerator idGenerator,PersistenceManager persistence,RelationshipTypeHolder relTypeHolder,String name){
  try {
    int eventIdentifier=((TxManager)txManager).getEventIdentifier();
    return receiver.receive(broker.getMaster().first().createRelationshipType(receiver.getSlaveContext(eventIdentifier),name));
  }
 catch (  ZooKeeperException e) {
    receiver.newMaster(null,e);
    throw e;
  }
catch (  ComException e) {
    receiver.newMaster(null,e);
    throw e;
  }
}",0.9888682745825604
154526,"public long generate(final XaDataSource dataSource,final int identifier){
  try {
    final int eventIdentifier=txManager.getEventIdentifier();
    Response<Long> response=broker.getMaster().first().commitSingleResourceTransaction(receiver.getSlaveContext(eventIdentifier),dataSource.getName(),new TxExtractor(){
      public void extract(      LogBuffer buffer){
        try {
          dataSource.getPreparedTransaction(identifier,buffer);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      public ReadableByteChannel extract(){
        try {
          return dataSource.getPreparedTransaction(identifier);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    return receiver.receive(response);
  }
 catch (  ZooKeeperException e) {
    receiver.newMaster(null,e);
    throw e;
  }
catch (  HaCommunicationException e) {
    receiver.newMaster(null,e);
    throw e;
  }
}","public long generate(final XaDataSource dataSource,final int identifier){
  try {
    final int eventIdentifier=txManager.getEventIdentifier();
    Response<Long> response=broker.getMaster().first().commitSingleResourceTransaction(receiver.getSlaveContext(eventIdentifier),dataSource.getName(),new TxExtractor(){
      public void extract(      LogBuffer buffer){
        try {
          dataSource.getPreparedTransaction(identifier,buffer);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      public ReadableByteChannel extract(){
        try {
          return dataSource.getPreparedTransaction(identifier);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    return receiver.receive(response);
  }
 catch (  ZooKeeperException e) {
    receiver.newMaster(null,e);
    throw e;
  }
catch (  ComException e) {
    receiver.newMaster(null,e);
    throw e;
  }
}",0.9939148073022313
154527,"public void finishTransaction(int eventIdentifier){
  try {
    receiver.receive(broker.getMaster().first().finishTransaction(receiver.getSlaveContext(eventIdentifier)));
  }
 catch (  ZooKeeperException e) {
    receiver.newMaster(null,e);
    throw e;
  }
catch (  HaCommunicationException e) {
    receiver.newMaster(null,e);
    throw e;
  }
}","public void finishTransaction(int eventIdentifier){
  try {
    receiver.receive(broker.getMaster().first().finishTransaction(receiver.getSlaveContext(eventIdentifier)));
  }
 catch (  ZooKeeperException e) {
    receiver.newMaster(null,e);
    throw e;
  }
catch (  ComException e) {
    receiver.newMaster(null,e);
    throw e;
  }
}",0.9824046920821116
154528,"public void write(String path,ReadableByteChannel data,ByteBuffer temporaryBuffer,boolean hasData) throws IOException {
  try {
    File file=new File(basePath,path);
    RandomAccessFile randomAccessFile=null;
    try {
      file.getParentFile().mkdirs();
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      if (hasData) {
        FileChannel channel=randomAccessFile.getChannel();
        while (data.read(temporaryBuffer) >= 0) {
          temporaryBuffer.flip();
          channel.write(temporaryBuffer);
          temporaryBuffer.clear();
        }
      }
    }
  finally {
      if (randomAccessFile != null) {
        randomAccessFile.close();
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    throw new IOException(t);
  }
}","public void write(String path,ReadableByteChannel data,ByteBuffer temporaryBuffer,boolean hasData) throws IOException {
  try {
    temporaryBuffer.clear();
    File file=new File(basePath,path);
    RandomAccessFile randomAccessFile=null;
    try {
      file.getParentFile().mkdirs();
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      if (hasData) {
        FileChannel channel=randomAccessFile.getChannel();
        while (data.read(temporaryBuffer) >= 0) {
          temporaryBuffer.flip();
          channel.write(temporaryBuffer);
          temporaryBuffer.clear();
        }
      }
    }
  finally {
      if (randomAccessFile != null) {
        randomAccessFile.close();
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    throw new IOException(t);
  }
}",0.9817265280403276
154529,"private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  if (master.other().getMachineId() == machineId) {
    return;
  }
 else   if (master.first() == null) {
    RuntimeException cause=new RuntimeException(""String_Node_Str"");
    shutdown(cause,false);
    throw cause;
  }
  XaDataSource nioneoDataSource=getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
  long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
  long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
  int masterForMyHighestCommonTxId=-1;
  try {
    masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    ;
  }
 catch (  IOException e) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str"",e);
    return;
  }
  int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId).response();
  if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
    return;
  }
 else {
    String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
    msgLog.logMessage(msg,true);
    RuntimeException exception=new BranchedDataException(msg);
    shutdown(exception,false);
    throw exception;
  }
}","private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  if (master.other().getMachineId() == machineId) {
    return;
  }
 else   if (master.first() == null) {
    RuntimeException cause=new RuntimeException(""String_Node_Str"");
    shutdown(cause,false);
    throw cause;
  }
  XaDataSource nioneoDataSource=getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
  long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
  long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
  int masterForMyHighestCommonTxId=-1;
  try {
    masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    ;
  }
 catch (  IOException e) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str"",e);
    return;
  }
  int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId).response();
  if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
    return;
  }
 else {
    String msg=""String_Node_Str"" + machineId + ""String_Node_Str""+ highestCommonTxId+ ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ master.other().getMachineId()+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
    msgLog.logMessage(msg,true);
    RuntimeException exception=new BranchedDataException(msg);
    shutdown(exception,false);
    throw exception;
  }
}",0.9631067961165048
154530,"protected synchronized void reevaluateMyself(Pair<Master,Machine> master,StoreId storeId){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster(storeId);
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave(storeId);
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}","protected synchronized void reevaluateMyself(Pair<Master,Machine> master,StoreId storeId){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster(storeId);
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    broker.notifyMasterChange(master.other());
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave(storeId);
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}",0.9765351972041936
154531,"protected void setDataChangeWatcher(String child,int currentMasterId){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + child;
    byte[] data=null;
    boolean exists=false;
    try {
      data=zooKeeper.getData(path,true,null);
      exists=true;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[4];
      ByteBuffer.wrap(data).putInt(currentMasterId);
      if (!exists) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
 else       if (currentMasterId != -1) {
        zooKeeper.setData(path,data,-1);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","protected void setDataChangeWatcher(String child,int currentMasterId,boolean checkIfCurrentMasterIsSame){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + child;
    byte[] data=null;
    boolean exists=false;
    try {
      data=zooKeeper.getData(path,true,null);
      exists=true;
      if (checkIfCurrentMasterIsSame) {
        int id=ByteBuffer.wrap(data).getInt();
        if (currentMasterId == -1 || id == currentMasterId) {
          msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
          return;
        }
      }
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[4];
      ByteBuffer.wrap(data).putInt(currentMasterId);
      if (!exists) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
 else       if (currentMasterId != -1) {
        zooKeeper.setData(path,data,-1);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.8922287390029325
154532,"@Test public void makeSureStoreCantBeUpgradedByBatchInserterEvenIfExplicitlyToldTo() throws Exception {
  String path=path(11);
  new EmbeddedGraphDatabase(path).shutdown();
  setOlderNeoStoreVersion(path);
  try {
    new BatchInserterImpl(path,stringMap(ALLOW_STORE_UPGRADE,""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}","@Test public void makeSureStoreCantBeUpgradedByBatchInserterEvenIfExplicitlyToldTo() throws Exception {
  String path=path(14);
  new EmbeddedGraphDatabase(path).shutdown();
  setOlderNeoStoreVersion(path);
  try {
    new BatchInserterImpl(path,stringMap(ALLOW_STORE_UPGRADE,""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}",0.9973333333333332
154533,"private static Iterable<LinkedList<Relationship>> getPaths(Hit hit,DirectionData data){
  LevelData levelData=data.visitedNodes.get(hit.connectingNode);
  if (levelData.depth == 0) {
    Collection<LinkedList<Relationship>> result=new ArrayList<LinkedList<Relationship>>();
    result.add(new LinkedList<Relationship>());
    return result;
  }
  Collection<PathData> set=new ArrayList<PathData>();
  GraphDatabaseService graphDb=data.startNode.getGraphDatabase();
  for (  long rel : levelData.relsToHere) {
    set.add(new PathData(hit.connectingNode,new LinkedList<Relationship>(Arrays.asList(graphDb.getRelationshipById(rel)))));
  }
  for (int i=0; i < levelData.depth - 1; i++) {
    Collection<PathData> nextSet=new ArrayList<PathData>();
    for (    PathData entry : set) {
      int counter=0;
      Node otherNode=entry.rels.getFirst().getOtherNode(entry.node);
      LevelData otherLevelData=data.visitedNodes.get(otherNode);
      for (      long rel : otherLevelData.relsToHere) {
        LinkedList<Relationship> rels=counter++ == 0 ? entry.rels : new LinkedList<Relationship>(entry.rels);
        rels.addFirst(graphDb.getRelationshipById(rel));
        nextSet.add(new PathData(otherNode,rels));
      }
    }
    set=nextSet;
  }
  return new IterableWrapper<LinkedList<Relationship>,PathData>(set){
    @Override protected LinkedList<Relationship> underlyingObjectToObject(    PathData object){
      return object.rels;
    }
  }
;
}","private static Iterable<LinkedList<Relationship>> getPaths(Hit hit,DirectionData data){
  LevelData levelData=data.visitedNodes.get(hit.connectingNode);
  if (levelData.depth == 0) {
    Collection<LinkedList<Relationship>> result=new ArrayList<LinkedList<Relationship>>();
    result.add(new LinkedList<Relationship>());
    return result;
  }
  Collection<PathData> set=new ArrayList<PathData>();
  GraphDatabaseService graphDb=data.startNode.getGraphDatabase();
  for (  long rel : levelData.relsToHere) {
    set.add(new PathData(hit.connectingNode,new LinkedList<Relationship>(Arrays.asList(graphDb.getRelationshipById(rel)))));
  }
  for (int i=0; i < levelData.depth - 1; i++) {
    Collection<PathData> nextSet=new ArrayList<PathData>();
    for (    PathData entry : set) {
      Node otherNode=entry.rels.getFirst().getOtherNode(entry.node);
      LevelData otherLevelData=data.visitedNodes.get(otherNode);
      int counter=0;
      for (      long rel : otherLevelData.relsToHere) {
        LinkedList<Relationship> rels=++counter == otherLevelData.relsToHere.length ? entry.rels : new LinkedList<Relationship>(entry.rels);
        rels.addFirst(graphDb.getRelationshipById(rel));
        nextSet.add(new PathData(otherNode,rels));
      }
    }
    set=nextSet;
  }
  return new IterableWrapper<LinkedList<Relationship>,PathData>(set){
    @Override protected LinkedList<Relationship> underlyingObjectToObject(    PathData object){
      return object.rels;
    }
  }
;
}",0.832822608103507
154534,"public int compareTo(ChannelBuffer buffer){
  return buffer.compareTo(buffer);
}","public int compareTo(ChannelBuffer buffer){
  return this.buffer.compareTo(buffer);
}",0.9696969696969696
154535,"public int compareTo(ChannelBuffer buffer){
  return buffer.compareTo(buffer);
}","public int compareTo(ChannelBuffer buffer){
  return this.buffer.compareTo(buffer);
}",0.9696969696969696
154536,"@Override protected boolean versionFound(String version){
  if (!version.startsWith(""String_Node_Str"")) {
    return false;
  }
  if (version.equals(""String_Node_Str"")) {
    try {
      long fileSize=getFileChannel().size();
      long recordCount=fileSize / getRecordSize();
      if (recordCount > 0xFFFF) {
        throw new IllegalStoreVersionException(""String_Node_Str"" + version + ""String_Node_Str""+ recordCount+ ""String_Node_Str""+ ""String_Node_Str""+ 0xFFFF+ ""String_Node_Str"");
      }
    }
 catch (    IOException e) {
      throw new IllegalStoreVersionException(""String_Node_Str"" + ""String_Node_Str"" + version + ""String_Node_Str"");
    }
    return true;
  }
  throw new IllegalStoreVersionException(""String_Node_Str"" + version + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Override protected boolean versionFound(String version){
  if (!version.startsWith(""String_Node_Str"")) {
    return false;
  }
  String nineFiveVersionString=""String_Node_Str"";
  if (version.equals(nineFiveVersionString)) {
    try {
      long fileSize=getFileChannel().size();
      long recordCount=(fileSize - nineFiveVersionString.getBytes().length) / getRecordSize();
      if (recordCount > 0xFFFF) {
        throw new IllegalStoreVersionException(""String_Node_Str"" + version + ""String_Node_Str""+ recordCount+ ""String_Node_Str""+ ""String_Node_Str""+ 0xFFFF+ ""String_Node_Str"");
      }
    }
 catch (    IOException e) {
      throw new IllegalStoreVersionException(""String_Node_Str"" + ""String_Node_Str"" + version + ""String_Node_Str"");
    }
    return true;
  }
  throw new IllegalStoreVersionException(""String_Node_Str"" + version + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9223529411764706
154537,"@Test public void makeSureStoreWithTooManyRelationshipTypesCannotBeUpgraded() throws Exception {
  new EmbeddedGraphDatabase(PATH).shutdown();
  createManyRelationshipTypes(0xFFFF + 10);
  assertCannotStart(""String_Node_Str"");
}","@Test public void makeSureStoreWithTooManyRelationshipTypesCannotBeUpgraded() throws Exception {
  new EmbeddedGraphDatabase(PATH).shutdown();
  createManyRelationshipTypes(0x10000);
  assertCannotStart(""String_Node_Str"");
}",0.9778761061946902
154538,"@Test public void makeSureStoreWithDecentAmountOfRelationshipTypesCanBeUpgraded() throws Exception {
  new EmbeddedGraphDatabase(PATH).shutdown();
  createManyRelationshipTypes(0xFFFF - 10);
  assertCanStart();
}","@Test public void makeSureStoreWithDecentAmountOfRelationshipTypesCanBeUpgraded() throws Exception {
  new EmbeddedGraphDatabase(PATH).shutdown();
  createManyRelationshipTypes(0xFFFF);
  assertCanStart();
}",0.9880668257756564
154539,"DirectionData(Node startNode,Collection<Long> sharedVisitedRels,MutableInteger sharedFrozenDepth,MutableBoolean sharedStop,MutableInteger sharedCurrentDepth,boolean stopAsap,RelationshipExpander expander){
  this.startNode=startNode;
  this.visitedNodes.put(startNode,new LevelData(null,0));
  this.nextNodes.add(startNode);
  this.sharedFrozenDepth=sharedFrozenDepth;
  this.sharedStop=sharedStop;
  this.sharedCurrentDepth=sharedCurrentDepth;
  this.stopAsap=stopAsap;
  this.expander=expander;
  this.sharedVisitedRels=sharedVisitedRels;
  prepareNextLevel();
}","DirectionData(Node startNode,Collection<Long> sharedVisitedRels,MutableInteger sharedFrozenDepth,MutableBoolean sharedStop,MutableInteger sharedCurrentDepth,boolean stopAsap,RelationshipExpander expander){
  this.startNode=startNode;
  this.visitedNodes.put(startNode,new LevelData(null,0));
  this.nextNodes.add(startNode);
  this.sharedFrozenDepth=sharedFrozenDepth;
  this.sharedStop=sharedStop;
  this.sharedCurrentDepth=sharedCurrentDepth;
  this.stopAsap=stopAsap;
  this.expander=expander;
  this.sharedVisitedRels=sharedVisitedRels;
  if (sharedCurrentDepth.value < maxDepth) {
    prepareNextLevel();
  }
 else {
    this.nextRelationships=Collections.<Relationship>emptyList().iterator();
  }
}",0.889589905362776
154540,"private void waitForCommandToComplete(){
  waitFor(DONE,WAITING);
}","public void waitForCommandToComplete(){
  waitFor(DONE,WAITING);
}",0.9323308270676692
154541,"private void waitForWorkerToStart(){
  waitFor(STARTING,WAITING);
}","public void waitForWorkerToStart(){
  waitFor(STARTING,WAITING);
}",0.9323308270676692
154542,"@Override public void run(){
  CommandState state=new CommandState(index,graphDb);
  threadState.set(STARTING);
  while (state.alive) {
    try {
      latch=new CountDownLatch(1);
      log(""String_Node_Str"");
      latch.await();
      threadState.set(RUNNING);
      Command command=commands.poll();
      log(""String_Node_Str"" + command.getClass().getSimpleName());
      command.doWork(state);
      threadState.set(DONE);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
catch (    Exception exception) {
      this.exception=exception;
      threadState.set(DONE);
    }
  }
}","@Override public void run(){
  final CommandState state=new CommandState(index,graphDb);
  threadState.set(STARTING);
  while (state.alive) {
    try {
      latch=new CountDownLatch(1);
      log(""String_Node_Str"");
      latch.await();
      threadState.set(RUNNING);
      Command command=commands.poll();
      log(""String_Node_Str"" + command.getClass().getSimpleName());
      command.doWork(state);
      threadState.set(DONE);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
catch (    Exception exception) {
      this.exception=exception;
      threadState.set(DONE);
    }
  }
}",0.9951923076923076
154543,"public BaseWorker(Index<Node> index,GraphDatabaseService graphDb){
  this.index=index;
  this.graphDb=graphDb;
  start();
  waitForWorkerToStart();
}","public BaseWorker(Index<Node> index,GraphDatabaseService graphDb){
  this.index=index;
  this.graphDb=graphDb;
  waitForWorkerToStart();
}",0.9616724738675958
154544,"@Test public void deleteAndCommitShouldBePublishedToOtherTransaction2() throws InterruptedException {
  WorkThread firstTx=createWorker();
  WorkThread secondTx=createWorker();
  firstTx.beginTransaction();
  secondTx.beginTransaction();
  firstTx.createNodeAndIndexBy(key,""String_Node_Str"");
  secondTx.createNodeAndIndexBy(key,""String_Node_Str"");
  firstTx.deleteIndex();
  firstTx.commit();
  secondTx.queryIndex(key,""String_Node_Str"");
  assertThat(secondTx,hasThrownException());
  secondTx.rollback();
  rollbackTx();
}","@Test public void deleteAndCommitShouldBePublishedToOtherTransaction2() throws InterruptedException {
  WorkThread firstTx=createWorker();
  WorkThread secondTx=createWorker();
  firstTx.beginTransaction();
  firstTx.waitForCommandToComplete();
  secondTx.beginTransaction();
  secondTx.waitForCommandToComplete();
  firstTx.createNodeAndIndexBy(key,""String_Node_Str"");
  firstTx.waitForCommandToComplete();
  secondTx.createNodeAndIndexBy(key,""String_Node_Str"");
  secondTx.waitForCommandToComplete();
  firstTx.deleteIndex();
  firstTx.waitForCommandToComplete();
  firstTx.commit();
  firstTx.waitForCommandToComplete();
  secondTx.queryIndex(key,""String_Node_Str"");
  secondTx.waitForCommandToComplete();
  assertThat(secondTx,hasThrownException());
  secondTx.rollback();
  secondTx.waitForCommandToComplete();
  rollbackTx();
}",0.7643593519882179
154545,"private WorkThread createWorker(){
  WorkThread workThread=new WorkThread(index,graphDb);
  workers.add(workThread);
  return workThread;
}","private WorkThread createWorker(){
  WorkThread workThread=new WorkThread(index,graphDb);
  workers.add(workThread);
  workThread.start();
  workThread.waitForWorkerToStart();
  return workThread;
}",0.8249258160237388
154546,"@Test public void indexDeletesShouldNotByVisibleUntilCommit(){
  commitTx();
  WorkThread firstTx=createWorker();
  WorkThread secondTx=createWorker();
  firstTx.beginTransaction();
  firstTx.removeFromIndex(key,value);
  assertThat(secondTx.queryIndex(key,value),contains(node));
  firstTx.rollback();
}","@Test public void indexDeletesShouldNotByVisibleUntilCommit(){
  commitTx();
  WorkThread firstTx=createWorker();
  WorkThread secondTx=createWorker();
  firstTx.beginTransaction();
  firstTx.waitForCommandToComplete();
  firstTx.removeFromIndex(key,value);
  firstTx.waitForCommandToComplete();
  IndexHits<Node> indexHits=secondTx.queryIndex(key,value);
  secondTx.waitForCommandToComplete();
  assertThat(indexHits,contains(node));
  firstTx.rollback();
}",0.7690288713910761
154547,"@Test public void testHardCoreRecovery() throws Exception {
  String path=""String_Node_Str"";
  Neo4jTestCase.deleteFileOrDirectory(new File(path));
  Process process=Runtime.getRuntime().exec(new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),Inserter.class.getName(),path});
  Thread.sleep(4000);
  process.destroy();
  process.waitFor();
  GraphDatabaseService db=new EmbeddedGraphDatabase(path);
  assertTrue(db.index().existsForNodes(""String_Node_Str""));
  Index<Node> index=db.index().forNodes(""String_Node_Str"");
  for (  Node node : db.getAllNodes()) {
    for (    String key : node.getPropertyKeys()) {
      String value=(String)node.getProperty(key);
      boolean found=false;
      for (      Node indexedNode : index.get(key,value)) {
        if (indexedNode.equals(node)) {
          found=true;
          break;
        }
      }
      if (!found) {
        throw new IllegalStateException(node + ""String_Node_Str"" + key+ ""String_Node_Str""+ value+ ""String_Node_Str"");
      }
    }
  }
  db.shutdown();
}","@Test public void testHardCoreRecovery() throws Exception {
  String path=""String_Node_Str"";
  Neo4jTestCase.deleteFileOrDirectory(new File(path));
  Process process=Runtime.getRuntime().exec(new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),Inserter.class.getName(),path});
  Thread.sleep(6000);
  process.destroy();
  process.waitFor();
  GraphDatabaseService db=new EmbeddedGraphDatabase(path);
  assertTrue(db.index().existsForNodes(""String_Node_Str""));
  Index<Node> index=db.index().forNodes(""String_Node_Str"");
  for (  Node node : db.getAllNodes()) {
    for (    String key : node.getPropertyKeys()) {
      String value=(String)node.getProperty(key);
      boolean found=false;
      for (      Node indexedNode : index.get(key,value)) {
        if (indexedNode.equals(node)) {
          found=true;
          break;
        }
      }
      if (!found) {
        throw new IllegalStateException(node + ""String_Node_Str"" + key+ ""String_Node_Str""+ value+ ""String_Node_Str"");
      }
    }
  }
  db.shutdown();
}",0.9990530303030304
154548,"private PropertyRecord getRecord(long id,PersistenceWindow window){
  Buffer buffer=window.getOffsettedBuffer(id);
  byte inUseByte=buffer.get();
  boolean inUse=(inUseByte & 0x1) == Record.IN_USE.intValue();
  if (!inUse) {
    throw new InvalidRecordException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  PropertyRecord record=new PropertyRecord(id);
  int typeInt=buffer.getInt();
  record.setType(getEnumType(typeInt & 0xFFFF));
  record.setInUse(true);
  record.setKeyIndexId(buffer.getInt());
  record.setPropBlock(buffer.getLong());
  long prevProp=buffer.getUnsignedInt();
  long prevModifier=prevProp == IdGeneratorImpl.INTEGER_MINUS_ONE && (inUseByte & 0xF0) == 0 ? 0 : (inUseByte & 0xF0) << 28;
  long nextProp=buffer.getUnsignedInt();
  long nextModifier=nextProp == IdGeneratorImpl.INTEGER_MINUS_ONE && (typeInt & 0xF0000) == 0 ? 0 : (typeInt & 0xF0000) << 16;
  record.setPrevProp(longFromIntAndMod(prevProp,prevModifier));
  record.setNextProp(longFromIntAndMod(nextProp,nextModifier));
  return record;
}","private PropertyRecord getRecord(long id,PersistenceWindow window){
  Buffer buffer=window.getOffsettedBuffer(id);
  byte inUseByte=buffer.get();
  boolean inUse=(inUseByte & 0x1) == Record.IN_USE.intValue();
  if (!inUse) {
    throw new InvalidRecordException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  PropertyRecord record=new PropertyRecord(id);
  long typeInt=buffer.getInt();
  record.setType(getEnumType((int)typeInt & 0xFFFF));
  record.setInUse(true);
  record.setKeyIndexId(buffer.getInt());
  record.setPropBlock(buffer.getLong());
  long prevProp=buffer.getUnsignedInt();
  long prevModifier=prevProp == IdGeneratorImpl.INTEGER_MINUS_ONE && (inUseByte & 0xF0) == 0 ? 0 : (inUseByte & 0xF0) << 28;
  long nextProp=buffer.getUnsignedInt();
  long nextModifier=nextProp == IdGeneratorImpl.INTEGER_MINUS_ONE && (typeInt & 0xF0000) == 0 ? 0 : (typeInt & 0xF0000) << 16;
  record.setPrevProp(longFromIntAndMod(prevProp,prevModifier));
  record.setNextProp(longFromIntAndMod(nextProp,nextModifier));
  return record;
}",0.9941690962099126
154549,"private void updateRecord(PropertyRecord record,PersistenceWindow window){
  long id=record.getId();
  Buffer buffer=window.getOffsettedBuffer(id);
  if (record.inUse()) {
    long prevProp=record.getPrevProp();
    short prevModifier=prevProp == Record.NO_NEXT_PROPERTY.intValue() ? 0 : (short)((prevProp & 0xF00000000L) >> 28);
    long nextProp=record.getNextProp();
    short nextModifier=nextProp == Record.NO_NEXT_PROPERTY.intValue() ? 0 : (short)((nextProp & 0xF00000000L) >> 16);
    short inUseUnsignedByte=(short)((Record.IN_USE.byteValue() | prevModifier));
    int typeInt=record.getType().intValue();
    typeInt|=nextModifier;
    buffer.put((byte)inUseUnsignedByte).putInt(typeInt).putInt(record.getKeyIndexId()).putLong(record.getPropBlock()).putInt((int)prevProp).putInt((int)nextProp);
  }
 else {
    buffer.put(Record.NOT_IN_USE.byteValue());
    if (!isInRecoveryMode()) {
      freeId(id);
    }
  }
}","private void updateRecord(PropertyRecord record,PersistenceWindow window){
  long id=record.getId();
  Buffer buffer=window.getOffsettedBuffer(id);
  if (record.inUse()) {
    long prevProp=record.getPrevProp();
    long prevModifier=prevProp == Record.NO_NEXT_PROPERTY.intValue() ? 0 : (prevProp & 0xF00000000L) >> 28;
    long nextProp=record.getNextProp();
    long nextModifier=nextProp == Record.NO_NEXT_PROPERTY.intValue() ? 0 : (nextProp & 0xF00000000L) >> 16;
    short inUseUnsignedByte=(short)((Record.IN_USE.byteValue() | prevModifier));
    int typeInt=record.getType().intValue();
    typeInt|=nextModifier;
    buffer.put((byte)inUseUnsignedByte).putInt(typeInt).putInt(record.getKeyIndexId()).putLong(record.getPropBlock()).putInt((int)prevProp).putInt((int)nextProp);
  }
 else {
    buffer.put(Record.NOT_IN_USE.byteValue());
    if (!isInRecoveryMode()) {
      freeId(id);
    }
  }
}",0.9802847754654984
154550,"IdBlock copy(){
  IdBlock copy=new IdBlock(highBits);
  copy.ids=new int[length];
  System.arraycopy(ids,0,copy.ids,0,length);
  copy.length=length;
  return copy;
}","IdBlock copy(){
  IdBlock copy=new IdBlock(highBits);
  copy.ids=new int[ids.length];
  System.arraycopy(ids,0,copy.ids,0,length);
  copy.length=length;
  return copy;
}",0.9880239520958084
154551,"@SuppressWarnings(""String_Node_Str"") GraphDatabaseShellServer load(GraphDatabaseService graphDb) throws RemoteException {
  return enable(new GraphDatabaseShellServer(graphDb,(Boolean)getConfig(StartClient.ARG_READONLY,Boolean.FALSE)));
}","@SuppressWarnings(""String_Node_Str"") GraphDatabaseShellServer load(GraphDatabaseService graphDb) throws RemoteException {
  if (!enable)   return null;
  return enable(new GraphDatabaseShellServer(graphDb,(Boolean)getConfig(StartClient.ARG_READONLY,Boolean.FALSE)));
}",0.9407114624505928
154552,"@Test public void canConnectAsAgent() throws Exception {
  Integer port=1234;
  String name=""String_Node_Str"";
  GraphDatabaseService graphDb=new EmbeddedGraphDatabase(""String_Node_Str"");
  try {
    new ShellServerExtension().loadAgent(new ShellBootstrap(port.toString(),name).serialize());
  }
  finally {
    graphDb.shutdown();
  }
  ShellLobby.newClient(port.intValue(),name);
}","@Test public void canConnectAsAgent() throws Exception {
  Integer port=Integer.valueOf(1234);
  String name=""String_Node_Str"";
  GraphDatabaseService graphDb=new EmbeddedGraphDatabase(""String_Node_Str"");
  try {
    new ShellServerExtension().loadAgent(new ShellBootstrap(port.toString(),name).serialize());
  }
  finally {
    graphDb.shutdown();
  }
  ShellLobby.newClient(port.intValue(),name);
}",0.9782886334610472
154553,"private Serializable getConfig(String key,Serializable defaultValue){
  Serializable result=config.get(key);
  return result != null ? result : defaultValue;
}","private Serializable getConfig(String key,Serializable defaultValue){
  Serializable result=config != null ? config.get(key) : null;
  return result != null ? result : defaultValue;
}",0.9298245614035088
154554,"public GraphDatabaseShellServer enable(GraphDatabaseShellServer server) throws RemoteException {
  int port=(Integer)getConfig(StartClient.ARG_PORT,AbstractServer.DEFAULT_PORT);
  String name=(String)getConfig(StartClient.ARG_NAME,AbstractServer.DEFAULT_NAME);
  server.makeRemotelyAvailable(port,name);
  return server;
}","public GraphDatabaseShellServer enable(GraphDatabaseShellServer server) throws RemoteException {
  Object portConfig=getConfig(StartClient.ARG_PORT,AbstractServer.DEFAULT_PORT);
  int port;
  if (portConfig instanceof Integer) {
    port=(Integer)portConfig;
  }
 else   if (portConfig instanceof String) {
    port=Integer.parseInt((String)portConfig);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + portConfig);
  }
  String name=(String)getConfig(StartClient.ARG_NAME,AbstractServer.DEFAULT_NAME);
  server.makeRemotelyAvailable(port,name);
  return server;
}",0.6718061674008811
154555,"public void add(long entityId,Map<String,Object> properties){
  try {
    Document document=identifier.entityType.newDocument(entityId);
    for (    Map.Entry<String,Object> entry : properties.entrySet()) {
      String key=entry.getKey();
      Object value=entry.getValue();
      value=value instanceof ValueContext ? ((ValueContext)value).getCorrectValue() : value;
      for (      Object oneValue : IoPrimitiveUtils.asArray(value)) {
        type.addToDocument(document,key,oneValue);
        if (createdNow) {
          addToCache(entityId,key,oneValue);
        }
      }
    }
    writer.addDocument(document);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public void add(long entityId,Map<String,Object> properties){
  try {
    Document document=identifier.entityType.newDocument(entityId);
    for (    Map.Entry<String,Object> entry : properties.entrySet()) {
      String key=entry.getKey();
      Object value=entry.getValue();
      boolean isValueContext=value instanceof ValueContext;
      value=isValueContext ? ((ValueContext)value).getCorrectValue() : value;
      for (      Object oneValue : IoPrimitiveUtils.asArray(value)) {
        oneValue=isValueContext ? oneValue : oneValue.toString();
        type.addToDocument(document,key,oneValue);
        if (createdNow) {
          addToCache(entityId,key,oneValue);
        }
      }
    }
    writer.addDocument(document);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9190635451505016
154556,"public void add(long entityId,Map<String,Object> properties){
  try {
    Document document=identifier.entityType.newDocument(entityId);
    for (    Map.Entry<String,Object> entry : properties.entrySet()) {
      String key=entry.getKey();
      for (      Object value : IoPrimitiveUtils.asArray(entry.getValue())) {
        type.addToDocument(document,key,value);
        if (createdNow) {
          addToCache(entityId,key,value);
        }
      }
    }
    writer.addDocument(document);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public void add(long entityId,Map<String,Object> properties){
  try {
    Document document=identifier.entityType.newDocument(entityId);
    for (    Map.Entry<String,Object> entry : properties.entrySet()) {
      String key=entry.getKey();
      Object value=entry.getValue();
      value=value instanceof ValueContext ? ((ValueContext)value).getCorrectValue() : value;
      for (      Object oneValue : IoPrimitiveUtils.asArray(value)) {
        type.addToDocument(document,key,oneValue);
        if (createdNow) {
          addToCache(entityId,key,oneValue);
        }
      }
    }
    writer.addDocument(document);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.8519108280254777
154557,"@Test public void testSome() throws Exception {
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex index=provider.nodeIndex(""String_Node_Str"",LuceneIndexImplementation.EXACT_CONFIG);
  Map<Integer,Long> ids=new HashMap<Integer,Long>();
  for (int i=0; i < 100; i++) {
    long id=inserter.createNode(null);
    index.add(id,MapUtil.map(""String_Node_Str"",""String_Node_Str"" + i,""String_Node_Str"",""String_Node_Str""));
    ids.put(i,id);
  }
  for (int i=0; i < 100; i++) {
    assertContains(index.get(""String_Node_Str"",""String_Node_Str"" + i),ids.get(i));
  }
  assertContains(index.query(""String_Node_Str""),ids.get(0));
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),ids.values().toArray(new Long[ids.size()]));
  provider.shutdown();
  inserter.shutdown();
  GraphDatabaseService db=new EmbeddedGraphDatabase(PATH);
  assertTrue(db.index().existsForNodes(""String_Node_Str""));
  Index<Node> dbIndex=db.index().forNodes(""String_Node_Str"");
  for (int i=0; i < 100; i++) {
    assertContains(dbIndex.get(""String_Node_Str"",""String_Node_Str"" + i),db.getNodeById(ids.get(i)));
  }
  Collection<Node> nodes=new ArrayList<Node>();
  for (  long id : ids.values()) {
    nodes.add(db.getNodeById(id));
  }
  assertContains(dbIndex.query(""String_Node_Str"",""String_Node_Str""),nodes.toArray(new Node[nodes.size()]));
  assertContains(dbIndex.query(""String_Node_Str""),db.getNodeById(ids.get(0)));
  db.shutdown();
}","@Test public void testSome() throws Exception {
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex index=provider.nodeIndex(""String_Node_Str"",EXACT_CONFIG);
  Map<Integer,Long> ids=new HashMap<Integer,Long>();
  for (int i=0; i < 100; i++) {
    long id=inserter.createNode(null);
    index.add(id,map(""String_Node_Str"",""String_Node_Str"" + i,""String_Node_Str"",""String_Node_Str""));
    ids.put(i,id);
  }
  for (int i=0; i < 100; i++) {
    assertContains(index.get(""String_Node_Str"",""String_Node_Str"" + i),ids.get(i));
  }
  assertContains(index.query(""String_Node_Str""),ids.get(0));
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),ids.values().toArray(new Long[ids.size()]));
  provider.shutdown();
  inserter.shutdown();
  GraphDatabaseService db=new EmbeddedGraphDatabase(PATH);
  assertTrue(db.index().existsForNodes(""String_Node_Str""));
  Index<Node> dbIndex=db.index().forNodes(""String_Node_Str"");
  for (int i=0; i < 100; i++) {
    assertContains(dbIndex.get(""String_Node_Str"",""String_Node_Str"" + i),db.getNodeById(ids.get(i)));
  }
  Collection<Node> nodes=new ArrayList<Node>();
  for (  long id : ids.values()) {
    nodes.add(db.getNodeById(id));
  }
  assertContains(dbIndex.query(""String_Node_Str"",""String_Node_Str""),nodes.toArray(new Node[nodes.size()]));
  assertContains(dbIndex.query(""String_Node_Str""),db.getNodeById(ids.get(0)));
  db.shutdown();
}",0.9887640449438202
154558,"@Test public void testCanIndexRelationships(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider indexProvider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex edgesIndex=indexProvider.relationshipIndex(""String_Node_Str"",MapUtil.stringMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  long nodeId1=inserter.createNode(MapUtil.map(""String_Node_Str"",""String_Node_Str""));
  long nodeId2=inserter.createNode(MapUtil.map(""String_Node_Str"",""String_Node_Str""));
  long relationshipId=inserter.createRelationship(nodeId1,nodeId2,EdgeType.KNOWS,null);
  edgesIndex.add(relationshipId,MapUtil.map(""String_Node_Str"",EdgeType.KNOWS.name()));
  edgesIndex.flush();
  assertEquals(String.format(""String_Node_Str""),new Long(relationshipId),edgesIndex.query(""String_Node_Str"",EdgeType.KNOWS.name()).getSingle());
  indexProvider.shutdown();
  inserter.shutdown();
}","@Test public void testCanIndexRelationships(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider indexProvider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex edgesIndex=indexProvider.relationshipIndex(""String_Node_Str"",stringMap(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  long nodeId1=inserter.createNode(map(""String_Node_Str"",""String_Node_Str""));
  long nodeId2=inserter.createNode(map(""String_Node_Str"",""String_Node_Str""));
  long relationshipId=inserter.createRelationship(nodeId1,nodeId2,EdgeType.KNOWS,null);
  edgesIndex.add(relationshipId,map(""String_Node_Str"",EdgeType.KNOWS.name()));
  edgesIndex.flush();
  assertEquals(String.format(""String_Node_Str""),new Long(relationshipId),edgesIndex.query(""String_Node_Str"",EdgeType.KNOWS.name()).getSingle());
  indexProvider.shutdown();
  inserter.shutdown();
}",0.9825517993456924
154559,"@Test public void testFulltext(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  String name=""String_Node_Str"";
  BatchInserterIndex index=provider.nodeIndex(name,MapUtil.stringMap(""String_Node_Str"",""String_Node_Str""));
  long id1=inserter.createNode(null);
  index.add(id1,MapUtil.map(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  long id2=inserter.createNode(null);
  index.add(id2,MapUtil.map(""String_Node_Str"",""String_Node_Str""));
  index.flush();
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id1);
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),id1);
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""));
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),id1,id2);
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),id1);
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id1);
  long id3=inserter.createNode(null);
  index.add(id3,MapUtil.map(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  index.flush();
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id3);
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id3);
  provider.shutdown();
  inserter.shutdown();
  GraphDatabaseService db=new EmbeddedGraphDatabase(PATH);
  Index<Node> dbIndex=db.index().forNodes(name);
  Node node1=db.getNodeById(id1);
  Node node2=db.getNodeById(id2);
  assertContains(dbIndex.query(""String_Node_Str"",""String_Node_Str""),node1,node2);
  db.shutdown();
}","@Test public void testFulltext(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  String name=""String_Node_Str"";
  BatchInserterIndex index=provider.nodeIndex(name,stringMap(""String_Node_Str"",""String_Node_Str""));
  long id1=inserter.createNode(null);
  index.add(id1,map(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  long id2=inserter.createNode(null);
  index.add(id2,map(""String_Node_Str"",""String_Node_Str""));
  index.flush();
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id1);
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),id1);
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""));
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),id1,id2);
  assertContains(index.query(""String_Node_Str"",""String_Node_Str""),id1);
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id1);
  long id3=inserter.createNode(null);
  index.add(id3,map(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  index.flush();
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id3);
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),id3);
  provider.shutdown();
  inserter.shutdown();
  GraphDatabaseService db=new EmbeddedGraphDatabase(PATH);
  Index<Node> dbIndex=db.index().forNodes(name);
  Node node1=db.getNodeById(id1);
  Node node2=db.getNodeById(id2);
  assertContains(dbIndex.query(""String_Node_Str"",""String_Node_Str""),node1,node2);
  db.shutdown();
}",0.9902557856272838
154560,"@Test public void testFindCreatedIndex(){
  String indexName=""String_Node_Str"";
  BatchInserter inserter=new BatchInserterImpl(PATH);
  LuceneBatchInserterIndexProvider indexProvider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex persons=indexProvider.nodeIndex(""String_Node_Str"",MapUtil.stringMap(""String_Node_Str"",""String_Node_Str""));
  Map<String,Object> properties=MapUtil.map(""String_Node_Str"",""String_Node_Str"");
  long node=inserter.createNode(properties);
  persons.add(node,properties);
  indexProvider.shutdown();
  inserter.shutdown();
  GraphDatabaseService graphDb=new EmbeddedGraphDatabase(PATH);
  Transaction tx=graphDb.beginTx();
  try {
    IndexManager indexManager=graphDb.index();
    Assert.assertFalse(indexManager.existsForRelationships(indexName));
    Assert.assertTrue(indexManager.existsForNodes(indexName));
    Assert.assertNotNull(indexManager.forNodes(indexName));
    Index<Node> nodes=graphDb.index().forNodes(indexName);
    Assert.assertTrue(nodes.get(""String_Node_Str"",""String_Node_Str"").hasNext());
    tx.success();
    tx.finish();
  }
  finally {
    graphDb.shutdown();
  }
}","@Test public void testFindCreatedIndex(){
  String indexName=""String_Node_Str"";
  BatchInserter inserter=new BatchInserterImpl(PATH);
  LuceneBatchInserterIndexProvider indexProvider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex persons=indexProvider.nodeIndex(""String_Node_Str"",stringMap(""String_Node_Str"",""String_Node_Str""));
  Map<String,Object> properties=map(""String_Node_Str"",""String_Node_Str"");
  long node=inserter.createNode(properties);
  persons.add(node,properties);
  indexProvider.shutdown();
  inserter.shutdown();
  GraphDatabaseService graphDb=new EmbeddedGraphDatabase(PATH);
  Transaction tx=graphDb.beginTx();
  try {
    IndexManager indexManager=graphDb.index();
    Assert.assertFalse(indexManager.existsForRelationships(indexName));
    Assert.assertTrue(indexManager.existsForNodes(indexName));
    Assert.assertNotNull(indexManager.forNodes(indexName));
    Index<Node> nodes=graphDb.index().forNodes(indexName);
    Assert.assertTrue(nodes.get(""String_Node_Str"",""String_Node_Str"").hasNext());
    tx.success();
    tx.finish();
  }
  finally {
    graphDb.shutdown();
  }
}",0.9929266136162688
154561,"@Test public void triggerNPEAfterFlush(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex index=provider.nodeIndex(""String_Node_Str"",LuceneIndexImplementation.EXACT_CONFIG);
  Map<String,Object> map=map(""String_Node_Str"",""String_Node_Str"");
  long node=inserter.createNode(map);
  index.add(node,map);
  index.flush();
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),node);
  provider.shutdown();
  inserter.shutdown();
}","@Test public void triggerNPEAfterFlush(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex index=provider.nodeIndex(""String_Node_Str"",EXACT_CONFIG);
  Map<String,Object> map=map(""String_Node_Str"",""String_Node_Str"");
  long node=inserter.createNode(map);
  index.add(node,map);
  index.flush();
  assertContains(index.get(""String_Node_Str"",""String_Node_Str""),node);
  provider.shutdown();
  inserter.shutdown();
}",0.9757914338919924
154562,"@Ignore @Test public void testInsertionSpeed(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex index=provider.nodeIndex(""String_Node_Str"",LuceneIndexImplementation.EXACT_CONFIG);
  index.setCacheCapacity(""String_Node_Str"",1000000);
  long t=System.currentTimeMillis();
  for (int i=0; i < 1000000; i++) {
    Map<String,Object> properties=MapUtil.map(""String_Node_Str"",""String_Node_Str"" + i);
    long id=inserter.createNode(properties);
    index.add(id,properties);
  }
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - t));
  index.flush();
  t=System.currentTimeMillis();
  for (int i=0; i < 1000000; i++) {
    IteratorUtil.count((Iterator<Long>)index.get(""String_Node_Str"",""String_Node_Str"" + i));
  }
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - t));
}","@Ignore @Test public void testInsertionSpeed(){
  BatchInserter inserter=new BatchInserterImpl(PATH);
  BatchInserterIndexProvider provider=new LuceneBatchInserterIndexProvider(inserter);
  BatchInserterIndex index=provider.nodeIndex(""String_Node_Str"",EXACT_CONFIG);
  index.setCacheCapacity(""String_Node_Str"",1000000);
  long t=currentTimeMillis();
  for (int i=0; i < 1000000; i++) {
    Map<String,Object> properties=map(""String_Node_Str"",""String_Node_Str"" + i);
    long id=inserter.createNode(properties);
    index.add(id,properties);
  }
  System.out.println(""String_Node_Str"" + (currentTimeMillis() - t));
  index.flush();
  t=currentTimeMillis();
  for (int i=0; i < 1000000; i++) {
    count((Iterator<Long>)index.get(""String_Node_Str"",""String_Node_Str"" + i));
  }
  System.out.println(""String_Node_Str"" + (currentTimeMillis() - t));
}",0.7059490084985836
154563,"public Relationship getRelationshipById(long id){
  if (id < 0 || id >= MAX_RELATIONSHIP_ID) {
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return nodeManager.getRelationshipById(id);
}","public Relationship getRelationshipById(long id){
  if (id < 0 || id > MAX_RELATIONSHIP_ID) {
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return nodeManager.getRelationshipById(id);
}",0.997752808988764
154564,"public Node getNodeById(long id){
  if (id < 0 || id >= MAX_NODE_ID) {
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return nodeManager.getNodeById(id);
}","public Node getNodeById(long id){
  if (id < 0 || id > MAX_NODE_ID) {
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return nodeManager.getNodeById(id);
}",0.9973753280839897
154565,"public void createNode(long id,Map<String,Object> properties){
  if (id < 0 || id > 0xFFFFFFFFL) {
    throw new IllegalArgumentException(""String_Node_Str"" + id);
  }
  int nodeId=(int)(id & 0xFFFFFFFF);
  NodeStore nodeStore=neoStore.getNodeStore();
  if (neoStore.getNodeStore().loadLightNode(nodeId)) {
    throw new IllegalArgumentException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  long highId=nodeStore.getHighId();
  if (highId <= id) {
    nodeStore.setHighId(nodeId + 1);
  }
  NodeRecord nodeRecord=new NodeRecord(nodeId);
  nodeRecord.setInUse(true);
  nodeRecord.setCreated();
  nodeRecord.setNextProp(createPropertyChain(properties));
  getNodeStore().updateRecord(nodeRecord);
}","public void createNode(long id,Map<String,Object> properties){
  if (id < 0 || id > MAX_NODE_ID) {
    throw new IllegalArgumentException(""String_Node_Str"" + id);
  }
  long nodeId=id;
  NodeStore nodeStore=neoStore.getNodeStore();
  if (neoStore.getNodeStore().loadLightNode(nodeId)) {
    throw new IllegalArgumentException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  long highId=nodeStore.getHighId();
  if (highId <= id) {
    nodeStore.setHighId(nodeId + 1);
  }
  NodeRecord nodeRecord=new NodeRecord(nodeId);
  nodeRecord.setInUse(true);
  nodeRecord.setCreated();
  nodeRecord.setNextProp(createPropertyChain(properties));
  getNodeStore().updateRecord(nodeRecord);
}",0.9616775126536516
154566,"/** 
 * Sets the highest id in use (use this when rebuilding id generator).
 * @param highId The high id to set.
 */
protected void setHighId(long highId){
  if (idGenerator != null) {
    idGenerator.setHighId(highId);
  }
}","/** 
 * Sets the highest id in use (use this when rebuilding id generator).
 * @param highId The high id to set.
 */
public void setHighId(long highId){
  if (idGenerator != null) {
    idGenerator.setHighId(highId);
  }
}",0.9753914988814316
154567,"private void assertIdWithinCapacity(long id){
  if (id >= max || id < 0) {
    throw new UnderlyingStorageException(""String_Node_Str"");
  }
}","private void assertIdWithinCapacity(long id){
  if (id > max || id < 0) {
    throw new UnderlyingStorageException(""String_Node_Str"");
  }
}",0.99644128113879
154568,"private void makeSureIdCapacityCannotBeExceeded(IdType type){
  deleteIdGeneratorFile();
  IdGeneratorImpl.createGenerator(idGeneratorFile());
  IdGenerator idGenerator=new IdGeneratorImpl(idGeneratorFile(),1,type.getMaxValue());
  long id=type.getMaxValue() - 3;
  idGenerator.setHighId(id);
  assertEquals(id,idGenerator.nextId());
  assertEquals(id + 1,idGenerator.nextId());
  assertEquals(id + 2,idGenerator.nextId());
  try {
    idGenerator.nextId();
    fail(""String_Node_Str"");
  }
 catch (  StoreFailureException e) {
  }
}","private void makeSureIdCapacityCannotBeExceeded(IdType type){
  deleteIdGeneratorFile();
  IdGeneratorImpl.createGenerator(idGeneratorFile());
  long maxValue=type.getMaxValue();
  IdGenerator idGenerator=new IdGeneratorImpl(idGeneratorFile(),1,maxValue);
  long id=maxValue - 2;
  idGenerator.setHighId(id);
  assertEquals(id,idGenerator.nextId());
  assertEquals(id + 1,idGenerator.nextId());
  if (maxValue != (long)Math.pow(2,32) - 1) {
    assertEquals(id + 2,idGenerator.nextId());
  }
  try {
    idGenerator.nextId();
    fail(""String_Node_Str"" + type);
  }
 catch (  StoreFailureException e) {
  }
}",0.8606485539000877
154569,"@Test public void testUnsignedId(){
  try {
    IdGeneratorImpl.createGenerator(idGeneratorFile());
    IdGenerator idGenerator=new IdGeneratorImpl(idGeneratorFile(),1,IdType.PROPERTY_INDEX.getMaxValue());
    idGenerator.setHighId(4294967293l);
    long id=idGenerator.nextId();
    assertEquals(4294967293l,id);
    idGenerator.freeId(id);
    try {
      idGenerator.nextId();
      fail(""String_Node_Str"");
    }
 catch (    StoreFailureException e) {
    }
    idGenerator.close();
    idGenerator=new IdGeneratorImpl(idGeneratorFile(),1,IdType.PROPERTY_INDEX.getMaxValue());
    assertEquals(4294967294l,idGenerator.getHighId());
    id=idGenerator.nextId();
    assertEquals(4294967293l,id);
    try {
      idGenerator.nextId();
    }
 catch (    StoreFailureException e) {
    }
    idGenerator.close();
  }
  finally {
    File file=new File(idGeneratorFile());
    if (file.exists()) {
      assertTrue(file.delete());
    }
  }
}","@Test public void testUnsignedId(){
  try {
    IdGeneratorImpl.createGenerator(idGeneratorFile());
    IdGenerator idGenerator=new IdGeneratorImpl(idGeneratorFile(),1,IdType.PROPERTY_INDEX.getMaxValue());
    idGenerator.setHighId(IdType.PROPERTY_INDEX.getMaxValue() - 1);
    long id=idGenerator.nextId();
    assertEquals(IdType.PROPERTY_INDEX.getMaxValue() - 1,id);
    idGenerator.freeId(id);
    try {
      idGenerator.nextId();
      fail(""String_Node_Str"");
    }
 catch (    StoreFailureException e) {
    }
    idGenerator.close();
    idGenerator=new IdGeneratorImpl(idGeneratorFile(),1,IdType.PROPERTY_INDEX.getMaxValue());
    assertEquals(IdType.PROPERTY_INDEX.getMaxValue() + 1,idGenerator.getHighId());
    id=idGenerator.nextId();
    assertEquals(IdType.PROPERTY_INDEX.getMaxValue() - 1,id);
    try {
      idGenerator.nextId();
    }
 catch (    StoreFailureException e) {
    }
    idGenerator.close();
  }
  finally {
    File file=new File(idGeneratorFile());
    if (file.exists()) {
      assertTrue(file.delete());
    }
  }
}",0.8996990972918756
154570,"@Override protected void startup(String parameter) throws Throwable {
  db=new EmbeddedGraphDatabase(parameter);
}","@Override protected void startup(String parameter) throws Throwable {
  db=new EmbeddedGraphDatabase(parameter,stringMap(OnlineBackupExtension.ENABLE_ONLINE_BACKUP,""String_Node_Str""));
}",0.76
154571,"private synchronized void expandBricks(int newBrickCount){
  if (newBrickCount > brickCount) {
    BrickElement tmpArray[]=new BrickElement[newBrickCount];
    System.arraycopy(brickArray,0,tmpArray,0,brickArray.length);
    for (int i=brickArray.length; i < tmpArray.length; i++) {
      BrickElement be=new BrickElement(i);
      tmpArray[i]=be;
      if (memUsed + brickSize <= availableMem) {
        try {
          be.setWindow(allocateNewWindow(i));
          memUsed+=brickSize;
        }
 catch (        MappedMemException e) {
          ooe++;
          logWarn(""String_Node_Str"");
        }
catch (        OutOfMemoryError e) {
          ooe++;
          logWarn(""String_Node_Str"");
        }
      }
    }
    brickArray=tmpArray;
    brickCount=tmpArray.length;
  }
}","private synchronized void expandBricks(int newBrickCount){
  if (newBrickCount > brickCount) {
    BrickElement tmpArray[]=new BrickElement[newBrickCount];
    System.arraycopy(brickArray,0,tmpArray,0,brickArray.length);
    if (memUsed + brickSize >= availableMem) {
      freeWindows(1);
    }
    for (int i=brickArray.length; i < tmpArray.length; i++) {
      BrickElement be=new BrickElement(i);
      tmpArray[i]=be;
      if (memUsed + brickSize <= availableMem) {
        try {
          be.setWindow(allocateNewWindow(i));
          memUsed+=brickSize;
        }
 catch (        MappedMemException e) {
          ooe++;
          logWarn(""String_Node_Str"");
        }
catch (        OutOfMemoryError e) {
          ooe++;
          logWarn(""String_Node_Str"");
        }
      }
    }
    brickArray=tmpArray;
    brickCount=tmpArray.length;
  }
}",0.9541284403669724
154572,"private void doNewMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  waitForStartupLatch();
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e,true);
    reevaluateMyself(master,storeId);
  }
 catch (  ZooKeeperException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  HaCommunicationException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"",true);
    shutdown(t instanceof RuntimeException ? (RuntimeException)t : new RuntimeException(t));
    if (t instanceof RuntimeException) {
      throw (RuntimeException)t;
    }
    throw new RuntimeException(t);
  }
}","private void doNewMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e,true);
    reevaluateMyself(master,storeId);
  }
 catch (  ZooKeeperException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  HaCommunicationException ee) {
    msgLog.logMessage(""String_Node_Str"",ee);
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"",true);
    shutdown(t instanceof RuntimeException ? (RuntimeException)t : new RuntimeException(t),false);
    if (t instanceof RuntimeException) {
      throw (RuntimeException)t;
    }
    throw new RuntimeException(t);
  }
}",0.9501706484641638
154573,"private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  if (master.other().getMachineId() == machineId) {
    return;
  }
  XaDataSource nioneoDataSource=getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
  long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
  long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
  int masterForMyHighestCommonTxId=-1;
  try {
    masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    ;
  }
 catch (  IOException e) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str"",e);
    return;
  }
  int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId);
  if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
    return;
  }
 else {
    String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
    msgLog.logMessage(msg,true);
    RuntimeException exception=new BranchedDataException(msg);
    shutdown(exception);
    throw exception;
  }
}","private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  if (master.other().getMachineId() == machineId) {
    return;
  }
 else   if (master.first() == null) {
    RuntimeException cause=new RuntimeException(""String_Node_Str"");
    shutdown(cause,false);
    throw cause;
  }
  XaDataSource nioneoDataSource=getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
  long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
  long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
  int masterForMyHighestCommonTxId=-1;
  try {
    masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    ;
  }
 catch (  IOException e) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str"",e);
    return;
  }
  int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId);
  if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
    return;
  }
 else {
    String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
    msgLog.logMessage(msg,true);
    RuntimeException exception=new BranchedDataException(msg);
    shutdown(exception,false);
    throw exception;
  }
}",0.9434229137199436
154574,"private void newMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    doNewMaster(master,storeId,e);
  }
 catch (  BranchedDataException bde) {
    System.out.println(""String_Node_Str"");
    cleanDatabase();
    doNewMaster(master,storeId,bde);
  }
}","private synchronized void newMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    doNewMaster(master,storeId,e);
  }
 catch (  BranchedDataException bde) {
    System.out.println(""String_Node_Str"");
    getFreshDatabaseFromMaster(master);
    doNewMaster(master,storeId,bde);
  }
}",0.9238754325259516
154575,"protected synchronized void reevaluateMyself(Pair<Master,Machine> master,StoreId storeId){
  boolean foundOutRightNow=false;
  if (master == null) {
    master=broker.getMasterReally();
    foundOutRightNow=true;
  }
  System.out.println(machineId + ""String_Node_Str"" + (foundOutRightNow ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ master+ ""String_Node_Str"");
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster(storeId);
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave(storeId);
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}","protected synchronized void reevaluateMyself(Pair<Master,Machine> master,StoreId storeId){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster(storeId);
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave(storeId);
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}",0.7175011483693156
154576,"public synchronized void shutdown(){
  shutdown(new IllegalStateException());
}","public synchronized void shutdown(){
  shutdown(new IllegalStateException(),true);
}",0.9693251533742332
154577,"public <T>T receive(Response<T> response){
  try {
    XaDataSourceManager localDataSourceManager=getConfig().getTxModule().getXaDataSourceManager();
    for (    Triplet<String,Long,TxExtractor> tx : IteratorUtil.asIterable(response.transactions())) {
      String resourceName=tx.first();
      XaDataSource dataSource=localDataSourceManager.getXaDataSource(resourceName);
      ReadableByteChannel txStream=tx.third().extract();
      try {
        dataSource.applyCommittedTransaction(tx.second(),txStream);
      }
  finally {
        txStream.close();
      }
    }
    updateTime();
    return response.response();
  }
 catch (  IOException e) {
    newMaster(broker.getMaster(),e);
    throw new RuntimeException(e);
  }
}","public <T>T receive(Response<T> response){
  try {
    applyReceivedTransactions(response,getConfig().getTxModule().getXaDataSourceManager(),NO_ACTION);
    updateTime();
    return response.response();
  }
 catch (  IOException e) {
    newMaster(broker.getMaster(),e);
    throw new RuntimeException(e);
  }
}",0.5148895292987512
154578,"private boolean copyStoreFromMaster(Pair<Master,Machine> master){
  try {
    msgLog.logMessage(""String_Node_Str"");
    master.first().copyStore(new SlaveContext(machineId,0,new Pair[0]),new ToFileStoreWriter(storeDir));
    msgLog.logMessage(""String_Node_Str"");
    return true;
  }
 catch (  Exception e) {
    msgLog.logMessage(""String_Node_Str"",e);
    broker.getMasterReally();
    return false;
  }
}","private void copyStoreFromMaster(Pair<Master,Machine> master) throws Exception {
  msgLog.logMessage(""String_Node_Str"");
  Response<Void> response=master.first().copyStore(new SlaveContext(machineId,0,new Pair[0]),new ToFileStoreWriter(storeDir));
  EmbeddedGraphDatabase tempDb=new EmbeddedGraphDatabase(storeDir);
  try {
    applyReceivedTransactions(response,tempDb.getConfig().getTxModule().getXaDataSourceManager(),new TxHandler(){
      private final Set<String> visitedDataSources=new HashSet<String>();
      @Override public void accept(      Triplet<String,Long,TxExtractor> tx,      XaDataSource dataSource){
        if (visitedDataSources.add(tx.first())) {
          dataSource.setLastCommittedTxId(tx.second() - 1);
        }
      }
    }
);
  }
  finally {
    tempDb.shutdown();
  }
  msgLog.logMessage(""String_Node_Str"");
}",0.3926282051282051
154579,"private void startUp(boolean allowInit){
  StoreId storeId=null;
  if (!new File(storeDir,""String_Node_Str"").exists()) {
    startupLatch=new CountDownLatch(1);
    try {
      long endTime=System.currentTimeMillis() + 10000;
      MASTER_ARBITRATION:       while (System.currentTimeMillis() < endTime) {
        Pair<Master,Machine> master=broker.getMaster();
        master=master.first() != null ? master : broker.getMasterReally();
        if (master != null && master.first() != null) {
          if (copyStoreFromMaster(master)) {
            break MASTER_ARBITRATION;
          }
        }
 else         if (allowInit) {
          StoreId myStoreId=new StoreId();
          storeId=broker.createCluster(myStoreId);
          if (storeId.equals(myStoreId)) {
            break MASTER_ARBITRATION;
          }
        }
        sleepWithoutInterruption(100,""String_Node_Str"");
      }
    }
  finally {
      startupLatch.countDown();
      startupLatch=null;
    }
  }
  newMaster(null,storeId,new Exception());
  localGraph();
}","private synchronized void startUp(boolean allowInit){
  StoreId storeId=null;
  if (!new File(storeDir,""String_Node_Str"").exists()) {
    long endTime=System.currentTimeMillis() + 10000;
    Exception exception=null;
    while (System.currentTimeMillis() < endTime) {
      Pair<Master,Machine> master=broker.getMaster();
      master=master.first() != null ? master : broker.getMasterReally();
      if (master != null && master.first() != null) {
        try {
          copyStoreFromMaster(master);
          exception=null;
          break;
        }
 catch (        Exception e) {
          exception=e;
          broker.getMasterReally();
          msgLog.logMessage(""String_Node_Str"",e);
        }
      }
 else       if (allowInit) {
        exception=null;
        StoreId myStoreId=new StoreId();
        storeId=broker.createCluster(myStoreId);
        if (storeId.equals(myStoreId)) {
          break;
        }
      }
      sleepWithoutInterruption(300,""String_Node_Str"");
    }
    if (exception != null) {
      throw new RuntimeException(""String_Node_Str"",exception);
    }
  }
  newMaster(null,storeId,new Exception());
  localGraph();
}",0.5643835616438356
154580,"public Response<Void> copyStore(SlaveContext context,StoreWriter writer){
  Collection<XaDataSource> sources=graphDbConfig.getTxModule().getXaDataSourceManager().getAllRegisteredDataSources();
  Pair<String,Long>[] appliedTransactions=new Pair[sources.size()];
  int i=0;
  for (  XaDataSource ds : sources) {
    appliedTransactions[i++]=Pair.of(ds.getName(),ds.getLastCommittedTxId());
    try {
      ds.rotateLogicalLog();
    }
 catch (    IOException e) {
      return new FailedResponse<Void>();
    }
  }
  context=new SlaveContext(context.machineId(),context.getEventIdentifier(),appliedTransactions);
  File baseDir=getBaseDir();
  for (  XaDataSource ds : sources) {
    try {
      ClosableIterable<File> files=ds.listStoreFiles();
      try {
        for (        File storefile : files) {
          FileInputStream stream=new FileInputStream(storefile);
          try {
            writer.write(relativePath(baseDir,storefile),stream.getChannel(),storefile.length() > 0);
          }
  finally {
            stream.close();
          }
        }
      }
  finally {
        files.close();
      }
    }
 catch (    IOException e) {
      return new FailedResponse<Void>();
    }
  }
  writer.done();
  context=makeSureThereIsAtLeastOneKernelTx(context);
  return packResponse(context,null,ALL);
}","public Response<Void> copyStore(SlaveContext context,StoreWriter writer){
  Collection<XaDataSource> sources=graphDbConfig.getTxModule().getXaDataSourceManager().getAllRegisteredDataSources();
  Pair<String,Long>[] appliedTransactions=new Pair[sources.size()];
  int i=0;
  for (  XaDataSource ds : sources) {
    appliedTransactions[i++]=Pair.of(ds.getName(),ds.getLastCommittedTxId());
    try {
      ds.getXaContainer().getResourceManager().rotateLogicalLog();
    }
 catch (    IOException e) {
      return new FailedResponse<Void>();
    }
  }
  context=new SlaveContext(context.machineId(),context.getEventIdentifier(),appliedTransactions);
  File baseDir=getBaseDir();
  for (  XaDataSource ds : sources) {
    try {
      ClosableIterable<File> files=ds.listStoreFiles();
      try {
        for (        File storefile : files) {
          FileInputStream stream=new FileInputStream(storefile);
          try {
            writer.write(relativePath(baseDir,storefile),stream.getChannel(),storefile.length() > 0);
          }
  finally {
            stream.close();
          }
        }
      }
  finally {
        files.close();
      }
    }
 catch (    IOException e) {
      return new FailedResponse<Void>();
    }
  }
  writer.done();
  context=makeSureThereIsAtLeastOneKernelTx(context);
  return packResponse(context,null,ALL);
}",0.9857035364936042
154581,"public void run(){
  try {
    finalType.serializer.write(response.response(),chunkingBuffer);
    if (finalType.includesSlaveContext()) {
      writeTransactionStreams(response.transactions(),chunkingBuffer,targetByteBuffer);
    }
    chunkingBuffer.done();
    if (finalType == RequestType.FINISH || finalType == RequestType.PULL_UPDATES) {
      unmapSlave(channel,finalContext);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","public void run(){
  try {
    finalType.serializer.write(response.response(),chunkingBuffer);
    if (finalType.includesSlaveContext()) {
      writeTransactionStreams(response.transactions(),chunkingBuffer,targetByteBuffer);
    }
    chunkingBuffer.done();
    if (finalType == RequestType.FINISH || finalType == RequestType.PULL_UPDATES) {
      unmapSlave(channel,finalContext);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
catch (  RuntimeException e) {
    e.printStackTrace();
    throw e;
  }
}",0.9301435406698564
154582,"@SuppressWarnings(""String_Node_Str"") private void handleRequest(Master realMaster,ChannelBuffer buffer,final Channel channel) throws IOException {
  byte continuation=buffer.readByte();
  if (continuation == ChunkingChannelBuffer.CONTINUATION_MORE) {
    PartialRequest partialRequest=partialRequests.get(channel);
    if (partialRequest == null) {
      RequestType type=RequestType.values()[buffer.readByte()];
      SlaveContext context=null;
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      Pair<ChannelBuffer,ByteBuffer> targetBuffers=mapSlave(channel,context);
      partialRequest=new PartialRequest(type,context,targetBuffers);
      partialRequests.put(channel,partialRequest);
    }
    partialRequest.add(buffer);
  }
 else {
    PartialRequest partialRequest=partialRequests.remove(channel);
    RequestType type=null;
    SlaveContext context=null;
    Pair<ChannelBuffer,ByteBuffer> targetBuffers;
    ChannelBuffer bufferToReadFrom=null;
    ChannelBuffer bufferToWriteTo=null;
    if (partialRequest == null) {
      type=RequestType.values()[buffer.readByte()];
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      targetBuffers=mapSlave(channel,context);
      bufferToReadFrom=buffer;
      bufferToWriteTo=targetBuffers.first();
    }
 else {
      type=partialRequest.type;
      context=partialRequest.slaveContext;
      targetBuffers=partialRequest.buffers;
      partialRequest.add(buffer);
      bufferToReadFrom=targetBuffers.first();
      bufferToWriteTo=ChannelBuffers.dynamicBuffer();
    }
    bufferToWriteTo.clear();
    final ChunkingChannelBuffer chunkingBuffer=new ChunkingChannelBuffer(bufferToWriteTo,channel,MAX_FRAME_LENGTH);
    final Response<?> response=type.caller.callMaster(realMaster,context,bufferToReadFrom,chunkingBuffer);
    final ByteBuffer targetByteBuffer=targetBuffers.other();
    final RequestType finalType=type;
    final SlaveContext finalContext=context;
    executor.submit(new Runnable(){
      public void run(){
        try {
          finalType.serializer.write(response.response(),chunkingBuffer);
          if (finalType.includesSlaveContext()) {
            writeTransactionStreams(response.transactions(),chunkingBuffer,targetByteBuffer);
          }
          chunkingBuffer.done();
          if (finalType == RequestType.FINISH || finalType == RequestType.PULL_UPDATES) {
            unmapSlave(channel,finalContext);
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
          throw new RuntimeException(e);
        }
      }
    }
);
  }
}","@SuppressWarnings(""String_Node_Str"") private void handleRequest(Master realMaster,ChannelBuffer buffer,final Channel channel) throws IOException {
  byte continuation=buffer.readByte();
  if (continuation == ChunkingChannelBuffer.CONTINUATION_MORE) {
    PartialRequest partialRequest=partialRequests.get(channel);
    if (partialRequest == null) {
      RequestType type=RequestType.values()[buffer.readByte()];
      SlaveContext context=null;
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      Pair<ChannelBuffer,ByteBuffer> targetBuffers=mapSlave(channel,context);
      partialRequest=new PartialRequest(type,context,targetBuffers);
      partialRequests.put(channel,partialRequest);
    }
    partialRequest.add(buffer);
  }
 else {
    PartialRequest partialRequest=partialRequests.remove(channel);
    RequestType type=null;
    SlaveContext context=null;
    Pair<ChannelBuffer,ByteBuffer> targetBuffers;
    ChannelBuffer bufferToReadFrom=null;
    ChannelBuffer bufferToWriteTo=null;
    if (partialRequest == null) {
      type=RequestType.values()[buffer.readByte()];
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      targetBuffers=mapSlave(channel,context);
      bufferToReadFrom=buffer;
      bufferToWriteTo=targetBuffers.first();
    }
 else {
      type=partialRequest.type;
      context=partialRequest.slaveContext;
      targetBuffers=partialRequest.buffers;
      partialRequest.add(buffer);
      bufferToReadFrom=targetBuffers.first();
      bufferToWriteTo=ChannelBuffers.dynamicBuffer();
    }
    bufferToWriteTo.clear();
    final ChunkingChannelBuffer chunkingBuffer=new ChunkingChannelBuffer(bufferToWriteTo,channel,MAX_FRAME_LENGTH);
    final Response<?> response=type.caller.callMaster(realMaster,context,bufferToReadFrom,chunkingBuffer);
    final ByteBuffer targetByteBuffer=targetBuffers.other();
    final RequestType finalType=type;
    final SlaveContext finalContext=context;
    executor.submit(new Runnable(){
      public void run(){
        try {
          finalType.serializer.write(response.response(),chunkingBuffer);
          if (finalType.includesSlaveContext()) {
            writeTransactionStreams(response.transactions(),chunkingBuffer,targetByteBuffer);
          }
          chunkingBuffer.done();
          if (finalType == RequestType.FINISH || finalType == RequestType.PULL_UPDATES) {
            unmapSlave(channel,finalContext);
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
          throw new RuntimeException(e);
        }
catch (        RuntimeException e) {
          e.printStackTrace();
          throw e;
        }
      }
    }
);
  }
}",0.980865688277912
154583,"public void write(String path,ReadableByteChannel data,boolean hasData) throws IOException {
  try {
    File file=new File(basePath,path);
    RandomAccessFile randomAccessFile=null;
    try {
      file.getParentFile().mkdirs();
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      if (hasData) {
        ByteBuffer intermediateBuffer=ByteBuffer.allocateDirect(1024);
        FileChannel channel=randomAccessFile.getChannel();
        while (data.read(intermediateBuffer) >= 0) {
          intermediateBuffer.flip();
          channel.write(intermediateBuffer);
          intermediateBuffer.clear();
        }
      }
    }
  finally {
      if (randomAccessFile != null) {
        randomAccessFile.close();
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    throw new IOException(t);
  }
}","public void write(String path,ReadableByteChannel data,boolean hasData) throws IOException {
  try {
    File file=new File(basePath,path);
    RandomAccessFile randomAccessFile=null;
    try {
      file.getParentFile().mkdirs();
      randomAccessFile=new RandomAccessFile(file,""String_Node_Str"");
      if (hasData) {
        ByteBuffer intermediateBuffer=ByteBuffer.allocateDirect(1024);
        FileChannel channel=randomAccessFile.getChannel();
        while (data.read(intermediateBuffer) >= 0) {
          intermediateBuffer.flip();
          channel.write(intermediateBuffer);
          intermediateBuffer.clear();
        }
      }
      System.out.println(""String_Node_Str"" + file);
    }
  finally {
      if (randomAccessFile != null) {
        randomAccessFile.close();
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    throw new IOException(t);
  }
}",0.9698025551684089
154584,"protected void setDataChangeWatcher(String child,int currentMasterId){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + child;
    byte[] data=null;
    boolean exists=false;
    try {
      data=zooKeeper.getData(path,true,null);
      exists=true;
      int id=ByteBuffer.wrap(data).getInt();
      if (currentMasterId == -1 || id == currentMasterId) {
        return;
      }
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[4];
      ByteBuffer.wrap(data).putInt(currentMasterId);
      if (!exists) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
 else       if (currentMasterId != -1) {
        zooKeeper.setData(path,data,-1);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","protected void setDataChangeWatcher(String child,int currentMasterId){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + child;
    byte[] data=null;
    boolean exists=false;
    try {
      data=zooKeeper.getData(path,true,null);
      exists=true;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[4];
      ByteBuffer.wrap(data).putInt(currentMasterId);
      if (!exists) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
 else       if (currentMasterId != -1) {
        zooKeeper.setData(path,data,-1);
        msgLog.logMessage(child + ""String_Node_Str"" + currentMasterId);
      }
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9496683573936792
154585,"public void process(WatchedEvent event){
  try {
    String path=event.getPath();
    msgLog.logMessage(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"",true);
    if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
      keeperState=KeeperState.Expired;
      if (zooKeeper != null) {
        try {
          zooKeeper.close();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          Thread.interrupted();
        }
      }
      zooKeeper=instantiateZooKeeper();
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
      long newSessionId=zooKeeper.getSessionId();
      Pair<Master,Machine> masterBeforeIWrite=getMasterFromZooKeeper(false);
      msgLog.logMessage(""String_Node_Str"" + masterBeforeIWrite);
      boolean masterBeforeIWriteDiffers=masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId();
      if (newSessionId != sessionId || masterBeforeIWriteDiffers) {
        sequenceNr=setup();
        msgLog.logMessage(""String_Node_Str"" + sequenceNr + ""String_Node_Str""+ newSessionId);
        keeperState=KeeperState.SyncConnected;
        Pair<Master,Machine> masterAfterIWrote=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterAfterIWrote);
        int masterId=masterAfterIWrote.other().getMachineId();
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,masterId);
        if (sessionId != -1) {
          receiver.newMaster(masterAfterIWrote,new Exception());
        }
        sessionId=newSessionId;
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + sessionId);
        keeperState=KeeperState.SyncConnected;
      }
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
      keeperState=KeeperState.Disconnected;
    }
 else     if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
      Pair<Master,Machine> currentMaster=getMasterFromZooKeeper(true);
      if (path.contains(MASTER_NOTIFY_CHILD)) {
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,-1);
        if (currentMaster.other().getMachineId() == machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else       if (path.contains(MASTER_REBOUND_CHILD)) {
        setDataChangeWatcher(MASTER_REBOUND_CHILD,-1);
        if (currentMaster.other().getMachineId() != machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + path);
      }
    }
  }
 catch (  RuntimeException e) {
    msgLog.logMessage(""String_Node_Str"",e,true);
    e.printStackTrace();
    throw e;
  }
 finally {
    msgLog.flush();
  }
}","public void process(WatchedEvent event){
  try {
    String path=event.getPath();
    msgLog.logMessage(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"",true);
    if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
      keeperState=KeeperState.Expired;
      if (zooKeeper != null) {
        try {
          zooKeeper.close();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          Thread.interrupted();
        }
      }
      zooKeeper=instantiateZooKeeper();
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
      long newSessionId=zooKeeper.getSessionId();
      Pair<Master,Machine> masterBeforeIWrite=getMasterFromZooKeeper(false);
      msgLog.logMessage(""String_Node_Str"" + masterBeforeIWrite);
      boolean masterBeforeIWriteDiffers=masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId();
      if (newSessionId != sessionId || masterBeforeIWriteDiffers) {
        sequenceNr=setup();
        msgLog.logMessage(""String_Node_Str"" + sequenceNr + ""String_Node_Str""+ newSessionId);
        keeperState=KeeperState.SyncConnected;
        Pair<Master,Machine> masterAfterIWrote=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterAfterIWrote);
        int masterId=masterAfterIWrote.other().getMachineId();
        msgLog.logMessage(""String_Node_Str"" + MASTER_NOTIFY_CHILD + ""String_Node_Str""+ masterId);
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,masterId);
        msgLog.logMessage(""String_Node_Str"" + MASTER_NOTIFY_CHILD + ""String_Node_Str""+ masterId);
        if (sessionId != -1) {
          receiver.newMaster(masterAfterIWrote,new Exception());
        }
        sessionId=newSessionId;
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + sessionId);
        keeperState=KeeperState.SyncConnected;
      }
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
      keeperState=KeeperState.Disconnected;
    }
 else     if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
      Pair<Master,Machine> currentMaster=getMasterFromZooKeeper(true);
      if (path.contains(MASTER_NOTIFY_CHILD)) {
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,-1);
        if (currentMaster.other().getMachineId() == machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else       if (path.contains(MASTER_REBOUND_CHILD)) {
        setDataChangeWatcher(MASTER_REBOUND_CHILD,-1);
        if (currentMaster.other().getMachineId() != machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + path);
      }
    }
  }
 catch (  RuntimeException e) {
    msgLog.logMessage(""String_Node_Str"",e,true);
    e.printStackTrace();
    throw e;
  }
 finally {
    msgLog.flush();
  }
}",0.9590361445783132
154586,"public static void main(String[] args) throws Exception {
  for (  File file : new File(""String_Node_Str"").listFiles()) {
    try {
      if (file.getName().contains(""String_Node_Str"") && !file.getName().endsWith(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
        DumpLogicalLog.main(new String[]{file.getPath()});
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public static void main(String[] args) throws Exception {
  for (  File file : sorted(new File(""String_Node_Str"").listFiles())) {
    try {
      if (file.getName().contains(""String_Node_Str"") && !file.getName().endsWith(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
        DumpLogicalLog.main(new String[]{file.getPath()});
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.9913232104121475
154587,"public IndexProviderStore(String store){
  if (!new File(store).exists()) {
    create(store);
  }
  try {
    fileChannel=new RandomAccessFile(store,""String_Node_Str"").getChannel();
    int bytesRead=fileChannel.read(buf);
    if (bytesRead != FILE_LENGTH && bytesRead != FILE_LENGTH - 8) {
      throw new RuntimeException(""String_Node_Str"" + FILE_LENGTH + ""String_Node_Str""+ (FILE_LENGTH - 8)+ ""String_Node_Str"");
    }
    buf.flip();
    creationTime=buf.getLong();
    randomIdentifier=buf.getLong();
    version=buf.getLong();
    lastCommittedTx=bytesRead == FILE_LENGTH ? buf.getLong() : 1;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public IndexProviderStore(File file){
  this.file=file;
  if (!file.exists()) {
    create(file);
  }
  try {
    fileChannel=new RandomAccessFile(file,""String_Node_Str"").getChannel();
    int bytesRead=fileChannel.read(buf);
    if (bytesRead != FILE_LENGTH && bytesRead != FILE_LENGTH - 8) {
      throw new RuntimeException(""String_Node_Str"" + FILE_LENGTH + ""String_Node_Str""+ (FILE_LENGTH - 8)+ ""String_Node_Str"");
    }
    buf.flip();
    creationTime=buf.getLong();
    randomIdentifier=buf.getLong();
    version=buf.getLong();
    lastCommittedTx=bytesRead == FILE_LENGTH ? buf.getLong() : 1;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9479166666666666
154588,"static void create(String store){
  if (new File(store).exists()) {
    throw new IllegalArgumentException(store + ""String_Node_Str"");
  }
  try {
    FileChannel fileChannel=new RandomAccessFile(store,""String_Node_Str"").getChannel();
    ByteBuffer buf=ByteBuffer.allocate(FILE_LENGTH);
    long time=System.currentTimeMillis();
    long identifier=new Random(time).nextLong();
    buf.putLong(time).putLong(identifier).putLong(0).putLong(1);
    buf.flip();
    writeBuffer(fileChannel,buf);
    fileChannel.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","static void create(File file){
  if (file.exists()) {
    throw new IllegalArgumentException(file + ""String_Node_Str"");
  }
  try {
    FileChannel fileChannel=new RandomAccessFile(file,""String_Node_Str"").getChannel();
    ByteBuffer buf=ByteBuffer.allocate(FILE_LENGTH);
    long time=System.currentTimeMillis();
    long identifier=new Random(time).nextLong();
    buf.putLong(time).putLong(identifier).putLong(0).putLong(1);
    buf.flip();
    writeBuffer(fileChannel,buf);
    fileChannel.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9553264604810996
154589,"@Override public ClosableIterable<File> listStoreFiles(){
  final Collection<File> files=new ArrayList<File>();
  for (  File neostoreFile : new File(storeDir).listFiles()) {
    String name=neostoreFile.getName();
    if (neostoreFile.isFile() && (name.startsWith(""String_Node_Str"") || name.equals(IndexStore.INDEX_DB_FILE_NAME))) {
      files.add(neostoreFile);
    }
  }
  return new ClosableIterable<File>(){
    public Iterator<File> iterator(){
      return files.iterator();
    }
    public void close(){
    }
  }
;
}","@Override public ClosableIterable<File> listStoreFiles(){
  final Collection<File> files=new ArrayList<File>();
  for (  File neostoreFile : new File(storeDir).listFiles()) {
    String name=neostoreFile.getName();
    if (neostoreFile.isFile() && (name.startsWith(""String_Node_Str"") || name.equals(IndexStore.INDEX_DB_FILE_NAME)) && !name.endsWith(""String_Node_Str"")) {
      files.add(neostoreFile);
    }
  }
  return new ClosableIterable<File>(){
    public Iterator<File> iterator(){
      return files.iterator();
    }
    public void close(){
    }
  }
;
}",0.9660861594867094
154590,"@Test public void testApplyLogicalLog() throws Exception {
  ds.keepLogicalLogs(true);
  Xid xid=new XidImpl(new byte[1],new byte[1]);
  XAResource xaRes=xaCon.getXaResource();
  xaRes.start(xid,XAResource.TMNOFLAGS);
  int node1=ds.nextId(Node.class);
  xaCon.getNodeConsumer().createNode(node1);
  int node2=ds.nextId(Node.class);
  xaCon.getNodeConsumer().createNode(node2);
  int n1prop1=ds.nextId(PropertyStore.class);
  xaCon.getNodeConsumer().addProperty(node1,n1prop1,index(""String_Node_Str""),""String_Node_Str"");
  xaCon.getNodeConsumer().getProperties(node1,false);
  int relType1=ds.nextId(RelationshipType.class);
  xaCon.getRelationshipTypeConsumer().addRelationshipType(relType1,""String_Node_Str"");
  int rel1=ds.nextId(Relationship.class);
  xaCon.getRelationshipConsumer().createRelationship(rel1,node1,node2,relType1);
  int r1prop1=ds.nextId(PropertyStore.class);
  xaCon.getRelationshipConsumer().addProperty(rel1,r1prop1,index(""String_Node_Str""),""String_Node_Str"");
  xaCon.getNodeConsumer().changeProperty(node1,n1prop1,""String_Node_Str"");
  xaCon.getRelationshipConsumer().changeProperty(rel1,r1prop1,""String_Node_Str"");
  xaCon.getNodeConsumer().removeProperty(node1,n1prop1);
  xaCon.getRelationshipConsumer().removeProperty(rel1,r1prop1);
  xaCon.getRelationshipConsumer().deleteRelationship(rel1);
  xaCon.getNodeConsumer().deleteNode(node1);
  xaCon.getNodeConsumer().deleteNode(node2);
  xaRes.end(xid,XAResource.TMSUCCESS);
  xaRes.commit(xid,true);
  long currentVersion=ds.getCurrentLogVersion();
  ds.keepLogicalLogs(true);
  ds.rotateLogicalLog();
  ds.rotateLogicalLog();
  ds.rotateLogicalLog();
  ds.setCurrentLogVersion(currentVersion);
  ds.setCommittedTxId(0);
  ds.makeBackupSlave();
  ds.applyLog(ds.getLogicalLog(currentVersion));
  ds.applyLog(ds.getLogicalLog(currentVersion + 1));
  ds.applyLog(ds.getLogicalLog(currentVersion + 2));
  ds.keepLogicalLogs(false);
}","@Test public void testApplyLogicalLog() throws Exception {
  ds.keepLogicalLogs(true);
  Xid xid=new XidImpl(new byte[1],new byte[1]);
  XAResource xaRes=xaCon.getXaResource();
  xaRes.start(xid,XAResource.TMNOFLAGS);
  int node1=ds.nextId(Node.class);
  xaCon.getNodeConsumer().createNode(node1);
  int node2=ds.nextId(Node.class);
  xaCon.getNodeConsumer().createNode(node2);
  int n1prop1=ds.nextId(PropertyStore.class);
  xaCon.getNodeConsumer().addProperty(node1,n1prop1,index(""String_Node_Str""),""String_Node_Str"");
  xaCon.getNodeConsumer().getProperties(node1,false);
  int relType1=ds.nextId(RelationshipType.class);
  xaCon.getRelationshipTypeConsumer().addRelationshipType(relType1,""String_Node_Str"");
  int rel1=ds.nextId(Relationship.class);
  xaCon.getRelationshipConsumer().createRelationship(rel1,node1,node2,relType1);
  int r1prop1=ds.nextId(PropertyStore.class);
  xaCon.getRelationshipConsumer().addProperty(rel1,r1prop1,index(""String_Node_Str""),""String_Node_Str"");
  xaCon.getNodeConsumer().changeProperty(node1,n1prop1,""String_Node_Str"");
  xaCon.getRelationshipConsumer().changeProperty(rel1,r1prop1,""String_Node_Str"");
  xaCon.getNodeConsumer().removeProperty(node1,n1prop1);
  xaCon.getRelationshipConsumer().removeProperty(rel1,r1prop1);
  xaCon.getRelationshipConsumer().deleteRelationship(rel1);
  xaCon.getNodeConsumer().deleteNode(node1);
  xaCon.getNodeConsumer().deleteNode(node2);
  xaRes.end(xid,XAResource.TMSUCCESS);
  xaRes.commit(xid,true);
  long currentVersion=ds.getCurrentLogVersion();
  ds.keepLogicalLogs(true);
  ds.rotateLogicalLog();
  ds.rotateLogicalLog();
  ds.rotateLogicalLog();
  ds.setCurrentLogVersion(currentVersion);
  ds.setLastCommittedTxId(0);
  ds.makeBackupSlave();
  ds.applyLog(ds.getLogicalLog(currentVersion));
  ds.applyLog(ds.getLogicalLog(currentVersion + 1));
  ds.applyLog(ds.getLogicalLog(currentVersion + 2));
  ds.keepLogicalLogs(false);
}",0.998952879581152
154591,"static IndexProviderStore newIndexStore(String dbStoreDir){
  return new IndexProviderStore(getStoreDir(dbStoreDir).first() + ""String_Node_Str"");
}","static IndexProviderStore newIndexStore(String dbStoreDir){
  File file=new File(getStoreDir(dbStoreDir).first() + ""String_Node_Str"");
  return new IndexProviderStore(file);
}",0.782608695652174
154592,"@Override public ClosableIterable<File> listStoreFiles() throws IOException {
  final Collection<File> files=new ArrayList<File>();
  final Collection<SnapshotDeletionPolicy> snapshots=new ArrayList<SnapshotDeletionPolicy>();
  for (  Map.Entry<IndexIdentifier,Triplet<IndexWriter,AtomicBoolean,SnapshotDeletionPolicy>> writer : indexWriters.entrySet()) {
    SnapshotDeletionPolicy deletionPolicy=writer.getValue().third();
    File indexDirectory=getFileDirectory(baseStorePath,writer.getKey());
    for (    String fileName : deletionPolicy.snapshot().getFileNames()) {
      files.add(new File(indexDirectory,fileName));
    }
    snapshots.add(deletionPolicy);
  }
  return new ClosableIterable<File>(){
    public Iterator<File> iterator(){
      return files.iterator();
    }
    public void close(){
      for (      SnapshotDeletionPolicy deletionPolicy : snapshots) {
        deletionPolicy.release();
      }
    }
  }
;
}","@Override public ClosableIterable<File> listStoreFiles() throws IOException {
  final Collection<File> files=new ArrayList<File>();
  final Collection<SnapshotDeletionPolicy> snapshots=new ArrayList<SnapshotDeletionPolicy>();
  for (  Map.Entry<IndexIdentifier,Triplet<IndexWriter,AtomicBoolean,SnapshotDeletionPolicy>> writer : indexWriters.entrySet()) {
    SnapshotDeletionPolicy deletionPolicy=writer.getValue().third();
    File indexDirectory=getFileDirectory(baseStorePath,writer.getKey());
    for (    String fileName : deletionPolicy.snapshot().getFileNames()) {
      files.add(new File(indexDirectory,fileName));
    }
    snapshots.add(deletionPolicy);
  }
  files.add(providerStore.getFile());
  return new ClosableIterable<File>(){
    public Iterator<File> iterator(){
      return files.iterator();
    }
    public void close(){
      for (      SnapshotDeletionPolicy deletionPolicy : snapshots) {
        deletionPolicy.release();
      }
    }
  }
;
}",0.9800629590766002
154593,"private EmbeddedGraphDbImpl localGraph(){
  if (localGraph == null) {
    if (causeOfShutdown != null) {
      throw causeOfShutdown;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return localGraph;
}","private EmbeddedGraphDbImpl localGraph(){
  if (localGraph == null) {
    if (causeOfShutdown != null) {
      throw causeOfShutdown;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return localGraph;
}",0.9588477366255144
154594,"public synchronized void internalShutdown(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ this,true);
  if (this.updatePuller != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.updatePuller.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.updatePuller=null;
  }
  if (this.masterServer != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.masterServer.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.masterServer=null;
  }
  if (this.localGraph != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.localGraph.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.localGraph=null;
  }
}","public synchronized void internalShutdown(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ this+ ""String_Node_Str""+ masterServer,true);
  if (this.updatePuller != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.updatePuller.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.updatePuller=null;
  }
  if (this.masterServer != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.masterServer.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.masterServer=null;
  }
  if (this.localGraph != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.localGraph.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.localGraph=null;
  }
}",0.9772256728778468
154595,"private void newMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e,true);
    reevaluateMyself(master,storeId);
  }
 catch (  ZooKeeperException ee) {
    ee.printStackTrace();
  }
catch (  HaCommunicationException ee) {
    ee.printStackTrace();
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"",true);
    shutdown(t instanceof RuntimeException ? (RuntimeException)t : new RuntimeException(t));
    if (t instanceof RuntimeException) {
      throw (RuntimeException)t;
    }
    throw new RuntimeException(t);
  }
}","private void newMaster(Pair<Master,Machine> master,StoreId storeId,Exception e){
  try {
    doNewMaster(master,storeId,e);
  }
 catch (  BranchedDataException bde) {
    System.out.println(""String_Node_Str"");
    cleanDatabase();
    doNewMaster(master,storeId,bde);
  }
}",0.2568421052631578
154596,"protected synchronized void reevaluateMyself(Pair<Master,Machine> master,StoreId storeId){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster(storeId);
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave(storeId);
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}","protected synchronized void reevaluateMyself(Pair<Master,Machine> master,StoreId storeId){
  boolean foundOutRightNow=false;
  if (master == null) {
    master=broker.getMasterReally();
    foundOutRightNow=true;
  }
  System.out.println(machineId + ""String_Node_Str"" + (foundOutRightNow ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ master+ ""String_Node_Str"");
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster(storeId);
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave(storeId);
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}",0.8984841525034452
154597,"/** 
 * Only for testing (and   {@link org.neo4j.kernel.ha.BackupFromHaCluster})
 */
public HighlyAvailableGraphDatabase(String storeDir,Map<String,String> config,BrokerFactory brokerFactory){
  if (config == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.storeDir=storeDir;
  this.config=config;
  config.put(Config.KEEP_LOGICAL_LOGS,""String_Node_Str"");
  this.brokerFactory=brokerFactory != null ? brokerFactory : defaultBrokerFactory(storeDir,config);
  this.machineId=getMachineIdFromConfig(config);
  this.broker=this.brokerFactory.create(storeDir,config);
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  startUp(getAllowInitFromConfig(config));
}","/** 
 * Only for testing (and   {@link org.neo4j.kernel.ha.BackupFromHaCluster})
 */
public HighlyAvailableGraphDatabase(String storeDir,Map<String,String> config,BrokerFactory brokerFactory){
  if (config == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.storeDir=storeDir;
  this.config=config;
  config.put(Config.KEEP_LOGICAL_LOGS,""String_Node_Str"");
  this.brokerFactory=brokerFactory != null ? brokerFactory : defaultBrokerFactory(storeDir,config);
  this.machineId=getMachineIdFromConfig(config);
  this.broker=this.brokerFactory.create(storeDir,config);
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  boolean allowInitFromConfig=getAllowInitFromConfig(config);
  startUp(allowInitFromConfig);
}",0.9486652977412732
154598,"private void startUp(boolean allowInit){
  StoreId storeId=null;
  if (!new File(storeDir,""String_Node_Str"").exists()) {
    MASTER_ARBITRATION:     while (true) {
      Pair<Master,Machine> master=broker.getMaster();
      master=master.first() != null ? master : broker.getMasterReally();
      if (master != null && master.first() != null) {
        master.first().copyStore(new SlaveContext(machineId,0,new Pair[0]),new ToFileStoreWriter(storeDir));
        break MASTER_ARBITRATION;
      }
 else       if (allowInit) {
        StoreId myStoreId=new StoreId();
        storeId=broker.createCluster(myStoreId);
        if (storeId.equals(myStoreId)) {
          break MASTER_ARBITRATION;
        }
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
    }
  }
  newMaster(null,storeId,new Exception());
  localGraph();
}","private void startUp(boolean allowInit){
  StoreId storeId=null;
  if (!new File(storeDir,""String_Node_Str"").exists()) {
    startupLatch=new CountDownLatch(1);
    try {
      long endTime=System.currentTimeMillis() + 10000;
      MASTER_ARBITRATION:       while (System.currentTimeMillis() < endTime) {
        Pair<Master,Machine> master=broker.getMaster();
        master=master.first() != null ? master : broker.getMasterReally();
        if (master != null && master.first() != null) {
          if (copyStoreFromMaster(master)) {
            break MASTER_ARBITRATION;
          }
        }
 else         if (allowInit) {
          StoreId myStoreId=new StoreId();
          storeId=broker.createCluster(myStoreId);
          if (storeId.equals(myStoreId)) {
            break MASTER_ARBITRATION;
          }
        }
        sleepWithoutInterruption(100,""String_Node_Str"");
      }
    }
  finally {
      startupLatch.countDown();
      startupLatch=null;
    }
  }
  newMaster(null,storeId,new Exception());
  localGraph();
}",0.7351296390442298
154599,"public Response<Void> finishTransaction(SlaveContext context){
  try {
    return sendRequest(RequestType.FINISH,context,new Serializer(){
      public void write(      ChannelBuffer buffer,      ByteBuffer readBuffer) throws IOException {
      }
    }
,VOID_DESERIALIZER);
  }
  finally {
    releaseChannel();
  }
}","public Response<Void> finishTransaction(SlaveContext context){
  return sendRequest(RequestType.FINISH,context,new Serializer(){
    public void write(    ChannelBuffer buffer,    ByteBuffer readBuffer) throws IOException {
    }
  }
,VOID_DESERIALIZER);
}",0.89198606271777
154600,"private <T>Response<T> sendRequest(RequestType type,SlaveContext slaveContext,Serializer serializer,Deserializer<T> deserializer){
  Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext=null;
  try {
    channelContext=getChannel();
    Channel channel=channelContext.first();
    ChannelBuffer buffer=channelContext.second();
    buffer.clear();
    buffer=new ChunkingChannelBuffer(buffer,channel,MAX_FRAME_LENGTH);
    buffer.writeByte(type.ordinal());
    if (type.includesSlaveContext()) {
      writeSlaveContext(buffer,slaveContext);
    }
    serializer.write(buffer,channelContext.third());
    if (buffer.writerIndex() > 0) {
      channel.write(buffer);
    }
    @SuppressWarnings(""String_Node_Str"") BlockingReadHandler<ChannelBuffer> reader=(BlockingReadHandler<ChannelBuffer>)channel.getPipeline().get(""String_Node_Str"");
    final Triplet<Channel,ChannelBuffer,ByteBuffer> finalChannelContext=channelContext;
    DechunkingChannelBuffer dechunkingBuffer=new DechunkingChannelBuffer(reader){
      @Override protected ChannelBuffer readNext(){
        ChannelBuffer result=super.readNext();
        if (result == null) {
          channelPool.dispose(finalChannelContext);
          throw new HaCommunicationException(""String_Node_Str"");
        }
        return result;
      }
    }
;
    T response=deserializer.read(dechunkingBuffer);
    TransactionStream txStreams=type.includesSlaveContext() ? readTransactionStreams(dechunkingBuffer) : TransactionStream.EMPTY;
    return new Response<T>(response,txStreams);
  }
 catch (  ClosedChannelException e) {
    channelPool.dispose(channelContext);
    throw new HaCommunicationException(e);
  }
catch (  IOException e) {
    throw new HaCommunicationException(e);
  }
catch (  InterruptedException e) {
    throw new HaCommunicationException(e);
  }
catch (  Exception e) {
    throw new HaCommunicationException(e);
  }
}","private <T>Response<T> sendRequest(RequestType type,SlaveContext slaveContext,Serializer serializer,Deserializer<T> deserializer){
  Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext=null;
  try {
    channelContext=getChannel();
    Channel channel=channelContext.first();
    ChannelBuffer buffer=channelContext.second();
    buffer.clear();
    buffer=new ChunkingChannelBuffer(buffer,channel,MAX_FRAME_LENGTH);
    buffer.writeByte(type.ordinal());
    if (type.includesSlaveContext()) {
      writeSlaveContext(buffer,slaveContext);
    }
    serializer.write(buffer,channelContext.third());
    if (buffer.writerIndex() > 0) {
      channel.write(buffer);
    }
    @SuppressWarnings(""String_Node_Str"") BlockingReadHandler<ChannelBuffer> reader=(BlockingReadHandler<ChannelBuffer>)channel.getPipeline().get(""String_Node_Str"");
    final Triplet<Channel,ChannelBuffer,ByteBuffer> finalChannelContext=channelContext;
    DechunkingChannelBuffer dechunkingBuffer=new DechunkingChannelBuffer(reader){
      @Override protected ChannelBuffer readNext(){
        ChannelBuffer result=super.readNext();
        if (result == null) {
          channelPool.dispose(finalChannelContext);
          throw new HaCommunicationException(""String_Node_Str"");
        }
        return result;
      }
    }
;
    T response=deserializer.read(dechunkingBuffer);
    TransactionStream txStreams=type.includesSlaveContext() ? readTransactionStreams(dechunkingBuffer) : TransactionStream.EMPTY;
    return new Response<T>(response,txStreams);
  }
 catch (  ClosedChannelException e) {
    channelPool.dispose(channelContext);
    throw new HaCommunicationException(e);
  }
catch (  IOException e) {
    throw new HaCommunicationException(e);
  }
catch (  InterruptedException e) {
    throw new HaCommunicationException(e);
  }
catch (  Exception e) {
    throw new HaCommunicationException(e);
  }
 finally {
    releaseChannel();
  }
}",0.9903166710285266
154601,"public GremlinSession(Database database){
  this.database=database;
  baos=new ByteArrayOutputStream();
  BufferedOutputStream out=new BufferedOutputStream(baos);
  io=new IO(System.in,out,out);
  Map bindings=new HashMap();
  bindings.put(""String_Node_Str"",getGremlinWrappedGraph());
  scriptEngine=new GremlinWebConsole(new Binding(bindings),io);
}","public GremlinSession(Database database){
  this.database=database;
  PrintStream out=new PrintStream(new BufferedOutputStream(baos));
  io=new IO(System.in,out,out);
  Map<String,Object> bindings=new HashMap<String,Object>();
  bindings.put(""String_Node_Str"",getGremlinWrappedGraph());
  bindings.put(""String_Node_Str"",out);
  scriptEngine=new GremlinWebConsole(new Binding(bindings),io);
}",0.7584345479082322
154602,"private void resetIO(){
  baos=new ByteArrayOutputStream();
  BufferedOutputStream out=new BufferedOutputStream(baos);
  IO io=new IO(System.in,out,out);
  scriptEngine.groovy.setResultHook(new ResultHookClosure(scriptEngine.groovy,io));
}","private void resetIO(){
  baos.reset();
}",0.2642857142857143
154603,"/** 
 * Take some gremlin script, evaluate it in the context of this gremlin session, and return the result.
 * @param script
 * @return
 */
@Override public String evaluate(String script){
  scriptEngine.groovy.execute(script);
  String result=baos.toString();
  resetIO();
  return result;
}","/** 
 * Take some gremlin script, evaluate it in the context of this gremlin session, and return the result.
 * @param script
 * @return
 */
@Override public String evaluate(String script){
  try {
    scriptEngine.groovy.execute(script);
    String result=baos.toString();
    resetIO();
    return result;
  }
 catch (  GroovyRuntimeException ex) {
    return ex.getMessage();
  }
}",0.8212703101920237
154604,"public GremlinWebConsole(Binding bindings,IO io){
  groovy=new Groovysh(bindings,io);
  groovy.setResultHook(new NullResultHookClosure(groovy));
  for (  String imps : Imports.getImports()) {
    groovy.execute(""String_Node_Str"" + imps);
  }
  groovy.setResultHook(new ResultHookClosure(groovy,io));
  Gremlin.load();
}","public GremlinWebConsole(Binding bindings,IO io){
  groovy=new Groovysh(bindings,io);
  groovy.setResultHook(new NullResultHookClosure(groovy));
  for (  String imps : Imports.getImports()) {
    groovy.execute(""String_Node_Str"" + imps);
  }
  groovy.setResultHook(new GremlinResultHook(groovy,io));
  Gremlin.load();
}",0.9780564263322884
154605,"private void removeFieldsFromDocument(Document document,String key,Object value){
  String stringValue=value.toString();
  Set<String> values=new HashSet<String>(Arrays.asList(document.getValues(key)));
  if (!values.remove(stringValue)) {
    return;
  }
  document.removeFields(key);
  for (  String existingValue : values) {
    addToDocument(document,key,existingValue);
  }
}","abstract void removeFieldsFromDocument(Document document,String key,Object value);",0.3333333333333333
154606,"abstract void removeFromDocument(Document document,String key,Object value);","final void removeFromDocument(Document document,String key,Object value){
  if (key == null && value == null) {
    clearDocument(document);
  }
 else {
    removeFieldsFromDocument(document,key,value);
  }
}",0.4788732394366197
154607,"public int size(){
  return currentIterator().size();
}","public int size(){
  return size;
}",0.7777777777777778
154608,"public CombinedIndexHits(Collection<IndexHits<T>> iterators){
  super(iterators);
  this.allIndexHits=iterators;
}","public CombinedIndexHits(Collection<IndexHits<T>> iterators){
  super(iterators);
  this.allIndexHits=iterators;
  size=accumulatedSize(iterators);
}",0.8669201520912547
154609,"<T extends PropertyContainer>void remove(LuceneIndex<T> index,T entity,String key,Object value){
  value=value instanceof ValueContext ? ((ValueContext)value).getCorrectValue() : value.toString();
  TxDataBoth data=getTxData(index,true);
  insert(index,entity,key,value,data.removed(true),data.added(false));
  queueCommand(index.newRemoveCommand(entity,key,value)).removeCount++;
}","<T extends PropertyContainer>void remove(LuceneIndex<T> index,T entity,String key,Object value){
  value=value instanceof ValueContext ? ((ValueContext)value).getCorrectValue() : value.toString();
  TxDataBoth data=getTxData(index,true);
  insert(index,entity,key,value,data.removed(true),data.added(false));
  queueCommand(index.newRemoveCommand(entity,key,value));
}",0.9813333333333332
154610,"void incCounter(LuceneCommand command){
  if (command instanceof AddCommand) {
    this.addCount++;
  }
 else   if (command instanceof RemoveCommand) {
    this.removeCount++;
  }
}","void incCounter(LuceneCommand command){
  if (command.isConsideredNormalWriteCommand()) {
    containsWrites=true;
  }
}",0.5980066445182725
154611,"private CommandList queueCommand(LuceneCommand command){
  IndexIdentifier indexId=command.indexId;
  CommandList commands=commandMap.get(indexId);
  if (commands == null) {
    commands=new CommandList();
    commandMap.put(indexId,commands);
  }
  if (command instanceof DeleteCommand) {
    commands.clear();
  }
  commands.add(command);
  return commands;
}","private CommandList queueCommand(LuceneCommand command){
  IndexIdentifier indexId=command.indexId;
  CommandList commands=commandMap.get(indexId);
  if (commands == null) {
    commands=new CommandList();
    commandMap.put(indexId,commands);
  }
  if (command instanceof DeleteCommand) {
    commands.clear();
  }
  commands.add(command);
  commands.incCounter(command);
  return commands;
}",0.9575596816976129
154612,"void clear(){
  commands.clear();
  addCount=0;
  removeCount=0;
}","void clear(){
  commands.clear();
  containsWrites=false;
}",0.704
154613,"boolean containsWrites(){
  return addCount + removeCount > 0;
}","boolean containsWrites(){
  return containsWrites;
}",0.7413793103448276
154614,"@Test public void testIndexDeleteIssue() throws Exception {
  GraphDatabaseService db=newGraphDbService();
  db.index().forNodes(""String_Node_Str"");
  db.shutdown();
  Runtime.getRuntime().exec(new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),AddDeleteQuit.class.getName(),getDbPath()}).waitFor();
  new EmbeddedGraphDatabase(getDbPath()).shutdown();
  db.shutdown();
}","@Test public void testIndexDeleteIssue() throws Exception {
  GraphDatabaseService db=newGraphDbService();
  db.index().forNodes(""String_Node_Str"");
  db.shutdown();
  assertEquals(0,Runtime.getRuntime().exec(new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),AddDeleteQuit.class.getName(),getDbPath()}).waitFor());
  new EmbeddedGraphDatabase(getDbPath()).shutdown();
  db.shutdown();
}",0.980722891566265
154615,"private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  try {
    if (master.other().getMachineId() == machineId) {
      return;
    }
    XaDataSource nioneoDataSource=getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
    long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
    long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
    int masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId);
    if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
      msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
      return;
    }
 else {
      String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
      msgLog.logMessage(msg,true);
      RuntimeException exception=new BranchedDataException(msg);
      shutdown(exception);
      throw exception;
    }
  }
 catch (  IOException e) {
    shutdown(new RuntimeException(e));
    throw new RuntimeException(e);
  }
}","private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  if (master.other().getMachineId() == machineId) {
    return;
  }
  XaDataSource nioneoDataSource=getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
  long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
  long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
  int masterForMyHighestCommonTxId=-1;
  try {
    masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    ;
  }
 catch (  IOException e) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str"",e);
    return;
  }
  int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId);
  if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
    msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
    return;
  }
 else {
    String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
    msgLog.logMessage(msg,true);
    RuntimeException exception=new BranchedDataException(msg);
    shutdown(exception);
    throw exception;
  }
}",0.7336112163698371
154616,"protected synchronized void reevaluateMyself(Pair<Master,Machine> master){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster();
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave();
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    broker.setConnectionInformation(this.localGraph.getKernelData());
    for (    TransactionEventHandler<?> handler : transactionEventHandlers) {
      localGraph().registerTransactionEventHandler(handler);
    }
    for (    KernelEventHandler handler : kernelEventHandlers) {
      localGraph().registerKernelEventHandler(handler);
    }
  }
}","protected synchronized void reevaluateMyself(Pair<Master,Machine> master){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster();
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave();
      restarted=true;
    }
 else {
      ((SlaveIdGeneratorFactory)getConfig().getIdGeneratorFactory()).forgetIdAllocationsFromMaster();
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    doAfterLocalGraphStarted();
  }
}",0.843155031731641
154617,"private void startUp(){
  if (!new File(storeDir,""String_Node_Str"").exists()) {
    Pair<Master,Machine> master=broker.getMaster();
    master=master != null ? master : broker.getMasterReally();
    if (master != null && master.first() != null) {
      master.first().copyStore(new SlaveContext(machineId,0,new Pair[0]),new ToFileStoreWriter(storeDir));
    }
 else {
    }
  }
  newMaster(null,new Exception());
  localGraph();
}","private void startUp(){
  if (!new File(storeDir,""String_Node_Str"").exists()) {
    Pair<Master,Machine> master=broker.getMaster();
    master=master.first() != null ? master : broker.getMasterReally();
    if (master != null && master.first() != null) {
      master.first().copyStore(new SlaveContext(machineId,0,new Pair[0]),new ToFileStoreWriter(storeDir));
    }
 else {
    }
  }
  newMaster(null,new Exception());
  localGraph();
}",0.9907834101382488
154618,"private String readRootPath(){
  waitForSyncConnected();
  try {
    List<String> children=getZooKeeper().getChildren(""String_Node_Str"",false);
    String foundChild=null;
    for (    String child : children) {
      if (child.contains(""String_Node_Str"")) {
        if (foundChild != null) {
          throw new RuntimeException(""String_Node_Str"" + foundChild + ""String_Node_Str""+ child);
        }
        foundChild=child;
      }
    }
    if (foundChild != null) {
      System.out.println(""String_Node_Str"" + foundChild + ""String_Node_Str"");
      return ""String_Node_Str"" + foundChild;
    }
    throw new RuntimeException(""String_Node_Str"");
  }
 catch (  KeeperException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}","private String readRootPath(){
  waitForSyncConnected();
  String result=getSingleRootPath(getZooKeeper());
  if (result == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  return result;
}",0.2330677290836653
154619,"public ZooClient(String servers,int machineId,long storeCreationTime,long storeId,long committedTx,ResponseReceiver receiver,String haServer,String storeDir){
  super(servers,storeDir);
  this.receiver=receiver;
  this.rootPath=""String_Node_Str"" + storeCreationTime + ""String_Node_Str""+ storeId;
  this.haServer=haServer;
  this.machineId=machineId;
  this.committedTx=committedTx;
  this.sequenceNr=""String_Node_Str"";
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  this.zooKeeper=instantiateZooKeeper();
}","public ZooClient(String servers,int machineId,RootPathGetter rootPathGetter,ResponseReceiver receiver,String haServer,String storeDir){
  super(servers,storeDir);
  this.receiver=receiver;
  this.rootPathGetter=rootPathGetter;
  this.haServer=haServer;
  this.machineId=machineId;
  this.sequenceNr=""String_Node_Str"";
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  this.zooKeeper=instantiateZooKeeper();
}",0.2863113897596656
154620,"@Override public String getRoot(){
  byte[] rootData=null;
  do {
    try {
      rootData=zooKeeper.getData(rootPath,false,null);
      return rootPath;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
    try {
      byte data[]=new byte[0];
      zooKeeper.create(rootPath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
  }
 while (rootData == null);
  throw new IllegalStateException();
}","@Override public String getRoot(){
  makeSureRootPathIsFound();
  byte[] rootData=null;
  do {
    try {
      rootData=zooKeeper.getData(rootPath,false,null);
      return rootPath;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
    try {
      byte data[]=new byte[0];
      zooKeeper.create(rootPath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
  }
 while (rootData == null);
  throw new IllegalStateException();
}",0.9848563968668408
154621,"public ZooKeeperBroker(String storeDir,int machineId,String zooKeeperServers,String haServer,ResponseReceiver receiver){
  super(machineId,storeDir);
  this.machineId=machineId;
  this.haServer=haServer;
  NeoStoreUtil store=new NeoStoreUtil(storeDir);
  this.zooClient=new ZooClient(zooKeeperServers,machineId,store.getCreationTime(),store.getStoreId(),store.getLastCommittedTx(),receiver,haServer,storeDir);
}","public ZooKeeperBroker(String storeDir,int machineId,String zooKeeperServers,String haServer,ResponseReceiver receiver){
  super(machineId,storeDir);
  this.machineId=machineId;
  this.haServer=haServer;
  this.zooClient=new ZooClient(zooKeeperServers,machineId,getRootPathGetter(storeDir),receiver,haServer,storeDir);
}",0.6183310533515732
154622,"@Override protected void initializeDbs(int numSlaves,Map<String,String> config) throws Exception {
  this.jvmByMachineId=new HashMap<Integer,StandaloneDbCom>();
  super.initializeDbs(numSlaves,config);
  zooKeeperMasterFetcher=new ClusterManager(buildZooKeeperServersConfigValue(ZOO_KEEPER_CLUSTER_SIZE));
  for (  StandaloneDbCom db : jvmByMachineId.values()) {
    db.awaitStarted();
  }
}","@Override protected void initializeDbs(int numSlaves,Map<String,String> config) throws Exception {
  super.initializeDbs(numSlaves,config);
  zooKeeperMasterFetcher=new ClusterManager(buildZooKeeperServersConfigValue(ZOO_KEEPER_CLUSTER_SIZE));
  for (  StandaloneDbCom db : jvmByMachineId.values()) {
    db.awaitStarted();
  }
}",0.9138888888888888
154623,"private Integer tryToReadVersion(ReadableByteChannel channel) throws IOException {
  byte[] array=IoPrimitiveUtils.readBytes(channel,new byte[MAGICK.length]);
  return array != null ? readNextInt(channel) : null;
}","private Integer tryToReadVersion(ReadableByteChannel channel) throws IOException {
  byte[] array=IoPrimitiveUtils.readBytes(channel,new byte[MAGICK.length]);
  if (!Arrays.equals(MAGICK,array)) {
    return null;
  }
  return array != null ? readNextInt(channel) : null;
}",0.8788501026694046
154624,"public static void main(String[] args) throws Exception {
  Args arguments=new Args(args);
  String storeDir=arguments.get(""String_Node_Str"",!arguments.orphans().isEmpty() ? arguments.orphans().get(0) : null);
  ClusterManager cluster=new ClusterManager(arguments.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,null));
  cluster.waitForSyncConnected();
  final Machine master=cluster.getCachedMaster().other();
  System.out.println(""String_Node_Str"" + master);
  Map<String,String> config=MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,String.valueOf(master.getMachineId()));
  HighlyAvailableGraphDatabase db=new HighlyAvailableGraphDatabase(storeDir,config,AbstractBroker.wrapSingleBroker(new BackupBroker(new MasterClient(master.getServer().first(),master.getServer().other(),storeDir),storeDir)));
  System.out.println(""String_Node_Str"" + master);
  try {
    db.pullUpdates();
    System.out.println(""String_Node_Str"");
  }
  finally {
    db.shutdown();
    cluster.shutdown();
  }
}","public static void main(String[] args) throws Exception {
  Args arguments=new Args(args);
  String storeDir=arguments.get(""String_Node_Str"",!arguments.orphans().isEmpty() ? arguments.orphans().get(0) : null);
  ClusterManager cluster=new ClusterManager(arguments.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,null));
  cluster.waitForSyncConnected();
  final Machine master=cluster.getCachedMaster().other();
  System.out.println(""String_Node_Str"" + master);
  Map<String,String> config=MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,String.valueOf(master.getMachineId()));
  DelegatingResponseReceiver receiver=new DelegatingResponseReceiver();
  HighlyAvailableGraphDatabase db=new HighlyAvailableGraphDatabase(storeDir,config,AbstractBroker.wrapSingleBroker(new BackupBroker(new MasterClient(master.getServer().first(),master.getServer().other(),storeDir,receiver),storeDir)));
  receiver.setTarget(db);
  System.out.println(""String_Node_Str"" + master);
  try {
    db.pullUpdates();
    System.out.println(""String_Node_Str"");
  }
  finally {
    db.shutdown();
    cluster.shutdown();
  }
}",0.9498389323515876
154625,"private void readNextBlock(){
  int maxReadableBytes=source.readableBytes();
  if (maxReadableBytes > 0) {
    int blockSize=source.readUnsignedByte();
    byteBuffer.clear();
    moreBlocks=blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;
    int limit=moreBlocks ? BlockLogBuffer.MAX_SIZE - 1 : blockSize;
    byteBuffer.limit(limit);
    source.readBytes(byteBuffer);
    byteBuffer.flip();
  }
}","private void readNextBlock(){
  int maxReadableBytes=source.readableBytes();
  if (maxReadableBytes > 0) {
    int blockSize=source.readUnsignedByte();
    byteBuffer.clear();
    moreBlocks=blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;
    int limit=moreBlocks ? BlockLogBuffer.DATA_SIZE : blockSize;
    byteBuffer.limit(limit);
    source.readBytes(byteBuffer);
    byteBuffer.flip();
  }
}",0.9886792452830188
154626,"private void sendChunkIfNeeded(int bytesPlus){
  if (writerIndex() + bytesPlus >= capacity) {
    setContinuation(CONTINUATION_MORE);
    channel.write(buffer);
    buffer=ChannelBuffers.dynamicBuffer();
    addRoomForContinuationHeader();
  }
}","private void sendChunkIfNeeded(int bytesPlus){
  if (writerIndex() + bytesPlus >= capacity) {
    setContinuation(CONTINUATION_MORE);
    writeCurrentChunk();
    buffer=ChannelBuffers.dynamicBuffer();
    addRoomForContinuationHeader();
  }
}",0.9262295081967212
154627,"protected static TransactionStream readTransactionStreams(final ChannelBuffer buffer){
  final String[] datasources=new String[buffer.readUnsignedByte() + 1];
  datasources[0]=null;
  for (int i=1; i < datasources.length; i++) {
    datasources[i]=readString(buffer);
  }
  return new TransactionStream(){
    @Override protected Triplet<String,Long,TxExtractor> fetchNextOrNull(){
      String datasource=datasources[buffer.readUnsignedByte()];
      if (datasource == null)       return null;
      long txId=buffer.readLong();
      TxExtractor extractor=TxExtractor.create(new BlockLogReader(buffer));
      return Triplet.of(datasource,txId,extractor);
    }
    @Override public String[] dataSourceNames(){
      return Arrays.copyOfRange(datasources,1,datasources.length);
    }
  }
;
}","protected static TransactionStream readTransactionStreams(final String[] datasources,final ChannelBuffer buffer){
  return new TransactionStream(){
    @Override protected Triplet<String,Long,TxExtractor> fetchNextOrNull(){
      String datasource=datasources[buffer.readUnsignedByte()];
      if (datasource == null)       return null;
      long txId=buffer.readLong();
      TxExtractor extractor=TxExtractor.create(new BlockLogReader(buffer));
      return Triplet.of(datasource,txId,extractor);
    }
    @Override public String[] dataSourceNames(){
      return Arrays.copyOfRange(datasources,1,datasources.length);
    }
  }
;
}",0.8515406162464986
154628,"@SuppressWarnings(""String_Node_Str"") private static SlaveContext readSlaveContext(ChannelBuffer buffer){
  int machineId=buffer.readInt();
  int eventIdentifier=buffer.readInt();
  int txsSize=buffer.readByte();
  Pair<String,Long>[] lastAppliedTransactions=new Pair[txsSize];
  for (int i=0; i < txsSize; i++) {
    lastAppliedTransactions[i]=Pair.of(readString(buffer),buffer.readLong());
  }
  return new SlaveContext(machineId,eventIdentifier,lastAppliedTransactions);
}","@SuppressWarnings(""String_Node_Str"") private static SlaveContext readSlaveContext(ChannelBuffer buffer){
  int machineId=buffer.readInt();
  int eventIdentifier=buffer.readInt();
  int txsSize=buffer.readByte();
  @SuppressWarnings(""String_Node_Str"") Pair<String,Long>[] lastAppliedTransactions=new Pair[txsSize];
  for (int i=0; i < txsSize; i++) {
    lastAppliedTransactions[i]=Pair.of(readString(buffer),buffer.readLong());
  }
  return new SlaveContext(machineId,eventIdentifier,lastAppliedTransactions);
}",0.9624365482233502
154629,"@SuppressWarnings(""String_Node_Str"") protected static ChannelBuffer handleRequest(Master realMaster,ChannelBuffer buffer,Channel channel,MasterServer server) throws IOException {
  byte continuation=buffer.readByte();
  Map<Channel,PartialRequest> partialRequests=server.getPartialRequests();
  if (continuation == ChunkingChannelBuffer.CONTINUATION_MORE) {
    PartialRequest partialRequest=partialRequests.get(channel);
    if (partialRequest == null) {
      RequestType type=RequestType.values()[buffer.readByte()];
      SlaveContext context=null;
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      Pair<ChannelBuffer,ByteBuffer> targetBuffers=server.mapSlave(channel,context);
      partialRequest=new PartialRequest(type,context,targetBuffers);
      partialRequests.put(channel,partialRequest);
    }
    partialRequest.add(buffer);
    return null;
  }
 else {
    PartialRequest partialRequest=partialRequests.remove(channel);
    RequestType type=null;
    SlaveContext context=null;
    Pair<ChannelBuffer,ByteBuffer> targetBuffers;
    ChannelBuffer bufferToReadFrom=null;
    if (partialRequest == null) {
      type=RequestType.values()[buffer.readByte()];
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      targetBuffers=server.mapSlave(channel,context);
      bufferToReadFrom=buffer;
    }
 else {
      type=partialRequest.type;
      context=partialRequest.slaveContext;
      targetBuffers=partialRequest.buffers;
      partialRequest.add(buffer);
      bufferToReadFrom=targetBuffers.first();
    }
    Response<?> response=type.caller.callMaster(realMaster,context,bufferToReadFrom);
    targetBuffers.first().clear();
    ChannelBuffer theBuffer=new ChunkingChannelBuffer(targetBuffers.first(),channel,MAX_FRAME_LENGTH);
    type.serializer.write(response.response(),theBuffer);
    if (type.includesSlaveContext()) {
      writeTransactionStreams(response.transactions(),theBuffer,targetBuffers.other());
    }
    if (type == RequestType.FINISH || type == RequestType.PULL_UPDATES) {
      server.unmapSlave(channel,context);
    }
    return theBuffer;
  }
}","@SuppressWarnings(""String_Node_Str"") protected static void handleRequest(Master realMaster,ChannelBuffer buffer,final Channel channel,final MasterServer server) throws IOException {
  byte continuation=buffer.readByte();
  Map<Channel,PartialRequest> partialRequests=server.getPartialRequests();
  if (continuation == ChunkingChannelBuffer.CONTINUATION_MORE) {
    PartialRequest partialRequest=partialRequests.get(channel);
    if (partialRequest == null) {
      RequestType type=RequestType.values()[buffer.readByte()];
      SlaveContext context=null;
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      Pair<ChannelBuffer,ByteBuffer> targetBuffers=server.mapSlave(channel,context);
      partialRequest=new PartialRequest(type,context,targetBuffers);
      partialRequests.put(channel,partialRequest);
    }
    partialRequest.add(buffer);
  }
 else {
    PartialRequest partialRequest=partialRequests.remove(channel);
    RequestType type=null;
    SlaveContext context=null;
    Pair<ChannelBuffer,ByteBuffer> targetBuffers;
    ChannelBuffer bufferToReadFrom=null;
    if (partialRequest == null) {
      type=RequestType.values()[buffer.readByte()];
      if (type.includesSlaveContext()) {
        context=readSlaveContext(buffer);
      }
      targetBuffers=server.mapSlave(channel,context);
      bufferToReadFrom=buffer;
    }
 else {
      type=partialRequest.type;
      context=partialRequest.slaveContext;
      targetBuffers=partialRequest.buffers;
      partialRequest.add(buffer);
      bufferToReadFrom=targetBuffers.first();
    }
    final Response<?> response=type.caller.callMaster(realMaster,context,bufferToReadFrom);
    targetBuffers.first().clear();
    final ChunkingChannelBuffer chunkingBuffer=new ChunkingChannelBuffer(targetBuffers.first(),channel,MAX_FRAME_LENGTH);
    final ByteBuffer targetByteBuffer=targetBuffers.other();
    final RequestType finalType=type;
    final SlaveContext finalContext=context;
    new Thread(){
      public void run(){
        try {
          finalType.serializer.write(response.response(),chunkingBuffer);
          if (finalType.includesSlaveContext()) {
            writeTransactionStreams(response.transactions(),chunkingBuffer,targetByteBuffer);
          }
          chunkingBuffer.done();
          if (finalType == RequestType.FINISH || finalType == RequestType.PULL_UPDATES) {
            server.unmapSlave(channel,finalContext);
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
          throw new RuntimeException(e);
        }
      }
    }
.start();
  }
}",0.8607753230512714
154630,"public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4));
  BlockingReadHandler<ChannelBuffer> reader=new BlockingReadHandler<ChannelBuffer>();
  pipeline.addLast(""String_Node_Str"",reader);
  return pipeline;
}","public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  addLengthFieldPipes(pipeline);
  BlockingReadHandler<ChannelBuffer> reader=new BlockingReadHandler<ChannelBuffer>(new ArrayBlockingQueue<ChannelEvent>(3,false));
  pipeline.addLast(""String_Node_Str"",reader);
  return pipeline;
}",0.4503311258278146
154631,"public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4));
  pipeline.addLast(""String_Node_Str"",new ServerHandler());
  return pipeline;
}","public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  addLengthFieldPipes(pipeline);
  pipeline.addLast(""String_Node_Str"",new ServerHandler());
  return pipeline;
}",0.6276595744680851
154632,"private void readNextBlock(){
  int maxReadableBytes=source.readableBytes();
  if (maxReadableBytes > 0) {
    byteBuffer.clear();
    byteBuffer.limit(Math.min(byteBuffer.capacity(),maxReadableBytes));
    source.readBytes(byteBuffer);
    byteBuffer.flip();
    moreBlocks=byteBuffer.get() == BlockLogBuffer.FULL_BLOCK_AND_MORE;
  }
}","private void readNextBlock(){
  int maxReadableBytes=source.readableBytes();
  if (maxReadableBytes > 0) {
    int blockSize=source.readUnsignedByte();
    byteBuffer.clear();
    moreBlocks=blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;
    int limit=moreBlocks ? BlockLogBuffer.MAX_SIZE - 1 : blockSize;
    byteBuffer.limit(limit);
    source.readBytes(byteBuffer);
    byteBuffer.flip();
  }
}",0.4272108843537415
154633,"private void checkForDeadChannels(){
synchronized (connectedSlaveChannels) {
    Collection<Channel> channelsToRemove=new ArrayList<Channel>();
    for (    Map.Entry<Channel,SlaveContext> entry : connectedSlaveChannels.entrySet()) {
      if (!channelIsOpen(entry.getKey())) {
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue());
        realMaster.finishTransaction(entry.getValue());
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue());
      }
      channelsToRemove.add(entry.getKey());
    }
    for (    Channel channel : channelsToRemove) {
      connectedSlaveChannels.remove(channel);
      channelBuffers.remove(channel);
      partialRequests.remove(channel);
    }
  }
}","private void checkForDeadChannels(){
synchronized (connectedSlaveChannels) {
    Collection<Channel> channelsToRemove=new ArrayList<Channel>();
    for (    Map.Entry<Channel,SlaveContext> entry : connectedSlaveChannels.entrySet()) {
      if (!channelIsOpen(entry.getKey())) {
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue());
        realMaster.finishTransaction(entry.getValue());
        System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue());
        channelsToRemove.add(entry.getKey());
      }
    }
    for (    Channel channel : channelsToRemove) {
      connectedSlaveChannels.remove(channel);
      channelBuffers.remove(channel);
      partialRequests.remove(channel);
    }
  }
}",0.942455242966752
154634,"@Override protected Boolean executeInTransaction(GraphDatabaseService db,Transaction tx){
  byte[] largeArray=new byte[1 * 1024 * 1024];
  for (int i=0; i < largeArray.length; i++) {
    largeArray[i]=(byte)(i % 256);
  }
  try {
    for (int i=0; i < 20; i++) {
      Node node=db.createNode();
      node.setProperty(""String_Node_Str"",largeArray);
    }
    tx.success();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return true;
}","@Override protected Boolean executeInTransaction(GraphDatabaseService db,Transaction tx){
  byte[] largeArray=new byte[1 * 1024 * 1024];
  for (int i=0; i < largeArray.length; i++) {
    largeArray[i]=(byte)(i % 256);
  }
  try {
    for (int i=0; i < 50; i++) {
      Node node=db.createNode();
      node.setProperty(""String_Node_Str"",largeArray);
    }
    tx.success();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return true;
}",0.9978165938864628
154635,"public static void main(String[] args) throws Exception {
  Args arguments=new Args(args);
  String storeDir=arguments.get(""String_Node_Str"",!arguments.orphans().isEmpty() ? arguments.orphans().get(0) : null);
  ClusterManager cluster=new ClusterManager(arguments.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,null));
  cluster.waitForSyncConnected();
  final Machine master=cluster.getCachedMaster().other();
  System.out.println(""String_Node_Str"" + master);
  Map<String,String> config=MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,String.valueOf(master.getMachineId()));
  DelegatingResponseReceiver receiver=new DelegatingResponseReceiver();
  HighlyAvailableGraphDatabase db=new HighlyAvailableGraphDatabase(storeDir,config,AbstractBroker.wrapSingleBroker(new BackupBroker(new MasterClient(master.getServer().first(),master.getServer().other(),storeDir,receiver),storeDir)));
  receiver.setTarget(db);
  System.out.println(""String_Node_Str"" + master);
  try {
    db.pullUpdates();
    System.out.println(""String_Node_Str"");
  }
  finally {
    db.shutdown();
    cluster.shutdown();
  }
}","public static void main(String[] args) throws Exception {
  Args arguments=new Args(args);
  String storeDir=arguments.get(""String_Node_Str"",!arguments.orphans().isEmpty() ? arguments.orphans().get(0) : null);
  ClusterManager cluster=new ClusterManager(arguments.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,null));
  cluster.waitForSyncConnected();
  final Machine master=cluster.getCachedMaster().other();
  System.out.println(""String_Node_Str"" + master);
  Map<String,String> config=MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,String.valueOf(master.getMachineId()));
  HighlyAvailableGraphDatabase db=new HighlyAvailableGraphDatabase(storeDir,config,AbstractBroker.wrapSingleBroker(new BackupBroker(new MasterClient(master.getServer().first(),master.getServer().other(),storeDir),storeDir)));
  System.out.println(""String_Node_Str"" + master);
  try {
    db.pullUpdates();
    System.out.println(""String_Node_Str"");
  }
  finally {
    db.shutdown();
    cluster.shutdown();
  }
}",0.9498389323515876
154636,"protected static TransactionStream readTransactionStreams(final String[] datasources,final ChannelBuffer buffer){
  return new TransactionStream(){
    @Override protected Triplet<String,Long,TxExtractor> fetchNextOrNull(){
      String datasource=datasources[buffer.readUnsignedByte()];
      if (datasource == null)       return null;
      long txId=buffer.readLong();
      TxExtractor extractor=TxExtractor.create(new BlockLogReader(buffer));
      return Triplet.of(datasource,txId,extractor);
    }
    @Override public String[] dataSourceNames(){
      return Arrays.copyOfRange(datasources,1,datasources.length);
    }
  }
;
}","protected static TransactionStream readTransactionStreams(final ChannelBuffer buffer){
  final String[] datasources=readTransactionStreamHeader(buffer);
  return new TransactionStream(){
    @Override protected Triplet<String,Long,TxExtractor> fetchNextOrNull(){
      makeSureNextTransactionIsFullyFetched(buffer);
      String datasource=datasources[buffer.readUnsignedByte()];
      if (datasource == null)       return null;
      long txId=buffer.readLong();
      TxExtractor extractor=TxExtractor.create(new BlockLogReader(buffer));
      return Triplet.of(datasource,txId,extractor);
    }
    @Override public String[] dataSourceNames(){
      return Arrays.copyOfRange(datasources,1,datasources.length);
    }
  }
;
}",0.9001468428781204
154637,"@Override protected Triplet<String,Long,TxExtractor> fetchNextOrNull(){
  String datasource=datasources[buffer.readUnsignedByte()];
  if (datasource == null)   return null;
  long txId=buffer.readLong();
  TxExtractor extractor=TxExtractor.create(new BlockLogReader(buffer));
  return Triplet.of(datasource,txId,extractor);
}","@Override protected Triplet<String,Long,TxExtractor> fetchNextOrNull(){
  makeSureNextTransactionIsFullyFetched(buffer);
  String datasource=datasources[buffer.readUnsignedByte()];
  if (datasource == null)   return null;
  long txId=buffer.readLong();
  TxExtractor extractor=TxExtractor.create(new BlockLogReader(buffer));
  return Triplet.of(datasource,txId,extractor);
}",0.9298998569384836
154638,"public void markReaderIndex(){
  buffer.markReaderIndex();
}","public void markReaderIndex(){
  buffer.markReaderIndex();
  hasMarkedReaderIndex=true;
}",0.8053691275167785
154639,"public void resetReaderIndex(){
  buffer.resetReaderIndex();
}","public void resetReaderIndex(){
  buffer.resetReaderIndex();
  hasMarkedReaderIndex=false;
}",0.8051948051948052
154640,"DechunkingChannelBuffer(ChannelBuffer buffer,BlockingReadHandler<ChannelBuffer> reader){
  this.buffer=buffer;
  this.reader=reader;
  readNextChunk();
}","DechunkingChannelBuffer(BlockingReadHandler<ChannelBuffer> reader){
  this.reader=reader;
  readNextChunk();
}",0.8365019011406845
154641,"public void discardReadBytes(){
  buffer.discardReadBytes();
}","public void discardReadBytes(){
  int oldReaderIndex=buffer.readerIndex();
  if (hasMarkedReaderIndex) {
    buffer.resetReaderIndex();
  }
  int bytesToDiscard=buffer.readerIndex();
  buffer.discardReadBytes();
  if (hasMarkedReaderIndex) {
    buffer.readerIndex(oldReaderIndex - bytesToDiscard);
  }
}",0.3387978142076502
154642,"private void readNextChunk(){
  ChannelBuffer readBuffer=readNext();
  more=readBuffer.readByte() == ChunkingChannelBuffer.CONTINUATION_MORE;
  discardReadBytes();
  buffer.writeBytes(readBuffer);
}","private void readNextChunk(){
  ChannelBuffer readBuffer=readNext();
  more=readBuffer.readByte() == ChunkingChannelBuffer.CONTINUATION_MORE;
  if (!more && buffer == null) {
    buffer=readBuffer;
  }
 else {
    buffer=buffer == null ? ChannelBuffers.dynamicBuffer() : buffer;
    discardReadBytes();
    buffer.writeBytes(readBuffer);
  }
}",0.7208872458410351
154643,"public MasterClient(Machine machine,String storeDir,ResponseReceiver receiver){
  this(machine.getServer().first(),machine.getServer().other(),storeDir,receiver);
}","public MasterClient(Machine machine,String storeDir){
  this(machine.getServer().first(),machine.getServer().other(),storeDir);
}",0.8805460750853242
154644,"private <T>Response<T> sendRequest(RequestType type,SlaveContext slaveContext,Serializer serializer,Deserializer<T> deserializer){
  Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext=null;
  try {
    channelContext=getChannel();
    Channel channel=channelContext.first();
    ChannelBuffer buffer=channelContext.second();
    buffer.clear();
    buffer=new ChunkingChannelBuffer(buffer,channel,MAX_FRAME_LENGTH);
    buffer.writeByte(type.ordinal());
    if (type.includesSlaveContext()) {
      writeSlaveContext(buffer,slaveContext);
    }
    serializer.write(buffer,channelContext.third());
    if (buffer.writerIndex() > 0) {
      channel.write(buffer);
    }
    @SuppressWarnings(""String_Node_Str"") BlockingReadHandler<ChannelBuffer> reader=(BlockingReadHandler<ChannelBuffer>)channel.getPipeline().get(""String_Node_Str"");
    final Triplet<Channel,ChannelBuffer,ByteBuffer> finalChannelContext=channelContext;
    DechunkingChannelBuffer dechunkingBuffer=new DechunkingChannelBuffer(ChannelBuffers.dynamicBuffer(),reader){
      @Override protected ChannelBuffer readNext(){
        ChannelBuffer result=super.readNext();
        if (result == null) {
          channelPool.dispose(finalChannelContext);
          throw new HaCommunicationException(""String_Node_Str"");
        }
        return result;
      }
    }
;
    T response=deserializer.read(dechunkingBuffer);
    String[] datasources=type.includesSlaveContext() ? readTransactionStreamHeader(dechunkingBuffer) : null;
    while (dechunkingBuffer.expectsMoreChunks()) {
      applyFullyAvailableTransactions(datasources,dechunkingBuffer);
      if (dechunkingBuffer.expectsMoreChunks()) {
        dechunkingBuffer.forceReadNextChunk();
      }
    }
    TransactionStream txStreams=type.includesSlaveContext() ? readTransactionStreams(datasources,dechunkingBuffer) : TransactionStream.EMPTY;
    return new Response<T>(response,txStreams);
  }
 catch (  ClosedChannelException e) {
    channelPool.dispose(channelContext);
    throw new HaCommunicationException(e);
  }
catch (  IOException e) {
    throw new HaCommunicationException(e);
  }
catch (  InterruptedException e) {
    throw new HaCommunicationException(e);
  }
catch (  Exception e) {
    throw new HaCommunicationException(e);
  }
}","private <T>Response<T> sendRequest(RequestType type,SlaveContext slaveContext,Serializer serializer,Deserializer<T> deserializer){
  Triplet<Channel,ChannelBuffer,ByteBuffer> channelContext=null;
  try {
    channelContext=getChannel();
    Channel channel=channelContext.first();
    ChannelBuffer buffer=channelContext.second();
    buffer.clear();
    buffer=new ChunkingChannelBuffer(buffer,channel,MAX_FRAME_LENGTH);
    buffer.writeByte(type.ordinal());
    if (type.includesSlaveContext()) {
      writeSlaveContext(buffer,slaveContext);
    }
    serializer.write(buffer,channelContext.third());
    if (buffer.writerIndex() > 0) {
      channel.write(buffer);
    }
    @SuppressWarnings(""String_Node_Str"") BlockingReadHandler<ChannelBuffer> reader=(BlockingReadHandler<ChannelBuffer>)channel.getPipeline().get(""String_Node_Str"");
    final Triplet<Channel,ChannelBuffer,ByteBuffer> finalChannelContext=channelContext;
    DechunkingChannelBuffer dechunkingBuffer=new DechunkingChannelBuffer(reader){
      @Override protected ChannelBuffer readNext(){
        ChannelBuffer result=super.readNext();
        if (result == null) {
          channelPool.dispose(finalChannelContext);
          throw new HaCommunicationException(""String_Node_Str"");
        }
        return result;
      }
    }
;
    T response=deserializer.read(dechunkingBuffer);
    TransactionStream txStreams=type.includesSlaveContext() ? readTransactionStreams(dechunkingBuffer) : TransactionStream.EMPTY;
    return new Response<T>(response,txStreams);
  }
 catch (  ClosedChannelException e) {
    channelPool.dispose(channelContext);
    throw new HaCommunicationException(e);
  }
catch (  IOException e) {
    throw new HaCommunicationException(e);
  }
catch (  InterruptedException e) {
    throw new HaCommunicationException(e);
  }
catch (  Exception e) {
    throw new HaCommunicationException(e);
  }
}",0.8960883129349652
154645,"@Override public long getFileChannelPosition() throws IOException {
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public long getFileChannelPosition() throws IOException {
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9603174603174603
154646,"@Override public LogBuffer putFloat(float f) throws IOException {
  byteBuffer.putFloat(f);
  return checkFlush();
}","public LogBuffer putFloat(float f) throws IOException {
  byteBuffer.putFloat(f);
  return checkFlush();
}",0.954954954954955
154647,"@Override public LogBuffer putInt(int i) throws IOException {
  byteBuffer.putInt(i);
  return checkFlush();
}","public LogBuffer putInt(int i) throws IOException {
  byteBuffer.putInt(i);
  return checkFlush();
}",0.9523809523809524
154648,"@Override public LogBuffer putDouble(double d) throws IOException {
  byteBuffer.putDouble(d);
  return checkFlush();
}","public LogBuffer putDouble(double d) throws IOException {
  byteBuffer.putDouble(d);
  return checkFlush();
}",0.956140350877193
154649,"@Override public void force() throws IOException {
}","public void force() throws IOException {
}",0.8936170212765957
154650,"private LogBuffer checkFlush(){
  if (byteBuffer.position() > MAX_SIZE) {
    target.writeBytes(byteArray,0,MAX_SIZE);
    int pos=byteBuffer.position();
    clearInternalBuffer();
    byteBuffer.put(byteArray,MAX_SIZE,MAX_SIZE - pos);
  }
  return this;
}","private LogBuffer checkFlush(){
  if (byteBuffer.position() > MAX_SIZE) {
    target.writeBytes(byteArray,0,MAX_SIZE);
    int pos=byteBuffer.position();
    clearInternalBuffer();
    byteBuffer.put(byteArray,MAX_SIZE,pos - MAX_SIZE);
  }
  return this;
}",0.95703125
154651,"@Override public LogBuffer putLong(long l) throws IOException {
  byteBuffer.putLong(l);
  return checkFlush();
}","public LogBuffer putLong(long l) throws IOException {
  byteBuffer.putLong(l);
  return checkFlush();
}",0.9537037037037036
154652,"@Override public LogBuffer put(char[] chars) throws IOException {
  for (int bytePos=0; bytePos < chars.length * 2; ) {
    int bytesToWrite=Math.min(byteBuffer.remaining(),chars.length * 2 - bytePos);
    bytesToWrite-=(bytesToWrite % 2);
    for (int i=0; i < bytesToWrite / 2; i++) {
      byteBuffer.putChar(chars[(bytePos / 2) + i]);
    }
    checkFlush();
    bytePos+=bytesToWrite;
  }
  return this;
}","public LogBuffer put(char[] chars) throws IOException {
  for (int bytePos=0; bytePos < chars.length * 2; ) {
    int bytesToWrite=Math.min(byteBuffer.remaining(),chars.length * 2 - bytePos);
    bytesToWrite-=(bytesToWrite % 2);
    for (int i=0; i < bytesToWrite / 2; i++) {
      byteBuffer.putChar(chars[(bytePos / 2) + i]);
    }
    checkFlush();
    bytePos+=bytesToWrite;
  }
  return this;
}",0.9876543209876544
154653,"@Override public FileChannel getFileChannel(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public FileChannel getFileChannel(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9523809523809524
154654,"@Override public void describeTo(Description descr){
  descr.appendText(String.format(""String_Node_Str"",toString(expected),toString(actual)));
}","public void describeTo(Description descr){
  descr.appendText(String.format(""String_Node_Str"",toString(expected),toString(actual)));
}",0.9640287769784172
154655,"private String toString(Object value){
  if (value instanceof byte[]) {
    return Arrays.toString((byte[])value);
  }
  if (value instanceof char[]) {
    return Arrays.toString((char[])value);
  }
  return ""String_Node_Str"" + value;
}","private String toString(Object value){
  if (value instanceof byte[]) {
    return Arrays.toString((byte[])value) + ""String_Node_Str"" + ((byte[])value).length;
  }
  if (value instanceof char[]) {
    return Arrays.toString((char[])value) + ""String_Node_Str"" + ((char[])value).length;
  }
  return ""String_Node_Str"" + value;
}",0.8398576512455516
154656,"@Override public boolean matches(Object actual){
  this.actual=actual;
  if (expected instanceof byte[] && actual instanceof byte[]) {
    return Arrays.equals((byte[])actual,(byte[])expected);
  }
 else   if (expected instanceof char[] && actual instanceof char[]) {
    return Arrays.equals((char[])actual,(char[])expected);
  }
  return false;
}","public boolean matches(Object actual){
  this.actual=actual;
  if (expected instanceof byte[] && actual instanceof byte[]) {
    return Arrays.equals((byte[])actual,(byte[])expected);
  }
 else   if (expected instanceof char[] && actual instanceof char[]) {
    return Arrays.equals((char[])actual,(char[])expected);
  }
  return false;
}",0.9854227405247812
154657,"public CombiningIterator(Iterable<? extends Iterator<T>> iterators){
  this.iterators=iterators.iterator();
}","public CombiningIterator(T first,Iterator<T> rest){
  this(Collections.<Iterator<T>>emptyList());
  this.hasFetchedNext=true;
  this.nextObject=first;
  this.currentIterator=rest;
}",0.4758620689655172
154658,"public Iterable<Relationship> relationships(){
  return new IterableWrapper<Relationship,Path>(this){
    @Override public Iterator<Relationship> iterator(){
      Iterator<Relationship> iter=super.iterator();
      iter.next();
      return iter;
    }
    @Override protected Relationship underlyingObjectToObject(    Path position){
      return position.lastRelationship();
    }
  }
;
}","public Iterable<Relationship> relationships(){
  return new IterableWrapper<Relationship,Path>(this){
    @Override public Iterator<Relationship> iterator(){
      Iterator<Relationship> iter=super.iterator();
      Relationship first=iter.next();
      if (first == null)       return iter;
      return new CombiningIterator<Relationship>(first,iter);
    }
    @Override protected Relationship underlyingObjectToObject(    Path position){
      return position.lastRelationship();
    }
  }
;
}",0.8558558558558559
154659,"@Override public Iterator<Relationship> iterator(){
  Iterator<Relationship> iter=super.iterator();
  iter.next();
  return iter;
}","@Override public Iterator<Relationship> iterator(){
  Iterator<Relationship> iter=super.iterator();
  Relationship first=iter.next();
  if (first == null)   return iter;
  return new CombiningIterator<Relationship>(first,iter);
}",0.6666666666666666
154660,"public Iterable<Relationship> relationships(){
  return new IterableWrapper<Relationship,Path>(this){
    @Override public Iterator<Relationship> iterator(){
      Iterator<Relationship> iter=super.iterator();
      Relationship first=iter.next();
      if (first == null)       return iter;
      return new CombiningIterator<Relationship>(first,iter);
    }
    @Override protected Relationship underlyingObjectToObject(    Path position){
      return position.lastRelationship();
    }
  }
;
}","public Iterable<Relationship> relationships(){
  return new IterableWrapper<Relationship,Path>(this){
    @Override public Iterator<Relationship> iterator(){
      Iterator<Relationship> iter=super.iterator();
      if (iter.hasNext()) {
        Relationship first=iter.next();
        if (first == null)         return iter;
        return new CombiningIterator<Relationship>(first,iter);
      }
 else {
        return iter;
      }
    }
    @Override protected Relationship underlyingObjectToObject(    Path position){
      return position.lastRelationship();
    }
  }
;
}",0.8762790697674419
154661,"@Override public Iterator<Relationship> iterator(){
  Iterator<Relationship> iter=super.iterator();
  Relationship first=iter.next();
  if (first == null)   return iter;
  return new CombiningIterator<Relationship>(first,iter);
}","@Override public Iterator<Relationship> iterator(){
  Iterator<Relationship> iter=super.iterator();
  if (iter.hasNext()) {
    Relationship first=iter.next();
    if (first == null)     return iter;
    return new CombiningIterator<Relationship>(first,iter);
  }
 else {
    return iter;
  }
}",0.6539196940726577
154662,"/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,KernelExtensionLoader kernelExtensionLoader){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  params.putAll(config.getInputParams());
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage(""String_Node_Str"");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage(""String_Node_Str"" + Version.get());
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(""String_Node_Str"" + os.getName() + ""String_Node_Str""+ os.getVersion()+ ""String_Node_Str""+ os.getArch());
  logger.logMessage(""String_Node_Str"" + runtime.getVmName());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVendor());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage(""String_Node_Str"" + runtime.getBootClassPath());
  }
  logger.logMessage(""String_Node_Str"" + runtime.getClassPath());
  logger.logMessage(""String_Node_Str"" + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage(""String_Node_Str"" + gcBean.getName() + ""String_Node_Str""+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage(""String_Node_Str"" + runtime.getInputArguments());
  logger.logMessage(""String_Node_Str"");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage(""String_Node_Str"");
  logger.flush();
  started=true;
  return Collections.unmodifiableMap(params);
}","/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,KernelExtensionLoader kernelExtensionLoader){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  params.putAll(config.getInputParams());
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage(""String_Node_Str"");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage(""String_Node_Str"" + Version.get());
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(String.format(""String_Node_Str"",os.getName(),os.getVersion(),os.getArch(),os.getAvailableProcessors()));
  logger.logMessage(""String_Node_Str"" + runtime.getVmName());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVendor());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage(""String_Node_Str"" + runtime.getBootClassPath());
  }
  logger.logMessage(""String_Node_Str"" + runtime.getClassPath());
  logger.logMessage(""String_Node_Str"" + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage(""String_Node_Str"" + gcBean.getName() + ""String_Node_Str""+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage(""String_Node_Str"" + runtime.getInputArguments());
  logger.logMessage(""String_Node_Str"");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage(""String_Node_Str"");
  logger.flush();
  started=true;
  return Collections.unmodifiableMap(params);
}",0.9849789705587824
154663,"public InstanceInfo[] getInstancesInCluster(){
  ConnectionInformation[] connections=db.getBroker().getConnectionInformation();
  InstanceInfo[] result=new InstanceInfo[connections.length];
  for (int i=0; i < result.length; i++) {
    ConnectionInformation connection=connections[i];
    result[i]=new InstanceInfo(connection.getJMXServiceURL(),connection.getInstanceId(),connection.getMachineId(),connection.isMaster(),connection.getLastCommitedTransactionId());
  }
  return result;
}","public InstanceInfo[] getInstancesInCluster(){
  ConnectionInformation[] connections=db.getBroker().getConnectionInformation();
  InstanceInfo[] result=new InstanceInfo[connections.length];
  for (int i=0; i < result.length; i++) {
    ConnectionInformation connection=connections[i];
    result[i]=new InstanceInfo(connection.getJMXServiceURL().toString(),connection.getInstanceId(),connection.getMachineId(),connection.isMaster(),connection.getLastCommitedTransactionId());
  }
  return result;
}",0.9888324873096448
154664,"private SlaveInfo slaveInfo(int machineId,Collection<SlaveContext> contexts){
  List<SlaveTransaction> txInfo=new ArrayList<SlaveTransaction>();
  for (  SlaveContext context : contexts) {
    Map<String,Long> lastTransactions=new HashMap<String,Long>();
    for (    Pair<String,Long> tx : context.lastAppliedTransactions()) {
      lastTransactions.put(tx.first(),tx.other());
    }
    txInfo.add(new SlaveTransaction(context.getEventIdentifier(),lastTransactions));
  }
  ConnectionInformation connection=db.getBroker().getConnectionInformation(machineId);
  return new SlaveInfo(connection.getJMXServiceURL(),connection.getInstanceId(),machineId,false,connection.getLastCommitedTransactionId(),txInfo.toArray(new SlaveTransaction[txInfo.size()]));
}","private SlaveInfo slaveInfo(int machineId,Collection<SlaveContext> contexts){
  List<SlaveTransaction> txInfo=new ArrayList<SlaveTransaction>();
  for (  SlaveContext context : contexts) {
    Map<String,Long> lastTransactions=new HashMap<String,Long>();
    for (    Pair<String,Long> tx : context.lastAppliedTransactions()) {
      lastTransactions.put(tx.first(),tx.other());
    }
    txInfo.add(new SlaveTransaction(context.getEventIdentifier(),lastTransactions));
  }
  ConnectionInformation connection=db.getBroker().getConnectionInformation(machineId);
  return new SlaveInfo(connection.getJMXServiceURL().toString(),connection.getInstanceId(),machineId,false,connection.getLastCommitedTransactionId(),txInfo.toArray(new SlaveTransaction[txInfo.size()]));
}",0.9927583936800528
154665,"public synchronized void setJmxConnectionData(JMXServiceURL jmxUrl,String instanceId){
  String path=rootPath + ""String_Node_Str"" + HA_SERVERS_CHILD+ ""String_Node_Str""+ machineId+ ""String_Node_Str"";
  String url=jmxUrl.toString();
  byte[] data=new byte[(url.length() + instanceId.length()) * 2 + 4];
  ByteBuffer buffer=ByteBuffer.wrap(data);
  buffer.putShort((short)url.length());
  buffer.asCharBuffer().put(url.toCharArray());
  buffer.putShort((short)instanceId.length());
  buffer.asCharBuffer().put(url.toCharArray());
  if (buffer.limit() != data.length) {
    byte[] array=new byte[buffer.limit()];
    System.arraycopy(data,0,array,0,array.length);
    data=array;
  }
  try {
    zooKeeper.setData(path,data,-1);
  }
 catch (  KeeperException e) {
    msgLog.logMessage(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    msgLog.logMessage(""String_Node_Str"",e);
  }
}","public synchronized void setJmxConnectionData(JMXServiceURL jmxUrl,String instanceId){
  String path=rootPath + ""String_Node_Str"" + HA_SERVERS_CHILD+ ""String_Node_Str""+ machineId+ ""String_Node_Str"";
  String url=jmxUrl.toString();
  byte[] data=new byte[(url.length() + instanceId.length()) * 2 + 4];
  ByteBuffer buffer=ByteBuffer.wrap(data);
  buffer.putShort((short)url.length());
  buffer.asCharBuffer().put(url.toCharArray());
  buffer.position(buffer.position() + url.length() * 2);
  buffer.putShort((short)instanceId.length());
  buffer.asCharBuffer().put(instanceId.toCharArray());
  if (buffer.limit() != data.length) {
    byte[] array=new byte[buffer.limit()];
    System.arraycopy(data,0,array,0,array.length);
    data=array;
  }
  try {
    try {
      zooKeeper.setData(path,data,-1);
    }
 catch (    KeeperException e) {
      if (e.code() == KeeperException.Code.NONODE) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
      }
 else {
        msgLog.logMessage(""String_Node_Str"",e);
      }
    }
  }
 catch (  KeeperException e) {
    msgLog.logMessage(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    msgLog.logMessage(""String_Node_Str"",e);
  }
}",0.801660516605166
154666,"public void getJmxConnectionData(ConnectionInformation connection){
  String path=rootPath + ""String_Node_Str"" + HA_SERVERS_CHILD+ ""String_Node_Str""+ machineId+ ""String_Node_Str"";
  byte[] data;
  try {
    data=zooKeeper.getData(path,false,null);
  }
 catch (  KeeperException e) {
    return;
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    return;
  }
  if (data == null || data.length == 0)   return;
  ByteBuffer buffer=ByteBuffer.wrap(data);
  char[] url, instanceId;
  try {
    url=new char[buffer.getShort()];
    buffer.asCharBuffer().get(url);
    instanceId=new char[buffer.getShort()];
    buffer.asCharBuffer().get(instanceId);
  }
 catch (  BufferUnderflowException e) {
    return;
  }
  connection.setJMXConnectionData(new String(url),new String(instanceId));
}","public void getJmxConnectionData(ConnectionInformation connection){
  String path=rootPath + ""String_Node_Str"" + HA_SERVERS_CHILD+ ""String_Node_Str""+ machineId+ ""String_Node_Str"";
  byte[] data;
  try {
    data=zooKeeper.getData(path,false,null);
  }
 catch (  KeeperException e) {
    return;
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    return;
  }
  if (data == null || data.length == 0)   return;
  ByteBuffer buffer=ByteBuffer.wrap(data);
  char[] url, instanceId;
  try {
    url=new char[buffer.getShort()];
    buffer.asCharBuffer().get(url);
    buffer.position(buffer.position() + url.length * 2);
    instanceId=new char[buffer.getShort()];
    buffer.asCharBuffer().get(instanceId);
  }
 catch (  BufferUnderflowException e) {
    return;
  }
  connection.setJMXConnectionData(new String(url),new String(instanceId));
}",0.965558912386707
154667,"public JMXServiceURL getAddress(){
  return address;
}","public String getAddress(){
  return address;
}",0.8712871287128713
154668,"@ConstructorProperties({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) public InstanceInfo(JMXServiceURL address,String instanceId,int machineId,boolean master,long lastTxId){
  this.address=address;
  this.instanceId=instanceId;
  this.machineId=machineId;
  this.master=master;
  this.lastTxId=lastTxId;
}","@ConstructorProperties({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) public InstanceInfo(String address,String instanceId,int machineId,boolean master,long lastTxId){
  this.address=address;
  this.instanceId=instanceId;
  this.machineId=machineId;
  this.master=master;
  this.lastTxId=lastTxId;
}",0.9727403156384504
154669,"public Pair<Neo4jManager,HighAvailability> connect(String username,String password){
  if (address == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Neo4jManager manager=Neo4jManager.get(address,username,password,instanceId);
  return Pair.of(manager,manager.getBean(HighAvailability.class));
}","public Pair<Neo4jManager,HighAvailability> connect(String username,String password){
  if (address == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Neo4jManager manager=Neo4jManager.get(url(),username,password,instanceId);
  return Pair.of(manager,manager.getBean(HighAvailability.class));
}",0.981012658227848
154670,"@ConstructorProperties({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) public SlaveInfo(JMXServiceURL address,String instanceId,int machineId,boolean master,long lastTxId,SlaveTransaction... txInfo){
  super(address,instanceId,machineId,master,lastTxId);
  this.txInfo=txInfo;
}","@ConstructorProperties({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) public SlaveInfo(String address,String instanceId,int machineId,boolean master,long lastTxId,SlaveTransaction... txInfo){
  super(address,instanceId,machineId,master,lastTxId);
  this.txInfo=txInfo;
}",0.971851851851852
154671,"JmxData(KernelData kernel,Neo4jMBean[] beans){
  this.beans=beans;
  @SuppressWarnings(""String_Node_Str"") JMXServiceURL url=null;
  try {
    Class<?> cal=Class.forName(""String_Node_Str"");
    try {
      Method importRemoteFrom=cal.getMethod(""String_Node_Str"",int.class);
      @SuppressWarnings(""String_Node_Str"") Map<String,String> remote=(Map<String,String>)importRemoteFrom.invoke(null,Integer.valueOf(0));
      url=getUrlFrom(remote);
    }
 catch (    NoSuchMethodException ex) {
    }
    if (url == null) {
      Method importFrom=cal.getMethod(""String_Node_Str"",int.class);
      url=getUrlFrom((String)importFrom.invoke(null,Integer.valueOf(0)));
    }
  }
 catch (  LinkageError e) {
    log.log(Level.INFO,""String_Node_Str"",e);
  }
catch (  Exception e) {
    log.log(Level.INFO,""String_Node_Str"",e);
  }
  if (url == null) {
    Object portObj=kernel.getParam(""String_Node_Str"");
    int port=0;
    if (portObj instanceof Integer) {
      port=((Integer)portObj).intValue();
    }
 else     if (portObj instanceof String) {
      try {
        port=Integer.parseInt((String)portObj);
      }
 catch (      NumberFormatException ok) {
      }
    }
    if (port > 0) {
      Object useSslObj=kernel.getParam(""String_Node_Str"");
      boolean useSSL=false;
      if (useSslObj instanceof Boolean) {
        useSSL=((Boolean)useSslObj).booleanValue();
      }
 else       if (useSslObj instanceof String) {
        useSSL=Boolean.parseBoolean((String)useSslObj);
      }
      JMXConnectorServer server=createServer(port,useSSL);
      if (server != null) {
        try {
          server.getMBeanServer().registerMBean(server,getObjectName(kernel,null,""String_Node_Str""));
        }
 catch (        Exception e) {
          log.log(Level.INFO,""String_Node_Str"",e);
        }
        url=server.getAddress();
      }
    }
  }
  this.url=url;
}","JmxData(KernelData kernel,Neo4jMBean[] beans){
  this.beans=beans;
  @SuppressWarnings(""String_Node_Str"") JMXServiceURL url=null;
  try {
    Class<?> cal=Class.forName(""String_Node_Str"");
    try {
      Method importRemoteFrom=cal.getMethod(""String_Node_Str"",int.class);
      @SuppressWarnings(""String_Node_Str"") Map<String,String> remote=(Map<String,String>)importRemoteFrom.invoke(null,Integer.valueOf(0));
      url=getUrlFrom(remote);
    }
 catch (    NoSuchMethodException ex) {
    }
    if (url == null) {
      Method importFrom=cal.getMethod(""String_Node_Str"",int.class);
      url=getUrlFrom((String)importFrom.invoke(null,Integer.valueOf(0)));
    }
  }
 catch (  InvocationTargetException e) {
    log.log(Level.CONFIG,""String_Node_Str"",e.getTargetException());
  }
catch (  LinkageError e) {
    log.log(Level.CONFIG,""String_Node_Str"",e);
  }
catch (  Exception e) {
    log.log(Level.CONFIG,""String_Node_Str"",e);
  }
  if (url == null) {
    Object portObj=kernel.getParam(""String_Node_Str"");
    int port=0;
    if (portObj instanceof Integer) {
      port=((Integer)portObj).intValue();
    }
 else     if (portObj instanceof String) {
      try {
        port=Integer.parseInt((String)portObj);
      }
 catch (      NumberFormatException ok) {
      }
    }
    if (port > 0) {
      Object useSslObj=kernel.getParam(""String_Node_Str"");
      boolean useSSL=false;
      if (useSslObj instanceof Boolean) {
        useSSL=((Boolean)useSslObj).booleanValue();
      }
 else       if (useSslObj instanceof String) {
        useSSL=Boolean.parseBoolean((String)useSslObj);
      }
      log.log(Level.CONFIG,""String_Node_Str"",new Object[]{port,useSSL ? ""String_Node_Str"" : ""String_Node_Str""});
      JMXConnectorServer server=createServer(port,useSSL);
      if (server != null) {
        try {
          server.start();
        }
 catch (        IOException e) {
          log.log(Level.CONFIG,""String_Node_Str"",e);
          server=null;
        }
        if (server != null) {
          try {
            server.getMBeanServer().registerMBean(server,getObjectName(kernel,null,""String_Node_Str""));
          }
 catch (          Exception e) {
            log.log(Level.CONFIG,""String_Node_Str"",e);
          }
          url=server.getAddress();
        }
      }
    }
  }
  this.url=url;
}",0.8536468330134357
154672,"@Test @Ignore(""String_Node_Str"") public void shouldBeAbleToInvokePluginWithLotsOfParams() throws Exception {
  String methodUri=getPluginMethodUri(functionalTestHelper.dataUri(),""String_Node_Str"");
  String a=""String_Node_Str"";
  byte b=(byte)0xff;
  char c='c';
  short d=(short)4;
  int e=365;
  long f=(long)4;
  float g=(float)4.5;
  double h=Math.PI;
  boolean i=false;
  Map<String,Object> params=MapUtil.map(""String_Node_Str"",a,""String_Node_Str"",b,""String_Node_Str"",c,""String_Node_Str"",d,""String_Node_Str"",e,""String_Node_Str"",f,""String_Node_Str"",g,""String_Node_Str"",h,""String_Node_Str"",i);
  makePostMap(methodUri,params);
  assertThat(Plugin._string,is(a));
  assertThat(Plugin._byte,is(b));
  assertThat(Plugin._character,is(c));
  assertThat(Plugin._short,is(d));
  assertThat(Plugin._integer,is(e));
  assertThat(Plugin._long,is(f));
  assertThat(Plugin._float,is(g));
  assertThat(Plugin._double,is(h));
  assertThat(Plugin._boolean,is(i));
}","@Test public void shouldBeAbleToInvokePluginWithLotsOfParams() throws Exception {
  String methodUri=getPluginMethodUri(functionalTestHelper.dataUri(),""String_Node_Str"");
  String a=""String_Node_Str"";
  byte b=(byte)0xff;
  char c='c';
  short d=(short)4;
  int e=365;
  long f=(long)4;
  float g=(float)4.5;
  double h=Math.PI;
  boolean i=false;
  Map<String,Object> params=MapUtil.map(""String_Node_Str"",a,""String_Node_Str"",b,""String_Node_Str"",c,""String_Node_Str"",d,""String_Node_Str"",e,""String_Node_Str"",f,""String_Node_Str"",g,""String_Node_Str"",h,""String_Node_Str"",i);
  makePostMap(methodUri,params);
  assertThat(Plugin._string,is(a));
  assertThat(Plugin._byte,is(b));
  assertThat(Plugin._character,is(c));
  assertThat(Plugin._short,is(d));
  assertThat(Plugin._integer,is(e));
  assertThat(Plugin._long,is(f));
  assertThat(Plugin._float,is(g));
  assertThat(Plugin._double,is(h));
  assertThat(Plugin._boolean,is(i));
}",0.985645933014354
154673,"@Test public void canListExtensionMethodsForServerExtension() throws Exception {
  ClientResponse response=Client.create().resource(functionalTestHelper.extensionUri()).accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
  assertThat(response.getStatus(),equalTo(200));
  Map<String,Object> json=JsonHelper.jsonToMap(response.getEntity(String.class));
  String refNodeService=(String)json.get(ReferenceNode.class.getSimpleName());
  response=Client.create().resource(refNodeService).accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
  assertThat(response.getStatus(),equalTo(200));
  json=JsonHelper.jsonToMap(response.getEntity(String.class));
  System.out.println(json);
  json=(Map<String,Object>)json.get(""String_Node_Str"");
  assertThat(json,hasKey(ReferenceNode.GET_REFERENCE_NODE));
}","@Test public void canListExtensionMethodsForServerExtension() throws Exception {
  ClientResponse response=Client.create().resource(functionalTestHelper.extensionUri()).accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
  assertThat(response.getStatus(),equalTo(200));
  Map<String,Object> json=JsonHelper.jsonToMap(response.getEntity(String.class));
  String refNodeService=(String)json.get(Plugin.class.getSimpleName());
  response=Client.create().resource(refNodeService).accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
  String result=response.getEntity(String.class);
  System.out.println(result);
  assertThat(response.getStatus(),equalTo(200));
  json=JsonHelper.jsonToMap(result);
  System.out.println(json);
  json=(Map<String,Object>)json.get(""String_Node_Str"");
  assertThat(json,hasKey(Plugin.GET_REFERENCE_NODE));
}",0.9110320284697508
154674,"String relationshipUri(long id){
  return relationshipUri() + ""String_Node_Str"" + id;
}","public String relationshipUri(long id){
  return relationshipUri() + ""String_Node_Str"" + id;
}",0.9613259668508288
154675,"@Test public void canGetUrisForNode() throws Exception {
  Map<String,List<String>> extensions=manager.getExensionsFor(GraphDatabaseService.class);
  List<String> methods=extensions.get(ReferenceNode.class.getSimpleName());
  assertNotNull(methods);
  assertThat(methods,hasItem(ReferenceNode.GET_REFERENCE_NODE));
}","@Test public void canGetUrisForNode() throws Exception {
  Map<String,List<String>> extensions=manager.getExensionsFor(GraphDatabaseService.class);
  List<String> methods=extensions.get(Plugin.class.getSimpleName());
  assertNotNull(methods);
  assertThat(methods,hasItem(Plugin.GET_REFERENCE_NODE));
}",0.9385113268608414
154676,"@Test public void canInvokeExtension() throws Exception {
  manager.invoke(graphDb,ReferenceNode.class.getSimpleName(),GraphDatabaseService.class,ReferenceNode.GET_REFERENCE_NODE,graphDb,new NullFormat(null,(MediaType[])null).readParameterList(""String_Node_Str""));
}","@Test public void canInvokeExtension() throws Exception {
  manager.invoke(graphDb,Plugin.class.getSimpleName(),GraphDatabaseService.class,Plugin.GET_REFERENCE_NODE,graphDb,new NullFormat(null,(MediaType[])null).readParameterList(""String_Node_Str""));
}",0.9266409266409268
154677,"protected void endReached(){
  if (this.searcherOrNull != null) {
    this.searcherOrNull.closeStrict();
  }
}","protected void endReached(){
  close();
}",0.543046357615894
154678,"@Override protected Long fetchNextOrNullFromSource(Iterator<Long> source){
  while (source.hasNext()) {
    Long id=source.next();
    if (alreadyReturned.add(id)) {
      return id;
    }
  }
  isExhausted=true;
  return null;
}","@Override protected Long fetchNextOrNullFromSource(Iterator<Long> source){
  while (source.hasNext()) {
    Long id=source.next();
    if (alreadyReturned.add(id)) {
      return id;
    }
  }
  return null;
}",0.9041095890410958
154679,"public IdToEntityIterator(IndexHits<Long> ids,IndexSearcherRef searcher){
  super(ids);
  this.ids=ids;
  this.searcher=searcher;
}","public IdToEntityIterator(IndexHits<Long> ids){
  super(ids);
  this.ids=ids;
}",0.7523809523809524
154680,"public void close(){
  if (searcher != null && !isExhausted) {
    searcher.closeStrict();
    searcher=null;
  }
}","public void close(){
  ids.close();
}",0.4736842105263157
154681,"@Override public void stop(){
  super.stop();
  recursiveDelete(dir);
  lastOpened=null;
}","@Override public void stop(){
  super.stop();
  recursiveDelete(dir);
  lastStarted=null;
}",0.9502762430939228
154682,"private String originatingTestClass(){
  try {
    throw new RuntimeException();
  }
 catch (  RuntimeException e) {
    for (    StackTraceElement el : Arrays.asList(e.getStackTrace())) {
      String className=el.getClassName();
      if (className.contains(""String_Node_Str"")) {
        return className;
      }
    }
  }
  return ""String_Node_Str"";
}","private String originatingTestClass(){
  for (  StackTraceElement el : Thread.currentThread().getStackTrace()) {
    String className=el.getClassName();
    if (className.contains(""String_Node_Str"")) {
      return className;
    }
  }
  return ""String_Node_Str"";
}",0.1935483870967742
154683,"public CleaningNeoServer(final AddressResolver addressResolver,final StartupHealthCheck startupHealthCheck,final File configFile,final Jetty6WebServer jetty6WebServer,final String dir){
  super(addressResolver,startupHealthCheck,configFile,jetty6WebServer);
  this.dir=dir;
  if (lastOpened != null) {
    String message=lastOpened + ""String_Node_Str"";
    lastOpened=null;
    System.out.println(message);
  }
  lastOpened=originatingTestClass();
}","public CleaningNeoServer(final AddressResolver addressResolver,final StartupHealthCheck startupHealthCheck,final File configFile,final Jetty6WebServer jetty6WebServer,final String dir){
  super(addressResolver,startupHealthCheck,configFile,jetty6WebServer);
  this.dir=dir;
  if (lastStarted != null) {
    try {
      throw lastStarted;
    }
  finally {
      lastStarted=null;
    }
  }
}",0.7476190476190476
154684,"public NeoServer build() throws IOException {
  File f=createPropertyFile();
  return new CleaningNeoServer(addressResolver,startupHealthCheck,f,new Jetty6WebServer(),dbDir);
}","public NeoServer build() throws IOException {
  if (dbDir == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  File f=createPropertyFile();
  return new CleaningNeoServer(addressResolver,startupHealthCheck,f,new Jetty6WebServer(),dbDir);
}",0.8091954022988506
154685,"@Test public void shouldPickUpPortFromConfig() throws Exception {
  NeoServer server=server().withPassingStartupHealthcheck().onPort(NON_DEFAULT_PORT).build();
  server.start();
  assertEquals(NON_DEFAULT_PORT,server.getWebServerPort());
  Client client=Client.create();
  ClientResponse response=client.resource(server.baseUri()).get(ClientResponse.class);
  assertThat(response.getStatus(),is(200));
  server.stop();
}","@Test public void shouldPickUpPortFromConfig() throws Exception {
  NeoServer server=server().withRandomDatabaseDir().withPassingStartupHealthcheck().onPort(NON_DEFAULT_PORT).build();
  server.start();
  assertEquals(NON_DEFAULT_PORT,server.getWebServerPort());
  Client client=Client.create();
  ClientResponse response=client.resource(server.baseUri()).get(ClientResponse.class);
  assertThat(response.getStatus(),is(200));
  server.stop();
}",0.9722222222222222
154686,"@Test public void shouldRespondWithTheWebAdminClientSettings() throws Exception {
  String url=functionalTestHelper.mangementUri() + ""String_Node_Str"";
  ClientResponse resp=Client.create().resource(url).accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
  String json=resp.getEntity(String.class);
  assertEquals(200,resp.getStatus());
  assertThat(json,containsString(""String_Node_Str""));
  assertThat(json,containsString(""String_Node_Str""));
}","@Test public void shouldRespondWithTheWebAdminClientSettings() throws Exception {
  String url=functionalTestHelper.mangementUri() + ""String_Node_Str"";
  ClientResponse resp=Client.create().resource(url).accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
  String json=resp.getEntity(String.class);
  assertEquals(json,200,resp.getStatus());
  assertThat(json,containsString(""String_Node_Str""));
  assertThat(json,containsString(""String_Node_Str""));
}",0.9946178686759956
154687,"@Override public List<Object> readList(String input){
  if (empty(input)) {
    return Collections.emptyList();
  }
  throw new WebApplicationException(noInputType());
}","@Override public List<Object> readList(String input){
  if (empty(input)) {
    return Collections.emptyList();
  }
  throw new MediaTypeNotSupportedException(Response.Status.UNSUPPORTED_MEDIA_TYPE,supported,requested);
}",0.7025641025641025
154688,"@Override public URI readUri(String input){
  if (empty(input)) {
    return null;
  }
  throw new WebApplicationException(noInputType());
}","@Override public URI readUri(String input){
  if (empty(input)) {
    return null;
  }
  throw new MediaTypeNotSupportedException(Response.Status.UNSUPPORTED_MEDIA_TYPE,supported,requested);
}",0.7349397590361446
154689,"@Override public Map<String,Object> readMap(String input){
  if (empty(input)) {
    return Collections.emptyMap();
  }
  throw new WebApplicationException(noInputType());
}","@Override public Map<String,Object> readMap(String input){
  if (empty(input)) {
    return Collections.emptyMap();
  }
  throw new MediaTypeNotSupportedException(Response.Status.UNSUPPORTED_MEDIA_TYPE,supported,requested);
}",0.7035175879396985
154690,"@Override protected String serializeValue(final String type,final Object value){
  throw new WebApplicationException(noOutputType());
}","@Override protected String serializeValue(final String type,final Object value){
  throw new MediaTypeNotSupportedException(Response.Status.NOT_ACCEPTABLE,supported,requested);
}",0.7412140575079872
154691,"@Override protected MappingWriter serializeMapping(final String type){
  throw new WebApplicationException(noOutputType());
}","@Override protected MappingWriter serializeMapping(final String type){
  throw new MediaTypeNotSupportedException(Response.Status.NOT_ACCEPTABLE,supported,requested);
}",0.7235494880546075
154692,"@Override protected ListWriter serializeList(final String type){
  throw new WebApplicationException(noOutputType());
}","@Override protected ListWriter serializeList(final String type){
  throw new MediaTypeNotSupportedException(Response.Status.NOT_ACCEPTABLE,supported,requested);
}",0.7117437722419929
154693,"@Override protected String complete(final MappingWriter serializer){
  throw new WebApplicationException(noOutputType());
}","@Override protected String complete(final MappingWriter serializer){
  throw new MediaTypeNotSupportedException(Response.Status.NOT_ACCEPTABLE,supported,requested);
}",0.7197231833910035
154694,"@Override protected void unload(KernelData kernel){
  getServer(kernel).shutdown();
}","@Override protected void unload(KernelData kernel){
  GraphDatabaseShellServer server=getServer(kernel);
  if (server != null) {
    server.shutdown();
  }
}",0.7024793388429752
154695,"public static void main(String[] args) throws URISyntaxException {
  checkDatabaseIsRunning();
  URI firstNode=createNode();
  addProperty(firstNode,""String_Node_Str"",""String_Node_Str"");
  URI secondNode=createNode();
  addProperty(firstNode,""String_Node_Str"",""String_Node_Str"");
  URI relationshipUri=addRelationship(firstNode,secondNode,""String_Node_Str"",""String_Node_Str"");
  addMetadataToProperty(relationshipUri,""String_Node_Str"",""String_Node_Str"");
  findSingersInBands(firstNode);
}","public static void main(String[] args) throws URISyntaxException {
  checkDatabaseIsRunning();
  URI firstNode=createNode();
  addProperty(firstNode,""String_Node_Str"",""String_Node_Str"");
  URI secondNode=createNode();
  addProperty(secondNode,""String_Node_Str"",""String_Node_Str"");
  URI relationshipUri=addRelationship(firstNode,secondNode,""String_Node_Str"",""String_Node_Str"");
  addMetadataToProperty(relationshipUri,""String_Node_Str"",""String_Node_Str"");
  findSingersInBands(firstNode);
}",0.5556690500510725
154696,"public void start(){
  startupHealthCheck();
  validateConfiguration();
  startDatabase();
  startWebServer();
  try {
    startRoundRobinDB();
    startOgsiContainer();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","public void start(){
  startupHealthCheck();
  validateConfiguration();
  startDatabase();
  try {
    startRoundRobinDB();
    startOsgiContainer();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  startWebServer();
}",0.9121338912133892
154697,"public long getValue(){
  try {
    long used=(Long)((CompositeDataSupport)mbeanServer.getAttribute(memoryName,""String_Node_Str"")).get(""String_Node_Str"");
    long max=100 * (Long)((CompositeDataSupport)mbeanServer.getAttribute(memoryName,""String_Node_Str"")).get(""String_Node_Str"");
    return used / max;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","public long getValue(){
  try {
    long used=(Long)((CompositeDataSupport)mbeanServer.getAttribute(memoryName,""String_Node_Str"")).get(""String_Node_Str"");
    long max=(Long)((CompositeDataSupport)mbeanServer.getAttribute(memoryName,""String_Node_Str"")).get(""String_Node_Str"");
    return Math.round((used / (double)max) * 100);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.6269430051813472
154698,"private RelTypeElement(String type,NodeImpl node,IntArray src,IntArray add,IntArray remove){
  super(type,node);
  this.src=src;
  if (src == null) {
    src=IntArray.EMPTY;
    srcTraversed=true;
  }
  if (add == null) {
    addTraversed=true;
  }
  this.add=add;
  if (remove != null) {
    for (int i=0; i < remove.length(); i++) {
      this.remove.add(remove.get(i));
    }
  }
}","private RelTypeElement(String type,NodeImpl node,IntArray src,IntArray add,IntArray remove){
  super(type,node);
  if (src == null) {
    src=IntArray.EMPTY;
    srcTraversed=true;
  }
  this.src=src;
  if (add == null) {
    addTraversed=true;
  }
  this.add=add;
  if (remove != null) {
    for (int i=0; i < remove.length(); i++) {
      this.remove.add(remove.get(i));
    }
  }
}",0.9583333333333334
154699,"static IndexProviderStore newIndexStore(String dbStoreDir){
  return new IndexProviderStore(getStoreDir(dbStoreDir) + ""String_Node_Str"");
}","static IndexProviderStore newIndexStore(String dbStoreDir){
  return new IndexProviderStore(getStoreDir(dbStoreDir).first() + ""String_Node_Str"");
}",0.972027972027972
154700,"public LuceneBatchInserterIndexProvider(final BatchInserter inserter){
  this.inserter=inserter;
  this.indexStore=((BatchInserterImpl)inserter).getIndexStore();
  this.nodeEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      return IndexType.newBaseDocument((Long)entityId);
    }
    public Class<? extends PropertyContainer> getType(){
      return Node.class;
    }
  }
;
  this.relationshipEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      RelationshipId relId=(RelationshipId)entityId;
      Document doc=IndexType.newBaseDocument(relId.id);
      doc.add(new Field(LuceneIndex.KEY_START_NODE_ID,""String_Node_Str"" + relId.startNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      doc.add(new Field(LuceneIndex.KEY_END_NODE_ID,""String_Node_Str"" + relId.endNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      return doc;
    }
    public Class<? extends PropertyContainer> getType(){
      return Relationship.class;
    }
  }
;
}","public LuceneBatchInserterIndexProvider(final BatchInserter inserter){
  this.inserter=inserter;
  this.indexStore=((BatchInserterImpl)inserter).getIndexStore();
  this.nodeEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      return IndexType.newBaseDocument((Long)entityId);
    }
    public Class<? extends PropertyContainer> getType(){
      return Node.class;
    }
  }
;
  this.relationshipEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      RelationshipId relId=null;
      if (entityId instanceof Long) {
        SimpleRelationship relationship=inserter.getRelationshipById((Long)entityId);
        relId=new RelationshipId(relationship.getId(),relationship.getStartNode(),relationship.getEndNode());
      }
 else       if (entityId instanceof RelationshipId) {
        relId=(RelationshipId)entityId;
      }
      Document doc=IndexType.newBaseDocument(relId.id);
      doc.add(new Field(LuceneIndex.KEY_START_NODE_ID,""String_Node_Str"" + relId.startNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      doc.add(new Field(LuceneIndex.KEY_END_NODE_ID,""String_Node_Str"" + relId.endNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      return doc;
    }
    public Class<? extends PropertyContainer> getType(){
      return Relationship.class;
    }
  }
;
}",0.8563218390804598
154701,"public Document newDocument(Object entityId){
  RelationshipId relId=(RelationshipId)entityId;
  Document doc=IndexType.newBaseDocument(relId.id);
  doc.add(new Field(LuceneIndex.KEY_START_NODE_ID,""String_Node_Str"" + relId.startNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
  doc.add(new Field(LuceneIndex.KEY_END_NODE_ID,""String_Node_Str"" + relId.endNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
  return doc;
}","public Document newDocument(Object entityId){
  RelationshipId relId=null;
  if (entityId instanceof Long) {
    SimpleRelationship relationship=inserter.getRelationshipById((Long)entityId);
    relId=new RelationshipId(relationship.getId(),relationship.getStartNode(),relationship.getEndNode());
  }
 else   if (entityId instanceof RelationshipId) {
    relId=(RelationshipId)entityId;
  }
  Document doc=IndexType.newBaseDocument(relId.id);
  doc.add(new Field(LuceneIndex.KEY_START_NODE_ID,""String_Node_Str"" + relId.startNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
  doc.add(new Field(LuceneIndex.KEY_END_NODE_ID,""String_Node_Str"" + relId.endNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
  return doc;
}",0.7417763157894737
154702,"public void setHighId(long id){
  this.highestIdInUse=id;
  this.localIdGenerator.setHighId(id);
}","public void setHighId(long id){
  this.localIdGenerator.setHighId(id);
}",0.8470588235294118
154703,"public long getHighId(){
  return this.highestIdInUse;
}","public long getHighId(){
  return Math.max(this.localIdGenerator.getHighId(),highestIdInUse);
}",0.7417218543046358
154704,"public SlaveIdGenerator(IdType idType,long highestIdInUse,Broker broker,ResponseReceiver receiver,IdGenerator localIdGenerator){
  this.idType=idType;
  this.highestIdInUse=highestIdInUse;
  this.broker=broker;
  this.receiver=receiver;
  this.localIdGenerator=localIdGenerator;
}","public SlaveIdGenerator(IdType idType,long highestIdInUse,Broker broker,ResponseReceiver receiver,IdGenerator localIdGenerator){
  this.idType=idType;
  this.broker=broker;
  this.receiver=receiver;
  this.localIdGenerator=localIdGenerator;
}",0.9272030651340996
154705,"public long getNumberOfIdsInUse(){
  return this.highestIdInUse - this.defragCount;
}","public long getNumberOfIdsInUse(){
  return Math.max(this.localIdGenerator.getNumberOfIdsInUse(),highestIdInUse - defragCount);
}",0.7476635514018691
154706,"@Override protected LuceneCommand newRemoveCommand(PropertyContainer entity,String key,Object value){
  Relationship rel=(Relationship)entity;
  return new LuceneCommand.RemoveCommand(getIdentifier(),LuceneCommand.RELATIONSHIP,rel.getId(),key,value);
}","@Override protected LuceneCommand newRemoveCommand(PropertyContainer entity,String key,Object value){
  Relationship rel=(Relationship)entity;
  return new LuceneCommand.RemoveCommand(getIdentifier(),LuceneCommand.RELATIONSHIP,RelationshipId.of(rel),key,value);
}",0.9436893203883496
154707,"public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (isStarted && lastCommittedTxIdSetter != null && txId != lastCommittedTx) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
  lastCommittedTx=txId;
}","public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (isStarted && lastCommittedTxIdSetter != null && txId != lastCommittedTx) {
    try {
      lastCommittedTxIdSetter.setLastCommittedTxId(txId);
    }
 catch (    RuntimeException e) {
      e.printStackTrace();
    }
  }
  lastCommittedTx=txId;
}",0.912280701754386
154708,"private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  try {
    if (master.other().getMachineId() == machineId) {
      return;
    }
    XaDataSource nioneoDataSource=this.localGraph.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
    long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
    long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
    int masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId);
    if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
      return;
    }
 else {
      String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
      msgLog.logMessage(msg);
      shutdown();
      throw new RuntimeException(msg);
    }
  }
 catch (  IOException e) {
    shutdown();
    throw new RuntimeException(e);
  }
}","private void tryToEnsureIAmNotABrokenMachine(Pair<Master,Machine> master){
  try {
    if (master.other().getMachineId() == machineId) {
      return;
    }
    XaDataSource nioneoDataSource=this.localGraph.getConfig().getTxModule().getXaDataSourceManager().getXaDataSource(Config.DEFAULT_DATA_SOURCE_NAME);
    long myLastCommittedTx=nioneoDataSource.getLastCommittedTxId();
    long highestCommonTxId=Math.min(myLastCommittedTx,master.other().getLastCommittedTxId());
    int masterForMyHighestCommonTxId=nioneoDataSource.getMasterForCommittedTx(highestCommonTxId);
    int masterForMastersHighestCommonTxId=master.first().getMasterIdForCommittedTx(highestCommonTxId);
    if (masterForMyHighestCommonTxId == masterForMastersHighestCommonTxId) {
      msgLog.logMessage(""String_Node_Str"" + highestCommonTxId + ""String_Node_Str""+ masterForMyHighestCommonTxId,true);
      return;
    }
 else {
      String msg=""String_Node_Str"" + myLastCommittedTx + ""String_Node_Str""+ masterForMyHighestCommonTxId+ ""String_Node_Str""+ masterForMastersHighestCommonTxId;
      msgLog.logMessage(msg,true);
      shutdown();
      throw new RuntimeException(msg);
    }
  }
 catch (  IOException e) {
    shutdown();
    throw new RuntimeException(e);
  }
}",0.9473684210526316
154709,"public synchronized void internalShutdown(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ this);
  if (this.updatePuller != null) {
    msgLog.logMessage(""String_Node_Str"");
    this.updatePuller.shutdown();
    msgLog.logMessage(""String_Node_Str"");
    this.updatePuller=null;
  }
  if (this.masterServer != null) {
    msgLog.logMessage(""String_Node_Str"");
    this.masterServer.shutdown();
    msgLog.logMessage(""String_Node_Str"");
    this.masterServer=null;
  }
  if (this.localGraph != null) {
    msgLog.logMessage(""String_Node_Str"");
    this.localGraph.shutdown();
    msgLog.logMessage(""String_Node_Str"");
    this.localGraph=null;
    this.localDataSourceManager=null;
  }
}","public synchronized void internalShutdown(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ this,true);
  if (this.updatePuller != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.updatePuller.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.updatePuller=null;
  }
  if (this.masterServer != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.masterServer.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.masterServer=null;
  }
  if (this.localGraph != null) {
    msgLog.logMessage(""String_Node_Str"",true);
    this.localGraph.shutdown();
    msgLog.logMessage(""String_Node_Str"",true);
    this.localGraph=null;
  }
}",0.948555320648344
154710,"public void newMaster(Pair<Master,Machine> master,Exception e){
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e);
    reevaluateMyself(master);
  }
 catch (  ZooKeeperException ee) {
    ee.printStackTrace();
  }
catch (  HaCommunicationException ee) {
    ee.printStackTrace();
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"");
    shutdown();
  }
}","public void newMaster(Pair<Master,Machine> master,Exception e){
  try {
    msgLog.logMessage(""String_Node_Str"" + master + ""String_Node_Str"",e,true);
    reevaluateMyself(master);
  }
 catch (  ZooKeeperException ee) {
    ee.printStackTrace();
  }
catch (  HaCommunicationException ee) {
    ee.printStackTrace();
  }
catch (  Throwable t) {
    t.printStackTrace();
    msgLog.logMessage(""String_Node_Str"" + t + ""String_Node_Str"",true);
    shutdown();
  }
}",0.989010989010989
154711,"public <T>T receive(Response<T> response){
  try {
    for (    Pair<String,TransactionStream> streams : response.transactions().getStreams()) {
      String resourceName=streams.first();
      XaDataSource dataSource=localDataSourceManager.getXaDataSource(resourceName);
      for (      Pair<Long,ReadableByteChannel> channel : streams.other().getChannels()) {
        dataSource.applyCommittedTransaction(channel.first(),channel.other());
        channel.other().close();
      }
    }
    return response.response();
  }
 catch (  IOException e) {
    newMaster(broker.getMaster(),e);
    throw new RuntimeException(e);
  }
}","public <T>T receive(Response<T> response){
  try {
    XaDataSourceManager localDataSourceManager=localGraph.getConfig().getTxModule().getXaDataSourceManager();
    for (    Pair<String,TransactionStream> streams : response.transactions().getStreams()) {
      String resourceName=streams.first();
      XaDataSource dataSource=localDataSourceManager.getXaDataSource(resourceName);
      for (      Pair<Long,ReadableByteChannel> channel : streams.other().getChannels()) {
        dataSource.applyCommittedTransaction(channel.first(),channel.other());
        channel.other().close();
      }
    }
    return response.response();
  }
 catch (  IOException e) {
    newMaster(broker.getMaster(),e);
    throw new RuntimeException(e);
  }
}",0.9195906432748538
154712,"public SlaveContext getSlaveContext(int eventIdentifier){
  Collection<XaDataSource> dataSources=localDataSourceManager.getAllRegisteredDataSources();
  @SuppressWarnings(""String_Node_Str"") Pair<String,Long>[] txs=new Pair[dataSources.size()];
  int i=0;
  for (  XaDataSource dataSource : dataSources) {
    txs[i++]=new Pair<String,Long>(dataSource.getName(),dataSource.getLastCommittedTxId());
  }
  return new SlaveContext(machineId,eventIdentifier,txs);
}","public SlaveContext getSlaveContext(int eventIdentifier){
  XaDataSourceManager localDataSourceManager=localGraph.getConfig().getTxModule().getXaDataSourceManager();
  Collection<XaDataSource> dataSources=localDataSourceManager.getAllRegisteredDataSources();
  @SuppressWarnings(""String_Node_Str"") Pair<String,Long>[] txs=new Pair[dataSources.size()];
  int i=0;
  for (  XaDataSource dataSource : dataSources) {
    txs[i++]=new Pair<String,Long>(dataSource.getName(),dataSource.getLastCommittedTxId());
  }
  return new SlaveContext(machineId,eventIdentifier,txs);
}",0.8949416342412452
154713,"protected synchronized void reevaluateMyself(Pair<Master,Machine> master){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster();
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave();
      restarted=true;
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    for (    TransactionEventHandler<?> handler : transactionEventHandlers) {
      this.localGraph.registerTransactionEventHandler(handler);
    }
    for (    KernelEventHandler handler : kernelEventHandlers) {
      this.localGraph.registerKernelEventHandler(handler);
    }
    this.localDataSourceManager=localGraph.getConfig().getTxModule().getXaDataSourceManager();
  }
}","protected synchronized void reevaluateMyself(Pair<Master,Machine> master){
  if (master == null) {
    master=broker.getMasterReally();
  }
  boolean restarted=false;
  boolean iAmCurrentlyMaster=masterServer != null;
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ master+ ""String_Node_Str""+ iAmCurrentlyMaster+ ""String_Node_Str"");
  if (master.other().getMachineId() == machineId) {
    if (this.localGraph == null || !iAmCurrentlyMaster) {
      internalShutdown();
      startAsMaster();
      restarted=true;
    }
    broker.rebindMaster();
  }
 else {
    if (this.localGraph == null || iAmCurrentlyMaster) {
      internalShutdown();
      startAsSlave();
      restarted=true;
    }
    tryToEnsureIAmNotABrokenMachine(broker.getMaster());
  }
  if (restarted) {
    for (    TransactionEventHandler<?> handler : transactionEventHandlers) {
      this.localGraph.registerTransactionEventHandler(handler);
    }
    for (    KernelEventHandler handler : kernelEventHandlers) {
      this.localGraph.registerKernelEventHandler(handler);
    }
  }
}",0.9577965348733896
154714,"private void startAsMaster(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str"");
  this.localGraph=new EmbeddedGraphDbImpl(storeDir,config,this,CommonFactories.defaultLockManagerFactory(),new MasterIdGeneratorFactory(),CommonFactories.defaultRelationshipTypeCreator(),new MasterTxIdGeneratorFactory(broker),CommonFactories.defaultTxFinishHook(),new ZooKeeperLastCommittedTxIdSetter(broker));
  this.masterServer=(MasterServer)broker.instantiateMasterServer(this);
  msgLog.logMessage(""String_Node_Str"");
}","private void startAsMaster(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str"",true);
  this.localGraph=new EmbeddedGraphDbImpl(storeDir,config,this,CommonFactories.defaultLockManagerFactory(),new MasterIdGeneratorFactory(),CommonFactories.defaultRelationshipTypeCreator(),new MasterTxIdGeneratorFactory(broker),CommonFactories.defaultTxFinishHook(),new ZooKeeperLastCommittedTxIdSetter(broker));
  this.masterServer=(MasterServer)broker.instantiateMasterServer(this);
  msgLog.logMessage(""String_Node_Str"",true);
}",0.9905838041431262
154715,"private void startAsSlave(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str"");
  this.localGraph=new EmbeddedGraphDbImpl(storeDir,config,this,new SlaveLockManagerFactory(broker,this),new SlaveIdGeneratorFactory(broker,this),new SlaveRelationshipTypeCreator(broker,this),new SlaveTxIdGeneratorFactory(broker,this),new SlaveTxRollbackHook(broker,this),new ZooKeeperLastCommittedTxIdSetter(broker));
  instantiateAutoUpdatePullerIfConfigSaysSo();
  msgLog.logMessage(""String_Node_Str"");
}","private void startAsSlave(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str"",true);
  this.localGraph=new EmbeddedGraphDbImpl(storeDir,config,this,new SlaveLockManagerFactory(broker,this),new SlaveIdGeneratorFactory(broker,this),new SlaveRelationshipTypeCreator(broker,this),new SlaveTxIdGeneratorFactory(broker,this),new SlaveTxRollbackHook(broker,this),new ZooKeeperLastCommittedTxIdSetter(broker));
  instantiateAutoUpdatePullerIfConfigSaysSo();
  msgLog.logMessage(""String_Node_Str"",true);
}",0.990234375
154716,"public synchronized void shutdown(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ this);
  if (this.broker != null) {
    this.broker.shutdown();
  }
  internalShutdown();
}","public synchronized void shutdown(){
  msgLog.logMessage(""String_Node_Str"" + machineId + ""String_Node_Str""+ this,true);
  if (this.broker != null) {
    this.broker.shutdown();
  }
  internalShutdown();
}",0.9875930521091812
154717,"@Override protected Triplet<Channel,ChannelBuffer,ByteBuffer> create(){
  ChannelFuture channelFuture=bootstrap.connect(address);
  channelFuture.awaitUninterruptibly(5,TimeUnit.SECONDS);
  Triplet<Channel,ChannelBuffer,ByteBuffer> channel=null;
  if (channelFuture.isSuccess()) {
    channel=Triplet.of(channelFuture.getChannel(),ChannelBuffers.dynamicBuffer(),ByteBuffer.allocateDirect(1024 * 1024));
    msgLog.logMessage(""String_Node_Str"" + address);
  }
  return channel;
}","@Override protected Triplet<Channel,ChannelBuffer,ByteBuffer> create(){
  ChannelFuture channelFuture=bootstrap.connect(address);
  channelFuture.awaitUninterruptibly(5,TimeUnit.SECONDS);
  Triplet<Channel,ChannelBuffer,ByteBuffer> channel=null;
  if (channelFuture.isSuccess()) {
    channel=Triplet.of(channelFuture.getChannel(),ChannelBuffers.dynamicBuffer(),ByteBuffer.allocateDirect(1024 * 1024));
    msgLog.logMessage(""String_Node_Str"" + address,true);
    return channel;
  }
  String msg=""String_Node_Str"" + address;
  msgLog.logMessage(msg,true);
  throw new HaCommunicationException(msg);
}",0.8582020389249305
154718,"public void shutdown(){
  msgLog.logMessage(""String_Node_Str"");
  channelPool.close(true);
}","public void shutdown(){
  msgLog.logMessage(""String_Node_Str"",true);
  channelPool.close(true);
}",0.9735449735449736
154719,"public void shutdown(){
  deadConnectionsPoller.shutdown();
  msgLog.logMessage(""String_Node_Str"");
  channelGroup.close().awaitUninterruptibly();
  executor.shutdown();
}","public void shutdown(){
  deadConnectionsPoller.shutdown();
  msgLog.logMessage(""String_Node_Str"",true);
  channelGroup.close().awaitUninterruptibly();
  executor.shutdown();
}",0.9855907780979828
154720,"public MasterServer(Master realMaster,final int port,String storeDir){
  this.realMaster=realMaster;
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  executor=Executors.newCachedThreadPool();
  channelFactory=new NioServerSocketChannelFactory(executor,executor,MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS);
  bootstrap=new ServerBootstrap(channelFactory);
  bootstrap.setPipelineFactory(this);
  channelGroup=new DefaultChannelGroup();
  executor.execute(new Runnable(){
    public void run(){
      Channel channel=bootstrap.bind(new InetSocketAddress(port));
      channelGroup.add(channel);
      msgLog.logMessage(""String_Node_Str"" + port);
    }
  }
);
  deadConnectionsPoller=new ScheduledThreadPoolExecutor(1);
  deadConnectionsPoller.scheduleWithFixedDelay(new Runnable(){
    public void run(){
    }
  }
,DEAD_CONNECTIONS_CHECK_INTERVAL,DEAD_CONNECTIONS_CHECK_INTERVAL,TimeUnit.SECONDS);
}","public MasterServer(Master realMaster,final int port,String storeDir){
  this.realMaster=realMaster;
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  executor=Executors.newCachedThreadPool();
  channelFactory=new NioServerSocketChannelFactory(executor,executor,MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS);
  bootstrap=new ServerBootstrap(channelFactory);
  bootstrap.setPipelineFactory(this);
  channelGroup=new DefaultChannelGroup();
  executor.execute(new Runnable(){
    public void run(){
      Channel channel=bootstrap.bind(new InetSocketAddress(port));
      channelGroup.add(channel);
      msgLog.logMessage(""String_Node_Str"" + port,true);
    }
  }
);
  deadConnectionsPoller=new ScheduledThreadPoolExecutor(1);
  deadConnectionsPoller.scheduleWithFixedDelay(new Runnable(){
    public void run(){
    }
  }
,DEAD_CONNECTIONS_CHECK_INTERVAL,DEAD_CONNECTIONS_CHECK_INTERVAL,TimeUnit.SECONDS);
}",0.9972722313147844
154721,"private Channel getChannel() throws Exception {
  Thread thread=Thread.currentThread();
synchronized (channels) {
    Channel channel=channels.get(thread);
    if (channel == null) {
      while (channel == null) {
        Channel unusedChannel=unusedChannels.poll();
        if (unusedChannel == null) {
          break;
        }
 else         if (unusedChannel.isConnected()) {
          msgLog.logMessage(""String_Node_Str"");
          channel=unusedChannel;
        }
 else {
          msgLog.logMessage(""String_Node_Str"");
        }
      }
      if (channel == null) {
        for (int i=0; i < 5; i++) {
          ChannelFuture channelFuture=bootstrap.connect(new InetSocketAddress(hostNameOrIp,port));
          channelFuture.awaitUninterruptibly();
          if (channelFuture.isSuccess()) {
            channel=channelFuture.getChannel();
            msgLog.logMessage(""String_Node_Str"" + hostNameOrIp + ""String_Node_Str""+ port);
            break;
          }
 else {
            msgLog.logMessage(""String_Node_Str"" + hostNameOrIp + ""String_Node_Str""+ port);
            try {
              Thread.sleep(500);
            }
 catch (            InterruptedException e) {
              Thread.interrupted();
            }
          }
        }
      }
      if (channel == null) {
        throw new IOException(""String_Node_Str"");
      }
      channels.put(thread,channel);
    }
    return channel;
  }
}","private Channel getChannel() throws Exception {
  Thread thread=Thread.currentThread();
synchronized (channels) {
    Channel channel=channels.get(thread);
    if (channel == null) {
      while (channel == null) {
        Channel unusedChannel=unusedChannels.poll();
        if (unusedChannel == null) {
          break;
        }
 else         if (unusedChannel.isConnected()) {
          msgLog.logMessage(""String_Node_Str"");
          channel=unusedChannel;
        }
 else {
          msgLog.logMessage(""String_Node_Str"");
        }
      }
      if (channel == null) {
        for (int i=0; i < 5; i++) {
          ChannelFuture channelFuture=bootstrap.connect(new InetSocketAddress(hostNameOrIp,port));
          channelFuture.awaitUninterruptibly();
          if (channelFuture.isSuccess()) {
            channel=channelFuture.getChannel();
            msgLog.logMessage(""String_Node_Str"" + hostNameOrIp + ""String_Node_Str""+ port,true);
            break;
          }
 else {
            msgLog.logMessage(""String_Node_Str"" + hostNameOrIp + ""String_Node_Str""+ port,true);
            try {
              Thread.sleep(500);
            }
 catch (            InterruptedException e) {
              Thread.interrupted();
            }
          }
        }
      }
      if (channel == null) {
        throw new IOException(""String_Node_Str"");
      }
      channels.put(thread,channel);
    }
    return channel;
  }
}",0.9964788732394366
154722,"public void shutdown(){
  msgLog.logMessage(""String_Node_Str"");
synchronized (channels) {
    for (    Channel channel : unusedChannels) {
      channel.close();
    }
    for (    Channel channel : channels.values()) {
      channel.close();
    }
  }
}","public void shutdown(){
  msgLog.logMessage(""String_Node_Str"",true);
synchronized (channels) {
    for (    Channel channel : unusedChannels) {
      channel.close();
    }
    for (    Channel channel : channels.values()) {
      channel.close();
    }
  }
}",0.9902534113060428
154723,"public void shutdown(){
  deadConnectionsPoller.shutdown();
  msgLog.logMessage(""String_Node_Str"");
  channelGroup.close().awaitUninterruptibly();
}","public void shutdown(){
  deadConnectionsPoller.shutdown();
  msgLog.logMessage(""String_Node_Str"",true);
  channelGroup.close().awaitUninterruptibly();
}",0.9833887043189368
154724,"public MasterServer(Master realMaster,final int port,String storeDir){
  this.realMaster=realMaster;
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  ExecutorService executor=Executors.newCachedThreadPool();
  channelFactory=new NioServerSocketChannelFactory(executor,executor,MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS);
  bootstrap=new ServerBootstrap(channelFactory);
  bootstrap.setPipelineFactory(this);
  channelGroup=new DefaultChannelGroup();
  executor.execute(new Runnable(){
    public void run(){
      Channel channel=bootstrap.bind(new InetSocketAddress(port));
      channelGroup.add(channel);
      msgLog.logMessage(""String_Node_Str"" + port);
    }
  }
);
  deadConnectionsPoller=new ScheduledThreadPoolExecutor(1);
  deadConnectionsPoller.scheduleWithFixedDelay(new Runnable(){
    public void run(){
    }
  }
,DEAD_CONNECTIONS_CHECK_INTERVAL,DEAD_CONNECTIONS_CHECK_INTERVAL,TimeUnit.SECONDS);
}","public MasterServer(Master realMaster,final int port,String storeDir){
  this.realMaster=realMaster;
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  ExecutorService executor=Executors.newCachedThreadPool();
  channelFactory=new NioServerSocketChannelFactory(executor,executor,MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS);
  bootstrap=new ServerBootstrap(channelFactory);
  bootstrap.setPipelineFactory(this);
  channelGroup=new DefaultChannelGroup();
  executor.execute(new Runnable(){
    public void run(){
      Channel channel=bootstrap.bind(new InetSocketAddress(port));
      channelGroup.add(channel);
      msgLog.logMessage(""String_Node_Str"" + port,true);
    }
  }
);
  deadConnectionsPoller=new ScheduledThreadPoolExecutor(1);
  deadConnectionsPoller.scheduleWithFixedDelay(new Runnable(){
    public void run(){
    }
  }
,DEAD_CONNECTIONS_CHECK_INTERVAL,DEAD_CONNECTIONS_CHECK_INTERVAL,TimeUnit.SECONDS);
}",0.9973190348525468
154725,"public void process(WatchedEvent event){
  try {
    String path=event.getPath();
    msgLog.logMessage(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
    if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
      keeperState=KeeperState.Expired;
      if (zooKeeper != null) {
        try {
          zooKeeper.close();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          Thread.interrupted();
        }
      }
      zooKeeper=instantiateZooKeeper();
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
      long newSessionId=zooKeeper.getSessionId();
      if (newSessionId != sessionId) {
        Pair<Master,Machine> masterBeforeIWrite=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterBeforeIWrite);
        sequenceNr=setup();
        msgLog.logMessage(""String_Node_Str"" + sequenceNr + ""String_Node_Str""+ newSessionId);
        keeperState=KeeperState.SyncConnected;
        Pair<Master,Machine> masterAfterIWrote=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterAfterIWrote);
        int masterId=masterAfterIWrote.other().getMachineId();
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,masterId);
        receiver.newMaster(masterAfterIWrote,new Exception());
        sessionId=newSessionId;
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + sessionId);
        keeperState=KeeperState.SyncConnected;
      }
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
      keeperState=KeeperState.Disconnected;
    }
 else     if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
      Pair<Master,Machine> currentMaster=getMasterFromZooKeeper(true);
      if (path.contains(MASTER_NOTIFY_CHILD)) {
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,-1);
        if (currentMaster.other().getMachineId() == machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else       if (path.contains(MASTER_REBOUND_CHILD)) {
        setDataChangeWatcher(MASTER_REBOUND_CHILD,-1);
        if (currentMaster.other().getMachineId() != machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + path);
      }
    }
  }
 catch (  RuntimeException e) {
    msgLog.logMessage(""String_Node_Str"",e);
    e.printStackTrace();
    throw e;
  }
}","public void process(WatchedEvent event){
  try {
    String path=event.getPath();
    msgLog.logMessage(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"",true);
    if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
      keeperState=KeeperState.Expired;
      if (zooKeeper != null) {
        try {
          zooKeeper.close();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          Thread.interrupted();
        }
      }
      zooKeeper=instantiateZooKeeper();
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
      long newSessionId=zooKeeper.getSessionId();
      Pair<Master,Machine> masterBeforeIWrite=getMasterFromZooKeeper(false);
      msgLog.logMessage(""String_Node_Str"" + masterBeforeIWrite);
      if (newSessionId != sessionId || masterBeforeIWrite.other().getMachineId() != getCachedMaster().other().getMachineId()) {
        sequenceNr=setup();
        msgLog.logMessage(""String_Node_Str"" + sequenceNr + ""String_Node_Str""+ newSessionId);
        keeperState=KeeperState.SyncConnected;
        Pair<Master,Machine> masterAfterIWrote=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterAfterIWrote);
        int masterId=masterAfterIWrote.other().getMachineId();
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,masterId);
        receiver.newMaster(masterAfterIWrote,new Exception());
        sessionId=newSessionId;
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + sessionId);
        keeperState=KeeperState.SyncConnected;
      }
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
      keeperState=KeeperState.Disconnected;
    }
 else     if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
      Pair<Master,Machine> currentMaster=getMasterFromZooKeeper(true);
      if (path.contains(MASTER_NOTIFY_CHILD)) {
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,-1);
        if (currentMaster.other().getMachineId() == machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else       if (path.contains(MASTER_REBOUND_CHILD)) {
        setDataChangeWatcher(MASTER_REBOUND_CHILD,-1);
        if (currentMaster.other().getMachineId() != machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + path);
      }
    }
  }
 catch (  RuntimeException e) {
    msgLog.logMessage(""String_Node_Str"",e,true);
    e.printStackTrace();
    throw e;
  }
 finally {
    msgLog.flush();
  }
}",0.958966565349544
154726,"public synchronized void setCommittedTx(long tx){
  msgLog.logMessage(""String_Node_Str"" + tx + ""String_Node_Str""+ machineId);
  waitForSyncConnected();
  this.committedTx=tx;
  String root=getRoot();
  String path=root + ""String_Node_Str"" + machineId+ ""String_Node_Str""+ sequenceNr;
  byte[] data=dataRepresentingMe(tx);
  try {
    zooKeeper.setData(path,data,-1);
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","public synchronized void setCommittedTx(long tx){
  msgLog.logMessage(""String_Node_Str"" + tx + ""String_Node_Str""+ machineId,true);
  waitForSyncConnected();
  this.committedTx=tx;
  String root=getRoot();
  String path=root + ""String_Node_Str"" + machineId+ ""String_Node_Str""+ sequenceNr;
  byte[] data=dataRepresentingMe(tx);
  try {
    zooKeeper.setData(path,data,-1);
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9957155098543272
154727,"private void writeHaServerConfig() throws InterruptedException, KeeperException {
  String path=rootPath + ""String_Node_Str"" + HA_SERVERS_CHILD;
  try {
    zooKeeper.create(path,new byte[0],ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  }
 catch (  KeeperException e) {
    if (e.code() != KeeperException.Code.NODEEXISTS) {
      throw e;
    }
  }
  String machinePath=path + ""String_Node_Str"" + machineId;
  byte[] data=haServerAsData();
  try {
    zooKeeper.create(machinePath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
  }
 catch (  KeeperException e) {
    if (e.code() != KeeperException.Code.NODEEXISTS) {
      throw e;
    }
  }
  zooKeeper.setData(machinePath,data,-1);
  msgLog.logMessage(""String_Node_Str"" + haServer + ""String_Node_Str"");
}","private void writeHaServerConfig() throws InterruptedException, KeeperException {
  String path=rootPath + ""String_Node_Str"" + HA_SERVERS_CHILD;
  try {
    zooKeeper.create(path,new byte[0],ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  }
 catch (  KeeperException e) {
    if (e.code() != KeeperException.Code.NODEEXISTS) {
      throw e;
    }
  }
  String machinePath=path + ""String_Node_Str"" + machineId;
  byte[] data=haServerAsData();
  try {
    zooKeeper.create(machinePath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
  }
 catch (  KeeperException e) {
    if (e.code() != KeeperException.Code.NODEEXISTS) {
      throw e;
    }
    msgLog.logMessage(""String_Node_Str"");
    try {
      zooKeeper.delete(machinePath,-1);
    }
 catch (    KeeperException ee) {
      ee.printStackTrace();
    }
 finally {
      writeHaServerConfig();
    }
  }
  zooKeeper.setData(machinePath,data,-1);
  msgLog.logMessage(""String_Node_Str"" + haServer + ""String_Node_Str"");
}",0.8637911464245176
154728,"private void parseArgs(String[] args){
  for (int i=0; i < args.length; i++) {
    String arg=args[i];
    if (isOption(arg)) {
      arg=stripOption(arg);
      int equalIndex=arg.indexOf('=');
      if (equalIndex != -1) {
        String key=arg.substring(0,equalIndex);
        String value=arg.substring(equalIndex + 1);
        if (value.length() > 0) {
          map.put(key,value);
        }
      }
 else {
        String key=arg;
        int nextIndex=++i;
        String value=nextIndex < args.length ? args[nextIndex] : null;
        value=value == null || isOption(value) ? null : value;
        map.put(key,value);
      }
    }
 else {
      orphans.add(arg);
    }
  }
}","private void parseArgs(String[] args){
  for (int i=0; i < args.length; i++) {
    String arg=args[i];
    if (isOption(arg)) {
      arg=stripOption(arg);
      int equalIndex=arg.indexOf('=');
      if (equalIndex != -1) {
        String key=arg.substring(0,equalIndex);
        String value=arg.substring(equalIndex + 1);
        if (value.length() > 0) {
          map.put(key,value);
        }
      }
 else {
        String key=arg;
        int nextIndex=i + 1;
        String value=nextIndex < args.length ? args[nextIndex] : null;
        value=value == null || isOption(value) ? null : value;
        if (value != null) {
          i=nextIndex;
        }
        map.put(key,value);
      }
    }
 else {
      orphans.add(arg);
    }
  }
}",0.9525801952580196
154729,"public void process(WatchedEvent event){
  try {
    String path=event.getPath();
    msgLog.logMessage(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
    if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
      keeperState=KeeperState.Expired;
      if (zooKeeper != null) {
        try {
          zooKeeper.close();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          Thread.interrupted();
        }
      }
      zooKeeper=instantiateZooKeeper();
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
      Pair<Master,Machine> masterBeforeIWrite=getMasterFromZooKeeper(false);
      msgLog.logMessage(""String_Node_Str"" + masterBeforeIWrite);
      sequenceNr=setup();
      msgLog.logMessage(""String_Node_Str"" + sequenceNr);
      keeperState=KeeperState.SyncConnected;
      Pair<Master,Machine> masterAfterIWrote=getMasterFromZooKeeper(false);
      msgLog.logMessage(""String_Node_Str"" + masterAfterIWrote);
      int masterId=masterAfterIWrote.other().getMachineId();
      setDataChangeWatcher(MASTER_NOTIFY_CHILD,masterId);
      receiver.newMaster(masterAfterIWrote,new Exception());
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
      keeperState=KeeperState.Disconnected;
    }
 else     if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
      Pair<Master,Machine> currentMaster=getMasterFromZooKeeper(true);
      if (path.contains(MASTER_NOTIFY_CHILD)) {
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,-1);
        if (currentMaster.other().getMachineId() == machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else       if (path.contains(MASTER_REBOUND_CHILD)) {
        setDataChangeWatcher(MASTER_REBOUND_CHILD,-1);
        if (currentMaster.other().getMachineId() != machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + path);
      }
    }
  }
 catch (  RuntimeException e) {
    msgLog.logMessage(""String_Node_Str"",e);
    e.printStackTrace();
    throw e;
  }
}","public void process(WatchedEvent event){
  try {
    String path=event.getPath();
    msgLog.logMessage(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
    if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
      keeperState=KeeperState.Expired;
      if (zooKeeper != null) {
        try {
          zooKeeper.close();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          Thread.interrupted();
        }
      }
      zooKeeper=instantiateZooKeeper();
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
      long newSessionId=zooKeeper.getSessionId();
      if (newSessionId != sessionId) {
        Pair<Master,Machine> masterBeforeIWrite=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterBeforeIWrite);
        sequenceNr=setup();
        msgLog.logMessage(""String_Node_Str"" + sequenceNr + ""String_Node_Str""+ newSessionId);
        keeperState=KeeperState.SyncConnected;
        Pair<Master,Machine> masterAfterIWrote=getMasterFromZooKeeper(false);
        msgLog.logMessage(""String_Node_Str"" + masterAfterIWrote);
        int masterId=masterAfterIWrote.other().getMachineId();
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,masterId);
        receiver.newMaster(masterAfterIWrote,new Exception());
        sessionId=newSessionId;
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + sessionId);
        keeperState=KeeperState.SyncConnected;
      }
    }
 else     if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
      keeperState=KeeperState.Disconnected;
    }
 else     if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
      Pair<Master,Machine> currentMaster=getMasterFromZooKeeper(true);
      if (path.contains(MASTER_NOTIFY_CHILD)) {
        setDataChangeWatcher(MASTER_NOTIFY_CHILD,-1);
        if (currentMaster.other().getMachineId() == machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else       if (path.contains(MASTER_REBOUND_CHILD)) {
        setDataChangeWatcher(MASTER_REBOUND_CHILD,-1);
        if (currentMaster.other().getMachineId() != machineId) {
          receiver.newMaster(currentMaster,new Exception());
        }
      }
 else {
        msgLog.logMessage(""String_Node_Str"" + path);
      }
    }
  }
 catch (  RuntimeException e) {
    msgLog.logMessage(""String_Node_Str"",e);
    e.printStackTrace();
    throw e;
  }
}",0.9358178053830228
154730,"private void parseArgs(String[] args){
  for (int i=0; i < args.length; i++) {
    String arg=args[i];
    if (isOption(arg)) {
      arg=stripOption(arg);
      int equalIndex=arg.indexOf('=');
      if (equalIndex != -1) {
        String key=arg.substring(0,equalIndex);
        String value=arg.substring(equalIndex + 1);
        if (value.length() > 0) {
          map.put(key,value);
        }
      }
 else {
        String key=arg;
        int nextIndex=++i;
        String value=nextIndex < args.length ? args[nextIndex] : null;
        value=value == null || isOption(value) ? null : value;
        map.put(key,value);
      }
    }
 else {
      orphans.add(arg);
    }
  }
}","private void parseArgs(String[] args){
  for (int i=0; i < args.length; i++) {
    String arg=args[i];
    if (isOption(arg)) {
      arg=stripOption(arg);
      int equalIndex=arg.indexOf('=');
      if (equalIndex != -1) {
        String key=arg.substring(0,equalIndex);
        String value=arg.substring(equalIndex + 1);
        if (value.length() > 0) {
          map.put(key,value);
        }
      }
 else {
        String key=arg;
        int nextIndex=i + 1;
        String value=nextIndex < args.length ? args[nextIndex] : null;
        value=value == null || isOption(value) ? null : value;
        if (value != null) {
          i=nextIndex;
        }
        map.put(key,value);
      }
    }
 else {
      orphans.add(arg);
    }
  }
}",0.9525801952580196
154731,"public String get(String key,String defaultValue){
  return this.map.containsKey(key) ? this.map.get(key) : defaultValue;
}","public String get(String key,String defaultValue){
  String value=this.map.get(key);
  return value != null ? value : defaultValue;
}",0.71875
154732,"boolean isReadOnly(){
  return readOnly;
}","public boolean isReadOnly(){
  return readOnly;
}",0.9230769230769232
154733,"public void load(final Map<Object,Object> params){
  extensions=new KernelExtension.KernelData(){
    @Override public String version(){
      return KERNEL_VERSION;
    }
    @Override public Config getConfig(){
      return config;
    }
    @Override public Map<Object,Object> getConfigParams(){
      return params;
    }
    @Override public GraphDatabaseService graphDatabase(){
      return EmbeddedGraphDbImpl.this.graphDbService;
    }
    protected void loaded(    KernelExtension extension){
      if (extension instanceof IndexProvider) {
        indexManager.addProvider(extension.getKey(),(IndexProvider)extension);
      }
    }
  }
;
  extensions.startup(msgLog);
}","public void load(){
  extensions.loadAll(msgLog);
}",0.133879781420765
154734,"/** 
 * A non-standard way of creating an embedded   {@link GraphDatabaseService}with a set of configuration parameters. Will most likely be removed in future releases.
 * @param storeDir the store directory for the db files
 * @param config configuration parameters
 */
public EmbeddedGraphDbImpl(String storeDir,Map<String,String> inputParams,GraphDatabaseService graphDbService,LockManagerFactory lockManagerFactory,IdGeneratorFactory idGeneratorFactory,RelationshipTypeCreator relTypeCreator,TxIdGeneratorFactory txIdFactory,TxFinishHook finishHook,LastCommittedTxIdSetter lastCommittedTxIdSetter){
  this.storeDir=storeDir;
  TxModule txModule=newTxModule(inputParams,finishHook);
  LockManager lockManager=lockManagerFactory.create(txModule);
  LockReleaser lockReleaser=new LockReleaser(lockManager,txModule.getTxManager());
  final Config config=new Config(graphDbService,storeDir,inputParams,kernelPanicEventGenerator,txModule,lockManager,lockReleaser,idGeneratorFactory,new SyncHookFactory(),relTypeCreator,txIdFactory.create(txModule.getTxManager()),lastCommittedTxIdSetter);
  graphDbInstance=new GraphDbInstance(storeDir,true,config);
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  this.graphDbService=graphDbService;
  IndexStore indexStore=graphDbInstance.getConfig().getIndexStore();
  this.indexManager=new IndexManagerImpl(this,indexStore);
  graphDbInstance.start(graphDbService,new KernelExtensionLoader(){
    public void load(    final Map<Object,Object> params){
      extensions=new KernelExtension.KernelData(){
        @Override public String version(){
          return KERNEL_VERSION;
        }
        @Override public Config getConfig(){
          return config;
        }
        @Override public Map<Object,Object> getConfigParams(){
          return params;
        }
        @Override public GraphDatabaseService graphDatabase(){
          return EmbeddedGraphDbImpl.this.graphDbService;
        }
        protected void loaded(        KernelExtension extension){
          if (extension instanceof IndexProvider) {
            indexManager.addProvider(extension.getKey(),(IndexProvider)extension);
          }
        }
      }
;
      extensions.startup(msgLog);
    }
  }
);
  nodeManager=config.getGraphDbModule().getNodeManager();
}","/** 
 * A non-standard way of creating an embedded   {@link GraphDatabaseService}with a set of configuration parameters. Will most likely be removed in future releases.
 * @param storeDir the store directory for the db files
 * @param config configuration parameters
 */
public EmbeddedGraphDbImpl(String storeDir,Map<String,String> inputParams,GraphDatabaseService graphDbService,LockManagerFactory lockManagerFactory,IdGeneratorFactory idGeneratorFactory,RelationshipTypeCreator relTypeCreator,TxIdGeneratorFactory txIdFactory,TxFinishHook finishHook,LastCommittedTxIdSetter lastCommittedTxIdSetter){
  this.storeDir=storeDir;
  TxModule txModule=newTxModule(inputParams,finishHook);
  LockManager lockManager=lockManagerFactory.create(txModule);
  LockReleaser lockReleaser=new LockReleaser(lockManager,txModule.getTxManager());
  final Config config=new Config(graphDbService,storeDir,inputParams,kernelPanicEventGenerator,txModule,lockManager,lockReleaser,idGeneratorFactory,new SyncHookFactory(),relTypeCreator,txIdFactory.create(txModule.getTxManager()),lastCommittedTxIdSetter);
  graphDbInstance=new GraphDbInstance(storeDir,true,config);
  this.msgLog=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  this.graphDbService=graphDbService;
  IndexStore indexStore=graphDbInstance.getConfig().getIndexStore();
  this.indexManager=new IndexManagerImpl(this,indexStore);
  extensions=new KernelExtension.KernelData(){
    @Override public String version(){
      return KERNEL_VERSION;
    }
    @Override public Config getConfig(){
      return config;
    }
    @Override public Map<Object,Object> getConfigParams(){
      return config.getParams();
    }
    @Override public GraphDatabaseService graphDatabase(){
      return EmbeddedGraphDbImpl.this.graphDbService;
    }
    protected void initialized(    KernelExtension extension){
      if (extension instanceof IndexProvider) {
        indexManager.addProvider(extension.getKey(),(IndexProvider)extension);
      }
    }
  }
;
  KernelExtensionLoader extensionLoader=new KernelExtensionLoader(){
    public void init(){
      extensions.initAll(msgLog);
    }
    public void load(){
      extensions.loadAll(msgLog);
    }
  }
;
  graphDbInstance.start(graphDbService,extensionLoader);
  nodeManager=config.getGraphDbModule().getNodeManager();
  extensionLoader.load();
}",0.870390338580979
154735,"@Override public Map<Object,Object> getConfigParams(){
  return params;
}","@Override public Map<Object,Object> getConfigParams(){
  return config.getParams();
}",0.9113924050632912
154736,"/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,KernelExtensionLoader kernelExtensionLoader){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  params.putAll(config.getInputParams());
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.load(params);
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage(""String_Node_Str"");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage(""String_Node_Str"" + Version.get());
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(""String_Node_Str"" + os.getName() + ""String_Node_Str""+ os.getVersion()+ ""String_Node_Str""+ os.getArch());
  logger.logMessage(""String_Node_Str"" + runtime.getVmName());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVendor());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage(""String_Node_Str"" + runtime.getBootClassPath());
  }
  logger.logMessage(""String_Node_Str"" + runtime.getClassPath());
  logger.logMessage(""String_Node_Str"" + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage(""String_Node_Str"" + gcBean.getName() + ""String_Node_Str""+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage(""String_Node_Str"" + runtime.getInputArguments());
  logger.logMessage(""String_Node_Str"");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage(""String_Node_Str"");
  started=true;
  return Collections.unmodifiableMap(params);
}","/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,KernelExtensionLoader kernelExtensionLoader){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=config.getParams();
  boolean useMemoryMapped=Boolean.parseBoolean((String)config.getInputParams().get(Config.USE_MEMORY_MAPPED_BUFFERS));
  boolean dumpToConsole=Boolean.parseBoolean((String)config.getInputParams().get(Config.DUMP_CONFIGURATION));
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  StringLogger logger=StringLogger.getLogger(storeDir + ""String_Node_Str"");
  AutoConfigurator autoConfigurator=new AutoConfigurator(storeDir,useMemoryMapped,dumpToConsole);
  autoConfigurator.configure(subset(config.getInputParams(),Config.USE_MEMORY_MAPPED_BUFFERS));
  params.putAll(config.getInputParams());
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  kernelExtensionLoader.init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,config.getSyncHookFactory());
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),config.getRelationshipTypeCreator(),params);
  logger.logMessage(""String_Node_Str"");
  logger.logMessage(autoConfigurator.getNiceMemoryInformation());
  logger.logMessage(""String_Node_Str"" + Version.get());
  RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  logger.logMessage(""String_Node_Str"" + os.getName() + ""String_Node_Str""+ os.getVersion()+ ""String_Node_Str""+ os.getArch());
  logger.logMessage(""String_Node_Str"" + runtime.getVmName());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVendor());
  logger.logMessage(""String_Node_Str"" + runtime.getVmVersion());
  if (runtime.isBootClassPathSupported()) {
    logger.logMessage(""String_Node_Str"" + runtime.getBootClassPath());
  }
  logger.logMessage(""String_Node_Str"" + runtime.getClassPath());
  logger.logMessage(""String_Node_Str"" + runtime.getLibraryPath());
  for (  GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {
    logger.logMessage(""String_Node_Str"" + gcBean.getName() + ""String_Node_Str""+ Arrays.toString(gcBean.getMemoryPoolNames()));
  }
  logger.logMessage(""String_Node_Str"" + runtime.getInputArguments());
  logger.logMessage(""String_Node_Str"");
  logConfiguration(params,logger,dumpToConsole);
  logger.logMessage(""String_Node_Str"");
  started=true;
  return Collections.unmodifiableMap(params);
}",0.9983929288871032
154737,"synchronized void shutdown(StringLogger msgLog){
  for (  KernelExtension loaded : state.keySet()) {
    try {
      loaded.unload(this);
    }
 catch (    Exception ex) {
      msgLog.logMessage(""String_Node_Str"" + loaded,ex);
    }
  }
  removeInstance(instanceId);
}","synchronized void shutdown(StringLogger msgLog){
  for (  KernelExtension loaded : loadedExtensions) {
    try {
      loaded.unload(this);
    }
 catch (    Exception ex) {
      msgLog.logMessage(""String_Node_Str"" + loaded,ex);
    }
  }
  removeInstance(instanceId);
}",0.9444444444444444
154738,"void load(Map<Object,Object> params);",void load();,0.4897959183673469
154739,"Query query(String keyOrNull,Object value,QueryContext contextOrNull){
  if (value instanceof Query) {
    return (Query)value;
  }
  QueryParser parser=new QueryParser(Version.LUCENE_30,keyOrNull,analyzer);
  parser.setAllowLeadingWildcard(true);
  parser.setLowercaseExpandedTerms(false);
  if (contextOrNull != null && contextOrNull.defaultOperator != null) {
    parser.setDefaultOperator(contextOrNull.defaultOperator);
  }
  try {
    return parser.parse(value.toString());
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
}","Query query(String keyOrNull,Object value,QueryContext contextOrNull){
  if (value instanceof Query) {
    return (Query)value;
  }
  QueryParser parser=new QueryParser(Version.LUCENE_30,keyOrNull,analyzer);
  parser.setAllowLeadingWildcard(true);
  parser.setLowercaseExpandedTerms(toLowerCase);
  if (contextOrNull != null && contextOrNull.defaultOperator != null) {
    parser.setDefaultOperator(contextOrNull.defaultOperator);
  }
  try {
    return parser.parse(value.toString());
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
}",0.9892280071813284
154740,"private IndexType(Analyzer analyzer){
  this.analyzer=analyzer;
}","private IndexType(Analyzer analyzer,boolean toLowerCase){
  this.analyzer=analyzer;
  this.toLowerCase=toLowerCase;
}",0.7142857142857143
154741,"static IndexType getIndexType(IndexIdentifier identifier){
  Map<String,String> config=identifier.config;
  String type=config.get(configKey(identifier.indexName,""String_Node_Str""));
  IndexType result=null;
  if (type.equals(""String_Node_Str"")) {
    result=EXACT;
  }
 else   if (type.equals(""String_Node_Str"")) {
    result=new FulltextType(getAnalyzer(config,identifier.indexName));
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ identifier.indexName+ ""String_Node_Str"");
  }
  return result;
}","static IndexType getIndexType(IndexIdentifier identifier){
  Map<String,String> config=identifier.config;
  String type=config.get(configKey(identifier.indexName,""String_Node_Str""));
  IndexType result=null;
  boolean toLowerCase=parseBoolean(config.get(configKey(identifier.indexName,""String_Node_Str"")),true);
  Analyzer customAnalyzer=getCustomAnalyzer(config,identifier.indexName);
  if (type != null) {
    if (type.equals(""String_Node_Str"")) {
      result=EXACT;
    }
 else     if (type.equals(""String_Node_Str"")) {
      Analyzer analyzer=customAnalyzer;
      if (analyzer == null) {
        analyzer=toLowerCase ? LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER : LuceneDataSource.WHITESPACE_ANALYZER;
      }
      result=new CustomType(analyzer,toLowerCase);
    }
  }
 else {
    if (customAnalyzer == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + Analyzer.class.getName() + ""String_Node_Str"");
    }
    result=new CustomType(customAnalyzer,toLowerCase);
  }
  return result;
}",0.5391849529780565
154742,"/** 
 * Returns an algorithm which can find all paths of a certain length between two nodes. These returned paths can contain loops (i.e. a node could occur more than once in any returned path).
 * @see ShortestPath
 * @param expander the {@link RelationshipExpander} to use for expanding{@link Relationship}s for each   {@link Node}.
 * @param length the {@link Path#length()} returned paths are must have.
 * @return an algorithm which finds paths of a certain length between two nodes.
 */
public static PathFinder<Path> pathsWithLength(RelationshipExpander expander,int length){
  return new ShortestPath(length,expander,true);
}","/** 
 * Returns an algorithm which can find simple all paths of a certain length between two nodes. These returned paths cannot contain loops (i.e. a node could not occur more than once in any returned path).
 * @see ShortestPath
 * @param expander the {@link RelationshipExpander} to use for expanding{@link Relationship}s for each   {@link Node}.
 * @param length the {@link Path#length()} returned paths will have, if anypaths were found.
 * @return an algorithm which finds paths of a certain length between two nodes.
 */
public static PathFinder<Path> pathsWithLength(RelationshipExpander expander,int length){
  return new ShortestPath(length,expander,true);
}",0.9615384615384616
154743,"@Override protected Node fetchNextOrNull(){
  while (true) {
    Relationship nextRel=fetchNextRelOrNull();
    if (nextRel == null) {
      return null;
    }
    Node result=nextRel.getOtherNode(this.lastParentTraverserNode);
    LevelData levelData=this.visitedNodes.get(result);
    boolean createdLevelData=false;
    if (levelData == null) {
      levelData=new LevelData(nextRel,this.currentDepth);
      this.visitedNodes.put(result,levelData);
      createdLevelData=true;
    }
    if (this.currentDepth < levelData.depth) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else     if (!this.stopAsap && this.currentDepth == levelData.depth && !createdLevelData) {
      levelData.addRel(nextRel);
    }
    if (!createdLevelData) {
      continue;
    }
    this.nextNodes.add(result);
    return result;
  }
}","@Override protected Node fetchNextOrNull(){
  while (true) {
    Relationship nextRel=fetchNextRelOrNull();
    if (nextRel == null) {
      return null;
    }
    if (!hitDecider.canVisitRelationship(sharedVisitedRels,nextRel)) {
      continue;
    }
    Node result=nextRel.getOtherNode(this.lastParentTraverserNode);
    LevelData levelData=this.visitedNodes.get(result);
    boolean createdLevelData=false;
    if (levelData == null) {
      levelData=new LevelData(nextRel,this.currentDepth);
      this.visitedNodes.put(result,levelData);
      createdLevelData=true;
    }
    if (this.currentDepth < levelData.depth) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else     if (!this.stopAsap && this.currentDepth == levelData.depth && !createdLevelData) {
      levelData.addRel(nextRel);
    }
    if (!createdLevelData) {
      continue;
    }
    this.nextNodes.add(result);
    return result;
  }
}",0.94712905059693
154744,"DirectionData(Node startNode,Collection<Long> sharedVisitedRels,MutableInteger sharedFrozenDepth,MutableBoolean sharedStop,MutableInteger sharedCurrentDepth,boolean stopAsap,RelationshipExpander expander){
  this.startNode=startNode;
  this.visitedNodes.put(startNode,new LevelData(null,0));
  this.nextNodes.add(startNode);
  this.sharedFrozenDepth=sharedFrozenDepth;
  this.sharedStop=sharedStop;
  this.sharedCurrentDepth=sharedCurrentDepth;
  this.stopAsap=stopAsap;
  this.expander=expander;
  prepareNextLevel();
}","DirectionData(Node startNode,Collection<Long> sharedVisitedRels,MutableInteger sharedFrozenDepth,MutableBoolean sharedStop,MutableInteger sharedCurrentDepth,boolean stopAsap,RelationshipExpander expander){
  this.startNode=startNode;
  this.visitedNodes.put(startNode,new LevelData(null,0));
  this.nextNodes.add(startNode);
  this.sharedFrozenDepth=sharedFrozenDepth;
  this.sharedStop=sharedStop;
  this.sharedCurrentDepth=sharedCurrentDepth;
  this.stopAsap=stopAsap;
  this.expander=expander;
  this.sharedVisitedRels=sharedVisitedRels;
  prepareNextLevel();
}",0.959409594095941
154745,"private void read(){
  if (!file.exists()) {
    return;
  }
  FileChannel channel=null;
  try {
    channel=new RandomAccessFile(file,""String_Node_Str"").getChannel();
    Integer version=tryToReadVersion(channel);
    if (version == null) {
      close(channel);
      channel=new RandomAccessFile(file,""String_Node_Str"").getChannel();
      readMap(channel,nodeConfig,version);
      relConfig.putAll(nodeConfig);
    }
 else     if (version < VERSION) {
      throw new UnsupportedOperationException(""String_Node_Str"" + version);
    }
 else {
      readMap(channel,nodeConfig,readNextInt(channel));
      readMap(channel,relConfig,readNextInt(channel));
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    close(channel);
  }
}","private void read(){
  File fileToReadFrom=file.exists() ? file : oldFile;
  if (!fileToReadFrom.exists()) {
    return;
  }
  FileChannel channel=null;
  try {
    channel=new RandomAccessFile(fileToReadFrom,""String_Node_Str"").getChannel();
    Integer version=tryToReadVersion(channel);
    if (version == null) {
      close(channel);
      channel=new RandomAccessFile(fileToReadFrom,""String_Node_Str"").getChannel();
      readMap(channel,nodeConfig,version);
      relConfig.putAll(nodeConfig);
    }
 else     if (version < VERSION) {
      throw new UnsupportedOperationException(""String_Node_Str"" + version);
    }
 else {
      readMap(channel,nodeConfig,readNextInt(channel));
      readMap(channel,relConfig,readNextInt(channel));
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    close(channel);
  }
}",0.9482758620689656
154746,"public IndexStore(String graphDbStoreDir){
  this.file=new File(new File(graphDbStoreDir),""String_Node_Str"");
  read();
}","public IndexStore(String graphDbStoreDir){
  this.file=new File(new File(graphDbStoreDir),""String_Node_Str"");
  this.oldFile=new File(file.getParentFile(),file.getName() + ""String_Node_Str"");
  read();
}",0.7160493827160493
154747,"@Test public void testRecovery() throws Exception {
  final GraphDatabaseService graphDb=newGraphDbService();
  final IndexProvider provider=new LuceneIndexProvider(graphDb);
  final Index<Node> nodeIndex=provider.nodeIndex(""String_Node_Str"",LuceneIndexProvider.EXACT_CONFIG);
  final Index<Relationship> relIndex=provider.relationshipIndex(""String_Node_Str"",LuceneIndexProvider.EXACT_CONFIG);
  final RelationshipType relType=DynamicRelationshipType.withName(""String_Node_Str"");
  graphDb.beginTx();
  Random random=new Random();
  Thread stopper=new Thread(){
    @Override public void run(){
      sleepNice(1000);
      graphDb.shutdown();
    }
  }
;
  final String[] keys={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  try {
    stopper.start();
    for (int i=0; i < 50; i++) {
      Node node=graphDb.createNode();
      Node otherNode=graphDb.createNode();
      Relationship rel=node.createRelationshipTo(otherNode,relType);
      for (int ii=0; ii < 3; ii++) {
        nodeIndex.add(node,keys[random.nextInt(keys.length)],random.nextInt());
        relIndex.add(rel,keys[random.nextInt(keys.length)],random.nextInt());
      }
      sleepNice(10);
    }
  }
 catch (  Exception e) {
  }
  sleepNice(1000);
  final GraphDatabaseService newGraphDb=new EmbeddedGraphDatabase(getDbPath());
  final IndexProvider newProvider=new LuceneIndexProvider(newGraphDb);
  sleepNice(1000);
  newGraphDb.shutdown();
}","@Test public void testRecovery() throws Exception {
  final GraphDatabaseService graphDb=newGraphDbService();
  final IndexProvider provider=new LuceneIndexProvider(graphDb);
  final Index<Node> nodeIndex=provider.nodeIndex(""String_Node_Str"",LuceneIndexProvider.EXACT_CONFIG);
  final Index<Relationship> relIndex=provider.relationshipIndex(""String_Node_Str"",LuceneIndexProvider.EXACT_CONFIG);
  final RelationshipType relType=DynamicRelationshipType.withName(""String_Node_Str"");
  graphDb.beginTx();
  Random random=new Random();
  Thread stopper=new Thread(){
    @Override public void run(){
      sleepNice(1000);
      graphDb.shutdown();
    }
  }
;
  final String[] keys={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  try {
    stopper.start();
    for (int i=0; i < 50; i++) {
      Node node=graphDb.createNode();
      Node otherNode=graphDb.createNode();
      Relationship rel=node.createRelationshipTo(otherNode,relType);
      for (int ii=0; ii < 3; ii++) {
        nodeIndex.add(node,keys[random.nextInt(keys.length)],random.nextInt());
        relIndex.add(rel,keys[random.nextInt(keys.length)],random.nextInt());
      }
      sleepNice(10);
    }
  }
 catch (  Exception e) {
  }
  while (stopper.getState() != State.TERMINATED) {
    sleepNice(100);
  }
  final GraphDatabaseService newGraphDb=new EmbeddedGraphDatabase(getDbPath());
  final IndexProvider newProvider=new LuceneIndexProvider(newGraphDb);
  newGraphDb.shutdown();
}",0.971943193626602
154748,"DeleteCommand(IndexIdentifier indexId){
  super(indexId,(byte)0,-1L,""String_Node_Str"",""String_Node_Str"",DELETE_COMMAND);
}","DeleteCommand(IndexIdentifier indexId){
  super(indexId,indexId.entityTypeByte,-1L,""String_Node_Str"",""String_Node_Str"",DELETE_COMMAND);
}",0.9111969111969112
154749,"@Override public void run(){
  CommandState state=new CommandState(index,graphDb);
  threadState.set(WorkThread.WAITING);
  while (state.alive) {
    try {
      latch=new CountDownLatch(1);
      log(""String_Node_Str"");
      latch.await();
      threadState.set(RUNNING);
      Command command=commands.poll();
      log(""String_Node_Str"" + command.getClass().getSimpleName());
      command.doWork(state);
      threadState.set(WorkThread.DONE);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
catch (    Exception exception) {
      this.exception=exception;
      threadState.set(WorkThread.DONE);
    }
  }
}","@Override public void run(){
  CommandState state=new CommandState(index,graphDb);
  threadState.set(STARTING);
  while (state.alive) {
    try {
      latch=new CountDownLatch(1);
      log(""String_Node_Str"");
      latch.await();
      threadState.set(RUNNING);
      Command command=commands.poll();
      log(""String_Node_Str"" + command.getClass().getSimpleName());
      command.doWork(state);
      threadState.set(DONE);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
catch (    Exception exception) {
      this.exception=exception;
      threadState.set(DONE);
    }
  }
}",0.9717425431711146
154750,"private void waitFor(){
  while (!threadState.compareAndSet(DONE,WAITING)) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
}","private void waitFor(int expectedState,int newState){
  int retries=0;
  while (!threadState.compareAndSet(expectedState,newState) && retries++ < 100) {
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  if (retries > 100) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.6654867256637168
154751,"public BaseWorker(Index<Node> index,GraphDatabaseService graphDb){
  this.index=index;
  this.graphDb=graphDb;
  start();
}","public BaseWorker(Index<Node> index,GraphDatabaseService graphDb){
  this.index=index;
  this.graphDb=graphDb;
  start();
  waitForWorkerToStart();
}",0.9044117647058824
154752,"protected void queueCommand(Command cmd){
  commands.add(cmd);
  log(""String_Node_Str"" + cmd.getClass().getSimpleName());
  latch.countDown();
  waitFor();
  threadState.set(WAITING);
}","protected void queueCommand(Command cmd){
  commands.add(cmd);
  log(""String_Node_Str"" + cmd.getClass().getSimpleName());
  latch.countDown();
  waitForCommandToComplete();
  threadState.set(WAITING);
}",0.9560723514211886
154753,"/** 
 * @param serverLocation the RMI location of the server to connect to.
 * @throws ShellException if no server was found at the RMI location.
 */
public RemoteClient(RmiLocation serverLocation) throws ShellException {
  this.serverLocation=serverLocation;
  this.server=findRemoteServer();
  this.session=new SessionImpl();
  this.out=RemoteOutput.newOutput();
}","/** 
 * @param serverLocation the RMI location of the server to connect to.
 * @throws ShellException if no server was found at the RMI location.
 */
public RemoteClient(RmiLocation serverLocation) throws ShellException {
  this.serverLocation=serverLocation;
  this.server=findRemoteServer();
  this.out=RemoteOutput.newOutput();
}",0.8882521489971347
154754,"public void shutdown(){
  this.tryUnexport(this.out);
  if (session.writer != null)   this.tryUnexport(session.writer);
}","public void shutdown(){
  super.shutdown();
  this.tryUnexport(this.out);
}",0.5612244897959183
154755,"public static void main(final String[] args){
  deleteFileOrDirectory(new File(DB_PATH));
  graphDb=new EmbeddedGraphDatabase(DB_PATH);
  indexService=new LuceneIndexService(graphDb);
  registerShutdownHook();
  Transaction tx=graphDb.beginTx();
  try {
    createChain(""String_Node_Str"",""String_Node_Str"");
    createChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    createChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    createChain(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
  finally {
    tx.finish();
  }
  Node neo=getOrCreateNode(""String_Node_Str"");
  Node agentSmith=getOrCreateNode(""String_Node_Str"");
  PathFinder<Path> finder=GraphAlgoFactory.shortestPath(Traversal.expanderForTypes(KNOWS,Direction.BOTH),4);
  Path foundPath=finder.findSinglePath(neo,agentSmith);
  System.out.println(""String_Node_Str"" + Traversal.simplePathToString(foundPath,NAME_KEY));
  System.out.println(""String_Node_Str"");
  indexService.shutdown();
  graphDb.shutdown();
  System.exit(0);
}","public static void main(final String[] args){
  deleteFileOrDirectory(new File(DB_PATH));
  graphDb=new EmbeddedGraphDatabase(DB_PATH);
  indexService=new LuceneIndexService(graphDb);
  registerShutdownHook();
  Transaction tx=graphDb.beginTx();
  try {
    createChain(""String_Node_Str"",""String_Node_Str"");
    createChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    createChain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    createChain(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
  finally {
    tx.finish();
  }
  Node neo=getOrCreateNode(""String_Node_Str"");
  Node agentSmith=getOrCreateNode(""String_Node_Str"");
  PathFinder<Path> finder=GraphAlgoFactory.shortestPath(Traversal.expanderForTypes(KNOWS,Direction.BOTH),4);
  Path foundPath=finder.findSinglePath(neo,agentSmith);
  System.out.println(""String_Node_Str"" + Traversal.simplePathToString(foundPath,NAME_KEY));
  System.out.println(""String_Node_Str"");
  indexService.shutdown();
  graphDb.shutdown();
}",0.9911678115799804
154756,"public static void main(final String[] args){
  GraphDatabaseService graphDb=new EmbeddedGraphDatabase(DB_PATH);
  registerShutdownHook(graphDb);
  Transaction tx=graphDb.beginTx();
  try {
    Node firstNode=graphDb.createNode();
    firstNode.setProperty(NAME_KEY,""String_Node_Str"");
    Node secondNode=graphDb.createNode();
    secondNode.setProperty(NAME_KEY,""String_Node_Str"");
    firstNode.createRelationshipTo(secondNode,ExampleRelationshipTypes.EXAMPLE);
    String greeting=firstNode.getProperty(NAME_KEY) + ""String_Node_Str"" + secondNode.getProperty(NAME_KEY);
    System.out.println(greeting);
    firstNode.getSingleRelationship(ExampleRelationshipTypes.EXAMPLE,Direction.OUTGOING).delete();
    firstNode.delete();
    secondNode.delete();
    tx.success();
  }
  finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  graphDb.shutdown();
  System.exit(0);
}","public static void main(final String[] args){
  GraphDatabaseService graphDb=new EmbeddedGraphDatabase(DB_PATH);
  registerShutdownHook(graphDb);
  Transaction tx=graphDb.beginTx();
  try {
    Node firstNode=graphDb.createNode();
    firstNode.setProperty(NAME_KEY,""String_Node_Str"");
    Node secondNode=graphDb.createNode();
    secondNode.setProperty(NAME_KEY,""String_Node_Str"");
    firstNode.createRelationshipTo(secondNode,ExampleRelationshipTypes.EXAMPLE);
    String greeting=firstNode.getProperty(NAME_KEY) + ""String_Node_Str"" + secondNode.getProperty(NAME_KEY);
    System.out.println(greeting);
    firstNode.getSingleRelationship(ExampleRelationshipTypes.EXAMPLE,Direction.OUTGOING).delete();
    firstNode.delete();
    secondNode.delete();
    tx.success();
  }
  finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  graphDb.shutdown();
}",0.9898074745186864
154757,"public static void main(final String[] args){
  graphDb=new EmbeddedGraphDatabase(DB_PATH);
  indexService=new LuceneIndexService(graphDb);
  registerShutdownHook();
  Transaction tx=graphDb.beginTx();
  try {
    Node usersReferenceNode=graphDb.createNode();
    graphDb.getReferenceNode().createRelationshipTo(usersReferenceNode,RelTypes.USERS_REFERENCE);
    for (int id=0; id < 100; id++) {
      Node userNode=createAndIndexUser(idToUserName(id));
      usersReferenceNode.createRelationshipTo(userNode,RelTypes.USER);
    }
    System.out.println(""String_Node_Str"");
    int idToFind=45;
    Node foundUser=indexService.getSingleNode(USERNAME_KEY,idToUserName(idToFind));
    System.out.println(""String_Node_Str"" + idToFind + ""String_Node_Str""+ foundUser.getProperty(USERNAME_KEY));
    for (    Relationship relationship : usersReferenceNode.getRelationships(RelTypes.USER,Direction.OUTGOING)) {
      Node user=relationship.getEndNode();
      indexService.removeIndex(user,USERNAME_KEY,user.getProperty(USERNAME_KEY));
      user.delete();
      relationship.delete();
    }
    usersReferenceNode.getSingleRelationship(RelTypes.USERS_REFERENCE,Direction.INCOMING).delete();
    usersReferenceNode.delete();
    tx.success();
  }
  finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  shutdown();
  System.exit(0);
}","public static void main(final String[] args){
  graphDb=new EmbeddedGraphDatabase(DB_PATH);
  indexService=new LuceneIndexService(graphDb);
  registerShutdownHook();
  Transaction tx=graphDb.beginTx();
  try {
    Node usersReferenceNode=graphDb.createNode();
    graphDb.getReferenceNode().createRelationshipTo(usersReferenceNode,RelTypes.USERS_REFERENCE);
    for (int id=0; id < 100; id++) {
      Node userNode=createAndIndexUser(idToUserName(id));
      usersReferenceNode.createRelationshipTo(userNode,RelTypes.USER);
    }
    System.out.println(""String_Node_Str"");
    int idToFind=45;
    Node foundUser=indexService.getSingleNode(USERNAME_KEY,idToUserName(idToFind));
    System.out.println(""String_Node_Str"" + idToFind + ""String_Node_Str""+ foundUser.getProperty(USERNAME_KEY));
    for (    Relationship relationship : usersReferenceNode.getRelationships(RelTypes.USER,Direction.OUTGOING)) {
      Node user=relationship.getEndNode();
      indexService.removeIndex(user,USERNAME_KEY,user.getProperty(USERNAME_KEY));
      user.delete();
      relationship.delete();
    }
    usersReferenceNode.getSingleRelationship(RelTypes.USERS_REFERENCE,Direction.INCOMING).delete();
    usersReferenceNode.delete();
    tx.success();
  }
  finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  shutdown();
}",0.9932685115931188
154758,"public static void main(final String[] args) throws Exception {
  registerShutdownHookForNeo();
  boolean trueForLocal=waitForUserInput(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"");
  if (trueForLocal) {
    startLocalShell();
  }
 else {
    startRemoteShellAndWait();
  }
  shutdown();
  System.exit(0);
}","public static void main(final String[] args) throws Exception {
  registerShutdownHookForNeo();
  boolean trueForLocal=waitForUserInput(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"");
  if (trueForLocal) {
    startLocalShell();
  }
 else {
    startRemoteShellAndWait();
  }
  shutdown();
}",0.9741379310344828
154759,"public Object propertyGetValue(int id){
  PropertyRecord propertyRecord=getPropertyRecord(id);
  if (propertyRecord == null) {
    propertyRecord=getPropertyStore().getRecord(id);
  }
  if (propertyRecord.isLight()) {
    getPropertyStore().makeHeavy(propertyRecord);
  }
  PropertyType type=propertyRecord.getType();
  if (type == PropertyType.INT) {
    return (int)propertyRecord.getPropBlock();
  }
  if (type == PropertyType.STRING) {
    return getPropertyStore().getStringFor(propertyRecord);
  }
  if (type == PropertyType.BOOL) {
    if (propertyRecord.getPropBlock() == 1) {
      return Boolean.valueOf(true);
    }
    return Boolean.valueOf(false);
  }
  if (type == PropertyType.DOUBLE) {
    return new Double(Double.longBitsToDouble(propertyRecord.getPropBlock()));
  }
  if (type == PropertyType.FLOAT) {
    return new Float(Float.intBitsToFloat((int)propertyRecord.getPropBlock()));
  }
  if (type == PropertyType.LONG) {
    return propertyRecord.getPropBlock();
  }
  if (type == PropertyType.BYTE) {
    return (byte)propertyRecord.getPropBlock();
  }
  if (type == PropertyType.CHAR) {
    return (char)propertyRecord.getPropBlock();
  }
  if (type == PropertyType.ARRAY) {
    return getPropertyStore().getArrayFor(propertyRecord);
  }
  if (type == PropertyType.SHORT) {
    return (short)propertyRecord.getPropBlock();
  }
  throw new InvalidRecordException(""String_Node_Str"" + type + ""String_Node_Str""+ propertyRecord);
}","public Object propertyGetValue(int id){
  PropertyRecord propertyRecord=getPropertyStore().getRecord(id);
  if (propertyRecord.isLight()) {
    getPropertyStore().makeHeavy(propertyRecord);
  }
  PropertyType type=propertyRecord.getType();
  if (type == PropertyType.INT) {
    return (int)propertyRecord.getPropBlock();
  }
  if (type == PropertyType.STRING) {
    return getPropertyStore().getStringFor(propertyRecord);
  }
  if (type == PropertyType.BOOL) {
    if (propertyRecord.getPropBlock() == 1) {
      return Boolean.valueOf(true);
    }
    return Boolean.valueOf(false);
  }
  if (type == PropertyType.DOUBLE) {
    return new Double(Double.longBitsToDouble(propertyRecord.getPropBlock()));
  }
  if (type == PropertyType.FLOAT) {
    return new Float(Float.intBitsToFloat((int)propertyRecord.getPropBlock()));
  }
  if (type == PropertyType.LONG) {
    return propertyRecord.getPropBlock();
  }
  if (type == PropertyType.BYTE) {
    return (byte)propertyRecord.getPropBlock();
  }
  if (type == PropertyType.CHAR) {
    return (char)propertyRecord.getPropBlock();
  }
  if (type == PropertyType.ARRAY) {
    return getPropertyStore().getArrayFor(propertyRecord);
  }
  if (type == PropertyType.SHORT) {
    return (short)propertyRecord.getPropBlock();
  }
  throw new InvalidRecordException(""String_Node_Str"" + type + ""String_Node_Str""+ propertyRecord);
}",0.9723207948899928
154760,"public ArrayMap<Integer,PropertyData> relGetProperties(int relId,boolean light){
  RelationshipRecord relRecord=getRelationshipRecord(relId);
  if (relRecord != null) {
    if (!relRecord.inUse() && !light) {
      throw new IllegalStateException(""String_Node_Str"" + relId + ""String_Node_Str"");
    }
  }
 else {
    relRecord=getRelationshipStore().getRecord(relId);
  }
  if (!relRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + relId + ""String_Node_Str"");
  }
  int nextProp=relRecord.getNextProp();
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyRecord(nextProp);
    if (propRecord == null) {
      propRecord=getPropertyStore().getLightRecord(nextProp);
    }
    if (!propRecord.isCreated()) {
      propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    }
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}","public ArrayMap<Integer,PropertyData> relGetProperties(int relId,boolean light){
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  RelationshipRecord relRecord=getRelationshipRecord(relId);
  if (relRecord != null && relRecord.isCreated()) {
    return propertyMap;
  }
  if (relRecord != null) {
    if (!relRecord.inUse() && !light) {
      throw new IllegalStateException(""String_Node_Str"" + relId + ""String_Node_Str"");
    }
  }
  relRecord=getRelationshipStore().getRecord(relId);
  if (!relRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + relId + ""String_Node_Str"");
  }
  int nextProp=relRecord.getNextProp();
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyStore().getLightRecord(nextProp);
    propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}",0.4094185487746276
154761,"public RelationshipChainPosition getRelationshipChainPosition(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord == null) {
    nodeRecord=getNodeStore().getRecord(nodeId);
  }
  int nextRel=nodeRecord.getNextRel();
  return new RelationshipChainPosition(nextRel);
}","public RelationshipChainPosition getRelationshipChainPosition(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord != null && nodeRecord.isCreated()) {
    return new RelationshipChainPosition(Record.NO_NEXT_RELATIONSHIP.intValue());
  }
  nodeRecord=getNodeStore().getRecord(nodeId);
  int nextRel=nodeRecord.getNextRel();
  return new RelationshipChainPosition(nextRel);
}",0.4144927536231884
154762,"ArrayMap<Integer,PropertyData> nodeGetProperties(int nodeId,boolean light){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord != null) {
    if (!nodeRecord.inUse() && !light) {
      throw new IllegalStateException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
    }
  }
 else {
    nodeRecord=getNodeStore().getRecord(nodeId);
  }
  if (!nodeRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
  }
  int nextProp=nodeRecord.getNextProp();
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyRecord(nextProp);
    if (propRecord == null) {
      propRecord=getPropertyStore().getLightRecord(nextProp);
    }
    if (!propRecord.isCreated()) {
      propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    }
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}","ArrayMap<Integer,PropertyData> nodeGetProperties(int nodeId,boolean light){
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord != null && nodeRecord.isCreated()) {
    return propertyMap;
  }
  if (nodeRecord != null) {
    if (!nodeRecord.inUse() && !light) {
      throw new IllegalStateException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
    }
  }
  nodeRecord=getNodeStore().getRecord(nodeId);
  if (!nodeRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
  }
  int nextProp=nodeRecord.getNextProp();
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyStore().getLightRecord(nextProp);
    propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}",0.2894865525672371
154763,"public Iterable<RelationshipData> getMoreRelationships(int nodeId,RelationshipChainPosition position){
  int nextRel=position.getNextRecord();
  List<RelationshipData> rels=new ArrayList<RelationshipData>();
  for (int i=0; i < getRelGrabSize() && nextRel != Record.NO_NEXT_RELATIONSHIP.intValue(); i++) {
    RelationshipRecord relRecord=getRelationshipRecord(nextRel);
    if (relRecord == null) {
      relRecord=getRelationshipStore().getChainRecord(nextRel);
    }
    if (relRecord == null) {
      position.setNextRecord(Record.NO_NEXT_RELATIONSHIP.intValue());
      return rels;
    }
    int firstNode=relRecord.getFirstNode();
    int secondNode=relRecord.getSecondNode();
    if (relRecord.inUse() && !relRecord.isCreated()) {
      rels.add(new RelationshipData(relRecord.getId(),firstNode,secondNode,relRecord.getType()));
    }
 else {
      i--;
    }
    if (firstNode == nodeId) {
      nextRel=relRecord.getFirstNextRel();
    }
 else     if (secondNode == nodeId) {
      nextRel=relRecord.getSecondNextRel();
    }
 else {
      throw new InvalidRecordException(""String_Node_Str"" + nodeId + ""String_Node_Str""+ firstNode+ ""String_Node_Str""+ secondNode+ ""String_Node_Str"");
    }
  }
  position.setNextRecord(nextRel);
  return rels;
}","public Iterable<RelationshipData> getMoreRelationships(int nodeId,RelationshipChainPosition position){
  int nextRel=position.getNextRecord();
  List<RelationshipData> rels=new ArrayList<RelationshipData>();
  for (int i=0; i < getRelGrabSize() && nextRel != Record.NO_NEXT_RELATIONSHIP.intValue(); i++) {
    RelationshipRecord relRecord=getRelationshipStore().getChainRecord(nextRel);
    if (relRecord == null) {
      position.setNextRecord(Record.NO_NEXT_RELATIONSHIP.intValue());
      return rels;
    }
    int firstNode=relRecord.getFirstNode();
    int secondNode=relRecord.getSecondNode();
    if (relRecord.inUse()) {
      rels.add(new RelationshipData(relRecord.getId(),firstNode,secondNode,relRecord.getType()));
    }
 else {
      i--;
    }
    if (firstNode == nodeId) {
      nextRel=relRecord.getFirstNextRel();
    }
 else     if (secondNode == nodeId) {
      nextRel=relRecord.getSecondNextRel();
    }
 else {
      throw new InvalidRecordException(""String_Node_Str"" + nodeId + ""String_Node_Str""+ firstNode+ ""String_Node_Str""+ secondNode+ ""String_Node_Str"");
    }
  }
  position.setNextRecord(nextRel);
  return rels;
}",0.9545644018340976
154764,"private void deleteRel2(int rel,int prop1,int prop2,int prop3,int firstNode,int secondNode,int relType) throws IOException {
  ArrayMap<Integer,PropertyData> props=rStore.getProperties(rel,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-2),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(true),data.getValue());
      rStore.removeProperty(rel,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(2,rStore.getProperties(rel,false).size());
  RelationshipData relData=rStore.getRelationship(rel);
  assertEquals(firstNode,relData.firstNode());
  assertEquals(secondNode,relData.secondNode());
  assertEquals(relType,relData.relationshipType());
  rStore.deleteRelationship(rel);
  RelationshipChainPosition firstPos=rStore.getRelationshipChainPosition(firstNode);
  Iterator<RelationshipData> first=rStore.getMoreRelationships(firstNode,firstPos).iterator();
  RelationshipChainPosition secondPos=rStore.getRelationshipChainPosition(secondNode);
  Iterator<RelationshipData> second=rStore.getMoreRelationships(secondNode,secondPos).iterator();
  assertTrue(!first.hasNext());
  assertTrue(!second.hasNext());
}","private void deleteRel2(int rel,int prop1,int prop2,int prop3,int firstNode,int secondNode,int relType) throws IOException {
  ArrayMap<Integer,PropertyData> props=rStore.getProperties(rel,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-2),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(true),data.getValue());
      rStore.removeProperty(rel,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(3,rStore.getProperties(rel,false).size());
  RelationshipData relData=rStore.getRelationship(rel);
  assertEquals(firstNode,relData.firstNode());
  assertEquals(secondNode,relData.secondNode());
  assertEquals(relType,relData.relationshipType());
  rStore.deleteRelationship(rel);
  RelationshipChainPosition firstPos=rStore.getRelationshipChainPosition(firstNode);
  Iterator<RelationshipData> first=rStore.getMoreRelationships(firstNode,firstPos).iterator();
  RelationshipChainPosition secondPos=rStore.getRelationshipChainPosition(secondNode);
  Iterator<RelationshipData> second=rStore.getMoreRelationships(secondNode,secondPos).iterator();
  assertTrue(first.hasNext());
  assertTrue(second.hasNext());
}",0.9988833054159688
154765,"private void deleteRel1(int rel,int prop1,int prop2,int prop3,int firstNode,int secondNode,int relType) throws IOException {
  ArrayMap<Integer,PropertyData> props=rStore.getProperties(rel,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-1),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(false),data.getValue());
      rStore.removeProperty(rel,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(2,rStore.getProperties(rel,false).size());
  RelationshipData relData=rStore.getRelationship(rel);
  assertEquals(firstNode,relData.firstNode());
  assertEquals(secondNode,relData.secondNode());
  assertEquals(relType,relData.relationshipType());
  rStore.deleteRelationship(rel);
  RelationshipChainPosition firstPos=rStore.getRelationshipChainPosition(firstNode);
  Iterator<RelationshipData> first=rStore.getMoreRelationships(firstNode,firstPos).iterator();
  first.next();
  RelationshipChainPosition secondPos=rStore.getRelationshipChainPosition(secondNode);
  Iterator<RelationshipData> second=rStore.getMoreRelationships(secondNode,secondPos).iterator();
  second.next();
  assertTrue(!first.hasNext());
  assertTrue(!second.hasNext());
}","private void deleteRel1(int rel,int prop1,int prop2,int prop3,int firstNode,int secondNode,int relType) throws IOException {
  ArrayMap<Integer,PropertyData> props=rStore.getProperties(rel,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-1),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(false),data.getValue());
      rStore.removeProperty(rel,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(3,rStore.getProperties(rel,false).size());
  RelationshipData relData=rStore.getRelationship(rel);
  assertEquals(firstNode,relData.firstNode());
  assertEquals(secondNode,relData.secondNode());
  assertEquals(relType,relData.relationshipType());
  rStore.deleteRelationship(rel);
  RelationshipChainPosition firstPos=rStore.getRelationshipChainPosition(firstNode);
  Iterator<RelationshipData> first=rStore.getMoreRelationships(firstNode,firstPos).iterator();
  first.next();
  RelationshipChainPosition secondPos=rStore.getRelationshipChainPosition(secondNode);
  Iterator<RelationshipData> second=rStore.getMoreRelationships(secondNode,secondPos).iterator();
  second.next();
  assertTrue(first.hasNext());
  assertTrue(second.hasNext());
}",0.9989041095890412
154766,"@Test public void testRels1() throws Exception {
  initializeStores();
  startTx();
  int relType1=ds.nextId(RelationshipType.class);
  relTypeStore.addRelationshipType(relType1,""String_Node_Str"");
  int nodeIds[]=new int[3];
  for (int i=0; i < 3; i++) {
    nodeIds[i]=ds.nextId(Node.class);
    nStore.createNode(nodeIds[i]);
    nStore.addProperty(nodeIds[i],pStore.nextId(),index(""String_Node_Str""),new Integer(10 - i));
  }
  for (int i=0; i < 2; i++) {
    rStore.createRelationship(ds.nextId(Relationship.class),nodeIds[i],nodeIds[i + 1],relType1);
  }
  commitTx();
  startTx();
  for (int i=0; i < 3; i++) {
    RelationshipChainPosition pos=rStore.getRelationshipChainPosition(nodeIds[i]);
    for (    RelationshipData rel : rStore.getMoreRelationships(nodeIds[i],pos)) {
      rStore.deleteRelationship(rel.getId());
    }
    nStore.deleteNode(nodeIds[i]);
  }
  commitTx();
  ds.close();
}","@Test public void testRels1() throws Exception {
  initializeStores();
  startTx();
  int relType1=ds.nextId(RelationshipType.class);
  relTypeStore.addRelationshipType(relType1,""String_Node_Str"");
  int nodeIds[]=new int[3];
  for (int i=0; i < 3; i++) {
    nodeIds[i]=ds.nextId(Node.class);
    nStore.createNode(nodeIds[i]);
    nStore.addProperty(nodeIds[i],pStore.nextId(),index(""String_Node_Str""),new Integer(10 - i));
  }
  for (int i=0; i < 2; i++) {
    rStore.createRelationship(ds.nextId(Relationship.class),nodeIds[i],nodeIds[i + 1],relType1);
  }
  commitTx();
  startTx();
  for (int i=0; i < 3; i+=2) {
    RelationshipChainPosition pos=rStore.getRelationshipChainPosition(nodeIds[i]);
    for (    RelationshipData rel : rStore.getMoreRelationships(nodeIds[i],pos)) {
      rStore.deleteRelationship(rel.getId());
    }
    nStore.deleteNode(nodeIds[i]);
  }
  commitTx();
  ds.close();
}",0.9983416252072967
154767,"private void deleteNode1(int node,int prop1,int prop2,int prop3) throws IOException {
  ArrayMap<Integer,PropertyData> props=nStore.getProperties(node,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-1),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(false),data.getValue());
      nStore.removeProperty(node,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(2,nStore.getProperties(node,false).size());
  RelationshipChainPosition pos=rStore.getRelationshipChainPosition(node);
  Iterator<RelationshipData> rels=rStore.getMoreRelationships(node,pos).iterator();
  assertTrue(!rels.hasNext());
  nStore.deleteNode(node);
}","private void deleteNode1(int node,int prop1,int prop2,int prop3) throws IOException {
  ArrayMap<Integer,PropertyData> props=nStore.getProperties(node,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-1),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(false),data.getValue());
      nStore.removeProperty(node,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(3,nStore.getProperties(node,false).size());
  RelationshipChainPosition pos=rStore.getRelationshipChainPosition(node);
  Iterator<RelationshipData> rels=rStore.getMoreRelationships(node,pos).iterator();
  assertTrue(rels.hasNext());
  nStore.deleteNode(node);
}",0.9988510149368058
154768,"private void deleteNode2(int node,int prop1,int prop2,int prop3) throws IOException {
  ArrayMap<Integer,PropertyData> props=nStore.getProperties(node,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-2),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(true),data.getValue());
      nStore.removeProperty(node,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(2,nStore.getProperties(node,false).size());
  RelationshipChainPosition pos=rStore.getRelationshipChainPosition(node);
  Iterator<RelationshipData> rels=rStore.getMoreRelationships(node,pos).iterator();
  assertTrue(!rels.hasNext());
  nStore.deleteNode(node);
}","private void deleteNode2(int node,int prop1,int prop2,int prop3) throws IOException {
  ArrayMap<Integer,PropertyData> props=nStore.getProperties(node,false);
  int count=0;
  for (  int keyId : props.keySet()) {
    int id=props.get(keyId).getId();
    PropertyRecord record=pStore.getRecord(id);
    PropertyData data=new PropertyData(id,getValue(record));
    if (data.getId() == prop1) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(""String_Node_Str"",data.getValue());
    }
 else     if (data.getId() == prop2) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Integer(-2),data.getValue());
    }
 else     if (data.getId() == prop3) {
      assertEquals(""String_Node_Str"",MyPropertyIndex.getIndexFor(keyId).getKey());
      assertEquals(new Boolean(true),data.getValue());
      nStore.removeProperty(node,prop3);
    }
 else {
      throw new IOException();
    }
    count++;
  }
  assertEquals(3,count);
  assertEquals(3,nStore.getProperties(node,false).size());
  RelationshipChainPosition pos=rStore.getRelationshipChainPosition(node);
  Iterator<RelationshipData> rels=rStore.getMoreRelationships(node,pos).iterator();
  assertTrue(rels.hasNext());
  nStore.deleteNode(node);
}",0.9988501341510158
154769,"public Node getNodeById(long id){
  return new ReadOnlyNodeProxy(getNodeById(id));
}","public Node getNodeById(long id){
  return new ReadOnlyNodeProxy(actual.getNodeById(id));
}",0.96
154770,"public Node getReferenceNode(){
  return new ReadOnlyNodeProxy(getReferenceNode());
}","public Node getReferenceNode(){
  return new ReadOnlyNodeProxy(actual.getReferenceNode());
}",0.96045197740113
154771,"protected void possiblyGrabDefaultVariableFromServer(String key,Serializable defaultValue){
  try {
    if (this.session().get(key) == null) {
      Serializable value=this.getServer().getProperty(key);
      if (value == null) {
        value=defaultValue;
      }
      if (value != null) {
        this.session().set(key,value);
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
}","protected void possiblyGrabDefaultVariableFromServer(String key,Serializable defaultValue){
  try {
    if (this.session().get(key) == null) {
      grabbedKeysFromServer.add(key);
      Serializable value=this.getServer().getProperty(key);
      if (value == null) {
        value=defaultValue;
      }
      if (value != null) {
        this.session().set(key,value);
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
}",0.9568181818181818
154772,"public ShellServer getServer(){
  boolean shouldTryToReconnect=this.server == null;
  try {
    if (!shouldTryToReconnect) {
      this.server.welcome();
    }
  }
 catch (  RemoteException e) {
    shouldTryToReconnect=true;
  }
  Exception originException=null;
  if (shouldTryToReconnect) {
    this.server=null;
    try {
      this.server=findRemoteServer();
      getOutput().println(""String_Node_Str"");
    }
 catch (    ShellException ee) {
      originException=ee;
    }
catch (    RemoteException ee) {
      originException=ee;
    }
  }
  if (this.server == null) {
    throw new RuntimeException(""String_Node_Str"" + originException.getMessage(),originException);
  }
  return this.server;
}","public ShellServer getServer(){
  boolean shouldTryToReconnect=this.server == null;
  try {
    if (!shouldTryToReconnect) {
      this.server.welcome();
    }
  }
 catch (  RemoteException e) {
    shouldTryToReconnect=true;
  }
  Exception originException=null;
  if (shouldTryToReconnect) {
    this.server=null;
    try {
      this.server=findRemoteServer();
      getOutput().println(""String_Node_Str"");
      regrabVariablesFromServer();
    }
 catch (    ShellException ee) {
      originException=ee;
    }
catch (    RemoteException ee) {
      originException=ee;
    }
  }
  if (this.server == null) {
    throw new RuntimeException(""String_Node_Str"" + originException.getMessage(),originException);
  }
  return this.server;
}",0.9757449757449758
154773,"public boolean isStopNode(TraversalPosition position){
  Relationship rel=position.lastRelationshipTraversed();
  return rel != null && rel.getType() == MyRelTypes.TEST_TRAVERSAL;
}","public boolean isStopNode(TraversalPosition position){
  Relationship rel=position.lastRelationshipTraversed();
  return rel != null && rel.isType(MyRelTypes.TEST_TRAVERSAL);
}",0.969187675070028
154774,"@Test public void testStopOnLastRelationship() throws Exception {
  Node root=this.buildIseTreePopulation();
  RelationshipType[] traversableRels=new RelationshipType[]{MyRelTypes.TEST,MyRelTypes.TEST_TRAVERSAL};
  StopEvaluator stopEvaluator=new StopEvaluator(){
    public boolean isStopNode(    TraversalPosition position){
      Relationship rel=position.lastRelationshipTraversed();
      return rel != null && rel.getType() == MyRelTypes.TEST_TRAVERSAL;
    }
  }
;
  Traverser traverser=root.traverse(BREADTH_FIRST,stopEvaluator,ReturnableEvaluator.ALL,traversableRels[0],Direction.BOTH,traversableRels[1],Direction.BOTH);
  try {
    this.assertLevelsOfNodes(traverser,new String[][]{new String[]{""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}});
    assertTrue(""String_Node_Str"",traverser.iterator().hasNext() == false);
  }
 catch (  java.util.NoSuchElementException nsee) {
    fail(""String_Node_Str"");
  }
 finally {
    this.deleteNodeTreeRecursively(root,0);
  }
}","@Test public void testStopOnLastRelationship() throws Exception {
  Node root=this.buildIseTreePopulation();
  RelationshipType[] traversableRels=new RelationshipType[]{MyRelTypes.TEST,MyRelTypes.TEST_TRAVERSAL};
  StopEvaluator stopEvaluator=new StopEvaluator(){
    public boolean isStopNode(    TraversalPosition position){
      Relationship rel=position.lastRelationshipTraversed();
      return rel != null && rel.isType(MyRelTypes.TEST_TRAVERSAL);
    }
  }
;
  Traverser traverser=root.traverse(BREADTH_FIRST,stopEvaluator,ReturnableEvaluator.ALL,traversableRels[0],Direction.BOTH,traversableRels[1],Direction.BOTH);
  try {
    this.assertLevelsOfNodes(traverser,new String[][]{new String[]{""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}});
    assertTrue(""String_Node_Str"",traverser.iterator().hasNext() == false);
  }
 catch (  java.util.NoSuchElementException nsee) {
    fail(""String_Node_Str"");
  }
 finally {
    this.deleteNodeTreeRecursively(root,0);
  }
}",0.9954375777685608
154775,"public static Long readLong(ReadableByteChannel channel,ByteBuffer buffer) throws IOException {
  buffer.clear();
  buffer.limit(8);
  int read=channel.read(buffer);
  if (read < 8) {
    return null;
  }
  buffer.flip();
  return buffer.getLong();
}","public static Long readLong(ReadableByteChannel channel,ByteBuffer buffer) throws IOException {
  return readAndFlip(channel,buffer,8) ? buffer.getLong() : null;
}",0.6876513317191283
154776,"public static Integer readInt(ReadableByteChannel channel,ByteBuffer buffer) throws IOException {
  buffer.clear();
  buffer.limit(4);
  int read=channel.read(buffer);
  if (read < 4) {
    return null;
  }
  buffer.flip();
  return buffer.getInt();
}","public static Integer readInt(ReadableByteChannel channel,ByteBuffer buffer) throws IOException {
  return readAndFlip(channel,buffer,4) ? buffer.getInt() : null;
}",0.689156626506024
154777,"static XaCommand readCommand(ReadableByteChannel channel,ByteBuffer buffer,LuceneDataSource dataSource) throws IOException {
  buffer.clear();
  buffer.limit(1);
  if (channel.read(buffer) != buffer.limit()) {
    return null;
  }
  buffer.flip();
  byte commandType=buffer.get();
  if (commandType == CREATE_INDEX_COMMAND) {
    buffer.clear();
    String name=PrimitiveUtils.readLengthAndString(channel,buffer);
    if (name == null) {
      return null;
    }
    int size=PrimitiveUtils.readInt(channel,buffer);
    Map<String,String> config=new HashMap<String,String>();
    for (int i=0; i < size; i++) {
      String key=PrimitiveUtils.readLengthAndString(channel,buffer);
      String value=PrimitiveUtils.readLengthAndString(channel,buffer);
      if (key == null || value == null) {
        return null;
      }
      config.put(key,value);
    }
    return new CreateIndexCommand(name,config);
  }
 else {
    buffer.clear();
    buffer.limit(18);
    if (channel.read(buffer) != buffer.limit()) {
      return null;
    }
    buffer.flip();
    byte cls=buffer.get();
    EntityType entityType=null;
    if (cls == NODE) {
      entityType=dataSource.nodeEntityType;
    }
 else     if (cls == RELATIONSHIP) {
      entityType=dataSource.relationshipEntityType;
    }
 else {
      return null;
    }
    int indexNameLength=buffer.getInt();
    long entityId=buffer.getLong();
    int keyCharLength=buffer.getInt();
    byte valueType=buffer.get();
    String indexName=PrimitiveUtils.readString(channel,buffer,indexNameLength);
    if (indexName == null) {
      return null;
    }
    String key=PrimitiveUtils.readString(channel,buffer,keyCharLength);
    if (key == null) {
      return null;
    }
    Object value=null;
    if (valueType >= VALUE_TYPE_INT && valueType <= VALUE_TYPE_DOUBLE) {
switch (valueType) {
case VALUE_TYPE_INT:
        value=buffer.getInt();
      break;
case VALUE_TYPE_LONG:
    value=buffer.getLong();
  break;
case VALUE_TYPE_FLOAT:
value=buffer.getFloat();
break;
case VALUE_TYPE_DOUBLE:
value=buffer.getDouble();
break;
}
}
 else if (valueType == VALUE_TYPE_STRING) {
value=PrimitiveUtils.readLengthAndString(channel,buffer);
}
if (value == null) {
return null;
}
Long startNodeId=null;
Long endNodeId=null;
if (commandType == ADD_COMMAND && cls == RELATIONSHIP) {
startNodeId=PrimitiveUtils.readLong(channel,buffer);
endNodeId=PrimitiveUtils.readLong(channel,buffer);
if (startNodeId == null || endNodeId == null) {
return null;
}
}
IndexIdentifier identifier=new IndexIdentifier(cls,entityType,indexName,dataSource.indexStore.get(indexName));
switch (commandType) {
case ADD_COMMAND:
return cls == NODE ? new AddCommand(identifier,cls,entityId,key,value) : new AddRelationshipCommand(identifier,cls,new RelationshipId(entityId,startNodeId,endNodeId),key,value);
case REMOVE_COMMAND:
return new RemoveCommand(identifier,cls,entityId,key,value);
case CLEAR_COMMAND:
return new ClearCommand(identifier);
default :
throw new IOException(""String_Node_Str"" + commandType + ""String_Node_Str"");
}
}
}","static XaCommand readCommand(ReadableByteChannel channel,ByteBuffer buffer,LuceneDataSource dataSource) throws IOException {
  buffer.clear();
  buffer.limit(1);
  if (channel.read(buffer) != buffer.limit()) {
    return null;
  }
  buffer.flip();
  byte commandType=buffer.get();
  if (commandType == CREATE_INDEX_COMMAND) {
    buffer.clear();
    String name=PrimitiveUtils.readLengthAndString(channel,buffer);
    if (name == null) {
      return null;
    }
    int size=PrimitiveUtils.readInt(channel,buffer);
    Map<String,String> config=new HashMap<String,String>();
    for (int i=0; i < size; i++) {
      String key=PrimitiveUtils.readLengthAndString(channel,buffer);
      String value=PrimitiveUtils.readLengthAndString(channel,buffer);
      if (key == null || value == null) {
        return null;
      }
      config.put(key,value);
    }
    return new CreateIndexCommand(name,config);
  }
 else {
    buffer.clear();
    buffer.limit(18);
    if (channel.read(buffer) != buffer.limit()) {
      return null;
    }
    buffer.flip();
    byte cls=buffer.get();
    EntityType entityType=null;
    if (cls == NODE) {
      entityType=dataSource.nodeEntityType;
    }
 else     if (cls == RELATIONSHIP) {
      entityType=dataSource.relationshipEntityType;
    }
 else {
      return null;
    }
    int indexNameLength=buffer.getInt();
    long entityId=buffer.getLong();
    int keyCharLength=buffer.getInt();
    byte valueType=buffer.get();
    String indexName=PrimitiveUtils.readString(channel,buffer,indexNameLength);
    if (indexName == null) {
      return null;
    }
    String key=PrimitiveUtils.readString(channel,buffer,keyCharLength);
    if (key == null) {
      return null;
    }
    Object value=null;
    if (valueType >= VALUE_TYPE_INT && valueType <= VALUE_TYPE_DOUBLE) {
switch (valueType) {
case VALUE_TYPE_INT:
        value=PrimitiveUtils.readInt(channel,buffer);
      break;
case VALUE_TYPE_LONG:
    value=PrimitiveUtils.readLong(channel,buffer);
  break;
case VALUE_TYPE_FLOAT:
value=PrimitiveUtils.readFloat(channel,buffer);
break;
case VALUE_TYPE_DOUBLE:
value=PrimitiveUtils.readDouble(channel,buffer);
break;
}
}
 else if (valueType == VALUE_TYPE_STRING) {
value=PrimitiveUtils.readLengthAndString(channel,buffer);
}
if (value == null) {
return null;
}
Long startNodeId=null;
Long endNodeId=null;
if (commandType == ADD_COMMAND && cls == RELATIONSHIP) {
startNodeId=PrimitiveUtils.readLong(channel,buffer);
endNodeId=PrimitiveUtils.readLong(channel,buffer);
if (startNodeId == null || endNodeId == null) {
return null;
}
}
IndexIdentifier identifier=new IndexIdentifier(cls,entityType,indexName,dataSource.indexStore.get(indexName));
switch (commandType) {
case ADD_COMMAND:
return cls == NODE ? new AddCommand(identifier,cls,entityId,key,value) : new AddRelationshipCommand(identifier,cls,new RelationshipId(entityId,startNodeId,endNodeId),key,value);
case REMOVE_COMMAND:
return new RemoveCommand(identifier,cls,entityId,key,value);
case CLEAR_COMMAND:
return new ClearCommand(identifier);
default :
throw new IOException(""String_Node_Str"" + commandType + ""String_Node_Str"");
}
}
}",0.9721592748462284
154778,"/** 
 * Constructs this data source.
 * @param params XA parameters.
 * @throws InstantiationException if the data source couldn't beinstantiated
 */
public LuceneDataSource(Map<Object,Object> params) throws InstantiationException {
  super(params);
  caching=new Cache();
  String storeDir=(String)params.get(""String_Node_Str"");
  this.baseStorePath=getStoreDir(storeDir);
  cleanWriteLocks(baseStorePath);
  this.indexStore=new IndexStore(storeDir);
  this.store=newIndexStore(storeDir);
  this.typeCache=new IndexTypeCache();
  boolean isReadOnly=params.containsKey(""String_Node_Str"") ? (Boolean)params.get(""String_Node_Str"") : false;
  if (!isReadOnly) {
    XaCommandFactory cf=new LuceneCommandFactory();
    XaTransactionFactory tf=new LuceneTransactionFactory(store);
    xaContainer=XaContainer.create(this.baseStorePath + ""String_Node_Str"",cf,tf,params);
    try {
      xaContainer.openLogicalLog();
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"" + this.baseStorePath,e);
    }
    xaContainer.getLogicalLog().setKeepLogs(shouldKeepLog((String)params.get(Config.KEEP_LOGICAL_LOGS),DEFAULT_NAME));
    setLogicalLogAtCreationTime(xaContainer.getLogicalLog());
  }
 else {
    xaContainer=null;
  }
  nodeEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      return IndexType.newBaseDocument((Long)entityId);
    }
    public Class<?> getType(){
      return Node.class;
    }
  }
;
  relationshipEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      RelationshipId relId=(RelationshipId)entityId;
      Document doc=IndexType.newBaseDocument(relId.id);
      doc.add(new Field(LuceneIndex.KEY_START_NODE_ID,""String_Node_Str"" + relId.startNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      doc.add(new Field(LuceneIndex.KEY_END_NODE_ID,""String_Node_Str"" + relId.endNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      return doc;
    }
    public Class<?> getType(){
      return Relationship.class;
    }
  }
;
}","/** 
 * Constructs this data source.
 * @param params XA parameters.
 * @throws InstantiationException if the data source couldn't beinstantiated
 */
public LuceneDataSource(Map<Object,Object> params) throws InstantiationException {
  super(params);
  caching=new Cache();
  String storeDir=(String)params.get(""String_Node_Str"");
  this.baseStorePath=getStoreDir(storeDir);
  cleanWriteLocks(baseStorePath);
  this.indexStore=new IndexStore(storeDir);
  this.store=newIndexStore(storeDir);
  this.typeCache=new IndexTypeCache();
  boolean isReadOnly=params.containsKey(""String_Node_Str"") ? (Boolean)params.get(""String_Node_Str"") : false;
  nodeEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      return IndexType.newBaseDocument((Long)entityId);
    }
    public Class<?> getType(){
      return Node.class;
    }
  }
;
  relationshipEntityType=new EntityType(){
    public Document newDocument(    Object entityId){
      RelationshipId relId=(RelationshipId)entityId;
      Document doc=IndexType.newBaseDocument(relId.id);
      doc.add(new Field(LuceneIndex.KEY_START_NODE_ID,""String_Node_Str"" + relId.startNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      doc.add(new Field(LuceneIndex.KEY_END_NODE_ID,""String_Node_Str"" + relId.endNode,Store.YES,org.apache.lucene.document.Field.Index.NOT_ANALYZED));
      return doc;
    }
    public Class<?> getType(){
      return Relationship.class;
    }
  }
;
  if (!isReadOnly) {
    XaCommandFactory cf=new LuceneCommandFactory();
    XaTransactionFactory tf=new LuceneTransactionFactory(store);
    xaContainer=XaContainer.create(this.baseStorePath + ""String_Node_Str"",cf,tf,params);
    try {
      xaContainer.openLogicalLog();
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"" + this.baseStorePath,e);
    }
    xaContainer.getLogicalLog().setKeepLogs(shouldKeepLog((String)params.get(Config.KEEP_LOGICAL_LOGS),DEFAULT_NAME));
    setLogicalLogAtCreationTime(xaContainer.getLogicalLog());
  }
 else {
    xaContainer=null;
  }
}",0.6002886002886003
154779,"@Override protected void doCommit(){
  dataSource.getWriteLock();
  try {
    for (    Map.Entry<IndexIdentifier,CommandList> entry : this.commandMap.entrySet()) {
      IndexIdentifier identifier=entry.getKey();
      IndexType type=identifier == LuceneCommand.CreateIndexCommand.FAKE_IDENTIFIER ? null : dataSource.getType(identifier);
      IndexWriter writer=null;
      IndexSearcher searcher=null;
      CommandList commandList=entry.getValue();
      Map<Long,DocumentContext> documents=new HashMap<Long,DocumentContext>();
      for (      LuceneCommand command : commandList.commands) {
        if (command instanceof CreateIndexCommand) {
          CreateIndexCommand createCommand=(CreateIndexCommand)command;
          dataSource.indexStore.setIfNecessary(createCommand.getName(),createCommand.getConfig());
          continue;
        }
        if (writer == null) {
          writer=dataSource.getIndexWriter(identifier);
          writer.setMaxBufferedDocs(commandList.addCount + 100);
          writer.setMaxBufferedDeleteTerms(commandList.removeCount + 100);
          searcher=dataSource.getIndexSearcher(identifier).getSearcher();
        }
        if (command instanceof ClearCommand) {
          documents.clear();
          dataSource.closeWriter(writer);
          writer=null;
          dataSource.deleteIndex(identifier);
          dataSource.invalidateCache(identifier);
          continue;
        }
        Object entityId=command.entityId;
        long id=entityId instanceof Long ? (Long)entityId : ((RelationshipId)entityId).id;
        DocumentContext context=documents.get(id);
        if (context == null) {
          Document document=LuceneDataSource.findDocument(type,searcher,id);
          context=document == null ? new DocumentContext(identifier.entityType.newDocument(entityId),false,id) : new DocumentContext(document,true,id);
          documents.put(id,context);
        }
        String key=command.key;
        Object value=command.value;
        if (command instanceof AddCommand || command instanceof AddRelationshipCommand) {
          type.addToDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else         if (command instanceof RemoveCommand) {
          type.removeFromDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + command + ""String_Node_Str""+ command.getClass());
        }
      }
      applyDocuments(writer,type,documents);
      if (writer != null) {
        dataSource.closeWriter(writer);
      }
      dataSource.invalidateIndexSearcher(identifier);
    }
    closeTxData();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    dataSource.releaseWriteLock();
  }
}","@Override protected void doCommit(){
  dataSource.getWriteLock();
  try {
    for (    Map.Entry<IndexIdentifier,CommandList> entry : this.commandMap.entrySet()) {
      if (entry.getValue().isEmpty()) {
        continue;
      }
      boolean isRecovery=entry.getValue().isRecovery();
      IndexIdentifier identifier=entry.getKey();
      IndexType type=identifier == LuceneCommand.CreateIndexCommand.FAKE_IDENTIFIER ? null : dataSource.getType(identifier);
      IndexWriter writer=null;
      IndexSearcher searcher=null;
      CommandList commandList=entry.getValue();
      Map<Long,DocumentContext> documents=new HashMap<Long,DocumentContext>();
      for (      LuceneCommand command : commandList.commands) {
        if (command instanceof CreateIndexCommand) {
          CreateIndexCommand createCommand=(CreateIndexCommand)command;
          dataSource.indexStore.setIfNecessary(createCommand.getName(),createCommand.getConfig());
          continue;
        }
        if (writer == null) {
          if (isRecovery) {
            writer=dataSource.getRecoveryIndexWriter(identifier);
          }
 else {
            writer=dataSource.getIndexWriter(identifier);
            writer.setMaxBufferedDocs(commandList.addCount + 100);
            writer.setMaxBufferedDeleteTerms(commandList.removeCount + 100);
          }
          searcher=dataSource.getIndexSearcher(identifier).getSearcher();
        }
        if (command instanceof ClearCommand) {
          documents.clear();
          dataSource.closeWriter(writer);
          writer=null;
          dataSource.deleteIndex(identifier);
          dataSource.invalidateCache(identifier);
          if (isRecovery) {
            dataSource.removeRecoveryIndexWriter(identifier);
          }
          continue;
        }
        Object entityId=command.entityId;
        long id=entityId instanceof Long ? (Long)entityId : ((RelationshipId)entityId).id;
        DocumentContext context=documents.get(id);
        if (context == null) {
          Document document=LuceneDataSource.findDocument(type,searcher,id);
          context=document == null ? new DocumentContext(identifier.entityType.newDocument(entityId),false,id) : new DocumentContext(document,true,id);
          documents.put(id,context);
        }
        String key=command.key;
        Object value=command.value;
        if (command instanceof AddCommand || command instanceof AddRelationshipCommand) {
          type.addToDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else         if (command instanceof RemoveCommand) {
          type.removeFromDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + command + ""String_Node_Str""+ command.getClass());
        }
      }
      applyDocuments(writer,type,documents);
      if (writer != null && !isRecovery) {
        dataSource.closeWriter(writer);
        dataSource.invalidateIndexSearcher(identifier);
      }
    }
    closeTxData();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    dataSource.releaseWriteLock();
  }
}",0.9365000824674252
154780,"public synchronized void applyTransaction(ReadableByteChannel byteChannel) throws IOException {
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndWriteAndApplyEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  scanIsComplete=true;
}","public synchronized void applyTransaction(ReadableByteChannel byteChannel) throws IOException {
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  long startEntryPosition=writeBuffer.getFileChannelPosition();
  while (logApplier.readAndWriteAndApplyEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  scanIsComplete=true;
  LogEntry.Start startEntry=logApplier.startEntry;
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"");
  }
  startEntry.setStartPosition(startEntryPosition);
  cacheTxStartPosition(logApplier.commitEntry.getTxId(),startEntry);
}",0.7016205910390848
154781,"public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId,int masterId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  long startEntryPosition=writeBuffer.getFileChannelPosition();
  ;
  while (logApplier.readAndWriteAndApplyEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start startEntry=logApplier.startEntry;
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"");
  }
  startEntry.setStartPosition(startEntryPosition);
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(xidIdent,nextTxId,masterId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=startEntry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
    LogEntry doneEntry=new LogEntry.Done(startEntry.getIdentifier());
    LogIoUtils.writeLogEntry(doneEntry,writeBuffer);
    xidIdentMap.remove(startEntry.getIdentifier());
    recoveredTxMap.remove(startEntry.getIdentifier());
    cacheTxStartPosition(nextTxId,startEntry);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  scanIsComplete=true;
  msgLog.logMessage(""String_Node_Str"" + nextTxId);
}","public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId,int masterId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  long startEntryPosition=writeBuffer.getFileChannelPosition();
  while (logApplier.readAndWriteAndApplyEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start startEntry=logApplier.startEntry;
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"");
  }
  startEntry.setStartPosition(startEntryPosition);
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(xidIdent,nextTxId,masterId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=startEntry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
    LogEntry doneEntry=new LogEntry.Done(startEntry.getIdentifier());
    LogIoUtils.writeLogEntry(doneEntry,writeBuffer);
    xidIdentMap.remove(startEntry.getIdentifier());
    recoveredTxMap.remove(startEntry.getIdentifier());
    cacheTxStartPosition(nextTxId,startEntry);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  scanIsComplete=true;
  msgLog.logMessage(""String_Node_Str"" + nextTxId);
}",0.9987812309567335
154782,"boolean readAndWriteAndApplyEntry(int newXidIdentifier) throws IOException {
  LogEntry entry=LogIoUtils.readEntry(buffer,byteChannel,cf);
  if (entry != null) {
    entry.setIdentifier(newXidIdentifier);
    if (entry instanceof LogEntry.Commit) {
      msgLog.logMessage(""String_Node_Str"" + ((LogEntry.Commit)entry).getTxId());
    }
 else     if (entry instanceof LogEntry.Start) {
      startEntry=(LogEntry.Start)entry;
    }
    LogIoUtils.writeLogEntry(entry,writeBuffer);
    applyEntry(entry);
    return true;
  }
  return false;
}","boolean readAndWriteAndApplyEntry(int newXidIdentifier) throws IOException {
  LogEntry entry=LogIoUtils.readEntry(buffer,byteChannel,cf);
  if (entry != null) {
    entry.setIdentifier(newXidIdentifier);
    if (entry instanceof LogEntry.Commit) {
      commitEntry=(LogEntry.Commit)entry;
      msgLog.logMessage(""String_Node_Str"" + ((LogEntry.Commit)entry).getTxId());
    }
 else     if (entry instanceof LogEntry.Start) {
      startEntry=(LogEntry.Start)entry;
    }
    LogIoUtils.writeLogEntry(entry,writeBuffer);
    applyEntry(entry);
    return true;
  }
  return false;
}",0.9626334519572952
154783,"private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  LogEntry entry;
  while ((entry=LogIoUtils.readEntry(buffer,log,cf)) != null && logEntryList == null) {
    if (entry instanceof LogEntry.Start) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(entry);
      transactions.put(entry.getIdentifier(),list);
    }
 else     if (entry instanceof LogEntry.Commit) {
      if (((LogEntry.Commit)entry).getTxId() == txId) {
        logEntryList=transactions.get(entry.getIdentifier());
        logEntryList.add(entry);
      }
 else {
        transactions.remove(entry.getIdentifier());
      }
    }
 else     if (entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare) {
      transactions.get(entry.getIdentifier()).add(entry);
    }
 else     if (entry instanceof LogEntry.Done) {
      transactions.remove(entry.getIdentifier());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + entry);
    }
  }
  if (logEntryList == null) {
    msgLog.logMessage(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion);
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str"");
  }
  logEntryList.add(new LogEntry.Done(logEntryList.get(0).getIdentifier()));
  return logEntryList;
}","private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  LogEntry entry;
  while ((entry=LogIoUtils.readEntry(buffer,log,cf)) != null && logEntryList == null) {
    if (entry instanceof LogEntry.Start) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(entry);
      transactions.put(entry.getIdentifier(),list);
    }
 else     if (entry instanceof LogEntry.Commit) {
      if (((LogEntry.Commit)entry).getTxId() == txId) {
        logEntryList=transactions.get(entry.getIdentifier());
        logEntryList.add(entry);
      }
 else {
        transactions.remove(entry.getIdentifier());
      }
    }
 else     if (entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare) {
      transactions.get(entry.getIdentifier()).add(entry);
    }
 else     if (entry instanceof LogEntry.Done) {
      transactions.remove(entry.getIdentifier());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + entry);
    }
  }
  if (logEntryList == null) {
    msgLog.logMessage(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion);
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ ""String_Node_Str""+ this.logVersion+ ""String_Node_Str"");
  }
  logEntryList.add(new LogEntry.Done(logEntryList.get(0).getIdentifier()));
  return logEntryList;
}",0.9816971713810316
154784,"private void applyOnePhaseCommitEntry(LogEntry.OnePhaseCommit commit) throws IOException {
  int identifier=commit.getIdentifier();
  long txId=commit.getTxId();
  LogEntry.Start startEntry=xidIdentMap.get(identifier);
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"" + identifier);
  }
  Xid xid=startEntry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(txId);
    xaRm.injectOnePhaseCommit(xid);
    cacheTxStartPosition(txId,startEntry);
    msgLog.logMessage(""String_Node_Str"" + commit.getTxId());
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
}","private void applyOnePhaseCommitEntry(LogEntry.OnePhaseCommit commit) throws IOException {
  int identifier=commit.getIdentifier();
  long txId=commit.getTxId();
  LogEntry.Start startEntry=xidIdentMap.get(identifier);
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"" + identifier);
  }
  Xid xid=startEntry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(txId);
    xaRm.injectOnePhaseCommit(xid);
    msgLog.logMessage(""String_Node_Str"" + commit.getTxId());
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
}",0.9670498084291188
154785,"private void applyTwoPhaseCommitEntry(LogEntry.TwoPhaseCommit commit) throws IOException {
  int identifier=commit.getIdentifier();
  long txId=commit.getTxId();
  LogEntry.Start startEntry=xidIdentMap.get(identifier);
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"" + identifier);
  }
  Xid xid=startEntry.getXid();
  if (xid == null) {
    throw new IOException(""String_Node_Str"" + identifier);
  }
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(txId);
    xaRm.injectTwoPhaseCommit(xid);
    cacheTxStartPosition(txId,startEntry);
    msgLog.logMessage(""String_Node_Str"" + commit.getTxId());
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
}","private void applyTwoPhaseCommitEntry(LogEntry.TwoPhaseCommit commit) throws IOException {
  int identifier=commit.getIdentifier();
  long txId=commit.getTxId();
  LogEntry.Start startEntry=xidIdentMap.get(identifier);
  if (startEntry == null) {
    throw new IOException(""String_Node_Str"" + identifier);
  }
  Xid xid=startEntry.getXid();
  if (xid == null) {
    throw new IOException(""String_Node_Str"" + identifier);
  }
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(txId);
    xaRm.injectTwoPhaseCommit(xid);
    msgLog.logMessage(""String_Node_Str"" + commit.getTxId());
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
}",0.9708078750848608
154786,"private synchronized void cacheTxStartPosition(long txId,LogEntry.Start startEntry){
  txStartPositionCache.put(txId,new Pair<Long,Long>(logVersion,startEntry.getStartPosition()));
}","private synchronized void cacheTxStartPosition(long txId,LogEntry.Start startEntry){
  if (startEntry.getStartPosition() == -1) {
    throw new RuntimeException(""String_Node_Str"" + startEntry.getStartPosition());
  }
  txStartPositionCache.put(txId,new Pair<Long,Long>(logVersion,startEntry.getStartPosition()));
}",0.7338709677419355
154787,"private void writeOutLogEntryList(List<LogEntry> logEntryList,File txFile,boolean tempWriteOutFirst) throws IOException {
  int identifier=logEntryList.get(0).getIdentifier();
  File tempFile=tempWriteOutFirst ? File.createTempFile(String.valueOf(identifier),""String_Node_Str"") : txFile;
  msgLog.logMessage(""String_Node_Str"" + tempFile);
  FileChannel txLog=new RandomAccessFile(tempFile,""String_Node_Str"").getChannel();
  LogBuffer buf=new DirectMappedLogBuffer(txLog);
  for (  LogEntry entry : logEntryList) {
    LogIoUtils.writeLogEntry(entry,buf);
  }
  buf.force();
  txLog.close();
  if (tempWriteOutFirst) {
    if (!tempFile.renameTo(txFile)) {
      throw new IOException(""String_Node_Str"" + tempFile + ""String_Node_Str""+ txFile);
    }
  }
}","private void writeOutLogEntryList(List<LogEntry> logEntryList,File txFile,boolean tempWriteOutFirst) throws IOException {
  int identifier=logEntryList.get(0).getIdentifier();
  File tempFile=tempWriteOutFirst ? File.createTempFile(""String_Node_Str"",""String_Node_Str"" + identifier) : txFile;
  msgLog.logMessage(""String_Node_Str"" + tempFile);
  FileChannel txLog=new RandomAccessFile(tempFile,""String_Node_Str"").getChannel();
  LogBuffer buf=new DirectMappedLogBuffer(txLog);
  for (  LogEntry entry : logEntryList) {
    LogIoUtils.writeLogEntry(entry,buf);
  }
  buf.force();
  txLog.close();
  if (tempWriteOutFirst) {
    if (!tempFile.renameTo(txFile)) {
      throw new IOException(""String_Node_Str"" + tempFile + ""String_Node_Str""+ txFile);
    }
  }
}",0.9629629629629628
154788,"public synchronized ReadableByteChannel getCommittedTransaction(long txId) throws IOException {
  String name=fileName + ""String_Node_Str"" + txId;
  File txFile=new File(name);
  List<LogEntry> logEntryList=extractLogEntryList(txId);
  writeOutLogEntryList(logEntryList,txFile,true);
  ReadableByteChannel result=new RandomAccessFile(txFile,""String_Node_Str"").getChannel();
  return result;
}","public synchronized ReadableByteChannel getCommittedTransaction(long txId) throws IOException {
  String name=fileName + ""String_Node_Str"" + txId;
  File txFile=new File(storeDir,name);
  List<LogEntry> logEntryList=extractLogEntryList(txId);
  writeOutLogEntryList(logEntryList,txFile,true);
  ReadableByteChannel result=new RandomAccessFile(txFile,""String_Node_Str"").getChannel();
  return result;
}",0.9886506935687264
154789,"protected StandaloneDbCom spawnJvm(File path,int port,int machineId,String... extraArgs) throws Exception {
  Collection<String> list=new ArrayList<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),StandaloneDb.class.getName(),""String_Node_Str"",path.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"" + port,""String_Node_Str"",""String_Node_Str"" + machineId,""String_Node_Str"",""String_Node_Str""));
  list.addAll(Arrays.asList(extraArgs));
  Runtime.getRuntime().exec(list.toArray(new String[list.size()]));
  StandaloneDbCom result=null;
  long startTime=System.currentTimeMillis();
  RmiLocation location=RmiLocation.location(""String_Node_Str"",port,""String_Node_Str"");
  RemoteException latestException=null;
  while (result == null && (System.currentTimeMillis() - startTime) < 1000 * 10) {
    try {
      result=(StandaloneDbCom)location.getBoundObject();
    }
 catch (    RemoteException e) {
      latestException=e;
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
  if (result == null) {
    throw latestException;
  }
  return result;
}","protected StandaloneDbCom spawnJvm(File path,int port,int machineId,String... extraArgs) throws Exception {
  Collection<String> list=new ArrayList<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),StandaloneDb.class.getName(),""String_Node_Str"",path.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"" + port,""String_Node_Str"",""String_Node_Str"" + machineId,""String_Node_Str"",""String_Node_Str""));
  list.addAll(Arrays.asList(extraArgs));
  Runtime.getRuntime().exec(list.toArray(new String[list.size()]));
  return awaitJvmStarted(port);
}",0.6455331412103746
154790,"@Override protected void startUpMaster(Map<String,String> config) throws Exception {
  Map<String,String> newConfig=new HashMap<String,String>(config);
  newConfig.put(""String_Node_Str"",""String_Node_Str"");
  StandaloneDbCom com=spawnJvm(dbPath(0),MASTER_PORT,0,buildExtraArgs(newConfig));
  com.awaitStarted();
  if (jvms.isEmpty()) {
    jvms.add(com);
  }
 else {
    jvms.set(0,com);
  }
}","@Override protected void startUpMaster(Map<String,String> config) throws Exception {
  Map<String,String> newConfig=new HashMap<String,String>(config);
  newConfig.put(""String_Node_Str"",""String_Node_Str"");
  StandaloneDbCom com=spawnJvm(dbPath(0),MASTER_PORT,0,buildExtraArgs(newConfig));
  if (jvms.isEmpty()) {
    jvms.add(com);
  }
 else {
    jvms.set(0,com);
  }
  Thread.sleep(1000);
}",0.9438775510204082
154791,"protected void initializeDbs(int numSlaves,Map<String,String> config) throws Exception {
  jvms=new ArrayList<StandaloneDbCom>();
  try {
    createDeadDbs(numSlaves);
    startUpMaster(config);
    for (int i=1; i <= numSlaves; i++) {
      File slavePath=dbPath(i);
      StandaloneDbCom slaveJvm=spawnJvm(slavePath,MASTER_PORT + i,i,buildExtraArgs(config));
      jvms.add(slaveJvm);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","protected void initializeDbs(int numSlaves,Map<String,String> config) throws Exception {
  jvms=new ArrayList<StandaloneDbCom>();
  try {
    createDeadDbs(numSlaves);
    startUpMaster(config);
    for (int i=1; i <= numSlaves; i++) {
      File slavePath=dbPath(i);
      StandaloneDbCom slaveJvm=spawnJvm(slavePath,MASTER_PORT + i,i,buildExtraArgs(config));
      jvms.add(slaveJvm);
    }
    Thread.sleep(1000);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9747899159663864
154792,"public StandaloneDb(Args args,RmiLocation location) throws Exception {
  super();
  storeDir=args.get(""String_Node_Str"",null);
  out=new PrintStream(new File(new File(storeDir),""String_Node_Str"")){
    public void println(    String x){
      super.println(new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"" + x);
    }
  }
;
  System.setOut(out);
  System.setErr(out);
  try {
    int tempMachineId;
    System.out.println(""String_Node_Str"");
    HighlyAvailableGraphDatabase haDb=null;
    System.out.println(args.asMap().toString());
    if (args.has(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID)) {
      new EmbeddedGraphDatabase(storeDir).shutdown();
      tempMachineId=args.getNumber(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,null).intValue();
      Map<String,String> config=MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,""String_Node_Str"" + tempMachineId,HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,args.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,null),HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,args.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,null),""String_Node_Str"",args.get(""String_Node_Str"",null));
      haDb=new HighlyAvailableGraphDatabase(storeDir,config);
      System.out.println(""String_Node_Str"");
    }
 else {
      boolean isMaster=args.getBoolean(""String_Node_Str"",false).booleanValue();
      tempMachineId=args.getNumber(""String_Node_Str"",null).intValue();
      Number masterId=args.getNumber(""String_Node_Str"",null);
      Master master=new MasterClient(""String_Node_Str"",CommunicationProtocol.PORT,storeDir);
      AbstractBroker broker=isMaster ? new FakeMasterBroker(tempMachineId,storeDir) : new FakeSlaveBroker(master,masterId.intValue(),tempMachineId,storeDir);
      haDb=new HighlyAvailableGraphDatabase(storeDir,MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,""String_Node_Str"" + tempMachineId,""String_Node_Str"",args.get(""String_Node_Str"",null)),AbstractBroker.wrapSingleBroker(broker));
      System.out.println(""String_Node_Str"");
    }
    this.location=location;
    this.location.ensureRegistryCreated();
    Thread.sleep(5000);
    this.location.bind(this);
    this.machineId=tempMachineId;
    this.db=haDb;
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    println(""String_Node_Str"",e);
    throw e;
  }
}","public StandaloneDb(Args args,RmiLocation location) throws Exception {
  super();
  storeDir=args.get(""String_Node_Str"",null);
  out=new PrintStream(new File(new File(storeDir),""String_Node_Str"")){
    public void println(    String x){
      super.println(new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"" + x);
    }
  }
;
  System.setOut(out);
  System.setErr(out);
  try {
    int tempMachineId;
    System.out.println(""String_Node_Str"");
    HighlyAvailableGraphDatabase haDb=null;
    System.out.println(args.asMap().toString());
    if (args.has(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID)) {
      new EmbeddedGraphDatabase(storeDir).shutdown();
      tempMachineId=args.getNumber(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,null).intValue();
      Map<String,String> config=MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,""String_Node_Str"" + tempMachineId,HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,args.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,null),HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,args.get(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER,null),""String_Node_Str"",args.get(""String_Node_Str"",null));
      haDb=new HighlyAvailableGraphDatabase(storeDir,config);
      System.out.println(""String_Node_Str"");
    }
 else {
      boolean isMaster=args.getBoolean(""String_Node_Str"",false).booleanValue();
      tempMachineId=args.getNumber(""String_Node_Str"",null).intValue();
      Number masterId=args.getNumber(""String_Node_Str"",null);
      Master master=new MasterClient(""String_Node_Str"",CommunicationProtocol.PORT,storeDir);
      AbstractBroker broker=isMaster ? new FakeMasterBroker(tempMachineId,storeDir) : new FakeSlaveBroker(master,masterId.intValue(),tempMachineId,storeDir);
      haDb=new HighlyAvailableGraphDatabase(storeDir,MapUtil.stringMap(HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,""String_Node_Str"" + tempMachineId,""String_Node_Str"",args.get(""String_Node_Str"",null)),AbstractBroker.wrapSingleBroker(broker));
      System.out.println(""String_Node_Str"");
    }
    this.location=location;
    this.location.ensureRegistryCreated();
    this.location.bind(this);
    this.machineId=tempMachineId;
    this.db=haDb;
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    println(""String_Node_Str"",e);
    throw e;
  }
}",0.995049504950495
154793,"private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  LogEntry entry;
  while ((entry=LogIoUtils.readEntry(buffer,log,cf)) != null && logEntryList == null) {
    if (entry instanceof LogEntry.Start) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(entry);
      transactions.put(entry.getIdentifier(),list);
    }
 else     if (entry instanceof LogEntry.Commit) {
      if (((LogEntry.Commit)entry).getTxId() == txId) {
        logEntryList=transactions.get(entry.getIdentifier());
        logEntryList.add(entry);
      }
 else {
        transactions.remove(entry.getIdentifier());
      }
    }
 else     if (entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare) {
      transactions.get(entry.getIdentifier()).add(entry);
    }
 else     if (entry instanceof LogEntry.Done) {
      transactions.remove(entry.getIdentifier());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + entry);
    }
  }
  if (logEntryList == null) {
    msgLog.logMessage(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion);
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ ""String_Node_Str""+ this.logVersion+ ""String_Node_Str"");
  }
  logEntryList.add(new LogEntry.Done(logEntryList.get(0).getIdentifier()));
  return logEntryList;
}","private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  LogEntry entry;
  while ((entry=LogIoUtils.readEntry(buffer,log,cf)) != null && logEntryList == null) {
    if (entry instanceof LogEntry.Start) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(entry);
      transactions.put(entry.getIdentifier(),list);
    }
 else     if (entry instanceof LogEntry.Commit) {
      if (((LogEntry.Commit)entry).getTxId() == txId) {
        logEntryList=transactions.get(entry.getIdentifier());
        logEntryList.add(entry);
      }
 else {
        transactions.remove(entry.getIdentifier());
      }
    }
 else     if (entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare) {
      List<LogEntry> list=transactions.get(entry.getIdentifier());
      if (list != null) {
        list.add(entry);
      }
    }
 else     if (entry instanceof LogEntry.Done) {
      transactions.remove(entry.getIdentifier());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + entry);
    }
  }
  if (logEntryList == null) {
    msgLog.logMessage(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion);
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ ""String_Node_Str""+ this.logVersion+ ""String_Node_Str"");
  }
  logEntryList.add(new LogEntry.Done(logEntryList.get(0).getIdentifier()));
  return logEntryList;
}",0.9705882352941176
154794,"/** 
 * Return the highest id in use.
 * @return The highest id in use.
 */
public long getHighId(){
  return idGenerator != null ? idGenerator.getHighId() : -1;
}","/** 
 * Return the highest id in use.
 * @return The highest id in use.
 */
public long getHighId(){
  long genHighId=idGenerator != null ? idGenerator.getHighId() : -1;
  long updateHighId=highestUpdateRecordId;
  if (updateHighId > genHighId) {
    return updateHighId;
  }
  return genHighId;
}",0.6782608695652174
154795,"/** 
 * Acquires a   {@link PersistenceWindow} for <CODE>position</CODE> andoperation <CODE>type</CODE>. Window must be released after operation has been performed via  {@link #releaseWindow(PersistenceWindow)}.
 * @param position The record position
 * @param type The operation type
 * @return a persistence window encapsulating the record
 * @throws IOException If unable to acquire window
 */
protected PersistenceWindow acquireWindow(int sPosition,OperationType type){
  long position=makeUnsignedInt(sPosition);
  if (!isInRecoveryMode() && (position > idGenerator.getHighId() || !storeOk)) {
    throw new InvalidRecordException(""String_Node_Str"" + position + ""String_Node_Str""+ idGenerator.getHighId()+ ""String_Node_Str""+ storeOk+ ""String_Node_Str"");
  }
  return windowPool.acquire(position,type);
}","/** 
 * Acquires a   {@link PersistenceWindow} for <CODE>position</CODE> andoperation <CODE>type</CODE>. Window must be released after operation has been performed via  {@link #releaseWindow(PersistenceWindow)}.
 * @param position The record position
 * @param type The operation type
 * @return a persistence window encapsulating the record
 * @throws IOException If unable to acquire window
 */
protected PersistenceWindow acquireWindow(int sPosition,OperationType type){
  long position=makeUnsignedInt(sPosition);
  if (!isInRecoveryMode() && (position > getHighId() || !storeOk)) {
    throw new InvalidRecordException(""String_Node_Str"" + position + ""String_Node_Str""+ getHighId()+ ""String_Node_Str""+ storeOk+ ""String_Node_Str"");
  }
  return windowPool.acquire(position,type);
}",0.984924623115578
154796,"private void commitRecovered(){
  try {
    committed=true;
    CommandSorter sorter=new CommandSorter();
    java.util.Collections.sort(relTypeCommands,sorter);
    for (    Command.RelationshipTypeCommand command : relTypeCommands) {
      command.execute();
      addRelationshipType(command.getKey());
    }
    java.util.Collections.sort(nodeCommands,sorter);
    for (    Command.NodeCommand command : nodeCommands) {
      command.execute();
      removeNodeFromCache(command.getKey());
    }
    java.util.Collections.sort(relCommands,sorter);
    for (    Command.RelationshipCommand command : relCommands) {
      command.execute();
      removeRelationshipFromCache(command.getKey());
    }
    java.util.Collections.sort(propIndexCommands,sorter);
    for (    Command.PropertyIndexCommand command : propIndexCommands) {
      command.execute();
      addPropertyIndexCommand(command.getKey());
    }
    java.util.Collections.sort(propCommands,sorter);
    for (    Command.PropertyCommand command : propCommands) {
      command.execute();
      removePropertyFromCache(command);
    }
    neoStore.setRecoveredStatus(true);
    try {
      neoStore.setLastCommittedTx(getCommitTxId());
    }
  finally {
      neoStore.setRecoveredStatus(false);
    }
    neoStore.getIdGeneratorFactory().updateIdGenerators(neoStore);
    if (!isRecovered()) {
      lockReleaser.commit();
    }
  }
  finally {
    nodeRecords.clear();
    propertyRecords.clear();
    relRecords.clear();
    relTypeRecords.clear();
    propIndexRecords.clear();
    nodeCommands.clear();
    propCommands.clear();
    propIndexCommands.clear();
    relCommands.clear();
    relTypeCommands.clear();
  }
}","private void commitRecovered(){
  try {
    committed=true;
    CommandSorter sorter=new CommandSorter();
    java.util.Collections.sort(propIndexCommands,sorter);
    for (    Command.PropertyIndexCommand command : propIndexCommands) {
      command.execute();
      addPropertyIndexCommand(command.getKey());
    }
    java.util.Collections.sort(propCommands,sorter);
    for (    Command.PropertyCommand command : propCommands) {
      command.execute();
      removePropertyFromCache(command);
    }
    java.util.Collections.sort(relTypeCommands,sorter);
    for (    Command.RelationshipTypeCommand command : relTypeCommands) {
      command.execute();
      addRelationshipType(command.getKey());
    }
    java.util.Collections.sort(relCommands,sorter);
    for (    Command.RelationshipCommand command : relCommands) {
      command.execute();
      removeRelationshipFromCache(command.getKey());
    }
    java.util.Collections.sort(nodeCommands,sorter);
    for (    Command.NodeCommand command : nodeCommands) {
      command.execute();
      removeNodeFromCache(command.getKey());
    }
    neoStore.setRecoveredStatus(true);
    try {
      neoStore.setLastCommittedTx(getCommitTxId());
    }
  finally {
      neoStore.setRecoveredStatus(false);
    }
    neoStore.getIdGeneratorFactory().updateIdGenerators(neoStore);
    if (!isRecovered()) {
      lockReleaser.commit();
    }
  }
  finally {
    nodeRecords.clear();
    propertyRecords.clear();
    relRecords.clear();
    relTypeRecords.clear();
    propIndexRecords.clear();
    nodeCommands.clear();
    propCommands.clear();
    propIndexCommands.clear();
    relCommands.clear();
    relTypeCommands.clear();
  }
}",0.6423919478981646
154797,"/** 
 * @param startCost Starting cost for both the start node and the end node
 * @param startNode the start node
 * @param endNode the end node
 * @param costRelationType the relationship that should be included in thepath
 * @param relationDirection relationship direction to follow
 * @param costEvaluator the cost function per relationship
 * @param costAccumulator adding up the path cost
 * @param costComparator comparing to path costs
 */
public Dijkstra(CostType startCost,Node startNode,Node endNode,CostEvaluator<CostType> costEvaluator,CostAccumulator<CostType> costAccumulator,Comparator<CostType> costComparator,Direction relationDirection,RelationshipType... costRelationTypes){
  super();
  this.startCost=startCost;
  this.startNode=startNode;
  this.endNode=endNode;
  this.costRelationTypes=costRelationTypes;
  this.relationDirection=relationDirection;
  this.costEvaluator=costEvaluator;
  this.costAccumulator=costAccumulator;
  this.costComparator=costComparator;
}","/** 
 * @param startCost Starting cost for both the start node and the end node
 * @param startNode the start node
 * @param endNode the end node
 * @param costRelationTypes the relationship that should be included in thepath
 * @param relationDirection relationship direction to follow
 * @param costEvaluator the cost function per relationship
 * @param costAccumulator adding up the path cost
 * @param costComparator comparing to path costs
 */
public Dijkstra(CostType startCost,Node startNode,Node endNode,CostEvaluator<CostType> costEvaluator,CostAccumulator<CostType> costAccumulator,Comparator<CostType> costComparator,Direction relationDirection,RelationshipType... costRelationTypes){
  super();
  this.startCost=startCost;
  this.startNode=startNode;
  this.endNode=endNode;
  this.costRelationTypes=costRelationTypes;
  this.relationDirection=relationDirection;
  this.costEvaluator=costEvaluator;
  this.costAccumulator=costAccumulator;
  this.costComparator=costComparator;
}",0.9994946942900454
154798,"public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId,int masterId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndWriteAndApplyEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start entry=logApplier.startEntry;
  if (entry == null) {
    throw new IOException(""String_Node_Str"");
  }
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(xidIdent,nextTxId,masterId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=entry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
    LogEntry doneEntry=new LogEntry.Done(entry.getIdentifier());
    LogIoUtils.writeLogEntry(doneEntry,writeBuffer);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  scanIsComplete=true;
  log.info(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ ""String_Node_Str"");
  msgLog.logMessage(""String_Node_Str"" + nextTxId);
}","public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId,int masterId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndWriteAndApplyEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start entry=logApplier.startEntry;
  if (entry == null) {
    throw new IOException(""String_Node_Str"");
  }
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(xidIdent,nextTxId,masterId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=entry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
    LogEntry doneEntry=new LogEntry.Done(entry.getIdentifier());
    LogIoUtils.writeLogEntry(doneEntry,writeBuffer);
    xidIdentMap.remove(entry.getIdentifier());
    recoveredTxMap.remove(entry.getIdentifier());
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  scanIsComplete=true;
  msgLog.logMessage(""String_Node_Str"" + nextTxId);
}",0.9263377345378736
154799,"public synchronized long applyPreparedTransaction(ReadableByteChannel transaction) throws IOException {
  long txId=TxIdGenerator.DEFAULT.generate(dataSource,0);
  int masterId=TxIdGenerator.DEFAULT.getCurrentMasterId();
  log.applyTransactionWithoutTxId(transaction,txId,masterId);
  return txId;
}","public synchronized long applyPreparedTransaction(ReadableByteChannel transaction) throws IOException {
  long txId=TxIdGenerator.DEFAULT.generate(dataSource,0);
  int masterId=txIdGenerator.getCurrentMasterId();
  log.applyTransactionWithoutTxId(transaction,txId,masterId);
  return txId;
}",0.9830508474576272
154800,"public void process(WatchedEvent event){
  String path=event.getPath();
  System.out.println(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
  if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
    keeperState=KeeperState.Expired;
    zooKeeper=instantiateZooKeeper();
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
    sequenceNr=setup();
    keeperState=KeeperState.SyncConnected;
    if (firstSyncConnected) {
      firstSyncConnected=false;
    }
 else {
      receiver.somethingIsWrong(new Exception());
    }
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
    keeperState=KeeperState.Disconnected;
  }
 else   if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
    System.out.println(""String_Node_Str"");
    if (broker.getCachedMasterMachineId() == getMasterNotifyId()) {
      System.out.println(""String_Node_Str"");
      return;
    }
    receiver.somethingIsWrong(new Exception());
  }
}","public void process(WatchedEvent event){
  String path=event.getPath();
  System.out.println(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
  if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
    keeperState=KeeperState.Expired;
    zooKeeper=instantiateZooKeeper();
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
    sequenceNr=setup();
    keeperState=KeeperState.SyncConnected;
    if (firstSyncConnected) {
      firstSyncConnected=false;
    }
 else {
      receiver.somethingIsWrong(new Exception());
    }
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
    keeperState=KeeperState.Disconnected;
  }
 else   if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
    System.out.println(""String_Node_Str"");
    if (broker.getMasterMachineId() == getMasterNotifyId()) {
      System.out.println(""String_Node_Str"");
      return;
    }
    receiver.somethingIsWrong(new Exception());
  }
}",0.997250229147571
154801,"IllBehavingXaDataSource() throws InstantiationException {
  super(new HashMap<Object,Object>());
}","IllBehavingXaDataSource() throws InstantiationException {
  super(MapUtil.stringMap(""String_Node_Str"",""String_Node_Str""));
}",0.7117117117117117
154802,"@Before public void setUpFramework(){
  getTransaction().finish();
  TxModule txModule=getEmbeddedGraphDb().getConfig().getTxModule();
  tm=txModule.getTxManager();
  xaDsMgr=txModule.getXaDataSourceManager();
  java.util.Map<String,FakeXAResource> map1=new java.util.HashMap<String,FakeXAResource>();
  map1.put(""String_Node_Str"",new FakeXAResource(""String_Node_Str""));
  java.util.Map<String,FakeXAResource> map2=new java.util.HashMap<String,FakeXAResource>();
  map2.put(""String_Node_Str"",new FakeXAResource(""String_Node_Str""));
  try {
    xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(map1),""String_Node_Str"".getBytes());
    xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(map2),""String_Node_Str"".getBytes());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    tm.commit();
  }
 catch (  Exception e) {
  }
  Transaction tx=null;
  try {
    tx=tm.getTransaction();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (tx != null) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Before public void setUpFramework(){
  getTransaction().finish();
  TxModule txModule=getEmbeddedGraphDb().getConfig().getTxModule();
  tm=txModule.getTxManager();
  xaDsMgr=txModule.getXaDataSourceManager();
  java.util.Map<String,Object> map1=new java.util.HashMap<String,Object>();
  map1.put(""String_Node_Str"",new FakeXAResource(""String_Node_Str""));
  map1.put(""String_Node_Str"",""String_Node_Str"");
  java.util.Map<String,Object> map2=new java.util.HashMap<String,Object>();
  map2.put(""String_Node_Str"",new FakeXAResource(""String_Node_Str""));
  map2.put(""String_Node_Str"",""String_Node_Str"");
  try {
    xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(map1),""String_Node_Str"".getBytes());
    xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(map2),""String_Node_Str"".getBytes());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    tm.commit();
  }
 catch (  Exception e) {
  }
  Transaction tx=null;
  try {
    tx=tm.getTransaction();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (tx != null) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.7838078291814946
154803,"@Test public void testTxIdGeneration() throws Exception {
  DummyXaDataSource xaDs1=null;
  DummyXaConnection xaC1=null;
  try {
    xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(new java.util.HashMap<Object,Object>()),""String_Node_Str"".getBytes());
    xaDs1=(DummyXaDataSource)xaDsMgr.getXaDataSource(""String_Node_Str"");
    xaC1=(DummyXaConnection)xaDs1.getXaConnection();
    tm.begin();
    xaC1.enlistWithTx();
    int currentTxId=xaC1.getTransactionId();
    xaC1.doStuff1();
    xaC1.delistFromTx();
    tm.commit();
    tm.begin();
    Node node=getGraphDb().createNode();
    xaC1.enlistWithTx();
    assertEquals(++currentTxId,xaC1.getTransactionId());
    xaC1.doStuff1();
    xaC1.delistFromTx();
    tm.commit();
    tm.begin();
    node=getGraphDb().getNodeById((int)node.getId());
    xaC1.enlistWithTx();
    assertEquals(++currentTxId,xaC1.getTransactionId());
    xaC1.doStuff2();
    xaC1.delistFromTx();
    node.delete();
    tm.commit();
  }
  finally {
    xaDsMgr.unregisterDataSource(""String_Node_Str"");
    if (xaC1 != null) {
      xaC1.destroy();
    }
  }
  File dir=new File(""String_Node_Str"");
  File files[]=dir.listFiles(new FilenameFilter(){
    public boolean accept(    File dir,    String fileName){
      return fileName.startsWith(resourceFile());
    }
  }
);
  for (int i=0; i < files.length; i++) {
    files[i].delete();
  }
}","@Test public void testTxIdGeneration() throws Exception {
  DummyXaDataSource xaDs1=null;
  DummyXaConnection xaC1=null;
  try {
    Map<Object,Object> config=new HashMap<Object,Object>();
    config.put(""String_Node_Str"",""String_Node_Str"");
    xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(config),""String_Node_Str"".getBytes());
    xaDs1=(DummyXaDataSource)xaDsMgr.getXaDataSource(""String_Node_Str"");
    xaC1=(DummyXaConnection)xaDs1.getXaConnection();
    tm.begin();
    xaC1.enlistWithTx();
    int currentTxId=xaC1.getTransactionId();
    xaC1.doStuff1();
    xaC1.delistFromTx();
    tm.commit();
    tm.begin();
    Node node=getGraphDb().createNode();
    xaC1.enlistWithTx();
    assertEquals(++currentTxId,xaC1.getTransactionId());
    xaC1.doStuff1();
    xaC1.delistFromTx();
    tm.commit();
    tm.begin();
    node=getGraphDb().getNodeById((int)node.getId());
    xaC1.enlistWithTx();
    assertEquals(++currentTxId,xaC1.getTransactionId());
    xaC1.doStuff2();
    xaC1.delistFromTx();
    node.delete();
    tm.commit();
  }
  finally {
    xaDsMgr.unregisterDataSource(""String_Node_Str"");
    if (xaC1 != null) {
      xaC1.destroy();
    }
  }
  File dir=new File(""String_Node_Str"");
  File files[]=dir.listFiles(new FilenameFilter(){
    public boolean accept(    File dir,    String fileName){
      return fileName.startsWith(resourceFile());
    }
  }
);
  for (int i=0; i < files.length; i++) {
    files[i].delete();
  }
}",0.910932588194202
154804,"@Test public void testCreateXaResource() throws Exception {
  xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(new java.util.HashMap<Object,Object>()),""String_Node_Str"".getBytes());
  XaDataSource xaDs=xaDsMgr.getXaDataSource(""String_Node_Str"");
  DummyXaConnection xaC=null;
  try {
    xaC=(DummyXaConnection)xaDs.getXaConnection();
    try {
      xaC.doStuff1();
      fail(""String_Node_Str"");
    }
 catch (    XAException e) {
    }
    Xid xid=new XidImpl(new byte[0],new byte[0]);
    xaC.getXaResource().start(xid,XAResource.TMNOFLAGS);
    try {
      xaC.doStuff1();
      xaC.doStuff2();
    }
 catch (    XAException e) {
      fail(""String_Node_Str"");
    }
    xaC.getXaResource().end(xid,XAResource.TMSUCCESS);
    xaC.getXaResource().prepare(xid);
    xaC.getXaResource().commit(xid,false);
  }
  finally {
    xaDsMgr.unregisterDataSource(""String_Node_Str"");
    if (xaC != null) {
      xaC.destroy();
    }
  }
  File dir=new File(""String_Node_Str"");
  File files[]=dir.listFiles(new FilenameFilter(){
    public boolean accept(    File dir,    String fileName){
      return fileName.startsWith(resourceFile());
    }
  }
);
  for (int i=0; i < files.length; i++) {
    files[i].delete();
  }
}","@Test public void testCreateXaResource() throws Exception {
  Map<Object,Object> config=new HashMap<Object,Object>();
  config.put(""String_Node_Str"",""String_Node_Str"");
  xaDsMgr.registerDataSource(""String_Node_Str"",new DummyXaDataSource(config),""String_Node_Str"".getBytes());
  XaDataSource xaDs=xaDsMgr.getXaDataSource(""String_Node_Str"");
  DummyXaConnection xaC=null;
  try {
    xaC=(DummyXaConnection)xaDs.getXaConnection();
    try {
      xaC.doStuff1();
      fail(""String_Node_Str"");
    }
 catch (    XAException e) {
    }
    Xid xid=new XidImpl(new byte[0],new byte[0]);
    xaC.getXaResource().start(xid,XAResource.TMNOFLAGS);
    try {
      xaC.doStuff1();
      xaC.doStuff2();
    }
 catch (    XAException e) {
      fail(""String_Node_Str"");
    }
    xaC.getXaResource().end(xid,XAResource.TMSUCCESS);
    xaC.getXaResource().prepare(xid);
    xaC.getXaResource().commit(xid,false);
  }
  finally {
    xaDsMgr.unregisterDataSource(""String_Node_Str"");
    if (xaC != null) {
      xaC.destroy();
    }
  }
  File dir=new File(""String_Node_Str"");
  File files[]=dir.listFiles(new FilenameFilter(){
    public boolean accept(    File dir,    String fileName){
      return fileName.startsWith(resourceFile());
    }
  }
);
  for (int i=0; i < files.length; i++) {
    files[i].delete();
  }
}",0.9012976799056232
154805,"public void somethingIsWrong(Exception e){
  new Thread(){
    @Override public void run(){
      for (int i=0; i < 5; i++) {
        try {
          reevaluateMyself();
          break;
        }
 catch (        ZooKeeperException e) {
          e.printStackTrace();
        }
catch (        HaCommunicationException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
}","public void somethingIsWrong(Exception e){
  e.printStackTrace();
  new Thread(){
    @Override public void run(){
      for (int i=0; i < 5; i++) {
        try {
          reevaluateMyself();
          break;
        }
 catch (        ZooKeeperException e) {
          e.printStackTrace();
        }
catch (        HaCommunicationException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
}",0.9715698393077874
154806,"@SuppressWarnings(""String_Node_Str"") protected static Pair<ChannelBuffer,SlaveContext> handleRequest(Master realMaster,ChannelBuffer buffer,Channel channel,MasterServer server) throws IOException {
  RequestType type=RequestType.values()[buffer.readByte()];
  SlaveContext context=null;
  if (type.includesSlaveContext()) {
    context=readSlaveContext(buffer);
    server.mapSlave(channel,context);
  }
  System.out.println(Thread.currentThread() + ""String_Node_Str"" + type+ ""String_Node_Str""+ context);
  Response<?> response=type.caller.callMaster(realMaster,context,buffer);
  System.out.println(Thread.currentThread() + ""String_Node_Str"" + response.response()+ ""String_Node_Str"");
  ChannelBuffer targetBuffer=ChannelBuffers.dynamicBuffer();
  type.serializer.write(response.response(),targetBuffer);
  if (type.includesSlaveContext()) {
    writeTransactionStreams(response.transactions(),targetBuffer);
  }
  return new Pair<ChannelBuffer,SlaveContext>(targetBuffer,context);
}","@SuppressWarnings(""String_Node_Str"") protected static ChannelBuffer handleRequest(Master realMaster,ChannelBuffer buffer,Channel channel,MasterServer server) throws IOException {
  RequestType type=RequestType.values()[buffer.readByte()];
  SlaveContext context=null;
  if (type.includesSlaveContext()) {
    context=readSlaveContext(buffer);
    server.mapSlave(channel,context);
  }
  System.out.println(Thread.currentThread() + ""String_Node_Str"" + type+ ""String_Node_Str""+ context);
  Response<?> response=type.caller.callMaster(realMaster,context,buffer);
  System.out.println(Thread.currentThread() + ""String_Node_Str"" + response.response()+ ""String_Node_Str"");
  ChannelBuffer targetBuffer=ChannelBuffers.dynamicBuffer();
  type.serializer.write(response.response(),targetBuffer);
  if (type.includesSlaveContext()) {
    writeTransactionStreams(response.transactions(),targetBuffer);
  }
  return targetBuffer;
}",0.9595375722543352
154807,"private void releaseChannel(){
synchronized (channels) {
    Channel channel=channels.remove(Thread.currentThread());
    if (channel != null) {
      if (unusedChannels.size() < 5) {
        unusedChannels.push(channel);
      }
 else {
        channel.close();
      }
    }
  }
}","private void releaseChannel(){
synchronized (channels) {
    Channel channel=channels.remove(Thread.currentThread());
    if (channel != null) {
      if (unusedChannels.size() < 5) {
        unusedChannels.push(channel);
      }
 else {
        new Exception(""String_Node_Str"" + channel).printStackTrace();
        channel.close();
      }
    }
  }
}",0.8107255520504731
154808,"public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4));
  pipeline.addLast(""String_Node_Str"",new BlockingReadHandler<ChannelBuffer>());
  return pipeline;
}","public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4));
  BlockingReadHandler<ChannelBuffer> reader=new BlockingReadHandler<ChannelBuffer>();
  pipeline.addLast(""String_Node_Str"",reader);
  return pipeline;
}",0.810126582278481
154809,"public void shutdown(){
synchronized (unusedChannels) {
    for (    Channel channel : unusedChannels) {
      channel.close();
    }
  }
synchronized (channels) {
    for (    Channel channel : channels.values()) {
      channel.close();
    }
  }
}","public void shutdown(){
synchronized (channels) {
    for (    Channel channel : unusedChannels) {
      new Exception(""String_Node_Str"" + channel).printStackTrace();
      channel.close();
    }
    for (    Channel channel : channels.values()) {
      new Exception(""String_Node_Str"" + channel).printStackTrace();
      channel.close();
    }
  }
}",0.3566666666666667
154810,"public Response<Void> rollbackTransaction(SlaveContext context){
  Transaction otherTx=suspendOtherAndResumeThis(context);
  try {
    Transaction tx=transactions.remove(context);
    if (tx == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    graphDbConfig.getTxModule().getTxManager().rollback();
    System.out.println(Thread.currentThread() + ""String_Node_Str"" + context);
    return packResponse(context,null,ALL);
  }
 catch (  IllegalStateException e) {
    throw new RuntimeException(e);
  }
catch (  SecurityException e) {
    throw new RuntimeException(e);
  }
catch (  SystemException e) {
    throw new RuntimeException(e);
  }
 finally {
    suspendThisAndResumeOther(otherTx,context);
  }
}","public Response<Void> rollbackTransaction(SlaveContext context){
  Transaction otherTx=suspendOtherAndResumeThis(context);
  try {
    Transaction tx=transactions.remove(context);
    if (tx == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    graphDbConfig.getTxModule().getTxManager().rollback();
    System.out.println(""String_Node_Str"" + context);
    return packResponse(context,null,ALL);
  }
 catch (  IllegalStateException e) {
    throw new RuntimeException(e);
  }
catch (  SecurityException e) {
    throw new RuntimeException(e);
  }
catch (  SystemException e) {
    throw new RuntimeException(e);
  }
 finally {
    suspendThisAndResumeOther(otherTx,context);
  }
}",0.9824561403508772
154811,"Transaction suspendOtherAndResumeThis(SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    Transaction otherTx=txManager.getTransaction();
    Transaction transaction=getTx(txId);
    if (otherTx != null && otherTx == transaction) {
      return null;
    }
 else {
      if (otherTx != null) {
        txManager.suspend();
        System.out.println(Thread.currentThread() + ""String_Node_Str"");
      }
      if (transaction == null) {
        beginTx(txId);
      }
 else {
        System.out.println(Thread.currentThread() + ""String_Node_Str"" + txId);
        txManager.resume(transaction);
      }
      return otherTx;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","Transaction suspendOtherAndResumeThis(SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    Transaction otherTx=txManager.getTransaction();
    Transaction transaction=getTx(txId);
    if (otherTx != null && otherTx == transaction) {
      return null;
    }
 else {
      if (otherTx != null) {
        txManager.suspend();
        System.out.println(""String_Node_Str"");
      }
      if (transaction == null) {
        beginTx(txId);
      }
 else {
        System.out.println(""String_Node_Str"" + txId);
        txManager.resume(transaction);
      }
      return otherTx;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}",0.9668874172185432
154812,"private Transaction beginTx(SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    txManager.begin();
    System.out.println(Thread.currentThread() + ""String_Node_Str"" + txId);
    Transaction tx=txManager.getTransaction();
    transactions.put(txId,tx);
    return tx;
  }
 catch (  NotSupportedException e) {
    throw new RuntimeException(e);
  }
catch (  SystemException e) {
    throw new RuntimeException(e);
  }
}","private Transaction beginTx(SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    txManager.begin();
    System.out.println(""String_Node_Str"" + txId);
    Transaction tx=txManager.getTransaction();
    transactions.put(txId,tx);
    return tx;
  }
 catch (  NotSupportedException e) {
    throw new RuntimeException(e);
  }
catch (  SystemException e) {
    throw new RuntimeException(e);
  }
}",0.972914409534128
154813,"void rollbackThisAndResumeOther(Transaction otherTx,SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    txManager.rollback();
    System.out.println(Thread.currentThread() + ""String_Node_Str"" + txId);
    transactions.remove(txId);
    if (otherTx != null) {
      System.out.println(Thread.currentThread() + ""String_Node_Str"" + txId);
      txManager.resume(otherTx);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","void rollbackThisAndResumeOther(Transaction otherTx,SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    txManager.rollback();
    System.out.println(""String_Node_Str"" + txId);
    transactions.remove(txId);
    if (otherTx != null) {
      System.out.println(""String_Node_Str"" + txId);
      txManager.resume(otherTx);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}",0.9500998003992016
154814,"void suspendThisAndResumeOther(Transaction otherTx,SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    txManager.suspend();
    System.out.println(Thread.currentThread() + ""String_Node_Str"" + txId);
    if (otherTx != null) {
      System.out.println(Thread.currentThread() + ""String_Node_Str"" + txId);
      txManager.resume(otherTx);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","void suspendThisAndResumeOther(Transaction otherTx,SlaveContext txId){
  try {
    TransactionManager txManager=graphDbConfig.getTxModule().getTxManager();
    txManager.suspend();
    System.out.println(""String_Node_Str"" + txId);
    if (otherTx != null) {
      System.out.println(""String_Node_Str"" + txId);
      txManager.resume(otherTx);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}",0.9465811965811964
154815,"@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  try {
    ChannelBuffer message=(ChannelBuffer)e.getMessage();
    Pair<ChannelBuffer,SlaveContext> result=handleRequest(realMaster,message,e.getChannel(),MasterServer.this);
    e.getChannel().write(result.first());
  }
 catch (  Exception e1) {
    e1.printStackTrace();
    throw e1;
  }
}","@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  try {
    ChannelBuffer message=(ChannelBuffer)e.getMessage();
    ChannelBuffer result=handleRequest(realMaster,message,e.getChannel(),MasterServer.this);
    e.getChannel().write(result);
  }
 catch (  Exception e1) {
    e1.printStackTrace();
    throw e1;
  }
}",0.9644268774703556
154816,"@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  e.getCause().printStackTrace();
}",0.8571428571428571
154817,"public void run(){
  checkForDeadConnections();
}","public void run(){
}",0.5797101449275363
154818,"public MasterServer(Master realMaster,final int port){
  this.realMaster=realMaster;
  ExecutorService executor=Executors.newCachedThreadPool();
  channelFactory=new NioServerSocketChannelFactory(executor,executor);
  bootstrap=new ServerBootstrap(channelFactory);
  bootstrap.setPipelineFactory(this);
  channelGroup=new DefaultChannelGroup();
  executor.execute(new Runnable(){
    public void run(){
      Channel channel=bootstrap.bind(new InetSocketAddress(port));
      channelGroup.add(channel);
      System.out.println(""String_Node_Str"" + port);
    }
  }
);
  deadConnectionsPoller=new ScheduledThreadPoolExecutor(1);
  deadConnectionsPoller.scheduleWithFixedDelay(new Runnable(){
    public void run(){
      checkForDeadConnections();
    }
  }
,DEAD_CONNECTIONS_CHECK_INTERVAL,DEAD_CONNECTIONS_CHECK_INTERVAL,TimeUnit.SECONDS);
}","public MasterServer(Master realMaster,final int port){
  this.realMaster=realMaster;
  ExecutorService executor=Executors.newCachedThreadPool();
  channelFactory=new NioServerSocketChannelFactory(executor,executor,MAX_NUMBER_OF_CONCURRENT_TRANSACTIONS);
  bootstrap=new ServerBootstrap(channelFactory);
  bootstrap.setPipelineFactory(this);
  channelGroup=new DefaultChannelGroup();
  executor.execute(new Runnable(){
    public void run(){
      Channel channel=bootstrap.bind(new InetSocketAddress(port));
      channelGroup.add(channel);
      System.out.println(""String_Node_Str"" + port);
    }
  }
);
  deadConnectionsPoller=new ScheduledThreadPoolExecutor(1);
  deadConnectionsPoller.scheduleWithFixedDelay(new Runnable(){
    public void run(){
    }
  }
,DEAD_CONNECTIONS_CHECK_INTERVAL,DEAD_CONNECTIONS_CHECK_INTERVAL,TimeUnit.SECONDS);
}",0.9579632918886916
154819,"private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  long[] header=readAndAssertLogHeader(buffer,log,expectedVersion);
  long prevTxId=header[1];
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  LogEntry entry;
  while ((entry=LogIoUtils.readEntry(buffer,log,cf)) != null && logEntryList == null) {
    if (entry instanceof LogEntry.Start) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(entry);
      transactions.put(entry.getIdentifier(),list);
    }
 else     if (entry instanceof LogEntry.Commit) {
      if (((LogEntry.Commit)entry).getTxId() == txId) {
        logEntryList=transactions.get(entry.getIdentifier());
        logEntryList.add(entry);
      }
 else {
        transactions.remove(entry.getIdentifier());
      }
    }
 else     if (entry instanceof LogEntry.Command) {
      transactions.get(entry.getIdentifier()).add(entry);
    }
 else     if (entry instanceof LogEntry.Done) {
      transactions.remove(entry.getIdentifier());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + entry);
    }
  }
  if (logEntryList == null) {
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
  }
  return logEntryList;
}","private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  long[] header=readAndAssertLogHeader(buffer,log,expectedVersion);
  long prevTxId=header[1];
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  LogEntry entry;
  while ((entry=LogIoUtils.readEntry(buffer,log,cf)) != null && logEntryList == null) {
    if (entry instanceof LogEntry.Start) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(entry);
      transactions.put(entry.getIdentifier(),list);
    }
 else     if (entry instanceof LogEntry.Commit) {
      if (((LogEntry.Commit)entry).getTxId() == txId) {
        logEntryList=transactions.get(entry.getIdentifier());
        logEntryList.add(entry);
      }
 else {
        transactions.remove(entry.getIdentifier());
      }
    }
 else     if (entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare) {
      transactions.get(entry.getIdentifier()).add(entry);
    }
 else     if (entry instanceof LogEntry.Done) {
      transactions.remove(entry.getIdentifier());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + entry);
    }
  }
  if (logEntryList == null) {
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
  }
  return logEntryList;
}",0.987315735344532
154820,"synchronized void doneInternal(int identifier) throws IOException {
  buffer.clear();
  buffer.put(DONE).putInt(identifier);
  buffer.flip();
  fileChannel.write(buffer);
  xidIdentMap.remove(identifier);
}","synchronized void doneInternal(int identifier) throws IOException {
  buffer.clear();
  buffer.put(DONE).putInt(identifier);
  buffer.flip();
  fileChannel.write(buffer);
  xidIdentMap.remove(identifier);
  fileChannel.force(false);
}",0.9363636363636364
154821,"public static void writeLogEntry(LogEntry entry,LogBuffer buffer) throws IOException {
  if (entry instanceof LogEntry.Command) {
    buffer.put(LogEntry.COMMAND).putInt(entry.getIdentifier());
    XaCommand command=((LogEntry.Command)entry).getXaCommand();
    command.writeToFile(buffer);
  }
 else   if (entry instanceof LogEntry.Start) {
    LogEntry.Start start=(LogEntry.Start)entry;
    Xid xid=start.getXid();
    byte globalId[]=xid.getGlobalTransactionId();
    byte branchId[]=xid.getBranchQualifier();
    int formatId=xid.getFormatId();
    int identifier=start.getIdentifier();
    buffer.put(LogEntry.TX_START).put((byte)globalId.length).put((byte)branchId.length).put(globalId).put(branchId).putInt(identifier).putInt(formatId);
  }
 else   if (entry instanceof LogEntry.Done) {
    buffer.put(LogEntry.DONE).putInt(entry.getIdentifier());
  }
 else   if (entry instanceof LogEntry.OnePhaseCommit) {
    buffer.put(LogEntry.TX_1P_COMMIT).putInt(entry.getIdentifier()).putLong(((LogEntry.OnePhaseCommit)entry).getTxId());
  }
 else   if (entry instanceof LogEntry.Prepare) {
    buffer.put(LogEntry.TX_PREPARE).putInt(entry.getIdentifier());
  }
 else   if (entry instanceof LogEntry.TwoPhaseCommit) {
    buffer.put(LogEntry.TX_2P_COMMIT).putInt(entry.getIdentifier()).putLong(((LogEntry.OnePhaseCommit)entry).getTxId());
  }
}","public static void writeLogEntry(LogEntry entry,LogBuffer buffer) throws IOException {
  if (entry instanceof LogEntry.Command) {
    buffer.put(LogEntry.COMMAND).putInt(entry.getIdentifier());
    XaCommand command=((LogEntry.Command)entry).getXaCommand();
    command.writeToFile(buffer);
  }
 else   if (entry instanceof LogEntry.Start) {
    LogEntry.Start start=(LogEntry.Start)entry;
    Xid xid=start.getXid();
    byte globalId[]=xid.getGlobalTransactionId();
    byte branchId[]=xid.getBranchQualifier();
    int formatId=xid.getFormatId();
    int identifier=start.getIdentifier();
    buffer.put(LogEntry.TX_START).put((byte)globalId.length).put((byte)branchId.length).put(globalId).put(branchId).putInt(identifier).putInt(formatId);
  }
 else   if (entry instanceof LogEntry.Done) {
    buffer.put(LogEntry.DONE).putInt(entry.getIdentifier());
  }
 else   if (entry instanceof LogEntry.OnePhaseCommit) {
    buffer.put(LogEntry.TX_1P_COMMIT).putInt(entry.getIdentifier()).putLong(((LogEntry.Commit)entry).getTxId());
  }
 else   if (entry instanceof LogEntry.Prepare) {
    buffer.put(LogEntry.TX_PREPARE).putInt(entry.getIdentifier());
  }
 else   if (entry instanceof LogEntry.TwoPhaseCommit) {
    buffer.put(LogEntry.TX_2P_COMMIT).putInt(entry.getIdentifier()).putLong(((LogEntry.Commit)entry).getTxId());
  }
}",0.994007490636704
154822,"private void applyStartEntry(LogEntry.Start entry) throws IOException {
  int identifier=entry.getIdentifier();
  if (identifier >= nextIdentifier) {
    nextIdentifier=(identifier + 1);
  }
  Xid xid=entry.getXid();
  xidIdentMap.put(identifier,entry);
  XaTransaction xaTx=xaTf.create(identifier);
  xaTx.setRecovered();
  recoveredTxMap.put(identifier,xaTx);
  xaRm.injectStart(xid,xaTx);
}","private void applyStartEntry(LogEntry.Start entry) throws IOException {
  int identifier=entry.getIdentifier();
  if (identifier >= nextIdentifier) {
    nextIdentifier=(identifier + 1);
  }
  Xid xid=entry.getXid();
  xidIdentMap.put(identifier,entry);
  XaTransaction xaTx=xaTf.create(identifier);
  xaTx.setRecovered();
  recoveredTxMap.put(identifier,xaTx);
  xaRm.injectStart(xid,xaTx);
  fileChannel.force(false);
}",0.9656019656019657
154823,"public synchronized void applyTransaction(ReadableByteChannel byteChannel) throws IOException {
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndApplyAndWriteEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
}","public synchronized void applyTransaction(ReadableByteChannel byteChannel) throws IOException {
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndApplyAndWriteEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  scanIsComplete=true;
}",0.9317851959361392
154824,"public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndApplyAndWriteEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start entry=logApplier.startEntry;
  if (entry == null) {
    throw new IOException(""String_Node_Str"");
  }
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(xidIdent,nextTxId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=entry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  log.info(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ ""String_Node_Str"");
  msgLog.logMessage(""String_Node_Str"" + nextTxId);
}","public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  scanIsComplete=false;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndApplyAndWriteEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start entry=logApplier.startEntry;
  if (entry == null) {
    throw new IOException(""String_Node_Str"");
  }
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(xidIdent,nextTxId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=entry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
    LogEntry doneEntry=new LogEntry.Done(entry.getIdentifier());
    LogIoUtils.writeLogEntry(doneEntry,writeBuffer);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  scanIsComplete=true;
  log.info(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ ""String_Node_Str"");
  msgLog.logMessage(""String_Node_Str"" + nextTxId);
}",0.9378062570674708
154825,"public synchronized void applyLog(ReadableByteChannel byteChannel) throws IOException {
  if (!backupSlave) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (xidIdentMap.size() > 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long[] header=readLogHeader(buffer,byteChannel,true);
  logVersion=header[0];
  long previousCommittedTx=header[1];
  if (logVersion != xaTf.getCurrentVersion()) {
    throw new IllegalStateException(""String_Node_Str"" + logVersion + ""String_Node_Str""+ xaTf.getCurrentVersion());
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ previousCommittedTx+ ""String_Node_Str"");
  msgLog.logMessage(""String_Node_Str"" + logVersion + ""String_Node_Str""+ previousCommittedTx+ ""String_Node_Str"");
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel);
  while (logApplier.readAndApplyEntry()) {
    logEntriesFound++;
  }
  byteChannel.close();
  xaTf.flushAll();
  xaTf.getAndSetNewVersion();
  xaRm.reset();
  msgLog.logMessage(""String_Node_Str"" + logVersion + ""String_Node_Str""+ logEntriesFound+ ""String_Node_Str"");
  log.info(""String_Node_Str"" + fileName + ""String_Node_Str""+ logVersion+ ""String_Node_Str"");
}","public synchronized void applyLog(ReadableByteChannel byteChannel) throws IOException {
  if (!backupSlave) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (xidIdentMap.size() > 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long[] header=readLogHeader(buffer,byteChannel,true);
  logVersion=header[0];
  long previousCommittedTx=header[1];
  if (logVersion != xaTf.getCurrentVersion()) {
    throw new IllegalStateException(""String_Node_Str"" + logVersion + ""String_Node_Str""+ xaTf.getCurrentVersion());
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ previousCommittedTx+ ""String_Node_Str"");
  msgLog.logMessage(""String_Node_Str"" + logVersion + ""String_Node_Str""+ previousCommittedTx+ ""String_Node_Str"");
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel);
  scanIsComplete=false;
  while (logApplier.readAndApplyEntry()) {
    logEntriesFound++;
  }
  scanIsComplete=true;
  byteChannel.close();
  xaTf.flushAll();
  xaTf.getAndSetNewVersion();
  xaRm.reset();
  msgLog.logMessage(""String_Node_Str"" + logVersion + ""String_Node_Str""+ logEntriesFound+ ""String_Node_Str"");
  log.info(""String_Node_Str"" + fileName + ""String_Node_Str""+ logVersion+ ""String_Node_Str"");
}",0.9808553971486762
154826,"@Override protected Iterator<T> createNestedIterator(final BufferedReader input){
  return new PrefetchingIterator<T>(){
    @Override protected T fetchNextOrNull(){
      try {
        String line;
        while (null != (line=input.readLine())) {
          try {
            return type.cast(Class.forName(line).newInstance());
          }
 catch (          Exception e) {
          }
        }
        return null;
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
;
}","@Override protected Iterator<T> createNestedIterator(final BufferedReader input){
  return new PrefetchingIterator<T>(){
    @Override protected T fetchNextOrNull(){
      try {
        String line;
        while (null != (line=input.readLine())) {
          try {
            return type.cast(Class.forName(line).newInstance());
          }
 catch (          Exception e) {
            return null;
          }
catch (          LinkageError e) {
            return null;
          }
        }
        return null;
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
;
}",0.9114155251141552
154827,"private static <T>Iterable<T> java6Loader(Class<T> type){
  try {
    @SuppressWarnings(""String_Node_Str"") Iterable<T> result=(Iterable<T>)Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",Class.class).invoke(null,type);
    return filterExceptions(result);
  }
 catch (  Exception e) {
    return null;
  }
}","private static <T>Iterable<T> java6Loader(Class<T> type){
  try {
    @SuppressWarnings(""String_Node_Str"") Iterable<T> result=(Iterable<T>)Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",Class.class).invoke(null,type);
    return filterExceptions(result);
  }
 catch (  Exception e) {
    return null;
  }
catch (  LinkageError e) {
    return null;
  }
}",0.9302325581395348
154828,"private static <T>Iterable<T> sunJava5Loader(final Class<T> type){
  final Method providers;
  try {
    providers=Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",Class.class);
  }
 catch (  Exception e) {
    return null;
  }
  return filterExceptions(new Iterable<T>(){
    public Iterator<T> iterator(){
      try {
        @SuppressWarnings(""String_Node_Str"") Iterator<T> result=(Iterator<T>)providers.invoke(null,type);
        return result;
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
    }
  }
);
}","private static <T>Iterable<T> sunJava5Loader(final Class<T> type){
  final Method providers;
  try {
    providers=Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",Class.class);
  }
 catch (  Exception e) {
    return null;
  }
catch (  LinkageError e) {
    return null;
  }
  return filterExceptions(new Iterable<T>(){
    public Iterator<T> iterator(){
      try {
        @SuppressWarnings(""String_Node_Str"") Iterator<T> result=(Iterator<T>)providers.invoke(null,type);
        return result;
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
    }
  }
);
}",0.9600665557404326
154829,"@Override protected T fetchNextOrNull(){
  try {
    String line;
    while (null != (line=input.readLine())) {
      try {
        return type.cast(Class.forName(line).newInstance());
      }
 catch (      Exception e) {
      }
    }
    return null;
  }
 catch (  IOException e) {
    return null;
  }
}","@Override protected T fetchNextOrNull(){
  try {
    String line;
    while (null != (line=input.readLine())) {
      try {
        return type.cast(Class.forName(line).newInstance());
      }
 catch (      Exception e) {
        return null;
      }
catch (      LinkageError e) {
        return null;
      }
    }
    return null;
  }
 catch (  IOException e) {
    return null;
  }
}",0.8831168831168831
154830,"private static <T>Iterable<T> ourOwnLoader(final Class<T> type){
  List<URL> urls=new LinkedList<URL>();
  try {
    Enumeration<URL> resources=Thread.currentThread().getContextClassLoader().getResources(""String_Node_Str"" + type.getName());
    while (resources.hasMoreElements()) {
      urls.add(resources.nextElement());
    }
  }
 catch (  IOException e) {
    return null;
  }
  return new NestingIterable<T,BufferedReader>(FilteringIterable.notNull(new IterableWrapper<BufferedReader,URL>(urls){
    @Override protected BufferedReader underlyingObjectToObject(    URL url){
      try {
        return new BufferedReader(new InputStreamReader(url.openStream()));
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
)){
    @Override protected Iterator<T> createNestedIterator(    final BufferedReader input){
      return new PrefetchingIterator<T>(){
        @Override protected T fetchNextOrNull(){
          try {
            String line;
            while (null != (line=input.readLine())) {
              try {
                return type.cast(Class.forName(line).newInstance());
              }
 catch (              Exception e) {
              }
            }
            return null;
          }
 catch (          IOException e) {
            return null;
          }
        }
      }
;
    }
  }
;
}","private static <T>Iterable<T> ourOwnLoader(final Class<T> type){
  List<URL> urls=new LinkedList<URL>();
  try {
    Enumeration<URL> resources=Thread.currentThread().getContextClassLoader().getResources(""String_Node_Str"" + type.getName());
    while (resources.hasMoreElements()) {
      urls.add(resources.nextElement());
    }
  }
 catch (  IOException e) {
    return null;
  }
  return new NestingIterable<T,BufferedReader>(FilteringIterable.notNull(new IterableWrapper<BufferedReader,URL>(urls){
    @Override protected BufferedReader underlyingObjectToObject(    URL url){
      try {
        return new BufferedReader(new InputStreamReader(url.openStream()));
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
)){
    @Override protected Iterator<T> createNestedIterator(    final BufferedReader input){
      return new PrefetchingIterator<T>(){
        @Override protected T fetchNextOrNull(){
          try {
            String line;
            while (null != (line=input.readLine())) {
              try {
                return type.cast(Class.forName(line).newInstance());
              }
 catch (              Exception e) {
                return null;
              }
catch (              LinkageError e) {
                return null;
              }
            }
            return null;
          }
 catch (          IOException e) {
            return null;
          }
        }
      }
;
    }
  }
;
}",0.9595706618962432
154831,"public AutoConfigurator(String dbPath,boolean useMemoryMapped,boolean dump){
  this.dbPath=dbPath;
  this.useMemoryMapped=useMemoryMapped;
  OperatingSystemMXBean osBean=ManagementFactory.getOperatingSystemMXBean();
  long mem=-1;
  try {
    Class<?> beanClass=Class.forName(""String_Node_Str"");
    Method method=beanClass.getMethod(""String_Node_Str"");
    mem=(Long)method.invoke(osBean);
  }
 catch (  Exception e) {
  }
  if (mem != -1) {
    totalPhysicalMemMb=(int)(mem / 1024 / 1024);
  }
 else {
    totalPhysicalMemMb=-1;
  }
  mem=Runtime.getRuntime().maxMemory();
  maxVmUsageMb=(int)(mem / 1024 / 1024);
  if (dump) {
    System.out.println(""String_Node_Str"" + totalPhysicalMemMb + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + maxVmUsageMb + ""String_Node_Str"");
  }
}","public AutoConfigurator(String dbPath,boolean useMemoryMapped,boolean dump){
  this.dbPath=dbPath;
  this.useMemoryMapped=useMemoryMapped;
  OperatingSystemMXBean osBean=ManagementFactory.getOperatingSystemMXBean();
  long mem=-1;
  try {
    Class<?> beanClass=Class.forName(""String_Node_Str"");
    Method method=beanClass.getMethod(""String_Node_Str"");
    mem=(Long)method.invoke(osBean);
  }
 catch (  Exception e) {
  }
catch (  LinkageError e) {
  }
  if (mem != -1) {
    totalPhysicalMemMb=(int)(mem / 1024 / 1024);
  }
 else {
    totalPhysicalMemMb=-1;
  }
  mem=Runtime.getRuntime().maxMemory();
  maxVmUsageMb=(int)(mem / 1024 / 1024);
  if (dump) {
    System.out.println(""String_Node_Str"" + totalPhysicalMemMb + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + maxVmUsageMb + ""String_Node_Str"");
  }
}",0.9809230769230768
154832,"/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,Map<String,String> stringParams,KernelPanicEventGenerator kpe,TxEventSyncHookFactory syncHookFactory){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=getDefaultParams();
  boolean useMemoryMapped=true;
  if (stringParams.containsKey(Config.USE_MEMORY_MAPPED_BUFFERS)) {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,stringParams.get(Config.USE_MEMORY_MAPPED_BUFFERS));
  }
  if (""String_Node_Str"".equals(params.get(Config.USE_MEMORY_MAPPED_BUFFERS))) {
    useMemoryMapped=false;
  }
  boolean dump=false;
  if (""String_Node_Str"".equals(stringParams.get(Config.DUMP_CONFIGURATION))) {
    dump=true;
  }
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  new AutoConfigurator(storeDir,useMemoryMapped,dump).configure(params);
  for (  Map.Entry<String,String> entry : stringParams.entrySet()) {
    params.put(entry.getKey(),entry.getValue());
  }
  config=new Config(graphDb,storeDir,params,kpe);
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
    try {
      Class<?> cls=Class.forName(""String_Node_Str"");
      config.getTxModule().registerDataSource(""String_Node_Str"",cls.getName(),""String_Node_Str"".getBytes(),config.getParams());
    }
 catch (    ClassNotFoundException e) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,syncHookFactory);
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),params);
  if (""String_Node_Str"".equals(params.get(Config.DUMP_CONFIGURATION))) {
    for (    Object key : params.keySet()) {
      if (key instanceof String) {
        Object value=params.get(key);
        if (value instanceof String) {
          System.out.println(key + ""String_Node_Str"" + value);
        }
      }
    }
  }
  if (config.getTxModule().getXaDataSourceManager().hasDataSource(""String_Node_Str"")) {
    config.getTxModule().getXaDataSourceManager().unregisterDataSource(""String_Node_Str"");
  }
  started=true;
  return Collections.unmodifiableMap(params);
}","/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,Map<String,String> stringParams,KernelPanicEventGenerator kpe,TxEventSyncHookFactory syncHookFactory){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=getDefaultParams();
  boolean useMemoryMapped=true;
  if (stringParams.containsKey(Config.USE_MEMORY_MAPPED_BUFFERS)) {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,stringParams.get(Config.USE_MEMORY_MAPPED_BUFFERS));
  }
  if (""String_Node_Str"".equals(params.get(Config.USE_MEMORY_MAPPED_BUFFERS))) {
    useMemoryMapped=false;
  }
  boolean dump=false;
  if (""String_Node_Str"".equals(stringParams.get(Config.DUMP_CONFIGURATION))) {
    dump=true;
  }
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  new AutoConfigurator(storeDir,useMemoryMapped,dump).configure(params);
  for (  Map.Entry<String,String> entry : stringParams.entrySet()) {
    params.put(entry.getKey(),entry.getValue());
  }
  config=new Config(graphDb,storeDir,params,kpe);
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte[] luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId,params);
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
    try {
      Class<?> cls=Class.forName(""String_Node_Str"");
      config.getTxModule().registerDataSource(""String_Node_Str"",cls.getName(),""String_Node_Str"".getBytes(),config.getParams());
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError err) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource,syncHookFactory);
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),params);
  if (""String_Node_Str"".equals(params.get(Config.DUMP_CONFIGURATION))) {
    for (    Object key : params.keySet()) {
      if (key instanceof String) {
        Object value=params.get(key);
        if (value instanceof String) {
          System.out.println(key + ""String_Node_Str"" + value);
        }
      }
    }
  }
  if (config.getTxModule().getXaDataSourceManager().hasDataSource(""String_Node_Str"")) {
    config.getTxModule().getXaDataSourceManager().unregisterDataSource(""String_Node_Str"");
  }
  started=true;
  return Collections.unmodifiableMap(params);
}",0.9851042701092354
154833,"@Override protected Iterator<T> createNestedIterator(final BufferedReader input){
  return new PrefetchingIterator<T>(){
    @Override protected T fetchNextOrNull(){
      try {
        String line;
        while (null != (line=input.readLine())) {
          try {
            return type.cast(Class.forName(line).newInstance());
          }
 catch (          Exception e) {
            return null;
          }
catch (          LinkageError e) {
            return null;
          }
        }
        return null;
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
;
}","@Override protected Iterator<T> createNestedIterator(final BufferedReader input){
  return new PrefetchingIterator<T>(){
    @Override protected T fetchNextOrNull(){
      try {
        String line;
        while (null != (line=input.readLine())) {
          try {
            return type.cast(Class.forName(line).newInstance());
          }
 catch (          Exception e) {
          }
catch (          LinkageError e) {
          }
        }
        return null;
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
;
}",0.956217162872154
154834,"@Override protected T fetchNextOrNull(){
  try {
    String line;
    while (null != (line=input.readLine())) {
      try {
        return type.cast(Class.forName(line).newInstance());
      }
 catch (      Exception e) {
        return null;
      }
catch (      LinkageError e) {
        return null;
      }
    }
    return null;
  }
 catch (  IOException e) {
    return null;
  }
}","@Override protected T fetchNextOrNull(){
  try {
    String line;
    while (null != (line=input.readLine())) {
      try {
        return type.cast(Class.forName(line).newInstance());
      }
 catch (      Exception e) {
      }
catch (      LinkageError e) {
      }
    }
    return null;
  }
 catch (  IOException e) {
    return null;
  }
}",0.9426229508196722
154835,"private static <T>Iterable<T> ourOwnLoader(final Class<T> type){
  List<URL> urls=new LinkedList<URL>();
  try {
    Enumeration<URL> resources=Thread.currentThread().getContextClassLoader().getResources(""String_Node_Str"" + type.getName());
    while (resources.hasMoreElements()) {
      urls.add(resources.nextElement());
    }
  }
 catch (  IOException e) {
    return null;
  }
  return new NestingIterable<T,BufferedReader>(FilteringIterable.notNull(new IterableWrapper<BufferedReader,URL>(urls){
    @Override protected BufferedReader underlyingObjectToObject(    URL url){
      try {
        return new BufferedReader(new InputStreamReader(url.openStream()));
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
)){
    @Override protected Iterator<T> createNestedIterator(    final BufferedReader input){
      return new PrefetchingIterator<T>(){
        @Override protected T fetchNextOrNull(){
          try {
            String line;
            while (null != (line=input.readLine())) {
              try {
                return type.cast(Class.forName(line).newInstance());
              }
 catch (              Exception e) {
                return null;
              }
catch (              LinkageError e) {
                return null;
              }
            }
            return null;
          }
 catch (          IOException e) {
            return null;
          }
        }
      }
;
    }
  }
;
}","private static <T>Iterable<T> ourOwnLoader(final Class<T> type){
  List<URL> urls=new LinkedList<URL>();
  try {
    Enumeration<URL> resources=Thread.currentThread().getContextClassLoader().getResources(""String_Node_Str"" + type.getName());
    while (resources.hasMoreElements()) {
      urls.add(resources.nextElement());
    }
  }
 catch (  IOException e) {
    return null;
  }
  return new NestingIterable<T,BufferedReader>(FilteringIterable.notNull(new IterableWrapper<BufferedReader,URL>(urls){
    @Override protected BufferedReader underlyingObjectToObject(    URL url){
      try {
        return new BufferedReader(new InputStreamReader(url.openStream()));
      }
 catch (      IOException e) {
        return null;
      }
    }
  }
)){
    @Override protected Iterator<T> createNestedIterator(    final BufferedReader input){
      return new PrefetchingIterator<T>(){
        @Override protected T fetchNextOrNull(){
          try {
            String line;
            while (null != (line=input.readLine())) {
              try {
                return type.cast(Class.forName(line).newInstance());
              }
 catch (              Exception e) {
              }
catch (              LinkageError e) {
              }
            }
            return null;
          }
 catch (          IOException e) {
            return null;
          }
        }
      }
;
    }
  }
;
}",0.9796491228070175
154836,"protected void registerIdFromUpdateRecord(long id){
  highestUpdateRecordId=Math.max(highestUpdateRecordId,id);
}","protected void registerIdFromUpdateRecord(long id){
  highestUpdateRecordId=Math.max(highestUpdateRecordId,id + 1);
}",0.982608695652174
154837,"XaLogicalLog(String fileName,XaResourceManager xaRm,XaCommandFactory cf,XaTransactionFactory xaTf,Map<Object,Object> config){
  this.fileName=fileName;
  this.xaRm=xaRm;
  this.cf=cf;
  this.xaTf=xaTf;
  this.useMemoryMapped=getMemoryMapped(config);
  log=Logger.getLogger(this.getClass().getName() + ""String_Node_Str"" + fileName);
  buffer=ByteBuffer.allocateDirect(9 + Xid.MAXGTRIDSIZE + Xid.MAXBQUALSIZE * 10);
  String root=(String)config.get(""String_Node_Str"");
  msgLog=StringLogger.getLogger(root + ""String_Node_Str"");
}","XaLogicalLog(String fileName,XaResourceManager xaRm,XaCommandFactory cf,XaTransactionFactory xaTf,Map<Object,Object> config){
  this.fileName=fileName;
  this.xaRm=xaRm;
  this.cf=cf;
  this.xaTf=xaTf;
  this.useMemoryMapped=getMemoryMapped(config);
  log=Logger.getLogger(this.getClass().getName() + ""String_Node_Str"" + fileName);
  buffer=ByteBuffer.allocateDirect(9 + Xid.MAXGTRIDSIZE + Xid.MAXBQUALSIZE * 10);
  storeDir=(String)config.get(""String_Node_Str"");
  msgLog=StringLogger.getLogger(new File(storeDir,""String_Node_Str"").getPath());
}",0.9487418452935694
154838,"private String generateUniqueName(String baseName){
  String tmpName=baseName + ""String_Node_Str"" + System.currentTimeMillis();
  while (new File(tmpName).exists()) {
    tmpName=baseName + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
  }
  return tmpName;
}","private String generateUniqueName(String baseName){
  File tmpFile=null;
  while (tmpFile == null || tmpFile.exists()) {
    tmpFile=new File(storeDir,baseName + ""String_Node_Str"" + System.currentTimeMillis());
  }
  return tmpFile.getPath();
}",0.4541984732824427
154839,"private void writeOutLogEntryList(List<LogEntry> logEntryList,String name,String tmpNameHint) throws IOException {
  String tmpName=generateUniqueName(tmpNameHint);
  FileChannel txLog=new RandomAccessFile(tmpName,""String_Node_Str"").getChannel();
  LogBuffer buf=new DirectMappedLogBuffer(txLog);
  for (  LogEntry entry : logEntryList) {
    LogIoUtils.writeLogEntry(entry,buf);
  }
  buf.force();
  txLog.close();
  if (!new File(tmpName).renameTo(new File(name))) {
    throw new IOException(""String_Node_Str"" + tmpName + ""String_Node_Str""+ name);
  }
}","private void writeOutLogEntryList(List<LogEntry> logEntryList,String name,String tmpNameHint) throws IOException {
  String tmpName=generateUniqueName(tmpNameHint);
  System.out.println(""String_Node_Str"" + tmpName);
  FileChannel txLog=new RandomAccessFile(tmpName,""String_Node_Str"").getChannel();
  LogBuffer buf=new DirectMappedLogBuffer(txLog);
  for (  LogEntry entry : logEntryList) {
    LogIoUtils.writeLogEntry(entry,buf);
  }
  buf.force();
  txLog.close();
  if (!new File(tmpName).renameTo(new File(name))) {
    throw new IOException(""String_Node_Str"" + tmpName + ""String_Node_Str""+ name);
  }
}",0.9561478933791916
154840,"<T>T makeProxy(ObjectName name,Class<T> beanType){
  try {
    final Method factoryMethod;
    if (isMXBeanInterface(beanType)) {
      factoryMethod=newMXBeanProxy;
    }
 else {
      factoryMethod=newMBeanProxy;
    }
    return beanType.cast(factoryMethod.invoke(null,getPlatformMBeanServer(),name,beanType));
  }
 catch (  InvocationTargetException exception) {
    throw launderRuntimeException(exception.getTargetException());
  }
catch (  Exception exception) {
    throw new UnsupportedOperationException(""String_Node_Str"",exception);
  }
}","@Override <T>T makeProxy(ObjectName name,Class<T> beanType){
  return MBeanServerInvocationHandler.newProxyInstance(getPlatformMBeanServer(),name,beanType,false);
}",0.3169705469845722
154841,"ProxyMaker() throws Exception {
  Class<?> JMX=Class.forName(""String_Node_Str"");
  this.isMXBeanInterface=JMX.getMethod(""String_Node_Str"",Class.class);
  this.newMBeanProxy=JMX.getMethod(""String_Node_Str"",MBeanServerConnection.class,ObjectName.class,Class.class);
  this.newMXBeanProxy=JMX.getMethod(""String_Node_Str"",MBeanServerConnection.class,ObjectName.class,Class.class);
}","ProxyMaker(boolean supportsMxBean){
  this.supportsMxBean=supportsMxBean;
}",0.1942604856512141
154842,"public GraphDatabaseShellServer(GraphDatabaseService graphDb) throws RemoteException {
  super();
  this.graphDb=graphDb;
  this.bashInterpreter=new BashVariableInterpreter();
  this.bashInterpreter.addReplacer(""String_Node_Str"",new WorkingDirReplacer());
  this.setProperty(AbstractClient.PROMPT_KEY,getShellPrompt());
  this.setProperty(AbstractClient.TITLE_KEYS_KEY,""String_Node_Str"");
  this.setProperty(AbstractClient.TITLE_MAX_LENGTH,""String_Node_Str"");
}","public GraphDatabaseShellServer(GraphDatabaseService graphDb) throws RemoteException {
  super();
  this.graphDb=graphDb;
  this.bashInterpreter=new BashVariableInterpreter();
  this.bashInterpreter.addReplacer(""String_Node_Str"",new WorkingDirReplacer());
  this.setProperty(AbstractClient.PROMPT_KEY,getShellPrompt());
  this.setProperty(AbstractClient.TITLE_KEYS_KEY,""String_Node_Str"");
  this.setProperty(AbstractClient.TITLE_MAX_LENGTH,""String_Node_Str"");
  this.graphDbCreatedHere=true;
}",0.9664570230607966
154843,"public void shutdown(){
  this.graphDb.shutdown();
}","public void shutdown(){
  if (graphDbCreatedHere) {
    this.graphDb.shutdown();
  }
}",0.7536231884057971
154844,"public synchronized void applyLog(ReadableByteChannel byteChannel) throws IOException {
  if (!backupSlave) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (xidIdentMap.size() > 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  buffer.clear();
  buffer.limit(8);
  if (byteChannel.read(buffer) != 8) {
    throw new IOException(""String_Node_Str"");
  }
  buffer.flip();
  logVersion=buffer.getLong();
  if (logVersion != xaTf.getCurrentVersion()) {
    throw new IllegalStateException(""String_Node_Str"" + logVersion + ""String_Node_Str""+ xaTf.getCurrentVersion());
  }
  msgLog.logMessage(""String_Node_Str"" + logVersion);
  log.fine(""String_Node_Str"" + logVersion);
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel,buffer,xaTf,xaRm,cf,xidIdentMap,recoveredTxMap);
  while (logApplier.readAndApplyEntry()) {
    logEntriesFound++;
  }
  byteChannel.close();
  xaTf.flushAll();
  xaTf.getAndSetNewVersion();
  xaRm.reset();
  msgLog.logMessage(""String_Node_Str"" + logVersion + ""String_Node_Str""+ logEntriesFound+ ""String_Node_Str"");
  log.info(""String_Node_Str"" + fileName + ""String_Node_Str""+ logVersion+ ""String_Node_Str"");
}","public synchronized void applyLog(ReadableByteChannel byteChannel) throws IOException {
  if (!backupSlave) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (xidIdentMap.size() > 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  buffer.clear();
  buffer.limit(8);
  if (byteChannel.read(buffer) != 8) {
    throw new IOException(""String_Node_Str"");
  }
  buffer.flip();
  logVersion=buffer.getLong();
  if (logVersion != xaTf.getCurrentVersion()) {
    throw new IllegalStateException(""String_Node_Str"" + logVersion + ""String_Node_Str""+ xaTf.getCurrentVersion());
  }
  msgLog.logMessage(""String_Node_Str"" + logVersion);
  log.fine(""String_Node_Str"" + logVersion);
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel,buffer,xaTf,xaRm,cf,xidIdentMap,recoveredTxMap);
  scanIsComplete=false;
  while (logApplier.readAndApplyEntry()) {
    logEntriesFound++;
  }
  scanIsComplete=true;
  byteChannel.close();
  xaTf.flushAll();
  xaTf.getAndSetNewVersion();
  xaRm.reset();
  msgLog.logMessage(""String_Node_Str"" + logVersion + ""String_Node_Str""+ logEntriesFound+ ""String_Node_Str"");
  log.info(""String_Node_Str"" + fileName + ""String_Node_Str""+ logVersion+ ""String_Node_Str"");
}",0.9805865344898802
154845,"synchronized XaTransaction commit(Xid xid,boolean onePhase) throws XAException {
  XidStatus status=xidMap.get(xid);
  if (status == null) {
    throw new XAException(""String_Node_Str"" + xid + ""String_Node_Str"");
  }
  TransactionStatus txStatus=status.getTransactionStatus();
  XaTransaction xaTransaction=txStatus.getTransaction();
  if (onePhase) {
    if (!xaTransaction.isReadOnly()) {
      if (!xaTransaction.isRecovered()) {
        xaTransaction.prepare();
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitOnePhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markAsPrepared();
  }
  if (!txStatus.prepared() || txStatus.rollback()) {
    throw new XAException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!xaTransaction.isReadOnly()) {
    if (!xaTransaction.isRecovered()) {
      if (!onePhase) {
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitTwoPhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markCommitStarted();
    if (xaTransaction.isRecovered() && xaTransaction.getCommitTxId() == -1) {
      xaTransaction.setCommitTxId(dataSource.getLastCommittedTxId() + 1);
    }
    xaTransaction.commit();
  }
  if (!xaTransaction.isRecovered()) {
    log.done(xaTransaction.getIdentifier());
  }
 else   if (!log.scanIsComplete()) {
    recoveredDoneRecords.add(xaTransaction.getIdentifier());
  }
  xidMap.remove(xid);
  if (xaTransaction.isRecovered()) {
    recoveredTxCount--;
    checkIfRecoveryComplete();
  }
  return xaTransaction;
}","synchronized XaTransaction commit(Xid xid,boolean onePhase) throws XAException {
  XidStatus status=xidMap.get(xid);
  if (status == null) {
    throw new XAException(""String_Node_Str"" + xid + ""String_Node_Str"");
  }
  TransactionStatus txStatus=status.getTransactionStatus();
  XaTransaction xaTransaction=txStatus.getTransaction();
  if (onePhase) {
    if (!xaTransaction.isReadOnly()) {
      if (!xaTransaction.isRecovered()) {
        xaTransaction.prepare();
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitOnePhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markAsPrepared();
  }
  if (!txStatus.prepared() || txStatus.rollback()) {
    throw new XAException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!xaTransaction.isReadOnly()) {
    if (!xaTransaction.isRecovered()) {
      if (!onePhase) {
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitTwoPhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markCommitStarted();
    if (xaTransaction.isRecovered() && xaTransaction.getCommitTxId() == -1) {
      xaTransaction.setCommitTxId(dataSource.getLastCommittedTxId() + 1);
    }
    xaTransaction.commit();
  }
  if (!xaTransaction.isRecovered()) {
    log.done(xaTransaction.getIdentifier());
  }
 else   if (!log.scanIsComplete() || recoveredTxCount > 0) {
    recoveredDoneRecords.add(xaTransaction.getIdentifier());
  }
  xidMap.remove(xid);
  if (xaTransaction.isRecovered()) {
    recoveredTxCount--;
    checkIfRecoveryComplete();
  }
  return xaTransaction;
}",0.9931506849315068
154846,"@Override public void run(){
  reevaluateMyself();
}","@Override public void run(){
  for (int i=0; i < 5; i++) {
    try {
      reevaluateMyself();
      break;
    }
 catch (    ZooKeeperException e) {
      e.printStackTrace();
    }
catch (    HaCommunicationException e) {
      e.printStackTrace();
    }
  }
}",0.3248407643312102
154847,"public void somethingIsWrong(Exception e){
  new Thread(){
    @Override public void run(){
      reevaluateMyself();
    }
  }
.start();
}","public void somethingIsWrong(Exception e){
  new Thread(){
    @Override public void run(){
      for (int i=0; i < 5; i++) {
        try {
          reevaluateMyself();
          break;
        }
 catch (        ZooKeeperException e) {
          e.printStackTrace();
        }
catch (        HaCommunicationException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
}",0.5225563909774437
154848,"public synchronized void shutdown(){
  if (this.broker != null) {
    this.broker.shutdown();
    this.broker=null;
  }
  internalShutdown();
}","public synchronized void shutdown(){
  if (this.broker != null) {
    this.broker.shutdown();
  }
  internalShutdown();
}",0.9166666666666666
154849,"public void process(WatchedEvent event){
  String path=event.getPath();
  System.out.println(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
  if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
    keeperState=KeeperState.Expired;
    zooKeeper=instantiateZooKeeper();
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
    sequenceNr=setup();
    keeperState=KeeperState.SyncConnected;
    receiver.somethingIsWrong(new Exception());
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
    keeperState=KeeperState.Disconnected;
  }
 else   if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
    System.out.println(""String_Node_Str"");
    receiver.somethingIsWrong(new Exception());
  }
}","public void process(WatchedEvent event){
  String path=event.getPath();
  System.out.println(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
  if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
    keeperState=KeeperState.Expired;
    zooKeeper=instantiateZooKeeper();
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
    sequenceNr=setup();
    keeperState=KeeperState.SyncConnected;
    if (firstSyncConnected) {
      firstSyncConnected=false;
    }
 else {
      receiver.somethingIsWrong(new Exception());
    }
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
    keeperState=KeeperState.Disconnected;
  }
 else   if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
    System.out.println(""String_Node_Str"");
    receiver.somethingIsWrong(new Exception());
  }
}",0.9542981501632208
154850,"private void setMasterChangeWatcher(int currentMasterId){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + MASTER_NOTIFY_CHILD;
    byte[] data=null;
    boolean exists=false;
    try {
      data=zooKeeper.getData(path,true,null);
      exists=true;
      if (data[0] == currentMasterId) {
        return;
      }
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[]{(byte)currentMasterId};
      if (!exists) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      }
      zooKeeper.setData(path,data,-1);
      System.out.println(""String_Node_Str"" + currentMasterId);
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","private void setMasterChangeWatcher(int currentMasterId){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + MASTER_NOTIFY_CHILD;
    byte[] data=null;
    boolean exists=false;
    try {
      data=zooKeeper.getData(path,true,null);
      exists=true;
      int id=ByteBuffer.wrap(data).getInt();
      if (id == currentMasterId) {
        return;
      }
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[4];
      ByteBuffer.wrap(data).putInt(currentMasterId);
      if (!exists) {
        zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      }
 else {
        zooKeeper.setData(path,data,-1);
      }
      System.out.println(""String_Node_Str"" + currentMasterId);
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9497206703910616
154851,"public String getRoot(){
  byte[] rootData=null;
  do {
    try {
      rootData=zooKeeper.getData(rootPath,false,null);
      return rootPath;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
    try {
      byte data[]=new byte[0];
      zooKeeper.create(rootPath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
  }
 while (rootData == null);
  throw new IllegalStateException();
}","public String getRoot(){
  States state=zooKeeper.getState();
  System.out.println(""String_Node_Str"" + state + ""String_Node_Str""+ state.isAlive());
  byte[] rootData=null;
  do {
    try {
      rootData=zooKeeper.getData(rootPath,false,null);
      return rootPath;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
    try {
      byte data[]=new byte[0];
      zooKeeper.create(rootPath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
  }
 while (rootData == null);
  throw new IllegalStateException();
}",0.93815987933635
154852,"@Override protected StandaloneDbCom spawnJvm(File path,int port,int machineId,String... extraArgs) throws Exception {
  List<String> myExtraArgs=new ArrayList<String>();
  myExtraArgs.add(""String_Node_Str"" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID);
  myExtraArgs.add(""String_Node_Str"" + (machineId + 1));
  myExtraArgs.add(""String_Node_Str"" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS);
  myExtraArgs.add(buildZooKeeperServersConfigValue(ZOO_KEEPER_CLUSTER_SIZE));
  myExtraArgs.add(""String_Node_Str"" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER);
  myExtraArgs.add(haServersConfig);
  myExtraArgs.addAll(Arrays.asList(extraArgs));
  StandaloneDbCom com=super.spawnJvm(path,port,machineId,myExtraArgs.toArray(new String[myExtraArgs.size()]));
  com.awaitStarted();
  jvmByMachineId.put(com.getMachineId(),com);
  return com;
}","@Override protected StandaloneDbCom spawnJvm(File path,int port,int machineId,String... extraArgs) throws Exception {
  List<String> myExtraArgs=new ArrayList<String>();
  myExtraArgs.add(""String_Node_Str"" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID);
  myExtraArgs.add(""String_Node_Str"" + (machineId + 1));
  myExtraArgs.add(""String_Node_Str"" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS);
  myExtraArgs.add(buildZooKeeperServersConfigValue(ZOO_KEEPER_CLUSTER_SIZE));
  myExtraArgs.add(""String_Node_Str"" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER);
  myExtraArgs.add(buildHaServerConfigValue(machineId));
  myExtraArgs.addAll(Arrays.asList(extraArgs));
  StandaloneDbCom com=super.spawnJvm(path,port,machineId,myExtraArgs.toArray(new String[myExtraArgs.size()]));
  com.awaitStarted();
  jvmByMachineId.put(com.getMachineId(),com);
  return com;
}",0.9863325740318908
154853,"@Override protected void initializeDbs(int numSlaves,Map<String,String> config) throws Exception {
  this.jvmByMachineId=new HashMap<Integer,StandaloneDbCom>();
  haServersConfig=buildHaServersConfigValue(numSlaves + 1);
  super.initializeDbs(numSlaves,config);
  zooKeeperMasterFetcher=new ClusterManager(buildZooKeeperServersConfigValue(ZOO_KEEPER_CLUSTER_SIZE));
}","@Override protected void initializeDbs(int numSlaves,Map<String,String> config) throws Exception {
  this.jvmByMachineId=new HashMap<Integer,StandaloneDbCom>();
  super.initializeDbs(numSlaves,config);
  zooKeeperMasterFetcher=new ClusterManager(buildZooKeeperServersConfigValue(ZOO_KEEPER_CLUSTER_SIZE));
}",0.9109792284866468
154854,"/** 
 * Returns the disconnected slaves in this cluster so that all slaves which are specified in the HA servers configuration, but not in the zoo keeper cluster will be returned.
 * @return the disconnected slaves in this cluster.
 */
public MachineInfo[] getDisconnectedSlaves(){
  Collection<MachineInfo> infos=new ArrayList<MachineInfo>();
  for (  Map.Entry<Integer,String> entry : haServers.entrySet()) {
    infos.add(new MachineInfo(entry.getKey(),-1,-1,entry.getValue()));
  }
  infos.removeAll(Arrays.asList(getAllMachines()));
  return infos.toArray(new MachineInfo[infos.size()]);
}","/** 
 * Returns the disconnected slaves in this cluster so that all slaves which are specified in the HA servers configuration, but not in the zoo keeper cluster will be returned.
 * @return the disconnected slaves in this cluster.
 */
public MachineInfo[] getDisconnectedSlaves(){
  Collection<MachineInfo> infos=new ArrayList<MachineInfo>();
  for (  Map.Entry<Integer,String> entry : haServers.entrySet()) {
    infos.add(new MachineInfo(entry.getKey(),-1,-1,entry.getValue()));
  }
  infos.removeAll(getAllMachines().values());
  return infos.toArray(new MachineInfo[infos.size()]);
}",0.8629441624365483
154855,"@Override protected String exec(AppCommandParser parser,Session session,Output out) throws Exception {
  HighlyAvailableGraphDatabase db=(HighlyAvailableGraphDatabase)getServer().getDb();
  MasterServer master=db.getMasterServerIfMaster();
  out.println(""String_Node_Str"" + (master != null ? ""String_Node_Str"" : ""String_Node_Str""));
  if (master != null) {
    out.println(""String_Node_Str"");
    for (    Pair<Integer,Collection<Integer>> entry : master.getConnectedClients()) {
      out.println(""String_Node_Str"" + entry.first());
      if (!entry.other().isEmpty()) {
        out.println(""String_Node_Str"" + entry.other());
      }
    }
  }
  return null;
}","@Override protected String exec(AppCommandParser parser,Session session,Output out) throws Exception {
  HighlyAvailableGraphDatabase db=(HighlyAvailableGraphDatabase)getServer().getDb();
  MasterServer master=db.getMasterServerIfMaster();
  out.println(""String_Node_Str"" + (master != null ? ""String_Node_Str"" : ""String_Node_Str""));
  if (master != null) {
    out.println(""String_Node_Str"");
    for (    Pair<Integer,Collection<Integer>> entry : master.getConnectedClients()) {
      out.println(""String_Node_Str"" + entry.first());
      if (entry.other() != null && !entry.other().isEmpty()) {
        out.println(""String_Node_Str"" + entry.other());
      }
    }
  }
  return null;
}",0.9814677538917717
154856,"/** 
 * Returns pairs of: key: machine ID value: collection of ongoing transaction event identifiers
 */
public Iterable<Pair<Integer,Collection<Integer>>> getConnectedClients(){
  Collection<Integer> clients=null;
synchronized (channelsPerClient) {
    clients=new ArrayList<Integer>(channelsPerClient.keySet());
  }
  Map<Integer,Collection<Integer>> txs=((MasterImpl)realMaster).getOngoingTransactions();
  Collection<Pair<Integer,Collection<Integer>>> result=new ArrayList<Pair<Integer,Collection<Integer>>>();
  for (  Integer id : clients) {
    result.add(new Pair<Integer,Collection<Integer>>(id,txs.get(id)));
  }
  return result;
}","/** 
 * Returns pairs of: key: machine ID value: collection of ongoing transaction event identifiers
 */
public Iterable<Pair<Integer,Collection<Integer>>> getConnectedClients(){
  Collection<Integer> clients=null;
synchronized (channelsPerClient) {
    clients=new ArrayList<Integer>(channelsPerClient.keySet());
  }
  Map<Integer,Collection<Integer>> txs=((MasterImpl)realMaster).getOngoingTransactions();
  Collection<Pair<Integer,Collection<Integer>>> result=new ArrayList<Pair<Integer,Collection<Integer>>>();
  for (  Integer id : clients) {
    Collection<Integer> ongoingTxs=txs.get(id);
    result.add(new Pair<Integer,Collection<Integer>>(id,ongoingTxs != null ? ongoingTxs : Collections.<Integer>emptyList()));
  }
  return result;
}",0.9155234657039713
154857,"public void process(WatchedEvent event){
  String path=event.getPath();
  System.out.println(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
  if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
    keeperState=KeeperState.Expired;
    instantiateZooKeeper();
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
    sequenceNr=setup();
    keeperState=KeeperState.SyncConnected;
    receiver.somethingIsWrong(new Exception());
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
    keeperState=KeeperState.Disconnected;
  }
 else   if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
    System.out.println(""String_Node_Str"");
    receiver.somethingIsWrong(new Exception());
  }
}","public void process(WatchedEvent event){
  String path=event.getPath();
  System.out.println(this + ""String_Node_Str"" + new Date()+ ""String_Node_Str""+ event+ ""String_Node_Str""+ path+ ""String_Node_Str"");
  if (path == null && event.getState() == Watcher.Event.KeeperState.Expired) {
    keeperState=KeeperState.Expired;
    zooKeeper=instantiateZooKeeper();
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected) {
    sequenceNr=setup();
    keeperState=KeeperState.SyncConnected;
    receiver.somethingIsWrong(new Exception());
  }
 else   if (path == null && event.getState() == Watcher.Event.KeeperState.Disconnected) {
    keeperState=KeeperState.Disconnected;
  }
 else   if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
    System.out.println(""String_Node_Str"");
    receiver.somethingIsWrong(new Exception());
  }
}",0.9942660550458716
154858,"synchronized XaTransaction commit(Xid xid,boolean onePhase) throws XAException {
  XidStatus status=xidMap.get(xid);
  if (status == null) {
    throw new XAException(""String_Node_Str"" + xid + ""String_Node_Str"");
  }
  TransactionStatus txStatus=status.getTransactionStatus();
  XaTransaction xaTransaction=txStatus.getTransaction();
  if (onePhase) {
    if (!xaTransaction.isReadOnly()) {
      if (!xaTransaction.isRecovered()) {
        xaTransaction.prepare();
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitOnePhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markAsPrepared();
  }
  if (!txStatus.prepared() || txStatus.rollback()) {
    throw new XAException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!xaTransaction.isReadOnly()) {
    if (!xaTransaction.isRecovered()) {
      if (!onePhase) {
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitTwoPhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markCommitStarted();
    if (xaTransaction.isRecovered() && xaTransaction.getCommitTxId() == -1) {
      xaTransaction.setCommitTxId(dataSource.getLastCommittedTxId() + 1);
    }
    xaTransaction.commit();
  }
  log.done(xaTransaction.getIdentifier());
  xidMap.remove(xid);
  if (xaTransaction.isRecovered()) {
    recoveredTxCount--;
    checkIfRecoveryComplete();
  }
  return xaTransaction;
}","synchronized XaTransaction commit(Xid xid,boolean onePhase) throws XAException {
  XidStatus status=xidMap.get(xid);
  if (status == null) {
    throw new XAException(""String_Node_Str"" + xid + ""String_Node_Str"");
  }
  TransactionStatus txStatus=status.getTransactionStatus();
  XaTransaction xaTransaction=txStatus.getTransaction();
  if (onePhase) {
    if (!xaTransaction.isReadOnly()) {
      if (!xaTransaction.isRecovered()) {
        xaTransaction.prepare();
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitOnePhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markAsPrepared();
  }
  if (!txStatus.prepared() || txStatus.rollback()) {
    throw new XAException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!xaTransaction.isReadOnly()) {
    if (!xaTransaction.isRecovered()) {
      if (!onePhase) {
        long txId=txIdGenerator.generate(dataSource,xaTransaction.getIdentifier());
        xaTransaction.setCommitTxId(txId);
        log.commitTwoPhase(xaTransaction.getIdentifier(),xaTransaction.getCommitTxId());
      }
    }
    txStatus.markCommitStarted();
    if (xaTransaction.isRecovered() && xaTransaction.getCommitTxId() == -1) {
      xaTransaction.setCommitTxId(dataSource.getLastCommittedTxId() + 1);
    }
    xaTransaction.commit();
  }
  if (!xaTransaction.isRecovered()) {
    log.done(xaTransaction.getIdentifier());
  }
  xidMap.remove(xid);
  if (xaTransaction.isRecovered()) {
    recoveredTxCount--;
    checkIfRecoveryComplete();
  }
  return xaTransaction;
}",0.9863861386138614
154859,"synchronized XaTransaction commit(Xid xid,boolean onePhase) throws XAException {
  XidStatus status=xidMap.get(xid);
  if (status == null) {
    throw new XAException(""String_Node_Str"" + xid + ""String_Node_Str"");
  }
  TransactionStatus txStatus=status.getTransactionStatus();
  XaTransaction xaTransaction=txStatus.getTransaction();
  if (onePhase) {
    if (!xaTransaction.isReadOnly()) {
      if (!xaTransaction.isRecovered()) {
        xaTransaction.prepare();
        log.commitOnePhase(xaTransaction.getIdentifier());
      }
    }
    txStatus.markAsPrepared();
  }
  if (!txStatus.prepared() || txStatus.rollback()) {
    throw new XAException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!xaTransaction.isReadOnly()) {
    if (!xaTransaction.isRecovered()) {
      if (!onePhase) {
        log.commitTwoPhase(xaTransaction.getIdentifier());
      }
    }
    txStatus.markCommitStarted();
    xaTransaction.commit();
  }
  log.done(xaTransaction.getIdentifier());
  xidMap.remove(xid);
  if (xaTransaction.isRecovered()) {
    recoveredTxCount--;
    checkIfRecoveryComplete();
  }
  return xaTransaction;
}","synchronized XaTransaction commit(Xid xid,boolean onePhase) throws XAException {
  XidStatus status=xidMap.get(xid);
  if (status == null) {
    throw new XAException(""String_Node_Str"" + xid + ""String_Node_Str"");
  }
  TransactionStatus txStatus=status.getTransactionStatus();
  XaTransaction xaTransaction=txStatus.getTransaction();
  if (onePhase) {
    if (!xaTransaction.isReadOnly()) {
      if (!xaTransaction.isRecovered()) {
        xaTransaction.prepare();
        log.commitOnePhase(xaTransaction.getIdentifier());
      }
    }
    txStatus.markAsPrepared();
  }
  if (!txStatus.prepared() || txStatus.rollback()) {
    throw new XAException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!xaTransaction.isReadOnly()) {
    if (!xaTransaction.isRecovered()) {
      if (!onePhase) {
        log.commitTwoPhase(xaTransaction.getIdentifier());
      }
    }
    txStatus.markCommitStarted();
    xaTransaction.commit();
  }
  if (!xaTransaction.isRecovered()) {
    log.done(xaTransaction.getIdentifier());
  }
  xidMap.remove(xid);
  if (xaTransaction.isRecovered()) {
    recoveredTxCount--;
    checkIfRecoveryComplete();
  }
  return xaTransaction;
}",0.9807692307692308
154860,"public synchronized void shutdown(){
  if (inShutdown)   return;
  try {
    if (graphDbInstance.started()) {
      sendShutdownEvent();
      extensions.shutdown(log);
    }
    graphDbInstance.shutdown();
  }
  finally {
    inShutdown=false;
  }
}","public synchronized void shutdown(){
  if (inShutdown)   return;
  inShutdown=true;
  try {
    if (graphDbInstance.started()) {
      sendShutdownEvent();
      extensions.shutdown(log);
    }
    graphDbInstance.shutdown();
  }
  finally {
    inShutdown=false;
  }
}",0.9633911368015414
154861,"/** 
 * A non-standard way of creating an embedded   {@link GraphDatabaseService}with a set of configuration parameters. Will most likely be removed in future releases.
 * @param storeDir the store directory for the db files
 * @param config configuration parameters
 */
public EmbeddedGraphDbImpl(String storeDir,Map<String,String> config,GraphDatabaseService graphDbService){
  this.storeDir=storeDir;
  graphDbInstance=new GraphDbInstance(storeDir,true);
  final Map<Object,Object> params=graphDbInstance.start(graphDbService,config,kernelPanicEventGenerator,new SyncHookFactory());
  nodeManager=graphDbInstance.getConfig().getGraphDbModule().getNodeManager();
  this.graphDbService=graphDbService;
  this.extensions=new KernelExtension.KernelData(instanceId){
    @Override public String version(){
      return KERNEL_VERSION;
    }
    @Override public Config getConfig(){
      return EmbeddedGraphDbImpl.this.getConfig();
    }
    @Override public Map<Object,Object> getConfigParams(){
      return params;
    }
    @Override public GraphDatabaseService graphDatabase(){
      return EmbeddedGraphDbImpl.this.graphDbService;
    }
  }
;
  initializeExtensions();
}","/** 
 * A non-standard way of creating an embedded   {@link GraphDatabaseService}with a set of configuration parameters. Will most likely be removed in future releases.
 * @param storeDir the store directory for the db files
 * @param config configuration parameters
 */
public EmbeddedGraphDbImpl(String storeDir,Map<String,String> config,GraphDatabaseService graphDbService){
  this.storeDir=storeDir;
  graphDbInstance=new GraphDbInstance(storeDir,true);
  final Map<Object,Object> params=graphDbInstance.start(graphDbService,config,kernelPanicEventGenerator,new SyncHookFactory());
  nodeManager=graphDbInstance.getConfig().getGraphDbModule().getNodeManager();
  this.graphDbService=graphDbService;
  this.extensions=new KernelExtension.KernelData(){
    @Override public String version(){
      return KERNEL_VERSION;
    }
    @Override public Config getConfig(){
      return EmbeddedGraphDbImpl.this.getConfig();
    }
    @Override public Map<Object,Object> getConfigParams(){
      return params;
    }
    @Override public GraphDatabaseService graphDatabase(){
      return EmbeddedGraphDbImpl.this.graphDbService;
    }
  }
;
  extensions.startup(log);
}",0.9850491243058522
154862,"public void shutdown(){
  if (graphDbInstance.started()) {
    sendShutdownEvent();
    extensions.shutdown(log);
  }
  graphDbInstance.shutdown();
}","public synchronized void shutdown(){
  if (inShutdown)   return;
  try {
    if (graphDbInstance.started()) {
      sendShutdownEvent();
      extensions.shutdown(log);
    }
    graphDbInstance.shutdown();
  }
  finally {
    inShutdown=false;
  }
}",0.731829573934837
154863,"KernelData(String instanceId){
  this.instanceId=instanceId;
}","KernelData(){
  instanceId=newInstance(this);
}",0.6238532110091743
154864,"void shutdown(Logger log){
  for (  KernelExtension loaded : state.keySet()) {
    try {
      loaded.unload(this);
    }
 catch (    Exception ex) {
      log.warning(""String_Node_Str"" + loaded + ""String_Node_Str""+ ex);
    }
  }
}","synchronized void shutdown(Logger log){
  for (  KernelExtension loaded : state.keySet()) {
    try {
      loaded.unload(this);
    }
 catch (    Exception ex) {
      log.warning(""String_Node_Str"" + loaded + ""String_Node_Str""+ ex);
    }
  }
  removeInstance(instanceId);
}",0.9112426035502958
154865,"private void setMasterChangeWatcher(int currentMasterId){
  try {
    String root=getRoot();
    String path=root + MASTER_NOTIFY_CHILD;
    byte[] data=null;
    try {
      data=zooKeeper.getData(path,true,null);
      if (data[0] == currentMasterId) {
        return;
      }
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[]{(byte)currentMasterId};
      zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      zooKeeper.setData(path,data,-1);
      System.out.println(""String_Node_Str"" + currentMasterId);
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","private void setMasterChangeWatcher(int currentMasterId){
  try {
    String root=getRoot();
    String path=root + ""String_Node_Str"" + MASTER_NOTIFY_CHILD;
    byte[] data=null;
    try {
      data=zooKeeper.getData(path,true,null);
      if (data[0] == currentMasterId) {
        return;
      }
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
    try {
      data=new byte[]{(byte)currentMasterId};
      zooKeeper.create(path,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      zooKeeper.setData(path,data,-1);
      System.out.println(""String_Node_Str"" + currentMasterId);
      zooKeeper.getData(path,true,null);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9903194578896418
154866,"public synchronized int getMaster(){
  waitForSyncConnected();
  try {
    Map<Integer,Pair<Integer,Long>> rawData=new HashMap<Integer,Pair<Integer,Long>>();
    String root=getRoot();
    List<String> children=zooKeeper.getChildren(root,false);
    int currentMasterId=-1;
    int lowestSeq=Integer.MAX_VALUE;
    long highestTxId=-1;
    for (    String child : children) {
      int index=child.indexOf('_');
      int id=Integer.parseInt(child.substring(0,index));
      int seq=Integer.parseInt(child.substring(index + 1));
      try {
        byte[] data=zooKeeper.getData(root + ""String_Node_Str"" + child,false,null);
        ByteBuffer buf=ByteBuffer.wrap(data);
        long tx=buf.getLong();
        if (rawData.put(id,new Pair<Integer,Long>(seq,tx)) != null) {
          System.out.println(""String_Node_Str"" + id + ""String_Node_Str"");
        }
        if (tx >= highestTxId) {
          if (tx > highestTxId || seq < lowestSeq) {
            currentMasterId=id;
            lowestSeq=seq;
          }
          highestTxId=tx;
        }
      }
 catch (      KeeperException inner) {
        if (inner.code() != KeeperException.Code.NONODE) {
          throw new ZooKeeperException(""String_Node_Str"",inner);
        }
      }
    }
    System.out.println(""String_Node_Str"" + currentMasterId + ""String_Node_Str""+ rawData);
    setMasterChangeWatcher(currentMasterId);
    return currentMasterId;
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","public synchronized int getMaster(){
  waitForSyncConnected();
  try {
    Map<Integer,Pair<Integer,Long>> rawData=new HashMap<Integer,Pair<Integer,Long>>();
    String root=getRoot();
    List<String> children=zooKeeper.getChildren(root,false);
    int currentMasterId=-1;
    int lowestSeq=Integer.MAX_VALUE;
    long highestTxId=-1;
    for (    String child : children) {
      if (child.equals(MASTER_NOTIFY_CHILD)) {
        continue;
      }
      int index=child.indexOf('_');
      int id=Integer.parseInt(child.substring(0,index));
      int seq=Integer.parseInt(child.substring(index + 1));
      try {
        byte[] data=zooKeeper.getData(root + ""String_Node_Str"" + child,false,null);
        ByteBuffer buf=ByteBuffer.wrap(data);
        long tx=buf.getLong();
        if (rawData.put(id,new Pair<Integer,Long>(seq,tx)) != null) {
          System.out.println(""String_Node_Str"" + id + ""String_Node_Str"");
        }
        if (tx >= highestTxId) {
          if (tx > highestTxId || seq < lowestSeq) {
            currentMasterId=id;
            lowestSeq=seq;
          }
          highestTxId=tx;
        }
      }
 catch (      KeeperException inner) {
        if (inner.code() != KeeperException.Code.NONODE) {
          throw new ZooKeeperException(""String_Node_Str"",inner);
        }
      }
    }
    System.out.println(""String_Node_Str"" + currentMasterId + ""String_Node_Str""+ rawData);
    setMasterChangeWatcher(currentMasterId);
    return currentMasterId;
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9779921615917998
154867,"private void startAsMaster(){
  this.broker=brokerFactory.create();
  this.masterServer=(MasterServer)broker.instantiateMasterServer(this);
  this.localGraph=new EmbeddedGraphDbImpl(storeDir,config,this,CommonFactories.defaultLockManagerFactory(),new MasterIdGeneratorFactory(),CommonFactories.defaultRelationshipTypeCreator(),CommonFactories.defaultTxIdGeneratorFactory(),CommonFactories.defaultTxRollbackHook(),new ZooKeeperLastCommittedTxIdSetter(broker));
  instantiateIndexIfNeeded();
  instantiateAutoUpdatePullerIfConfigSaysSo();
}","private void startAsMaster(){
  this.broker=brokerFactory.create();
  this.localGraph=new EmbeddedGraphDbImpl(storeDir,config,this,CommonFactories.defaultLockManagerFactory(),new MasterIdGeneratorFactory(),CommonFactories.defaultRelationshipTypeCreator(),CommonFactories.defaultTxIdGeneratorFactory(),CommonFactories.defaultTxRollbackHook(),new ZooKeeperLastCommittedTxIdSetter(broker));
  this.masterServer=(MasterServer)broker.instantiateMasterServer(this);
  instantiateIndexIfNeeded();
  instantiateAutoUpdatePullerIfConfigSaysSo();
}",0.8661710037174721
154868,"private Iterable<Node> get(IndexProvider indexes,AppCommandParser parser,Session session,Output out){
  String index=parser.arguments().get(0);
  String key=parser.arguments().get(1);
  String value=parser.arguments().get(2);
  return indexes.nodeIndex(index,emptyConfig()).get(key,value);
}","private Iterable<Node> get(IndexProvider indexes,AppCommandParser parser){
  String index=parser.arguments().get(0);
  String key=parser.arguments().get(1);
  String value=parser.arguments().get(2);
  return indexes.nodeIndex(index,emptyConfig()).get(key,value);
}",0.9513513513513514
154869,"private Iterable<Node> query(IndexProvider indexes,AppCommandParser parser,Session session,Output out){
  String index=parser.arguments().get(0);
  String query=parser.arguments().get(1);
  return indexes.nodeIndex(index,emptyConfig()).query(query);
}","private Iterable<Node> query(IndexProvider indexes,AppCommandParser parser){
  String index=parser.arguments().get(0);
  String query=parser.arguments().get(1);
  return indexes.nodeIndex(index,emptyConfig()).query(query);
}",0.3326315789473684
154870,"private void index(IndexProvider indexes,AppCommandParser parser,Session session,Output out) throws ShellException {
  Node node=getCurrent(session).asNode();
  String index=parser.arguments().get(0);
  String key=parser.arguments().get(0);
  Object value=parser.arguments().size() > 1 ? parser.arguments().get(1) : node.getProperty(key,null);
  if (value == null) {
    throw new ShellException(""String_Node_Str"");
  }
  indexes.nodeIndex(index,emptyConfig()).add(node,key,value);
}","private void index(IndexProvider indexes,AppCommandParser parser,Session session) throws ShellException {
  Node node=getCurrent(session).asNode();
  String index=parser.arguments().get(0);
  String key=parser.arguments().get(1);
  Object value=parser.arguments().size() > 2 ? parser.arguments().get(2) : node.getProperty(key,null);
  if (value == null) {
    throw new ShellException(""String_Node_Str"");
  }
  indexes.nodeIndex(index,emptyConfig()).add(node,key,value);
}",0.9821989528795813
154871,"@Override protected String exec(AppCommandParser parser,Session session,Output out) throws ShellException, RemoteException {
  IndexProvider indexes=indexes();
  boolean doCd=parser.options().containsKey(""String_Node_Str"");
  boolean doLs=parser.options().containsKey(""String_Node_Str"");
  boolean query=parser.options().containsKey(""String_Node_Str"");
  boolean get=parser.options().containsKey(""String_Node_Str"") || query || doCd|| doLs;
  boolean index=parser.options().containsKey(""String_Node_Str"");
  boolean remove=parser.options().containsKey(""String_Node_Str"");
  int count=boolCount(get,index,remove);
  if (count != 1) {
    throw new ShellException(""String_Node_Str"");
  }
  if (get) {
    String commandToRun=parser.options().get(""String_Node_Str"");
    Collection<String> commandsToRun=new ArrayList<String>();
    boolean specialCommand=false;
    if (doCd || doLs) {
      specialCommand=true;
      if (doCd) {
        commandsToRun.add(""String_Node_Str"");
      }
 else       if (doLs) {
        commandsToRun.add(""String_Node_Str"");
      }
    }
 else     if (commandToRun != null) {
      commandsToRun.addAll(Arrays.asList(commandToRun.split(Pattern.quote(""String_Node_Str""))));
    }
    Iterable<Node> result;
    if (query) {
      result=query(indexes,parser,session,out);
    }
 else {
      result=get(indexes,parser,session,out);
    }
    for (    Node node : result) {
      printAndInterpretTemplateLines(commandsToRun,false,!specialCommand,node,getServer(),session,out);
    }
  }
 else   if (index) {
    index(indexes,parser,session,out);
  }
 else   if (remove) {
    remove(indexes,parser,session,out);
  }
  return null;
}","@Override protected String exec(AppCommandParser parser,Session session,Output out) throws ShellException, RemoteException {
  IndexProvider indexes=indexes();
  boolean doCd=parser.options().containsKey(""String_Node_Str"");
  boolean doLs=parser.options().containsKey(""String_Node_Str"");
  boolean query=parser.options().containsKey(""String_Node_Str"");
  boolean get=parser.options().containsKey(""String_Node_Str"") || query || doCd|| doLs;
  boolean index=parser.options().containsKey(""String_Node_Str"");
  boolean remove=parser.options().containsKey(""String_Node_Str"");
  int count=boolCount(get,index,remove);
  if (count != 1) {
    throw new ShellException(""String_Node_Str"");
  }
  if (get) {
    String commandToRun=parser.options().get(""String_Node_Str"");
    Collection<String> commandsToRun=new ArrayList<String>();
    boolean specialCommand=false;
    if (doCd || doLs) {
      specialCommand=true;
      if (doCd) {
        commandsToRun.add(""String_Node_Str"");
      }
 else       if (doLs) {
        commandsToRun.add(""String_Node_Str"");
      }
    }
 else     if (commandToRun != null) {
      commandsToRun.addAll(Arrays.asList(commandToRun.split(Pattern.quote(""String_Node_Str""))));
    }
    Iterable<Node> result;
    if (query) {
      result=query(indexes,parser);
    }
 else {
      result=get(indexes,parser);
    }
    for (    Node node : result) {
      printAndInterpretTemplateLines(commandsToRun,false,!specialCommand,node,getServer(),session,out);
    }
  }
 else   if (index) {
    index(indexes,parser,session);
  }
 else   if (remove) {
    remove(indexes,parser,session);
  }
  return null;
}",0.916058394160584
154872,"private void remove(IndexProvider indexes,AppCommandParser parser,Session session,Output out) throws ShellException {
  Node node=getCurrent(session).asNode();
  String index=parser.arguments().get(0);
  String key=parser.arguments().get(0);
  Object value=parser.arguments().size() > 1 ? parser.arguments().get(1) : node.getProperty(key,null);
  if (value == null) {
    throw new ShellException(""String_Node_Str"");
  }
  indexes.nodeIndex(index,emptyConfig()).remove(node,key,value);
}","private void remove(IndexProvider indexes,AppCommandParser parser,Session session) throws ShellException {
  Node node=getCurrent(session).asNode();
  String index=parser.arguments().get(0);
  String key=parser.arguments().get(0);
  Object value=parser.arguments().size() > 1 ? parser.arguments().get(1) : node.getProperty(key,null);
  if (value == null) {
    throw new ShellException(""String_Node_Str"");
  }
  indexes.nodeIndex(index,emptyConfig()).remove(node,key,value);
}",0.988577362409138
154873,"@Override protected void shutdown(){
  this.tryUnexport(this.out);
}","@Override protected void shutdown(){
  this.tryUnexport(this.out);
  if (session.writer != null)   this.tryUnexport(session.writer);
}",0.6732673267326733
154874,"public void set(String key,Serializable value){
  if (value == null) {
    this.properties.remove(key);
  }
 else {
    this.properties.put(key,value);
  }
}","public void set(String key,Serializable value){
  try {
    if (writer != null)     writer.set(key,value);
  }
 catch (  RemoteException swallowed) {
  }
  setProperty(properties,key,value);
}",0.5329512893982808
154875,"public synchronized int getMaster(){
  try {
    String root=getRoot();
    List<String> children=zooKeeper.getChildren(root,false);
    int currentMasterId=-1;
    int lowestSeq=Integer.MAX_VALUE;
    long highestTxId=-1;
    for (    String child : children) {
      int index=child.indexOf('_');
      int id=Integer.parseInt(child.substring(0,index));
      int seq=Integer.parseInt(child.substring(index + 1));
      try {
        byte[] data=zooKeeper.getData(root + ""String_Node_Str"" + child,false,null);
        ByteBuffer buf=ByteBuffer.wrap(data);
        long tx=buf.getLong();
        if (tx >= highestTxId) {
          highestTxId=tx;
          if (seq < lowestSeq) {
            currentMasterId=id;
            lowestSeq=seq;
          }
        }
      }
 catch (      KeeperException inner) {
        if (inner.code() != KeeperException.Code.NONODE) {
          throw new ZooKeeperException(""String_Node_Str"",inner);
        }
      }
    }
    return currentMasterId;
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","public synchronized int getMaster(){
  try {
    String root=getRoot();
    List<String> children=zooKeeper.getChildren(root,false);
    int currentMasterId=-1;
    int lowestSeq=Integer.MAX_VALUE;
    long highestTxId=-1;
    for (    String child : children) {
      int index=child.indexOf('_');
      int id=Integer.parseInt(child.substring(0,index));
      int seq=Integer.parseInt(child.substring(index + 1));
      try {
        byte[] data=zooKeeper.getData(root + ""String_Node_Str"" + child,false,null);
        ByteBuffer buf=ByteBuffer.wrap(data);
        long tx=buf.getLong();
        if (tx >= highestTxId) {
          if (tx > highestTxId || seq < lowestSeq) {
            currentMasterId=id;
            lowestSeq=seq;
          }
          highestTxId=tx;
        }
      }
 catch (      KeeperException inner) {
        if (inner.code() != KeeperException.Code.NONODE) {
          throw new ZooKeeperException(""String_Node_Str"",inner);
        }
      }
    }
    return currentMasterId;
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9760330578512396
154876,"public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (lastCommittedTxIdSetter != null && !isInRecoveryMode() && txId == getLastCommittedTx() + 1) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
}","public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (lastCommittedTxIdSetter != null && txId == getLastCommittedTx() + 1) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
}",0.972972972972973
154877,"@Override protected void rebuildIdGenerator(){
  logger.fine(""String_Node_Str"" + getStorageFileName() + ""String_Node_Str"");
  closeIdGenerator();
  File file=new File(getStorageFileName() + ""String_Node_Str"");
  if (file.exists()) {
    boolean success=file.delete();
    assert success;
  }
  createIdGenerator(getStorageFileName() + ""String_Node_Str"");
  openIdGenerator();
  FileChannel fileChannel=getFileChannel();
  long highId=-1;
  int recordSize=getRecordSize();
  try {
    long fileSize=fileChannel.size();
    ByteBuffer byteBuffer=ByteBuffer.wrap(new byte[recordSize]);
    for (int i=0; i * recordSize < fileSize; i++) {
      fileChannel.read(byteBuffer,i * recordSize);
      byteBuffer.flip();
      byte inUse=byteBuffer.get();
      byteBuffer.flip();
      if (inUse != Record.IN_USE.byteValue()) {
        byteBuffer.clear();
        byteBuffer.put(Record.IN_USE.byteValue()).putInt(Record.RESERVED.intValue());
        byteBuffer.flip();
        fileChannel.write(byteBuffer,i * recordSize);
        byteBuffer.clear();
      }
 else {
        highId=i;
      }
      nextId();
    }
    highId++;
    fileChannel.truncate(highId * recordSize);
  }
 catch (  IOException e) {
    throw new UnderlyingStorageException(""String_Node_Str"" + getStorageFileName(),e);
  }
  setHighId(highId);
  logger.fine(""String_Node_Str"" + getStorageFileName() + ""String_Node_Str""+ getHighId());
  closeIdGenerator();
  openIdGenerator();
}","@Override protected void rebuildIdGenerator(){
  logger.fine(""String_Node_Str"" + getStorageFileName() + ""String_Node_Str"");
  closeIdGenerator();
  File file=new File(getStorageFileName() + ""String_Node_Str"");
  if (file.exists()) {
    boolean success=file.delete();
    assert success;
  }
  createIdGenerator(getStorageFileName() + ""String_Node_Str"");
  openIdGenerator();
  FileChannel fileChannel=getFileChannel();
  long highId=-1;
  int recordSize=getRecordSize();
  try {
    long fileSize=fileChannel.size();
    ByteBuffer byteBuffer=ByteBuffer.wrap(new byte[recordSize]);
    for (int i=0; i * recordSize < fileSize; i++) {
      fileChannel.read(byteBuffer,i * recordSize);
      byteBuffer.flip();
      byte inUse=byteBuffer.get();
      byteBuffer.flip();
      if (inUse != Record.IN_USE.byteValue()) {
        byteBuffer.clear();
        byteBuffer.put(Record.IN_USE.byteValue()).putInt(Record.RESERVED.intValue());
        byteBuffer.flip();
        fileChannel.write(byteBuffer,i * recordSize);
        byteBuffer.clear();
      }
 else {
        highId=i;
      }
    }
    highId++;
    fileChannel.truncate(highId * recordSize);
  }
 catch (  IOException e) {
    throw new UnderlyingStorageException(""String_Node_Str"" + getStorageFileName(),e);
  }
  setHighId(highId);
  logger.fine(""String_Node_Str"" + getStorageFileName() + ""String_Node_Str""+ getHighId());
  closeIdGenerator();
  openIdGenerator();
}",0.994425087108014
154878,"public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndApplyAndWriteEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start entry=logApplier.startEntry;
  if (entry == null) {
    throw new IOException(""String_Node_Str"");
  }
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(entry.getIdentifier(),nextTxId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=entry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  LogEntry.Done done=new LogEntry.Done(entry.getIdentifier());
  LogIoUtils.writeLogEntry(done,writeBuffer);
  log.info(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ ""String_Node_Str"");
}","public synchronized void applyTransactionWithoutTxId(ReadableByteChannel byteChannel,long nextTxId) throws IOException {
  if (nextTxId != (xaTf.getLastCommittedTx() + 1)) {
    throw new IllegalStateException(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ (xaTf.getCurrentVersion() + 1));
  }
  log.fine(""String_Node_Str"" + logVersion + ""String_Node_Str""+ nextTxId+ ""String_Node_Str"");
  long logEntriesFound=0;
  LogApplier logApplier=new LogApplier(byteChannel);
  int xidIdent=getNextIdentifier();
  while (logApplier.readAndApplyAndWriteEntry(xidIdent)) {
    logEntriesFound++;
  }
  byteChannel.close();
  LogEntry.Start entry=logApplier.startEntry;
  if (entry == null) {
    throw new IOException(""String_Node_Str"");
  }
  LogEntry.OnePhaseCommit commit=new LogEntry.OnePhaseCommit(entry.getIdentifier(),nextTxId);
  LogIoUtils.writeLogEntry(commit,writeBuffer);
  Xid xid=entry.getXid();
  try {
    XaTransaction xaTx=xaRm.getXaTransaction(xid);
    xaTx.setCommitTxId(nextTxId);
    xaRm.commit(xid,true);
  }
 catch (  XAException e) {
    e.printStackTrace();
    throw new IOException(e.getMessage());
  }
  log.info(""String_Node_Str"" + nextTxId + ""String_Node_Str""+ ""String_Node_Str"");
}",0.9520031733439112
154879,"public DynamicStringStore(String fileName,Map<?,?> config){
  super(fileName,config);
}","public DynamicStringStore(String fileName,Map<?,?> config,IdType idType){
  super(fileName,config);
  this.idType=idType;
}",0.8285714285714286
154880,"@Override protected IdType getIdType(){
  return IdType.STRING_BLOCK;
}","@Override protected IdType getIdType(){
  return idType;
}",0.8837209302325582
154881,"protected void initStorage(){
  keyPropertyStore=new DynamicStringStore(getStorageFileName() + ""String_Node_Str"",getConfig());
}","protected void initStorage(){
  keyPropertyStore=new DynamicStringStore(getStorageFileName() + ""String_Node_Str"",getConfig(),IdType.PROPERTY_INDEX_BLOCK);
}",0.9014084507042254
154882,"/** 
 * See   {@link AbstractStore#AbstractStore(String)}
 */
@Override protected void initStorage(){
  stringPropertyStore=new DynamicStringStore(getStorageFileName() + ""String_Node_Str"",getConfig());
  propertyIndexStore=new PropertyIndexStore(getStorageFileName() + ""String_Node_Str"",getConfig());
  arrayPropertyStore=new DynamicArrayStore(getStorageFileName() + ""String_Node_Str"",getConfig());
}","/** 
 * See   {@link AbstractStore#AbstractStore(String)}
 */
@Override protected void initStorage(){
  stringPropertyStore=new DynamicStringStore(getStorageFileName() + ""String_Node_Str"",getConfig(),IdType.STRING_BLOCK);
  propertyIndexStore=new PropertyIndexStore(getStorageFileName() + ""String_Node_Str"",getConfig());
  arrayPropertyStore=new DynamicArrayStore(getStorageFileName() + ""String_Node_Str"",getConfig());
}",0.975609756097561
154883,"@Override protected void initStorage(){
  typeNameStore=new DynamicStringStore(getStorageFileName() + ""String_Node_Str"",getConfig());
}","@Override protected void initStorage(){
  typeNameStore=new DynamicStringStore(getStorageFileName() + ""String_Node_Str"",getConfig(),IdType.RELATIONSHIP_TYPE_BLOCK);
}",0.8970099667774086
154884,"public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (isStarted && lastCommittedTxIdSetter != null && txId == getLastCommittedTx() + 1) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
}","public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (isStarted && lastCommittedTxIdSetter != null) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
}",0.8753056234718827
154885,"public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (lastCommittedTxIdSetter != null) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
}","public synchronized void setLastCommittedTx(long txId){
  long current=getRecord(3);
  if ((current + 1) != txId && !isInRecoveryMode()) {
    throw new InvalidRecordException(""String_Node_Str"" + txId + ""String_Node_Str""+ current+ ""String_Node_Str"");
  }
  setRecord(3,txId);
  if (lastCommittedTxIdSetter != null && !isInRecoveryMode() && txId == getLastCommittedTx() + 1) {
    lastCommittedTxIdSetter.setLastCommittedTxId(txId);
  }
}",0.9276073619631902
154886,"private Pair<String,Integer> getHaServer(int machineId){
  String host=haServers.get(getMyMachineId());
  int pos=host.indexOf(""String_Node_Str"");
  return new Pair<String,Integer>(host.substring(0,pos),Integer.parseInt(host.substring(pos + 1)));
}","private Pair<String,Integer> getHaServer(int machineId){
  String host=haServers.get(machineId);
  int pos=host.indexOf(""String_Node_Str"");
  return new Pair<String,Integer>(host.substring(0,pos),Integer.parseInt(host.substring(pos + 1)));
}",0.98159509202454
154887,"public NeoStoreUtil(String storeDir){
  try {
    FileChannel fileChannel=new RandomAccessFile(storeDir + ""String_Node_Str"",""String_Node_Str"").getChannel();
    ByteBuffer buf=ByteBuffer.allocate(32);
    if (fileChannel.read(buf) != 32) {
      throw new RuntimeException(""String_Node_Str"");
    }
    buf.flip();
    creationTime=buf.getLong();
    storeId=buf.getLong();
    buf.getLong();
    txId=buf.getLong();
    fileChannel.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public NeoStoreUtil(String storeDir){
  try {
    FileChannel fileChannel=new RandomAccessFile(storeDir + ""String_Node_Str"",""String_Node_Str"").getChannel();
    ByteBuffer buf=ByteBuffer.allocate(4 * 9);
    if (fileChannel.read(buf) != 4 * 9) {
      throw new RuntimeException(""String_Node_Str"");
    }
    buf.flip();
    buf.get();
    creationTime=buf.getLong();
    buf.get();
    storeId=buf.getLong();
    buf.get();
    buf.getLong();
    buf.get();
    txId=buf.getLong();
    fileChannel.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9322344322344324
154888,"private String getRoot(){
  String rootPath=""String_Node_Str"" + storeCreationTime + ""String_Node_Str""+ storeId;
  byte[] rootData=null;
  do {
    try {
      rootData=zooKeeper.getData(rootPath,false,null);
      ByteBuffer buf=ByteBuffer.wrap(rootData);
      globalCommittedTx=buf.getLong();
      if (globalCommittedTx < committedTx) {
        throw new IllegalStateException(""String_Node_Str"" + globalCommittedTx + ""String_Node_Str""+ machineId+ ""String_Node_Str""+ committedTx);
      }
      return rootPath;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
    try {
      byte data[]=new byte[8];
      ByteBuffer buf=ByteBuffer.wrap(data);
      buf.putLong(committedTx);
      zooKeeper.create(rootPath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
  }
 while (rootData == null);
  throw new IllegalStateException();
}","private String getRoot(){
  String rootPath=""String_Node_Str"" + storeCreationTime + ""String_Node_Str""+ storeId;
  byte[] rootData=null;
  do {
    try {
      rootData=zooKeeper.getData(rootPath,false,null);
      return rootPath;
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NONODE) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
    try {
      byte data[]=new byte[0];
      zooKeeper.create(rootPath,data,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
 catch (    KeeperException e) {
      if (e.code() != KeeperException.Code.NODEEXISTS) {
        throw new ZooKeeperException(""String_Node_Str"",e);
      }
    }
catch (    InterruptedException e) {
      Thread.interrupted();
      throw new ZooKeeperException(""String_Node_Str"",e);
    }
  }
 while (rootData == null);
  throw new IllegalStateException();
}",0.2134222592746978
154889,"public synchronized int getMaster(){
  try {
    String root=getRoot();
    List<String> children=zooKeeper.getChildren(root,false);
    int currentMasterId=-1;
    int lowestSeq=Integer.MAX_VALUE;
    for (    String child : children) {
      int index=child.indexOf('_');
      int id=Integer.parseInt(child.substring(0,index));
      int seq=Integer.parseInt(child.substring(index + 1));
      try {
        byte[] data=zooKeeper.getData(root + ""String_Node_Str"" + child,false,null);
        ByteBuffer buf=ByteBuffer.wrap(data);
        long tx=buf.getLong();
        if (tx == globalCommittedTx) {
          if (seq < lowestSeq) {
            currentMasterId=id;
            lowestSeq=seq;
          }
        }
      }
 catch (      KeeperException inner) {
        if (inner.code() != KeeperException.Code.NONODE) {
          throw new ZooKeeperException(""String_Node_Str"",inner);
        }
      }
    }
    return currentMasterId;
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}","public synchronized int getMaster(){
  try {
    String root=getRoot();
    List<String> children=zooKeeper.getChildren(root,false);
    int currentMasterId=-1;
    int lowestSeq=Integer.MAX_VALUE;
    long highestTxId=-1;
    for (    String child : children) {
      int index=child.indexOf('_');
      int id=Integer.parseInt(child.substring(0,index));
      int seq=Integer.parseInt(child.substring(index + 1));
      try {
        byte[] data=zooKeeper.getData(root + ""String_Node_Str"" + child,false,null);
        ByteBuffer buf=ByteBuffer.wrap(data);
        long tx=buf.getLong();
        if (tx > highestTxId) {
          highestTxId=tx;
          if (seq < lowestSeq) {
            currentMasterId=id;
            lowestSeq=seq;
          }
        }
      }
 catch (      KeeperException inner) {
        if (inner.code() != KeeperException.Code.NONODE) {
          throw new ZooKeeperException(""String_Node_Str"",inner);
        }
      }
    }
    return currentMasterId;
  }
 catch (  KeeperException e) {
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.interrupted();
    throw new ZooKeeperException(""String_Node_Str"",e);
  }
}",0.9660152931180968
154890,"public int getMyMachineId(){
  return zooClient.getMaster();
}","public int getMyMachineId(){
  return machineId;
}",0.7678571428571429
154891,"public void setHighId(long id){
  this.highestIdInUse=id;
}","public void setHighId(long id){
  this.highestIdInUse=id;
  this.localIdGenerator.setHighId(id);
}",0.7515923566878981
154892,"private void updateLocalIdGenerator(){
  long localHighId=this.localIdGenerator.getHighId();
  if (this.highestIdInUse > localHighId) {
    this.localIdGenerator.setHighId(this.highestIdInUse);
    System.out.println(""String_Node_Str"" + localHighId);
  }
}","private void updateLocalIdGenerator(){
  long localHighId=this.localIdGenerator.getHighId();
  if (this.highestIdInUse > localHighId) {
    this.localIdGenerator.setHighId(this.highestIdInUse);
  }
}",0.8747252747252747
154893,"@Test public void testMultipleSlaves(){
  initializeDbs(3);
  GraphDatabaseService db1=haDbs.get(0);
  GraphDatabaseService db2=haDbs.get(1);
  GraphDatabaseService db3=haDbs.get(2);
  Transaction tx=db1.beginTx();
  try {
    Node node=db1.createNode();
    db1.getReferenceNode().createRelationshipTo(node,REL_TYPE);
    tx.success();
  }
  finally {
    tx.finish();
  }
  tx=db2.beginTx();
  try {
    db2.getReferenceNode().removeProperty(""String_Node_Str"");
    Node node=db2.getReferenceNode().getSingleRelationship(REL_TYPE,Direction.OUTGOING).getEndNode();
    node.setProperty(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
  finally {
    tx.finish();
  }
  ((HighlyAvailableGraphDatabase)db1).pullUpdates();
  ((HighlyAvailableGraphDatabase)db3).pullUpdates();
  verificationFilter=new Predicate<Integer>(){
    public boolean accept(    Integer item){
      return item == 2;
    }
  }
;
}","@Test public void testMultipleSlaves(){
  initializeDbs(3);
  GraphDatabaseService db1=haDbs.get(0);
  GraphDatabaseService db2=haDbs.get(1);
  GraphDatabaseService db3=haDbs.get(2);
  Transaction tx=db1.beginTx();
  try {
    Node node=db1.createNode();
    db1.getReferenceNode().createRelationshipTo(node,REL_TYPE);
    tx.success();
  }
  finally {
    tx.finish();
  }
  tx=db2.beginTx();
  try {
    db2.getReferenceNode().removeProperty(""String_Node_Str"");
    Node node=db2.getReferenceNode().getSingleRelationship(REL_TYPE,Direction.OUTGOING).getEndNode();
    node.setProperty(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
  finally {
    tx.finish();
  }
  ((HighlyAvailableGraphDatabase)db1).pullUpdates();
  ((HighlyAvailableGraphDatabase)db3).pullUpdates();
}",0.9247943595769684
154894,"public boolean accept(Integer item){
  return item == 2;
}","public boolean accept(Integer item){
  return true;
}",0.918918918918919
154895,"@Override public void applyLog(ReadableByteChannel byteChannel) throws IOException {
  logApplied=true;
  xaContainer.getLogicalLog().applyLog(byteChannel);
}","@Override public void applyLog(ReadableByteChannel byteChannel) throws IOException {
  logApplied=true;
  super.applyLog(byteChannel);
}",0.9047619047619048
154896,"/** 
 * Creates a data source with minimum (no memory mapped) configuration.
 * @param neoStoreFileName The file name of the store
 * @param logicalLogPath The file name of the logical log
 * @throws IOException If unable to open store
 */
public NeoStoreXaDataSource(String neoStoreFileName,String logicalLogPath,LockManager lockManager,LockReleaser lockReleaser) throws IOException, InstantiationException {
  super(null);
  this.readOnly=false;
  this.lockManager=lockManager;
  this.lockReleaser=lockReleaser;
  storeDir=logicalLogPath;
  neoStore=new NeoStore(neoStoreFileName);
  xaContainer=XaContainer.create(this,logicalLogPath,new CommandFactory(neoStore),new TransactionFactory(),null);
  xaContainer.openLogicalLog();
  if (!xaContainer.getResourceManager().hasRecoveredTransactions()) {
    neoStore.makeStoreOk();
  }
 else {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
  }
  idGenerators=new ArrayMap<Class<?>,Store>(5,false,false);
  this.idGenerators.put(Node.class,neoStore.getNodeStore());
  this.idGenerators.put(Relationship.class,neoStore.getRelationshipStore());
  this.idGenerators.put(RelationshipType.class,neoStore.getRelationshipTypeStore());
  this.idGenerators.put(PropertyStore.class,neoStore.getPropertyStore());
  this.idGenerators.put(PropertyIndex.class,neoStore.getPropertyStore().getIndexStore());
}","/** 
 * Creates a data source with minimum (no memory mapped) configuration.
 * @param neoStoreFileName The file name of the store
 * @param logicalLogPath The file name of the logical log
 * @throws IOException If unable to open store
 */
public NeoStoreXaDataSource(String neoStoreFileName,String logicalLogPath,LockManager lockManager,LockReleaser lockReleaser) throws IOException, InstantiationException {
  super(null);
  this.readOnly=false;
  this.lockManager=lockManager;
  this.lockReleaser=lockReleaser;
  storeDir=logicalLogPath;
  neoStore=new NeoStore(neoStoreFileName);
  xaContainer=XaContainer.create(this,logicalLogPath,new CommandFactory(neoStore),new TransactionFactory(),null);
  setLogicalLogAtCreationTime(xaContainer.getLogicalLog());
  xaContainer.openLogicalLog();
  if (!xaContainer.getResourceManager().hasRecoveredTransactions()) {
    neoStore.makeStoreOk();
  }
 else {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
  }
  idGenerators=new ArrayMap<Class<?>,Store>(5,false,false);
  this.idGenerators.put(Node.class,neoStore.getNodeStore());
  this.idGenerators.put(Relationship.class,neoStore.getRelationshipStore());
  this.idGenerators.put(RelationshipType.class,neoStore.getRelationshipTypeStore());
  this.idGenerators.put(PropertyStore.class,neoStore.getPropertyStore());
  this.idGenerators.put(PropertyIndex.class,neoStore.getPropertyStore().getIndexStore());
}",0.9782293178519592
154897,"private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  buffer.clear();
  buffer.limit(8);
  log.read(buffer);
  long versionInLog=buffer.getLong();
  assertExpectedVersion(expectedVersion,versionInLog);
  long prevTxId=buffer.getLong();
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  while (logEntryList == null && fileChannel.read(buffer) != buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    List<LogEntry> list=new LinkedList<LogEntry>();
  list.add(logEntry);
transactions.put(logEntry.getIdentifier(),list);
break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
if (((LogEntry.OnePhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
if (((LogEntry.TwoPhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
transactions.remove(logEntry.getIdentifier());
break;
default :
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str"");
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
}
return logEntryList;
}","private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  buffer.flip();
  long versionInLog=buffer.getLong();
  assertExpectedVersion(expectedVersion,versionInLog);
  long prevTxId=buffer.getLong();
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  buffer.clear();
  while (logEntryList == null && fileChannel.read(buffer) != buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    List<LogEntry> list=new LinkedList<LogEntry>();
  list.add(logEntry);
transactions.put(logEntry.getIdentifier(),list);
break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
if (((LogEntry.OnePhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
if (((LogEntry.TwoPhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
transactions.remove(logEntry.getIdentifier());
break;
default :
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str"");
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
}
return logEntryList;
}",0.9819444444444444
154898,"private void assertLogCanContainTx(long txId,long prevTxId) throws IOException {
  if (prevTxId < txId) {
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
  }
}","private void assertLogCanContainTx(long txId,long prevTxId) throws IOException {
  if (prevTxId >= txId) {
    throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
  }
}",0.9929742388758782
154899,"private long findLogContainingTxId(long txId) throws IOException {
  long version=logVersion;
  long committedTx=previousLogLastCommittedTx;
  while (version >= 0) {
    ReadableByteChannel log=getLogicalLogOrMyself(version);
    ByteBuffer buf=ByteBuffer.allocate(16);
    if (log.read(buf) != 16) {
      throw new IOException(""String_Node_Str"" + version);
    }
    buf.flip();
    long readVersion=buffer.getLong();
    if (readVersion != version) {
      throw new IOException(""String_Node_Str"" + readVersion + ""String_Node_Str""+ version);
    }
    committedTx=buffer.getLong();
    log.close();
    if (committedTx <= txId) {
      break;
    }
    version--;
  }
  return version;
}","private long findLogContainingTxId(long txId) throws IOException {
  long version=logVersion;
  long committedTx=previousLogLastCommittedTx;
  while (version >= 0) {
    ReadableByteChannel log=getLogicalLogOrMyself(version);
    ByteBuffer buf=ByteBuffer.allocate(16);
    if (log.read(buf) != 16) {
      throw new IOException(""String_Node_Str"" + version);
    }
    buf.flip();
    long readVersion=buf.getLong();
    if (readVersion != version) {
      throw new IOException(""String_Node_Str"" + readVersion + ""String_Node_Str""+ version);
    }
    committedTx=buf.getLong();
    log.close();
    if (committedTx <= txId) {
      break;
    }
    version--;
  }
  return version;
}",0.9956331877729258
154900,"private List<LogEntry> extractPreparedTransactionFromLog(long identifier,ReadableByteChannel log) throws IOException {
  buffer.clear();
  buffer.limit(8);
  log.read(buffer);
  long versionInLog=buffer.getLong();
  long prevTxId=buffer.getLong();
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  while (logEntryList == null && fileChannel.read(buffer) != buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    if (logEntry.getIdentifier() == identifier) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(logEntry);
      transactions.put(logEntry.getIdentifier(),list);
    }
  break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
if (logEntry.getIdentifier() == identifier) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
if (logEntry.getIdentifier() == identifier) {
transactions.get(logEntry.getIdentifier()).add(logEntry);
}
break;
default :
throw new IOException(""String_Node_Str"" + identifier);
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException(""String_Node_Str"" + identifier + ""String_Node_Str"");
}
return logEntryList;
}","private List<LogEntry> extractPreparedTransactionFromLog(long identifier,ReadableByteChannel log) throws IOException {
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  buffer.clear();
  buffer.limit(1);
  while (logEntryList == null && log.read(buffer) == buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    if (logEntry.getIdentifier() == identifier) {
      List<LogEntry> list=new LinkedList<LogEntry>();
      list.add(logEntry);
      transactions.put(logEntry.getIdentifier(),list);
    }
  break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
if (logEntry.getIdentifier() == identifier) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
if (logEntry.getIdentifier() == identifier) {
transactions.get(logEntry.getIdentifier()).add(logEntry);
}
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
break;
default :
throw new IOException(""String_Node_Str"" + entry);
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException(""String_Node_Str"" + identifier + ""String_Node_Str"");
}
return logEntryList;
}",0.8502415458937198
154901,"private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  buffer.flip();
  long versionInLog=buffer.getLong();
  assertExpectedVersion(expectedVersion,versionInLog);
  long prevTxId=buffer.getLong();
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  buffer.clear();
  while (logEntryList == null && fileChannel.read(buffer) != buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    List<LogEntry> list=new LinkedList<LogEntry>();
  list.add(logEntry);
transactions.put(logEntry.getIdentifier(),list);
break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
if (((LogEntry.OnePhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
if (((LogEntry.TwoPhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
transactions.remove(logEntry.getIdentifier());
break;
default :
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str"");
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
}
return logEntryList;
}","private List<LogEntry> extractTransactionFromLog(long txId,long expectedVersion,ReadableByteChannel log) throws IOException {
  buffer.clear();
  buffer.limit(16);
  log.read(buffer);
  buffer.flip();
  long versionInLog=buffer.getLong();
  assertExpectedVersion(expectedVersion,versionInLog);
  long prevTxId=buffer.getLong();
  assertLogCanContainTx(txId,prevTxId);
  List<LogEntry> logEntryList=null;
  Map<Integer,List<LogEntry>> transactions=new HashMap<Integer,List<LogEntry>>();
  buffer.clear();
  buffer.limit(1);
  while (logEntryList == null && log.read(buffer) == buffer.limit()) {
    buffer.flip();
    byte entry=buffer.get();
    LogEntry logEntry;
switch (entry) {
case LogEntry.TX_START:
      logEntry=LogIoUtils.readTxStartEntry(buffer,log,-1);
    List<LogEntry> list=new LinkedList<LogEntry>();
  list.add(logEntry);
transactions.put(logEntry.getIdentifier(),list);
break;
case LogEntry.TX_PREPARE:
logEntry=LogIoUtils.readTxPrepareEntry(buffer,log);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.TX_1P_COMMIT:
logEntry=LogIoUtils.readTxOnePhaseCommit(buffer,log);
if (((LogEntry.OnePhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.TX_2P_COMMIT:
logEntry=LogIoUtils.readTxTwoPhaseCommit(buffer,log);
if (((LogEntry.TwoPhaseCommit)logEntry).getTxId() == txId) {
logEntryList=transactions.get(logEntry.getIdentifier());
logEntryList.add(logEntry);
}
 else {
transactions.remove(logEntry.getIdentifier());
}
break;
case LogEntry.COMMAND:
logEntry=LogIoUtils.readTxCommand(buffer,log,cf);
transactions.get(logEntry.getIdentifier()).add(logEntry);
break;
case LogEntry.DONE:
logEntry=LogIoUtils.readTxDoneEntry(buffer,log);
transactions.remove(logEntry.getIdentifier());
break;
default :
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str"");
}
buffer.clear();
buffer.limit(1);
}
if (logEntryList == null) {
throw new IOException(""String_Node_Str"" + txId + ""String_Node_Str""+ expectedVersion+ ""String_Node_Str""+ prevTxId+ ""String_Node_Str"");
}
return logEntryList;
}",0.9855736203343256
154902,"public int getOrCreate(TransactionManager txManager,EntityIdGenerator idGenerator,PersistenceManager persistence,String name){
  RelTypeCreater createrThread=new RelTypeCreater(name,txManager,idGenerator,persistence);
synchronized (createrThread) {
    createrThread.start();
    while (createrThread.isAlive()) {
      try {
        createrThread.wait(50);
      }
 catch (      InterruptedException e) {
        Thread.interrupted();
      }
    }
  }
  if (createrThread.succeded()) {
    return createrThread.getRelTypeId();
  }
  throw new TransactionFailureException(""String_Node_Str"" + name);
}","public int getOrCreate(TransactionManager txManager,EntityIdGenerator idGenerator,PersistenceManager persistence,RelationshipTypeHolder relTypeHolder,String name){
  RelTypeCreater createrThread=new RelTypeCreater(name,txManager,idGenerator,persistence);
synchronized (createrThread) {
    createrThread.start();
    while (createrThread.isAlive()) {
      try {
        createrThread.wait(50);
      }
 catch (      InterruptedException e) {
        Thread.interrupted();
      }
    }
  }
  if (createrThread.succeded()) {
    int id=createrThread.getRelTypeId();
    relTypeHolder.addRawRelationshipType(new RelationshipTypeData(id,name));
    return id;
  }
  throw new TransactionFailureException(""String_Node_Str"" + name);
}",0.8925619834710744
154903,"int getOrCreate(TransactionManager txManager,EntityIdGenerator idGenerator,PersistenceManager persistence,String name);","int getOrCreate(TransactionManager txManager,EntityIdGenerator idGenerator,PersistenceManager persistence,RelationshipTypeHolder relTypeHolder,String name);",0.8654545454545455
154904,"void addRawRelationshipTypes(RelationshipTypeData[] types){
  for (int i=0; i < types.length; i++) {
    relTypes.put(types[i].getName(),types[i].getId());
    relTranslation.put(types[i].getId(),types[i].getName());
  }
}","void addRawRelationshipTypes(RelationshipTypeData[] types){
  for (int i=0; i < types.length; i++) {
    addRawRelationshipType(types[i]);
  }
}",0.6994535519125683
154905,"void addRawRelationshipType(RelationshipTypeData type){
  relTypes.put(type.getName(),type.getId());
  relTranslation.put(type.getId(),type.getName());
}","void addRawRelationshipType(RelationshipTypeData type){
  relTypes.put(type.getName(),type.getId());
  relTranslation.put(type.getId(),type.getName());
  printIt(type.getId(),type.getName());
}",0.884393063583815
154906,"public RelationshipType addValidRelationshipType(String name,boolean create){
  if (relTypes.get(name) == null) {
    if (!create) {
      return null;
    }
    int id=createRelationshipType(name);
    relTranslation.put(id,name);
  }
 else {
    relTranslation.put(relTypes.get(name),name);
  }
  return new RelationshipTypeImpl(name);
}","public RelationshipType addValidRelationshipType(String name,boolean create){
  if (relTypes.get(name) == null) {
    if (!create) {
      return null;
    }
    int id=createRelationshipType(name);
    relTranslation.put(id,name);
    printIt(id,name);
  }
 else {
    relTranslation.put(relTypes.get(name),name);
    printIt(relTypes.get(name),name);
  }
  return new RelationshipTypeImpl(name);
}",0.91869918699187
154907,"private synchronized int createRelationshipType(String name){
  Integer id=relTypes.get(name);
  if (id != null) {
    return id;
  }
  id=relTypeCreator.getOrCreate(transactionManager,idGenerator,persistenceManager,name);
  addRelType(name,id);
  return id;
}","private synchronized int createRelationshipType(String name){
  Integer id=relTypes.get(name);
  if (id != null) {
    return id;
  }
  id=relTypeCreator.getOrCreate(transactionManager,idGenerator,persistenceManager,this,name);
  addRelType(name,id);
  return id;
}",0.9904761904761904
154908,"@Override protected boolean versionFound(String version){
  if (!version.startsWith(""String_Node_Str"")) {
    return false;
  }
  if (version.equals(""String_Node_Str"")) {
    ByteBuffer buffer=ByteBuffer.wrap(new byte[3 * RECORD_SIZE]);
    long time=System.currentTimeMillis();
    long random=r.nextLong();
    buffer.put(Record.IN_USE.byteValue()).putLong(time);
    buffer.put(Record.IN_USE.byteValue()).putLong(random);
    buffer.put(Record.IN_USE.byteValue()).putLong(0);
    buffer.put(Record.IN_USE.byteValue()).putLong(0);
    buffer.flip();
    try {
      getFileChannel().write(buffer,0);
    }
 catch (    IOException e) {
      throw new UnderlyingStorageException(e);
    }
    rebuildIdGenerator();
    closeIdGenerator();
    return true;
  }
  throw new IllegalStoreVersionException(""String_Node_Str"" + version + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Override protected boolean versionFound(String version){
  if (!version.startsWith(""String_Node_Str"")) {
    return false;
  }
  if (version.equals(""String_Node_Str"")) {
    ByteBuffer buffer=ByteBuffer.wrap(new byte[4 * RECORD_SIZE]);
    long time=System.currentTimeMillis();
    long random=r.nextLong();
    buffer.put(Record.IN_USE.byteValue()).putLong(time);
    buffer.put(Record.IN_USE.byteValue()).putLong(random);
    buffer.put(Record.IN_USE.byteValue()).putLong(0);
    buffer.put(Record.IN_USE.byteValue()).putLong(0);
    buffer.flip();
    try {
      getFileChannel().write(buffer,0);
    }
 catch (    IOException e) {
      throw new UnderlyingStorageException(e);
    }
    rebuildIdGenerator();
    closeIdGenerator();
    return true;
  }
  throw new IllegalStoreVersionException(""String_Node_Str"" + version + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9988776655443322
154909,"private ReadableByteChannel getLogicalLogOrMyself(long version) throws IOException {
  if (version < logVersion) {
    return getLogicalLog(version);
  }
 else {
    String currentLogName=fileName + (currentLog == LOG1 ? ""String_Node_Str"" : ""String_Node_Str"");
    return new RandomAccessFile(currentLogName,""String_Node_Str"").getChannel();
  }
}","private ReadableByteChannel getLogicalLogOrMyself(long version) throws IOException {
  if (version < logVersion) {
    return getLogicalLog(version);
  }
 else   if (version == logVersion) {
    String currentLogName=fileName + (currentLog == LOG1 ? ""String_Node_Str"" : ""String_Node_Str"");
    return new RandomAccessFile(currentLogName,""String_Node_Str"").getChannel();
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + version + ""String_Node_Str""+ logVersion+ ""String_Node_Str"");
  }
}",0.8189349112426035
154910,"private long findLogContainingTxId(long txId) throws IOException {
  long version=logVersion;
  long committedTx=previousLogLastCommittedTx;
  while (committedTx <= txId) {
    version--;
    ReadableByteChannel log=getLogicalLog(version);
    ByteBuffer buf=ByteBuffer.allocate(16);
    if (log.read(buf) != 16) {
      throw new IOException(""String_Node_Str"" + version);
    }
    buf.flip();
    long readVersion=buffer.getLong();
    if (readVersion != version) {
      throw new IOException(""String_Node_Str"" + readVersion + ""String_Node_Str""+ version);
    }
    committedTx=buffer.getLong();
    log.close();
  }
  return version;
}","private long findLogContainingTxId(long txId) throws IOException {
  long version=logVersion;
  long committedTx=previousLogLastCommittedTx;
  while (version >= 0) {
    ReadableByteChannel log=getLogicalLogOrMyself(version);
    ByteBuffer buf=ByteBuffer.allocate(16);
    if (log.read(buf) != 16) {
      throw new IOException(""String_Node_Str"" + version);
    }
    buf.flip();
    long readVersion=buffer.getLong();
    if (readVersion != version) {
      throw new IOException(""String_Node_Str"" + readVersion + ""String_Node_Str""+ version);
    }
    committedTx=buffer.getLong();
    log.close();
    if (committedTx <= txId) {
      break;
    }
    version--;
  }
  return version;
}",0.8863807373965388
154911,"private void ensureEntitiesAreGathered(){
  if (nodes == null) {
    nodes=new LinkedList<Node>();
    relationships=new LinkedList<Relationship>();
    TraversalBranch stepper=branch;
    while (stepper != null) {
      nodes.addFirst(stepper.node());
      Relationship relationship=stepper.relationship();
      if (relationship != null) {
        relationships.addFirst(relationship);
      }
      stepper=stepper.parent();
    }
  }
}","private void ensureEntitiesAreGathered(){
  if (nodes == null) {
    LinkedList<Node> nodesList=new LinkedList<Node>();
    LinkedList<Relationship> relationshipsList=new LinkedList<Relationship>();
    TraversalBranch stepper=branch;
    while (stepper != null) {
      nodesList.addFirst(stepper.node());
      Relationship relationship=stepper.relationship();
      if (relationship != null) {
        relationshipsList.addFirst(relationship);
      }
      stepper=stepper.parent();
    }
    nodes=nodesList;
    relationships=relationshipsList;
  }
}",0.821285140562249
154912,"public Iterator<PropertyContainer> iterator(){
  return new Iterator<PropertyContainer>(){
    Iterator<? extends PropertyContainer> current=relationships().iterator();
    Iterator<? extends PropertyContainer> next=nodes().iterator();
    public boolean hasNext(){
      return current.hasNext();
    }
    public PropertyContainer next(){
      try {
        return current.next();
      }
  finally {
        Iterator<? extends PropertyContainer> temp=current;
        current=next;
        next=temp;
      }
    }
    public void remove(){
      next.remove();
    }
  }
;
}","public Iterator<PropertyContainer> iterator(){
  return new Iterator<PropertyContainer>(){
    Iterator<? extends PropertyContainer> current=nodes().iterator();
    Iterator<? extends PropertyContainer> next=relationships().iterator();
    public boolean hasNext(){
      return current.hasNext();
    }
    public PropertyContainer next(){
      try {
        return current.next();
      }
  finally {
        Iterator<? extends PropertyContainer> temp=current;
        current=next;
        next=temp;
      }
    }
    public void remove(){
      next.remove();
    }
  }
;
}",0.9723661485319516
154913,"public boolean isStartNode(){
  return position.length() > 0;
}","public boolean isStartNode(){
  return position.length() == 0;
}",0.9763779527559056
154914,"private void writeInt(FileChannel channel,int value) throws IOException {
  NioUtils.writeInt(channel,buffer(4),value);
}","private void writeInt(FileChannel channel,int value) throws IOException {
  PrimitiveUtils.writeInt(channel,buffer(4),value);
}",0.9596774193548387
154915,"private Integer readNextInt(FileChannel channel) throws IOException {
  return NioUtils.readInt(channel,buffer(4));
}","private Integer readNextInt(FileChannel channel) throws IOException {
  return PrimitiveUtils.readInt(channel,buffer(4));
}",0.9583333333333334
154916,"private String readNextString(FileChannel channel) throws IOException {
  return NioUtils.readLengthAndString(channel,buffer(100));
}","private String readNextString(FileChannel channel) throws IOException {
  return PrimitiveUtils.readLengthAndString(channel,buffer(100));
}",0.9632352941176472
154917,"private void writeString(FileChannel channel,String value) throws IOException {
  NioUtils.writeLengthAndString(channel,buffer(200),value);
}","private void writeString(FileChannel channel,String value) throws IOException {
  PrimitiveUtils.writeLengthAndString(channel,buffer(200),value);
}",0.9652777777777778
154918,"public void add(long entityId,Map<String,Object> properties){
  put(type.newDocument(entityId),properties);
}","public void add(long entityId,Map<String,Object> properties){
  try {
    Document document=type.newDocument(entityId);
    for (    Map.Entry<String,Object> entry : properties.entrySet()) {
      String key=entry.getKey();
      for (      Object value : PrimitiveUtils.asArray(entry.getValue())) {
        type.addToDocument(document,key,value);
      }
    }
    writer().addDocument(document);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.3633217993079585
154919,"public void updateOrAdd(long entityId,Map<String,Object> properties){
  Document document=LuceneDataSource.findDocument(type,searcher(),entityId);
  put(document != null ? document : type.newDocument(entityId),properties);
}","public void updateOrAdd(long entityId,Map<String,Object> properties){
  try {
    writer().deleteDocuments(type.idTermQuery(entityId));
    add(entityId,properties);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.386117136659436
154920,"static CommandData readCommandData(ReadableByteChannel channel,ByteBuffer buffer,LuceneDataSource dataSource) throws IOException {
  buffer.clear();
  buffer.limit(21);
  if (channel.read(buffer) != buffer.limit()) {
    return null;
  }
  buffer.flip();
  byte cls=buffer.get();
  Class<?> itemsClass=null;
  if (cls == NODE) {
    itemsClass=Node.class;
  }
 else   if (cls == RELATIONSHIP) {
    itemsClass=Relationship.class;
  }
 else {
    return null;
  }
  int indexNameLength=buffer.getInt();
  long entityId=buffer.getLong();
  int keyCharLength=buffer.getInt();
  int valueCharLength=buffer.getInt();
  String indexName=NioUtils.readString(channel,buffer,indexNameLength);
  if (indexName == null) {
    return null;
  }
  String key=NioUtils.readString(channel,buffer,keyCharLength);
  if (key == null) {
    return null;
  }
  String value=NioUtils.readString(channel,buffer,valueCharLength);
  if (value == null) {
    return null;
  }
  IndexIdentifier identifier=new IndexIdentifier(itemsClass,indexName,dataSource.indexStore.get(indexName));
  return new CommandData(identifier,entityId,key,value);
}","static CommandData readCommandData(ReadableByteChannel channel,ByteBuffer buffer,LuceneDataSource dataSource) throws IOException {
  buffer.clear();
  buffer.limit(21);
  if (channel.read(buffer) != buffer.limit()) {
    return null;
  }
  buffer.flip();
  byte cls=buffer.get();
  Class<?> itemsClass=null;
  if (cls == NODE) {
    itemsClass=Node.class;
  }
 else   if (cls == RELATIONSHIP) {
    itemsClass=Relationship.class;
  }
 else {
    return null;
  }
  int indexNameLength=buffer.getInt();
  long entityId=buffer.getLong();
  int keyCharLength=buffer.getInt();
  int valueCharLength=buffer.getInt();
  String indexName=PrimitiveUtils.readString(channel,buffer,indexNameLength);
  if (indexName == null) {
    return null;
  }
  String key=PrimitiveUtils.readString(channel,buffer,keyCharLength);
  if (key == null) {
    return null;
  }
  String value=PrimitiveUtils.readString(channel,buffer,valueCharLength);
  if (value == null) {
    return null;
  }
  IndexIdentifier identifier=new IndexIdentifier(itemsClass,indexName,dataSource.indexStore.get(indexName));
  return new CommandData(identifier,entityId,key,value);
}",0.9840142095914742
154921,"/** 
 * See   {@link Index#add(PropertyContainer,String,Object)} for more genericdocumentation. Adds key/value to the  {@code entity} in this index. Added values aresearchable withing the transaction, but composite  {@code AND}queries aren't guaranteed to return added values correctly within that transaction. When the transaction has been committed all such queries are guaranteed to return correct results.
 * @param entity the entity (i.e {@link Node} or {@link Relationship}) to associate the key/value pair with.
 * @param key the key in the key/value pair to associate with the entity.
 * @param value the value in the key/value pair to associate with theentity.
 */
public void add(T entity,String key,Object value){
  getConnection().add(this,entity,key,value);
}","/** 
 * See   {@link Index#add(PropertyContainer,String,Object)} for more genericdocumentation. Adds key/value to the  {@code entity} in this index. Added values aresearchable withing the transaction, but composite  {@code AND}queries aren't guaranteed to return added values correctly within that transaction. When the transaction has been committed all such queries are guaranteed to return correct results.
 * @param entity the entity (i.e {@link Node} or {@link Relationship}) to associate the key/value pair with.
 * @param key the key in the key/value pair to associate with the entity.
 * @param value the value in the key/value pair to associate with theentity.
 */
public void add(T entity,String key,Object value){
  for (  Object oneValue : PrimitiveUtils.asArray(value)) {
    getConnection().add(this,entity,key,oneValue);
  }
}",0.9559826410415376
154922,"/** 
 * See   {@link Index#remove(PropertyContainer,String,Object)} for moregeneric documentation. Removes key/value to the  {@code entity} in this index. Removed valuesare excluded withing the transaction, but composite  {@code AND}queries aren't guaranteed to exclude removed values correctly within that transaction. When the transaction has been committed all such queries are guaranteed to return correct results.
 * @param entity the entity (i.e {@link Node} or {@link Relationship}) to dissociate the key/value pair from.
 * @param key the key in the key/value pair to dissociate from the entity.
 * @param value the value in the key/value pair to dissociate from theentity.
 */
public void remove(T entity,String key,Object value){
  getConnection().remove(this,entity,key,value);
}","/** 
 * See   {@link Index#remove(PropertyContainer,String,Object)} for moregeneric documentation. Removes key/value to the  {@code entity} in this index. Removed valuesare excluded withing the transaction, but composite  {@code AND}queries aren't guaranteed to exclude removed values correctly within that transaction. When the transaction has been committed all such queries are guaranteed to return correct results.
 * @param entity the entity (i.e {@link Node} or {@link Relationship}) to dissociate the key/value pair from.
 * @param key the key in the key/value pair to dissociate from the entity.
 * @param value the value in the key/value pair to dissociate from theentity.
 */
public void remove(T entity,String key,Object value){
  for (  Object oneValue : PrimitiveUtils.asArray(value)) {
    getConnection().remove(this,entity,key,oneValue);
  }
}",0.9569436021831412
154923,"@Override protected void doCommit(){
  dataSource.getWriteLock();
  try {
    for (    Map.Entry<IndexIdentifier,CommandList> entry : this.commandMap.entrySet()) {
      IndexIdentifier identifier=entry.getKey();
      IndexType type=dataSource.getType(identifier);
      IndexWriter writer=null;
      IndexSearcher searcher=null;
      CommandList commandList=entry.getValue();
      Map<Long,DocumentContext> documents=new HashMap<Long,DocumentContext>();
      for (      LuceneCommand command : commandList.commands) {
        if (writer == null) {
          writer=dataSource.getIndexWriter(identifier);
          writer.setMaxBufferedDocs(commandList.addCount + 100);
          writer.setMaxBufferedDeleteTerms(commandList.removeCount + 100);
          searcher=dataSource.getIndexSearcher(identifier).getSearcher();
        }
        long entityId=command.getEntityId();
        DocumentContext context=documents.get(entityId);
        if (context == null) {
          Document document=LuceneDataSource.findDocument(type,searcher,entityId);
          context=document == null ? new DocumentContext(type.newDocument(entityId),false,entityId) : new DocumentContext(document,true,entityId);
          documents.put(entityId,context);
        }
        String key=command.getKey();
        String value=command.getValue();
        if (command instanceof AddCommand) {
          type.addToDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else         if (command instanceof RemoveCommand) {
          type.removeFromDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else         if (command instanceof ClearCommand) {
          documents.clear();
          dataSource.closeWriter(writer);
          writer=null;
          dataSource.closeIndexSearcher(identifier);
          dataSource.invalidateCache(identifier);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + command + ""String_Node_Str""+ command.getClass());
        }
      }
      applyDocuments(writer,type,documents);
      if (writer != null) {
        dataSource.closeWriter(writer);
      }
      dataSource.invalidateIndexSearcher(identifier);
    }
    closeTxData();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    dataSource.releaseWriteLock();
  }
}","@Override protected void doCommit(){
  dataSource.getWriteLock();
  try {
    for (    Map.Entry<IndexIdentifier,CommandList> entry : this.commandMap.entrySet()) {
      IndexIdentifier identifier=entry.getKey();
      IndexType type=dataSource.getType(identifier);
      IndexWriter writer=null;
      IndexSearcher searcher=null;
      CommandList commandList=entry.getValue();
      Map<Long,DocumentContext> documents=new HashMap<Long,DocumentContext>();
      for (      LuceneCommand command : commandList.commands) {
        if (writer == null) {
          writer=dataSource.getIndexWriter(identifier);
          writer.setMaxBufferedDocs(commandList.addCount + 100);
          writer.setMaxBufferedDeleteTerms(commandList.removeCount + 100);
          searcher=dataSource.getIndexSearcher(identifier).getSearcher();
        }
        long entityId=command.getEntityId();
        DocumentContext context=documents.get(entityId);
        if (context == null) {
          Document document=LuceneDataSource.findDocument(type,searcher,entityId);
          context=document == null ? new DocumentContext(type.newDocument(entityId),false,entityId) : new DocumentContext(document,true,entityId);
          documents.put(entityId,context);
        }
        String key=command.getKey();
        String value=command.getValue();
        if (command instanceof AddCommand) {
          type.addToDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else         if (command instanceof RemoveCommand) {
          type.removeFromDocument(context.document,key,value);
          dataSource.invalidateCache(identifier,key,value);
        }
 else         if (command instanceof ClearCommand) {
          documents.clear();
          dataSource.closeWriter(writer);
          writer=null;
          dataSource.deleteIndex(identifier);
          dataSource.invalidateCache(identifier);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + command + ""String_Node_Str""+ command.getClass());
        }
      }
      applyDocuments(writer,type,documents);
      if (writer != null) {
        dataSource.closeWriter(writer);
      }
      dataSource.invalidateIndexSearcher(identifier);
    }
    closeTxData();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    dataSource.releaseWriteLock();
  }
}",0.996456118407338
154924,"public static <T>T getBean(int instanceId,Class<T> beanType){
  if (beanType.isInterface() && beanType.getPackage().equals(""String_Node_Str"")) {
    if (PROXY_MAKER == null) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
 else {
      ObjectName name=getObjectName(instanceId,beanType,null);
      return PROXY_MAKER.makeProxy(name,beanType);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + beanType);
}","public static <T>T getBean(int instanceId,Class<T> beanType){
  if (beanType.isInterface() && beanType.getPackage().getName().equals(""String_Node_Str"")) {
    if (PROXY_MAKER == null) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
 else {
      ObjectName name=getObjectName(instanceId,beanType,null);
      return PROXY_MAKER.makeProxy(name,beanType);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + beanType);
}",0.9889867841409692
154925,"public String relationshipRepresentation(Path path,Node from,Relationship relationship){
  return relationship.getStartNode().equals(from) ? ""String_Node_Str"" : ""String_Node_Str"";
}","@Override public String relationshipRepresentation(Path path,Node from,Relationship relationship){
  return relationship.getStartNode().equals(from) ? ""String_Node_Str"" : ""String_Node_Str"";
}",0.9731182795698924
154926,"/** 
 * Returns a quite simple string representation of a   {@link Path}. It doesn't print relationship types or ids, just directions. it uses the  {@code nodePropertyKey} to try to display that property value as in thenode representation instead of the node id. If that property doesn't exist, the id is used.
 * @param path the {@link Path} to build a string representation of.
 * @return a quite simple representation of a {@link Path}.
 */
public static String simplePathToString(Path path,final String nodePropertyKey){
  return pathToString(path,new DefaultPathDescriptor<Path>(){
    public String nodeRepresentation(    Path path,    Node node){
      return ""String_Node_Str"" + node.getProperty(nodePropertyKey,node.getId()) + ""String_Node_Str"";
    }
    public String relationshipRepresentation(    Path path,    Node from,    Relationship relationship){
      return relationship.getStartNode().equals(from) ? ""String_Node_Str"" : ""String_Node_Str"";
    }
  }
);
}","/** 
 * Returns a quite simple string representation of a   {@link Path}. It doesn't print relationship types or ids, just directions. it uses the  {@code nodePropertyKey} to try to display that property value as in thenode representation instead of the node id. If that property doesn't exist, the id is used.
 * @param path the {@link Path} to build a string representation of.
 * @return a quite simple representation of a {@link Path}.
 */
public static String simplePathToString(Path path,final String nodePropertyKey){
  return pathToString(path,new DefaultPathDescriptor<Path>(){
    @Override public String nodeRepresentation(    Path path,    Node node){
      return ""String_Node_Str"" + node.getProperty(nodePropertyKey,node.getId()) + ""String_Node_Str"";
    }
    @Override public String relationshipRepresentation(    Path path,    Node from,    Relationship relationship){
      return relationship.getStartNode().equals(from) ? ""String_Node_Str"" : ""String_Node_Str"";
    }
  }
);
}",0.9898477157360406
154927,"public String nodeRepresentation(Path path,Node node){
  return ""String_Node_Str"" + node.getProperty(nodePropertyKey,node.getId()) + ""String_Node_Str"";
}","@Override public String nodeRepresentation(Path path,Node node){
  return ""String_Node_Str"" + node.getProperty(nodePropertyKey,node.getId()) + ""String_Node_Str"";
}",0.9683544303797468
154928,"private static <T>T[] extract(Class<T[]> type,T obj1,T obj2,Object[] more,boolean odd){
  if (more.length % 2 != 0) {
    throw new IllegalArgumentException();
  }
  Object[] target=(Object[])Array.newInstance(type,(more.length / 2) + 2);
  try {
    target[0]=obj1;
    target[1]=obj2;
    for (int i=2; i < target.length; i++) {
      target[i]=more[(i - 2) * 2 + (odd ? 1 : 0)];
    }
  }
 catch (  ArrayStoreException cast) {
    throw new IllegalArgumentException(cast);
  }
  return type.cast(target);
}","private static <T>T[] extract(Class<T[]> type,T obj1,T obj2,Object[] more,boolean odd){
  if (more.length % 2 != 0) {
    throw new IllegalArgumentException();
  }
  Object[] target=(Object[])Array.newInstance(type.getComponentType(),(more.length / 2) + 2);
  try {
    target[0]=obj1;
    target[1]=obj2;
    for (int i=2; i < target.length; i++) {
      target[i]=more[(i - 2) * 2 + (odd ? 1 : 0)];
    }
  }
 catch (  ArrayStoreException cast) {
    throw new IllegalArgumentException(cast);
  }
  return type.cast(target);
}",0.9816779170684669
154929,"public Path findSinglePath(Node start,Node end){
  Collection<Path> paths=internalPaths(start,end,true);
  return IteratorUtil.singleValueOrNull(paths.iterator());
}","public Path findSinglePath(Node start,Node end){
  Collection<Path> paths=internalPaths(start,end,true);
  return paths.isEmpty() ? null : paths.iterator().next();
}",0.8545454545454545
154930,"private RelationshipExpander toExpander(Direction direction,Map<String,Object> filterMap,boolean caseInsensitiveFilters,boolean looseFilters){
  DefaultExpander expander=new DefaultExpander();
  for (  RelationshipType type : getServer().getDb().getRelationshipTypes()) {
    boolean matches=false;
    if (filterMap == null || filterMap.isEmpty()) {
      matches=true;
    }
 else {
      for (      String filter : filterMap.keySet()) {
        if (matches(newPattern(filter,caseInsensitiveFilters),type.name(),caseInsensitiveFilters,looseFilters)) {
          matches=true;
          break;
        }
      }
    }
    if (matches) {
      expander=expander.add(type,direction);
    }
  }
  return expander;
}","private RelationshipExpander toExpander(Direction direction,Map<String,Object> filterMap,boolean caseInsensitiveFilters,boolean looseFilters){
  Expander expander=TraversalFactory.emptyExpander();
  for (  RelationshipType type : getServer().getDb().getRelationshipTypes()) {
    boolean matches=false;
    if (filterMap == null || filterMap.isEmpty()) {
      matches=true;
    }
 else {
      for (      String filter : filterMap.keySet()) {
        if (matches(newPattern(filter,caseInsensitiveFilters),type.name(),caseInsensitiveFilters,looseFilters)) {
          matches=true;
          break;
        }
      }
    }
    if (matches) {
      expander=expander.add(type,direction);
    }
  }
  return expander;
}",0.972027972027972
154931,"public void close(){
  neoStore.flushAll();
  xaContainer.close();
  if (logApplied) {
    neoStore.rebuildIdGenerators();
    logApplied=false;
  }
  neoStore.close();
  logger.fine(""String_Node_Str"");
}","public void close(){
  if (!readOnly) {
    neoStore.flushAll();
  }
  xaContainer.close();
  if (logApplied) {
    neoStore.rebuildIdGenerators();
    logApplied=false;
  }
  neoStore.close();
  logger.fine(""String_Node_Str"");
}",0.9422632794457276
154932,"private void fixCleanKill(String fileName) throws IOException {
  File file=new File(fileName);
  if (!keepLogs && !file.delete()) {
    throw new IllegalStateException(""String_Node_Str"" + fileName);
  }
 else {
    renameCurrentLogFileAndIncrementVersion(fileName,file.length());
  }
}","private void fixCleanKill(String fileName) throws IOException {
  File file=new File(fileName);
  if (!keepLogs) {
    if (!file.delete()) {
      throw new IllegalStateException(""String_Node_Str"" + fileName);
    }
  }
 else {
    renameCurrentLogFileAndIncrementVersion(fileName,file.length());
  }
}",0.9591836734693876
154933,"AutoConfigurator(String dbPath,boolean useMemoryMapped){
  this.dbPath=dbPath;
  this.useMemoryMapped=useMemoryMapped;
  OperatingSystemMXBean osBean=ManagementFactory.getOperatingSystemMXBean();
  long mem=-1;
  try {
    Class<?> beanClass=Class.forName(""String_Node_Str"");
    Method method=beanClass.getMethod(""String_Node_Str"");
    mem=(Long)method.invoke(osBean,new Object[0]);
  }
 catch (  Exception e) {
  }
  if (mem != -1) {
    totalPhysicalMemMb=(int)(mem / 1024 / 1024);
  }
 else {
    totalPhysicalMemMb=-1;
  }
  mem=Runtime.getRuntime().maxMemory();
  maxVmUsageMb=(int)(mem / 1024 / 1024);
}","public AutoConfigurator(String dbPath,boolean useMemoryMapped,boolean dump){
  this.dbPath=dbPath;
  this.useMemoryMapped=useMemoryMapped;
  OperatingSystemMXBean osBean=ManagementFactory.getOperatingSystemMXBean();
  long mem=-1;
  try {
    Class<?> beanClass=Class.forName(""String_Node_Str"");
    Method method=beanClass.getMethod(""String_Node_Str"");
    mem=(Long)method.invoke(osBean,new Object[0]);
  }
 catch (  Exception e) {
  }
  if (mem != -1) {
    totalPhysicalMemMb=(int)(mem / 1024 / 1024);
  }
 else {
    totalPhysicalMemMb=-1;
  }
  mem=Runtime.getRuntime().maxMemory();
  maxVmUsageMb=(int)(mem / 1024 / 1024);
  if (dump) {
    System.out.println(""String_Node_Str"" + totalPhysicalMemMb + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + maxVmUsageMb + ""String_Node_Str"");
  }
}",0.8593530239099859
154934,"void configure(Map<Object,Object> config){
  if (totalPhysicalMemMb > 0) {
    if (useMemoryMapped) {
      int availableMem=(totalPhysicalMemMb - maxVmUsageMb);
      availableMem-=(int)(availableMem * 0.15f);
      assignMemory(config,availableMem);
    }
 else {
      assignMemory(config,maxVmUsageMb / 2);
    }
  }
}","public void configure(Map<Object,Object> config){
  if (totalPhysicalMemMb > 0) {
    if (useMemoryMapped) {
      int availableMem=(totalPhysicalMemMb - maxVmUsageMb);
      availableMem-=(int)(availableMem * 0.15f);
      assignMemory(config,availableMem);
    }
 else {
      assignMemory(config,maxVmUsageMb / 2);
    }
  }
}",0.989247311827957
154935,"private Map<Object,Object> getDefaultParams(){
  Map<Object,Object> params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  String nameOs=System.getProperty(""String_Node_Str"");
  if (nameOs.startsWith(""String_Node_Str"")) {
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
  return params;
}","private Map<Object,Object> getDefaultParams(){
  Map<Object,Object> params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",""String_Node_Str"");
  String nameOs=System.getProperty(""String_Node_Str"");
  if (nameOs.startsWith(""String_Node_Str"")) {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,""String_Node_Str"");
  }
  return params;
}",0.9620449264136328
154936,"/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,Map<String,String> stringParams,KernelPanicEventGenerator kpe){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=getDefaultParams();
  boolean useMemoryMapped=true;
  if (""String_Node_Str"".equals(params.get(""String_Node_Str""))) {
    useMemoryMapped=false;
  }
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  new AutoConfigurator(storeDir,useMemoryMapped).configure(params);
  for (  Map.Entry<String,String> entry : stringParams.entrySet()) {
    params.put(entry.getKey(),entry.getValue());
  }
  config=new Config(graphDb,storeDir,params,kpe);
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(DEFAULT_DATA_SOURCE_NAME,NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId);
      clazz=Class.forName(LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId);
    }
 catch (    ClassNotFoundException e) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource);
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),params);
  if (""String_Node_Str"".equals(params.get(""String_Node_Str""))) {
    for (    Object key : params.keySet()) {
      if (key instanceof String) {
        Object value=params.get(key);
        if (value instanceof String) {
          System.out.println(key + ""String_Node_Str"" + value);
        }
      }
    }
  }
  started=true;
  return Collections.unmodifiableMap(params);
}","/** 
 * Starts Neo4j with default configuration
 * @param graphDb The graph database service.
 * @param storeDir path to directory where Neo4j store is located
 * @param create if true a new Neo4j store will be created if no store existat <CODE>storeDir</CODE>
 * @param configuration parameters
 * @throws StartupFailedException if unable to start
 */
public synchronized Map<Object,Object> start(GraphDatabaseService graphDb,Map<String,String> stringParams,KernelPanicEventGenerator kpe){
  if (started) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<Object,Object> params=getDefaultParams();
  boolean useMemoryMapped=true;
  if (stringParams.containsKey(Config.USE_MEMORY_MAPPED_BUFFERS)) {
    params.put(Config.USE_MEMORY_MAPPED_BUFFERS,stringParams.get(Config.USE_MEMORY_MAPPED_BUFFERS));
  }
  if (""String_Node_Str"".equals(params.get(Config.USE_MEMORY_MAPPED_BUFFERS))) {
    useMemoryMapped=false;
  }
  boolean dump=false;
  if (""String_Node_Str"".equals(stringParams.get(Config.DUMP_CONFIGURATION))) {
    dump=true;
  }
  storeDir=FileUtils.fixSeparatorsInPath(storeDir);
  new AutoConfigurator(storeDir,useMemoryMapped,dump).configure(params);
  for (  Map.Entry<String,String> entry : stringParams.entrySet()) {
    params.put(entry.getKey(),entry.getValue());
  }
  config=new Config(graphDb,storeDir,params,kpe);
  String separator=System.getProperty(""String_Node_Str"");
  String store=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",storeDir);
  params.put(""String_Node_Str"",store);
  params.put(""String_Node_Str"",String.valueOf(create));
  String logicalLog=storeDir + separator + ""String_Node_Str"";
  params.put(""String_Node_Str"",logicalLog);
  byte resourceId[]=""String_Node_Str"".getBytes();
  params.put(LockManager.class,config.getLockManager());
  params.put(LockReleaser.class,config.getLockReleaser());
  config.getTxModule().registerDataSource(Config.DEFAULT_DATA_SOURCE_NAME,Config.NIO_NEO_DB_CLASS,resourceId,params);
  if (!config.isReadOnly() || config.isBackupSlave()) {
    try {
      Class clazz=Class.forName(Config.LUCENE_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      byte luceneId[]=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId);
      clazz=Class.forName(Config.LUCENE_FULLTEXT_DS_CLASS);
      cleanWriteLocksInLuceneDirectory(storeDir + ""String_Node_Str"");
      luceneId=""String_Node_Str"".getBytes();
      registerLuceneDataSource(""String_Node_Str"",clazz.getName(),config.getTxModule(),storeDir + ""String_Node_Str"",config.getLockManager(),luceneId);
    }
 catch (    ClassNotFoundException e) {
    }
  }
  persistenceSource=new NioNeoDbPersistenceSource();
  config.setPersistenceSource(Config.DEFAULT_DATA_SOURCE_NAME,create);
  config.getIdGeneratorModule().setPersistenceSourceInstance(persistenceSource);
  config.getTxModule().init();
  config.getPersistenceModule().init();
  persistenceSource.init();
  config.getIdGeneratorModule().init();
  config.getGraphDbModule().init();
  config.getTxModule().start();
  config.getPersistenceModule().start(config.getTxModule().getTxManager(),persistenceSource);
  persistenceSource.start(config.getTxModule().getXaDataSourceManager());
  config.getIdGeneratorModule().start();
  config.getGraphDbModule().start(config.getLockReleaser(),config.getPersistenceModule().getPersistenceManager(),params);
  if (""String_Node_Str"".equals(params.get(Config.DUMP_CONFIGURATION))) {
    for (    Object key : params.keySet()) {
      if (key instanceof String) {
        Object value=params.get(key);
        if (value instanceof String) {
          System.out.println(key + ""String_Node_Str"" + value);
        }
      }
    }
  }
  started=true;
  return Collections.unmodifiableMap(params);
}",0.9429494079655544
154937,"public BatchInserterImpl(String storeDir,Map<String,String> stringParams){
  Map<Object,Object> params=getDefaultParams();
  params.put(""String_Node_Str"",""String_Node_Str"");
  for (  Map.Entry<String,String> entry : stringParams.entrySet()) {
    params.put(entry.getKey(),entry.getValue());
  }
  this.storeDir=storeDir;
  String store=fixPath(storeDir);
  params.put(""String_Node_Str"",store);
  neoStore=new NeoStore(params);
  neoStore.makeStoreOk();
  PropertyIndexData[] indexes=getPropertyIndexStore().getPropertyIndexes(10000);
  indexHolder=new PropertyIndexHolder(indexes);
  RelationshipTypeData[] types=getRelationshipTypeStore().getRelationshipTypes();
  typeHolder=new RelationshipTypeHolder(types);
  graphDbService=new BatchGraphDatabaseImpl(this);
}","public BatchInserterImpl(String storeDir,Map<String,String> stringParams){
  Map<Object,Object> params=getDefaultParams();
  params.put(Config.USE_MEMORY_MAPPED_BUFFERS,""String_Node_Str"");
  boolean dump=false;
  if (""String_Node_Str"".equals(stringParams.get(Config.DUMP_CONFIGURATION))) {
    dump=true;
  }
  new AutoConfigurator(storeDir,false,dump).configure(params);
  for (  Map.Entry<String,String> entry : stringParams.entrySet()) {
    params.put(entry.getKey(),entry.getValue());
  }
  this.storeDir=storeDir;
  String store=fixPath(storeDir);
  params.put(""String_Node_Str"",store);
  if (""String_Node_Str"".equals(params.get(Config.DUMP_CONFIGURATION))) {
    for (    Object key : params.keySet()) {
      if (key instanceof String) {
        Object value=params.get(key);
        if (value instanceof String) {
          System.out.println(key + ""String_Node_Str"" + value);
        }
      }
    }
  }
  neoStore=new NeoStore(params);
  neoStore.makeStoreOk();
  PropertyIndexData[] indexes=getPropertyIndexStore().getPropertyIndexes(10000);
  indexHolder=new PropertyIndexHolder(indexes);
  RelationshipTypeData[] types=getRelationshipTypeStore().getRelationshipTypes();
  typeHolder=new RelationshipTypeHolder(types);
  graphDbService=new BatchGraphDatabaseImpl(this);
}",0.5534407027818448
154938,"protected boolean getIfMemoryMapped(){
  if (getConfig() != null) {
    String useMemMapped=(String)getConfig().get(""String_Node_Str"");
    if (useMemMapped != null && useMemMapped.toLowerCase().equals(""String_Node_Str"")) {
      return false;
    }
  }
  return true;
}","protected boolean getIfMemoryMapped(){
  if (getConfig() != null) {
    String useMemMapped=(String)getConfig().get(Config.USE_MEMORY_MAPPED_BUFFERS);
    if (useMemMapped != null && useMemMapped.toLowerCase().equals(""String_Node_Str"")) {
      return false;
    }
  }
  return true;
}",0.9117117117117116
154939,"private boolean getMemoryMapped(Map<Object,Object> config){
  if (config != null) {
    String value=(String)config.get(""String_Node_Str"");
    if (value != null && value.toLowerCase().equals(""String_Node_Str"")) {
      return false;
    }
  }
  return true;
}","private boolean getMemoryMapped(Map<Object,Object> config){
  if (config != null) {
    String value=(String)config.get(Config.USE_MEMORY_MAPPED_BUFFERS);
    if (value != null && value.toLowerCase().equals(""String_Node_Str"")) {
      return false;
    }
  }
  return true;
}",0.908411214953271
154940,"@Test public void testIt(){
  PriorityMap<Integer,Integer,Double> map=PriorityMap.withSelfKeyNaturalOrder();
  int start=0, a=1, b=2, c=3, d=4, e=6, f=7, y=8, x=9;
  map.put(start,0d);
  map.put(a,1d);
  map.put(x,10d);
  map.put(b,2d);
  map.put(x,9d);
  map.put(c,3d);
  map.put(x,8d);
  map.put(x,6d);
  map.put(d,4d);
  map.put(x,7d);
  map.put(e,5d);
  map.put(x,6d);
  map.put(f,7d);
  map.put(y,8d);
}","@Test public void testIt(){
  PriorityMap<Integer,Integer,Double> map=PriorityMap.<Integer,Double>withSelfKeyNaturalOrder();
  int start=0, a=1, b=2, c=3, d=4, e=6, f=7, y=8, x=9;
  map.put(start,0d);
  map.put(a,1d);
  map.put(x,10d);
  map.put(b,2d);
  map.put(x,9d);
  map.put(c,3d);
  map.put(x,8d);
  map.put(x,6d);
  map.put(d,4d);
  map.put(x,7d);
  map.put(e,5d);
  map.put(x,6d);
  map.put(f,7d);
  map.put(y,8d);
}",0.9807692307692308
154941,"public void createMemoryMappingMBean(XaDataSourceManager datasourceMananger){
  NeoStoreXaDataSource datasource=(NeoStoreXaDataSource)datasourceMananger.getXaDataSource(""String_Node_Str"");
  if (!register(new MemoryMappingMonitor.MXBeanImplementation(instance.id,datasource))) {
    if (!register(new MemoryMappingMonitor.MemoryMapping(instance.id,datasource)))     failedToRegister(""String_Node_Str"");
  }
}","public void createMemoryMappingMBean(XaDataSourceManager datasourceMananger){
  NeoStoreXaDataSource datasource=(NeoStoreXaDataSource)datasourceMananger.getXaDataSource(""String_Node_Str"");
  if (!register(new MemoryMapping.AsMxBean(instance.id,datasource))) {
    if (!register(new MemoryMapping(instance.id,datasource)))     failedToRegister(""String_Node_Str"");
  }
}",0.9381443298969072
154942,"public void createXaManagerMBean(XaDataSourceManager datasourceMananger){
  if (!register(new XaMonitor.MXBeanImplementation(instance.id,datasourceMananger))) {
    if (!register(new XaMonitor.XaManager(instance.id,datasourceMananger)))     failedToRegister(""String_Node_Str"");
  }
}","public void createXaManagerMBean(XaDataSourceManager datasourceMananger){
  if (!register(new XaManager.AsMXBean(instance.id,datasourceMananger))) {
    if (!register(new XaManager(instance.id,datasourceMananger)))     failedToRegister(""String_Node_Str"");
  }
}",0.9338235294117648
154943,"private void populateNodeRelEvent(PrimitiveElement element,TransactionDataImpl result){
  for (  int nodeId : element.nodes.keySet()) {
    CowNodeElement nodeElement=element.nodes.get(nodeId);
    NodeProxy node=new NodeProxy(nodeId,nodeManager);
    NodeImpl nodeImpl=nodeManager.getNodeForProxy(nodeId);
    if (nodeElement.relationshipAddMap != null) {
      for (      String type : nodeElement.relationshipAddMap.keySet()) {
        IntArray createdRels=nodeElement.relationshipAddMap.get(type);
        for (int i=0; i < createdRels.length(); i++) {
          int relId=createdRels.get(i);
          CowRelElement relElement=element.relationships.get(relId);
          if (relElement != null && relElement.deleted) {
            continue;
          }
          RelationshipProxy rel=new RelationshipProxy(relId,nodeManager);
          if (rel.getStartNode().getId() == nodeId) {
            result.created(new RelationshipProxy(relId,nodeManager));
          }
        }
      }
    }
    if (nodeElement.relationshipRemoveMap != null) {
      for (      String type : nodeElement.relationshipRemoveMap.keySet()) {
        IntArray deletedRels=nodeElement.relationshipRemoveMap.get(type);
        for (int i=0; i < deletedRels.length(); i++) {
          int relId=deletedRels.get(i);
          if (nodeManager.relCreated(relId)) {
            continue;
          }
          RelationshipProxy rel=new RelationshipProxy(relId,nodeManager);
          if (rel.getStartNode().getId() == nodeId) {
            result.deleted(new RelationshipProxy(relId,nodeManager));
          }
        }
      }
    }
    if (nodeElement.deleted) {
      if (nodeManager.nodeCreated(nodeId)) {
        continue;
      }
      result.deleted(node);
      List<PropertyEventData> props=nodeImpl.getAllCommittedProperties();
      for (      PropertyEventData data : props) {
        result.removedProperty(node,data.getKey(),data.getValue());
      }
    }
 else {
      if (nodeElement.propertyAddMap != null) {
        for (        PropertyData data : nodeElement.propertyAddMap.values()) {
          String key=nodeManager.getKeyForProperty(data.getId());
          Object oldValue=nodeImpl.getCommittedPropertyValue(key);
          Object newValue=data.getValue();
          result.assignedProperty(node,key,newValue,oldValue);
        }
      }
      if (nodeElement.propertyRemoveMap != null) {
        for (        PropertyData data : nodeElement.propertyRemoveMap.values()) {
          String key=nodeManager.getKeyForProperty(data.getId());
          Object oldValue=nodeImpl.getCommittedPropertyValue(key);
          result.removedProperty(node,key,oldValue);
        }
      }
    }
  }
}","private void populateNodeRelEvent(PrimitiveElement element,TransactionDataImpl result){
  for (  int nodeId : element.nodes.keySet()) {
    CowNodeElement nodeElement=element.nodes.get(nodeId);
    NodeProxy node=new NodeProxy(nodeId,nodeManager);
    NodeImpl nodeImpl=nodeManager.getNodeForProxy(nodeId);
    if (nodeElement.deleted) {
      if (nodeManager.nodeCreated(nodeId)) {
        continue;
      }
      result.deleted(node);
    }
    if (nodeElement.relationshipAddMap != null && !nodeElement.deleted) {
      for (      String type : nodeElement.relationshipAddMap.keySet()) {
        IntArray createdRels=nodeElement.relationshipAddMap.get(type);
        for (int i=0; i < createdRels.length(); i++) {
          int relId=createdRels.get(i);
          CowRelElement relElement=element.relationships.get(relId);
          if (relElement != null && relElement.deleted) {
            continue;
          }
          RelationshipProxy rel=new RelationshipProxy(relId,nodeManager);
          if (rel.getStartNode().getId() == nodeId) {
            result.created(new RelationshipProxy(relId,nodeManager));
          }
        }
      }
    }
    if (nodeElement.relationshipRemoveMap != null) {
      for (      String type : nodeElement.relationshipRemoveMap.keySet()) {
        IntArray deletedRels=nodeElement.relationshipRemoveMap.get(type);
        for (int i=0; i < deletedRels.length(); i++) {
          int relId=deletedRels.get(i);
          if (nodeManager.relCreated(relId)) {
            continue;
          }
          RelationshipProxy rel=new RelationshipProxy(relId,nodeManager);
          if (rel.getStartNode().getId() == nodeId) {
            result.deleted(new RelationshipProxy(relId,nodeManager));
          }
        }
      }
    }
    if (nodeElement.propertyAddMap != null && !nodeElement.deleted) {
      for (      PropertyData data : nodeElement.propertyAddMap.values()) {
        String key=nodeManager.getKeyForProperty(data.getId());
        Object oldValue=nodeImpl.getCommittedPropertyValue(key);
        Object newValue=data.getValue();
        result.assignedProperty(node,key,newValue,oldValue);
      }
    }
    if (nodeElement.propertyRemoveMap != null) {
      for (      PropertyData data : nodeElement.propertyRemoveMap.values()) {
        String key=nodeManager.getKeyForProperty(data.getId());
        Object oldValue=data.getValue();
        if (oldValue == null && !nodeElement.deleted) {
          nodeImpl.getCommittedPropertyValue(key);
        }
        result.removedProperty(node,key,oldValue);
      }
    }
  }
}",0.8202204484986697
154944,"private void populateRelationshipPropertyEvents(PrimitiveElement element,TransactionDataImpl result){
  for (  int relId : element.relationships.keySet()) {
    CowRelElement relElement=element.relationships.get(relId);
    RelationshipProxy rel=new RelationshipProxy(relId,nodeManager);
    RelationshipImpl relImpl=nodeManager.getRelForProxy(relId);
    if (relElement.deleted) {
      if (nodeManager.relCreated(relId)) {
        continue;
      }
      List<PropertyEventData> props=relImpl.getAllCommittedProperties();
      for (      PropertyEventData data : props) {
        result.removedProperty(rel,data.getKey(),data.getValue());
      }
    }
 else {
      if (relElement.propertyAddMap != null) {
        for (        PropertyData data : relElement.propertyAddMap.values()) {
          String key=nodeManager.getKeyForProperty(data.getId());
          Object oldValue=relImpl.getCommittedPropertyValue(key);
          Object newValue=data.getValue();
          result.assignedProperty(rel,key,newValue,oldValue);
        }
      }
      if (relElement.propertyRemoveMap != null) {
        for (        PropertyData data : relElement.propertyRemoveMap.values()) {
          String key=nodeManager.getKeyForProperty(data.getId());
          Object oldValue=relImpl.getCommittedPropertyValue(key);
          result.removedProperty(rel,key,oldValue);
        }
      }
    }
  }
}","private void populateRelationshipPropertyEvents(PrimitiveElement element,TransactionDataImpl result){
  for (  int relId : element.relationships.keySet()) {
    CowRelElement relElement=element.relationships.get(relId);
    RelationshipProxy rel=new RelationshipProxy(relId,nodeManager);
    RelationshipImpl relImpl=nodeManager.getRelForProxy(relId);
    if (relElement.deleted) {
      if (nodeManager.relCreated(relId)) {
        continue;
      }
    }
    if (relElement.propertyAddMap != null && !relElement.deleted) {
      for (      PropertyData data : relElement.propertyAddMap.values()) {
        String key=nodeManager.getKeyForProperty(data.getId());
        Object oldValue=relImpl.getCommittedPropertyValue(key);
        Object newValue=data.getValue();
        result.assignedProperty(rel,key,newValue,oldValue);
      }
    }
    if (relElement.propertyRemoveMap != null) {
      for (      PropertyData data : relElement.propertyRemoveMap.values()) {
        String key=nodeManager.getKeyForProperty(data.getId());
        Object oldValue=data.getValue();
        if (oldValue != null && !relElement.deleted) {
          relImpl.getCommittedPropertyValue(key);
        }
        result.removedProperty(rel,key,oldValue);
      }
    }
  }
}",0.8648036253776435
154945,"public void delete(){
  nodeManager.acquireLock(this,LockType.WRITE);
  boolean success=false;
  try {
    nodeManager.deleteNode(this);
    success=true;
  }
  finally {
    nodeManager.releaseLock(this,LockType.WRITE);
    if (!success) {
      setRollbackOnly();
    }
  }
}","public void delete(){
  nodeManager.acquireLock(this,LockType.WRITE);
  boolean success=false;
  try {
    ArrayMap<Integer,PropertyData> skipMap=nodeManager.getCowPropertyRemoveMap(this,true);
    ArrayMap<Integer,PropertyData> removedProps=nodeManager.deleteNode(this);
    if (removedProps.size() > 0) {
      for (      int index : removedProps.keySet()) {
        skipMap.put(index,removedProps.get(index));
      }
    }
    success=true;
  }
  finally {
    nodeManager.releaseLock(this,LockType.WRITE);
    if (!success) {
      setRollbackOnly();
    }
  }
}",0.6563981042654028
154946,"void deleteNode(NodeImpl node){
  int nodeId=(int)node.getId();
  deletePrimitive(node);
  persistenceManager.nodeDelete(nodeId);
}","ArrayMap<Integer,PropertyData> deleteNode(NodeImpl node){
  int nodeId=(int)node.getId();
  deletePrimitive(node);
  return persistenceManager.nodeDelete(nodeId);
}",0.8677966101694915
154947,"void deleteRelationship(RelationshipImpl rel){
  int relId=(int)rel.getId();
  deletePrimitive(rel);
  persistenceManager.relDelete(relId);
}","ArrayMap<Integer,PropertyData> deleteRelationship(RelationshipImpl rel){
  int relId=(int)rel.getId();
  deletePrimitive(rel);
  return persistenceManager.relDelete(relId);
}",0.8761904761904762
154948,"@Override void deleteNode(NodeImpl node){
  throw new ReadOnlyDbException();
}","@Override ArrayMap<Integer,PropertyData> deleteNode(NodeImpl node){
  throw new ReadOnlyDbException();
}",0.8241758241758241
154949,"@Override void deleteRelationship(RelationshipImpl rel){
  throw new ReadOnlyDbException();
}","@Override ArrayMap<Integer,PropertyData> deleteRelationship(RelationshipImpl rel){
  throw new ReadOnlyDbException();
}",0.8490566037735849
154950,"public void delete(){
  NodeImpl startNode=null;
  NodeImpl endNode=null;
  boolean startNodeLocked=false;
  boolean endNodeLocked=false;
  nodeManager.acquireLock(this,LockType.WRITE);
  boolean success=false;
  try {
    startNode=nodeManager.getLightNode(startNodeId);
    if (startNode != null) {
      nodeManager.acquireLock(startNode,LockType.WRITE);
      startNodeLocked=true;
    }
    endNode=nodeManager.getLightNode(endNodeId);
    if (endNode != null) {
      nodeManager.acquireLock(endNode,LockType.WRITE);
      endNodeLocked=true;
    }
    nodeManager.deleteRelationship(this);
    if (startNode != null) {
      startNode.removeRelationship(type,id);
    }
    if (endNode != null) {
      endNode.removeRelationship(type,id);
    }
    success=true;
  }
  finally {
    boolean releaseFailed=false;
    try {
      if (startNodeLocked) {
        nodeManager.releaseLock(startNode,LockType.WRITE);
      }
    }
 catch (    Exception e) {
      releaseFailed=true;
      e.printStackTrace();
    }
    try {
      if (endNodeLocked) {
        nodeManager.releaseLock(endNode,LockType.WRITE);
      }
    }
 catch (    Exception e) {
      releaseFailed=true;
      e.printStackTrace();
    }
    nodeManager.releaseLock(this,LockType.WRITE);
    if (!success) {
      setRollbackOnly();
    }
    if (releaseFailed) {
      throw new LockException(""String_Node_Str"" + startNode + ""String_Node_Str""+ endNode+ ""String_Node_Str""+ this);
    }
  }
}","public void delete(){
  NodeImpl startNode=null;
  NodeImpl endNode=null;
  boolean startNodeLocked=false;
  boolean endNodeLocked=false;
  nodeManager.acquireLock(this,LockType.WRITE);
  boolean success=false;
  try {
    startNode=nodeManager.getLightNode(startNodeId);
    if (startNode != null) {
      nodeManager.acquireLock(startNode,LockType.WRITE);
      startNodeLocked=true;
    }
    endNode=nodeManager.getLightNode(endNodeId);
    if (endNode != null) {
      nodeManager.acquireLock(endNode,LockType.WRITE);
      endNodeLocked=true;
    }
    ArrayMap<Integer,PropertyData> skipMap=nodeManager.getCowPropertyRemoveMap(this,true);
    ArrayMap<Integer,PropertyData> removedProps=nodeManager.deleteRelationship(this);
    if (removedProps.size() > 0) {
      for (      int index : removedProps.keySet()) {
        skipMap.put(index,removedProps.get(index));
      }
    }
    success=true;
    if (startNode != null) {
      startNode.removeRelationship(type,id);
    }
    if (endNode != null) {
      endNode.removeRelationship(type,id);
    }
    success=true;
  }
  finally {
    boolean releaseFailed=false;
    try {
      if (startNodeLocked) {
        nodeManager.releaseLock(startNode,LockType.WRITE);
      }
    }
 catch (    Exception e) {
      releaseFailed=true;
      e.printStackTrace();
    }
    try {
      if (endNodeLocked) {
        nodeManager.releaseLock(endNode,LockType.WRITE);
      }
    }
 catch (    Exception e) {
      releaseFailed=true;
      e.printStackTrace();
    }
    nodeManager.releaseLock(this,LockType.WRITE);
    if (!success) {
      setRollbackOnly();
    }
    if (releaseFailed) {
      throw new LockException(""String_Node_Str"" + startNode + ""String_Node_Str""+ endNode+ ""String_Node_Str""+ this);
    }
  }
}",0.887584928968499
154951,"public Object getStringFor(PropertyRecord propRecord){
  int recordToFind=(int)propRecord.getPropBlock();
  Iterator<DynamicRecord> records=propRecord.getValueRecords().iterator();
  List<char[]> charList=new LinkedList<char[]>();
  int totalSize=0;
  while (recordToFind != Record.NO_NEXT_BLOCK.intValue() && records.hasNext()) {
    DynamicRecord record=records.next();
    if (record.getId() == recordToFind) {
      if (record.isLight()) {
        stringPropertyStore.makeHeavy(record);
      }
      if (!record.isCharData()) {
        ByteBuffer buf=ByteBuffer.wrap(record.getData());
        char[] chars=new char[record.getData().length / 2];
        totalSize+=chars.length;
        buf.asCharBuffer().get(chars);
        charList.add(chars);
      }
 else {
        charList.add(record.getDataAsChar());
      }
      recordToFind=record.getNextBlock();
      records=propRecord.getValueRecords().iterator();
    }
  }
  StringBuffer buf=new StringBuffer();
  for (  char[] str : charList) {
    buf.append(str);
  }
  return buf.toString();
}","public Object getStringFor(PropertyRecord propRecord){
  int recordToFind=(int)propRecord.getPropBlock();
  Map<Integer,DynamicRecord> recordsMap=new HashMap<Integer,DynamicRecord>();
  for (  DynamicRecord record : propRecord.getValueRecords()) {
    recordsMap.put(record.getId(),record);
  }
  List<char[]> charList=new LinkedList<char[]>();
  int totalSize=0;
  while (recordToFind != Record.NO_NEXT_BLOCK.intValue()) {
    DynamicRecord record=recordsMap.get(recordToFind);
    if (record.isLight()) {
      stringPropertyStore.makeHeavy(record);
    }
    if (!record.isCharData()) {
      ByteBuffer buf=ByteBuffer.wrap(record.getData());
      char[] chars=new char[record.getData().length / 2];
      totalSize+=chars.length;
      buf.asCharBuffer().get(chars);
      charList.add(chars);
    }
 else {
      charList.add(record.getDataAsChar());
    }
    recordToFind=record.getNextBlock();
  }
  StringBuffer buf=new StringBuffer();
  for (  char[] str : charList) {
    buf.append(str);
  }
  return buf.toString();
}",0.8234165067178503
154952,"public Object getArrayFor(PropertyRecord propertyRecord){
  int recordToFind=(int)propertyRecord.getPropBlock();
  Iterator<DynamicRecord> records=propertyRecord.getValueRecords().iterator();
  List<byte[]> byteList=new LinkedList<byte[]>();
  int totalSize=0;
  while (recordToFind != Record.NO_NEXT_BLOCK.intValue() && records.hasNext()) {
    DynamicRecord record=records.next();
    if (record.getId() == recordToFind) {
      if (record.isLight()) {
        arrayPropertyStore.makeHeavy(record);
      }
      if (!record.isCharData()) {
        ByteBuffer buf=ByteBuffer.wrap(record.getData());
        byte[] bytes=new byte[record.getData().length];
        totalSize+=bytes.length;
        buf.get(bytes);
        byteList.add(bytes);
      }
 else {
        throw new InvalidRecordException(""String_Node_Str"" + record);
      }
      recordToFind=record.getNextBlock();
      records=propertyRecord.getValueRecords().iterator();
    }
  }
  byte[] bArray=new byte[totalSize];
  int offset=0;
  for (  byte[] currentArray : byteList) {
    System.arraycopy(currentArray,0,bArray,offset,currentArray.length);
    offset+=currentArray.length;
  }
  return arrayPropertyStore.getRightArray(bArray);
}","public Object getArrayFor(PropertyRecord propertyRecord){
  int recordToFind=(int)propertyRecord.getPropBlock();
  Map<Integer,DynamicRecord> recordsMap=new HashMap<Integer,DynamicRecord>();
  for (  DynamicRecord record : propertyRecord.getValueRecords()) {
    recordsMap.put(record.getId(),record);
  }
  List<byte[]> byteList=new LinkedList<byte[]>();
  int totalSize=0;
  while (recordToFind != Record.NO_NEXT_BLOCK.intValue()) {
    DynamicRecord record=recordsMap.get(recordToFind);
    if (record.isLight()) {
      arrayPropertyStore.makeHeavy(record);
    }
    if (!record.isCharData()) {
      ByteBuffer buf=ByteBuffer.wrap(record.getData());
      byte[] bytes=new byte[record.getData().length];
      totalSize+=bytes.length;
      buf.get(bytes);
      byteList.add(bytes);
    }
 else {
      throw new InvalidRecordException(""String_Node_Str"" + record);
    }
    recordToFind=record.getNextBlock();
  }
  byte[] bArray=new byte[totalSize];
  int offset=0;
  for (  byte[] currentArray : byteList) {
    System.arraycopy(currentArray,0,bArray,offset,currentArray.length);
    offset+=currentArray.length;
  }
  return arrayPropertyStore.getRightArray(bArray);
}",0.7659395973154363
154953,"@SuppressWarnings(""String_Node_Str"") public void afterCompletion(int status){
  if (status == Status.STATUS_COMMITTED) {
    for (    HandlerAndState state : this.states) {
      state.handler.afterCommit(this.transactionData,state.state);
    }
  }
 else   if (status == Status.STATUS_ROLLEDBACK) {
    for (    HandlerAndState state : this.states) {
      state.handler.afterRollback(this.transactionData,state.state);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}","@SuppressWarnings(""String_Node_Str"") public void afterCompletion(int status){
  if (status == Status.STATUS_COMMITTED) {
    for (    HandlerAndState state : this.states) {
      state.handler.afterCommit(this.transactionData,state.state);
    }
  }
 else   if (status == Status.STATUS_ROLLEDBACK) {
    if (this.states == null) {
      return;
    }
    for (    HandlerAndState state : this.states) {
      state.handler.afterRollback(this.transactionData,state.state);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + status);
  }
}",0.9518413597733713
154954,"public ExperimentalAStar(RelationshipExpander expander,CostEvaluator<Double> costEvaluator,EstimateEvaluator<Double> estimateEvaluator){
  this.traversalDescription=TraversalFactory.createTraversalDescription().uniqueness(Uniqueness.RELATIONSHIP_GLOBAL).expand(expander);
  this.costEvaluator=costEvaluator;
  this.estimateEvaluator=estimateEvaluator;
}","public ExperimentalAStar(RelationshipExpander expander,CostEvaluator<Double> costEvaluator,EstimateEvaluator<Double> estimateEvaluator){
  this.traversalDescription=TraversalFactory.createTraversalDescription().uniqueness(Uniqueness.NONE).expand(expander);
  this.costEvaluator=costEvaluator;
  this.estimateEvaluator=estimateEvaluator;
}",0.9725036179450072
154955,"public ExpansionSource nextPosition(){
  while (true) {
    ExpansionSource next=current.next();
    if (next != null) {
      P newPriority=addPriority(next,currentAggregatedValue,calculateValue(next));
      queue.put(next,newPriority);
    }
 else {
      break;
    }
  }
  Entry<ExpansionSource,P> entry=queue.pop();
  if (entry != null) {
    current=entry.getEntity();
    currentAggregatedValue=entry.getPriority();
    return current;
  }
  return null;
}","public ExpansionSource nextPosition(){
  while (true) {
    ExpansionSource next=current.next();
    if (next != null) {
      if (!visitedNodes.contains(next.node().getId())) {
        P newPriority=addPriority(next,currentAggregatedValue,calculateValue(next));
        queue.put(next,newPriority);
        System.out.println(""String_Node_Str"" + newPriority + ""String_Node_Str""+ next.node().getProperty(SimpleGraphBuilder.KEY_ID));
      }
    }
 else {
      break;
    }
  }
  Entry<ExpansionSource,P> entry=queue.pop();
  if (entry != null) {
    current=entry.getEntity();
    currentAggregatedValue=entry.getPriority();
    visitedNodes.add(current.node().getId());
    System.out.println(""String_Node_Str"" + currentAggregatedValue + ""String_Node_Str""+ current.node().getProperty(SimpleGraphBuilder.KEY_ID));
    return current;
  }
  return null;
}",0.7035633055344959
154956,"/** 
 * Add an entity to the priority map.
 * @param entity the entity to add.
 * @param priority the priority of the entity.
 */
public void put(E entity,P priority){
  K key=keyFunction.convert(entity);
  Node<E,P> node=map.get(key);
  if (node != null && priority.equals(node.priority)) {
    node.head=new Link<E>(entity,node.head);
  }
 else {
    node=new Node<E,P>(entity,priority);
    map.put(key,node);
    queue.add(node);
  }
}","private void put(E entity,P priority,K key){
  Node<E,P> node=new Node<E,P>(entity,priority);
  map.put(key,node);
  queue.add(node);
}",0.4564459930313589
154957,"/** 
 * Remove and return the entry with the highest priority.
 * @return the entry with the highest priority.
 */
public Entry<E,P> pop(){
  Node<E,P> node=queue.peek();
  if (node == null) {
    return null;
  }
 else   if (node.head.next == null) {
    node=queue.poll();
    map.remove(keyFunction.convert(node.head.entity));
  }
 else {
    node.head=node.head.next;
  }
  return new Entry<E,P>(node);
}","/** 
 * Remove and return the entry with the highest priority.
 * @return the entry with the highest priority.
 */
public Entry<E,P> pop(){
  Node<E,P> node=queue.peek();
  Entry<E,P> result=null;
  if (node == null) {
    return null;
  }
 else   if (node.head.next == null) {
    node=queue.poll();
    map.remove(keyFunction.convert(node.head.entity));
    result=new Entry<E,P>(node);
  }
 else {
    result=new Entry<E,P>(node);
    node.head=node.head.next;
  }
  return result;
}",0.4116331096196868
154958,"@Override protected WeightedPath fetchNextOrNull(){
  if (!paths.hasNext()) {
    return null;
  }
  WeightedPath path=new WeightedPathImpl(costEvaluator,paths.next());
  if (foundWeight != null && path.weight() > foundWeight) {
    return null;
  }
  foundWeight=path.weight();
  return path;
}","@Override protected WeightedPath fetchNextOrNull(){
  if (!paths.hasNext()) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  WeightedPath path=new WeightedPathImpl(costEvaluator,paths.next());
  System.out.println(""String_Node_Str"" + path);
  if (foundWeight != null && path.weight() > foundWeight) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  foundWeight=path.weight();
  return path;
}",0.8149171270718232
154959,"@Ignore @Test public void canGetMultiplePathsInASmallRoadNetwork() throws Exception {
  Node nodeA=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",1d);
  Node nodeB=graph.makeNode(""String_Node_Str"",""String_Node_Str"",2d,""String_Node_Str"",2d);
  Node nodeC=graph.makeNode(""String_Node_Str"",""String_Node_Str"",0d,""String_Node_Str"",3d);
  Node nodeD=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",4d);
  Node nodeE=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",4d);
  Node nodeF=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",4d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2.5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7.3d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2.5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",12d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",25d);
  AStar algo=new AStar(graphDb,TraversalFactory.expanderForAllTypes(),new DoubleEvaluator(""String_Node_Str""),ESTIMATE_EVALUATOR);
  for (  Node[] nodes : new Node[][]{{nodeA,nodeF},{nodeF,nodeA}}) {
    int found=0;
    Iterator<WeightedPath> paths=algo.findAllPaths(nodes[0],nodes[1]).iterator();
    for (int i=0; i < 2; i++) {
      assertTrue(""String_Node_Str"",paths.hasNext());
      Path path=paths.next();
      if (path.length() != found && path.length() == 3) {
        assertContains(path.nodes(),nodeA,nodeC,nodeE,nodeF);
      }
 else       if (path.length() != found && path.length() == 4) {
        assertContains(path.nodes(),nodeA,nodeB,nodeD,nodeE,nodeF);
      }
 else {
        fail(""String_Node_Str"" + path.length());
      }
      found=path.length();
    }
    assertFalse(""String_Node_Str"",paths.hasNext());
  }
}","@Ignore @Test public void canGetMultiplePathsInASmallRoadNetwork() throws Exception {
  Node nodeA=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",1d);
  Node nodeB=graph.makeNode(""String_Node_Str"",""String_Node_Str"",2d,""String_Node_Str"",2d);
  Node nodeC=graph.makeNode(""String_Node_Str"",""String_Node_Str"",0d,""String_Node_Str"",3d);
  Node nodeD=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",4d);
  Node nodeE=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",4d);
  Node nodeF=graph.makeNode(""String_Node_Str"",""String_Node_Str"",1d,""String_Node_Str"",4d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2.5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7.3d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2.5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",12d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",25d);
  PathFinder<WeightedPath> algo=newFinder();
  for (  Node[] nodes : new Node[][]{{nodeA,nodeF},{nodeF,nodeA}}) {
    int found=0;
    Iterator<WeightedPath> paths=algo.findAllPaths(nodes[0],nodes[1]).iterator();
    for (int i=0; i < 2; i++) {
      assertTrue(""String_Node_Str"" + i + ""String_Node_Str"",paths.hasNext());
      Path path=paths.next();
      if (path.length() != found && path.length() == 3) {
        assertContains(path.nodes(),nodeA,nodeC,nodeE,nodeF);
      }
 else       if (path.length() != found && path.length() == 4) {
        assertContains(path.nodes(),nodeA,nodeB,nodeD,nodeE,nodeF);
      }
 else {
        fail(""String_Node_Str"" + path.length());
      }
      found=path.length();
    }
    assertFalse(""String_Node_Str"",paths.hasNext());
  }
}",0.960207205085943
154960,"@Test public void testSimplest(){
  Node nodeA=graph.makeNode(""String_Node_Str"",""String_Node_Str"",0d,""String_Node_Str"",0d);
  Node nodeB=graph.makeNode(""String_Node_Str"",""String_Node_Str"",2d,""String_Node_Str"",1d);
  Node nodeC=graph.makeNode(""String_Node_Str"",""String_Node_Str"",7d,""String_Node_Str"",0d);
  Relationship relAB=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  Relationship relBC=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3d);
  Relationship relAC=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10d);
  AStar astar=new AStar(graphDb,TraversalFactory.expanderForAllTypes(),new DoubleEvaluator(""String_Node_Str""),ESTIMATE_EVALUATOR);
  WeightedPath path=astar.findSinglePath(nodeA,nodeC);
  assertEquals((Double)5d,(Double)path.weight());
  assertPath(path,nodeA,nodeB,nodeC);
}","@Test public void testSimplest(){
  Node nodeA=graph.makeNode(""String_Node_Str"",""String_Node_Str"",0d,""String_Node_Str"",0d);
  Node nodeB=graph.makeNode(""String_Node_Str"",""String_Node_Str"",2d,""String_Node_Str"",1d);
  Node nodeC=graph.makeNode(""String_Node_Str"",""String_Node_Str"",7d,""String_Node_Str"",0d);
  Relationship relAB=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  Relationship relAB2=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  Relationship relBC=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3d);
  Relationship relAC=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10d);
  PathFinder<WeightedPath> astar=newFinder();
  int counter=0;
  for (  WeightedPath path : astar.findAllPaths(nodeA,nodeC)) {
    assertEquals((Double)5d,(Double)path.weight());
    assertPath(path,nodeA,nodeB,nodeC);
    counter++;
  }
}",0.8279329608938547
154961,"@Ignore @Test public void canGetMultiplePathsInTriangleGraph() throws Exception {
  Node nodeA=graph.makeNode(""String_Node_Str"",""String_Node_Str"",0d,""String_Node_Str"",0d);
  Node nodeB=graph.makeNode(""String_Node_Str"",""String_Node_Str"",2d,""String_Node_Str"",1d);
  Node nodeC=graph.makeNode(""String_Node_Str"",""String_Node_Str"",7d,""String_Node_Str"",0d);
  Set<Relationship> expectedFirsts=new HashSet<Relationship>();
  expectedFirsts.add(graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1d));
  expectedFirsts.add(graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1d));
  Relationship expectedSecond=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5d);
  AStar algo=new AStar(graphDb,TraversalFactory.expanderForAllTypes(),new DoubleEvaluator(""String_Node_Str""),ESTIMATE_EVALUATOR);
  Iterator<WeightedPath> paths=algo.findAllPaths(nodeA,nodeC).iterator();
  for (int i=0; i < 2; i++) {
    assertTrue(""String_Node_Str"",paths.hasNext());
    Path path=paths.next();
    assertPath(path,nodeA,nodeB,nodeC);
    Iterator<Relationship> relationships=path.relationships().iterator();
    assertTrue(""String_Node_Str"",relationships.hasNext());
    assertTrue(""String_Node_Str"",expectedFirsts.remove(relationships.next()));
    assertTrue(""String_Node_Str"",relationships.hasNext());
    assertEquals(expectedSecond,relationships.next());
    assertFalse(""String_Node_Str"",relationships.hasNext());
  }
  assertFalse(""String_Node_Str"",paths.hasNext());
}","@Ignore @Test public void canGetMultiplePathsInTriangleGraph() throws Exception {
  Node nodeA=graph.makeNode(""String_Node_Str"",""String_Node_Str"",0d,""String_Node_Str"",0d);
  Node nodeB=graph.makeNode(""String_Node_Str"",""String_Node_Str"",2d,""String_Node_Str"",1d);
  Node nodeC=graph.makeNode(""String_Node_Str"",""String_Node_Str"",7d,""String_Node_Str"",0d);
  Set<Relationship> expectedFirsts=new HashSet<Relationship>();
  expectedFirsts.add(graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1d));
  expectedFirsts.add(graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1d));
  Relationship expectedSecond=graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2d);
  graph.makeEdge(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5d);
  PathFinder<WeightedPath> algo=newFinder();
  Iterator<WeightedPath> paths=algo.findAllPaths(nodeA,nodeC).iterator();
  for (int i=0; i < 2; i++) {
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str"",paths.hasNext());
    Path path=paths.next();
    assertPath(path,nodeA,nodeB,nodeC);
    Iterator<Relationship> relationships=path.relationships().iterator();
    assertTrue(""String_Node_Str"",relationships.hasNext());
    assertTrue(""String_Node_Str"",expectedFirsts.remove(relationships.next()));
    assertTrue(""String_Node_Str"",relationships.hasNext());
    assertEquals(expectedSecond,relationships.next());
    assertFalse(""String_Node_Str"",relationships.hasNext());
  }
  assertFalse(""String_Node_Str"",paths.hasNext());
}",0.9320012890750886
154962,"public static String templateString(String templateString,String variablePrefix,Map<String,? extends Object> data){
  Map<Integer,List<String>> lengthMap=new HashMap<Integer,List<String>>();
  int longest=0;
  for (  String key : data.keySet()) {
    int length=key.length();
    if (length > longest) {
      longest=length;
    }
    List<String> innerList=null;
    Integer innerKey=Integer.valueOf(length);
    if (lengthMap.containsKey(innerKey)) {
      innerList=lengthMap.get(innerKey);
    }
 else {
      innerList=new ArrayList<String>();
      lengthMap.put(innerKey,innerList);
    }
    innerList.add(key);
  }
  String result=templateString;
  for (int i=longest; i >= 0; i--) {
    Integer lengthKey=Integer.valueOf(i);
    if (!lengthMap.containsKey(lengthKey)) {
      continue;
    }
    List<String> list=lengthMap.get(lengthKey);
    for (    String key : list) {
      String replacement=data.get(key).toString();
      String regExpMatchString=variablePrefix + key;
      result=result.replaceAll(regExpMatchString,replacement);
    }
  }
  return result;
}","public static String templateString(String templateString,String variablePrefix,Map<String,? extends Object> data){
  Map<Integer,List<String>> lengthMap=new HashMap<Integer,List<String>>();
  int longest=0;
  for (  String key : data.keySet()) {
    int length=key.length();
    if (length > longest) {
      longest=length;
    }
    List<String> innerList=null;
    Integer innerKey=Integer.valueOf(length);
    if (lengthMap.containsKey(innerKey)) {
      innerList=lengthMap.get(innerKey);
    }
 else {
      innerList=new ArrayList<String>();
      lengthMap.put(innerKey,innerList);
    }
    innerList.add(key);
  }
  String result=templateString;
  for (int i=longest; i >= 0; i--) {
    Integer lengthKey=Integer.valueOf(i);
    if (!lengthMap.containsKey(lengthKey)) {
      continue;
    }
    List<String> list=lengthMap.get(lengthKey);
    for (    String key : list) {
      Object value=data.get(key);
      if (value != null) {
        String replacement=data.get(key).toString();
        String regExpMatchString=variablePrefix + key;
        result=result.replaceAll(regExpMatchString,replacement);
      }
    }
  }
  return result;
}",0.9422818791946308
154963,"public void grabPrompt(){
  this.init();
  while (true) {
    try {
      String line=this.readLine(tryGetProperPromptString());
      if (EXIT_COMMANDS.contains(line)) {
        break;
      }
      line=expandLine(line);
      String result=this.getServer().interpretLine(line,this.session(),this.getOutput());
      if (result == null || result.trim().length() == 0) {
        continue;
      }
      if (result.contains(""String_Node_Str"")) {
        break;
      }
    }
 catch (    Exception e) {
      if (this.shouldPrintStackTraces()) {
        e.printStackTrace();
      }
      this.console.format(getShortExceptionMessage(e) + ""String_Node_Str"");
    }
  }
  this.shutdown();
}","public void grabPrompt(){
  this.init();
  while (true) {
    try {
      String line=this.readLine(tryGetProperPromptString());
      if (EXIT_COMMANDS.contains(line)) {
        break;
      }
      line=expandLine(line);
      String result=this.getServer().interpretLine(line,this.session(),this.getOutput());
      if (result == null || result.trim().length() == 0) {
        continue;
      }
      if (result.contains(""String_Node_Str"")) {
        break;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      this.console.format(getShortExceptionMessage(e) + ""String_Node_Str"");
    }
  }
  this.shutdown();
}",0.9508692365835224
154964,"public int complete(String buffer,int cursor,List candidates){
  if (buffer == null || buffer.length() == 0) {
    return cursor;
  }
  try {
    if (buffer.contains(""String_Node_Str"")) {
      AppCommandParser parser=new AppCommandParser((AppShellServer)client.getServer(),buffer.toString());
      App app=parser.app();
      List<String> appCandidates=app.completionCandidates(buffer,client.session());
      appCandidates=quote(appCandidates);
      if (appCandidates.size() == 1) {
        appCandidates.set(0,appCandidates.get(0) + ""String_Node_Str"");
      }
      candidates.addAll(appCandidates);
      return buffer.length() - TextUtil.lastWordOrQuoteOf(buffer,true).length();
    }
 else {
      return this.appNameCompletor.complete(buffer,cursor,candidates);
    }
  }
 catch (  ShellException e) {
    e.printStackTrace();
  }
  return cursor;
}","public int complete(String buffer,int cursor,List candidates){
  if (buffer == null || buffer.length() == 0) {
    return cursor;
  }
  try {
    if (buffer.contains(""String_Node_Str"")) {
      TabCompletion completion=client.getServer().tabComplete(buffer.trim(),client.session());
      cursor=completion.getCursor();
      candidates.addAll(completion.getCandidates());
    }
 else {
      return this.appNameCompletor.complete(buffer,cursor,candidates);
    }
  }
 catch (  RemoteException e) {
    e.printStackTrace();
  }
catch (  ShellException e) {
    e.printStackTrace();
  }
  return cursor;
}",0.3636363636363636
154965,"@Override public List<String> completionCandidates(String partOfLine,Session session){
  String lastWord=TextUtil.lastWordOrQuoteOf(partOfLine,false);
  if (lastWord.startsWith(""String_Node_Str"")) {
    return super.completionCandidates(partOfLine,session);
  }
  Transaction tx=getServer().getDb().beginTx();
  try {
    TreeSet<String> result=new TreeSet<String>();
    NodeOrRelationship current=getCurrent(session);
    if (current.isNode()) {
      Node node=current.asNode();
      for (      Relationship rel : node.getRelationships()) {
        Node otherNode=rel.getOtherNode(node);
        long otherNodeId=otherNode.getId();
        String title=findTitle(getServer(),session,otherNode);
        if (title != null) {
          if (!result.contains(title)) {
            maybeAddCompletionCandidate(result,title + ""String_Node_Str"" + otherNodeId,lastWord);
          }
        }
        maybeAddCompletionCandidate(result,""String_Node_Str"" + otherNodeId,lastWord);
      }
    }
 else {
      maybeAddCompletionCandidate(result,START_ALIAS,lastWord);
      maybeAddCompletionCandidate(result,END_ALIAS,lastWord);
      Relationship rel=current.asRelationship();
      maybeAddCompletionCandidate(result,""String_Node_Str"" + rel.getStartNode().getId(),lastWord);
      maybeAddCompletionCandidate(result,""String_Node_Str"" + rel.getEndNode().getId(),lastWord);
    }
    tx.success();
    return new ArrayList<String>(result);
  }
 catch (  ShellException e) {
    e.printStackTrace();
    return super.completionCandidates(partOfLine,session);
  }
 finally {
    tx.finish();
  }
}","@Override public List<String> completionCandidates(String partOfLine,Session session){
  String lastWord=TextUtil.lastWordOrQuoteOf(partOfLine,false);
  if (lastWord.startsWith(""String_Node_Str"")) {
    return super.completionCandidates(partOfLine,session);
  }
  try {
    TreeSet<String> result=new TreeSet<String>();
    NodeOrRelationship current=getCurrent(session);
    if (current.isNode()) {
      Node node=current.asNode();
      for (      Relationship rel : node.getRelationships()) {
        Node otherNode=rel.getOtherNode(node);
        long otherNodeId=otherNode.getId();
        String title=findTitle(getServer(),session,otherNode);
        if (title != null) {
          if (!result.contains(title)) {
            maybeAddCompletionCandidate(result,title + ""String_Node_Str"" + otherNodeId,lastWord);
          }
        }
        maybeAddCompletionCandidate(result,""String_Node_Str"" + otherNodeId,lastWord);
      }
    }
 else {
      maybeAddCompletionCandidate(result,START_ALIAS,lastWord);
      maybeAddCompletionCandidate(result,END_ALIAS,lastWord);
      Relationship rel=current.asRelationship();
      maybeAddCompletionCandidate(result,""String_Node_Str"" + rel.getStartNode().getId(),lastWord);
      maybeAddCompletionCandidate(result,""String_Node_Str"" + rel.getEndNode().getId(),lastWord);
    }
    return new ArrayList<String>(result);
  }
 catch (  ShellException e) {
    e.printStackTrace();
    return super.completionCandidates(partOfLine,session);
  }
}",0.968181818181818
154966,"private void doInternalRecovery(String logFileName) throws IOException {
  log.info(""String_Node_Str"" + logFileName + ""String_Node_Str"");
  buffer.clear();
  buffer.limit(8);
  if (fileChannel.read(buffer) != 8) {
    log.info(""String_Node_Str"" + ""String_Node_Str"");
    fileChannel.close();
    boolean success=FileUtils.renameFile(new File(logFileName),new File(logFileName + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str""));
    assert success;
    fileChannel=new RandomAccessFile(logFileName,""String_Node_Str"").getChannel();
    return;
  }
  buffer.flip();
  logVersion=buffer.getLong();
  log.fine(""String_Node_Str"" + logVersion);
  long logEntriesFound=0;
  long lastEntryPos=fileChannel.position();
  while (readEntry()) {
    logEntriesFound++;
    lastEntryPos=fileChannel.position();
  }
  fileChannel.position(lastEntryPos);
  scanIsComplete=true;
  log.fine(""String_Node_Str"" + logEntriesFound + ""String_Node_Str"");
  xaRm.checkXids();
  if (xidIdentMap.size() == 0) {
    log.fine(""String_Node_Str"");
  }
 else {
    log.fine(""String_Node_Str"" + logFileName + ""String_Node_Str""+ xidIdentMap.size()+ ""String_Node_Str"");
    for (    StartEntry entry : xidIdentMap.values()) {
      log.fine(""String_Node_Str"" + logFileName + ""String_Node_Str""+ entry.getXid()+ ""String_Node_Str"");
    }
  }
  recoveredTxMap.clear();
}","private void doInternalRecovery(String logFileName) throws IOException {
  log.info(""String_Node_Str"" + logFileName + ""String_Node_Str"");
  buffer.clear();
  buffer.limit(8);
  if (fileChannel.read(buffer) != 8) {
    log.info(""String_Node_Str"" + ""String_Node_Str"");
    fileChannel.close();
    boolean success=FileUtils.renameFile(new File(logFileName),new File(logFileName + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str""));
    assert success;
    fileChannel=new RandomAccessFile(logFileName,""String_Node_Str"").getChannel();
    return;
  }
  buffer.flip();
  logVersion=buffer.getLong();
  log.fine(""String_Node_Str"" + logVersion);
  long logEntriesFound=0;
  long lastEntryPos=fileChannel.position();
  while (readEntry()) {
    logEntriesFound++;
    lastEntryPos=fileChannel.position();
  }
  fileChannel.position(lastEntryPos);
  buffer.clear();
  while (buffer.hasRemaining()) {
    buffer.put((byte)0);
  }
  buffer.flip();
  long endPosition=fileChannel.size();
  do {
    long bytesLeft=fileChannel.size() - fileChannel.position();
    if (bytesLeft < buffer.capacity()) {
      buffer.limit((int)bytesLeft);
    }
    fileChannel.write(buffer);
    buffer.flip();
  }
 while (fileChannel.position() < endPosition);
  fileChannel.position(lastEntryPos);
  scanIsComplete=true;
  log.fine(""String_Node_Str"" + logEntriesFound + ""String_Node_Str"");
  xaRm.checkXids();
  if (xidIdentMap.size() == 0) {
    log.fine(""String_Node_Str"");
  }
 else {
    log.fine(""String_Node_Str"" + logFileName + ""String_Node_Str""+ xidIdentMap.size()+ ""String_Node_Str"");
    for (    StartEntry entry : xidIdentMap.values()) {
      log.fine(""String_Node_Str"" + logFileName + ""String_Node_Str""+ entry.getXid()+ ""String_Node_Str"");
    }
  }
  recoveredTxMap.clear();
}",0.8626198083067093
154967,"protected PathFinder<Path> instantiatePathFinder(int maxDepth){
  return new TraversalShortestPath(TraversalFactory.expanderForAllTypes());
}","protected PathFinder<Path> instantiatePathFinder(int maxDepth){
  return new ShortestPath(graphDb,maxDepth,TraversalFactory.expanderForTypes(MyRelTypes.R1,Direction.BOTH));
}",0.819047619047619
154968,"public void beforeCompletion(){
  TransactionData data=null;
  data=nodeManager.getTransactionData();
  states=new ArrayList<HandlerAndState>();
  for (  TransactionEventHandler<T> handler : this.handlers) {
    try {
      T state=handler.beforeCommit(data);
      states.add(new HandlerAndState(handler,state));
    }
 catch (    Throwable t) {
      transaction.failure();
      throw new RuntimeException(t);
    }
  }
}","public void beforeCompletion(){
  this.transactionData=nodeManager.getTransactionData();
  states=new ArrayList<HandlerAndState>();
  for (  TransactionEventHandler<T> handler : this.handlers) {
    try {
      T state=handler.beforeCommit(transactionData);
      states.add(new HandlerAndState(handler,state));
    }
 catch (    Throwable t) {
      transaction.failure();
      throw new RuntimeException(t);
    }
  }
}",0.9550827423167848
154969,"public void flushAll(){
  relTypeStore.flushAll();
  propStore.flushAll();
  relStore.flushAll();
  nodeStore.flushAll();
}","public void flushAll(){
  if (relTypeStore == null || propStore == null || relStore == null || nodeStore == null) {
    return;
  }
  relTypeStore.flushAll();
  propStore.flushAll();
  relStore.flushAll();
  nodeStore.flushAll();
}",0.2768361581920904
154970,"public void close(){
  xaContainer.close();
  if (logApplied) {
    neoStore.rebuildIdGenerators();
    logApplied=false;
  }
  neoStore.close();
  logger.fine(""String_Node_Str"");
}","public void close(){
  neoStore.flushAll();
  xaContainer.close();
  if (logApplied) {
    neoStore.rebuildIdGenerators();
    logApplied=false;
  }
  neoStore.close();
  logger.fine(""String_Node_Str"");
}",0.9402597402597402
154971,"public boolean shouldExpandBeyond(ExpansionSource source){
  return !this.pruning.pruneAfter(source.position()) && this.uniquness.check(source,false);
}","public boolean shouldExpandBeyond(ExpansionSource source){
  return this.uniquness.check(source,false) && !this.pruning.pruneAfter(source.position());
}",0.75
154972,"private boolean sendLog(){
  if (retries > 20) {
    close();
  }
  connection.write();
  log(""String_Node_Str"" + logVersionToSend);
  if (!buffer.hasRemaining()) {
    buffer.clear();
    try {
      if (logToSend.read(buffer) <= 0) {
        releaseWriteBuffer();
        if (nextLogVersion != -1) {
          logToSend=master.getLog(xaDsName,nextLogVersion);
          logLength=master.getLogLength(xaDsName,nextLogVersion);
          logVersionToSend=nextLogVersion;
          nextLogVersion=-1;
          setStatus(Status.SETUP_OFFER_LOG);
        }
 else {
          setStatus(Status.GET_MESSAGE);
        }
        logLength=-1;
        logVersionToSend=-1;
        logToSend=null;
        return true;
      }
      buffer.flip();
    }
 catch (    IOException e) {
      log(""String_Node_Str"",e);
      close();
      return true;
    }
  }
  retries++;
  return false;
}","private boolean sendLog(){
  if (retries > 20) {
    close();
  }
  connection.write();
  log(""String_Node_Str"" + logVersionToSend);
  if (!buffer.hasRemaining()) {
    buffer.clear();
    try {
      if (logToSend.read(buffer) <= 0) {
        releaseWriteBuffer();
        logToSend.close();
        if (nextLogVersion != -1) {
          logToSend=master.getLog(xaDsName,nextLogVersion);
          logLength=master.getLogLength(xaDsName,nextLogVersion);
          logVersionToSend=nextLogVersion;
          nextLogVersion=-1;
          setStatus(Status.SETUP_OFFER_LOG);
        }
 else {
          setStatus(Status.GET_MESSAGE);
        }
        logLength=-1;
        logVersionToSend=-1;
        logToSend=null;
        return true;
      }
      buffer.flip();
    }
 catch (    IOException e) {
      log(""String_Node_Str"",e);
      close();
      return true;
    }
  }
  retries++;
  return false;
}",0.9848908785674314
154973,"public Iterable<Relationship> expand(final Node start){
  if (types.length == 0) {
    return start.getRelationships();
  }
  if (types.length == 1) {
    RelationshipType type=types[0];
    return start.getRelationships(type,directions.get(type));
  }
  return new FilteringIterable<Relationship>(start.getRelationships(types)){
    @Override protected boolean passes(    Relationship item){
switch (directions.get(item.getType())) {
case INCOMING:
        return item.getEndNode().equals(start);
case OUTGOING:
      return item.getStartNode().equals(start);
default :
    return true;
}
}
}
;
}","public Iterable<Relationship> expand(final Node start){
  if (types.length == 0) {
    return start.getRelationships();
  }
  if (types.length == 1) {
    RelationshipType type=types[0];
    return start.getRelationships(type,directions.get(type.name()));
  }
  return new FilteringIterable<Relationship>(start.getRelationships(types)){
    @Override protected boolean passes(    Relationship item){
switch (directions.get(item.getType().name())) {
case INCOMING:
        return item.getEndNode().equals(start);
case OUTGOING:
      return item.getStartNode().equals(start);
default :
    return true;
}
}
}
;
}",0.98841059602649
154974,"@Override protected boolean passes(Relationship item){
switch (directions.get(item.getType())) {
case INCOMING:
    return item.getEndNode().equals(start);
case OUTGOING:
  return item.getStartNode().equals(start);
default :
return true;
}
}","@Override protected boolean passes(Relationship item){
switch (directions.get(item.getType().name())) {
case INCOMING:
    return item.getEndNode().equals(start);
case OUTGOING:
  return item.getStartNode().equals(start);
default :
return true;
}
}",0.985685071574642
154975,"private RelationshipExpander(RelationshipType[] types,Direction[] dirs){
  if (types.length != dirs.length) {
    throw new IllegalArgumentException();
  }
  this.types=new RelationshipType[types.length];
  this.directions=new HashMap<RelationshipType,Direction>();
  for (int i=0; i < types.length; i++) {
    this.types[i]=types[i];
    this.directions.put(types[i],dirs[i]);
  }
}","private RelationshipExpander(RelationshipType[] types,Direction[] dirs){
  if (types.length != dirs.length) {
    throw new IllegalArgumentException();
  }
  this.types=new RelationshipType[types.length];
  this.directions=new HashMap<String,Direction>();
  for (int i=0; i < types.length; i++) {
    this.types[i]=types[i];
    this.directions.put(types[i].name(),dirs[i]);
  }
}",0.9619921363040628
154976,"public ArrayMap<Integer,PropertyData> getCowPropertyRemoveMap(Primitive primitive,boolean create){
  if (!create) {
    return getCowPropertyRemoveMap(primitive);
  }
  PrimitiveElement primitiveElement=getAndSetupPrimitiveElement();
  if (primitive instanceof NodeImpl) {
    ArrayMap<Integer,CowNodeElement> cowElements=primitiveElement.nodes;
    CowNodeElement element=cowElements.get(primitive.id);
    if (element == null) {
      element=new CowNodeElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyRemoveMap == null) {
      element.propertyRemoveMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyRemoveMap;
  }
 else   if (primitive instanceof RelationshipImpl) {
    ArrayMap<Integer,CowRelElement> cowElements=primitiveElement.relationships;
    CowRelElement element=cowElements.get(primitive.id);
    if (element == null) {
      element=new CowRelElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyRemoveMap == null) {
      element.propertyRemoveMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyRemoveMap;
  }
  return null;
}","public ArrayMap<Integer,PropertyData> getCowPropertyRemoveMap(Primitive primitive,boolean create){
  if (!create) {
    return getCowPropertyRemoveMap(primitive);
  }
  PrimitiveElement primitiveElement=getAndSetupPrimitiveElement();
  if (primitive instanceof NodeImpl) {
    ArrayMap<Integer,CowNodeElement> cowElements=primitiveElement.nodes;
    CowNodeElement element=cowElements.get(primitive.id);
    if (element != null && element.deleted) {
      throw new IllegalStateException(""String_Node_Str"" + primitive.id + ""String_Node_Str"");
    }
    if (element == null) {
      element=new CowNodeElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyRemoveMap == null) {
      element.propertyRemoveMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyRemoveMap;
  }
 else   if (primitive instanceof RelationshipImpl) {
    ArrayMap<Integer,CowRelElement> cowElements=primitiveElement.relationships;
    CowRelElement element=cowElements.get(primitive.id);
    if (element != null && element.deleted) {
      throw new IllegalStateException(""String_Node_Str"" + primitive.id + ""String_Node_Str"");
    }
    if (element == null) {
      element=new CowRelElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyRemoveMap == null) {
      element.propertyRemoveMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyRemoveMap;
  }
  return null;
}",0.8891437308868502
154977,"public ArrayMap<Integer,PropertyData> getCowPropertyAddMap(Primitive primitive,boolean create){
  if (!create) {
    return getCowPropertyAddMap(primitive);
  }
  PrimitiveElement primitiveElement=getAndSetupPrimitiveElement();
  if (primitive instanceof NodeImpl) {
    ArrayMap<Integer,CowNodeElement> cowElements=primitiveElement.nodes;
    CowNodeElement element=cowElements.get(primitive.id);
    if (element == null) {
      element=new CowNodeElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyAddMap == null) {
      element.propertyAddMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyAddMap;
  }
 else   if (primitive instanceof RelationshipImpl) {
    ArrayMap<Integer,CowRelElement> cowElements=primitiveElement.relationships;
    CowRelElement element=cowElements.get(primitive.id);
    if (element == null) {
      element=new CowRelElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyAddMap == null) {
      element.propertyAddMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyAddMap;
  }
  return null;
}","public ArrayMap<Integer,PropertyData> getCowPropertyAddMap(Primitive primitive,boolean create){
  if (!create) {
    return getCowPropertyAddMap(primitive);
  }
  PrimitiveElement primitiveElement=getAndSetupPrimitiveElement();
  if (primitive instanceof NodeImpl) {
    ArrayMap<Integer,CowNodeElement> cowElements=primitiveElement.nodes;
    CowNodeElement element=cowElements.get(primitive.id);
    if (element != null && element.deleted) {
      throw new IllegalStateException(""String_Node_Str"" + primitive.id + ""String_Node_Str"");
    }
    if (element == null) {
      element=new CowNodeElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyAddMap == null) {
      element.propertyAddMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyAddMap;
  }
 else   if (primitive instanceof RelationshipImpl) {
    ArrayMap<Integer,CowRelElement> cowElements=primitiveElement.relationships;
    CowRelElement element=cowElements.get(primitive.id);
    if (element != null && element.deleted) {
      throw new IllegalStateException(""String_Node_Str"" + primitive.id + ""String_Node_Str"");
    }
    if (element == null) {
      element=new CowRelElement();
      cowElements.put(primitive.id,element);
    }
    if (element.propertyAddMap == null) {
      element.propertyAddMap=new ArrayMap<Integer,PropertyData>();
    }
    return element.propertyAddMap;
  }
  return null;
}",0.8870716510903427
154978,"void deleteNode(NodeImpl node){
  int nodeId=(int)node.getId();
  persistenceManager.nodeDelete(nodeId);
}","void deleteNode(NodeImpl node){
  int nodeId=(int)node.getId();
  deletePrimitive(node);
  persistenceManager.nodeDelete(nodeId);
}",0.8945147679324894
154979,"void deleteRelationship(RelationshipImpl rel){
  int relId=(int)rel.getId();
  persistenceManager.relDelete(relId);
}","void deleteRelationship(RelationshipImpl rel){
  int relId=(int)rel.getId();
  deletePrimitive(rel);
  persistenceManager.relDelete(relId);
}",0.9069767441860463
154980,"public boolean nodeLoadLight(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord != null) {
    return nodeRecord.inUse();
  }
  return getNodeStore().loadLightNode(nodeId);
}","public boolean nodeLoadLight(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord != null) {
    return true;
  }
  return getNodeStore().loadLightNode(nodeId);
}",0.9481865284974094
154981,"public RelationshipData relationshipLoad(int id){
  RelationshipRecord relRecord=getRelationshipRecord(id);
  if (relRecord != null) {
    if (!relRecord.inUse()) {
      return null;
    }
    return new RelationshipData(id,relRecord.getFirstNode(),relRecord.getSecondNode(),relRecord.getType());
  }
  relRecord=getRelationshipStore().getLightRel(id);
  if (relRecord != null) {
    return new RelationshipData(id,relRecord.getFirstNode(),relRecord.getSecondNode(),relRecord.getType());
  }
  return null;
}","public RelationshipData relationshipLoad(int id){
  RelationshipRecord relRecord=getRelationshipRecord(id);
  if (relRecord != null) {
    return new RelationshipData(id,relRecord.getFirstNode(),relRecord.getSecondNode(),relRecord.getType());
  }
  relRecord=getRelationshipStore().getLightRel(id);
  if (relRecord != null) {
    return new RelationshipData(id,relRecord.getFirstNode(),relRecord.getSecondNode(),relRecord.getType());
  }
  return null;
}",0.9428868120456906
154982,"public ArrayMap<Integer,PropertyData> relGetProperties(int relId){
  RelationshipRecord relRecord=getRelationshipRecord(relId);
  if (relRecord == null) {
    relRecord=getRelationshipStore().getRecord(relId);
  }
  if (!relRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + relId + ""String_Node_Str"");
  }
  int nextProp=relRecord.getNextProp();
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyRecord(nextProp);
    if (propRecord == null) {
      propRecord=getPropertyStore().getLightRecord(nextProp);
    }
    if (!propRecord.isCreated()) {
      propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    }
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}","public ArrayMap<Integer,PropertyData> relGetProperties(int relId){
  RelationshipRecord relRecord=getRelationshipRecord(relId);
  if (relRecord != null) {
    if (!relRecord.inUse()) {
      throw new IllegalStateException(""String_Node_Str"" + relId + ""String_Node_Str"");
    }
  }
 else {
    relRecord=getRelationshipStore().getRecord(relId);
  }
  if (!relRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + relId + ""String_Node_Str"");
  }
  int nextProp=relRecord.getNextProp();
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyRecord(nextProp);
    if (propRecord == null) {
      propRecord=getPropertyStore().getLightRecord(nextProp);
    }
    if (!propRecord.isCreated()) {
      propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    }
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}",0.930541368743616
154983,"public RelationshipChainPosition getRelationshipChainPosition(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord == null) {
    nodeRecord=getNodeStore().getRecord(nodeId);
  }
 else   if (!nodeRecord.inUse()) {
    return new RelationshipChainPosition(Record.NO_NEXT_RELATIONSHIP.intValue());
  }
  int nextRel=nodeRecord.getNextRel();
  return new RelationshipChainPosition(nextRel);
}","public RelationshipChainPosition getRelationshipChainPosition(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord == null) {
    nodeRecord=getNodeStore().getRecord(nodeId);
  }
  int nextRel=nodeRecord.getNextRel();
  return new RelationshipChainPosition(nextRel);
}",0.723404255319149
154984,"ArrayMap<Integer,PropertyData> nodeGetProperties(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord == null) {
    nodeRecord=getNodeStore().getRecord(nodeId);
  }
 else   if (!nodeRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
  }
  int nextProp=nodeRecord.getNextProp();
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyRecord(nextProp);
    if (propRecord == null) {
      propRecord=getPropertyStore().getLightRecord(nextProp);
    }
    if (!propRecord.isCreated()) {
      propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    }
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}","ArrayMap<Integer,PropertyData> nodeGetProperties(int nodeId){
  NodeRecord nodeRecord=getNodeRecord(nodeId);
  if (nodeRecord != null) {
    if (!nodeRecord.inUse()) {
      throw new IllegalStateException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
    }
  }
 else {
    nodeRecord=getNodeStore().getRecord(nodeId);
  }
  if (!nodeRecord.inUse()) {
    throw new InvalidRecordException(""String_Node_Str"" + nodeId + ""String_Node_Str"");
  }
  int nextProp=nodeRecord.getNextProp();
  ArrayMap<Integer,PropertyData> propertyMap=new ArrayMap<Integer,PropertyData>(9,false,true);
  while (nextProp != Record.NO_NEXT_PROPERTY.intValue()) {
    PropertyRecord propRecord=getPropertyRecord(nextProp);
    if (propRecord == null) {
      propRecord=getPropertyStore().getLightRecord(nextProp);
    }
    if (!propRecord.isCreated()) {
      propertyMap.put(propRecord.getKeyIndexId(),new PropertyData(propRecord.getId(),propertyGetValueOrNull(propRecord)));
    }
    nextProp=propRecord.getNextProp();
  }
  return propertyMap;
}",0.9012474012474012
154985,"private Collection<Path> least(Map<Integer,List<Path>> hits){
  if (hits.size() == 0) {
    return Collections.emptyList();
  }
  for (int i=0; true; i++) {
    List<Path> paths=hits.get(i);
    if (paths != null) {
      return paths;
    }
  }
}","private Collection<Path> least(Map<Integer,Collection<Hit>> hits){
  if (hits.size() == 0) {
    return Collections.emptyList();
  }
  for (int i=0; true; i++) {
    Collection<Hit> depthHits=hits.get(i);
    if (depthHits != null) {
      return hitsToPaths(depthHits);
    }
  }
}",0.7599243856332704
154986,"DirectionData(String name,Node startNode,Collection<Long> sharedVisitedRels,FrozenDepth sharedFrozenDepth,MutableBoolean sharedStop,MutableInteger sharedCurrentDepth){
  this.name=name;
  this.visitedNodes.put(startNode,new LevelData(startNode,currentDepth,new Path.Builder(startNode)));
  this.nextNodes.add(startNode);
  this.sharedVisitedRels=sharedVisitedRels;
  this.sharedFrozenDepth=sharedFrozenDepth;
  this.sharedStop=sharedStop;
  this.sharedCurrentDepth=sharedCurrentDepth;
  prepareNextLevel();
}","DirectionData(String name,Node startNode,Collection<Long> sharedVisitedRels,ValueHolder<Integer> sharedFrozenDepth,ValueHolder<Boolean> sharedStop,ValueHolder<Integer> sharedCurrentDepth){
  this.visitedNodes.put(startNode,new LevelData(startNode,currentDepth,new Path.Builder(startNode)));
  this.nextNodes.add(startNode);
  this.sharedFrozenDepth=sharedFrozenDepth;
  this.sharedStop=sharedStop;
  this.sharedCurrentDepth=sharedCurrentDepth;
  prepareNextLevel();
}",0.2892307692307692
154987,"private void goOneStep(DirectionData directionData,DirectionData otherSide,Map<Integer,List<Path>> hits,boolean stopAsEarlyAsPossible,DirectionData startSide){
  if (!directionData.hasNext()) {
    return;
  }
  LevelData levelData=directionData.next();
  LevelData otherSideHit=otherSide.visitedNodes.get(levelData.node);
  if (otherSideHit != null) {
    int depth=directionData.currentDepth + otherSideHit.depth;
    if (!directionData.sharedFrozenDepth.isFrozen()) {
      directionData.sharedFrozenDepth.depth=depth;
    }
    if (depth <= directionData.sharedFrozenDepth.depth) {
      directionData.haveFoundSomething=true;
      if (depth < directionData.sharedFrozenDepth.depth) {
        directionData.sharedFrozenDepth.depth=depth;
        otherSide.stop=true;
        if (stopAsEarlyAsPossible) {
          directionData.sharedStop.value=true;
        }
      }
      List<Path> paths=hits.get(depth);
      if (paths == null) {
        paths=new ArrayList<Path>();
        hits.put(depth,paths);
      }
      Path.Builder startPath=directionData == startSide ? levelData.path : otherSideHit.path;
      Path.Builder endPath=directionData == startSide ? otherSideHit.path : levelData.path;
      paths.add(startPath.build(endPath));
    }
    if (depth == 1) {
      directionData.sharedStop.value=true;
    }
  }
}","private void goOneStep(DirectionData directionData,DirectionData otherSide,Map<Integer,Collection<Hit>> hits,boolean stopAsEarlyAsPossible,DirectionData startSide){
  if (!directionData.hasNext()) {
    return;
  }
  LevelData levelData=directionData.next();
  LevelData otherSideHit=otherSide.visitedNodes.get(levelData.node);
  if (otherSideHit != null) {
    int depth=directionData.currentDepth + otherSideHit.depth;
    if (directionData.sharedFrozenDepth.value == null) {
      directionData.sharedFrozenDepth.value=depth;
    }
    if (depth <= directionData.sharedFrozenDepth.value) {
      directionData.haveFoundSomething=true;
      if (depth < directionData.sharedFrozenDepth.value) {
        directionData.sharedFrozenDepth.value=depth;
        otherSide.stop=true;
        if (stopAsEarlyAsPossible) {
          directionData.sharedStop.value=true;
        }
      }
      Collection<Hit> depthHits=hits.get(depth);
      if (depthHits == null) {
        depthHits=new HashSet<Hit>();
        hits.put(depth,depthHits);
      }
      LevelData startSideData=directionData == startSide ? levelData : otherSideHit;
      LevelData endSideData=directionData == startSide ? otherSideHit : levelData;
      depthHits.add(new Hit(startSideData,endSideData));
    }
  }
}",0.5257099002302379
154988,"@Override protected Iterator<Relationship> createNestedIterator(Node node){
  lastParentTraverserNode=node;
  return relExpander.expand(node).iterator();
}","@Override protected Iterator<Relationship> createNestedIterator(Node node){
  lastParentTraverserNode=node;
  lastParentLevelData=visitedNodes.get(node);
  return relExpander.expand(node).iterator();
}",0.8707865168539326
154989,"private void prepareNextLevel(){
  Collection<Node> nodesToIterate=new ArrayList<Node>(this.nextNodes);
  this.nextNodes.clear();
  this.nextRelationships=new NestingIterator<Relationship,Node>(nodesToIterate.iterator()){
    @Override protected Iterator<Relationship> createNestedIterator(    Node node){
      lastParentTraverserNode=node;
      return relExpander.expand(node).iterator();
    }
  }
;
  this.currentDepth++;
  this.sharedCurrentDepth.value++;
}","private void prepareNextLevel(){
  Collection<Node> nodesToIterate=new ArrayList<Node>(this.nextNodes);
  this.nextNodes.clear();
  this.nextRelationships=new NestingIterator<Relationship,Node>(nodesToIterate.iterator()){
    @Override protected Iterator<Relationship> createNestedIterator(    Node node){
      lastParentTraverserNode=node;
      lastParentLevelData=visitedNodes.get(node);
      return relExpander.expand(node).iterator();
    }
  }
;
  this.currentDepth++;
  this.sharedCurrentDepth.value++;
}",0.9487704918032788
154990,"private boolean canGoDeeper(){
  return !this.sharedFrozenDepth.isFrozen() && this.sharedCurrentDepth.value < maxDepth;
}","private boolean canGoDeeper(){
  return this.sharedFrozenDepth.value == null && this.sharedCurrentDepth.value < maxDepth;
}",0.918032786885246
154991,"private Collection<Path> internalPaths(Node start,Node end,boolean stopAsap){
  if (start.equals(end)) {
    return Arrays.asList(Path.singular(start));
  }
  Map<Integer,List<Path>> hits=new HashMap<Integer,List<Path>>();
  Collection<Long> sharedVisitedRels=new HashSet<Long>();
  FrozenDepth sharedFrozenDepth=new FrozenDepth();
  MutableBoolean sharedStop=new MutableBoolean();
  MutableInteger sharedCurrentDepth=new MutableInteger();
  final DirectionData startData=new DirectionData(""String_Node_Str"",start,sharedVisitedRels,sharedFrozenDepth,sharedStop,sharedCurrentDepth);
  final DirectionData endData=new DirectionData(""String_Node_Str"",end,sharedVisitedRels,sharedFrozenDepth,sharedStop,sharedCurrentDepth);
  while (startData.hasNext() || endData.hasNext()) {
    goOneStep(startData,endData,hits,stopAsap,startData);
    goOneStep(endData,startData,hits,stopAsap,startData);
  }
  return least(hits);
}","private Collection<Path> internalPaths(Node start,Node end,boolean stopAsap){
  if (start.equals(end)) {
    return Arrays.asList(Path.singular(start));
  }
  Map<Integer,Collection<Hit>> hits=new HashMap<Integer,Collection<Hit>>();
  Collection<Long> sharedVisitedRels=new HashSet<Long>();
  ValueHolder<Integer> sharedFrozenDepth=new ValueHolder<Integer>(null);
  ValueHolder<Boolean> sharedStop=new ValueHolder<Boolean>(false);
  ValueHolder<Integer> sharedCurrentDepth=new ValueHolder<Integer>(0);
  final DirectionData startData=new DirectionData(""String_Node_Str"",start,sharedVisitedRels,sharedFrozenDepth,sharedStop,sharedCurrentDepth);
  final DirectionData endData=new DirectionData(""String_Node_Str"",end,sharedVisitedRels,sharedFrozenDepth,sharedStop,sharedCurrentDepth);
  while (startData.hasNext() || endData.hasNext()) {
    goOneStep(startData,endData,hits,stopAsap,startData);
    goOneStep(endData,startData,hits,stopAsap,startData);
  }
  return least(hits);
}",0.7170010559662091
154992,"@Override protected LevelData fetchNextOrNull(){
  while (true) {
    Relationship nextRel=fetchNextRelOrNull();
    if (nextRel == null) {
      return null;
    }
    if (!sharedVisitedRels.add(nextRel.getId())) {
      continue;
    }
    Node result=nextRel.getOtherNode(this.lastParentTraverserNode);
    if (this.visitedNodes.containsKey(result)) {
      continue;
    }
    Path.Builder parentPath=this.visitedNodes.get(lastParentTraverserNode).path;
    LevelData levelData=new LevelData(result,currentDepth,parentPath.push(nextRel));
    this.visitedNodes.put(result,levelData);
    this.nextNodes.add(result);
    return levelData;
  }
}","@Override protected LevelData fetchNextOrNull(){
  while (true) {
    Relationship nextRel=fetchNextRelOrNull();
    if (nextRel == null) {
      return null;
    }
    Node result=nextRel.getOtherNode(this.lastParentTraverserNode);
    LevelData levelData=this.visitedNodes.get(result);
    boolean createdLevelData=false;
    if (levelData == null) {
      levelData=new LevelData(result,this.currentDepth);
      this.visitedNodes.put(result,levelData);
      createdLevelData=true;
    }
    if (this.currentDepth < levelData.depth) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else     if (this.currentDepth == levelData.depth) {
      for (      Path.Builder parentPath : this.lastParentLevelData.paths) {
        levelData.paths.add(parentPath.push(nextRel));
      }
    }
    if (!createdLevelData) {
      continue;
    }
    this.nextNodes.add(result);
    return levelData;
  }
}",0.2340836012861736
154993,"private Relationship fetchNextRelOrNull(){
  boolean stopped=this.stop || this.sharedStop.value;
  boolean hasComeTooFarEmptyHanded=this.sharedFrozenDepth.isFrozen() && sharedCurrentDepth.value > sharedFrozenDepth.depth && !this.haveFoundSomething;
  if (stopped || hasComeTooFarEmptyHanded) {
    return null;
  }
  if (!this.nextRelationships.hasNext()) {
    if (canGoDeeper()) {
      prepareNextLevel();
    }
  }
  return this.nextRelationships.hasNext() ? this.nextRelationships.next() : null;
}","private Relationship fetchNextRelOrNull(){
  boolean stopped=this.stop || this.sharedStop.value;
  boolean hasComeTooFarEmptyHanded=this.sharedFrozenDepth.value != null && this.sharedCurrentDepth.value > this.sharedFrozenDepth.value && !this.haveFoundSomething;
  if (stopped || hasComeTooFarEmptyHanded) {
    return null;
  }
  if (!this.nextRelationships.hasNext()) {
    if (canGoDeeper()) {
      prepareNextLevel();
    }
  }
  return this.nextRelationships.hasNext() ? this.nextRelationships.next() : null;
}",0.9577187807276304
154994,"LevelData(Node node,int depth,Path.Builder pathToHere){
  this.node=node;
  this.depth=depth;
  this.path=pathToHere;
}","LevelData(Node node,int depth,Path.Builder... pathsToHere){
  this.node=node;
  this.depth=depth;
  this.paths.addAll(Arrays.asList(pathsToHere));
}",0.8838951310861424
154995,"/** 
 * Creates a new relationship type store contained in <CODE>fileName</CODE> If filename is <CODE>null</CODE> or the file already exists an  <CODE>IOException</CODE> is thrown.
 * @param fileName File name of the new relationship type store
 * @throws IOException If unable to create store or name null
 */
public static void createStore(String fileName){
  createEmptyStore(fileName,VERSION);
  DynamicStringStore.createStore(fileName + ""String_Node_Str"",TYPE_STORE_BLOCK_SIZE);
  RelationshipTypeStore store=new RelationshipTypeStore(fileName);
  store.markAsReserved(store.nextId());
  store.markAsReserved(store.nextId());
  store.markAsReserved(store.nextId());
  store.close();
}","/** 
 * Creates a new relationship type store contained in <CODE>fileName</CODE> If filename is <CODE>null</CODE> or the file already exists an  <CODE>IOException</CODE> is thrown.
 * @param fileName File name of the new relationship type store
 * @throws IOException If unable to create store or name null
 */
public static void createStore(String fileName){
  createEmptyStore(fileName,VERSION);
  DynamicStringStore.createStore(fileName + ""String_Node_Str"",TYPE_STORE_BLOCK_SIZE);
  RelationshipTypeStore store=new RelationshipTypeStore(fileName);
  store.close();
}",0.904610492845787
154996,"DirectMappedLogBuffer(FileChannel fileChannel) throws IOException {
  this.fileChannel=fileChannel;
  bufferStartPosition=fileChannel.position();
  byteBuffer=ByteBuffer.allocateDirect(BUFFER_SIZE);
  getNewMappedBuffer();
}","DirectMappedLogBuffer(FileChannel fileChannel) throws IOException {
  this.fileChannel=fileChannel;
  bufferStartPosition=fileChannel.position();
  byteBuffer=ByteBuffer.allocateDirect(BUFFER_SIZE);
}",0.9433962264150944
154997,"public LogBuffer putInt(int i) throws IOException {
  if (byteBuffer == null || (BUFFER_SIZE - byteBuffer.position()) < 4) {
    getNewMappedBuffer();
  }
  byteBuffer.putInt(i);
  return this;
}","public LogBuffer putInt(int i) throws IOException {
  if (byteBuffer == null || (BUFFER_SIZE - byteBuffer.position()) < 4) {
    getNewDirectBuffer();
  }
  byteBuffer.putInt(i);
  return this;
}",0.9743589743589745
154998,"public void force() throws IOException {
  getNewMappedBuffer();
  fileChannel.force(false);
}","public void force() throws IOException {
  getNewDirectBuffer();
  fileChannel.force(false);
}",0.946808510638298
154999,"public LogBuffer putLong(long l) throws IOException {
  if (byteBuffer == null || (BUFFER_SIZE - byteBuffer.position()) < 8) {
    getNewMappedBuffer();
  }
  byteBuffer.putLong(l);
  return this;
}","public LogBuffer putLong(long l) throws IOException {
  if (byteBuffer == null || (BUFFER_SIZE - byteBuffer.position()) < 8) {
    getNewDirectBuffer();
  }
  byteBuffer.putLong(l);
  return this;
}",0.9747474747474748
155000,"public LogBuffer put(char[] chars) throws IOException {
  if (byteBuffer == null || (BUFFER_SIZE - byteBuffer.position()) < (chars.length * 2)) {
    getNewMappedBuffer();
  }
  int oldPos=byteBuffer.position();
  byteBuffer.asCharBuffer().put(chars);
  byteBuffer.position(oldPos + chars.length * 2);
  return this;
}","private void put(char[] chars,int offset) throws IOException {
  int charsToWrite=chars.length - offset;
  if (charsToWrite * 2 > BUFFER_SIZE) {
    charsToWrite=BUFFER_SIZE / 2;
  }
  if (byteBuffer == null || (BUFFER_SIZE - byteBuffer.position()) < (charsToWrite * 2)) {
    getNewDirectBuffer();
  }
  int oldPos=byteBuffer.position();
  byteBuffer.asCharBuffer().put(chars,offset,charsToWrite);
  byteBuffer.position(oldPos + (charsToWrite * 2));
  offset+=charsToWrite;
  if (offset < chars.length) {
    put(chars,offset);
  }
}",0.5352112676056338
