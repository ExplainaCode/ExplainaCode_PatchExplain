record_number,buggy_code,fixed_code,code_similarity
40001,"@Override public void run(){
  System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx);
  long t0=System.currentTimeMillis();
  EnactmentEngine enacter=new EnactEngClient(ENACTMENT_ENGINE_HOST);
  String chorId=enacter.createChoreography(chorSpec);
  Choreography chor=null;
  try {
    chor=enacter.enact(chorId);
  }
 catch (  EnactmentException e) {
    System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx+ ""String_Node_Str"");
    ok=false;
    return;
  }
catch (  ChoreographyNotFoundException e) {
    System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx+ ""String_Node_Str"");
    ok=false;
    return;
  }
  long tf=System.currentTimeMillis();
  duration=tf - t0;
  Service travelService=chor.getDeployedServiceByName(TRAVEL_AGENCY);
  travelWSDL=travelService.getUri() + ""String_Node_Str"";
  System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx+ ""String_Node_Str""+ duration+ ""String_Node_Str"");
  report.addChorEnactmentTime(duration);
  StringBuilder chorMachinesMessage=new StringBuilder(""String_Node_Str"" + idx + ""String_Node_Str"");
  for (  String mch : getMachinesFromChor(chor)) {
    chorMachinesMessage.append(mch + ""String_Node_Str"");
  }
  System.out.println(Utils.getTimeStamp() + chorMachinesMessage.toString());
}","@Override public void run(){
  System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx);
  long t0=System.currentTimeMillis();
  EnactmentEngine enacter=new EnactEngClient(ENACTMENT_ENGINE_HOST);
  String chorId=enacter.createChoreography(chorSpec);
  Choreography chor=null;
  try {
    chor=enacter.enact(chorId);
  }
 catch (  EnactmentException e) {
    System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx+ ""String_Node_Str""+ chorId+ ""String_Node_Str"");
    ok=false;
    return;
  }
catch (  ChoreographyNotFoundException e) {
    System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx+ ""String_Node_Str""+ chorId+ ""String_Node_Str"");
    ok=false;
    return;
  }
  long tf=System.currentTimeMillis();
  duration=tf - t0;
  Service travelService=chor.getDeployedServiceByName(TRAVEL_AGENCY);
  travelWSDL=travelService.getUri() + ""String_Node_Str"";
  System.out.println(Utils.getTimeStamp() + ""String_Node_Str"" + idx+ ""String_Node_Str""+ duration+ ""String_Node_Str"");
  report.addChorEnactmentTime(duration);
  StringBuilder chorMachinesMessage=new StringBuilder(""String_Node_Str"" + idx + ""String_Node_Str""+ chorId+ ""String_Node_Str"");
  for (  String mch : getMachinesFromChor(chor)) {
    chorMachinesMessage.append(mch + ""String_Node_Str"");
  }
  System.out.println(Utils.getTimeStamp() + chorMachinesMessage.toString());
}",0.9694224235560588
40002,"public static ChorRegistry getInstance(){
  if (instance == null)   instance=new ChorRegistry();
  return instance;
}","public static ChorRegistry getInstance(){
  return instance;
}",0.6927374301675978
40003,"@Override public String createChoreography(ChorSpec chor){
  String chorId=reg.create(chor);
  return chorId;
}","@Override public String createChoreography(ChorSpec chor){
  String chorId=reg.create(chor);
  logger.info(""String_Node_Str"" + chorId + ""String_Node_Str"");
  return chorId;
}",0.7789473684210526
40004,"@Override public Choreography enact(String chorId) throws EnactmentException {
  Choreography chor=reg.get(chorId);
  if (chor == null) {
    return null;
  }
  logger.info(""String_Node_Str"" + chorId);
  Deployer deployer=new Deployer();
  Map<String,Service> deployedMap=deployer.deployServices(chor.getChorSpec());
  ContextCaster caster=new ContextCaster();
  caster.cast(chor.getChorSpec(),deployedMap);
  logger.info(""String_Node_Str"" + chorId);
  List<Service> deployedList=new ArrayList<Service>(deployedMap.values());
  reg.addDeployedServices(chorId,deployedList);
  return chor;
}","@Override public Choreography enact(String chorId) throws EnactmentException, ChoreographyNotFoundException {
  Choreography chor=reg.get(chorId);
  if (chor == null) {
    throw new ChoreographyNotFoundException(chorId);
  }
  logger.info(""String_Node_Str"" + chorId);
  Deployer deployer=new Deployer();
  Map<String,Service> deployedMap=deployer.deployServices(chor.getChorSpec());
  ContextCaster caster=new ContextCaster();
  caster.cast(chor.getChorSpec(),deployedMap);
  logger.info(""String_Node_Str"" + chorId);
  List<Service> deployedList=new ArrayList<Service>(deployedMap.values());
  reg.addDeployedServices(chorId,deployedList);
  return chor;
}",0.9302325581395348
40005,"@Override public Choreography enact(String chorId) throws EnactmentException, ChoreographyNotFoundException {
  WebClient client=setupClient();
  client.path(""String_Node_Str"");
  client.path(chorId);
  client.path(""String_Node_Str"");
  Choreography chor;
  try {
    chor=client.post(null,Choreography.class);
  }
 catch (  WebApplicationException e) {
    int code=e.getResponse().getStatus();
    if (code == 400 || code == 404) {
      throw new ChoreographyNotFoundException(chorId);
    }
 else {
      throw new EnactmentException(""String_Node_Str"" + chorId + ""String_Node_Str"");
    }
  }
  return chor;
}","@Override public Choreography enact(String chorId) throws EnactmentException, ChoreographyNotFoundException {
  WebClient client=setupClient();
  client.path(""String_Node_Str"");
  client.path(chorId);
  client.path(""String_Node_Str"");
  Choreography chor;
  try {
    chor=client.post(null,Choreography.class);
  }
 catch (  WebApplicationException e) {
    int code=e.getResponse().getStatus();
    if (code == 400 || code == 404) {
      throw new ChoreographyNotFoundException(chorId);
    }
 else {
      throw new EnactmentException(""String_Node_Str"" + chorId + ""String_Node_Str""+ code+ ""String_Node_Str"");
    }
  }
  return chor;
}",0.980015987210232
40006,"private void waitForSSHAccess() throws NodeNotAccessibleException {
  logger.debug(""String_Node_Str"");
  SshUtil ssh=new SshUtil(this.node.getIp(),this.node.getUser(),this.node.getPrivateKeyFile());
  final int DELAY=5000;
  Timer timer=new Timer(MAX_TIME_TO_CONNECT,DELAY);
  Thread t=new Thread(timer);
  t.start();
  while (!ssh.isAccessible()) {
    if (timer.timeouted()) {
      throw new NodeNotAccessibleException(this.node.getId());
    }
    logger.debug(""String_Node_Str"" + this.node.getIp() + ""String_Node_Str"");
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    ssh.disconnect();
  }
  logger.debug(""String_Node_Str"" + this.node);
}","private void waitForSSHAccess() throws NodeNotAccessibleException {
  logger.debug(""String_Node_Str"");
  SshUtil ssh=new SshUtil(this.node.getIp(),this.node.getUser(),this.node.getPrivateKeyFile());
  final int DELAY=5000;
  Timer timer=new Timer(MAX_TIME_TO_CONNECT,DELAY);
  Thread t=new Thread(timer);
  t.start();
  while (!ssh.isAccessible()) {
    if (timer.timeouted()) {
      throw new NodeNotAccessibleException(this.node.getId());
    }
    logger.debug(""String_Node_Str"" + this.node.getIp() + ""String_Node_Str"");
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
  }
  ssh.disconnect();
  logger.debug(""String_Node_Str"" + this.node);
}",0.9692982456140352
40007,"/** 
 * Try to run chef client 5 times This strategy is carried out since sometimes  we try to ssh the VM when it is not ready yet.
 * @param ssh
 * @throws JSchException 
 */
private void runChefClient(SshUtil ssh) throws JSchException {
  String logFile=Configuration.get(""String_Node_Str"");
  if (logFile == null || logFile.isEmpty()) {
    logFile=""String_Node_Str"";
  }
  final String CHEF_CLIENT_COMMAND=""String_Node_Str"" + logFile;
  final int MAX_TRIALS=5;
  final int SLEEPING_TIME=5000;
  int trials=0;
  boolean ok=false;
  while (!ok) {
    try {
      trials++;
      ssh.runCommand(CHEF_CLIENT_COMMAND);
      ok=true;
    }
 catch (    JSchException e) {
      if (trials >= MAX_TRIALS) {
        throw e;
      }
      try {
        Thread.sleep(SLEEPING_TIME);
      }
 catch (      InterruptedException e1) {
      }
    }
  }
}","/** 
 * Try to run chef client 5 times This strategy is carried out since sometimes  we try to ssh the VM when it is not ready yet.
 * @param ssh
 * @throws JSchException 
 */
private void runChefClient(SshUtil ssh) throws JSchException {
  String logFile=Configuration.get(""String_Node_Str"");
  if (logFile == null || logFile.isEmpty()) {
    logFile=""String_Node_Str"";
  }
  final String CHEF_CLIENT_COMMAND=""String_Node_Str"" + logFile + ""String_Node_Str""+ logFile+ ""String_Node_Str"";
  final int MAX_TRIALS=5;
  final int SLEEPING_TIME=5000;
  int trials=0;
  boolean ok=false;
  while (!ok) {
    try {
      trials++;
      ssh.runCommand(CHEF_CLIENT_COMMAND);
      ok=true;
    }
 catch (    JSchException e) {
      if (trials >= MAX_TRIALS) {
        throw e;
      }
      try {
        Thread.sleep(SLEEPING_TIME);
      }
 catch (      InterruptedException e1) {
      }
    }
  }
}",0.9724137931034482
40008,"/** 
 * Runs chef-client in a given node
 * @param node
 * @throws JSchException if could not connect into the node
 * @throws NodeNotUpgradedException if chef-client ends in error
 */
public void upgradeNodeConfiguration(Node node) throws JSchException, NodeNotUpgradedException {
  List<String> newRecipes=this.findNewRecipes(node);
  needUpdate.put(node,true);
  if (updating.containsKey(node) && updating.get(node)) {
    return;
  }
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  while (needUpdate.get(node)) {
    needUpdate.put(node,false);
    updating.put(node,true);
    logger.debug(""String_Node_Str"" + node);
    this.runChefClient(ssh);
    updating.put(node,false);
  }
  if (!this.checkNewRecipes(node,newRecipes)) {
    throw new NodeNotUpgradedException(node.getId());
  }
}","/** 
 * Runs chef-client in a given node
 * @param node
 * @throws JSchException if could not connect into the node
 * @throws NodeNotUpgradedException if chef-client ends in error
 */
public void upgradeNodeConfiguration(Node node) throws JSchException, NodeNotUpgradedException {
  needUpdate.put(node,true);
  if (updating.containsKey(node) && updating.get(node)) {
    return;
  }
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  while (needUpdate.get(node)) {
    needUpdate.put(node,false);
    updating.put(node,true);
    logger.debug(""String_Node_Str"" + node);
    this.runChefClient(ssh);
    updating.put(node,false);
  }
}",0.8936454849498328
40009,"private void updateNodeConfiguration(final Node node) throws Exception {
  needUpdate.put(node,true);
  if (updating.containsKey(node) && updating.get(node)) {
    return;
  }
  while (needUpdate.get(node)) {
    needUpdate.put(node,false);
    updating.put(node,true);
    new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile()).runCommand(""String_Node_Str"");
    updating.put(node,false);
  }
}","private void updateNodeConfiguration(final Node node) throws Exception {
  needUpdate.put(node,true);
  if (updating.containsKey(node) && updating.get(node)) {
    return;
  }
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  while (needUpdate.get(node)) {
    needUpdate.put(node,false);
    updating.put(node,true);
    ssh.runCommand(""String_Node_Str"");
    updating.put(node,false);
  }
}",0.7460890493381468
40010,"public void initializeNode(Node node){
  System.out.println(""String_Node_Str"");
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  while (!ssh.isAccessible()) {
    System.out.println(""String_Node_Str"" + node.getHostname() + ""String_Node_Str""+ node.getUser()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
  }
  System.out.println(""String_Node_Str"");
  String command;
  try {
    System.out.println(""String_Node_Str"" + node.getHostname());
    command=ChefScripts.getChefBootstrapScript(node.getPrivateKeyFile(),node.getIp(),node.getUser());
    System.out.println(command);
    CommandLine.runLocalCommand(command,CHEF_REPO);
    System.out.println(""String_Node_Str"");
    this.retrieveChefName(node);
    this.installInitialRecipe(node);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void initializeNode(Node node) throws JSchException {
  System.out.println(""String_Node_Str"");
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  while (!ssh.isAccessible()) {
    System.out.println(""String_Node_Str"" + node.getUser() + ""String_Node_Str""+ node.getIp()+ ""String_Node_Str""+ node.getPrivateKeyFile()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
  }
  System.out.println(""String_Node_Str"");
  String command;
  try {
    System.out.println(""String_Node_Str"" + node.getHostname());
    command=ChefScripts.getChefBootstrapScript(node.getPrivateKeyFile(),node.getIp(),node.getUser());
    System.out.println(command);
    CommandLine.runLocalCommand(command,CHEF_REPO);
    System.out.println(""String_Node_Str"");
    this.retrieveChefName(node);
    this.installInitialRecipe(node);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.955981356809943
40011,"/** 
 * @param node
 * @param cookbook
 * @param recipe
 * @return false if recipe not applied
 * @throws IOException
 */
public boolean installRecipe(Node node,String cookbook,String recipe){
  try {
    if (!isInitialized(node)) {
      System.out.println(""String_Node_Str"");
      this.initializeNode(node);
    }
  }
 catch (  NodeNotAccessible e) {
    return false;
  }
catch (  Exception e) {
    return false;
  }
  if (node.getChefName() == null)   this.retrieveChefName(node);
  String command=ChefScripts.getChefAddCookbook(node.getChefName(),cookbook,recipe);
  System.out.println(""String_Node_Str"" + command + ""String_Node_Str"");
  CommandLine.runLocalCommand(command);
  try {
    this.updateNodeConfiguration(node);
  }
 catch (  Exception e) {
    return false;
  }
  return true;
}","/** 
 * @param node
 * @param cookbook
 * @param recipe
 * @return false if recipe not applied
 * @throws Exception
 * @throws IOException
 */
public void installRecipe(Node node,String cookbook,String recipe) throws Exception {
  if (!isInitialized(node)) {
    System.out.println(""String_Node_Str"");
    this.initializeNode(node);
  }
  if (node.getChefName() == null)   this.retrieveChefName(node);
  System.out.println(""String_Node_Str"" + node.getChefName());
  String command=ChefScripts.getChefAddCookbook(node.getChefName(),cookbook,recipe);
  System.out.println(""String_Node_Str"" + command + ""String_Node_Str"");
  CommandLine.runLocalCommand(command);
  this.updateNodeConfiguration(node);
}",0.5691382765531062
40012,"public boolean isInitialized(Node node) throws NodeNotAccessible, Exception {
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  while (!ssh.isAccessible()) {
    System.out.println(""String_Node_Str"" + node.getIp() + ""String_Node_Str""+ node.getUser()+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
  }
  String createdFile=""String_Node_Str"";
  String returnText=null;
  returnText=ssh.runCommand(""String_Node_Str"" + createdFile);
  System.out.println(""String_Node_Str"" + returnText.trim() + ""String_Node_Str"");
  return returnText.trim().equals(createdFile);
}","public boolean isInitialized(Node node) throws NodeNotAccessible, Exception {
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  String createdFile=""String_Node_Str"";
  String returnText=null;
  returnText=ssh.runCommand(""String_Node_Str"" + createdFile,true);
  System.out.println(""String_Node_Str"" + returnText.trim() + ""String_Node_Str"");
  return returnText.trim().equals(createdFile);
}",0.7466427931960609
40013,"private void retrieveChefName(Node node){
  while (node.getChefName() == null) {
    try {
      SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
      String command=ChefScripts.getChefName();
      String chefClientName=ssh.runCommand(command,true);
      if (chefClientName == null || chefClientName.isEmpty())       chefClientName=node.getHostname();
      chefClientName=chefClientName.replace(""String_Node_Str"",""String_Node_Str"").trim();
      node.setChefName(chefClientName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","private void retrieveChefName(Node node) throws Exception {
  SshUtil ssh=new SshUtil(node.getIp(),node.getUser(),node.getPrivateKeyFile());
  String command=ChefScripts.getChefName();
  String chefClientName=ssh.runCommand(command,true);
  if (chefClientName == null || chefClientName.isEmpty())   chefClientName=node.getHostname();
  chefClientName=chefClientName.replace(""String_Node_Str"",""String_Node_Str"").trim();
  node.setChefName(chefClientName);
}",0.6954851104707013
40014,"private void upgradeNodes(){
  NodePoolManager npm=new NodePoolManagerClient();
  npm.upgradeNodes();
}","private void upgradeNodes(){
  System.out.println(""String_Node_Str"");
  NodePoolManager npm=new NodePoolManagerClient();
  npm.upgradeNodes();
}",0.8340080971659919
40015,"@GET public Response getIntegradeApplication(@Context UriInfo uriInfo){
  Response response=null;
  try {
    log.debug(""String_Node_Str"");
    Property dfs=new Property();
    dfs.setName(""String_Node_Str"");
    if (System.getProperty(""String_Node_Str"") != null && !System.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
      log.debug(""String_Node_Str"");
      dfs.setValue(System.getProperty(""String_Node_Str""));
    }
 else {
      log.debug(""String_Node_Str"");
      File hdConfPath=new File(System.getProperty(""String_Node_Str"",System.getProperty(""String_Node_Str"")) + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"");
      log.debug(""String_Node_Str"" + hdConfPath.getAbsolutePath());
      OurURLClassLoader.addFile(hdConfPath);
      log.debug(""String_Node_Str"");
      Configuration.addDefaultResource(hdConfPath.getAbsolutePath() + File.separator + ""String_Node_Str"");
      Configuration.addDefaultResource(hdConfPath.getAbsolutePath() + File.separator + ""String_Node_Str"");
      Configuration.addDefaultResource(hdConfPath.getAbsolutePath() + File.separator + ""String_Node_Str"");
      log.debug(""String_Node_Str"");
      Configuration conf=new Configuration(true);
      ByteArrayOutputStream baout=new ByteArrayOutputStream();
      conf.writeXml(baout);
      baout.close();
      ByteArrayInputStream bais=new ByteArrayInputStream(baout.toByteArray());
      log.debug(""String_Node_Str"");
      XMLSource xml=new XMLSource(bais);
      xml.setBuffering(true);
      dfs=xml.getNode(""String_Node_Str"",Property.class);
    }
    log.debug(""String_Node_Str"" + dfs);
    response=Response.ok(dfs).build();
  }
 catch (  Exception e) {
    e.printStackTrace();
    response=Response.status(Status.INTERNAL_SERVER_ERROR).build();
  }
  return response;
}","@GET public Response getIntegradeApplication(@Context UriInfo uriInfo){
  Response response=null;
  try {
    log.debug(""String_Node_Str"");
    Property dfs=new Property();
    dfs.setName(""String_Node_Str"");
    if (System.getProperty(""String_Node_Str"") != null && !System.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
      log.debug(""String_Node_Str"");
      dfs.setValue(System.getProperty(""String_Node_Str""));
    }
 else {
      log.debug(""String_Node_Str"");
      File hdConfPath=new File(System.getProperty(""String_Node_Str"",System.getProperty(""String_Node_Str"")) + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"");
      log.debug(""String_Node_Str"" + hdConfPath.getAbsolutePath());
      OurURLClassLoader.addFile(hdConfPath);
      log.debug(""String_Node_Str"");
      Configuration.addDefaultResource(hdConfPath.getAbsolutePath() + File.separator + ""String_Node_Str"");
      Configuration.addDefaultResource(hdConfPath.getAbsolutePath() + File.separator + ""String_Node_Str"");
      Configuration.addDefaultResource(hdConfPath.getAbsolutePath() + File.separator + ""String_Node_Str"");
      log.debug(""String_Node_Str"");
      Configuration conf=new Configuration(true);
      ByteArrayOutputStream baout=new ByteArrayOutputStream();
      conf.writeXml(baout);
      baout.close();
      log.debug(""String_Node_Str"" + baout.toString());
      ByteArrayInputStream bais=new ByteArrayInputStream(baout.toByteArray());
      log.debug(""String_Node_Str"");
      XMLSource xml=new XMLSource(bais);
      xml.setBuffering(true);
      dfs=xml.getNode(""String_Node_Str"",Property.class);
    }
    log.debug(""String_Node_Str"" + dfs);
    response=Response.ok(dfs).build();
  }
 catch (  Exception e) {
    e.printStackTrace();
    response=Response.status(Status.INTERNAL_SERVER_ERROR).build();
  }
  return response;
}",0.9849603500136724
40016,"@Test public void testWordCount() throws Exception {
  HttpClient httpclient=new DefaultHttpClient();
  FileSystem fs=null;
  try {
    Configuration conf=new Configuration(true);
    ByteArrayInputStream bais=new ByteArrayInputStream(retrieveConfig(httpclient).getBytes());
    XMLSource xml=new XMLSource(bais);
    xml.setBuffering(true);
    Property dfs=xml.getNode(""String_Node_Str"",Property.class);
    String newValue=dfs.getValue();
    conf.set(""String_Node_Str"",newValue);
    fs=FileSystem.get(conf);
    if (!fs.exists(new Path(""String_Node_Str"")))     fs.mkdirs(new Path(""String_Node_Str""));
    FSDataOutputStream output=fs.create(new Path(""String_Node_Str""),true);
    FileInputStream input=new FileInputStream(new File(PROJECT_PATH + ""String_Node_Str""));
    byte buffer[]=new byte[4096];
    int byte_read=0;
    while ((byte_read=input.read(buffer)) != -1) {
      output.write(buffer,0,byte_read);
    }
    conf=new Configuration();
    Job job=Job.getInstance(conf,""String_Node_Str"");
    job.setOutputKeyClass(Text.class);
    job.setOutputValueClass(IntWritable.class);
    job.setMapperClass(Map.class);
    job.setReducerClass(Reduce.class);
    job.setInputFormatClass(TextInputFormat.class);
    job.setOutputFormatClass(TextOutputFormat.class);
    FileInputFormat.addInputPath(job,new Path(""String_Node_Str""));
    FileOutputFormat.setOutputPath(job,new Path(""String_Node_Str""));
    job.waitForCompletion(true);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
 finally {
    fs.close();
    FileSystem.closeAll();
    httpclient.getConnectionManager().shutdown();
  }
}","@Test public void testWordCount() throws Exception {
  HttpClient httpclient=new DefaultHttpClient();
  FileSystem fs=null;
  try {
    Configuration conf=new Configuration(true);
    ByteArrayInputStream bais=new ByteArrayInputStream(retrieveConfig(httpclient).getBytes());
    XMLSource xml=new XMLSource(bais);
    xml.setBuffering(true);
    Property dfs=xml.getNode(""String_Node_Str"",Property.class);
    String newValue=dfs.getValue();
    System.out.println(""String_Node_Str"" + newValue);
    conf.set(""String_Node_Str"",newValue);
    conf.set(""String_Node_Str"",MAPRED_URL);
    fs=FileSystem.get(conf);
    try {
      fs.mkdirs(new Path(""String_Node_Str""));
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    FSDataOutputStream output=fs.create(new Path(""String_Node_Str""));
    FileInputStream input=new FileInputStream(new File(PROJECT_PATH + ""String_Node_Str""));
    try {
      int read=0;
      while ((read=input.read()) != -1) {
        output.write(read);
      }
    }
  finally {
      output.close();
      input.close();
    }
    WordCount.setConf(conf);
    WordCount.main(null);
    assertTrue(fs.exists(new Path(""String_Node_Str"")));
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
 finally {
    fs.close();
    FileSystem.closeAll();
    httpclient.getConnectionManager().shutdown();
  }
}",0.6534128561961564
40017,"public String deploy(Service service) throws MalformedURLException {
  RecipeFactory factory=new RecipeFactory();
  Recipe serviceDeployRecipe=factory.createRecipe(service);
  RecipeDeployer deployer=new RecipeDeployer(new NodePoolManagerHandler());
  deployer.uploadRecipe(serviceDeployRecipe);
  String deployedHost=deployer.deployRecipe(serviceDeployRecipe,service);
  String serviceURL;
  if (deployedHost.contains(""String_Node_Str""))   serviceURL=service.getUri() + ""String_Node_Str"" + service.getPort()+ ""String_Node_Str""+ service.getId()+ ""String_Node_Str"";
 else   serviceURL=""String_Node_Str"" + service.getUri() + ""String_Node_Str""+ service.getPort()+ ""String_Node_Str""+ service.getId()+ ""String_Node_Str"";
  return serviceURL;
}","public String deploy(Service service) throws MalformedURLException {
  RecipeFactory factory=new RecipeFactory();
  Recipe serviceDeployRecipe=factory.createRecipe(service);
  RecipeDeployer deployer=new RecipeDeployer(new NodePoolManagerHandler());
  deployer.uploadRecipe(serviceDeployRecipe);
  String deployedHost=deployer.deployRecipe(serviceDeployRecipe,service);
  String serviceURL;
  if (deployedHost.contains(""String_Node_Str""))   serviceURL=service.getUri() + ""String_Node_Str"" + service.getPort()+ ""String_Node_Str""+ ""String_Node_Str""+ service.getId()+ ""String_Node_Str"";
 else   serviceURL=""String_Node_Str"" + service.getUri() + ""String_Node_Str""+ service.getPort()+ ""String_Node_Str""+ service.getId()+ ""String_Node_Str"";
  return serviceURL;
}",0.9872909698996656
40018,"public String copyTemplate(Service service) throws IOException {
  URL scriptFile=ClassLoader.getSystemResource(""String_Node_Str"");
  URL destURL=ClassLoader.getSystemResource(""String_Node_Str"");
  File srcFolder=new File(scriptFile.getFile());
  File destFolder=new File(destURL.getFile().concat(""String_Node_Str"" + service.getId()));
  FileUtils.copyDirectory(srcFolder,destFolder);
  return destFolder.getAbsolutePath();
}","public String copyTemplate(Service service) throws IOException {
  URL scriptFile=ClassLoader.getSystemResource(""String_Node_Str"");
  URL destURL=RecipeDeployer.destURL;
  File srcFolder=new File(scriptFile.getFile());
  File destFolder=new File(destURL.getFile().concat(""String_Node_Str"" + service.getId()));
  FileUtils.copyDirectory(srcFolder,destFolder);
  return destFolder.getAbsolutePath();
}",0.6674757281553398
40019,"public void testInitDesktopBackgrounds() throws Exception {
  List<DesktopBackground> bgs=desktopBackgroundService.findDesktopBackgrounds(userSiteKey);
  assertEquals(8,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.USER_TYPE,""String_Node_Str""));
  assertEquals(1,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.GROUP_TYPE,""String_Node_Str""));
  assertEquals(0,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.GROUP_TYPE,""String_Node_Str""));
  assertEquals(1,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.GROUP_TYPE,""String_Node_Str""));
  assertEquals(8,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.PORTAL_TYPE,""String_Node_Str""));
  assertEquals(0,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.PORTAL_TYPE,""String_Node_Str""));
  assertEquals(8,bgs.size());
}","public void testInitDesktopBackgrounds() throws Exception {
  List<DesktopBackground> bgs=desktopBackgroundService.findDesktopBackgrounds(userSiteKey);
  assertEquals(8,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.USER_TYPE,""String_Node_Str""));
  assertEquals(1,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.GROUP_TYPE,""String_Node_Str""));
  assertEquals(1,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.GROUP_TYPE,""String_Node_Str""));
  assertEquals(8,bgs.size());
  createEmptyDir(""String_Node_Str"");
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.GROUP_TYPE,""String_Node_Str""));
  assertEquals(0,bgs.size());
  createEmptyDir(""String_Node_Str"");
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.PORTAL_TYPE,""String_Node_Str""));
  assertEquals(0,bgs.size());
  bgs=desktopBackgroundService.findDesktopBackgrounds(new PortalKey(PortalConfig.PORTAL_TYPE,""String_Node_Str""));
  assertEquals(8,bgs.size());
}",0.9629286376274327
40020,"public String createNewPageNode(String nodeLabel){
  try {
    if (nodeLabel == null || nodeLabel.length() == 0) {
      nodeLabel=""String_Node_Str"" + getCurrentNumberOfTabs();
    }
    Page page=configService.createPageTemplate(UIWebOSTabPaneDashboard.PAGE_TEMPLATE,pageNavigation.getOwnerType(),pageNavigation.getOwnerId());
    page.setTitle(nodeLabel);
    List<PageNode> selectedPath=uiPortal.getSelectedPath();
    PageNode parentNode=null;
    if (selectedPath != null && selectedPath.size() > 1) {
      parentNode=selectedPath.get(selectedPath.size() - 2);
    }
    PageNode pageNode=new PageNode();
    pageNode.setLabel(nodeLabel);
    String uniqueNodeName=nodeLabel.toLowerCase().replace(' ','_');
    if (nameExisted(uniqueNodeName)) {
      uniqueNodeName=uniqueNodeName + ""String_Node_Str"" + System.currentTimeMillis();
    }
    String fullName=(parentNode != null) ? parentNode.getUri() + ""String_Node_Str"" + uniqueNodeName : uniqueNodeName;
    page.setName(uniqueNodeName);
    pageNode.setName(uniqueNodeName);
    pageNode.setUri(fullName);
    pageNode.setPageReference(page.getPageId());
    if (parentNode == null) {
      pageNavigation.addNode(pageNode);
    }
 else     if (parentNode.getChildren() != null) {
      parentNode.getChildren().add(pageNode);
    }
    dataService.create(page);
    dataService.save(pageNavigation);
    return fullName;
  }
 catch (  Exception ex) {
    logger.info(""String_Node_Str"",ex);
    return null;
  }
}","public String createNewPageNode(String nodeLabel){
  try {
    if (nodeLabel == null || nodeLabel.length() == 0) {
      nodeLabel=""String_Node_Str"" + getCurrentNumberOfTabs();
    }
    Page page=configService.createPageTemplate(UIWebOSTabPaneDashboard.PAGE_TEMPLATE,pageNavigation.getOwnerType(),pageNavigation.getOwnerId());
    page.setTitle(nodeLabel);
    List<PageNode> selectedPath=uiPortal.getSelectedPath();
    PageNode parentNode=null;
    if (selectedPath != null && selectedPath.size() > 1) {
      parentNode=selectedPath.get(selectedPath.size() - 2);
    }
    PageNode pageNode=new PageNode();
    pageNode.setLabel(nodeLabel);
    String uniqueNodeName=nodeLabel.toLowerCase().replace(' ','_');
    if (nameExisted(uniqueNodeName)) {
      uniqueNodeName=uniqueNodeName + ""String_Node_Str"" + System.currentTimeMillis();
    }
    String fullName=(parentNode != null) ? parentNode.getUri() + ""String_Node_Str"" + uniqueNodeName : uniqueNodeName;
    page.setName(uniqueNodeName + ""String_Node_Str"" + page.hashCode());
    pageNode.setName(uniqueNodeName);
    pageNode.setUri(fullName);
    pageNode.setPageReference(page.getPageId());
    if (parentNode == null) {
      pageNavigation.addNode(pageNode);
    }
 else     if (parentNode.getChildren() != null) {
      parentNode.getChildren().add(pageNode);
    }
    dataService.create(page);
    dataService.save(pageNavigation);
    return fullName;
  }
 catch (  Exception ex) {
    logger.info(""String_Node_Str"",ex);
    return null;
  }
}",0.9872568745808182
40021,"@Override public String toString(){
  StringBuffer param=new StringBuffer();
  param.append(KEY_PARAM).append(""String_Node_Str"").append(this.getKey()).append(SEPARATOR);
  param.append(FILTER_TYPE_PARAM).append(""String_Node_Str"").append(Boolean.toString(this.isAttributeFilter()));
  this.appendParamValue(param,this.getValue(),VALUE_PARAM);
  this.appendParamValue(param,this.getOrder(),LIKE_OPTION_PARAM);
  if (this.getValue() instanceof String) {
    this.appendParamValue(param,this.isLikeOption(),LIKE_OPTION_PARAM);
  }
  if (null != this.getAllowedValues() && !this.getAllowedValues().isEmpty()) {
    this.appendParamValue(param,this.getAllowedValues(),ALLOWED_VALUES_PARAM);
  }
  this.appendParamValue(param,this.getLangCode(),LANG_PARAM);
  this.appendParamValue(param,this.getStart(),START_PARAM);
  this.appendParamValue(param,this.getEnd(),END_PARAM);
  this.appendParamValue(param,this.getOrder(),ORDER_PARAM);
  return param.toString();
}","@Override public String toString(){
  StringBuffer param=new StringBuffer();
  param.append(KEY_PARAM).append(""String_Node_Str"").append(this.getKey()).append(SEPARATOR);
  param.append(FILTER_TYPE_PARAM).append(""String_Node_Str"").append(Boolean.toString(this.isAttributeFilter()));
  this.appendParamValue(param,this.getValue(),VALUE_PARAM);
  this.appendParamValue(param,this.getOrder(),ORDER_PARAM);
  if (this.getValue() instanceof String) {
    this.appendParamValue(param,this.isLikeOption(),LIKE_OPTION_PARAM);
  }
  if (null != this.getAllowedValues() && !this.getAllowedValues().isEmpty()) {
    this.appendParamValue(param,this.getAllowedValues(),ALLOWED_VALUES_PARAM);
  }
  this.appendParamValue(param,this.getLangCode(),LANG_PARAM);
  this.appendParamValue(param,this.getStart(),START_PARAM);
  this.appendParamValue(param,this.getEnd(),END_PARAM);
  this.appendParamValue(param,this.getOrder(),ORDER_PARAM);
  return param.toString();
}",0.8823529411764706
40022,"public String[] getUserConfig(){
  String[] config=null;
  try {
    config=(String[])this.getRequest().getSession().getAttribute(SESSION_PARAM_MY_SHORTCUTS);
    if (null == config) {
      config=this.getShortcutManager().getUserConfig(this.getCurrentUser());
      this.setUserConfig(config);
    }
  }
 catch (  Throwable t) {
    ApsSystemUtils.logThrowable(t,this,""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + this.getCurrentUser(),t);
  }
  return config;
}","public String[] getUserConfig(){
  return this.getUserConfigBean().getConfig();
}",0.256140350877193
40023,"protected void setUserConfig(String[] userConfig){
  this.getRequest().getSession().setAttribute(SESSION_PARAM_MY_SHORTCUTS,userConfig);
}","protected void setUserConfig(String[] config){
  UserConfigBean userConfig=new UserConfigBean(this.getCurrentUser().getUsername(),config);
  this.setUserConfigBean(userConfig);
}",0.4936708860759494
40024,"/** 
 * Save a shortcut config of the given user. THe saved confif shold be not equals than the given, the invalid position  (whith invalid shortcut code, or with shortcut not allowed to the user) will be emptied.
 * @param user The user owner of the config to save.
 * @param config The config to save.
 * @return The saved config.
 * @throws ApsSystemException In case of error.
 */
public String[] saveUserConfig(UserDetails user,String[] config) throws ApsSystemException ;","/** 
 * Save a shortcut config of the given user. The saved config shold be not equals than the given, the invalid position  (with invalid shortcut code, or with shortcut not allowed to the user) will be emptied.
 * @param user The user owner of the config to save.
 * @param config The config to save.
 * @return The saved config.
 * @throws ApsSystemException In case of error.
 */
public String[] saveUserConfig(UserDetails user,String[] config) throws ApsSystemException ;",0.9674711437565582
40025,"abstract public boolean updateLandAddons(int id,HashMap<String,Boolean> newAddons);","abstract public boolean updateLandAddons(int id,String addons);",0.8493150684931506
40026,"abstract public boolean updateLandPerms(int id,HashMap<String,Boolean> newPerms);","abstract public boolean updateLandPerms(int id,String perms);",0.8450704225352113
40027,"public boolean updateLandAddons(int id,HashMap<String,Boolean> newAddons){
  String addons=Land.writeAddonTags(newAddons);
  int ret=0;
  Connection conn=null;
  PreparedStatement ps=null;
  try {
    conn=getConnection();
    ps=conn.prepareStatement(""String_Node_Str"" + Config.sqlTableName + ""String_Node_Str"");
    ps.setString(1,addons);
    ps.setInt(2,id);
    if (Config.debugMode)     iCoLand.info(ps.toString());
    ret=ps.executeUpdate();
    ps.close();
    conn.close();
  }
 catch (  SQLException ex) {
    ex.printStackTrace();
  }
  return (ret > 0);
}","public boolean updateLandAddons(int id,String addons){
  int ret=0;
  Connection conn=null;
  PreparedStatement ps=null;
  try {
    conn=getConnection();
    ps=conn.prepareStatement(""String_Node_Str"" + Config.sqlTableName + ""String_Node_Str"");
    ps.setString(1,addons);
    ps.setInt(2,id);
    if (Config.debugMode)     iCoLand.info(ps.toString());
    ret=ps.executeUpdate();
    ps.close();
    conn.close();
  }
 catch (  SQLException ex) {
    ex.printStackTrace();
  }
  return (ret > 0);
}",0.9213483146067416
40028,"public boolean updateLandPerms(int id,HashMap<String,Boolean> newPerms){
  String perms=Land.writePermTags(newPerms);
  int ret=0;
  Connection conn=null;
  PreparedStatement ps=null;
  try {
    conn=getConnection();
    ps=conn.prepareStatement(""String_Node_Str"" + Config.sqlTableName + ""String_Node_Str"");
    ps.setString(1,perms);
    ps.setInt(2,id);
    if (Config.debugMode)     iCoLand.info(ps.toString());
    ret=ps.executeUpdate();
    ps.close();
    conn.close();
  }
 catch (  SQLException ex) {
    ex.printStackTrace();
  }
  return (ret > 0);
}","public boolean updateLandPerms(int id,String perms){
  int ret=0;
  Connection conn=null;
  PreparedStatement ps=null;
  try {
    conn=getConnection();
    ps=conn.prepareStatement(""String_Node_Str"" + Config.sqlTableName + ""String_Node_Str"");
    ps.setString(1,perms);
    ps.setInt(2,id);
    if (Config.debugMode)     iCoLand.info(ps.toString());
    ret=ps.executeUpdate();
    ps.close();
    conn.close();
  }
 catch (  SQLException ex) {
    ex.printStackTrace();
  }
  return (ret > 0);
}",0.923512747875354
40029,"public static void loadConfig(File configFile){
  Configuration config=new Configuration(configFile);
  config.load();
  ConfigurationNode debug=config.getNode(""String_Node_Str"");
  if (debug != null) {
    debugMode=debug.getBoolean(""String_Node_Str"",false);
    debugModeSQL=debug.getBoolean(""String_Node_Str"",false);
  }
  ConfigurationNode taxes=config.getNode(""String_Node_Str"");
  if (taxes != null) {
    sellTax=taxes.getDouble(""String_Node_Str"",80.0) / 100.0;
    if (sellTax < 0)     sellTax=0;
    if (sellTax > 1)     sellTax=1;
    taxRate=taxes.getDouble(""String_Node_Str"",5.0) / 100.0;
    if (taxRate < 0)     taxRate=0;
    if (taxRate > 1)     taxRate=1;
    bankName=taxes.getString(""String_Node_Str"",""String_Node_Str"");
  }
  ConfigurationNode timers=config.getNode(""String_Node_Str"");
  if (timers != null) {
    healTime=timers.getInt(""String_Node_Str"",30);
    mobRemovalTime=timers.getInt(""String_Node_Str"",2);
    taxTimeMinutes=timers.getInt(""String_Node_Str"",0);
    announceCheckInterval=timers.getInt(""String_Node_Str"",1000);
  }
  ConfigurationNode unclaimed=config.getNode(""String_Node_Str"");
  if (unclaimed != null) {
    unclaimedLandCanBuild=unclaimed.getBoolean(""String_Node_Str"",true);
    unclaimedLandCanBoom=unclaimed.getBoolean(""String_Node_Str"",true);
    unclaimedLandCanBurn=unclaimed.getBoolean(""String_Node_Str"",true);
  }
  ConfigurationNode landLimits=config.getNode(""String_Node_Str"");
  if (landLimits != null) {
    maxBlocksClaimable=landLimits.getInt(""String_Node_Str"",1000);
    maxLandsClaimable=landLimits.getInt(""String_Node_Str"",10);
    maxLandVolume=landLimits.getInt(""String_Node_Str"",1000);
    minLandVolume=landLimits.getInt(""String_Node_Str"",10);
  }
  addonsEnabled.clear();
  ConfigurationNode addons=config.getNode(""String_Node_Str"");
  if (addons != null) {
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
  }
  pricePerBlock.clear();
  ConfigurationNode addonPrices=config.getNode(""String_Node_Str"");
  if (addonPrices != null) {
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",20.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",100.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",200.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",10.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
  }
  ConfigurationNode selectionOptions=config.getNode(""String_Node_Str"");
  if (selectionOptions != null) {
    allLandFullHeight=selectionOptions.getBoolean(""String_Node_Str"",false);
  }
}","public static void loadConfig(File configFile){
  Configuration config=new Configuration(configFile);
  config.load();
  ConfigurationNode debug=config.getNode(""String_Node_Str"");
  if (debug != null) {
    debugMode=debug.getBoolean(""String_Node_Str"",false);
    debugMode1=debug.getBoolean(""String_Node_Str"",false);
    debugModeSQL=debug.getBoolean(""String_Node_Str"",false);
  }
  ConfigurationNode taxes=config.getNode(""String_Node_Str"");
  if (taxes != null) {
    sellTax=taxes.getDouble(""String_Node_Str"",80.0) / 100.0;
    if (sellTax < 0)     sellTax=0;
    if (sellTax > 1)     sellTax=1;
    taxRate=taxes.getDouble(""String_Node_Str"",5.0) / 100.0;
    if (taxRate < 0)     taxRate=0;
    if (taxRate > 1)     taxRate=1;
    bankName=taxes.getString(""String_Node_Str"",""String_Node_Str"");
  }
  ConfigurationNode timers=config.getNode(""String_Node_Str"");
  if (timers != null) {
    healTime=timers.getInt(""String_Node_Str"",30);
    mobRemovalTime=timers.getInt(""String_Node_Str"",2);
    taxTimeMinutes=timers.getInt(""String_Node_Str"",0);
    announceCheckInterval=timers.getInt(""String_Node_Str"",1000);
  }
  ConfigurationNode unclaimed=config.getNode(""String_Node_Str"");
  if (unclaimed != null) {
    unclaimedLandCanBuild=unclaimed.getBoolean(""String_Node_Str"",true);
    unclaimedLandCanBoom=unclaimed.getBoolean(""String_Node_Str"",true);
    unclaimedLandCanBurn=unclaimed.getBoolean(""String_Node_Str"",true);
  }
  ConfigurationNode landLimits=config.getNode(""String_Node_Str"");
  if (landLimits != null) {
    maxBlocksClaimable=landLimits.getInt(""String_Node_Str"",1000);
    maxLandsClaimable=landLimits.getInt(""String_Node_Str"",10);
    maxLandVolume=landLimits.getInt(""String_Node_Str"",1000);
    minLandVolume=landLimits.getInt(""String_Node_Str"",10);
  }
  addonsEnabled.clear();
  ConfigurationNode addons=config.getNode(""String_Node_Str"");
  if (addons != null) {
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
    addonsEnabled.put(""String_Node_Str"",addons.getBoolean(""String_Node_Str"",false));
  }
  pricePerBlock.clear();
  ConfigurationNode addonPrices=config.getNode(""String_Node_Str"");
  if (addonPrices != null) {
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",20.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",100.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",200.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",10.0));
    pricePerBlock.put(""String_Node_Str"",addonPrices.getDouble(""String_Node_Str"",50.0));
  }
  ConfigurationNode selectionOptions=config.getNode(""String_Node_Str"");
  if (selectionOptions != null) {
    allLandFullHeight=selectionOptions.getBoolean(""String_Node_Str"",false);
  }
}",0.991649870429024
40030,"public static void getConfig(File dataFolder){
  File configFile=new File(dataFolder + File.separator + ""String_Node_Str"");
  debugMode=false;
  debugModeSQL=false;
  sellTax=0.80;
  taxRate=0.05;
  maxBlocksClaimable=1000;
  maxLandsClaimable=10;
  maxLandVolume=1000;
  minLandVolume=10;
  addonsEnabled=new HashMap<String,Boolean>();
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  pricePerBlock=new HashMap<String,Double>();
  pricePerBlock.put(""String_Node_Str"",20.0);
  pricePerBlock.put(""String_Node_Str"",50.0);
  pricePerBlock.put(""String_Node_Str"",100.0);
  pricePerBlock.put(""String_Node_Str"",200.0);
  pricePerBlock.put(""String_Node_Str"",50.0);
  pricePerBlock.put(""String_Node_Str"",50.0);
  pricePerBlock.put(""String_Node_Str"",10.0);
  pricePerBlock.put(""String_Node_Str"",10.0);
  healTime=30;
  mobRemovalTime=2;
  taxTimeMinutes=0;
  announceCheckInterval=1000;
  unclaimedLandCanBuild=true;
  unclaimedLandCanBoom=true;
  unclaimedLandCanBurn=true;
  allLandFullHeight=false;
  bankName=""String_Node_Str"";
  if (!configFile.exists()) {
    saveConfig(configFile);
  }
 else {
    loadConfig(configFile);
    saveConfig(configFile);
  }
  loaded=true;
}","public static void getConfig(File dataFolder){
  File configFile=new File(dataFolder + File.separator + ""String_Node_Str"");
  debugMode=false;
  debugMode1=false;
  debugModeSQL=false;
  sellTax=0.80;
  taxRate=0.05;
  maxBlocksClaimable=1000;
  maxLandsClaimable=10;
  maxLandVolume=1000;
  minLandVolume=10;
  addonsEnabled=new HashMap<String,Boolean>();
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  addonsEnabled.put(""String_Node_Str"",true);
  pricePerBlock=new HashMap<String,Double>();
  pricePerBlock.put(""String_Node_Str"",20.0);
  pricePerBlock.put(""String_Node_Str"",50.0);
  pricePerBlock.put(""String_Node_Str"",100.0);
  pricePerBlock.put(""String_Node_Str"",200.0);
  pricePerBlock.put(""String_Node_Str"",50.0);
  pricePerBlock.put(""String_Node_Str"",50.0);
  pricePerBlock.put(""String_Node_Str"",10.0);
  pricePerBlock.put(""String_Node_Str"",10.0);
  healTime=30;
  mobRemovalTime=2;
  taxTimeMinutes=0;
  announceCheckInterval=1000;
  unclaimedLandCanBuild=true;
  unclaimedLandCanBoom=true;
  unclaimedLandCanBurn=true;
  allLandFullHeight=false;
  bankName=""String_Node_Str"";
  if (!configFile.exists()) {
    saveConfig(configFile);
  }
 else {
    loadConfig(configFile);
    saveConfig(configFile);
  }
  loaded=true;
}",0.9930843706777316
40031,"public static void saveConfig(File configFile){
  Configuration config=new Configuration(configFile);
  config.setProperty(""String_Node_Str"",debugMode);
  config.setProperty(""String_Node_Str"",debugModeSQL);
  config.setProperty(""String_Node_Str"",sellTax * 100.0);
  config.setProperty(""String_Node_Str"",taxRate * 100.0);
  config.setProperty(""String_Node_Str"",bankName);
  config.setProperty(""String_Node_Str"",healTime);
  config.setProperty(""String_Node_Str"",mobRemovalTime);
  config.setProperty(""String_Node_Str"",taxTimeMinutes);
  config.setProperty(""String_Node_Str"",announceCheckInterval);
  config.setProperty(""String_Node_Str"",unclaimedLandCanBuild);
  config.setProperty(""String_Node_Str"",unclaimedLandCanBoom);
  config.setProperty(""String_Node_Str"",unclaimedLandCanBurn);
  config.setProperty(""String_Node_Str"",maxBlocksClaimable);
  config.setProperty(""String_Node_Str"",maxLandsClaimable);
  config.setProperty(""String_Node_Str"",maxLandVolume);
  config.setProperty(""String_Node_Str"",minLandVolume);
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",allLandFullHeight);
  config.save();
}","public static void saveConfig(File configFile){
  Configuration config=new Configuration(configFile);
  config.setProperty(""String_Node_Str"",debugMode);
  config.setProperty(""String_Node_Str"",debugMode1);
  config.setProperty(""String_Node_Str"",debugModeSQL);
  config.setProperty(""String_Node_Str"",sellTax * 100.0);
  config.setProperty(""String_Node_Str"",taxRate * 100.0);
  config.setProperty(""String_Node_Str"",bankName);
  config.setProperty(""String_Node_Str"",healTime);
  config.setProperty(""String_Node_Str"",mobRemovalTime);
  config.setProperty(""String_Node_Str"",taxTimeMinutes);
  config.setProperty(""String_Node_Str"",announceCheckInterval);
  config.setProperty(""String_Node_Str"",unclaimedLandCanBuild);
  config.setProperty(""String_Node_Str"",unclaimedLandCanBoom);
  config.setProperty(""String_Node_Str"",unclaimedLandCanBurn);
  config.setProperty(""String_Node_Str"",maxBlocksClaimable);
  config.setProperty(""String_Node_Str"",maxLandsClaimable);
  config.setProperty(""String_Node_Str"",maxLandVolume);
  config.setProperty(""String_Node_Str"",minLandVolume);
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",addonsEnabled.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",pricePerBlock.get(""String_Node_Str""));
  config.setProperty(""String_Node_Str"",allLandFullHeight);
  config.save();
}",0.9886214442013128
40032,"public void run(){
  Player[] players=iCoLand.server.getOnlinePlayers();
  Timestamp now=new Timestamp(System.currentTimeMillis());
  Timestamp timeThreshold=new Timestamp(System.currentTimeMillis() - Config.taxTimeMinutes * 60 * 1000);
  ArrayList<Land> lands=iCoLand.landMgr.listLandPastTaxTime(timeThreshold);
  for (  Land land : lands) {
    double tax=land.location.volume() * Config.taxRate;
    Account acc=iConomy.getBank().getAccount(land.owner);
    Account bank=iConomy.getBank().getAccount(Config.bankName);
    if (acc == null) {
      iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ land.owner+ ""String_Node_Str"");
    }
 else     if (acc.hasEnough(tax)) {
      if (!iCoLand.landMgr.updateTaxTime(land.getID(),now)) {
        iCoLand.severe(""String_Node_Str"" + land.getID());
      }
      if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
        if (acc.hasEnough(tax)) {
          acc.subtract(tax);
          bank.add(tax);
          int i=playerInList(players,land.owner);
          if (i > -1) {
            Messaging mess=new Messaging(players[i]);
            mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ iCoLand.df.format(tax));
          }
          if (Config.debugMode)           iCoLand.info(land.owner + ""String_Node_Str"" + land.getID()+ ""String_Node_Str""+ iCoLand.df.format(tax));
        }
 else {
          if (!iCoLand.landMgr.updateActive(land.getID(),false)) {
            iCoLand.severe(""String_Node_Str"" + land.getID() + ""String_Node_Str"");
          }
          Double price=Double.valueOf(iCoLand.df.format(land.getTotalPrice()));
          if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
            acc.add(price);
            bank.subtract(price);
          }
          int i=playerInList(players,land.owner);
          if (i > 0) {
            Messaging mess=new Messaging(players[i]);
            mess.send(""String_Node_Str"" + tax + ""String_Node_Str""+ land.getID());
            if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
              mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price);
            }
 else {
              mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price+ ""String_Node_Str"");
            }
          }
          if (Config.debugMode) {
            iCoLand.info(land.owner + ""String_Node_Str"" + tax+ ""String_Node_Str""+ land.getID());
            iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price+ ""String_Node_Str"");
            if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
              iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price);
            }
 else {
              iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price+ ""String_Node_Str"");
            }
          }
        }
      }
 else {
        int i=playerInList(players,land.owner);
        if (i > -1) {
          Messaging mess=new Messaging(players[i]);
          mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ iCoLand.df.format(tax)+ ""String_Node_Str"");
        }
        if (Config.debugMode)         iCoLand.info(land.owner + ""String_Node_Str"" + land.getID()+ ""String_Node_Str""+ iCoLand.df.format(tax)+ ""String_Node_Str"");
      }
    }
  }
}","public void run(){
  Player[] players=iCoLand.server.getOnlinePlayers();
  Timestamp now=new Timestamp(System.currentTimeMillis());
  Timestamp timeThreshold=new Timestamp(System.currentTimeMillis() - Config.taxTimeMinutes * 60 * 1000);
  ArrayList<Land> lands=iCoLand.landMgr.listLandPastTaxTime(timeThreshold);
  if (Config.debugMode1)   iCoLand.info(""String_Node_Str"" + now);
  for (  Land land : lands) {
    double tax=land.location.volume() * Config.taxRate;
    Account acc=iConomy.getBank().getAccount(land.owner);
    Account bank=iConomy.getBank().getAccount(Config.bankName);
    if (acc == null) {
      iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ land.owner+ ""String_Node_Str"");
    }
 else     if (acc.hasEnough(tax)) {
      if (!iCoLand.landMgr.updateTaxTime(land.getID(),now)) {
        iCoLand.severe(""String_Node_Str"" + land.getID());
      }
      if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
        if (acc.hasEnough(tax)) {
          acc.subtract(tax);
          bank.add(tax);
          int i=playerInList(players,land.owner);
          if (i > -1) {
            Messaging mess=new Messaging(players[i]);
            mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ iCoLand.df.format(tax));
          }
          if (Config.debugMode)           iCoLand.info(land.owner + ""String_Node_Str"" + land.getID()+ ""String_Node_Str""+ iCoLand.df.format(tax));
        }
 else {
          if (!iCoLand.landMgr.updateActive(land.getID(),false)) {
            iCoLand.severe(""String_Node_Str"" + land.getID() + ""String_Node_Str"");
          }
          Double price=Double.valueOf(iCoLand.df.format(land.getTotalPrice()));
          if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
            acc.add(price);
            bank.subtract(price);
          }
          int i=playerInList(players,land.owner);
          if (i > 0) {
            Messaging mess=new Messaging(players[i]);
            mess.send(""String_Node_Str"" + tax + ""String_Node_Str""+ land.getID());
            if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
              mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price);
            }
 else {
              mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price+ ""String_Node_Str"");
            }
          }
          if (Config.debugMode) {
            iCoLand.info(land.owner + ""String_Node_Str"" + tax+ ""String_Node_Str""+ land.getID());
            iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price+ ""String_Node_Str"");
            if (!iCoLand.hasPermission(land.location.setLoc1.getWorld().getName(),land.owner,""String_Node_Str"")) {
              iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price);
            }
 else {
              iCoLand.info(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ price+ ""String_Node_Str"");
            }
          }
        }
      }
 else {
        int i=playerInList(players,land.owner);
        if (i > -1) {
          Messaging mess=new Messaging(players[i]);
          mess.send(""String_Node_Str"" + land.getID() + ""String_Node_Str""+ iCoLand.df.format(tax)+ ""String_Node_Str"");
        }
        if (Config.debugMode)         iCoLand.info(land.owner + ""String_Node_Str"" + land.getID()+ ""String_Node_Str""+ iCoLand.df.format(tax)+ ""String_Node_Str"");
      }
    }
  }
}",0.9905660377358492
40033,"public void adminEditLand(CommandSender sender,Integer id,String category,String tags){
  Messaging mess=new Messaging(sender);
  if (category.equals(""String_Node_Str"")) {
    editLand((Player)sender,id,category,tags);
  }
 else   if (category.equalsIgnoreCase(""String_Node_Str"")) {
    editLand((Player)sender,id,category,tags);
  }
 else   if (category.equalsIgnoreCase(""String_Node_Str"")) {
    if (iCoLand.landMgr.updateOwner(id,tags))     mess.send(""String_Node_Str"");
 else     mess.send(""String_Node_Str"");
  }
 else   if (category.equalsIgnoreCase(""String_Node_Str"")) {
    if (iCoLand.landMgr.toggleAddons(id,tags))     mess.send(""String_Node_Str"");
 else     mess.send(""String_Node_Str"");
  }
}","public void adminEditLand(CommandSender sender,Integer id,String category,String tags){
  Messaging mess=new Messaging(sender);
  if (category.equals(""String_Node_Str"")) {
    if (iCoLand.landMgr.modifyPermTags(id,tags))     mess.send(""String_Node_Str"");
 else     mess.send(""String_Node_Str"");
  }
 else   if (category.equalsIgnoreCase(""String_Node_Str"")) {
    if (iCoLand.landMgr.updateOwner(id,tags))     mess.send(""String_Node_Str"");
 else     mess.send(""String_Node_Str"");
  }
 else   if (category.equalsIgnoreCase(""String_Node_Str"")) {
    if (iCoLand.landMgr.toggleAddons(id,tags))     mess.send(""String_Node_Str"");
 else     mess.send(""String_Node_Str"");
  }
 else   if (category.equalsIgnoreCase(""String_Node_Str"")) {
    if (iCoLand.landMgr.updateName(id,tags.substring(0,(tags.length() > 35) ? 35 : tags.length())))     mess.send(""String_Node_Str"");
 else     mess.send(""String_Node_Str"");
  }
 else {
    mess.send(""String_Node_Str"");
  }
}",0.5926372963186481
40034,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  Messaging mess=new Messaging(sender);
  if (Config.debugMode) {
    String debug=""String_Node_Str"" + ((sender instanceof Player) ? ""String_Node_Str"" + ((Player)sender).getName() : ""String_Node_Str"") + ""String_Node_Str""+ cmd.getName()+ ""String_Node_Str"";
    for (int i=0; i < args.length; i++)     debug+=args[i] + ""String_Node_Str"";
    iCoLand.info(debug);
  }
  if (!(sender instanceof Player))   return false;
  if (Misc.isAny(cmd.getName(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    if (Config.debugMode)     iCoLand.info(""String_Node_Str"");
    if (args.length == 0) {
      showHelp(sender,""String_Node_Str"");
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args.length == 1) {
        showHelp(sender,""String_Node_Str"");
      }
 else {
        showHelp(sender,args[1]);
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length > 1) {
          Integer page;
          try {
            page=Integer.parseInt(args[1]);
            if (page > 1)             showList(sender,page - 1);
 else             mess.send(""String_Node_Str"");
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
        }
 else {
          showList(sender,0);
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        Player player=(Player)sender;
        if (args.length > 3) {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
            return true;
          }
          if (iCoLand.landMgr.landIdExists(id)) {
            if (iCoLand.landMgr.isOwner(player.getName(),id)) {
              if (Misc.isEither(args[2],""String_Node_Str"",""String_Node_Str"")) {
                String tags=""String_Node_Str"";
                for (int i=3; i < args.length; i++)                 tags+=args[i] + ""String_Node_Str"";
                editLand(player,id,args[2],tags);
              }
 else {
                mess.send(""String_Node_Str"");
                showHelp(sender,""String_Node_Str"");
              }
            }
 else {
              mess.send(""String_Node_Str"" + id);
            }
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else {
          mess.send(""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length < 4) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException e) {
            mess.send(""String_Node_Str"");
            return true;
          }
          if (!iCoLand.landMgr.landIdExists(id)) {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
 else {
            if (Misc.isAny(args[2],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
              String tags=args[3];
              for (int i=4; i < args.length; i++)               tags+=args[i];
              adminEditLand(sender,id,args[2],tags);
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (!(sender instanceof Player)) {
          mess.send(""String_Node_Str"");
        }
 else         if (args.length == 1) {
          selectArea((Player)sender);
        }
 else         if (args.length == 2) {
          Player player=(Player)sender;
          if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
            mess.send(""String_Node_Str"");
            iCoLand.cmdMap.remove(player.getName());
            iCoLand.tmpCuboidMap.remove(((Player)sender).getName());
          }
 else           if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
            if (iCoLand.tmpCuboidMap.containsKey(player.getName())) {
              mess.send(""String_Node_Str"");
              iCoLand.tmpCuboidMap.get(player.getName()).setFullHeight();
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if ((args.length == 1)) {
          if (sender instanceof Player)           showLandInfo(sender,""String_Node_Str"");
 else           mess.send(""String_Node_Str"");
        }
 else         if (args.length == 2) {
          showLandInfo(sender,args[1]);
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 1) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          if (args.length == 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            buyLand(sender);
          }
 else           if (args.length > 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            if (args.length == 4) {
              if (Config.isAddon(args[2])) {
                try {
                  Integer id=Integer.parseInt(args[3]);
                  if (iCoLand.landMgr.landIdExists(id)) {
                    buyAddon((Player)sender,args[2],id);
                  }
 else {
                    mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
                  }
                }
 catch (                NumberFormatException ex) {
                  mess.send(""String_Node_Str"");
                }
              }
 else {
                mess.send(""String_Node_Str"");
              }
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
 else {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 3 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[2]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iCoLand.landMgr.landIdExists(id)) {
            sellLand((Player)sender,id);
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else         if (args.length == 4 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[3]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iCoLand.landMgr.landIdExists(id)) {
            if (Config.isAddon(args[2])) {
              sellAddon((Player)sender,args[2],id);
            }
 else {
              mess.send(""String_Node_Str"" + args[2]);
            }
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        iCoLand.landMgr.importDB(new File(iCoLand.pluginDirectory + File.separator + Config.importFile));
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        iCoLand.landMgr.exportDB(new File(iCoLand.pluginDirectory + File.separator + Config.exportFile));
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length > 1) {
          Integer numLands=0;
          try {
            numLands=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException ex) {
            ex.printStackTrace();
          }
          long start=System.currentTimeMillis();
          for (int i=0; i < numLands; i++) {
            Location loc1=new Location(iCoLand.server.getWorlds().get(0),rand(-4096,4096),rand(5,100),rand(-4096,4096));
            Location loc2=new Location(iCoLand.server.getWorlds().get(0),loc1.getBlockX() + rand(0,100),loc1.getBlockY() + rand(0,28),loc1.getBlockZ() + rand(0,100));
            iCoLand.landMgr.addLand(new Cuboid(loc1,loc2),((Player)sender).getName(),""String_Node_Str"",""String_Node_Str"");
          }
          if (Config.debugMode)           iCoLand.info(""String_Node_Str"" + numLands + ""String_Node_Str""+ (System.currentTimeMillis() - start)+ ""String_Node_Str"");
        }
 else {
          mess.send(""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else {
      mess.send(""String_Node_Str"");
      mess.send(""String_Node_Str"");
      return true;
    }
  }
 else {
    return false;
  }
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  Messaging mess=new Messaging(sender);
  if (Config.debugMode1) {
    String debug=""String_Node_Str"" + ((sender instanceof Player) ? ""String_Node_Str"" + ((Player)sender).getName() : ""String_Node_Str"") + ""String_Node_Str""+ cmd.getName()+ ""String_Node_Str"";
    for (int i=0; i < args.length; i++)     debug+=args[i] + ""String_Node_Str"";
    iCoLand.info(debug);
  }
  if (Misc.isAny(cmd.getName(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    if (Config.debugMode)     iCoLand.info(""String_Node_Str"");
    if (args.length == 0) {
      showHelp(sender,""String_Node_Str"");
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args.length == 1) {
        showHelp(sender,""String_Node_Str"");
      }
 else {
        showHelp(sender,args[1]);
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length > 1) {
          Integer page;
          try {
            page=Integer.parseInt(args[1]);
            if (page > 1)             showList(sender,page - 1);
 else             mess.send(""String_Node_Str"");
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
        }
 else {
          showList(sender,0);
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        Player player=(Player)sender;
        if (args.length > 3) {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
            return true;
          }
          if (iCoLand.landMgr.landIdExists(id)) {
            if (iCoLand.landMgr.isOwner(player.getName(),id)) {
              if (Misc.isEither(args[2],""String_Node_Str"",""String_Node_Str"")) {
                String tags=""String_Node_Str"";
                for (int i=3; i < args.length; i++)                 tags+=args[i] + ""String_Node_Str"";
                editLand(player,id,args[2],tags);
              }
 else {
                mess.send(""String_Node_Str"");
                showHelp(sender,""String_Node_Str"");
              }
            }
 else {
              mess.send(""String_Node_Str"" + id);
            }
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else {
          mess.send(""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length < 4) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException e) {
            mess.send(""String_Node_Str"");
            return true;
          }
          if (!iCoLand.landMgr.landIdExists(id)) {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
 else {
            if (Misc.isAny(args[2],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
              String tags=args[3];
              for (int i=4; i < args.length; i++)               tags+=args[i];
              adminEditLand(sender,id,args[2],tags);
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (!(sender instanceof Player)) {
          mess.send(""String_Node_Str"");
        }
 else         if (args.length == 1) {
          selectArea((Player)sender);
        }
 else         if (args.length == 2) {
          Player player=(Player)sender;
          if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
            mess.send(""String_Node_Str"");
            iCoLand.cmdMap.remove(player.getName());
            iCoLand.tmpCuboidMap.remove(((Player)sender).getName());
          }
 else           if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
            if (iCoLand.tmpCuboidMap.containsKey(player.getName())) {
              mess.send(""String_Node_Str"");
              iCoLand.tmpCuboidMap.get(player.getName()).setFullHeight();
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if ((args.length == 1)) {
          if (sender instanceof Player)           showLandInfo(sender,""String_Node_Str"");
 else           mess.send(""String_Node_Str"");
        }
 else         if (args.length == 2) {
          showLandInfo(sender,args[1]);
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 1) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          if (args.length == 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            buyLand(sender);
          }
 else           if (args.length > 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            if (args.length == 4) {
              if (Config.isAddon(args[2])) {
                try {
                  Integer id=Integer.parseInt(args[3]);
                  if (iCoLand.landMgr.landIdExists(id)) {
                    buyAddon((Player)sender,args[2],id);
                  }
 else {
                    mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
                  }
                }
 catch (                NumberFormatException ex) {
                  mess.send(""String_Node_Str"");
                }
              }
 else {
                mess.send(""String_Node_Str"");
              }
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
 else {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 3 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[2]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iCoLand.landMgr.landIdExists(id)) {
            sellLand((Player)sender,id);
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else         if (args.length == 4 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[3]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iCoLand.landMgr.landIdExists(id)) {
            if (Config.isAddon(args[2])) {
              sellAddon((Player)sender,args[2],id);
            }
 else {
              mess.send(""String_Node_Str"" + args[2]);
            }
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        iCoLand.landMgr.importDB(new File(iCoLand.pluginDirectory + File.separator + Config.importFile));
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        iCoLand.landMgr.exportDB(new File(iCoLand.pluginDirectory + File.separator + Config.exportFile));
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iCoLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length > 1) {
          Integer numLands=0;
          try {
            numLands=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException ex) {
            ex.printStackTrace();
          }
          long start=System.currentTimeMillis();
          for (int i=0; i < numLands; i++) {
            Location loc1=new Location(iCoLand.server.getWorlds().get(0),rand(-4096,4096),rand(5,100),rand(-4096,4096));
            Location loc2=new Location(iCoLand.server.getWorlds().get(0),loc1.getBlockX() + rand(0,100),loc1.getBlockY() + rand(0,28),loc1.getBlockZ() + rand(0,100));
            iCoLand.landMgr.addLand(new Cuboid(loc1,loc2),((Player)sender).getName(),""String_Node_Str"",""String_Node_Str"");
          }
          if (Config.debugMode)           iCoLand.info(""String_Node_Str"" + numLands + ""String_Node_Str""+ (System.currentTimeMillis() - start)+ ""String_Node_Str"");
        }
 else {
          mess.send(""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else {
      mess.send(""String_Node_Str"");
      mess.send(""String_Node_Str"");
      return true;
    }
  }
 else {
    return false;
  }
}",0.9967277486910996
40035,"public void showLandInfo(CommandSender sender,String... args){
  Messaging mess=new Messaging(sender);
  if (args.length == 0) {
    showHelp(sender,""String_Node_Str"");
  }
 else {
    Integer id=0;
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      id=iCoLand.landMgr.getLandId(((Player)sender).getLocation());
      if (id > 0) {
        showSelectLandInfo((CommandSender)sender,id);
      }
 else {
        mess.send(""String_Node_Str"");
      }
    }
 else {
      try {
        id=Integer.parseInt(args[0]);
      }
 catch (      NumberFormatException e) {
        id=0;
      }
      if (id > 0) {
        if (iCoLand.landMgr.landIdExists(id)) {
          showSelectLandInfo((CommandSender)sender,id);
        }
 else {
          mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
        }
      }
 else {
        if (sender instanceof Player)         showLandInfo((Player)sender,args);
 else         showHelp(sender,""String_Node_Str"");
      }
    }
  }
}","public void showLandInfo(CommandSender sender,String... args){
  Messaging mess=new Messaging(sender);
  if (args.length == 0) {
    showHelp(sender,""String_Node_Str"");
  }
 else {
    Integer id=0;
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (sender instanceof Player) {
        id=iCoLand.landMgr.getLandId(((Player)sender).getLocation());
        if (id > 0) {
          showSelectLandInfo((CommandSender)sender,id);
        }
 else {
          mess.send(""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
    }
 else {
      try {
        id=Integer.parseInt(args[0]);
      }
 catch (      NumberFormatException e) {
        id=0;
      }
      if (id > 0) {
        if (iCoLand.landMgr.landIdExists(id)) {
          showSelectLandInfo((CommandSender)sender,id);
        }
 else {
          mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
        }
      }
 else {
        if (sender instanceof Player)         showLandInfo((Player)sender,args);
 else         showHelp(sender,""String_Node_Str"");
      }
    }
  }
}",0.9457364341085271
40036,"public boolean canBuild(Player player,Location loc){
  String playerName=player.getName();
  Integer id=getLandId(loc);
  if (id > 0) {
    return getLandById(id).hasPermission(playerName);
  }
 else {
    if (Config.preventGlobalBuildWithoutPerm && iCoLand.hasPermission(player,""String_Node_Str"")) {
      return true;
    }
 else {
      return false;
    }
  }
}","public boolean canBuild(Player player,Location loc){
  String playerName=player.getName();
  Integer id=getLandId(loc);
  if (id > 0) {
    return getLandById(id).hasPermission(playerName);
  }
 else {
    if (Config.preventGlobalBuildWithoutPerm) {
      return iCoLand.hasPermission(player,""String_Node_Str"");
    }
 else {
      return true;
    }
  }
}",0.8155339805825242
40037,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  Messaging mess=new Messaging(sender);
  if (iConomyLand.debugMode) {
    String debug=""String_Node_Str"" + ((sender instanceof Player) ? ""String_Node_Str"" + ((Player)sender).getName() : ""String_Node_Str"") + ""String_Node_Str""+ cmd.getName()+ ""String_Node_Str"";
    for (int i=0; i < args.length; i++)     debug+=args[i] + ""String_Node_Str"";
    iConomyLand.info(debug);
  }
  if (!(sender instanceof Player))   return false;
  if (Misc.isAny(cmd.getName(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    if (iConomyLand.debugMode)     iConomyLand.info(""String_Node_Str"");
    if (args.length == 0) {
      showHelp(sender,""String_Node_Str"");
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args.length == 1) {
        showHelp(sender,""String_Node_Str"");
      }
 else {
        showHelp(sender,args[1]);
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        showList(sender);
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (!(sender instanceof Player)) {
          mess.send(""String_Node_Str"");
        }
 else         if (args.length == 1) {
          selectArea((Player)sender);
        }
 else         if (args.length == 2 & args[1].equalsIgnoreCase(""String_Node_Str"")) {
          mess.send(""String_Node_Str"");
          iConomyLand.cmdMap.remove(((Player)sender).getName());
          iConomyLand.tmpCuboidMap.remove(((Player)sender).getName());
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if ((args.length == 1)) {
          if (sender instanceof Player)           showLandInfo(sender,""String_Node_Str"");
 else           mess.send(""String_Node_Str"");
        }
 else {
          showLandInfo(sender,args[1]);
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 1) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          if (args.length == 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            buyLand(sender);
          }
 else           if (args.length > 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            if (args.length == 4) {
              if (Misc.isAny(args[2],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
                try {
                  Integer id=Integer.parseInt(args[3]);
                  if (iConomyLand.landMgr.landIdExists(id)) {
                    buyAddon((Player)sender,args[2],id);
                  }
 else {
                    mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
                  }
                }
 catch (                NumberFormatException ex) {
                  mess.send(""String_Node_Str"");
                }
              }
 else {
                mess.send(""String_Node_Str"");
              }
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
 else {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 3 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[2]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iConomyLand.landMgr.landIdExists(id)) {
            sellLand((Player)sender,id);
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else         if (args.length == 4 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[3]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iConomyLand.landMgr.landIdExists(id)) {
            if (Misc.isAny(args[2],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
              sellAddon((Player)sender,args[2],id);
            }
 else {
              mess.send(""String_Node_Str"" + args[2]);
            }
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length < 4) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException e) {
            id=-1;
          }
          if (id <= 0) {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
 else {
            if (args[2].equals(""String_Node_Str"") && iConomyLand.hasPermission(sender,""String_Node_Str"")) {
              changeOwner(sender,id,args[3]);
            }
 else {
              if (args.length < 5) {
                mess.send(""String_Node_Str"");
                showHelp(sender,""String_Node_Str"");
              }
 else {
                String tags=args[4];
                for (int i=5; i < args.length; i++)                 tags+=""String_Node_Str"" + args[i];
                if (args[2].equals(""String_Node_Str"") && iConomyLand.hasPermission(sender,""String_Node_Str"")) {
                  if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    addPerms(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else                   if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    delPerms(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else {
                    mess.send(""String_Node_Str"");
                  }
                }
 else                 if (args[2].equals(""String_Node_Str"") && iConomyLand.hasPermission(sender,""String_Node_Str"")) {
                  if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    addAddon(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else                   if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    delAddon(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else {
                    mess.send(""String_Node_Str"");
                  }
                }
 else {
                  mess.send(""String_Node_Str"");
                  showHelp(sender,""String_Node_Str"");
                }
              }
            }
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else {
      mess.send(""String_Node_Str"");
      mess.send(""String_Node_Str"");
      return true;
    }
  }
 else {
    return false;
  }
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  Messaging mess=new Messaging(sender);
  if (iConomyLand.debugMode) {
    String debug=""String_Node_Str"" + ((sender instanceof Player) ? ""String_Node_Str"" + ((Player)sender).getName() : ""String_Node_Str"") + ""String_Node_Str""+ cmd.getName()+ ""String_Node_Str"";
    for (int i=0; i < args.length; i++)     debug+=args[i] + ""String_Node_Str"";
    iConomyLand.info(debug);
  }
  if (!(sender instanceof Player))   return false;
  if (Misc.isAny(cmd.getName(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    if (iConomyLand.debugMode)     iConomyLand.info(""String_Node_Str"");
    if (args.length == 0) {
      showHelp(sender,""String_Node_Str"");
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args.length == 1) {
        showHelp(sender,""String_Node_Str"");
      }
 else {
        showHelp(sender,args[1]);
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        showList(sender);
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (!(sender instanceof Player)) {
          mess.send(""String_Node_Str"");
        }
 else         if (args.length == 1) {
          selectArea((Player)sender);
        }
 else         if (args.length == 2 & args[1].equalsIgnoreCase(""String_Node_Str"")) {
          mess.send(""String_Node_Str"");
          iConomyLand.cmdMap.remove(((Player)sender).getName());
          iConomyLand.tmpCuboidMap.remove(((Player)sender).getName());
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if ((args.length == 1)) {
          if (sender instanceof Player)           showLandInfo(sender,""String_Node_Str"");
 else           mess.send(""String_Node_Str"");
        }
 else         if (args.length == 2) {
          showLandInfo(sender,args[1]);
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 1) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          if (args.length == 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            buyLand(sender);
          }
 else           if (args.length > 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
            if (args.length == 4) {
              if (Misc.isAny(args[2],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
                try {
                  Integer id=Integer.parseInt(args[3]);
                  if (iConomyLand.landMgr.landIdExists(id)) {
                    buyAddon((Player)sender,args[2],id);
                  }
 else {
                    mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
                  }
                }
 catch (                NumberFormatException ex) {
                  mess.send(""String_Node_Str"");
                }
              }
 else {
                mess.send(""String_Node_Str"");
              }
            }
 else {
              mess.send(""String_Node_Str"");
            }
          }
 else {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (!(sender instanceof Player)) {
        mess.send(""String_Node_Str"");
      }
 else       if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 3 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[2]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iConomyLand.landMgr.landIdExists(id)) {
            sellLand((Player)sender,id);
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else         if (args.length == 4 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
          Integer id=0;
          try {
            id=Integer.parseInt(args[3]);
          }
 catch (          NumberFormatException ex) {
            mess.send(""String_Node_Str"");
          }
          if (iConomyLand.landMgr.landIdExists(id)) {
            if (Misc.isAny(args[2],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
              sellAddon((Player)sender,args[2],id);
            }
 else {
              mess.send(""String_Node_Str"" + args[2]);
            }
          }
 else {
            mess.send(""String_Node_Str"" + id + ""String_Node_Str"");
          }
        }
 else {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length < 4) {
          mess.send(""String_Node_Str"");
          showHelp(sender,""String_Node_Str"");
        }
 else {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException e) {
            id=-1;
          }
          if (id <= 0) {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
 else {
            if (args[2].equals(""String_Node_Str"") && iConomyLand.hasPermission(sender,""String_Node_Str"")) {
              changeOwner(sender,id,args[3]);
            }
 else {
              if (args.length < 5) {
                mess.send(""String_Node_Str"");
                showHelp(sender,""String_Node_Str"");
              }
 else {
                String tags=args[4];
                for (int i=5; i < args.length; i++)                 tags+=""String_Node_Str"" + args[i];
                if (args[2].equals(""String_Node_Str"") && iConomyLand.hasPermission(sender,""String_Node_Str"")) {
                  if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    addPerms(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else                   if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    delPerms(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else {
                    mess.send(""String_Node_Str"");
                  }
                }
 else                 if (args[2].equals(""String_Node_Str"") && iConomyLand.hasPermission(sender,""String_Node_Str"")) {
                  if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    addAddon(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else                   if (args[3].equalsIgnoreCase(""String_Node_Str"")) {
                    delAddon(sender,id,tags);
                    iConomyLand.landMgr.showSelectLandInfo(sender,id);
                  }
 else {
                    mess.send(""String_Node_Str"");
                  }
                }
 else {
                  mess.send(""String_Node_Str"");
                  showHelp(sender,""String_Node_Str"");
                }
              }
            }
          }
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else {
      mess.send(""String_Node_Str"");
      mess.send(""String_Node_Str"");
      return true;
    }
  }
 else {
    return false;
  }
}",0.9919635360441406
40038,"public boolean intersects(Cuboid other){
  double maxX=other.LocMax.getBlockX();
  double maxY=other.LocMax.getBlockX();
  double maxZ=other.LocMax.getBlockZ();
  double minX=other.LocMin.getBlockX();
  double minY=other.LocMin.getBlockY();
  double minZ=other.LocMin.getBlockZ();
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,maxY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,maxY,minZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,minY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,minY,minZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,maxY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,maxY,minZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,minY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,minY,minZ)))   return true;
  maxX=LocMax.getBlockX();
  maxY=LocMax.getBlockX();
  maxZ=LocMax.getBlockZ();
  minX=LocMin.getBlockX();
  minY=LocMin.getBlockY();
  minZ=LocMin.getBlockZ();
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,maxY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,maxY,minZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,minY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,minY,minZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,maxY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,maxY,minZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,minY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,minY,minZ)))   return true;
  return false;
}","public boolean intersects(Cuboid other){
  double maxX=other.LocMax.getBlockX();
  double maxY=other.LocMax.getBlockX();
  double maxZ=other.LocMax.getBlockZ();
  double minX=other.LocMin.getBlockX();
  double minY=other.LocMin.getBlockY();
  double minZ=other.LocMin.getBlockZ();
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,maxY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,maxY,minZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,minY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),maxX,minY,minZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,maxY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,maxY,minZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,minY,maxZ)))   return true;
  if (isIn(new Location(other.setLoc1.getWorld(),minX,minY,minZ)))   return true;
  maxX=LocMax.getBlockX();
  maxY=LocMax.getBlockY();
  maxZ=LocMax.getBlockZ();
  minX=LocMin.getBlockX();
  minY=LocMin.getBlockY();
  minZ=LocMin.getBlockZ();
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,maxY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,maxY,minZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,minY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),maxX,minY,minZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,maxY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,maxY,minZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,minY,maxZ)))   return true;
  if (other.isIn(new Location(setLoc1.getWorld(),minX,minY,minZ)))   return true;
  return false;
}",0.9994356659142212
40039,"public void showExistingLandInfo(CommandSender sender,Land land){
  Messaging mess=new Messaging(sender);
  mess.send(Misc.headerify(""String_Node_Str"" + land.getID() + ""String_Node_Str""));
  mess.send(""String_Node_Str"" + land.owner);
  if (!(sender instanceof Player) || land.owner.equals(((Player)sender).getName())) {
    mess.send(""String_Node_Str"" + land.perms);
    mess.send(""String_Node_Str"" + land.addons);
    mess.send(""String_Node_Str"" + land.dateCreated);
    mess.send(""String_Node_Str"" + land.dateTaxed);
  }
}","public void showExistingLandInfo(CommandSender sender,Land land){
  Messaging mess=new Messaging(sender);
  mess.send(""String_Node_Str"" + Misc.headerify(""String_Node_Str"" + land.getID() + ""String_Node_Str""));
  mess.send(""String_Node_Str"" + land.owner);
  if (!(sender instanceof Player) || land.owner.equals(((Player)sender).getName())) {
    mess.send(""String_Node_Str"" + land.perms);
    mess.send(""String_Node_Str"" + land.addons);
    mess.send(""String_Node_Str"" + land.dateCreated);
    mess.send(""String_Node_Str"" + land.dateTaxed);
  }
}",0.9812734082397004
40040,"@Override public void onBlockRightClick(BlockRightClickEvent event){
  Player player=event.getPlayer();
  String playerName=player.getName();
  if (iConomyLand.cmdMap.containsKey(playerName) && iConomyLand.cmdMap.get(playerName).equals(""String_Node_Str"")) {
    Cuboid newCuboid;
    Location loc=event.getBlock().getLocation();
    if (iConomyLand.tmpCuboidMap.containsKey(playerName)) {
      newCuboid=iConomyLand.tmpCuboidMap.get(playerName);
      newCuboid.setLocation(loc);
    }
 else {
      newCuboid=new Cuboid(loc);
    }
    Messaging mess=new Messaging((CommandSender)player);
    if (newCuboid.isValid()) {
      mess.send(""String_Node_Str"");
      iConomyLand.landMgr.showSelectLandInfo(player,newCuboid);
      if (iConomyLand.landMgr.add(newCuboid,playerName,""String_Node_Str"",""String_Node_Str"")) {
        iConomyLand.cmdMap.remove(playerName);
      }
    }
 else {
      iConomyLand.tmpCuboidMap.put(playerName,newCuboid);
      mess.send(""String_Node_Str"");
    }
  }
}","@Override public void onBlockRightClick(BlockRightClickEvent event){
  Player player=event.getPlayer();
  String playerName=player.getName();
  if (iConomyLand.cmdMap.containsKey(playerName) && iConomyLand.cmdMap.get(playerName).equals(""String_Node_Str"")) {
    Cuboid newCuboid;
    Location loc=event.getBlock().getLocation();
    if (iConomyLand.tmpCuboidMap.containsKey(playerName)) {
      newCuboid=iConomyLand.tmpCuboidMap.get(playerName);
      newCuboid.setLocation(loc);
    }
 else {
      newCuboid=new Cuboid(loc);
    }
    Messaging mess=new Messaging((CommandSender)player);
    if (newCuboid.isValid()) {
      mess.send(""String_Node_Str"");
      iConomyLand.landMgr.showSelectLandInfo(player,newCuboid);
    }
 else {
      iConomyLand.tmpCuboidMap.put(playerName,newCuboid);
      mess.send(""String_Node_Str"");
    }
  }
}",0.8264192139737991
40041,"public void showHelp(CommandSender sender,String topic){
  Messaging mess=new Messaging(sender);
  mess.send(Misc.headerify(""String_Node_Str"" + iConomyLand.name + ""String_Node_Str""+ iConomyLand.codename+ ""String_Node_Str""));
  if (topic == null || topic.isEmpty()) {
    mess.send(""String_Node_Str"");
    mess.send(""String_Node_Str"");
    String topics=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    mess.send(""String_Node_Str"" + topics);
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
}","public void showHelp(CommandSender sender,String topic){
  Messaging mess=new Messaging(sender);
  mess.send(""String_Node_Str"" + Misc.headerify(""String_Node_Str"" + iConomyLand.name + ""String_Node_Str""+ iConomyLand.codename+ ""String_Node_Str""));
  if (topic == null || topic.isEmpty()) {
    mess.send(""String_Node_Str"");
    mess.send(""String_Node_Str"");
    String topics=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    if (iConomyLand.hasPermission(sender,""String_Node_Str""))     topics+=""String_Node_Str"";
    mess.send(""String_Node_Str"" + topics);
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
 else   if (topic.equalsIgnoreCase(""String_Node_Str"")) {
    if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
    }
  }
}",0.994186046511628
40042,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  Messaging mess=new Messaging(sender);
  if (iConomyLand.debugMode) {
    String debug=""String_Node_Str"" + ((sender instanceof Player) ? ""String_Node_Str"" + ((Player)sender).getName() : ""String_Node_Str"") + ""String_Node_Str""+ cmd.getName()+ ""String_Node_Str"";
    for (int i=0; i < args.length; i++)     debug+=args[i] + ""String_Node_Str"";
    iConomyLand.info(debug);
  }
  if (!(sender instanceof Player))   return false;
  if (Misc.isAny(cmd.getName(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    if (iConomyLand.debugMode)     iConomyLand.info(""String_Node_Str"");
    if (args.length == 0) {
      showHelp(sender,""String_Node_Str"");
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args.length == 1) {
        showHelp(sender,""String_Node_Str"");
      }
 else {
        showHelp(sender,args[1]);
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (sender instanceof Player)         selectArea((Player)sender);
 else         mess.send(""String_Node_Str"");
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 1) {
          if (sender instanceof Player)           showLandInfo((Player)sender,""String_Node_Str"");
 else           mess.send(""String_Node_Str"");
        }
 else {
          showLandInfo(sender,args[1]);
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else {
      mess.send(""String_Node_Str"");
      mess.send(""String_Node_Str"");
      return true;
    }
  }
 else {
    return false;
  }
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  Messaging mess=new Messaging(sender);
  if (iConomyLand.debugMode) {
    String debug=""String_Node_Str"" + ((sender instanceof Player) ? ""String_Node_Str"" + ((Player)sender).getName() : ""String_Node_Str"") + ""String_Node_Str""+ cmd.getName()+ ""String_Node_Str"";
    for (int i=0; i < args.length; i++)     debug+=args[i] + ""String_Node_Str"";
    iConomyLand.info(debug);
  }
  if (!(sender instanceof Player))   return false;
  if (Misc.isAny(cmd.getName(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    if (iConomyLand.debugMode)     iConomyLand.info(""String_Node_Str"");
    if (args.length == 0) {
      showHelp(sender,""String_Node_Str"");
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args.length == 1) {
        showHelp(sender,""String_Node_Str"");
      }
 else {
        showHelp(sender,args[1]);
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (sender instanceof Player)         selectArea((Player)sender);
 else         mess.send(""String_Node_Str"");
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length == 1) {
          if (sender instanceof Player)           showLandInfo((Player)sender,""String_Node_Str"");
 else           mess.send(""String_Node_Str"");
        }
 else {
          showLandInfo(sender,args[1]);
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        buyLand(sender);
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (iConomyLand.hasPermission(sender,""String_Node_Str"")) {
        if (args.length > 3) {
          Integer id;
          try {
            id=Integer.parseInt(args[1]);
          }
 catch (          NumberFormatException e) {
            id=-1;
          }
          if (id <= 0) {
            mess.send(""String_Node_Str"");
            showHelp(sender,""String_Node_Str"");
          }
 else {
            if (Misc.isEither(args[2],""String_Node_Str"",""String_Node_Str"")) {
              String tags=args[3];
              for (int i=4; i < args.length; i++)               tags+=""String_Node_Str"" + args[i];
              modifyLand(sender,id,args[2],tags);
            }
 else {
              mess.send(""String_Node_Str"");
              showHelp(sender,""String_Node_Str"");
            }
          }
        }
 else {
          showHelp(sender,""String_Node_Str"");
        }
      }
 else {
        mess.send(""String_Node_Str"");
      }
      return true;
    }
 else {
      mess.send(""String_Node_Str"");
      mess.send(""String_Node_Str"");
      return true;
    }
  }
 else {
    return false;
  }
}",0.848990488903721
40043,"public void showLandInfo(CommandSender sender,String... args){
}","public void showLandInfo(CommandSender sender,String... args){
  if (args.length == 0) {
    showHelp(sender,""String_Node_Str"");
  }
 else {
    Integer id;
    try {
      id=Integer.parseInt(args[0]);
    }
 catch (    NumberFormatException e) {
      id=-1;
    }
    if (id > 0) {
      iConomyLand.landMgr.showSelectLandInfo((CommandSender)sender,id);
    }
 else {
      showHelp(sender,""String_Node_Str"");
    }
  }
}",0.2581967213114754
40044,"public boolean selectArea(Player player){
  String playerName=player.getName();
  Messaging mess=new Messaging((CommandSender)player);
  if (iConomyLand.cmdMap.containsKey(playerName)) {
    String action=iConomyLand.cmdMap.get(playerName);
    if (action.equals(""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
      iConomyLand.cmdMap.remove(playerName);
      iConomyLand.tmpCuboidMap.remove(playerName);
    }
  }
  mess.send(""String_Node_Str"");
  iConomyLand.cmdMap.put(playerName,""String_Node_Str"");
  return true;
}","public boolean selectArea(Player player){
  String playerName=player.getName();
  Messaging mess=new Messaging((CommandSender)player);
  if (iConomyLand.cmdMap.containsKey(playerName)) {
    String action=iConomyLand.cmdMap.get(playerName);
    if (action.equals(""String_Node_Str"")) {
      mess.send(""String_Node_Str"");
      iConomyLand.cmdMap.remove(playerName);
      iConomyLand.tmpCuboidMap.remove(playerName);
    }
 else {
      mess.send(""String_Node_Str"" + action);
      iConomyLand.cmdMap.remove(playerName);
    }
  }
  mess.send(""String_Node_Str"");
  iConomyLand.cmdMap.put(playerName,""String_Node_Str"");
  return true;
}",0.9108061749571184
40045,"@Override public void onPlayerMove(PlayerMoveEvent event){
  Player player=event.getPlayer();
  if (!checkNow(player))   return;
  String playerName=player.getName();
  if (iConomyLand.debugMode)   iConomyLand.info(""String_Node_Str"" + playerName);
  if (!locMap.containsKey(playerName))   locMap.put(playerName,iConomyLand.landMgr.getLandID(player.getLocation()));
  int locFrom=locMap.get(playerName);
  int locTo=iConomyLand.landMgr.getLandID(player.getLocation());
  locMap.put(playerName,locTo);
  if (locFrom != locTo) {
    if (locFrom != 0) {
      player.sendMessage(""String_Node_Str"");
    }
    if (locTo != 0) {
      player.sendMessage(""String_Node_Str"");
    }
  }
}","@Override public void onPlayerMove(PlayerMoveEvent event){
  Player player=event.getPlayer();
  if (!checkNow(player))   return;
  String playerName=player.getName();
  if (!locMap.containsKey(playerName))   locMap.put(playerName,iConomyLand.landMgr.getLandID(player.getLocation()));
  int locFrom=locMap.get(playerName);
  int locTo=iConomyLand.landMgr.getLandID(player.getLocation());
  locMap.put(playerName,locTo);
  if (locFrom != locTo) {
    if (locFrom != 0) {
      player.sendMessage(""String_Node_Str"");
    }
    if (locTo != 0) {
      player.sendMessage(""String_Node_Str"");
    }
  }
}",0.4400939702427565
40046,"private static void gameLoop(){
  Log.info(""String_Node_Str"",""String_Node_Str"");
  long lastTime=System.nanoTime();
  while (true) {
    long currentTime=System.nanoTime();
    game.update((currentTime - lastTime) * 1.0e-9);
    try {
      GameCanvas.startDrawing(game.getMap().getSizeX(),game.getMap().getSizeY());
      game.render();
    }
  finally {
      GameCanvas.stopDrawing();
    }
    long millisToNextUpdate=Math.max(0,(1000 / 60) - ((System.nanoTime() - currentTime) / 1000000));
    lastTime=currentTime;
    try {
      Thread.sleep(millisToNextUpdate);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
}","private static void gameLoop(){
  Log.info(""String_Node_Str"",""String_Node_Str"");
  long lastTime=System.nanoTime();
  while (true) {
    boolean loadedMap=false;
    long currentTime=System.nanoTime();
    try {
      game.update((currentTime - lastTime) * 1.0e-9);
    }
 catch (    mapLoadedException e) {
      loadedMap=true;
      ui.dispose();
      ui=new RavenUI(game);
    }
    try {
      GameCanvas.startDrawing(game.getMap().getSizeX(),game.getMap().getSizeY(),loadedMap);
      loadedMap=false;
      game.render();
    }
  finally {
      GameCanvas.stopDrawing();
    }
    long millisToNextUpdate=Math.max(0,(1000 / 60) - ((System.nanoTime() - currentTime) / 1000000));
    lastTime=currentTime;
    try {
      Thread.sleep(millisToNextUpdate);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
}",0.8680272108843538
40047,"/** 
 * Update the game state over the given timestep in seconds.
 * @param delta amount of time to advance in seconds
 */
public void update(double delta){
  Log.trace(""String_Node_Str"",""String_Node_Str"");
  if (newMapPath != null) {
    try {
      loadMap(newMapPath);
    }
 catch (    IOException e) {
      Log.warn(""String_Node_Str"",""String_Node_Str"" + newMapPath + ""String_Node_Str"");
    }
  }
  while (botsToAdd != 0) {
    if (botsToAdd < 0) {
      removeBot();
      botsToAdd++;
    }
 else {
      addBots(botsToAdd);
      botsToAdd=0;
    }
  }
  if (paused) {
    return;
  }
  graveMarkers.update(delta);
  getPlayerInput(delta);
  pathManager.updateSearches();
  for (  RavenDoor door : map.getDoors()) {
    door.update(delta);
  }
  HashSet<RavenProjectile> toRemove=new HashSet<RavenProjectile>();
  for (  RavenProjectile projectile : projectiles) {
    if (projectile.IsDead()) {
      toRemove.add(projectile);
    }
 else {
      projectile.update(delta);
    }
  }
  projectiles.removeAll(toRemove);
  boolean spawnPossible=true;
  for (  RavenBot bot : bots) {
    if (bot.isSpawning() && spawnPossible) {
      spawnPossible=attemptToAddBot(bot);
    }
 else     if (bot.isDead()) {
      graveMarkers.addGrave(bot.pos());
      bot.setSpawning();
    }
 else     if (bot.isAlive()) {
      bot.update(delta);
    }
  }
  map.updateTriggerSystem(delta,bots);
  if (removeBot) {
    Log.info(""String_Node_Str"",""String_Node_Str"");
    if (!bots.isEmpty()) {
      RavenBot bot=bots.get(bots.size() - 1);
      if (bot.equals(selectedBot)) {
        selectedBot=null;
      }
      notifyAllBotsOfRemoval(bot);
      bots.remove(bot);
    }
    removeBot=false;
  }
}","/** 
 * Update the game state over the given timestep in seconds.
 * @param delta amount of time to advance in seconds
 * @throws mapLoadedException 
 */
public void update(double delta) throws mapLoadedException {
  Log.trace(""String_Node_Str"",""String_Node_Str"");
  if (newMapPath != null) {
    try {
      loadMap(newMapPath);
      throw new mapLoadedException();
    }
 catch (    IOException e) {
      Log.warn(""String_Node_Str"",""String_Node_Str"" + newMapPath + ""String_Node_Str"");
    }
  }
  while (botsToAdd != 0) {
    if (botsToAdd < 0) {
      removeBot();
      botsToAdd++;
    }
 else {
      addBots(botsToAdd);
      botsToAdd=0;
    }
  }
  if (paused) {
    return;
  }
  graveMarkers.update(delta);
  getPlayerInput(delta);
  pathManager.updateSearches();
  for (  RavenDoor door : map.getDoors()) {
    door.update(delta);
  }
  HashSet<RavenProjectile> toRemove=new HashSet<RavenProjectile>();
  for (  RavenProjectile projectile : projectiles) {
    if (projectile.IsDead()) {
      toRemove.add(projectile);
    }
 else {
      projectile.update(delta);
    }
  }
  projectiles.removeAll(toRemove);
  boolean spawnPossible=true;
  for (  RavenBot bot : bots) {
    if (bot.isSpawning() && spawnPossible) {
      spawnPossible=attemptToAddBot(bot);
    }
 else     if (bot.isDead()) {
      graveMarkers.addGrave(bot.pos());
      bot.setSpawning();
    }
 else     if (bot.isAlive()) {
      bot.update(delta);
    }
  }
  map.updateTriggerSystem(delta,bots);
  if (removeBot) {
    Log.info(""String_Node_Str"",""String_Node_Str"");
    if (!bots.isEmpty()) {
      RavenBot bot=bots.get(bots.size() - 1);
      if (bot.equals(selectedBot)) {
        selectedBot=null;
      }
      notifyAllBotsOfRemoval(bot);
      bots.remove(bot);
    }
    removeBot=false;
  }
}",0.9724454649827784
40048,"protected void create(int width,int height){
  setIgnoreRepaint(true);
  setFocusable(true);
  requestFocus();
  if (getBufferStrategy() == null) {
    createBufferStrategy(2);
    setBounds(0,0,width,height);
  }
  if (g2d != null) {
    g2d.dispose();
    System.err.println(""String_Node_Str"");
  }
  g2d=(Graphics2D)getBufferStrategy().getDrawGraphics();
  RenderingHints renderHints=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  renderHints.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
  g2d.setRenderingHints(renderHints);
  g2d.setColor(Color.WHITE);
  g2d.fillRect(0,0,getWidth(),getHeight());
}","protected void create(int width,int height,boolean loadedMap){
  setIgnoreRepaint(true);
  setFocusable(true);
  requestFocus();
  if (getBufferStrategy() == null || loadedMap == true) {
    createBufferStrategy(2);
    setBounds(0,0,width,height);
  }
  if (g2d != null) {
    g2d.dispose();
    System.err.println(""String_Node_Str"");
  }
  g2d=(Graphics2D)getBufferStrategy().getDrawGraphics();
  RenderingHints renderHints=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  renderHints.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
  g2d.setRenderingHints(renderHints);
  g2d.setColor(Color.WHITE);
  g2d.fillRect(0,0,getWidth(),getHeight());
}",0.9717595944967417
40049,"public static void startDrawing(int width,int height){
  getInstance().create(width,height);
}","public static void startDrawing(int width,int height,boolean loadedMap){
  getInstance().create(width,height,loadedMap);
}",0.8703703703703703
40050,"private static void discharge(BaseGameEntity receiver,Telegram msg){
  if (!receiver.handleMessage(msg)) {
    Log.error(""String_Node_Str"",""String_Node_Str"");
  }
}","private static void discharge(IRavenBot receiver,Telegram msg){
  if (!receiver.handleMessage(msg)) {
    Log.error(""String_Node_Str"",""String_Node_Str"");
  }
}",0.9411764705882352
40051,"/** 
 * send a message to another agent. Receiving agent is referenced by ID.
 * @param delay Delay in seconds until the message should be sent
 * @param senderID the ID of the sender
 * @param receiverID the ID of the sender 
 * @param msg the type of the message to send
 * @param extraInfo optional object to attach to the message
 */
public static void dispatchMsg(double delay,int senderID,int receiverID,RavenMessage msg,Object extraInfo){
  BaseGameEntity receiver=EntityManager.getEntityFromID(receiverID);
  if (receiver == null) {
    System.err.println(""String_Node_Str"" + receiverID + ""String_Node_Str"");
    return;
  }
  Telegram telegram=new Telegram(0,senderID,receiverID,msg,extraInfo);
  if (delay <= 0.0) {
    discharge(receiver,telegram);
  }
 else {
    telegram.dispatchDelay=delay;
    getInstance().priorityQueue.add(telegram);
  }
}","/** 
 * send a message to another agent. Receiving agent is referenced by ID.
 * @param delay Delay in seconds until the message should be sent
 * @param senderID the ID of the sender
 * @param receiverID the ID of the sender 
 * @param msg the type of the message to send
 * @param extraInfo optional object to attach to the message
 */
public static void dispatchMsg(double delay,int senderID,int receiverID,RavenMessage msg,Object extraInfo){
  BaseGameEntity receiver=EntityManager.getEntityFromID(receiverID);
  IRavenBot bot=null;
  if (receiver == null) {
    bot=EntityManager.getBotFromID(receiverID);
  }
  if (bot == null)   System.err.println(""String_Node_Str"" + receiverID + ""String_Node_Str"");
  Telegram telegram=new Telegram(0,senderID,receiverID,msg,extraInfo);
  if (delay <= 0.0) {
    if (receiver != null)     discharge(receiver,telegram);
 else     discharge(bot,telegram);
  }
 else {
    telegram.dispatchDelay=delay;
    getInstance().priorityQueue.add(telegram);
  }
}",0.8725701943844493
40052,"protected BaseGameEntity(int id,RavenObject type){
  setID(id);
  this.type=type;
}","protected BaseGameEntity(int id,RavenObject type){
  LogManager.GetInstance().Info(""String_Node_Str"" + type + ""String_Node_Str""+ id);
  setID(id);
  this.type=type;
}",0.6666666666666666
40053,"public static void reset(){
  getInstance().entityMap.clear();
}","public static void reset(){
  LogManager.GetInstance().Info(""String_Node_Str"");
  getInstance().entityMap.clear();
}",0.7111111111111111
40054,"public static void registerEntity(BaseGameEntity entity){
  getInstance().entityMap.put(entity.ID(),entity);
}","public static void registerEntity(BaseGameEntity entity){
  LogManager.GetInstance().Info(""String_Node_Str"" + entity.entityType() + ""String_Node_Str""+ entity.ID());
  getInstance().entityMap.put(entity.ID(),entity);
}",0.672782874617737
40055,"public static void removeEntity(BaseGameEntity entity){
  getInstance().entityMap.remove(entity);
}","public static void removeEntity(BaseGameEntity entity){
  getInstance().entityMap.remove(entity);
  LogManager.GetInstance().Info(""String_Node_Str"" + entity.entityType() + ""String_Node_Str""+ entity.ID());
}",0.6491803278688525
40056,"public static int getAvailableID(){
  return 0;
}","public static synchronized int getAvailableID(){
  int toReturn=availableID;
  availableID++;
  return toReturn;
}",0.588957055214724
40057,"private boolean attemptToAddBot(RavenBot bot){
  LogManager.GetInstance().Info(""String_Node_Str"" + bot.ID());
  if (map.getSpawnPoints().size() <= 0) {
    LogManager.GetInstance().Error(""String_Node_Str"");
    return false;
  }
  int attempts=map.getSpawnPoints().size();
  while (--attempts >= 0) {
    Vector2D pos=map.getRandomSpawnPoint();
    boolean available=true;
    for (    RavenBot other : bots) {
      if (pos.distance(other.pos()) < other.getBRadius()) {
        available=false;
      }
    }
    if (available) {
      LogManager.GetInstance().Info(""String_Node_Str"" + bot.ID() + ""String_Node_Str""+ pos);
      bot.spawn(pos);
      return true;
    }
  }
  return false;
}","private boolean attemptToAddBot(RavenBot bot){
  LogManager.GetInstance().Info(""String_Node_Str"" + bot.ID());
  if (map.getSpawnPoints().size() <= 0) {
    LogManager.GetInstance().Error(""String_Node_Str"");
    return false;
  }
  int attempts=map.getSpawnPoints().size();
  while (--attempts >= 0) {
    Vector2D pos=map.getRandomSpawnPoint();
    boolean available=true;
    for (    RavenBot other : bots) {
      if (pos.distance(other.pos()) < other.getBRadius()) {
        available=false;
      }
    }
    if (available) {
      LogManager.GetInstance().Info(""String_Node_Str"" + bot.ID() + ""String_Node_Str""+ pos);
      bot.spawn(pos);
      int nodeID=bot.getPathPlanner().getClosestNodeToPosition(bot.pos());
      Vector2D posNode=bot.getPathPlanner().getNodePosition(nodeID);
      if (posNode == null)       return true;
      bot.getPathPlanner().RequestPathToPosition(posNode);
      return true;
    }
  }
  return false;
}",0.8375229920294298
40058,"public void addBots(int numBotsToAdd){
  LogManager.GetInstance().Info(""String_Node_Str"" + numBotsToAdd + ""String_Node_Str"");
  while (--numBotsToAdd > 0) {
    RavenBot bot=new RavenBot(this,new Vector2D());
    bot.getSteering().wallAvoidanceOn();
    bot.getSteering().separationOn();
    bots.add(bot);
    LogManager.GetInstance().Info(""String_Node_Str"" + bot.ID() + ""String_Node_Str"");
    EntityManager.registerEntity(bot);
  }
}","public void addBots(int numBotsToAdd){
  LogManager.GetInstance().Info(""String_Node_Str"" + numBotsToAdd + ""String_Node_Str"");
  while (--numBotsToAdd > 0) {
    RavenBot bot=new RavenBot(this,new Vector2D());
    bot.getSteering().wallAvoidanceOn();
    bot.getSteering().separationOn();
    bots.add(bot);
    LogManager.GetInstance().Info(""String_Node_Str"" + bot.ID() + ""String_Node_Str"");
    EntityManager.registerEntity(bot);
    bot.getBrain().addGoal_explore();
    bot.getBrain().activate();
  }
}",0.926673751328374
40059,"public Vector2D getNodePosition(int idx){
  return graph.getNode(idx).pos();
}","public Vector2D getNodePosition(int idx){
  GraphNode node=graph.getNode(idx);
  if (node != null) {
    return node.pos();
  }
 else   return null;
}",0.6491228070175439
40060,"public boolean requestPathToItem(int ItemType){
  GetReadyForNewSearch();
  int ClosestNodeToBot=getClosestNodeToPosition(ravenBot.pos());
  if (ClosestNodeToBot == 0) {
    return false;
  }
  TriggerSystem<Trigger<RavenBot>> t_con;
  GraphSearchDijkstra DijSearch;
  currentSearch=new GraphSearchDijkstra(graph,ClosestNodeToBot,ItemType);
  ravenBot.getWorld().getPathManager().Register(this);
  return true;
}","public boolean requestPathToItem(int ItemType){
  GetReadyForNewSearch();
  int ClosestNodeToBot=getClosestNodeToPosition(ravenBot.pos());
  if (ClosestNodeToBot == 0) {
    return false;
  }
  currentSearch=new GraphSearchDijkstra(graph,ClosestNodeToBot,ItemType);
  ravenBot.getWorld().getPathManager().Register(this);
  return true;
}",0.8571428571428571
40061,"public RavenPathPlanner(RavenBot ravenBot){
  this.ravenBot=ravenBot;
}","public RavenPathPlanner(RavenBot ravenBot){
  this.ravenBot=ravenBot;
  path=new ArrayList<PathEdge>();
}",0.8068181818181818
40062,"public GoalComposite(T PE,raven.goals.Goal.GoalType type){
  super(PE,type);
}","public GoalComposite(T PE,raven.goals.Goal.GoalType type){
  super(PE,type);
  m_SubGoals=new ArrayList<Goal<T>>();
}",0.8
40063,"public raven.goals.Goal.CurrentStatus ProcessSubgoals(){
  while (!m_SubGoals.isEmpty() && (m_SubGoals.get(0).isComplete() || m_SubGoals.get(0).hasFailed())) {
    m_SubGoals.get(0).Terminate();
    m_SubGoals.remove(0);
  }
  if (!m_SubGoals.isEmpty()) {
    raven.goals.Goal.CurrentStatus StatusOfSubGoals=m_SubGoals.get(0).Process();
    if (StatusOfSubGoals == Goal.CurrentStatus.completed && m_SubGoals.size() > 1) {
      return Goal.CurrentStatus.active;
    }
    return StatusOfSubGoals;
  }
 else {
    return Goal.CurrentStatus.completed;
  }
}","public CurrentStatus ProcessSubgoals(){
  while (!m_SubGoals.isEmpty() && (m_SubGoals.get(0).isComplete() || m_SubGoals.get(0).hasFailed())) {
    m_SubGoals.get(0).Terminate();
    m_SubGoals.remove(0);
  }
  if (!m_SubGoals.isEmpty()) {
    raven.goals.Goal.CurrentStatus StatusOfSubGoals=m_SubGoals.get(0).Process();
    if (StatusOfSubGoals == Goal.CurrentStatus.completed && m_SubGoals.size() > 1) {
      return Goal.CurrentStatus.active;
    }
    return StatusOfSubGoals;
  }
 else {
    return Goal.CurrentStatus.completed;
  }
}",0.9844464775846294
40064,"protected void addDrawingPoint(Vector2D point){
  if (drawingPoints == null)   drawingPoints=new ArrayList<Vector2D>();
  drawingPoints.add(point);
  delegate.updateStatus(""String_Node_Str"" + point.x + ""String_Node_Str""+ point.y+ ""String_Node_Str"");
  if (isSnapped)   commitDrawing();
}","protected void addDrawingPoint(Vector2D point){
  if (drawingPoints == null)   drawingPoints=new ArrayList<Vector2D>();
  drawingPoints.add(point);
  delegate.updateStatus(""String_Node_Str"" + point.x + ""String_Node_Str""+ point.y+ ""String_Node_Str"");
  if (isSnapped && drawingPoints.size() > 1)   commitDrawing();
}",0.9534883720930232
40065,"protected void commitDrawing(){
  isDrawing=false;
  if (drawingPoints == null)   return;
  delegate.addWalls(drawingPoints.toArray(new Vector2D[drawingPoints.size()]));
  delegate.updateStatus(""String_Node_Str"" + (drawingPoints.size() - 1) + ""String_Node_Str"");
  drawingPoints=null;
  updateCursorSnap();
}","protected void commitDrawing(){
  isDrawing=false;
  isSnapped=false;
  if (drawingPoints == null)   return;
  delegate.addWalls(drawingPoints.toArray(new Vector2D[drawingPoints.size()]));
  delegate.updateStatus(""String_Node_Str"" + (drawingPoints.size() - 1) + ""String_Node_Str"");
  drawingPoints=null;
  updateCursorSnap();
  viewport.repaint();
}",0.9375951293759512
40066,"@Override public void paintComponent(Graphics g){
  Graphics2D g2d=(Graphics2D)g;
  Line2D line;
  g2d.setColor(Color.LIGHT_GRAY);
  if (isDrawing) {
    for (int i=0; i < drawingPoints.size() - 1; i++) {
      line=new Line2D.Float(levelToView(drawingPoints.get(i)),levelToView(drawingPoints.get(i + 1)));
      g2d.draw(line);
    }
    line=new Line2D.Float(levelToView(drawingPoints.get(drawingPoints.size() - 1)),levelToView(levelCursor));
    g2d.draw(line);
  }
  if (isSnapped) {
    Ellipse2D highlight=new Ellipse2D.Double(levelToView(levelCursor).getX() - snapDistance / 2,levelToView(levelCursor).getY() - snapDistance / 2,snapDistance,snapDistance);
    g2d.setColor(Color.YELLOW);
    g2d.draw(highlight);
  }
  if (levelCursor != null) {
    FontMetrics fm=g2d.getFontMetrics(font);
    String coordString=new String(""String_Node_Str"" + levelCursor.x + ""String_Node_Str""+ levelCursor.y+ ""String_Node_Str"");
    int width=fm.stringWidth(coordString);
    g2d.setFont(font);
    g2d.setColor(Color.BLACK);
    g2d.drawString(coordString,0,10);
  }
}","@Override public void paintComponent(Graphics g){
  Graphics2D g2d=(Graphics2D)g;
  Line2D line;
  g2d.setColor(Color.LIGHT_GRAY);
  if (isDrawing) {
    for (int i=0; i < drawingPoints.size() - 1; i++) {
      line=new Line2D.Float(levelToView(drawingPoints.get(i)),levelToView(drawingPoints.get(i + 1)));
      g2d.draw(line);
    }
    line=new Line2D.Float(levelToView(drawingPoints.get(drawingPoints.size() - 1)),levelToView(levelCursor));
    g2d.draw(line);
  }
  if (levelCursor != null) {
    Ellipse2D highlight=new Ellipse2D.Double(levelToView(levelCursor).getX() - snapDistance,levelToView(levelCursor).getY() - snapDistance,2 * snapDistance,2 * snapDistance);
    g2d.setColor(Color.ORANGE);
    g2d.draw(highlight);
  }
  if (levelCursor != null) {
    FontMetrics fm=g2d.getFontMetrics(font);
    String coordString=new String(""String_Node_Str"" + levelCursor.x + ""String_Node_Str""+ levelCursor.y+ ""String_Node_Str"");
    int width=fm.stringWidth(coordString);
    g2d.setFont(font);
    g2d.setColor(Color.BLACK);
    g2d.drawString(coordString,0,10);
  }
}",0.9390815370196812
40067,"@Override public void mouseMoved(MouseEvent e){
  if (isDrawing) {
    mouseLocation=e.getPoint();
    levelCursor=viewToLevel(mouseLocation);
  }
  updateCursorSnap();
  viewport.repaint();
  e.consume();
}","@Override public void mouseMoved(MouseEvent e){
  mouseLocation=e.getPoint();
  levelCursor=viewToLevel(mouseLocation);
  updateCursorSnap();
  viewport.repaint();
  e.consume();
}",0.9302325581395348
40068,"protected void updateCursorSnap(){
  if (levelCursor == null) {
    isSnapped=false;
    return;
  }
  Vector2D nearestPoint=null;
  double closestSq=Double.MAX_VALUE;
  for (  Wall2D wall : level.getWalls()) {
    double dist=wall.from().distanceSq(levelCursor);
    if (dist < closestSq && dist < snapDistance) {
      nearestPoint=wall.from();
      closestSq=dist;
    }
    dist=wall.to().distanceSq(levelCursor);
    if (dist < closestSq && dist < snapDistance) {
      nearestPoint=wall.to();
      closestSq=dist;
    }
  }
  if (isDrawing && drawingPoints.size() > 2 && levelToView(levelCursor).distance(levelToView(drawingPoints.get(0))) < snapDistance) {
    nearestPoint=drawingPoints.get(0);
  }
  if (nearestPoint != null) {
    isSnapped=true;
    levelCursor=nearestPoint;
  }
 else {
    isSnapped=false;
  }
}","protected void updateCursorSnap(){
  if (levelCursor == null) {
    isSnapped=false;
    return;
  }
  Vector2D nearestPoint=null;
  double closestSq=Double.MAX_VALUE;
  for (  Wall2D wall : level.getWalls()) {
    double dist=wall.from().distanceSq(levelCursor);
    if (dist < closestSq && dist < snapDistance * snapDistance) {
      nearestPoint=wall.from();
      closestSq=dist;
    }
    dist=wall.to().distanceSq(levelCursor);
    if (dist < closestSq && dist < snapDistance * snapDistance) {
      nearestPoint=wall.to();
      closestSq=dist;
    }
  }
  if (isDrawing && drawingPoints.size() > 2 && levelToView(levelCursor).distance(levelToView(drawingPoints.get(0))) < snapDistance) {
    nearestPoint=drawingPoints.get(0);
  }
  if (nearestPoint != null) {
    isSnapped=true;
    levelCursor=nearestPoint;
  }
 else {
    isSnapped=false;
  }
}",0.982185273159145
40069,"protected void calculateNormal(){
  Vector2D temp=vB.sub(vA);
  temp.normalize();
  vN.x=-temp.x;
  vN.y=temp.y;
}","protected void calculateNormal(){
  Vector2D temp=vB.sub(vA);
  temp.normalize();
  vN=new Vector2D(-temp.x,temp.y);
}",0.8879310344827587
40070,"public void RequestPathToPosition(Vector2D m_CurrentDestination){
}","public boolean RequestPathToPosition(Vector2D m_CurrentDestination){
  return false;
}",0.8366013071895425
40071,"public void activateIfInactive(){
  if (isInactive()) {
    Activate();
  }
}","public void activateIfInactive(){
  if (isInactive()) {
    activate();
  }
}",0.987012987012987
40072,abstract public void renderAtPos(Vector2D p);,"public void renderAtPos(Vector2D pos,String tts){
  renderAtPos(pos,tts);
  pos.x+=10;
  GameCanvas.transparentText();
  for (int it=0; it < m_SubGoals.size() - 1; it++) {
    m_SubGoals.get(it).renderAtPos(pos,tts);
  }
  pos.x-=10;
}",0.2428571428571428
40073,abstract public void render();,"public void render(){
  if (!m_SubGoals.isEmpty()) {
    m_SubGoals.get(0).render();
  }
}",0.35
40074,"public void activateIfInactive(){
  if (isInactive()) {
    Activate();
  }
}","public void activateIfInactive(){
  if (isInactive()) {
    activate();
  }
}",0.987012987012987
40075,"public raven.goals.Goal.curStatus process(){
  activateIfInactive();
  m_iStatus=ProcessSubgoals();
  if (m_iStatus == Goal.curStatus.completed && !m_Path.isEmpty()) {
    Activate();
  }
  return m_iStatus;
}","public raven.goals.Goal.curStatus process(){
  activateIfInactive();
  m_iStatus=ProcessSubgoals();
  if (m_iStatus == Goal.curStatus.completed && !m_Path.isEmpty()) {
    activate();
  }
  return m_iStatus;
}",0.9952153110047848
40076,"void activate(){
  m_iStatus=Goal.curStatus.active;
  GraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.behavior()) {
case normal:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case GraphEdge.goesThroughDoor:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case GraphEdge.jump:
{
}
break;
case GraphEdge.grapple:
{
}
break;
default :
throw new Exception(""String_Node_Str"");
}
}","public void activate(){
  m_iStatus=Goal.curStatus.active;
  GraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.behavior()) {
case normal:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case GraphEdge.goesThroughDoor:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case GraphEdge.jump:
{
}
break;
case GraphEdge.grapple:
{
}
break;
default :
throw new Exception(""String_Node_Str"");
}
}",0.9927159209157128
40077,"void activate(){
  m_iStatus=Goal.curStatus.active;
  removeAllSubgoals();
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    Vector2D lrp=getM_pOwner().getTargetSys().getLastRecordedPosition();
    if (lrp.isZero() || getM_pOwner().isAtPosition(lrp)) {
      AddSubgoal(new Goal_Explore(getM_pOwner()));
    }
 else {
      AddSubgoal(new Goal_MoveToPosition(getM_pOwner(),lrp));
    }
  }
 else {
    m_iStatus=Goal.curStatus.completed;
  }
}","public void activate(){
  m_iStatus=Goal.curStatus.active;
  removeAllSubgoals();
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    Vector2D lrp=getM_pOwner().getTargetSys().getLastRecordedPosition();
    if (lrp.isZero() || getM_pOwner().isAtPosition(lrp)) {
      AddSubgoal(new Goal_Explore(getM_pOwner()));
    }
 else {
      AddSubgoal(new Goal_MoveToPosition(getM_pOwner(),lrp));
    }
  }
 else {
    m_iStatus=Goal.curStatus.completed;
  }
}",0.9923329682365828
40078,"@Override public void render(){
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    GameCanvas.greenBrush();
    GameCanvas.redBrush();
    GameCanvas.circle(getM_pOwner().getTargetSys().getLastRecordedPosition(),3);
  }
}","@Override public void render(){
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    GameCanvas.greenBrush();
    GameCanvas.redBrush();
    GameCanvas.circle(getM_pOwner().getTargetSys().getLastRecordedPosition(),3);
  }
  if (!m_SubGoals.isEmpty()) {
    m_SubGoals.get(0).render();
  }
}",0.872865275142315
40079,"public void activate(){
  m_iStatus=Goal.curStatus.active;
  GraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.behavior()) {
case normal:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case GraphEdge.goesThroughDoor:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case GraphEdge.jump:
{
}
break;
case GraphEdge.grapple:
{
}
break;
default :
throw new Exception(""String_Node_Str"");
}
}","public void activate(){
  m_iStatus=Goal.curStatus.active;
  NavGraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.flags()) {
case NavGraphEdge.NORMAL:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case NavGraphEdge.GOES_THROUGH_DOOR:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case NavGraphEdge.JUMP:
{
}
break;
case NavGraphEdge.GRAPPLE:
{
}
break;
default :
try {
throw new Exception(""String_Node_Str"");
}
 catch (Exception e) {
e.printStackTrace();
}
}
}",0.7724665391969407
40080,"boolean isStuck(){
  double TimeTaken=Clock.GetCurrentTime() - m_dStartTime;
  if (TimeTaken > m_dTimeToReachPos) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}","boolean isStuck(){
  double TimeTaken=System.nanoTime() * 1000 - m_dStartTime;
  if (TimeTaken > m_dTimeToReachPos) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}",0.9037656903765692
40081,"@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
  m_dStartTime=Clock.GetCurrentTime();
  m_dTimeToReachPos=getM_pOwner().calculateTimeToReachPosition(m_vPosition);
  double MarginOfError=1.0;
  m_dTimeToReachPos+=MarginOfError;
  getM_pOwner().getSteering().SetTarget(m_vPosition);
  getM_pOwner().getSteering().SeekOn();
}","@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
  m_dStartTime=System.nanoTime() * 1000;
  m_dTimeToReachPos=getM_pOwner().calculateTimeToReachPosition(m_vPosition);
  double MarginOfError=1.0;
  m_dTimeToReachPos+=MarginOfError;
  getM_pOwner().getSteering().SetTarget(m_vPosition);
  getM_pOwner().getSteering().SeekOn();
}",0.9333333333333332
40082,"boolean isStuck(){
  double TimeTaken=Clock.GetCurrentTime() - m_dStartTime;
  if (TimeTaken > m_dTimeExpected) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}","boolean isStuck(){
  double TimeTaken=System.nanoTime() * 1000 - m_dStartTime;
  if (TimeTaken > m_dTimeExpected) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}",0.9029535864978904
40083,"public Goal_TraverseEdge(RavenBot ravenBot,GraphEdge edge,boolean lastedgeinpath){
  super(ravenBot,Goal.goalType.goal_traverse_edge);
  m_Edge=edge;
  m_dTimeExpected=0.0;
  m_bLastEdgeInPath=lastedgeinpath;
}","public Goal_TraverseEdge(RavenBot ravenBot,NavGraphEdge edge,boolean lastedgeinpath){
  super(ravenBot,Goal.goalType.goal_traverse_edge);
  m_Edge=edge;
  m_dTimeExpected=0.0;
  m_bLastEdgeInPath=lastedgeinpath;
}",0.9929078014184396
40084,"@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
switch (m_Edge.behavior()) {
case swim:
{
      getM_pOwner().SetMaxSpeed(script.GetDouble(""String_Node_Str""));
    }
  break;
case crawl:
{
  getM_pOwner().SetMaxSpeed(script.GetDouble(""String_Node_Str""));
}
break;
}
m_dStartTime=Clock.GetCurrentTime();
m_dTimeExpected=getM_pOwner().calculateTimeToReachPosition(m_Edge.destination());
double MarginOfError=2.0;
m_dTimeExpected+=MarginOfError;
getM_pOwner().getSteering().SetTarget(m_Edge.destination());
if (m_bLastEdgeInPath) {
getM_pOwner().getSteering().ArriveOn();
}
 else {
getM_pOwner().getSteering().SeekOn();
}
}","@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
switch (m_Edge.flags()) {
case NavGraphEdge.SWIM:
{
      getM_pOwner().setMaxSpeed(RavenScript.getDouble(""String_Node_Str""));
    }
  break;
case NavGraphEdge.CRAWL:
{
  getM_pOwner().setMaxSpeed(RavenScript.getDouble(""String_Node_Str""));
}
break;
}
m_dStartTime=System.nanoTime() * 1000;
m_dTimeExpected=getM_pOwner().calculateTimeToReachPosition(m_Edge.destination());
double MarginOfError=2.0;
m_dTimeExpected+=MarginOfError;
getM_pOwner().getSteering().SetTarget(m_Edge.destination());
if (m_bLastEdgeInPath) {
getM_pOwner().getSteering().ArriveOn();
}
 else {
getM_pOwner().getSteering().SeekOn();
}
}",0.7274107820804859
40085,"public void terminate(){
  getM_pOwner().getSteering().SeekOff();
  getM_pOwner().getSteering().ArriveOff();
  getM_pOwner().SetMaxSpeed(script.GetDouble(""String_Node_Str""));
}","public void terminate(){
  getM_pOwner().getSteering().SeekOff();
  getM_pOwner().getSteering().ArriveOff();
  getM_pOwner().setMaxSpeed(RavenScript.getDouble(""String_Node_Str""));
}",0.969187675070028
40086,"public void RequestPathToPosition(Vector2D m_CurrentDestination){
}","public boolean RequestPathToPosition(Vector2D m_CurrentDestination){
  return false;
}",0.8366013071895425
40087,"public void activateIfInactive(){
  if (isInactive()) {
    Activate();
  }
}","public void activateIfInactive(){
  if (isInactive()) {
    activate();
  }
}",0.987012987012987
40088,abstract public void renderAtPos(Vector2D p);,"public void renderAtPos(Vector2D pos,String tts){
  renderAtPos(pos,tts);
  pos.x+=10;
  GameCanvas.transparentText();
  for (int it=0; it < m_SubGoals.size() - 1; it++) {
    m_SubGoals.get(it).renderAtPos(pos,tts);
  }
  pos.x-=10;
}",0.2428571428571428
40089,abstract public void render();,"public void render(){
  if (!m_SubGoals.isEmpty()) {
    m_SubGoals.get(0).render();
  }
}",0.35
40090,"public void activateIfInactive(){
  if (isInactive()) {
    Activate();
  }
}","public void activateIfInactive(){
  if (isInactive()) {
    activate();
  }
}",0.987012987012987
40091,"public raven.goals.Goal.curStatus process(){
  activateIfInactive();
  m_iStatus=ProcessSubgoals();
  if (m_iStatus == Goal.curStatus.completed && !m_Path.isEmpty()) {
    Activate();
  }
  return m_iStatus;
}","public raven.goals.Goal.curStatus process(){
  activateIfInactive();
  m_iStatus=ProcessSubgoals();
  if (m_iStatus == Goal.curStatus.completed && !m_Path.isEmpty()) {
    activate();
  }
  return m_iStatus;
}",0.9952153110047848
40092,"void activate(){
  m_iStatus=Goal.curStatus.active;
  GraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.behavior()) {
case normal:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case GraphEdge.goesThroughDoor:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case GraphEdge.jump:
{
}
break;
case GraphEdge.grapple:
{
}
break;
default :
throw new Exception(""String_Node_Str"");
}
}","public void activate(){
  m_iStatus=Goal.curStatus.active;
  GraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.behavior()) {
case normal:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case GraphEdge.goesThroughDoor:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case GraphEdge.jump:
{
}
break;
case GraphEdge.grapple:
{
}
break;
default :
throw new Exception(""String_Node_Str"");
}
}",0.9927159209157128
40093,"void activate(){
  m_iStatus=Goal.curStatus.active;
  removeAllSubgoals();
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    Vector2D lrp=getM_pOwner().getTargetSys().getLastRecordedPosition();
    if (lrp.isZero() || getM_pOwner().isAtPosition(lrp)) {
      AddSubgoal(new Goal_Explore(getM_pOwner()));
    }
 else {
      AddSubgoal(new Goal_MoveToPosition(getM_pOwner(),lrp));
    }
  }
 else {
    m_iStatus=Goal.curStatus.completed;
  }
}","public void activate(){
  m_iStatus=Goal.curStatus.active;
  removeAllSubgoals();
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    Vector2D lrp=getM_pOwner().getTargetSys().getLastRecordedPosition();
    if (lrp.isZero() || getM_pOwner().isAtPosition(lrp)) {
      AddSubgoal(new Goal_Explore(getM_pOwner()));
    }
 else {
      AddSubgoal(new Goal_MoveToPosition(getM_pOwner(),lrp));
    }
  }
 else {
    m_iStatus=Goal.curStatus.completed;
  }
}",0.9923329682365828
40094,"@Override public void render(){
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    GameCanvas.greenBrush();
    GameCanvas.redBrush();
    GameCanvas.circle(getM_pOwner().getTargetSys().getLastRecordedPosition(),3);
  }
}","@Override public void render(){
  if (getM_pOwner().getTargetSys().isTargetPresent()) {
    GameCanvas.greenBrush();
    GameCanvas.redBrush();
    GameCanvas.circle(getM_pOwner().getTargetSys().getLastRecordedPosition(),3);
  }
  if (!m_SubGoals.isEmpty()) {
    m_SubGoals.get(0).render();
  }
}",0.872865275142315
40095,"public void activate(){
  m_iStatus=Goal.curStatus.active;
  GraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.behavior()) {
case normal:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case GraphEdge.goesThroughDoor:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case GraphEdge.jump:
{
}
break;
case GraphEdge.grapple:
{
}
break;
default :
throw new Exception(""String_Node_Str"");
}
}","public void activate(){
  m_iStatus=Goal.curStatus.active;
  NavGraphEdge edge=m_Path.get(0);
  m_Path.remove(0);
switch (edge.flags()) {
case NavGraphEdge.NORMAL:
{
      AddSubgoal(new Goal_TraverseEdge(getM_pOwner(),edge,m_Path.isEmpty()));
    }
  break;
case NavGraphEdge.GOES_THROUGH_DOOR:
{
  AddSubgoal(new Goal_NegotiateDoor(getM_pOwner(),edge,m_Path.isEmpty()));
}
break;
case NavGraphEdge.JUMP:
{
}
break;
case NavGraphEdge.GRAPPLE:
{
}
break;
default :
try {
throw new Exception(""String_Node_Str"");
}
 catch (Exception e) {
e.printStackTrace();
}
}
}",0.7724665391969407
40096,"boolean isStuck(){
  double TimeTaken=Clock.GetCurrentTime() - m_dStartTime;
  if (TimeTaken > m_dTimeToReachPos) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}","boolean isStuck(){
  double TimeTaken=System.nanoTime() * 1000 - m_dStartTime;
  if (TimeTaken > m_dTimeToReachPos) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}",0.9037656903765692
40097,"@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
  m_dStartTime=Clock.GetCurrentTime();
  m_dTimeToReachPos=getM_pOwner().calculateTimeToReachPosition(m_vPosition);
  double MarginOfError=1.0;
  m_dTimeToReachPos+=MarginOfError;
  getM_pOwner().getSteering().SetTarget(m_vPosition);
  getM_pOwner().getSteering().SeekOn();
}","@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
  m_dStartTime=System.nanoTime() * 1000;
  m_dTimeToReachPos=getM_pOwner().calculateTimeToReachPosition(m_vPosition);
  double MarginOfError=1.0;
  m_dTimeToReachPos+=MarginOfError;
  getM_pOwner().getSteering().SetTarget(m_vPosition);
  getM_pOwner().getSteering().SeekOn();
}",0.9333333333333332
40098,"boolean isStuck(){
  double TimeTaken=Clock.GetCurrentTime() - m_dStartTime;
  if (TimeTaken > m_dTimeExpected) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}","boolean isStuck(){
  double TimeTaken=System.nanoTime() * 1000 - m_dStartTime;
  if (TimeTaken > m_dTimeExpected) {
    System.out.println(""String_Node_Str"" + getM_pOwner().ID() + ""String_Node_Str"");
    return true;
  }
  return false;
}",0.9029535864978904
40099,"public Goal_TraverseEdge(RavenBot ravenBot,GraphEdge edge,boolean lastedgeinpath){
  super(ravenBot,Goal.goalType.goal_traverse_edge);
  m_Edge=edge;
  m_dTimeExpected=0.0;
  m_bLastEdgeInPath=lastedgeinpath;
}","public Goal_TraverseEdge(RavenBot ravenBot,NavGraphEdge edge,boolean lastedgeinpath){
  super(ravenBot,Goal.goalType.goal_traverse_edge);
  m_Edge=edge;
  m_dTimeExpected=0.0;
  m_bLastEdgeInPath=lastedgeinpath;
}",0.9929078014184396
40100,"@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
switch (m_Edge.behavior()) {
case swim:
{
      getM_pOwner().SetMaxSpeed(script.GetDouble(""String_Node_Str""));
    }
  break;
case crawl:
{
  getM_pOwner().SetMaxSpeed(script.GetDouble(""String_Node_Str""));
}
break;
}
m_dStartTime=Clock.GetCurrentTime();
m_dTimeExpected=getM_pOwner().calculateTimeToReachPosition(m_Edge.destination());
double MarginOfError=2.0;
m_dTimeExpected+=MarginOfError;
getM_pOwner().getSteering().SetTarget(m_Edge.destination());
if (m_bLastEdgeInPath) {
getM_pOwner().getSteering().ArriveOn();
}
 else {
getM_pOwner().getSteering().SeekOn();
}
}","@Override public void activate(){
  m_iStatus=Goal.curStatus.active;
switch (m_Edge.flags()) {
case NavGraphEdge.SWIM:
{
      getM_pOwner().setMaxSpeed(RavenScript.getDouble(""String_Node_Str""));
    }
  break;
case NavGraphEdge.CRAWL:
{
  getM_pOwner().setMaxSpeed(RavenScript.getDouble(""String_Node_Str""));
}
break;
}
m_dStartTime=System.nanoTime() * 1000;
m_dTimeExpected=getM_pOwner().calculateTimeToReachPosition(m_Edge.destination());
double MarginOfError=2.0;
m_dTimeExpected+=MarginOfError;
getM_pOwner().getSteering().SetTarget(m_Edge.destination());
if (m_bLastEdgeInPath) {
getM_pOwner().getSteering().ArriveOn();
}
 else {
getM_pOwner().getSteering().SeekOn();
}
}",0.7274107820804859
40101,"public void terminate(){
  getM_pOwner().getSteering().SeekOff();
  getM_pOwner().getSteering().ArriveOff();
  getM_pOwner().SetMaxSpeed(script.GetDouble(""String_Node_Str""));
}","public void terminate(){
  getM_pOwner().getSteering().SeekOff();
  getM_pOwner().getSteering().ArriveOff();
  getM_pOwner().setMaxSpeed(RavenScript.getDouble(""String_Node_Str""));
}",0.969187675070028
40102,"public void SeekOff(){
  if (On(seek))   flags^=seek;
}","public void SeekOff(){
  if (On(BehaviorType.seek))   flags^=BehaviorType.seek.getValue();
}",0.7482993197278912
40103,"public void WanderOff(){
  if (On(wander))   flags^=wander;
}","public void WanderOff(){
  if (On(BehaviorType.wander))   flags^=BehaviorType.wander.getValue();
}",0.7672955974842768
40104,"public void ArriveOn(){
  flags|=arrive;
}","public void ArriveOn(){
  flags|=BehaviorType.arrive.getValue();
}",0.7777777777777778
40105,"public void WallAvoidanceOff(){
  if (On(BehaviorType.wallAvoidance))   flags^=wallAvoidance;
}","public void WallAvoidanceOff(){
  if (On(BehaviorType.wallAvoidance))   flags^=BehaviorType.wallAvoidance.getValue();
}",0.8878504672897196
40106,"private Vector2D CalculatePrioritized(){
}","private Vector2D CalculatePrioritized(){
  Vector2D force;
  if (On(BehaviorType.wallAvoidance)) {
    force=WallAvoidance(world.getMap().getWalls()).mul(weightWallAvoidance);
    if (!AccumulateForce(steeringForce,force))     return steeringForce;
  }
  if (On(BehaviorType.separation)) {
    force=Separation(world.getBots()).mul(weightSeparation);
    if (!AccumulateForce(steeringForce,force))     return steeringForce;
  }
  if (On(BehaviorType.seek)) {
    force=Seek(target).mul(weightSeek);
    if (!AccumulateForce(steeringForce,force))     return steeringForce;
  }
  if (On(BehaviorType.arrive)) {
    force=Arrive(target,deceleration).mul(weightArrive);
    if (!AccumulateForce(steeringForce,force))     return steeringForce;
  }
  if (On(BehaviorType.wander)) {
    force=Wander().mul(weightWander);
    if (!AccumulateForce(steeringForce,force))     return steeringForce;
  }
  return steeringForce;
}",0.0876826722338204
40107,"final Vector<Vector2D> GetFeelers(){
  return feelers;
}","public final Vector<Vector2D> GetFeelers(){
  return feelers;
}",0.9411764705882352
40108,"public void WanderOn(){
  flags|=wander;
}","public void WanderOn(){
  flags|=BehaviorType.wander.getValue();
}",0.7777777777777778
40109,"public void SeparationOff(){
  if (On(separation))   flags^=separation;
}","public void SeparationOff(){
  if (On(BehaviorType.separation))   flags^=BehaviorType.separation.getValue();
}",0.7978142076502732
40110,"public void SeekOn(){
  flags|=seek;
}","public void SeekOn(){
  flags|=BehaviorType.seek.getValue();
}",0.76
40111,"public void SeparationOn(){
  flags|=separation;
}","public void SeparationOn(){
  flags|=BehaviorType.separation.getValue();
}",0.8064516129032258
40112,"private boolean On(BehaviorType bt){
  return (flags & bt) == bt;
}","private boolean On(BehaviorType bt){
  return (flags & bt.getValue()) == bt.getValue();
}",0.8589743589743589
40113,"public void ArriveOff(){
  if (On(arrive))   flags^=arrive;
}","public void ArriveOff(){
  if (On(BehaviorType.arrive))   flags^=BehaviorType.arrive.getValue();
}",0.7672955974842768
40114,"public GetWeaponGoal_Evaluator(Double inp,Wep weptype){
}","public GetWeaponGoal_Evaluator(Double inp,RavenObject weptype) throws Exception {
switch (weptype) {
case BLASTER:
    this.weptype=RavenObject.BLASTER;
  break;
case SHOTGUN:
this.weptype=RavenObject.SHOTGUN;
break;
case ROCKET_LAUNCHER:
this.weptype=RavenObject.ROCKET_LAUNCHER;
break;
case RAIL_GUN:
this.weptype=RavenObject.RAIL_GUN;
break;
default :
throw new Exception();
}
this.m_iBias=inp;
}",0.2368421052631578
40115,"public GoalThink(RavenBot ravenBot){
  Random randomGenerator=new Random();
  HealthBias=randomGenerator.nextDouble();
  ShotgunBias=randomGenerator.nextDouble();
  RocketLauncherBias=randomGenerator.nextDouble();
  RailgunBias=randomGenerator.nextDouble();
  ExploreBias=randomGenerator.nextDouble();
  AttackBias=randomGenerator.nextDouble();
  m_Evaluators.add(new GetHealthGoal_Evaluator(HealthBias));
  m_Evaluators.add(new ExploreGoal_Evaluator(ExploreBias));
  m_Evaluators.add(new AttackTargetGoal_Evaluator(AttackBias));
  m_Evaluators.add(new GetWeaponGoal_Evaluator(ShotgunBias,GetWeaponGoal_Evaluator.Wep.SHOTGUN));
  m_Evaluators.add(new GetWeaponGoal_Evaluator(RailgunBias,GetWeaponGoal_Evaluator.Wep.RAILGUN));
  m_Evaluators.add(new GetWeaponGoal_Evaluator(RocketLauncherBias,GetWeaponGoal_Evaluator.Wep.ROCKETLAUNCHER));
}","public GoalThink(RavenBot ravenBot){
  Random randomGenerator=new Random();
  HealthBias=randomGenerator.nextDouble();
  ShotgunBias=randomGenerator.nextDouble();
  RocketLauncherBias=randomGenerator.nextDouble();
  RailgunBias=randomGenerator.nextDouble();
  ExploreBias=randomGenerator.nextDouble();
  AttackBias=randomGenerator.nextDouble();
  m_Evaluators.add(new GetHealthGoal_Evaluator(HealthBias));
  m_Evaluators.add(new ExploreGoal_Evaluator(ExploreBias));
  m_Evaluators.add(new AttackTargetGoal_Evaluator(AttackBias));
  try {
    m_Evaluators.add(new GetWeaponGoal_Evaluator(ShotgunBias,RavenObject.SHOTGUN));
    m_Evaluators.add(new GetWeaponGoal_Evaluator(RailgunBias,RavenObject.RAIL_GUN));
    m_Evaluators.add(new GetWeaponGoal_Evaluator(RocketLauncherBias,RavenObject.ROCKET_LAUNCHER));
  }
 catch (  Exception ex) {
    System.out.println(ex.getMessage());
  }
}",0.8808832074375363
40116,"/** 
 * Backups the complete server. At first messages were sent to the console and to every player, so everyone know, a Backup is running. After this it deactivates all world saves and then saves every player position. Is this done, every world getting zipped and stored.
 */
protected void backup(){
  String startBackupMessage=pSystem.getStringProperty(STRING_START_BACKUP_MESSAGE);
  System.out.println(startBackupMessage);
  server.broadcastMessage(startBackupMessage);
  ConsoleCommandSender ccs=new ConsoleCommandSender(server);
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.savePlayers();
  String[] worldNames=pSystem.getStringProperty(STRING_NO_BACKUP_WORLDNAMES).split(""String_Node_Str"");
  if (worldNames.length > 0 && !worldNames[0].isEmpty()) {
    System.out.println(""String_Node_Str"");
    System.out.println(Arrays.toString(worldNames));
  }
  try {
    boolean hasToZIP=pSystem.getBooleanProperty(BOOL_ZIP);
    if (hasToZIP)     System.out.println(""String_Node_Str"");
    outter:     for (    World world : server.getWorlds()) {
      inner:       for (      String worldName : worldNames)       if (worldName.equalsIgnoreCase(world.getName()))       continue outter;
      String backupDir=""String_Node_Str"".concat(FILE_SEPARATOR).concat(world.getName());
      if (!hasToZIP)       backupDir=backupDir.concat(this.getDate());
      world.save();
      FileUtils.copyDirectory(new File(world.getName()),new File(backupDir));
      String targetName=world.getName();
      String targetDir=""String_Node_Str"".concat(FILE_SEPARATOR);
      if (backupName != null) {
        targetName=backupName;
        targetDir=targetDir.concat(""String_Node_Str"").concat(FILE_SEPARATOR);
      }
      if (hasToZIP) {
        FileUtils.zipDirectory(backupDir,targetDir.concat(targetName).concat(getDate()));
        FileUtils.deleteDirectory(new File(backupDir));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
  server.dispatchCommand(ccs,""String_Node_Str"");
  String completedBackupMessage=pSystem.getStringProperty(STRING_FINISH_BACKUP_MESSAGE);
  server.broadcastMessage(completedBackupMessage);
  System.out.println(completedBackupMessage);
  deleteOldBackups();
  backupName=null;
  isManuelBackup=false;
}","/** 
 * Backups the complete server. At first messages were sent to the console and to every player, so everyone know, a Backup is running. After this it deactivates all world saves and then saves every player position. Is this done, every world getting zipped and stored.
 */
protected void backup(){
  String startBackupMessage=pSystem.getStringProperty(STRING_START_BACKUP_MESSAGE);
  System.out.println(startBackupMessage);
  server.broadcastMessage(startBackupMessage);
  ConsoleCommandSender ccs=new ConsoleCommandSender(server);
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.savePlayers();
  String[] worldNames=pSystem.getStringProperty(STRING_NO_BACKUP_WORLDNAMES).split(""String_Node_Str"");
  if (worldNames.length > 0 && !worldNames[0].isEmpty()) {
    System.out.println(""String_Node_Str"");
    System.out.println(Arrays.toString(worldNames));
  }
  try {
    boolean hasToZIP=pSystem.getBooleanProperty(BOOL_ZIP);
    if (!hasToZIP)     System.out.println(""String_Node_Str"");
    outter:     for (    World world : server.getWorlds()) {
      inner:       for (      String worldName : worldNames)       if (worldName.equalsIgnoreCase(world.getName()))       continue outter;
      String backupDir=""String_Node_Str"".concat(FILE_SEPARATOR).concat(world.getName());
      if (!hasToZIP)       backupDir=backupDir.concat(this.getDate());
      world.save();
      FileUtils.copyDirectory(new File(world.getName()),new File(backupDir));
      String targetName=world.getName();
      String targetDir=""String_Node_Str"".concat(FILE_SEPARATOR);
      if (backupName != null) {
        targetName=backupName;
        targetDir=targetDir.concat(""String_Node_Str"").concat(FILE_SEPARATOR);
      }
      if (hasToZIP) {
        FileUtils.zipDirectory(backupDir,targetDir.concat(targetName).concat(getDate()));
        FileUtils.deleteDirectory(new File(backupDir));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
  server.dispatchCommand(ccs,""String_Node_Str"");
  String completedBackupMessage=pSystem.getStringProperty(STRING_FINISH_BACKUP_MESSAGE);
  server.broadcastMessage(completedBackupMessage);
  System.out.println(completedBackupMessage);
  deleteOldBackups();
  backupName=null;
  isManuelBackup=false;
}",0.9997837837837836
40117,"@Override public void onEnable(){
  setupPermissions();
  File backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"");
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  PropertiesSystem pSystem=new PropertiesSystem(this);
  Server server=getServer();
  PluginManager pm=server.getPluginManager();
  run=new PrepareBackupTask(server,pSystem);
  pm.registerEvent(Type.PLAYER_COMMAND_PREPROCESS,new CommandListener(run,pSystem,this),Priority.Normal,this);
  if (pSystem.getBooleanProperty(BOOL_BACKUP_ONLY_PLAYER)) {
    LoginListener ll=new LoginListener(this,pSystem);
    pm.registerEvent(Type.PLAYER_LOGIN,ll,Priority.Normal,this);
    pm.registerEvent(Type.PLAYER_QUIT,ll,Priority.Normal,this);
  }
  int intervall=pSystem.getIntProperty(INT_BACKUP_INTERVALL);
  server.getScheduler().scheduleSyncRepeatingTask(this,run,intervall,intervall);
  System.out.println(this.getDescription().getFullName() + ""String_Node_Str"");
}","@Override public void onEnable(){
  setupPermissions();
  File backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"");
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  PropertiesSystem pSystem=new PropertiesSystem(this);
  Server server=getServer();
  PluginManager pm=server.getPluginManager();
  run=new PrepareBackupTask(server,pSystem);
  pm.registerEvent(Type.PLAYER_COMMAND_PREPROCESS,new CommandListener(run,pSystem,this),Priority.Normal,this);
  if (pSystem.getBooleanProperty(BOOL_BACKUP_ONLY_PLAYER)) {
    LoginListener ll=new LoginListener(this,pSystem);
    pm.registerEvent(Type.PLAYER_LOGIN,ll,Priority.Normal,this);
    pm.registerEvent(Type.PLAYER_QUIT,ll,Priority.Normal,this);
  }
  int intervall=pSystem.getIntProperty(INT_BACKUP_INTERVALL);
  if (intervall != -1)   server.getScheduler().scheduleSyncRepeatingTask(this,run,intervall,intervall);
 else   System.out.println(""String_Node_Str"");
  System.out.println(this.getDescription().getFullName() + ""String_Node_Str"");
}",0.9713349713349714
40118,"/** 
 * Check whethere there are more backups as allowed to store. When this case is true, it deletes oldest ones
 */
private void deleteOldBackups(){
  try {
    File backupDir=new File(pSystem.getStringProperty(STRING_BACKUP_FOLDER));
    File[] tempArray=backupDir.listFiles();
    final int maxBackups=pSystem.getIntProperty(INT_MAX_BACKUPS);
    if (tempArray.length > maxBackups) {
      System.out.println(""String_Node_Str"");
      ArrayList<File> backups=new ArrayList<File>(tempArray.length);
      backups.addAll(Arrays.asList(tempArray));
      int maxModifiedIndex;
      long maxModified;
      for (int i=0; i < maxBackups; ++i) {
        maxModifiedIndex=0;
        maxModified=backups.get(0).lastModified();
        for (int j=1; j < backups.size(); ++j) {
          File currentFile=backups.get(j);
          if (currentFile.lastModified() > maxModified) {
            maxModified=currentFile.lastModified();
            maxModifiedIndex=j;
          }
        }
        backups.remove(maxModifiedIndex);
      }
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(backups.toArray()));
      for (      File backupToDelete : backups)       backupToDelete.delete();
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
}","/** 
 * Check whethere there are more backups as allowed to store. When this case is true, it deletes oldest ones
 */
private void deleteOldBackups(){
  try {
    File backupDir=new File(pSystem.getStringProperty(STRING_BACKUP_FOLDER));
    File[] tempArray=backupDir.listFiles();
    File[] array=new File[tempArray.length - 1];
    for (int i=0, j=0; i < tempArray.length; ++i) {
      File file=tempArray[i];
      if (file.isDirectory() && file.getName().equals(""String_Node_Str""))       continue;
      array[j++]=tempArray[i];
    }
    tempArray=array;
    final int maxBackups=pSystem.getIntProperty(INT_MAX_BACKUPS);
    if (tempArray.length > maxBackups) {
      System.out.println(""String_Node_Str"");
      ArrayList<File> backups=new ArrayList<File>(tempArray.length);
      backups.addAll(Arrays.asList(tempArray));
      int maxModifiedIndex;
      long maxModified;
      for (int i=0; i < maxBackups; ++i) {
        maxModifiedIndex=0;
        maxModified=backups.get(0).lastModified();
        for (int j=1; j < backups.size(); ++j) {
          File currentFile=backups.get(j);
          if (currentFile.lastModified() > maxModified) {
            maxModified=currentFile.lastModified();
            maxModifiedIndex=j;
          }
        }
        backups.remove(maxModifiedIndex);
      }
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(backups.toArray()));
      for (      File backupToDelete : backups)       backupToDelete.delete();
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
}",0.9024816497728068
40119,"@Override public void performVerboseAction(){
  super.performVerboseAction();
  if (DEBUG_MEMORY) {
    DEBUG_MEM_COUNTER++;
    if (DEBUG_MEM_COUNTER % DEBUG_MEM_INTERVAL == 0) {
      DEBUG_MEM_COUNTER=0;
      ReferenceCleanser.clearSoftCaches();
      System.err.println(flowGraph.spaceReport());
      System.err.println(""String_Node_Str"");
      HeapTracer.traceHeap(Collections.singleton(this),true);
      System.err.println(""String_Node_Str"");
    }
  }
  if (getFixedPointSystem() instanceof VerboseAction) {
    ((VerboseAction)getFixedPointSystem()).performVerboseAction();
  }
  AbstractStatement s=workList.takeStatement();
  System.err.println(printRHSInstances(s));
  workList.insertStatement(s);
  System.err.println(""String_Node_Str"" + cg.getNumberOfNodes());
}","@Override public void performVerboseAction(){
  super.performVerboseAction();
  if (DEBUG_MEMORY) {
    DEBUG_MEM_COUNTER++;
    if (DEBUG_MEM_COUNTER % DEBUG_MEM_INTERVAL == 0) {
      DEBUG_MEM_COUNTER=0;
      ReferenceCleanser.clearSoftCaches();
      System.err.println(flowGraph.spaceReport());
      System.err.println(""String_Node_Str"");
      HeapTracer.traceHeap(Collections.singleton(this),true);
      System.err.println(""String_Node_Str"");
    }
  }
  if (getFixedPointSystem() instanceof VerboseAction) {
    ((VerboseAction)getFixedPointSystem()).performVerboseAction();
  }
  if (!workList.isEmpty()) {
    AbstractStatement s=workList.takeStatement();
    System.err.println(printRHSInstances(s));
    workList.insertStatement(s);
    System.err.println(""String_Node_Str"" + cg.getNumberOfNodes());
  }
}",0.9743589743589745
40120,"public CAstNode translateDoLoop(CAstNode loopTest,CAstNode loopBody,CAstNode continueNode,CAstNode breakNode,WalkContext<?,?> wc){
  if (replicateForDoLoops) {
    loopBody=Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode);
    CAstRewriter.Rewrite x=(new CAstCloner(Ast,false)).copy(loopBody,wc.cfg(),wc.pos(),wc.getNodeTypeMap(),null);
    CAstNode otherBody=x.newRoot();
    wc.cfg().addAll(x.newCfg());
    wc.pos().addAll(x.newPos());
    wc.getNodeTypeMap().addAll(x.newTypes());
    return Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,Ast.makeNode(CAstNode.LOOP,loopTest,otherBody),breakNode);
  }
 else {
    CAstNode header=Ast.makeNode(CAstNode.EMPTY);
    CAstNode loopGoto=Ast.makeNode(CAstNode.IFGOTO,loopTest);
    wc.cfg().map(header,header);
    wc.cfg().map(loopGoto,loopGoto);
    wc.cfg().add(loopGoto,header,Boolean.TRUE);
    return Ast.makeNode(CAstNode.BLOCK_STMT,header,Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode),loopGoto,breakNode);
  }
}","public CAstNode translateDoLoop(CAstNode loopTest,CAstNode loopBody,CAstNode continueNode,CAstNode breakNode,WalkContext<?,?> wc){
  if (replicateForDoLoops) {
    loopBody=Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode);
    CAstRewriter.Rewrite x=(new CAstCloner(Ast,false)).copy(loopBody,wc.cfg(),wc.pos(),wc.getNodeTypeMap(),null);
    CAstNode otherBody=x.newRoot();
    wc.cfg().addAll(x.newCfg());
    wc.pos().addAll(x.newPos());
    wc.getNodeTypeMap().addAll(x.newTypes());
    return Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,Ast.makeNode(CAstNode.LOOP,loopTest,otherBody),breakNode);
  }
 else {
    CAstNode header=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(""String_Node_Str""),Ast.makeNode(CAstNode.EMPTY));
    CAstNode loopGoto=Ast.makeNode(CAstNode.IFGOTO,loopTest);
    wc.cfg().map(header,header);
    wc.cfg().map(loopGoto,loopGoto);
    wc.cfg().add(loopGoto,header,Boolean.TRUE);
    return Ast.makeNode(CAstNode.BLOCK_STMT,header,Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode),loopGoto,breakNode);
  }
}",0.965483234714004
40121,"/** 
 * Given a calling node and a call site, return the set of parameters based on which this selector may choose  to specialize contexts.   {@inheritDoc}
 */
@Override public IntSet getRelevantParameters(CGNode caller,CallSiteReference site){
  IntSet ret;
  if (this.parent != null) {
    ret=this.parent.getRelevantParameters(caller,site);
  }
 else {
    ret=EmptyIntSet.instance;
  }
  final MethodReference target=site.getDeclaredTarget();
  if (intentStarters.isStarter(target)) {
    final StartInfo info=intentStarters.getInfo(target);
    final int[] relevant=info.getRelevant();
    if (relevant != null) {
      for (int i=0; i < relevant.length; ++i) {
        ret=IntSetUtil.add(ret,relevant[i]);
      }
    }
    logger.debug(""String_Node_Str"",site,ret);
  }
 else   if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentName)) {
    final MethodReference mRef=site.getDeclaredTarget();
    final int numArgs=mRef.getNumberOfParameters();
switch (numArgs) {
case 0:
      return EmptyIntSet.instance;
case 1:
    return IntSetUtil.make(new int[]{0,1});
case 2:
  logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2});
case 3:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3});
case 4:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4});
default :
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4,5});
}
}
 else if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentSenderName)) {
logger.warn(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
logger.debug(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
return ret;
}","/** 
 * Given a calling node and a call site, return the set of parameters based on which this selector may choose  to specialize contexts.   {@inheritDoc}
 */
@Override public IntSet getRelevantParameters(CGNode caller,CallSiteReference site){
  IntSet ret;
  if (this.parent != null) {
    ret=this.parent.getRelevantParameters(caller,site);
  }
 else {
    ret=EmptyIntSet.instance;
  }
  final MethodReference target=site.getDeclaredTarget();
  if (intentStarters.isStarter(target)) {
    final StartInfo info=intentStarters.getInfo(target);
    final int[] relevant=info.getRelevant();
    if (relevant != null) {
      for (int i=0; i < relevant.length; ++i) {
        ret=IntSetUtil.add(ret,relevant[i]);
      }
    }
    logger.debug(""String_Node_Str"",site,ret);
  }
 else   if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentName)) {
    final MethodReference mRef=site.getDeclaredTarget();
    final int numArgs=mRef.getNumberOfParameters();
switch (numArgs) {
case 0:
      return EmptyIntSet.instance;
case 1:
    return IntSetUtil.make(new int[]{0,1});
case 2:
  logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2});
case 3:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3});
case 4:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4});
default :
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4,5});
}
}
 else if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentSenderName)) {
logger.warn(""String_Node_Str"",target);
if (target.getNumberOfParameters() == 0) {
return IntSetUtil.make(new int[]{0});
}
 else {
return IntSetUtil.make(new int[]{0,1});
}
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
logger.debug(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
return ret;
}",0.9799150251062186
40122,"private ClassWriter.Element[] makeMethodAttributes(int m,ClassWriter w,CodeReader oldCode,Compiler.Output output,MethodData md) throws InvalidClassFileException {
  CodeWriter code=makeNewCode(w,output);
  int codeAttrCount=0;
  LineNumberTableWriter lines=null;
  LocalVariableTableWriter locals=null;
  StackMapTableWriter stacks=null;
  if (oldCode != null) {
    lines=makeNewLines(w,oldCode,output);
    if (lines != null) {
      codeAttrCount++;
    }
    locals=makeNewLocals(w,oldCode,output);
    if (locals != null) {
      codeAttrCount++;
    }
    if (oldCode.getClassReader().getMajorVersion() > 50) {
      try {
        List<StackMapFrame> sm=StackMapTableReader.readStackMap(oldCode);
        String[][] varTypes=null;
        int[] newToOld=output.getNewBytecodesToOldBytecodes();
        int[][] vars=LocalVariableTableReader.makeVarMap(oldCode);
        if (vars != null) {
          varTypes=new String[newToOld.length][];
          for (int i=0; i < newToOld.length; i++) {
            int idx=newToOld[i];
            if (idx != -1 && vars[idx] != null) {
              varTypes[i]=new String[vars[idx].length / 2];
              for (int j=1; j < vars[idx].length; j+=2) {
                int type=vars[idx][j];
                varTypes[i][j / 2]=type == 0 ? null : oldCode.getClassReader().getCP().getCPUtf8(type);
              }
            }
          }
        }
        stacks=new StackMapTableWriter(w,md,output,cha,varTypes,sm);
        codeAttrCount++;
      }
 catch (      IOException|FailureException e) {
        e.printStackTrace();
      }
    }
  }
  ClassWriter.Element[] codeAttributes=new ClassWriter.Element[codeAttrCount];
  int codeAttrIndex=0;
  if (lines != null) {
    codeAttributes[codeAttrIndex++]=lines;
  }
  if (locals != null) {
    codeAttributes[codeAttrIndex++]=locals;
  }
  if (stacks != null) {
    codeAttributes[codeAttrIndex++]=stacks;
  }
  code.setAttributes(codeAttributes);
  ClassReader.AttrIterator iter=new ClassReader.AttrIterator();
  cr.initMethodAttributeIterator(m,iter);
  int methodAttrCount=iter.getRemainingAttributesCount();
  if (oldCode == null) {
    methodAttrCount++;
  }
  ClassWriter.Element[] methodAttributes=new ClassWriter.Element[methodAttrCount];
  for (int i=0; iter.isValid(); iter.advance()) {
    if (iter.getName().equals(""String_Node_Str"")) {
      methodAttributes[i]=code;
      code=null;
      if (oldCode == null) {
        throw new Error(""String_Node_Str"");
      }
    }
 else {
      methodAttributes[i]=new ClassWriter.RawElement(cr.getBytes(),iter.getRawOffset(),iter.getRawSize());
    }
    i++;
  }
  if (oldCode == null) {
    if (code == null) {
      throw new Error(""String_Node_Str"");
    }
    methodAttributes[methodAttrCount - 1]=code;
  }
  return methodAttributes;
}","private ClassWriter.Element[] makeMethodAttributes(int m,ClassWriter w,CodeReader oldCode,Compiler.Output output,MethodData md) throws InvalidClassFileException {
  CodeWriter code=makeNewCode(w,output);
  int codeAttrCount=0;
  LineNumberTableWriter lines=null;
  LocalVariableTableWriter locals=null;
  StackMapTableWriter stacks=null;
  if (oldCode != null) {
    lines=makeNewLines(w,oldCode,output);
    if (lines != null) {
      codeAttrCount++;
    }
    locals=makeNewLocals(w,oldCode,output);
    if (locals != null) {
      codeAttrCount++;
    }
    if (oldCode.getClassReader().getMajorVersion() > 50) {
      try {
        List<StackMapFrame> sm=StackMapTableReader.readStackMap(oldCode);
        String[][] varTypes=null;
        int[] newToOld=output.getNewBytecodesToOldBytecodes();
        int[][] vars=LocalVariableTableReader.makeVarMap(oldCode);
        if (vars != null) {
          varTypes=new String[newToOld.length][];
          for (int i=0; i < newToOld.length; i++) {
            int idx=newToOld[i];
            if (idx != -1 && vars[idx] != null) {
              varTypes[i]=new String[vars[idx].length / 2];
              for (int j=1; j < vars[idx].length; j+=2) {
                int type=vars[idx][j];
                varTypes[i][j / 2]=type == 0 ? null : oldCode.getClassReader().getCP().getCPUtf8(type);
              }
            }
          }
        }
        stacks=new StackMapTableWriter(w,md,output,cha,varTypes);
        codeAttrCount++;
      }
 catch (      IOException|FailureException e) {
        e.printStackTrace();
      }
    }
  }
  ClassWriter.Element[] codeAttributes=new ClassWriter.Element[codeAttrCount];
  int codeAttrIndex=0;
  if (lines != null) {
    codeAttributes[codeAttrIndex++]=lines;
  }
  if (locals != null) {
    codeAttributes[codeAttrIndex++]=locals;
  }
  if (stacks != null) {
    codeAttributes[codeAttrIndex++]=stacks;
  }
  code.setAttributes(codeAttributes);
  ClassReader.AttrIterator iter=new ClassReader.AttrIterator();
  cr.initMethodAttributeIterator(m,iter);
  int methodAttrCount=iter.getRemainingAttributesCount();
  if (oldCode == null) {
    methodAttrCount++;
  }
  ClassWriter.Element[] methodAttributes=new ClassWriter.Element[methodAttrCount];
  for (int i=0; iter.isValid(); iter.advance()) {
    if (iter.getName().equals(""String_Node_Str"")) {
      methodAttributes[i]=code;
      code=null;
      if (oldCode == null) {
        throw new Error(""String_Node_Str"");
      }
    }
 else {
      methodAttributes[i]=new ClassWriter.RawElement(cr.getBytes(),iter.getRawOffset(),iter.getRawSize());
    }
    i++;
  }
  if (oldCode == null) {
    if (code == null) {
      throw new Error(""String_Node_Str"");
    }
    methodAttributes[methodAttrCount - 1]=code;
  }
  return methodAttributes;
}",0.9994624619243864
40123,"@Override public SSAAbstractInvokeInstruction addDirectCall(int function,int[] params,CallSiteReference site){
  CallSiteReference newSite=new JSCallSiteReference(statements.size());
  JavaScriptInvoke s=new JavaScriptInvoke(function,nextLocal++,params,nextLocal++,newSite);
  statements.add(s);
  return s;
}","@Override public SSAAbstractInvokeInstruction addDirectCall(int function,int[] params,CallSiteReference site){
  CallSiteReference newSite=new JSCallSiteReference(statements.size());
  JavaScriptInvoke s=new JavaScriptInvoke(statements.size(),function,nextLocal++,params,nextLocal++,newSite);
  statements.add(s);
  return s;
}",0.9716981132075472
40124,"private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(S.getNextProgramCounter(),propertyReadResult,4,constVN));
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(S.getNumberOfStatements(),propertyReadResult,4,constVN));
    S.getNextProgramCounter();
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9118483412322276
40125,"private IR makeIRForArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int numParamsToPass=10;
  int[] paramsToPassToInvoked=new int[numParamsToPass + 1];
  paramsToPassToInvoked[0]=3;
  int curValNum=passActualPropertyValsAsParams(insts,nargs,S,paramsToPassToInvoked);
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int resultVal=curValNum++;
  int excVal=curValNum++;
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,paramsToPassToInvoked,excVal,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}","private IR makeIRForArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int numParamsToPass=10;
  int[] paramsToPassToInvoked=new int[numParamsToPass + 1];
  paramsToPassToInvoked[0]=3;
  int curValNum=passActualPropertyValsAsParams(insts,nargs,S,paramsToPassToInvoked);
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int resultVal=curValNum++;
  int excVal=curValNum++;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,paramsToPassToInvoked,excVal,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}",0.7147058823529412
40126,"private IR makeIRForNoArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[1];
  params[0]=3;
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,params,resultVal + 1,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}","private IR makeIRForNoArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[1];
  params[0]=3;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,params,resultVal + 1,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}",0.8585247883917775
40127,"@SuppressWarnings(""String_Node_Str"") private int passArbitraryPropertyValAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  int eachElementGetResult=curValNum++;
  S.addStatement(insts.EachElementGetInstruction(S.getNextProgramCounter(),eachElementGetResult,4));
  int propertyReadResult=curValNum++;
  S.addStatement(insts.PropertyRead(S.getNextProgramCounter(),propertyReadResult,4,eachElementGetResult));
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","@SuppressWarnings(""String_Node_Str"") private int passArbitraryPropertyValAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  int eachElementGetResult=curValNum++;
  S.addStatement(insts.EachElementGetInstruction(S.getNumberOfStatements(),eachElementGetResult,4));
  S.getNextProgramCounter();
  int propertyReadResult=curValNum++;
  S.addStatement(insts.PropertyRead(S.getNumberOfStatements(),propertyReadResult,4,eachElementGetResult));
  S.getNextProgramCounter();
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9018691588785048
40128,"/** 
 * generate a synthetic method modeling the invocation of Function.call() at the site
 * @param caller
 * @param site
 * @param receiver
 * @return
 */
private IMethod getFunctionCallTarget(CGNode caller,CallSiteReference site,IClass receiver){
  int nargs=getNumberOfArgsPassed(caller,site);
  if (nargs < 2)   return null;
  String key=getKey(nargs,caller,site);
  if (callModels.containsKey(key)) {
    return callModels.get(key);
  }
  JSInstructionFactory insts=(JSInstructionFactory)receiver.getClassLoader().getInstructionFactory();
  MethodReference ref=genSyntheticMethodRef(receiver,nargs,key);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  if (WARN_ABOUT_IMPRECISE_CALLGRAPH && caller.getMethod().getName().toString().contains(SYNTHETIC_CALL_METHOD_PREFIX))   warnAboutImpreciseCallGraph(caller,site);
  if (DEBUG_SYNTHETIC_CALL_METHODS) {
    IMethod method=caller.getMethod();
    if (method instanceof AstMethod) {
      int line=((AstMethod)method).getLineNumber(caller.getIR().getCallInstructionIndices(site).intIterator().next());
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ line+ ""String_Node_Str""+ caller);
    }
 else {
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ method.getName());
    }
  }
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[nargs - 2];
  for (int i=0; i < params.length; i++) {
    params[i]=i + 3;
  }
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,params,resultVal + 1,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,receiver);
  callModels.put(key,t);
  return t;
}","/** 
 * generate a synthetic method modeling the invocation of Function.call() at the site
 * @param caller
 * @param site
 * @param receiver
 * @return
 */
private IMethod getFunctionCallTarget(CGNode caller,CallSiteReference site,IClass receiver){
  int nargs=getNumberOfArgsPassed(caller,site);
  if (nargs < 2)   return null;
  String key=getKey(nargs,caller,site);
  if (callModels.containsKey(key)) {
    return callModels.get(key);
  }
  JSInstructionFactory insts=(JSInstructionFactory)receiver.getClassLoader().getInstructionFactory();
  MethodReference ref=genSyntheticMethodRef(receiver,nargs,key);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  if (WARN_ABOUT_IMPRECISE_CALLGRAPH && caller.getMethod().getName().toString().contains(SYNTHETIC_CALL_METHOD_PREFIX))   warnAboutImpreciseCallGraph(caller,site);
  if (DEBUG_SYNTHETIC_CALL_METHODS) {
    IMethod method=caller.getMethod();
    if (method instanceof AstMethod) {
      int line=((AstMethod)method).getLineNumber(caller.getIR().getCallInstructionIndices(site).intIterator().next());
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ line+ ""String_Node_Str""+ caller);
    }
 else {
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ method.getName());
    }
  }
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[nargs - 2];
  for (int i=0; i < params.length; i++) {
    params[i]=i + 3;
  }
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,params,resultVal + 1,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,receiver);
  callModels.put(key,t);
  return t;
}",0.965160587915079
40129,"private IMethod makeUnaryNumberCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.Number));
}","private IMethod makeUnaryNumberCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.Number));
}",0.98224043715847
40130,"private IMethod makeUnaryStringCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.String));
}","private IMethod makeUnaryStringCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.String));
}",0.98224043715847
40131,"private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(insts.NewInstruction(S.getNumberOfStatements(),nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(insts.SetPrototype(S.getNumberOfStatements(),nargs + 5,nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(insts.Invoke(1,nargs + 7,args,nargs + 8,cs));
  int pc=S.getNextProgramCounter();
  S.addConstant(nargs + 9,null);
  S.addStatement(insts.ConditionalBranchInstruction(S.getNumberOfStatements(),Operator.EQ,JavaScriptTypes.Root,nargs + 7,nargs + 9,pc + 2));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls,cls));
}","private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(insts.NewInstruction(S.getNumberOfStatements(),nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(insts.SetPrototype(S.getNumberOfStatements(),nargs + 5,nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),1,nargs + 7,args,nargs + 8,cs));
  int pc=S.getNextProgramCounter();
  S.addConstant(nargs + 9,null);
  S.addStatement(insts.ConditionalBranchInstruction(S.getNumberOfStatements(),Operator.EQ,JavaScriptTypes.Root,nargs + 7,nargs + 9,pc + 2));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls,cls));
}",0.9918851435705368
40132,"protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}","protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral() << 16,((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral() << 16,((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}",0.999909412084428
40133,"@Override public int getLastCol(){
  return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
}","@Override public int getLastCol(){
  return -1;
}",0.618421052631579
40134,"private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
    }
    @Override public int getLastCol(){
      return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public InputStream getInputStream() throws IOException {
      return new FileInputStream(sourceFile);
    }
  }
;
}","private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return -1;
    }
    @Override public int getLastCol(){
      return -1;
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public Reader getReader() throws IOException {
      return new FileReader(sourceFile);
    }
  }
;
}",0.847723704866562
40135,"public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString();
  return Pair.make(lineNum,body);
}","public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString().replace(content.getSource().getNewLine(),""String_Node_Str"");
  return Pair.make(lineNum,body);
}",0.8837209302325582
40136,"@Override public int getFirstCol(){
  return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
}","@Override public int getFirstCol(){
  return -1;
}",0.6153846153846154
40137,"/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(pf));
  }
}","/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    String prop=pf.endsWith(""String_Node_Str"") ? pf.substring(0,pf.length() - 6) : pf;
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(prop));
  }
}",0.9208006962576152
40138,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      lines.add(currentLine.substring(p.getFirstOffset() - (offset - currentLine.length() - 1)));
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(p.getReader());
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      int startOffset=p.getFirstOffset() - (offset - currentLine.length() - 1);
      if (offset > p.getLastOffset()) {
        int endOffset=p.getLastOffset() - (offset - currentLine.length() - 1);
        lines.add(currentLine.substring(startOffset,endOffset));
      }
 else {
        lines.add(currentLine.substring(startOffset));
      }
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}",0.8793259103219982
40139,"public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public InputStream getInputStream() throws IOException {
        return hack.getInputStream();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}","public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public Reader getReader() throws IOException {
        return hack.getReader();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}",0.9867979413739092
40140,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      lines.add(currentLine.substring(p.getFirstOffset() - (offset - currentLine.length() - 1)));
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(p.getReader());
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      int startOffset=p.getFirstOffset() - (offset - currentLine.length() - 1);
      if (offset > p.getLastOffset()) {
        int endOffset=p.getLastOffset() - (offset - currentLine.length() - 1);
        lines.add(currentLine.substring(startOffset,endOffset));
      }
 else {
        lines.add(currentLine.substring(startOffset));
      }
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}",0.8793259103219982
40141,"public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public InputStream getInputStream() throws IOException {
        return hack.getInputStream();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}","public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public Reader getReader() throws IOException {
        return hack.getReader();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}",0.9867979413739092
40142,"@Override public int getLastCol(){
  return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
}","@Override public int getLastCol(){
  return -1;
}",0.618421052631579
40143,"private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
    }
    @Override public int getLastCol(){
      return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public InputStream getInputStream() throws IOException {
      return new FileInputStream(sourceFile);
    }
  }
;
}","private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return -1;
    }
    @Override public int getLastCol(){
      return -1;
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public Reader getReader() throws IOException {
      return new FileReader(sourceFile);
    }
  }
;
}",0.847723704866562
40144,"public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString();
  return Pair.make(lineNum,body);
}","public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString().replace(content.getSource().getNewLine(),""String_Node_Str"");
  return Pair.make(lineNum,body);
}",0.8837209302325582
40145,"@Override public int getFirstCol(){
  return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
}","@Override public int getFirstCol(){
  return -1;
}",0.6153846153846154
40146,"/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(pf));
  }
}","/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    String prop=pf.endsWith(""String_Node_Str"") ? pf.substring(0,pf.length() - 6) : pf;
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(prop));
  }
}",0.9208006962576152
40147,"public final Set<TypeReference> getUnresolvedClasses(){
  return unresolved;
}","@Override public final Set<TypeReference> getUnresolvedClasses(){
  return unresolved;
}",0.9397590361445785
40148,"/** 
 * Find a class in this class hierarchy.
 * @return the {@link IClass} for a if found; null if can't find the class.
 * @throws IllegalArgumentException if A is null
 */
@Override public IClass lookupClass(TypeReference a){
  if (a == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassLoaderReference loader=a.getClassLoader();
  ClassLoaderReference parent=loader.getParent();
  if (parent != null) {
    TypeReference p=TypeReference.findOrCreate(parent,a.getName());
    IClass c=lookupClass(p);
    if (c != null) {
      return c;
    }
  }
  if (a.isArrayType()) {
    TypeReference elt=a.getInnermostElementType();
    if (elt.isPrimitiveType()) {
      return getRootClass().getClassLoader().lookupClass(a.getName());
    }
 else {
      IClass c=lookupClass(elt);
      if (c == null) {
        unresolved.add(elt);
        return null;
      }
 else {
        return c.getClassLoader().lookupClass(a.getName());
      }
    }
  }
 else {
    Node n=map.get(a);
    if (n != null) {
      return n.klass;
    }
 else {
      unresolved.add(a);
      return null;
    }
  }
}","/** 
 * Find a class in this class hierarchy.
 * @return the {@link IClass} for a if found; null if can't find the class.
 * @throws IllegalArgumentException if A is null
 */
@Override public IClass lookupClass(TypeReference a){
  if (a == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final IClass cls=lookupClassRecursive(a);
  if (cls == null) {
    unresolved.add(a);
  }
  return cls;
}",0.4928292046936114
40149,"protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
Instruction prev_inst=getInstructionFromIndex(instCounter - 1);
if (prev_inst instanceof NewArray && ((NewArray)prev_inst).destination == ((Instruction31t)inst).getRegisterA()) {
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),((NewArray)prev_inst).newSiteRef.getDeclaredType().getArrayElementType().getName().toString()),inst.opcode,this));
}
 else {
throw new UnsupportedOperationException(""String_Node_Str"");
}
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}","protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}",0.9969844093965804
40150,"/** 
 * set up the methodMap mapping
 */
protected void computeMethodMapIfNeeded() throws InvalidClassFileException {
  if (methodMap == null) {
synchronized (this) {
      if (methodMap == null) {
        IMethod[] methods=computeDeclaredMethods();
        if (methods.length > 5) {
          methodMap=HashMapFactory.make(methods.length);
        }
 else {
          methodMap=new SmallMap<Selector,IMethod>();
        }
        for (int i=0; i < methods.length; i++) {
          IMethod m=methods[i];
          methodMap.put(m.getReference().getSelector(),m);
        }
      }
    }
  }
}","/** 
 * set up the methodMap mapping
 */
protected void computeMethodMapIfNeeded() throws InvalidClassFileException {
  if (methodMap == null) {
synchronized (this) {
      if (methodMap == null) {
        IMethod[] methods=computeDeclaredMethods();
        final Map<Selector,IMethod> tmpMethodMap;
        if (methods.length > 5) {
          tmpMethodMap=HashMapFactory.make(methods.length);
        }
 else {
          tmpMethodMap=new SmallMap<Selector,IMethod>();
        }
        for (int i=0; i < methods.length; i++) {
          IMethod m=methods[i];
          tmpMethodMap.put(m.getReference().getSelector(),m);
        }
        methodMap=tmpMethodMap;
      }
    }
  }
}",0.9223529411764706
40151,"public void unary1(){
}","@Override public void unary1(){
}",0.8214285714285714
40152,"public void unary2(){
  unary1();
}","@Override public void unary2(){
  unary1();
}",0.875
40153,"public void binary(Whatever arg){
  this.unary1();
  arg.unary2();
}","@Override public void binary(Whatever arg){
  this.unary1();
  arg.unary2();
}",0.9315068493150684
40154,"public static void main(String[] args){
  Whatever x=new This();
  Whatever y=new That();
  Whatever z=choice() ? x : y;
  if (z instanceof This)   x.binary(z);
 else   y.binary(z);
}","public static void main(String[] args){
  Whatever x=new This();
  Whatever y=new That();
  Whatever z=choice() ? x : y;
  if (z instanceof This)   x.binary(z);
 else   y.binary(z);
  localCast();
}",0.9606299212598424
40155,"private void checkCallAssertions(CallGraph cg,int desiredNumberOfTargets,int desiredNumberOfCalls){
}","private void checkCallAssertions(CallGraph cg,int desiredNumberOfTargets,int desiredNumberOfCalls,int numLocalCastCallees){
}",0.8938053097345132
40156,"@Test public void testNoPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(false),2,2);
}","@Test public void testNoPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(false),2,2,2);
}",0.9940476190476192
40157,"@Test public void testPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(true),1,2);
}","@Test public void testPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(true),1,2,1);
}",0.993939393939394
40158,"public void defineFunction(CAstEntity n,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  ((JavaClass)owner).addMethod(n,owner,cfg,symtab,hasCatchBlock,catchTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public void defineFunction(CAstEntity n,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  ((JavaClass)owner).addMethod(n,owner,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.9440459110473458
40159,"public ConcreteJavaMethod(CAstEntity methodEntity,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(methodEntity,owner,cfg,symtab,hasCatchBlock,catchTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public ConcreteJavaMethod(CAstEntity methodEntity,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(methodEntity,owner,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.9437229437229436
40160,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}",0.962671905697446
40161,"@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (N == codeBodyEntity) {
    specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
  }
 else {
    super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
  }
}","@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (N == codeBodyEntity) {
    specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
  }
 else {
    super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
  }
}",0.9826166514181152
40162,"@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e;
        Map<String,CAstNode> argRefs=HashMapFactory.make();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
          this.e=m.getEntity();
          for (          Segments s : CAstPattern.findAll(destructuredAccessPattern,m.getEntity())) {
            argRefs.put(s.getSingle(""String_Node_Str"").getValue().toString(),s.getSingle(""String_Node_Str""));
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=n.getValue();
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          Segments s;
          if ((s=CAstPattern.match(directAccessPattern,root)) != null) {
            result=handleArgumentRef(s.getSingle(""String_Node_Str""));
          }
 else           if ((s=CAstPattern.match(destructuredCallPattern,root)) != null) {
            if (argRefs.containsKey(s.getSingle(""String_Node_Str"").getValue().toString())) {
              List<CAstNode> x=new ArrayList<CAstNode>();
              CAstNode ref=handleArgumentRef(argRefs.get(s.getSingle(""String_Node_Str"").getValue().toString()));
              if (ref != null) {
                x.add(ref);
                x.add(Ast.makeConstant(""String_Node_Str""));
                x.add(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"")));
                for (                CAstNode c : s.getMultiple(""String_Node_Str"")) {
                  x.add(copyNodes(c,cfg,context,nodeMap));
                }
                result=Ast.makeNode(CAstNode.CALL,x.toArray(new CAstNode[x.size()]));
              }
            }
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}","@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e;
        Map<String,CAstNode> argRefs=HashMapFactory.make();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
          this.e=m.getEntity();
          for (          Segments s : CAstPattern.findAll(destructuredAccessPattern,m.getEntity())) {
            argRefs.put(s.getSingle(""String_Node_Str"").getValue().toString(),s.getSingle(""String_Node_Str""));
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=n.getValue();
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          Segments s;
          if ((s=CAstPattern.match(directAccessPattern,root)) != null) {
            result=handleArgumentRef(s.getSingle(""String_Node_Str""));
          }
 else           if ((s=CAstPattern.match(destructuredCallPattern,root)) != null) {
            if (argRefs.containsKey(s.getSingle(""String_Node_Str"").getValue().toString())) {
              List<CAstNode> x=new ArrayList<CAstNode>();
              CAstNode ref=handleArgumentRef(argRefs.get(s.getSingle(""String_Node_Str"").getValue().toString()));
              if (ref != null) {
                x.add(ref);
                x.add(Ast.makeConstant(""String_Node_Str""));
                x.add(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"")));
                for (                CAstNode c : s.getMultiple(""String_Node_Str"")) {
                  x.add(copyNodes(c,cfg,context,nodeMap));
                }
                result=Ast.makeNode(CAstNode.CALL,x.toArray(new CAstNode[x.size()]));
              }
            }
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        Map<IBasicBlock,TypeReference[]> caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}",0.998531117124082
40163,"@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
  names.add(fnName);
  super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
  names.add(fnName);
  super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9791894852135816
40164,"/** 
 * @param cha
 * @param cl
 * @param fileName
 * @param url
 * @return The set of class names that where defined in the CHA as a resultloading process.
 * @throws IOException
 */
public static Set<String> loadAdditionalFile(IClassHierarchy cha,JavaScriptLoader cl,String fileName,URL url) throws IOException {
  try {
    SourceURLModule M=new SourceURLModule(url);
    TranslatorToCAst toCAst=getTranslatorFactory().make(new CAstImpl(),M);
    final Set<String> names=new HashSet<String>();
    JSAstTranslator toIR=new JSAstTranslator(cl){
      @Override protected void defineFunction(      CAstEntity N,      WalkContext definingContext,      AbstractCFG cfg,      SymbolTable symtab,      boolean hasCatchBlock,      TypeReference[][] caughtTypes,      boolean hasMonitorOp,      AstLexicalInformation LI,      DebuggingInformation debugInfo){
        String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
        names.add(fnName);
        super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
      }
      @Override protected void leaveFunctionStmt(      CAstNode n,      WalkContext c,      CAstVisitor<WalkContext> visitor){
        CAstEntity fn=(CAstEntity)n.getChild(0).getValue();
        Scope cs=c.currentScope();
        if (!cs.contains(fn.getName()) || cs.lookup(fn.getName()).getDefiningScope().getEntity().getKind() == CAstEntity.SCRIPT_ENTITY) {
          int result=processFunctionExpr(n,c);
          assignValue(n,c,cs.lookup(fn.getName()),fn.getName(),result);
        }
 else {
          super.leaveFunctionStmt(n,c,visitor);
        }
      }
    }
;
    CAstEntity tree;
    try {
      tree=toCAst.translateToCAst();
      if (DEBUG) {
        CAstPrinter.printTo(tree,new PrintWriter(System.err));
      }
      toIR.translate(tree,M);
      for (      String name : names) {
        IClass fcls=cl.lookupClass(name,cha);
        cha.addClass(fcls);
      }
      return names;
    }
 catch (    Error e) {
      return Collections.emptySet();
    }
  }
 catch (  RuntimeException e) {
    return Collections.emptySet();
  }
}","/** 
 * @param cha
 * @param cl
 * @param fileName
 * @param url
 * @return The set of class names that where defined in the CHA as a resultloading process.
 * @throws IOException
 */
public static Set<String> loadAdditionalFile(IClassHierarchy cha,JavaScriptLoader cl,String fileName,URL url) throws IOException {
  try {
    SourceURLModule M=new SourceURLModule(url);
    TranslatorToCAst toCAst=getTranslatorFactory().make(new CAstImpl(),M);
    final Set<String> names=new HashSet<String>();
    JSAstTranslator toIR=new JSAstTranslator(cl){
      @Override protected void defineFunction(      CAstEntity N,      WalkContext definingContext,      AbstractCFG cfg,      SymbolTable symtab,      boolean hasCatchBlock,      Map<IBasicBlock,TypeReference[]> caughtTypes,      boolean hasMonitorOp,      AstLexicalInformation LI,      DebuggingInformation debugInfo){
        String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
        names.add(fnName);
        super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
      }
      @Override protected void leaveFunctionStmt(      CAstNode n,      WalkContext c,      CAstVisitor<WalkContext> visitor){
        CAstEntity fn=(CAstEntity)n.getChild(0).getValue();
        Scope cs=c.currentScope();
        if (!cs.contains(fn.getName()) || cs.lookup(fn.getName()).getDefiningScope().getEntity().getKind() == CAstEntity.SCRIPT_ENTITY) {
          int result=processFunctionExpr(n,c);
          assignValue(n,c,cs.lookup(fn.getName()),fn.getName(),result);
        }
 else {
          super.leaveFunctionStmt(n,c,visitor);
        }
      }
    }
;
    CAstEntity tree;
    try {
      tree=toCAst.translateToCAst();
      if (DEBUG) {
        CAstPrinter.printTo(tree,new PrintWriter(System.err));
      }
      toIR.translate(tree,M);
      for (      String name : names) {
        IClass fcls=cl.lookupClass(name,cha);
        cha.addClass(fcls);
      }
      return names;
    }
 catch (    Error e) {
      return Collections.emptySet();
    }
  }
 catch (  RuntimeException e) {
    return Collections.emptySet();
  }
}",0.9955555555555556
40165,"public JavaScriptMethodObject makeCodeBodyCode(AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo,IClass C){
  return new JavaScriptMethodObject(C,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public JavaScriptMethodObject makeCodeBodyCode(AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo,IClass C){
  return new JavaScriptMethodObject(C,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.972972972972973
40166,"public IMethod defineCodeBodyCode(String clsName,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}","public IMethod defineCodeBodyCode(String clsName,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}",0.9591397849462364
40167,"JavaScriptMethodObject(IClass cls,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(cls,functionQualifiers,cfg,symtab,AstMethodReference.fnReference(cls.getReference()),hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo,null);
  symtab.getNullConstant();
}","JavaScriptMethodObject(IClass cls,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(cls,functionQualifiers,cfg,symtab,AstMethodReference.fnReference(cls.getReference()),hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo,null);
  symtab.getNullConstant();
}",0.976629766297663
40168,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9823911028730306
40169,"private void setupCatchTypes(SSACFG cfg,TypeReference[][] catchTypes){
  for (int i=0; i < catchTypes.length; i++) {
    if (catchTypes[i] != null) {
      ExceptionHandlerBasicBlock bb=(ExceptionHandlerBasicBlock)cfg.getNode(i);
      for (int j=0; j < catchTypes[i].length; j++) {
        bb.addCaughtExceptionType(catchTypes[i][j]);
      }
    }
  }
}","private void setupCatchTypes(SSACFG cfg,Map<IBasicBlock,TypeReference[]> map){
  for (  Map.Entry<IBasicBlock,TypeReference[]> e : map.entrySet()) {
    if (e.getKey().getNumber() != -1) {
      ExceptionHandlerBasicBlock bb=(ExceptionHandlerBasicBlock)cfg.getNode(e.getKey().getNumber());
      for (int j=0; j < e.getValue().length; j++) {
        bb.addCaughtExceptionType(e.getValue()[j]);
      }
    }
  }
}",0.6432291666666666
40170,"/** 
 * When adding an edge from source to target, it is possible that certain exception-handling code needs to be executed before the control is actually transfered to target. This method determines if this is the case, and if so, it generates the exception handler blocks and adds an appropriate edge to the target. It returns the basic block that should be the target of the edge from source (target itself if there is no exception-handling code, the initial catch block otherwise)
 */
public PreBasicBlock findOrCreateCode(PreBasicBlock source,PreBasicBlock target,final boolean exception){
  UnwindState sourceContext=unwindData.get(source);
  final CAstNode dummy=exception ? (new CAstImpl()).makeNode(CAstNode.EMPTY) : null;
  if (sourceContext == null)   return target;
  WalkContext astContext=sourceContext.astContext;
  UnwindState targetContext=null;
  if (target != null)   targetContext=unwindData.get(target);
  if (targetContext != null && targetContext.covers(sourceContext))   return target;
  Pair<UnwindState,Pair<PreBasicBlock,Boolean>> key=Pair.make(sourceContext,Pair.make(target,exception));
  if (code.containsKey(key)) {
    return code.get(key);
  }
 else {
    int e=-1;
    PreBasicBlock currentBlock=getCurrentBlock();
    if (!isDeadBlock(currentBlock)) {
      addInstruction(insts.GotoInstruction());
      newBlock(false);
    }
    PreBasicBlock startBlock=getCurrentBlock();
    if (exception) {
      setCurrentBlockAsHandler();
      e=sourceContext.astContext.currentScope().allocateTempValue();
      addInstruction(insts.GetCaughtExceptionInstruction(startBlock.getNumber(),e));
      sourceContext.astContext.setCatchType(startBlock.getNumber(),defaultCatchType());
    }
    while (sourceContext != null && (targetContext == null || !targetContext.covers(sourceContext))) {
      final CAstRewriter.Rewrite ast=(new CAstCloner(new CAstImpl()){
        protected CAstNode flowOutTo(        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap,        CAstNode oldSource,        Object label,        CAstNode oldTarget,        CAstControlFlowMap orig,        CAstSourcePositionMap src){
          if (exception && !isExceptionLabel(label)) {
            return dummy;
          }
 else {
            return oldTarget;
          }
        }
      }
).copy(sourceContext.unwindAst,sourceContext.astContext.getControlFlow(),sourceContext.astContext.getSourceMap(),sourceContext.astContext.top().getNodeTypeMap(),sourceContext.astContext.top().getAllScopedEntities());
      sourceContext.astVisitor.visit(ast.newRoot(),new DelegatingContext(sourceContext.astContext){
        public CAstSourcePositionMap getSourceMap(){
          return ast.newPos();
        }
        public CAstControlFlowMap getControlFlow(){
          return ast.newCfg();
        }
      }
,sourceContext.astVisitor);
      sourceContext=sourceContext.getParent();
    }
    PreBasicBlock endBlock=getCurrentBlock();
    if (exception) {
      addPreNode(dummy);
      doThrow(astContext,e);
    }
 else {
      addInstruction(insts.GotoInstruction());
    }
    newBlock(false);
    addEdge(currentBlock,getCurrentBlock());
    if (target != null) {
      addEdge(endBlock,target);
    }
 else {
      addDelayedEdge(endBlock,exitMarker,exception);
    }
    code.put(key,startBlock);
    return startBlock;
  }
}","/** 
 * When adding an edge from source to target, it is possible that certain exception-handling code needs to be executed before the control is actually transfered to target. This method determines if this is the case, and if so, it generates the exception handler blocks and adds an appropriate edge to the target. It returns the basic block that should be the target of the edge from source (target itself if there is no exception-handling code, the initial catch block otherwise)
 */
public PreBasicBlock findOrCreateCode(PreBasicBlock source,PreBasicBlock target,final boolean exception){
  UnwindState sourceContext=unwindData.get(source);
  final CAstNode dummy=exception ? (new CAstImpl()).makeNode(CAstNode.EMPTY) : null;
  if (sourceContext == null)   return target;
  WalkContext astContext=sourceContext.astContext;
  UnwindState targetContext=null;
  if (target != null)   targetContext=unwindData.get(target);
  if (targetContext != null && targetContext.covers(sourceContext))   return target;
  Pair<UnwindState,Pair<PreBasicBlock,Boolean>> key=Pair.make(sourceContext,Pair.make(target,exception));
  if (code.containsKey(key)) {
    return code.get(key);
  }
 else {
    int e=-1;
    PreBasicBlock currentBlock=getCurrentBlock();
    if (!isDeadBlock(currentBlock)) {
      addInstruction(insts.GotoInstruction());
      newBlock(false);
    }
    PreBasicBlock startBlock=getCurrentBlock();
    if (exception) {
      setCurrentBlockAsHandler();
      e=sourceContext.astContext.currentScope().allocateTempValue();
      addInstruction(insts.GetCaughtExceptionInstruction(startBlock.getNumber(),e));
      sourceContext.astContext.setCatchType(startBlock,defaultCatchType());
    }
    while (sourceContext != null && (targetContext == null || !targetContext.covers(sourceContext))) {
      final CAstRewriter.Rewrite ast=(new CAstCloner(new CAstImpl()){
        protected CAstNode flowOutTo(        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap,        CAstNode oldSource,        Object label,        CAstNode oldTarget,        CAstControlFlowMap orig,        CAstSourcePositionMap src){
          if (exception && !isExceptionLabel(label)) {
            return dummy;
          }
 else {
            return oldTarget;
          }
        }
      }
).copy(sourceContext.unwindAst,sourceContext.astContext.getControlFlow(),sourceContext.astContext.getSourceMap(),sourceContext.astContext.top().getNodeTypeMap(),sourceContext.astContext.top().getAllScopedEntities());
      sourceContext.astVisitor.visit(ast.newRoot(),new DelegatingContext(sourceContext.astContext){
        public CAstSourcePositionMap getSourceMap(){
          return ast.newPos();
        }
        public CAstControlFlowMap getControlFlow(){
          return ast.newCfg();
        }
      }
,sourceContext.astVisitor);
      sourceContext=sourceContext.getParent();
    }
    PreBasicBlock endBlock=getCurrentBlock();
    if (exception) {
      addPreNode(dummy);
      doThrow(astContext,e);
    }
 else {
      addInstruction(insts.GotoInstruction());
    }
    newBlock(false);
    addEdge(currentBlock,getCurrentBlock());
    if (target != null) {
      addEdge(endBlock,target);
    }
 else {
      addDelayedEdge(endBlock,exitMarker,exception);
    }
    code.put(key,startBlock);
    return startBlock;
  }
}",0.99818676337262
40171,"/** 
 * fully define a function. invoked after all the code of the function has been processed
 */
protected abstract void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo);","/** 
 * fully define a function. invoked after all the code of the function has been processed
 */
protected abstract void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo);",0.9555555555555556
40172,"public TypeReference[][] getCatchTypes(){
  return null;
}","public Map<IBasicBlock,TypeReference[]> getCatchTypes(){
  return null;
}",0.8549618320610687
40173,"public void closeFunctionEntity(final CAstEntity n,WalkContext parentContext,WalkContext functionContext){
  functionContext.cfg().makeExitBlock(functionContext.cfg().newBlock(true));
  SymbolTable symtab=((AbstractScope)functionContext.currentScope()).getUnderlyingSymtab();
  TypeReference[][] catchTypes=functionContext.getCatchTypes();
  AstCFG cfg=new AstCFG(n,functionContext.cfg(),symtab);
  Position[] line=functionContext.cfg().getLinePositionMap();
  boolean katch=functionContext.cfg().hasCatchBlock();
  boolean monitor=functionContext.cfg().hasMonitorOp();
  String[] nms=makeNameMap(n,functionContext.entityScopes());
  patchLexicalAccesses(cfg.getInstructions(),functionContext.getAccesses(n));
  AstLexicalInformation LI=new AstLexicalInformation(functionContext.getEntityName(n),(AbstractScope)functionContext.currentScope(),cfg.getInstructions(),functionContext.exposeNameSet(n,false),functionContext.exposeNameSet(n,true),functionContext.getAccesses(n));
  DebuggingInformation DBG=new AstDebuggingInformation(n.getPosition(),line,nms);
  defineFunction(n,parentContext,cfg,symtab,katch,catchTypes,monitor,LI,DBG);
}","public void closeFunctionEntity(final CAstEntity n,WalkContext parentContext,WalkContext functionContext){
  functionContext.cfg().makeExitBlock(functionContext.cfg().newBlock(true));
  SymbolTable symtab=((AbstractScope)functionContext.currentScope()).getUnderlyingSymtab();
  Map<IBasicBlock,TypeReference[]> catchTypes=functionContext.getCatchTypes();
  AstCFG cfg=new AstCFG(n,functionContext.cfg(),symtab);
  Position[] line=functionContext.cfg().getLinePositionMap();
  boolean katch=functionContext.cfg().hasCatchBlock();
  boolean monitor=functionContext.cfg().hasMonitorOp();
  String[] nms=makeNameMap(n,functionContext.entityScopes());
  patchLexicalAccesses(cfg.getInstructions(),functionContext.getAccesses(n));
  AstLexicalInformation LI=new AstLexicalInformation(functionContext.getEntityName(n),(AbstractScope)functionContext.currentScope(),cfg.getInstructions(),functionContext.exposeNameSet(n,false),functionContext.exposeNameSet(n,true),functionContext.getAccesses(n));
  DebuggingInformation DBG=new AstDebuggingInformation(n.getPosition(),line,nms);
  defineFunction(n,parentContext,cfg,symtab,katch,catchTypes,monitor,LI,DBG);
}",0.9916849015317286
40174,"public void copyState(BitVectorVariable other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (V == null) {
    if (other.V == null) {
      return;
    }
 else {
      V=new MutableSharedBitVectorIntSet(other.V);
      return;
    }
  }
  if (other.V != null) {
    V.copySet(other.V);
  }
}","public void copyState(BitVectorVariable other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (V == null) {
    if (other.V == null) {
      return;
    }
 else {
      V=new MutableSharedBitVectorIntSet(other.V);
      return;
    }
  }
  if (other.V != null) {
    V.copySet(other.V);
  }
 else {
    V=null;
  }
}",0.9627507163323782
40175,"@TestAnnotation(doSomething=""String_Node_Str"",count=1,date=""String_Node_Str"") public void mymethod(){
}","@TestAnnotation(doSomething=""String_Node_Str"",count=1,date=""String_Node_Str"",stuff={}) public int mymethod(){
  @AnotherTestAnnotation(""String_Node_Str"") int i=0;
  return i;
}",0.7168458781362007
40176,"@TestAnnotation(doSomething=""String_Node_Str"",count=0,date=""String_Node_Str"") public static void main(String[] args){
  (new Annotations()).mymethod();
}","@TestAnnotation(doSomething=""String_Node_Str"",count=0,date=""String_Node_Str"",stuff={1,2,3,4,5}) public static void main(String[] args){
  (new Annotations()).mymethod();
}",0.9444444444444444
40177,"public void check(CallGraph cg){
  classes:   for (  ClassAnnotation ca : classAnnotations) {
    IClass cls=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.className));
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.annotationTypeName));
    for (    Annotation a : cls.getAnnotations()) {
      if (a.getType().equals(at.getReference())) {
        continue classes;
      }
    }
    Assert.assertFalse(""String_Node_Str"" + at + ""String_Node_Str""+ cls,false);
  }
  for (  MethodAnnotation ma : methodAnnotations) {
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ma.annotationTypeName));
    annot:     for (    CGNode n : cg) {
      if (n.getMethod().getSignature().equals(ma.methodSig)) {
        for (        Annotation a : n.getMethod().getAnnotations()) {
          if (a.getType().equals(at.getReference())) {
            continue annot;
          }
        }
        Assert.assertFalse(""String_Node_Str"" + at,false);
      }
    }
  }
}","public void check(CallGraph cg){
  classes:   for (  ClassAnnotation ca : classAnnotations) {
    IClass cls=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.className));
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.annotationTypeName));
    for (    Annotation a : cls.getAnnotations()) {
      if (a.getType().equals(at.getReference())) {
        continue classes;
      }
    }
    Assert.assertFalse(""String_Node_Str"" + at + ""String_Node_Str""+ cls,false);
  }
  annot:   for (  MethodAnnotation ma : methodAnnotations) {
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ma.annotationTypeName));
    for (    CGNode n : cg) {
      if (n.getMethod().getSignature().equals(ma.methodSig)) {
        for (        Annotation a : n.getMethod().getAnnotations()) {
          if (a.getType().equals(at.getReference())) {
            continue annot;
          }
        }
        Assert.assertFalse(""String_Node_Str"" + at,false);
      }
    }
  }
}",0.9910793933987512
40178,"protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
  RhinoToAstTranslator translator=new RhinoToAstTranslator(ast,module,module.getName(),false);
  CAstEntity entity=translator.translateToCAst();
  return entity;
}","protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
}",0.5120481927710844
40179,"protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
  RhinoToAstTranslator translator=new RhinoToAstTranslator(ast,module,module.getName(),false);
  CAstEntity entity=translator.translateToCAst();
  return entity;
}","protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
}",0.5120481927710844
40180,"public static void main(String args[]) throws ClassHierarchyException, IllegalArgumentException, IOException, CancelException {
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  boolean domless=false;
  URL url=new URL(args[0]);
  JSCallGraphBuilderUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
  JavaScriptLoader.addBootstrapFile(WebUtil.preamble);
  SourceModule[] sources=getSources(domless,url);
  JSCFABuilder builder=makeCGBuilder(new WebPageLoaderFactory(translatorFactory),sources,CGBuilderType.ZERO_ONE_CFA,AstIRFactory.makeDefaultFactory());
  builder.setBaseURL(url);
  CallGraph cg=builder.makeCallGraph(builder.getOptions());
  PointerAnalysis pa=builder.getPointerAnalysis();
  new JsViewer(cg,pa);
}","public static void main(String args[]) throws ClassHierarchyException, IllegalArgumentException, IOException, CancelException, Error {
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  boolean domless=false;
  URL url=new URL(args[0]);
  JSCallGraphBuilderUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
  JavaScriptLoader.addBootstrapFile(WebUtil.preamble);
  SourceModule[] sources=getSources(domless,url);
  JSCFABuilder builder=makeCGBuilder(new WebPageLoaderFactory(translatorFactory),sources,CGBuilderType.ZERO_ONE_CFA,AstIRFactory.makeDefaultFactory());
  builder.setBaseURL(url);
  CallGraph cg=builder.makeCallGraph(builder.getOptions());
  PointerAnalysis pa=builder.getPointerAnalysis();
  new JsViewer(cg,pa);
}",0.9954983922829582
40181,"private static SourceModule[] getSources(boolean domless,URL url) throws IOException {
  JSSourceExtractor sourceExtractor;
  if (domless) {
    sourceExtractor=new DomLessSourceExtractor();
  }
 else {
    sourceExtractor=new DefaultSourceExtractor();
  }
  Set<MappedSourceModule> sourcesMap=sourceExtractor.extractSources(url,new JerichoHtmlParser(),new IdentityUrlResolver());
  SourceModule[] sources=new SourceFileModule[sourcesMap.size()];
  int i=0;
  for (  SourceModule m : sourcesMap) {
    sources[i++]=m;
  }
  return sources;
}","private static SourceModule[] getSources(boolean domless,URL url) throws IOException, Error {
  JSSourceExtractor sourceExtractor;
  if (domless) {
    sourceExtractor=new DomLessSourceExtractor();
  }
 else {
    sourceExtractor=new DefaultSourceExtractor();
  }
  Set<MappedSourceModule> sourcesMap=sourceExtractor.extractSources(url,new JerichoHtmlParser(),new IdentityUrlResolver());
  SourceModule[] sources=new SourceFileModule[sourcesMap.size()];
  int i=0;
  for (  SourceModule m : sourcesMap) {
    sources[i++]=m;
  }
  return sources;
}",0.9935720844811754
40182,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  try {
    return URLDecoder.decode(uri.getPath(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}",0.8748370273794003
40183,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  try {
    return URLDecoder.decode(uri.getPath(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    URI uri=new File(URLDecoder.decode(url.getPath(),""String_Node_Str"")).toURI();
    return uri.getPath();
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}",0.9455864570737604
40184,"private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(propertyReadResult,4,constVN));
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(propertyReadResult,4,constVN));
    S.getNextProgramCounter();
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9690927218344964
40185,"@Override public byte evaluate(final BitVectorVariable lhs,final BitVectorVariable[] rhs){
  IntSet intersect=lhs.getValue();
  if (intersect == null || intersect.isEmpty()) {
    return NOT_CHANGED_AND_FIXED;
  }
  for (  final BitVectorVariable bv : rhs) {
    final IntSet vlhs=bv.getValue();
    intersect=intersect.intersection(vlhs);
  }
  if (intersect.sameValue(lhs.getValue())) {
    return NOT_CHANGED;
  }
 else {
    final BitVectorVariable bvv=new BitVectorVariable();
    intersect.foreach(new IntSetAction(){
      @Override public void act(      final int x){
        bvv.set(x);
      }
    }
);
    lhs.copyState(bvv);
    return CHANGED;
  }
}","@Override public byte evaluate(final BitVectorVariable lhs,final BitVectorVariable[] rhs){
  IntSet intersect=lhs.getValue();
  if (intersect == null || intersect.isEmpty()) {
    intersect=rhs[0].getValue();
  }
  for (  final BitVectorVariable bv : rhs) {
    final IntSet vlhs=bv.getValue();
    intersect=intersect.intersection(vlhs);
  }
  if (lhs.getValue() != null && intersect.sameValue(lhs.getValue())) {
    return NOT_CHANGED;
  }
 else {
    final BitVectorVariable bvv=new BitVectorVariable();
    intersect.foreach(new IntSetAction(){
      @Override public void act(      final int x){
        bvv.set(x);
      }
    }
);
    lhs.copyState(bvv);
    return CHANGED;
  }
}",0.3261675315048183
40186,"@Override public void run(){
  try {
    boolean repeat=true;
    while (repeat) {
      try {
        Thread.sleep(SLEEP_MS);
      }
 catch (      InterruptedException e1) {
      }
      drain();
      try {
        p.exitValue();
        repeat=false;
        drain();
        if (logger != null) {
          logger.fine(""String_Node_Str"" + p.exitValue());
        }
      }
 catch (      IllegalThreadStateException e) {
        repeat=true;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    boolean repeat=true;
    while (repeat) {
      try {
        Thread.sleep(SLEEP_MS);
      }
 catch (      InterruptedException e1) {
      }
      drain();
      try {
        p.exitValue();
        repeat=false;
        blockingDrain();
        if (logger != null) {
          logger.fine(""String_Node_Str"" + p.exitValue());
        }
      }
 catch (      IllegalThreadStateException e) {
        repeat=true;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9904942965779469
40187,abstract void drain() throws IOException ;,"/** 
 * Drain data from the stream, but don't block.
 */
abstract void drain() throws IOException ;",0.5957446808510638
40188,"protected Drainer captureStdErr(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}","protected Drainer captureStdErr(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}",0.8873563218390804
40189,"private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Drain some data from the input stream, and append said data to b.  Do not block.
 */
private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}",0.8571428571428571
40190,"protected Thread drainStdErr(Process p){
  final BufferedInputStream err=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(err,System.err);
    }
  }
;
  result.start();
  return result;
}","protected Thread drainStdErr(Process p){
  final BufferedInputStream err=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(err,System.err);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndPrint(err,System.err);
    }
  }
;
  result.start();
  return result;
}",0.8464849354375896
40191,"protected Thread drainStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(out,System.out);
    }
  }
;
  result.start();
  return result;
}","protected Thread drainStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(out,System.out);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndPrint(out,System.out);
    }
  }
;
  result.start();
  return result;
}",0.8464849354375896
40192,"protected Drainer captureStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}","protected Drainer captureStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}",0.8873563218390804
40193,"private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Drain some data from the input stream, and print said data to p.  Do not block.
 */
private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}",0.8511326860841424
40194,"/** 
 * Process an element indicating a new allocation site.
 * @param atts
 */
private void processAllocation(Attributes atts){
  Language lang=scope.getLanguage(governingLoader.getLanguage());
  SSAInstructionFactory insts=lang.instructionFactory();
  String classString=atts.getValue(A_CLASS);
  final TypeReference type=TypeReference.findOrCreate(governingLoader,TypeName.string2TypeName(classString));
  String defVar=atts.getValue(A_DEF);
  if (symbolTable.keySet().contains(defVar)) {
    Assertions.UNREACHABLE(""String_Node_Str"" + defVar + ""String_Node_Str""+ governingMethod);
  }
  if (defVar == null) {
    defVar=""String_Node_Str"" + nextLocal;
  }
  int defNum=nextLocal;
  symbolTable.put(defVar,new Integer(nextLocal++));
  NewSiteReference ref=NewSiteReference.make(governingMethod.getNextProgramCounter(),type);
  SSANewInstruction a=null;
  if (type.isArrayType()) {
    String size=atts.getValue(A_SIZE);
    Assertions.productionAssertion(size != null);
    Integer sNumber=symbolTable.get(size);
    Assertions.productionAssertion(sNumber != null);
    Assertions.productionAssertion(type.getDerivedMask() == ArrayMask || type.getDerivedMask() == ((ArrayMask << 2) | PrimitiveMask));
    a=insts.NewInstruction(defNum,ref,new int[]{sNumber.intValue()});
  }
 else {
    a=insts.NewInstruction(defNum,ref);
  }
  governingMethod.addStatement(a);
}","/** 
 * Process an element indicating a new allocation site.
 * @param atts
 */
private void processAllocation(Attributes atts){
  Language lang=scope.getLanguage(governingLoader.getLanguage());
  SSAInstructionFactory insts=lang.instructionFactory();
  String classString=atts.getValue(A_CLASS);
  final TypeReference type=TypeReference.findOrCreate(governingLoader,TypeName.string2TypeName(classString));
  String defVar=atts.getValue(A_DEF);
  if (symbolTable.keySet().contains(defVar)) {
    Assertions.UNREACHABLE(""String_Node_Str"" + defVar + ""String_Node_Str""+ governingMethod);
  }
  if (defVar == null) {
    defVar=""String_Node_Str"" + nextLocal;
  }
  int defNum=nextLocal;
  symbolTable.put(defVar,new Integer(nextLocal++));
  NewSiteReference ref=NewSiteReference.make(governingMethod.getNextProgramCounter(),type);
  SSANewInstruction a=null;
  if (type.isArrayType()) {
    String size=atts.getValue(A_SIZE);
    Assertions.productionAssertion(size != null);
    Integer sNumber=symbolTable.get(size);
    Assertions.productionAssertion(sNumber != null);
    Assertions.productionAssertion(type.getDerivedMask() == ArrayMask || type.getDerivedMask() == ((ArrayMask << ElementBits) | PrimitiveMask));
    a=insts.NewInstruction(defNum,ref,new int[]{sNumber.intValue()});
  }
 else {
    a=insts.NewInstruction(defNum,ref);
  }
  governingMethod.addStatement(a);
}",0.9956204379562044
40195,"/** 
 * @throws FileNotFoundException
 */
public static File getFileFromClassLoader(String fileName,ClassLoader loader) throws FileNotFoundException {
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + url + ""String_Node_Str""+ fileName));
  }
  if (url == null) {
    File f=new File(fileName);
    if (f.exists()) {
      return f;
    }
    throw new FileNotFoundException(fileName);
  }
 else {
    return new File(filePathFromURL(url));
  }
}","/** 
 * @throws FileNotFoundException
 */
public static File getFileFromClassLoader(String fileName,ClassLoader loader) throws FileNotFoundException {
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=null;
  try {
    url=loader.getResource(fileName);
  }
 catch (  Exception e) {
  }
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + url + ""String_Node_Str""+ fileName));
  }
  if (url == null) {
    File f=new File(fileName);
    if (f.exists()) {
      return f;
    }
    throw new FileNotFoundException(fileName);
  }
 else {
    return new File(filePathFromURL(url));
  }
}",0.96113074204947
40196,"protected void iterateCrossProduct(final CGNode caller,final CallSiteReference site,IntSet parameters,final InstanceKey[][] invariants,final VoidFunction<InstanceKey[]> f){
  final IR ir=caller.getIR();
  final int params[]=IntSetUtil.toArray(parameters);
  for (  final SSAAbstractInvokeInstruction call : ir.getCalls(site)) {
    final InstanceKey[] keys=new InstanceKey[call.getNumberOfParameters()];
    new Object(){
      private void rec(      final int pi){
        if (pi == params.length) {
          f.apply(keys);
        }
 else {
          final int p=params[pi];
          int vn=call.getUse(p);
          PointerKey var=getPointerKeyForLocal(caller,vn);
          InstanceKey[] ik=invariants != null ? invariants[p] : null;
          if (ik != null) {
            if (ik.length > 0) {
              for (int i=0; i < ik.length; i++) {
                system.findOrCreateIndexForInstanceKey(ik[i]);
                keys[p]=ik[i];
                rec(pi + 1);
              }
            }
 else {
              if (!site.isDispatch() || p != 0) {
                keys[p]=null;
                rec(pi + 1);
              }
            }
          }
 else {
            IntSet s=system.findOrCreatePointsToSet(var).getValue();
            if (s != null && !s.isEmpty()) {
              s.foreach(new IntSetAction(){
                public void act(                int x){
                  keys[p]=system.getInstanceKey(x);
                  rec(pi + 1);
                }
              }
);
            }
 else {
              if (!site.isDispatch() || p != 0) {
                keys[p]=null;
                rec(pi + 1);
              }
            }
          }
        }
      }
    }
.rec(0);
  }
}","protected void iterateCrossProduct(final CGNode caller,final SSAAbstractInvokeInstruction call,IntSet parameters,final InstanceKey[][] invariants,final VoidFunction<InstanceKey[]> f){
  final int params[]=IntSetUtil.toArray(parameters);
  final InstanceKey[] keys=new InstanceKey[call.getNumberOfParameters()];
  final CallSiteReference site=call.getCallSite();
  new Object(){
    private void rec(    final int pi){
      if (pi == params.length) {
        f.apply(keys);
      }
 else {
        final int p=params[pi];
        int vn=call.getUse(p);
        PointerKey var=getPointerKeyForLocal(caller,vn);
        InstanceKey[] ik=invariants != null ? invariants[p] : null;
        if (ik != null) {
          if (ik.length > 0) {
            for (int i=0; i < ik.length; i++) {
              system.findOrCreateIndexForInstanceKey(ik[i]);
              keys[p]=ik[i];
              rec(pi + 1);
            }
          }
 else {
            if (!site.isDispatch() || p != 0) {
              keys[p]=null;
              rec(pi + 1);
            }
          }
        }
 else {
          IntSet s=system.findOrCreatePointsToSet(var).getValue();
          if (s != null && !s.isEmpty()) {
            s.foreach(new IntSetAction(){
              public void act(              int x){
                keys[p]=system.getInstanceKey(x);
                rec(pi + 1);
              }
            }
);
          }
 else {
            if (!site.isDispatch() || p != 0) {
              keys[p]=null;
              rec(pi + 1);
            }
          }
        }
      }
    }
  }
.rec(0);
}",0.8460606060606061
40197,"protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction,InvariantComputer invs){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  InstanceKey[][] invariantParameters=invs.computeInvariantParameters(instruction);
  if (instruction.getCallSite().isStatic()) {
    for (    CGNode n : getBuilder().getTargetsForCall(node,instruction.getCallSite(),invariantParameters)) {
      getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    IntSet params=getBuilder().getContextSelector().getRelevantParameters(node,instruction.getCallSite());
    if (!params.contains(0)) {
      params=IntSetUtil.makeMutableCopy(params);
      ((MutableIntSet)params).add(0);
    }
    final int vns[]=new int[params.size()];
    params.foreach(new IntSetAction(){
      private int i=0;
      public void act(      int x){
        vns[i++]=instruction.getUse(x);
      }
    }
);
    if (contentsAreInvariant(symbolTable,du,vns)) {
      for (      CGNode n : getBuilder().getTargetsForCall(node,instruction.getCallSite(),invariantParameters)) {
        getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
        processClassInitializer(n.getMethod().getDeclaringClass());
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ params);
      }
      final List<PointerKey> pks=new ArrayList<PointerKey>(params.size());
      params.foreach(new IntSetAction(){
        public void act(        int x){
          if (!contentsAreInvariant(symbolTable,du,instruction.getUse(x))) {
            pks.add(getBuilder().getPointerKeyForLocal(node,instruction.getUse(x)));
          }
        }
      }
);
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,invariantParameters,uniqueCatch,params);
      system.newSideEffect(dispatchOperator,pks.toArray(new PointerKey[pks.size()]));
    }
  }
}","protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction,InvariantComputer invs){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  InstanceKey[][] invariantParameters=invs.computeInvariantParameters(instruction);
  if (instruction.getCallSite().isStatic()) {
    for (    CGNode n : getBuilder().getTargetsForCall(node,instruction,invariantParameters)) {
      getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    IntSet params=getBuilder().getContextSelector().getRelevantParameters(node,instruction.getCallSite());
    if (!params.contains(0)) {
      params=IntSetUtil.makeMutableCopy(params);
      ((MutableIntSet)params).add(0);
    }
    final int vns[]=new int[params.size()];
    params.foreach(new IntSetAction(){
      private int i=0;
      public void act(      int x){
        vns[i++]=instruction.getUse(x);
      }
    }
);
    if (contentsAreInvariant(symbolTable,du,vns)) {
      for (      CGNode n : getBuilder().getTargetsForCall(node,instruction,invariantParameters)) {
        getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
        processClassInitializer(n.getMethod().getDeclaringClass());
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ params);
      }
      final List<PointerKey> pks=new ArrayList<PointerKey>(params.size());
      params.foreach(new IntSetAction(){
        public void act(        int x){
          if (!contentsAreInvariant(symbolTable,du,instruction.getUse(x))) {
            pks.add(getBuilder().getPointerKeyForLocal(node,instruction.getUse(x)));
          }
        }
      }
);
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,invariantParameters,uniqueCatch,params);
      system.newSideEffect(dispatchOperator,pks.toArray(new PointerKey[pks.size()]));
    }
  }
}",0.9938811188811189
40198,"protected Set<CGNode> getTargetsForCall(final CGNode caller,final CallSiteReference site,InstanceKey[][] invs){
  IntSet params=contextSelector.getRelevantParameters(caller,site);
  if (!site.isStatic() && !params.contains(0)) {
    params=IntSetUtil.makeMutableCopy(params);
    ((MutableIntSet)params).add(0);
  }
  final Set<CGNode> targets=HashSetFactory.make();
  VoidFunction<InstanceKey[]> f=new VoidFunction<InstanceKey[]>(){
    public void apply(    InstanceKey[] v){
      IClass recv=null;
      if (site.isDispatch()) {
        recv=v[0].getConcreteType();
      }
      CGNode target=getTargetForCall(caller,site,recv,v);
      if (target != null) {
        targets.add(target);
      }
    }
  }
;
  iterateCrossProduct(caller,site,params,invs,f);
  return targets;
}","protected Set<CGNode> getTargetsForCall(final CGNode caller,final SSAAbstractInvokeInstruction instruction,InstanceKey[][] invs){
  final CallSiteReference site=instruction.getCallSite();
  IntSet params=contextSelector.getRelevantParameters(caller,site);
  if (!site.isStatic() && !params.contains(0)) {
    params=IntSetUtil.makeMutableCopy(params);
    ((MutableIntSet)params).add(0);
  }
  final Set<CGNode> targets=HashSetFactory.make();
  VoidFunction<InstanceKey[]> f=new VoidFunction<InstanceKey[]>(){
    public void apply(    InstanceKey[] v){
      IClass recv=null;
      if (site.isDispatch()) {
        recv=v[0].getConcreteType();
      }
      CGNode target=getTargetForCall(caller,site,recv,v);
      if (target != null) {
        targets.add(target);
      }
    }
  }
;
  iterateCrossProduct(caller,instruction,params,invs,f);
  return targets;
}",0.918032786885246
40199,"public IField getField(Atom name){
  if (declaredFields.containsKey(name)) {
    return declaredFields.get(name);
  }
 else   if (getSuperclass() != null) {
    return getSuperclass().getField(name);
  }
 else {
    return null;
  }
}","public IField getField(Atom name,TypeName type){
  return getField(name);
}",0.3948220064724919
40200,"public IField getField(Atom name){
  return loader.lookupClass(superReference.getName()).getField(name);
}","public IField getField(Atom name,TypeName type){
  return loader.lookupClass(superReference.getName()).getField(name);
}",0.9380530973451328
40201,"private boolean isNamedVar(CAstNode n,String name){
  if (n.getKind() == CAstNode.VAR) {
    String nm=(String)n.getChild(0).getValue();
    return nm.equals(name);
  }
  return false;
}","private boolean isNamedVar(CAstNode n,Pattern namePattern){
  if (n.getKind() == CAstNode.VAR) {
    String nm=(String)n.getChild(0).getValue();
    return namePattern.matcher(nm).matches();
  }
  return false;
}",0.7135678391959799
40202,"@Override protected String[] getArgumentNames(CAstEntity f){
  if (super.getArgumentCount(f) >= v.getValue()) {
    return super.getArgumentNames(f);
  }
 else {
    String[] argNames=new String[v.getValue()];
    System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
    for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
      argNames[i]=""String_Node_Str"" + (i + 1);
    }
    return argNames;
  }
}","@Override protected String[] getArgumentNames(CAstEntity f){
  if (super.getArgumentCount(f) >= v.getValue()) {
    return super.getArgumentNames(f);
  }
 else {
    String[] argNames=new String[v.getValue()];
    System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
    for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
      argNames[i]=""String_Node_Str"" + i;
    }
    return argNames;
  }
}",0.990990990990991
40203,"@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e=m.getEntity();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
        }
        private boolean isNamedVar(        CAstNode n,        String name){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return nm.equals(name);
          }
          return false;
        }
        private Object getIndexFromArgumentRef(        CAstNode n){
          if (n.getKind() == CAstNode.OBJECT_REF || n.getKind() == CAstNode.ARRAY_REF) {
            if (isNamedVar(n.getChild(0),""String_Node_Str"")) {
              return n.getChild(1).getValue();
            }
          }
          return null;
        }
        private Object getIndexFromBaseVar(        CAstNode n){
          if (n.getKind() == CAstNode.BLOCK_EXPR) {
            if (n.getChildCount() == 2) {
              CAstNode c1=n.getChild(0);
              if (c1.getKind() == CAstNode.ASSIGN) {
                if (isNamedVar(c1.getChild(0),""String_Node_Str"")) {
                  if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
                    CAstNode c2=n.getChild(1);
                    if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
                      if (isNamedVar(c2.getChild(0),""String_Node_Str"")) {
                        return c2.getChild(1).getValue();
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }
        private Object getStaticArgumentIndex(        CAstNode n){
          Object x=getIndexFromArgumentRef(n);
          if (x != null) {
            return x;
          }
 else {
            return getIndexFromBaseVar(n);
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=getStaticArgumentIndex(n);
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 3;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          if (root.getKind() == CAstNode.ARRAY_REF || root.getKind() == CAstNode.OBJECT_REF || root.getKind() == CAstNode.BLOCK_EXPR) {
            result=handleArgumentRef(root);
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + (i + 1);
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}","@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e=m.getEntity();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
        }
        private boolean isNamedVar(        CAstNode n,        String name){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return nm.equals(name);
          }
          return false;
        }
        private boolean isNamedVar(        CAstNode n,        Pattern namePattern){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return namePattern.matcher(nm).matches();
          }
          return false;
        }
        private Object getIndexFromArgumentRef(        CAstNode n){
          if (n.getKind() == CAstNode.OBJECT_REF || n.getKind() == CAstNode.ARRAY_REF) {
            if (isNamedVar(n.getChild(0),""String_Node_Str"")) {
              return n.getChild(1).getValue();
            }
          }
          return null;
        }
        private Object getIndexFromBaseVar(        CAstNode n){
          if (n.getKind() == CAstNode.BLOCK_EXPR) {
            if (n.getChildCount() == 2) {
              CAstNode c1=n.getChild(0);
              if (c1.getKind() == CAstNode.ASSIGN) {
                if (isNamedVar(c1.getChild(0),baseNameRegex)) {
                  if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
                    CAstNode c2=n.getChild(1);
                    if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
                      if (isNamedVar(c2.getChild(0),baseNameRegex)) {
                        return c2.getChild(1).getValue();
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }
        private Object getStaticArgumentIndex(        CAstNode n){
          Object x=getIndexFromArgumentRef(n);
          if (x != null) {
            return x;
          }
 else {
            return getIndexFromBaseVar(n);
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=getStaticArgumentIndex(n);
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          if (root.getKind() == CAstNode.ARRAY_REF || root.getKind() == CAstNode.OBJECT_REF || root.getKind() == CAstNode.BLOCK_EXPR) {
            result=handleArgumentRef(root);
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}",0.9751522362987332
40204,"private CAstNode handleArgumentRef(CAstNode n){
  Object x=getStaticArgumentIndex(n);
  if (x != null) {
    if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
      int arg=((Number)x).intValue() + 3;
      if (arg < e.getArgumentCount()) {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
      }
 else {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
      }
    }
 else     if (x instanceof String && ""String_Node_Str"".equals(x)) {
      return Ast.makeConstant(v.getValue());
    }
  }
  return null;
}","private CAstNode handleArgumentRef(CAstNode n){
  Object x=getStaticArgumentIndex(n);
  if (x != null) {
    if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
      int arg=((Number)x).intValue() + 2;
      if (arg < e.getArgumentCount()) {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
      }
 else {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
      }
    }
 else     if (x instanceof String && ""String_Node_Str"".equals(x)) {
      return Ast.makeConstant(v.getValue());
    }
  }
  return null;
}",0.9983443708609272
40205,"private Object getIndexFromBaseVar(CAstNode n){
  if (n.getKind() == CAstNode.BLOCK_EXPR) {
    if (n.getChildCount() == 2) {
      CAstNode c1=n.getChild(0);
      if (c1.getKind() == CAstNode.ASSIGN) {
        if (isNamedVar(c1.getChild(0),""String_Node_Str"")) {
          if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
            CAstNode c2=n.getChild(1);
            if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
              if (isNamedVar(c2.getChild(0),""String_Node_Str"")) {
                return c2.getChild(1).getValue();
              }
            }
          }
        }
      }
    }
  }
  return null;
}","private Object getIndexFromBaseVar(CAstNode n){
  if (n.getKind() == CAstNode.BLOCK_EXPR) {
    if (n.getChildCount() == 2) {
      CAstNode c1=n.getChild(0);
      if (c1.getKind() == CAstNode.ASSIGN) {
        if (isNamedVar(c1.getChild(0),baseNameRegex)) {
          if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
            CAstNode c2=n.getChild(1);
            if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
              if (isNamedVar(c2.getChild(0),baseNameRegex)) {
                return c2.getChild(1).getValue();
              }
            }
          }
        }
      }
    }
  }
  return null;
}",0.9542682926829268
40206,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey[] receiver){
  IClass declaringClass=callee.getDeclaringClass();
  IMethod method=declaringClass.getMethod(AstMethodReference.fnSelector);
  Context baseCtxt=base.getCalleeTarget(caller,site,callee,receiver);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      boolean isNonNullArray=false;
      if (receiver.length >= 4) {
        InstanceKey argsList=receiver[3];
        if (argsList != null && argsList.getConcreteType().equals(caller.getClassHierarchy().lookupClass(JavaScriptTypes.Array))) {
          isNonNullArray=true;
        }
      }
      if (USE_ONE_LEVEL_CALLSTRING)       baseCtxt=new DelegatingContext(oneLevel.getCalleeTarget(caller,site,callee,receiver),baseCtxt);
      return new ApplyContext(baseCtxt,isNonNullArray);
    }
  }
  return baseCtxt;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey[] receiver){
  IClass declaringClass=callee.getDeclaringClass();
  IMethod method=declaringClass.getMethod(AstMethodReference.fnSelector);
  Context baseCtxt=base.getCalleeTarget(caller,site,callee,receiver);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      boolean isNonNullArray=false;
      if (receiver.length >= 4) {
        InstanceKey argsList=receiver[3];
        if (argsList != null && argsList.getConcreteType().equals(caller.getClassHierarchy().lookupClass(JavaScriptTypes.Array))) {
          isNonNullArray=true;
        }
      }
      if (USE_ONE_LEVEL)       baseCtxt=oneLevel.getCalleeTarget(caller,site,callee,receiver);
      return new ApplyContext(baseCtxt,isNonNullArray);
    }
  }
  return baseCtxt;
}",0.9079297498669504
40207,"@Override public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass receiver){
  IMethod method=receiver.getMethod(AstMethodReference.fnSelector);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      final MethodReference ref=genSyntheticMethodRef(receiver);
      JavaScriptSummary S=new JavaScriptSummary(ref,1);
      return new JavaScriptSummarizedFunction(ref,S,receiver);
    }
  }
  return base.getCalleeTarget(caller,site,receiver);
}","@Override public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass receiver){
  IMethod method=receiver.getMethod(AstMethodReference.fnSelector);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      if (applyMethod == null) {
        applyMethod=createApplyDummyMethod(receiver);
      }
      return applyMethod;
    }
  }
  return base.getCalleeTarget(caller,site,receiver);
}",0.6416906820365034
40208,"@SuppressWarnings(""String_Node_Str"") public static void dumpCG(PointerAnalysis PA,CallGraph CG){
  if (AVOID_DUMP)   return;
  for (Iterator x=CG.iterator(); x.hasNext(); ) {
    CGNode N=(CGNode)x.next();
    System.err.print(""String_Node_Str"" + getShortName(N) + ""String_Node_Str"");
    boolean fst=true;
    for (Iterator<? extends CGNode> ns=CG.getSuccNodes(N); ns.hasNext(); ) {
      if (fst)       fst=false;
 else       System.err.print(""String_Node_Str"");
      System.err.print(getShortName(ns.next()));
    }
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + N.getGraphNodeId());
    IR ir=N.getIR();
    if (ir != null) {
      System.err.println(ir);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  System.err.println(""String_Node_Str"");
  for (Iterator x=PA.getPointerKeys().iterator(); x.hasNext(); ) {
    PointerKey n=(PointerKey)x.next();
    try {
      System.err.println((n + ""String_Node_Str"" + PA.getPointsToSet(n)));
    }
 catch (    Throwable e) {
      System.err.println((""String_Node_Str"" + n));
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public static void dumpCG(PointerAnalysis PA,CallGraph CG){
  if (AVOID_DUMP)   return;
  for (Iterator x=CG.iterator(); x.hasNext(); ) {
    CGNode N=(CGNode)x.next();
    System.err.print(""String_Node_Str"" + getShortName(N) + ""String_Node_Str"");
    boolean fst=true;
    for (Iterator<? extends CGNode> ns=CG.getSuccNodes(N); ns.hasNext(); ) {
      if (fst)       fst=false;
 else       System.err.print(""String_Node_Str"");
      System.err.print(getShortName(ns.next()));
    }
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + N.getGraphNodeId() + ""String_Node_Str""+ N.getContext());
    IR ir=N.getIR();
    if (ir != null) {
      System.err.println(ir);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  System.err.println(""String_Node_Str"");
  for (Iterator x=PA.getPointerKeys().iterator(); x.hasNext(); ) {
    PointerKey n=(PointerKey)x.next();
    try {
      System.err.println((n + ""String_Node_Str"" + PA.getPointsToSet(n)));
    }
 catch (    Throwable e) {
      System.err.println((""String_Node_Str"" + n));
    }
  }
}",0.9838274932614556
40209,"@Before public void setUp(){
  com.ibm.wala.cast.js.ipa.callgraph.Util.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}","@Before public void setUp(){
  JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}",0.8620689655172413
40210,"@Before public void setUp(){
  com.ibm.wala.cast.js.ipa.callgraph.Util.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}","@Before public void setUp(){
  JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}",0.8620689655172413
40211,"@Test public void testTranslateToCAstCrash3() throws IllegalArgumentException, IOException, CancelException {
  Util.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTranslateToCAstCrash3() throws IllegalArgumentException, IOException, CancelException {
  JSCallGraphBuilderUtil.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
}",0.949438202247191
40212,"@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException, ClassHierarchyException {
  JavaScriptLoaderFactory loaders=Util.makeLoaders();
  AnalysisScope scope=Util.makeScriptScope(""String_Node_Str"",""String_Node_Str"",loaders);
  IClassHierarchy cha=Util.makeHierarchy(scope,loaders);
  com.ibm.wala.cast.js.util.Util.checkForFrontEndErrors(cha);
  Iterable<Entrypoint> roots=Util.makeScriptRoots(cha);
  JSAnalysisOptions options=Util.makeOptions(scope,cha,roots);
  AnalysisCache cache=Util.makeCache(new ArgumentSpecialization.ArgumentCountIRFactory(options.getSSAOptions()));
  JSCFABuilder builder=new JSZeroOrOneXCFABuilder(cha,options,cache,null,null,ZeroXInstanceKeys.ALLOCATIONS,false);
  builder.setContextSelector(new ArgumentSpecialization.ArgumentCountContextSelector(builder.getContextSelector()));
  builder.setContextInterpreter(new ArgumentSpecialization.ArgumentSpecializationContextIntepreter(options,cache));
  CallGraph CG=builder.makeCallGraph(options);
  Util.AVOID_DUMP=false;
  Util.dumpCG(builder.getPointerAnalysis(),CG);
  verifyGraphAssertions(CG,assertionsForArgs);
}","@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException, ClassHierarchyException {
  JavaScriptLoaderFactory loaders=JSCallGraphBuilderUtil.makeLoaders();
  AnalysisScope scope=JSCallGraphBuilderUtil.makeScriptScope(""String_Node_Str"",""String_Node_Str"",loaders);
  IClassHierarchy cha=JSCallGraphBuilderUtil.makeHierarchy(scope,loaders);
  com.ibm.wala.cast.js.util.Util.checkForFrontEndErrors(cha);
  Iterable<Entrypoint> roots=JSCallGraphBuilderUtil.makeScriptRoots(cha);
  JSAnalysisOptions options=JSCallGraphBuilderUtil.makeOptions(scope,cha,roots);
  AnalysisCache cache=JSCallGraphBuilderUtil.makeCache(new ArgumentSpecialization.ArgumentCountIRFactory(options.getSSAOptions()));
  JSCFABuilder builder=new JSZeroOrOneXCFABuilder(cha,options,cache,null,null,ZeroXInstanceKeys.ALLOCATIONS,false);
  builder.setContextSelector(new ArgumentSpecialization.ArgumentCountContextSelector(builder.getContextSelector()));
  builder.setContextInterpreter(new ArgumentSpecialization.ArgumentSpecializationContextIntepreter(options,cache));
  CallGraph CG=builder.makeCallGraph(options);
  CAstCallGraphUtil.AVOID_DUMP=false;
  CAstCallGraphUtil.dumpCG(builder.getPointerAnalysis(),CG);
  verifyGraphAssertions(CG,assertionsForArgs);
}",0.9440267335004175
40213,"@Test public void testEx1() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  JSCFABuilder builder=Util.makeHTMLCGBuilder(url);
  CallGraph CG=builder.makeCallGraph(builder.getOptions());
  Util.dumpCG(builder.getPointerAnalysis(),CG);
}","@Test public void testEx1() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  JSCFABuilder builder=JSCallGraphBuilderUtil.makeHTMLCGBuilder(url);
  CallGraph CG=builder.makeCallGraph(builder.getOptions());
  CAstCallGraphUtil.dumpCG(builder.getPointerAnalysis(),CG);
}",0.9542097488921714
40214,"@Test public void testSwineFlu() throws IOException, IllegalArgumentException, CancelException {
  URL url=new URL(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForSwineFlu);
}","@Ignore(""String_Node_Str"") @Test public void testSwineFlu() throws IOException, IllegalArgumentException, CancelException {
  URL url=new URL(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForSwineFlu);
}",0.9471624266144814
40215,"@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException {
  CallGraph CG=Util.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
  verifyGraphAssertions(CG,assertionsForArgs);
}","@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException {
  CallGraph CG=JSCallGraphBuilderUtil.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
  verifyGraphAssertions(CG,assertionsForArgs);
}",0.9592760180995475
40216,"@Test public void testCrawlPage17() throws IOException, IllegalArgumentException, CancelException {
}","@Test public void testCrawlPage17() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForPage17);
}",0.5372340425531915
40217,"@Test public void testCrawlPage12() throws IOException, IllegalArgumentException, CancelException {
}","@Test public void testCrawlPage12() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForPage12);
}",0.5372340425531915
40218,"public void translate(final CAstEntity N,final WalkContext context){
  walkEntities(N,context);
}","public void translate(final CAstEntity N,final WalkContext context){
  final ExposedNamesCollector exposedNamesCollector=new ExposedNamesCollector();
  exposedNamesCollector.run(N);
  entity2ExposedNames=exposedNamesCollector.getEntity2ExposedNames();
  walkEntities(N,context);
}",0.5145888594164456
40219,"private boolean forInOnFirstArg(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return false;
  Boolean b=forInOnFirstArg_cache.get(mref);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof EachElementGetInstruction) {
      forInOnFirstArg_cache.put(mref,true);
      return true;
    }
  }
  forInOnFirstArg_cache.put(mref,false);
  return false;
}","private boolean forInOnFirstArg(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return false;
  Boolean b=forInOnFirstArg_cache.get(mref);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(index + 1))) {
    if (use instanceof EachElementGetInstruction) {
      forInOnFirstArg_cache.put(mref,true);
      return true;
    }
  }
  forInOnFirstArg_cache.put(mref,false);
  return false;
}",0.9903846153846154
40220,"private Frequency usesFirstArgAsPropertyName(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(mref);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
 else     if (use instanceof AstIsDefinedInstruction) {
      AstIsDefinedInstruction aidi=(AstIsDefinedInstruction)use;
      if (aidi.getNumberOfUses() > 1 && aidi.getUse(1) == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(mref,f);
  return f;
}","private Frequency usesFirstArgAsPropertyName(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(mref);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(index + 1))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == index + 1) {
        usedAsPropertyName=true;
        continue;
      }
    }
 else     if (use instanceof AstIsDefinedInstruction) {
      AstIsDefinedInstruction aidi=(AstIsDefinedInstruction)use;
      if (aidi.getNumberOfUses() > 1 && aidi.getUse(1) == index + 1) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(mref,f);
  return f;
}",0.986784140969163
40221,"@Override public CAstNode visitVariableDeclaration(VariableDeclaration node,WalkContext arg){
  List<VariableInitializer> inits=node.getVariables();
  CAstNode[] children=new CAstNode[inits.size()];
  int i=0;
  for (  VariableInitializer init : inits) {
    arg.addNameDecl(noteSourcePosition(arg,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(init.getTarget().getString())),readName(arg,""String_Node_Str"")),node));
    children[i++]=Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(init.getTarget().getString())),visit(init,arg));
  }
  return Ast.makeNode(CAstNode.BLOCK_STMT,children);
}","@Override public CAstNode visitVariableDeclaration(VariableDeclaration node,WalkContext arg){
  List<VariableInitializer> inits=node.getVariables();
  CAstNode[] children=new CAstNode[inits.size()];
  int i=0;
  for (  VariableInitializer init : inits) {
    arg.addNameDecl(noteSourcePosition(arg,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(init.getTarget().getString())),readName(arg,""String_Node_Str"")),node));
    if (init.getInitializer() == null) {
      children[i++]=Ast.makeNode(CAstNode.EMPTY);
    }
 else {
      children[i++]=Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(init.getTarget().getString())),visit(init,arg));
    }
  }
  return Ast.makeNode(CAstNode.BLOCK_STMT,children);
}",0.918293564714389
40222,"@Override public CAstNode visitBreakStatement(BreakStatement node,WalkContext arg){
  CAstNode breakStmt;
  if (node.getBreakLabel() != null) {
    breakStmt=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(node.getBreakLabel().getIdentifier()));
  }
 else {
    breakStmt=Ast.makeNode(CAstNode.GOTO);
  }
  arg.cfg().map(node,breakStmt);
  Node target=node.getBreakTarget();
  arg.cfg().add(node,target,null);
  return breakStmt;
}","@Override public CAstNode visitBreakStatement(BreakStatement node,WalkContext arg){
  CAstNode breakStmt;
  Node target;
  if (node.getBreakLabel() != null) {
    breakStmt=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(node.getBreakLabel().getIdentifier()));
    target=arg.getBreakFor(node.getBreakLabel().getIdentifier());
  }
 else {
    breakStmt=Ast.makeNode(CAstNode.GOTO);
    target=arg.getBreakFor(null);
  }
  arg.cfg().map(node,breakStmt);
  arg.cfg().add(node,target,null);
  return breakStmt;
}",0.8369098712446352
40223,"@Override public CAstNode visitSwitchStatement(SwitchStatement node,WalkContext context){
  int i=0;
  CAstNode[] children=new CAstNode[node.getCases().size() * 2];
  for (  SwitchCase sc : node.getCases()) {
    CAstNode label=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(String.valueOf(i / 2)),Ast.makeNode(CAstNode.EMPTY));
    context.cfg().map(label,label);
    children[i++]=label;
    if (sc.isDefault()) {
      context.cfg().add(node,label,CAstControlFlowMap.SWITCH_DEFAULT);
    }
 else {
      CAstNode labelCAst=visit(sc.getExpression(),context);
      context.cfg().add(node,label,labelCAst);
    }
    children[i++]=visit(sc,context);
  }
  CAstNode s=Ast.makeNode(CAstNode.SWITCH,visit(node.getExpression(),context),Ast.makeNode(CAstNode.BLOCK_STMT,children));
  context.cfg().map(node,s);
  return s;
}","@Override public CAstNode visitSwitchStatement(SwitchStatement node,WalkContext context){
  AstNode breakStmt=makeEmptyLabelStmt(""String_Node_Str"");
  CAstNode breakLabel=visit(breakStmt,context);
  WalkContext switchBodyContext=makeBreakContext(node,context,breakStmt);
  int i=0;
  CAstNode[] children=new CAstNode[node.getCases().size() * 2];
  for (  SwitchCase sc : node.getCases()) {
    CAstNode label=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(String.valueOf(i / 2)),Ast.makeNode(CAstNode.EMPTY));
    context.cfg().map(label,label);
    children[i++]=label;
    if (sc.isDefault()) {
      context.cfg().add(node,label,CAstControlFlowMap.SWITCH_DEFAULT);
    }
 else {
      CAstNode labelCAst=visit(sc.getExpression(),context);
      context.cfg().add(node,label,labelCAst);
    }
    children[i++]=visit(sc,switchBodyContext);
  }
  CAstNode s=Ast.makeNode(CAstNode.SWITCH,visit(node.getExpression(),context),Ast.makeNode(CAstNode.BLOCK_STMT,children));
  context.cfg().map(node,s);
  return Ast.makeNode(CAstNode.BLOCK_STMT,s,breakLabel);
}",0.8724760892667375
40224,"@Override public CAstNode visitFunctionCall(FunctionCall n,WalkContext context){
  if (!isPrimitiveCall(context,n)) {
    CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
    AstNode callee=n.getTarget();
    WalkContext child=new BaseCollectingContext(context,callee,base);
    CAstNode fun=visit(callee,child);
    CAstNode[] args=gatherCallArguments(n,context);
    if (child.foundBase(callee))     return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,args,context)));
 else     return makeCall(fun,makeVarRef(JSSSAPropagationCallGraphBuilder.GLOBAL_OBJ_VAR_NAME),args,context);
  }
 else {
    return Ast.makeNode(CAstNode.PRIMITIVE,gatherCallArguments(n,context));
  }
}","@Override public CAstNode visitFunctionCall(FunctionCall n,WalkContext context){
  if (!isPrimitiveCall(context,n)) {
    CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(baseVarName));
    AstNode callee=n.getTarget();
    WalkContext child=new BaseCollectingContext(context,callee,base);
    CAstNode fun=visit(callee,child);
    CAstNode[] args=gatherCallArguments(n,context);
    if (child.foundBase(callee))     return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(baseVarName)),Ast.makeConstant(null)),makeCall(fun,base,args,context)));
 else     return makeCall(fun,makeVarRef(JSSSAPropagationCallGraphBuilder.GLOBAL_OBJ_VAR_NAME),args,context);
  }
 else {
    return Ast.makeNode(CAstNode.PRIMITIVE,gatherCallArguments(n,context));
  }
}",0.967020023557126
40225,"@Override public CAstNode visitLabeledStatement(LabeledStatement node,WalkContext arg){
  CAstNode result=visit(node.getStatement(),arg);
  for (  Label label : node.getLabels()) {
    result=Ast.makeNode(CAstNode.LABEL_STMT,visit(label,arg),result);
    arg.cfg().map(label,result);
  }
  return result;
}","@Override public CAstNode visitLabeledStatement(LabeledStatement node,WalkContext arg){
  CAstNode result=visit(node.getStatement(),arg);
  AstNode prev=node;
  for (  Label label : node.getLabels()) {
    result=Ast.makeNode(CAstNode.LABEL_STMT,visit(label,arg),result);
    arg.cfg().map(prev,result);
    prev=label;
  }
  return result;
}",0.904320987654321
40226,"protected boolean useLexicalAccessesForExposedVars(){
  return false;
}","protected boolean useLexicalAccessesForExposedVars(){
  return NEW_LEXICAL;
}",0.8918918918918919
40227,"protected boolean useLocalValuesForLexicalVars(){
  return true;
}","protected boolean useLocalValuesForLexicalVars(){
  return !NEW_LEXICAL;
}",0.8857142857142857
40228,"/** 
 * generate instructions for a write of a global
 */
protected void doGlobalWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,true,context);
      addAccess(context,context.top(),A);
      context.cfg().addInstruction(new AssignInstruction(vn,rval));
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
 else {
      Access A=new Access(name,null,rval);
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
  }
 else {
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalWrite(global,rval));
  }
}","/** 
 * generate instructions for a write of a global
 */
protected void doGlobalWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,true,context);
      addAccess(context,context.top(),A);
      context.cfg().addInstruction(new AssignInstruction(vn,rval));
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
 else {
      Access A=new Access(name,null,rval);
      context.cfg().addInstruction(new AstLexicalWrite(A));
      addAccess(context,context.top(),A);
    }
  }
 else {
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalWrite(global,rval));
  }
}",0.975
40229,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true,context);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,context.getEntityName(E),true);
    context.cfg().addInstruction(new AssignInstruction(S.valueNumber(),rval));
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true,context);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,context.getEntityName(E),true);
    context.cfg().addInstruction(new AssignInstruction(S.valueNumber(),rval));
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
    addAccess(context,context.top(),A);
  }
}",0.9775028121484814
40230,"/** 
 * generate instructions for a read of a global
 */
protected int doGlobalRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,false,context);
      addAccess(context,context.top(),A);
      return vn;
    }
 else {
      int result=context.currentScope().allocateTempValue();
      Access A=new Access(name,null,result);
      context.cfg().addInstruction(new AstLexicalRead(A));
      return result;
    }
  }
 else {
    int result=context.currentScope().allocateTempValue();
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalRead(result,global));
    return result;
  }
}","/** 
 * generate instructions for a read of a global
 */
protected int doGlobalRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,false,context);
      addAccess(context,context.top(),A);
      return vn;
    }
 else {
      int result=context.currentScope().allocateTempValue();
      Access A=new Access(name,null,result);
      context.cfg().addInstruction(new AstLexicalRead(A));
      addAccess(context,context.top(),A);
      return result;
    }
  }
 else {
    int result=context.currentScope().allocateTempValue();
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalRead(result,global));
    return result;
  }
}",0.976510067114094
40231,"/** 
 * we only have this method to avoid having to pass a node parameter at other call sites, as would be required for  {@link #doLexicallyScopedRead(CAstNode,WalkContext,String)}
 */
private int doLexReadHelper(WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false,context);
  final String entityName=context.getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * we only have this method to avoid having to pass a node parameter at other call sites, as would be required for  {@link #doLexicallyScopedRead(CAstNode,WalkContext,String)}
 */
private int doLexReadHelper(WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false,context);
  final String entityName=context.getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    addAccess(context,context.top(),A);
    return result;
  }
}",0.977628635346756
40232,"/** 
 * record that in entity e, the access is performed using a local variable. in  {@link #patchLexicalAccesses(SSAInstruction[],Set)}, this information is used to update an instruction that performs all the accesses at the beginning of the method and defines the locals.
 */
private void addAccess(WalkContext context,CAstEntity e,Access access){
}","/** 
 * record that in entity e, the access is performed. If   {@link #useLocalValuesForLexicalVars()} is true, the access is performedusing a local variable. in {@link #patchLexicalAccesses(SSAInstruction[],Set)}, this information is used to update an instruction that performs all the accesses at the beginning of the method and defines the locals.
 */
private void addAccess(WalkContext context,CAstEntity e,Access access){
  context.getAccesses(e).add(access);
}",0.8543451652386781
40233,"private Set<CGNode> getLexicalDefiners(final CGNode opNode,final Pair<String,String> definer){
  if (definer == null) {
    return Collections.singleton(getBuilder().getCallGraph().getFakeRootNode());
  }
 else {
    final Set<CGNode> result=HashSetFactory.make();
    PointerKey F=getBuilder().getPointerKeyForLocal(opNode,1);
    IR ir=getBuilder().getCFAContextInterpreter().getIR(opNode);
    SymbolTable symtab=ir.getSymbolTable();
    DefUse du=getAnalysisCache().getSSACache().findOrCreateDU(ir,opNode.getContext());
    if (contentsAreInvariant(symtab,du,1)) {
      system.recordImplicitPointsToSet(F);
      final InstanceKey[] functionKeys=getInvariantContents(symtab,du,opNode,1);
      for (int f=0; f < functionKeys.length; f++) {
        system.findOrCreateIndexForInstanceKey(functionKeys[f]);
        ScopeMappingInstanceKey K=(ScopeMappingInstanceKey)functionKeys[f];
        Iterator<CGNode> x=K.getFunargNodes(definer);
        while (x.hasNext()) {
          result.add(x.next());
        }
      }
    }
 else {
      PointsToSetVariable FV=system.findOrCreatePointsToSet(F);
      if (FV.getValue() != null) {
        FV.getValue().foreach(new IntSetAction(){
          public void act(          int ptr){
            InstanceKey iKey=system.getInstanceKey(ptr);
            if (iKey instanceof ScopeMappingInstanceKey) {
              ScopeMappingInstanceKey K=(ScopeMappingInstanceKey)iKey;
              Iterator<CGNode> x=K.getFunargNodes(definer);
              while (x.hasNext()) {
                result.add(x.next());
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"" + iKey);
            }
          }
        }
);
      }
    }
    return result;
  }
}","private Set<CGNode> getLexicalDefiners(final CGNode opNode,final Pair<String,String> definer){
}",0.1052054794520548
40234,"public JSZeroOrOneXCFABuilder(IClassHierarchy cha,JSAnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,int instancePolicy,boolean doOneCFA){
  super(cha,options,cache);
  SSAContextInterpreter contextInterpreter=makeDefaultContextInterpreters(appContextInterpreter,options,cha);
  if (options.handleCallApply()) {
    contextInterpreter=new DelegatingSSAContextInterpreter(new JavaScriptFunctionApplyContextInterpreter(options,cache),contextInterpreter);
  }
  setContextInterpreter(contextInterpreter);
  MethodTargetSelector targetSelector=new JavaScriptConstructTargetSelector(cha,options.getMethodTargetSelector());
  if (options.handleCallApply()) {
    targetSelector=new JavaScriptFunctionDotCallTargetSelector(targetSelector);
  }
  if (options.useLoadFileTargetSelector()) {
    targetSelector=new LoadFileTargetSelector(targetSelector,this);
  }
  options.setSelector(targetSelector);
  ContextSelector def=new ContextInsensitiveSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new ScopeMappingKeysContextSelector(contextSelector);
  contextSelector=new JavaScriptConstructorContextSelector(contextSelector);
  if (USE_OBJECT_SENSITIVITY) {
    contextSelector=new ObjectSensitivityContextSelector(contextSelector);
  }
  if (options.handleCallApply()) {
    contextSelector=new JavaScriptFunctionApplyContextSelector(contextSelector);
  }
  contextSelector=new LexicalScopingResolverContexts(this,contextSelector);
  if (doOneCFA) {
    contextSelector=new nCFAContextSelector(1,contextSelector);
  }
  setContextSelector(contextSelector);
  setInstanceKeys(new JavaScriptScopeMappingInstanceKeys(cha,this,new JavaScriptConstructorInstanceKeys(new ZeroXInstanceKeys(options,cha,contextInterpreter,instancePolicy))));
}","public JSZeroOrOneXCFABuilder(IClassHierarchy cha,JSAnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,int instancePolicy,boolean doOneCFA){
  super(cha,options,cache);
  SSAContextInterpreter contextInterpreter=makeDefaultContextInterpreters(appContextInterpreter,options,cha);
  if (options.handleCallApply()) {
    contextInterpreter=new DelegatingSSAContextInterpreter(new JavaScriptFunctionApplyContextInterpreter(options,cache),contextInterpreter);
  }
  setContextInterpreter(contextInterpreter);
  MethodTargetSelector targetSelector=new JavaScriptConstructTargetSelector(cha,options.getMethodTargetSelector());
  if (options.handleCallApply()) {
    targetSelector=new JavaScriptFunctionApplyTargetSelector(new JavaScriptFunctionDotCallTargetSelector(targetSelector));
  }
  if (options.useLoadFileTargetSelector()) {
    targetSelector=new LoadFileTargetSelector(targetSelector,this);
  }
  options.setSelector(targetSelector);
  ContextSelector def=new ContextInsensitiveSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new ScopeMappingKeysContextSelector(contextSelector);
  contextSelector=new JavaScriptConstructorContextSelector(contextSelector);
  if (USE_OBJECT_SENSITIVITY) {
    contextSelector=new ObjectSensitivityContextSelector(contextSelector);
  }
  if (options.handleCallApply()) {
    contextSelector=new JavaScriptFunctionApplyContextSelector(contextSelector);
  }
  contextSelector=new LexicalScopingResolverContexts(this,contextSelector);
  if (doOneCFA) {
    contextSelector=new nCFAContextSelector(1,contextSelector);
  }
  setContextSelector(contextSelector);
  setInstanceKeys(new JavaScriptScopeMappingInstanceKeys(cha,this,new JavaScriptConstructorInstanceKeys(new ZeroXInstanceKeys(options,cha,contextInterpreter,instancePolicy))));
}",0.988845654993515
40235,"private AbstractScope makeScriptScope(final CAstEntity s,Scope parent){
  return new AbstractScope(parent){
    SymbolTable scriptGlobalSymtab=new SymbolTable(s.getArgumentCount());
    public SymbolTable getUnderlyingSymtab(){
      return scriptGlobalSymtab;
    }
    protected AbstractScope getEntityScope(){
      return this;
    }
    public boolean isLexicallyScoped(    Symbol s){
      if (isGlobal(s))       return false;
 else       return ((AbstractScope)s.getDefiningScope()).getEntityScope() != this;
    }
    public CAstEntity getEntity(){
      return s;
    }
    public ScopeType type(){
      return ScopeType.SCRIPT;
    }
    protected Symbol makeSymbol(    final String nm,    final boolean isFinal,    final boolean isInternalName,    final Object defaultInitValue,    int vn,    Scope definer){
      final int v=vn == -1 ? getUnderlyingSymtab().newSymbol() : vn;
      if (useDefaultInitValues() && defaultInitValue != null) {
        if (getUnderlyingSymtab().getValue(v) == null) {
          setDefaultValue(getUnderlyingSymtab(),v,defaultInitValue);
        }
      }
      return new AbstractSymbol(definer,isFinal,defaultInitValue){
        public String toString(){
          return nm + ""String_Node_Str"" + System.identityHashCode(this);
        }
        public int valueNumber(){
          return v;
        }
        public boolean isInternalName(){
          return isInternalName;
        }
        public boolean isParameter(){
          return false;
        }
      }
;
    }
  }
;
}","private AbstractScope makeScriptScope(final CAstEntity s,Scope parent){
  return new AbstractScope(parent){
    SymbolTable scriptGlobalSymtab=new SymbolTable(s.getArgumentCount());
    public SymbolTable getUnderlyingSymtab(){
      return scriptGlobalSymtab;
    }
    protected AbstractScope getEntityScope(){
      return this;
    }
    public boolean isLexicallyScoped(    Symbol s){
      if (isGlobal(s))       return false;
 else       return ((AbstractScope)s.getDefiningScope()).getEntity() != getEntity();
    }
    public CAstEntity getEntity(){
      return s;
    }
    public ScopeType type(){
      return ScopeType.SCRIPT;
    }
    protected Symbol makeSymbol(    final String nm,    final boolean isFinal,    final boolean isInternalName,    final Object defaultInitValue,    int vn,    Scope definer){
      final int v=vn == -1 ? getUnderlyingSymtab().newSymbol() : vn;
      if (useDefaultInitValues() && defaultInitValue != null) {
        if (getUnderlyingSymtab().getValue(v) == null) {
          setDefaultValue(getUnderlyingSymtab(),v,defaultInitValue);
        }
      }
      return new AbstractSymbol(definer,isFinal,defaultInitValue){
        public String toString(){
          return nm + ""String_Node_Str"" + System.identityHashCode(this);
        }
        public int valueNumber(){
          return v;
        }
        public boolean isInternalName(){
          return isInternalName;
        }
        public boolean isParameter(){
          return false;
        }
      }
;
    }
  }
;
}",0.9934469200524246
40236,"/** 
 * record name as exposed for the current entity and for all enclosing entities up to that of the defining scope, since if the name is updated via a call to a nested function, SSA for these entities may need to be updated with the new definition
 * @param context
 * @param name
 * @param definingScope
 * @param E
 * @param entityName
 * @param isWrite
 */
private void markExposedInEnclosingEntities(WalkContext context,final String name,Scope definingScope,CAstEntity E,final String entityName,boolean isWrite){
  Scope curScope=context.currentScope();
  while (!curScope.equals(definingScope)) {
    final Symbol curSymbol=curScope.lookup(name);
    final int vn=curSymbol.valueNumber();
    final Access A=new Access(name,entityName,vn);
    final CAstEntity entity=curScope.getEntity();
    addExposedName(entity,E,name,vn,isWrite);
    addAccess(entity,A);
    curScope=curScope.getParent();
  }
}","/** 
 * record name as exposed for the current entity and for all enclosing entities up to that of the defining scope, since if the name is updated via a call to a nested function, SSA for these entities may need to be updated with the new definition
 * @param context
 * @param name
 * @param definingScope
 * @param E
 * @param entityName
 * @param isWrite
 */
private void markExposedInEnclosingEntities(WalkContext context,final String name,Scope definingScope,CAstEntity E,final String entityName,boolean isWrite){
  Scope curScope=context.currentScope();
  while (!curScope.equals(definingScope)) {
    final Symbol curSymbol=curScope.lookup(name);
    final int vn=curSymbol.valueNumber();
    final Access A=new Access(name,entityName,vn);
    final CAstEntity entity=curScope.getEntity();
    if (entity != definingScope.getEntity()) {
      addExposedName(entity,E,name,vn,isWrite);
      addAccess(entity,A);
    }
    curScope=curScope.getParent();
  }
}",0.9696
40237,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR) && receiver.length > index) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
  }
 else   if (receiver.length > index) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
 else     if (receiver[index] != null && (f == Frequency.SOMETIMES || forInOnFirstArg(callee))) {
      return new ForInContext(baseContext,receiver[index]);
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR) && receiver.length > index) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
  }
 else   if (receiver.length > index) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
 else     if (f == Frequency.SOMETIMES || forInOnFirstArg(callee)) {
      if (receiver[index] == null) {
        IClass undef=caller.getClassHierarchy().lookupClass(JavaScriptTypes.Undefined);
        return new ForInContext(baseContext,new ConcreteTypeKey(undef));
      }
 else {
        return new ForInContext(baseContext,receiver[index]);
      }
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}",0.9171306911234852
40238,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  if (useForInContext(callee,receiver)) {
    InstanceKey loopVar=receiver[2];
    IClass stringClass=caller.getClassHierarchy().lookupClass(JavaScriptTypes.String);
    if (loopVar instanceof ConstantKey) {
      Object value=((ConstantKey)loopVar).getValue();
      if (value instanceof String) {
        return new ForInContext(baseContext,loopVar);
      }
 else       if (value instanceof Number) {
        Integer ival=((Number)value).intValue();
        return new ForInContext(baseContext,new ConstantKey<String>(ival.toString(),stringClass));
      }
 else       if (value instanceof Boolean) {
        Boolean bval=(Boolean)value;
        return new ForInContext(baseContext,new ConstantKey<String>(bval.toString(),stringClass));
      }
 else       if (value == null) {
        return new ForInContext(baseContext,new ConstantKey<String>(""String_Node_Str"",stringClass));
      }
    }
    ConcreteTypeKey stringKey=new ConcreteTypeKey(stringClass);
    return new ForInContext(baseContext,stringKey);
  }
 else   if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
 else {
    return baseContext;
  }
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR)) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[2]));
    }
  }
 else   if (receiver.length > 2 && receiver[2] != null) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[2]));
    }
 else     if (f == Frequency.SOMETIMES || forInOnFirstArg(callee)) {
      return new ForInContext(baseContext,receiver[2]);
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}",0.5068852459016393
40239,"private boolean usesFirstArgAsPropertyName(IMethod method){
  if (method.getNumberOfParameters() < 2)   return false;
  Boolean b=usesFirstArgAsPropertyName_cache.get(method);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usesFirstArgAsPropertyName_cache.put(method,true);
        return true;
      }
    }
  }
  usesFirstArgAsPropertyName_cache.put(method,false);
  return false;
}","private Frequency usesFirstArgAsPropertyName(IMethod method){
  if (method.getNumberOfParameters() < 2)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(method);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(method,f);
  return f;
}",0.5840220385674931
40240,"/** 
 * get the CGNode representing the lexical parent of   {@link #creator} withname definer
 * @param definer
 * @return
 */
Iterator<CGNode> getFunargNodes(Pair<String,String> name){
  Iterator<CGNode> result=EmptyIterator.instance();
  LexicalScopingResolver r=(LexicalScopingResolver)creator.getContext().get(LexicalScopingResolverContexts.RESOLVER);
  if (r != null) {
    CGNode def=r.getOriginalDefiner(name);
    if (def != null) {
      result=new NonNullSingletonIterator<CGNode>(def);
    }
  }
  PointerKey funcKey=builder.getPointerKeyForLocal(creator,1);
  OrdinalSet<InstanceKey> funcPtrs=builder.getPointerAnalysis().getPointsToSet(funcKey);
  for (  InstanceKey x : funcPtrs) {
    if (x instanceof ScopeMappingInstanceKey) {
      result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)x).getFunargNodes(name));
    }
  }
  return result;
}","/** 
 * get the CGNode representing the lexical parent of   {@link #creator} withname definer
 * @param definer
 * @return
 */
Iterator<CGNode> getFunargNodes(Pair<String,String> name){
  Iterator<CGNode> result=EmptyIterator.instance();
  LexicalScopingResolver r=(LexicalScopingResolver)creator.getContext().get(LexicalScopingResolverContexts.RESOLVER);
  if (r != null) {
    CGNode def=r.getOriginalDefiner(name);
    if (def != null) {
      result=new NonNullSingletonIterator<CGNode>(def);
    }
  }
  ContextItem nested=creator.getContext().get(ScopeMappingKeysContextSelector.scopeKey);
  if (nested != null) {
    result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)nested).getFunargNodes(name));
  }
  PointerKey funcKey=builder.getPointerKeyForLocal(creator,1);
  OrdinalSet<InstanceKey> funcPtrs=builder.getPointerAnalysis().getPointsToSet(funcKey);
  for (  InstanceKey x : funcPtrs) {
    if (x instanceof ScopeMappingInstanceKey) {
      result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)x).getFunargNodes(name));
    }
  }
  return result;
}",0.887646161667514
40241,"/** 
 * compute the   {@link CGNode} correspond to each specified{@link LexicalParent} of {@link #base}, populating   {@link #scopeMap}
 */
private ScopeMappingInstanceKey(CGNode creator,InstanceKey base){
  this.creator=creator;
  this.base=base;
}","private ScopeMappingInstanceKey(CGNode creator,InstanceKey base){
  this.creator=creator;
  this.base=base;
}",0.6089385474860335
40242,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  if (name.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    Scope curScope=context.currentScope();
    while (!curScope.equals(definingScope)) {
      Symbol curSymbol=curScope.lookup(name);
      final int vn=curSymbol.valueNumber();
      Access A=new Access(name,entityName,vn);
      CAstEntity entity=curScope.getEntity();
      addExposedName(entity,E,name,vn,false);
      addAccess(entity,A);
      curScope=curScope.getParent();
    }
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  final String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}",0.5987084870848709
40243,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  CAstEntity E=S.getDefiningScope().getEntity();
  addExposedName(E,E,name,S.getDefiningScope().lookup(name).valueNumber(),true);
  if (useLocalValuesForLexicalVars()) {
    int vn=S.valueNumber();
    Access A=new Access(name,getEntityName(E),vn);
    addExposedName(context.top(),E,name,vn,true);
    addAccess(context.top(),A);
    context.cfg().addInstruction(new AssignInstruction(vn,rval));
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,getEntityName(E),true);
    int vn=S.valueNumber();
    Access A=new Access(name,getEntityName(E),vn);
    context.cfg().addInstruction(new AssignInstruction(vn,rval));
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}",0.6009615384615384
40244,"@SuppressWarnings(""String_Node_Str"") AstLexicalInformation(String entityName,Scope scope,SSAInstruction[] instrs,Set<Pair<Pair<String,String>,Integer>> exposedNamesForReadSet,Set<Pair<Pair<String,String>,Integer>> exposedNamesForWriteSet,Set<Access> accesses){
  this.functionLexicalName=entityName;
  Pair<Pair<String,String>,Integer>[] EN=null;
  if (exposedNamesForReadSet != null || exposedNamesForWriteSet != null) {
    Set<Pair<Pair<String,String>,Integer>> exposedNamesSet=new HashSet<Pair<Pair<String,String>,Integer>>();
    if (exposedNamesForReadSet != null) {
      exposedNamesSet.addAll(exposedNamesForReadSet);
    }
    if (exposedNamesForWriteSet != null) {
      exposedNamesSet.addAll(exposedNamesForWriteSet);
    }
    EN=exposedNamesSet.toArray(new Pair[exposedNamesSet.size()]);
  }
  if (exposedNamesForReadSet != null) {
    Set<String> readOnlyNames=new HashSet<String>();
    for (    Pair<Pair<String,String>,Integer> v : exposedNamesForReadSet) {
      if (entityName != null && entityName.equals(v.fst.snd)) {
        readOnlyNames.add(v.fst.fst);
      }
    }
    if (exposedNamesForWriteSet != null) {
      for (      Pair<Pair<String,String>,Integer> v : exposedNamesForWriteSet) {
        if (entityName != null && entityName.equals(v.fst.snd)) {
          readOnlyNames.remove(v.fst.fst);
        }
      }
    }
    this.readOnlyNames=readOnlyNames;
  }
 else {
    this.readOnlyNames=null;
  }
  this.exposedNames=buildLexicalNamesArray(EN);
  this.exitLexicalUses=buildLexicalUseArray(EN,entityName);
  this.instructionLexicalUses=new int[instrs.length][];
  for (int i=0; i < instrs.length; i++) {
    if (instrs[i] instanceof SSAAbstractInvokeInstruction) {
      this.instructionLexicalUses[i]=buildLexicalUseArray(EN,null);
    }
  }
  if (accesses != null) {
    Set<String> parents=new LinkedHashSet<String>();
    for (Iterator<Access> ACS=accesses.iterator(); ACS.hasNext(); ) {
      Access AC=ACS.next();
      if (AC.variableDefiner != null) {
        parents.add(AC.variableDefiner);
      }
    }
    scopingParents=parents.toArray(new String[parents.size()]);
    if (DEBUG_LEXICAL) {
      System.err.println((""String_Node_Str"" + scope.getEntity()));
      System.err.println(parents.toString());
    }
  }
 else {
    scopingParents=null;
  }
  if (DEBUG_NAMES) {
    System.err.println((""String_Node_Str"" + scope.getEntity()));
    for (int i=0; i < instructionLexicalUses.length; i++) {
      if (instructionLexicalUses[i] != null) {
        System.err.println((""String_Node_Str"" + instrs[i]));
        for (int j=0; j < instructionLexicalUses[i].length; j++) {
          System.err.println((""String_Node_Str"" + this.exposedNames[j].fst + ""String_Node_Str""+ instructionLexicalUses[i][j]));
        }
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") AstLexicalInformation(String entityName,Scope scope,SSAInstruction[] instrs,Set<Pair<Pair<String,String>,Integer>> exposedNamesForReadSet,Set<Pair<Pair<String,String>,Integer>> exposedNamesForWriteSet,Set<Access> accesses){
  if (entityName.contains(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  this.functionLexicalName=entityName;
  Pair<Pair<String,String>,Integer>[] EN=null;
  if (exposedNamesForReadSet != null || exposedNamesForWriteSet != null) {
    Set<Pair<Pair<String,String>,Integer>> exposedNamesSet=new HashSet<Pair<Pair<String,String>,Integer>>();
    if (exposedNamesForReadSet != null) {
      exposedNamesSet.addAll(exposedNamesForReadSet);
    }
    if (exposedNamesForWriteSet != null) {
      exposedNamesSet.addAll(exposedNamesForWriteSet);
    }
    EN=exposedNamesSet.toArray(new Pair[exposedNamesSet.size()]);
  }
  if (exposedNamesForReadSet != null) {
    Set<String> readOnlyNames=new HashSet<String>();
    for (    Pair<Pair<String,String>,Integer> v : exposedNamesForReadSet) {
      if (entityName != null && entityName.equals(v.fst.snd)) {
        readOnlyNames.add(v.fst.fst);
      }
    }
    if (exposedNamesForWriteSet != null) {
      for (      Pair<Pair<String,String>,Integer> v : exposedNamesForWriteSet) {
        if (entityName != null && entityName.equals(v.fst.snd)) {
          readOnlyNames.remove(v.fst.fst);
        }
      }
    }
    this.readOnlyNames=readOnlyNames;
  }
 else {
    this.readOnlyNames=null;
  }
  this.exposedNames=buildLexicalNamesArray(EN);
  this.exitLexicalUses=buildLexicalUseArray(EN,entityName);
  this.instructionLexicalUses=new int[instrs.length][];
  for (int i=0; i < instrs.length; i++) {
    if (instrs[i] instanceof SSAAbstractInvokeInstruction) {
      this.instructionLexicalUses[i]=buildLexicalUseArray(EN,null);
    }
  }
  if (accesses != null) {
    Set<String> parents=new LinkedHashSet<String>();
    for (Iterator<Access> ACS=accesses.iterator(); ACS.hasNext(); ) {
      Access AC=ACS.next();
      if (AC.variableDefiner != null) {
        parents.add(AC.variableDefiner);
      }
    }
    scopingParents=parents.toArray(new String[parents.size()]);
    if (DEBUG_LEXICAL) {
      System.err.println((""String_Node_Str"" + scope.getEntity()));
      System.err.println(parents.toString());
    }
  }
 else {
    scopingParents=null;
  }
  if (DEBUG_NAMES) {
    System.err.println((""String_Node_Str"" + scope.getEntity()));
    for (int i=0; i < instructionLexicalUses.length; i++) {
      if (instructionLexicalUses[i] != null) {
        System.err.println((""String_Node_Str"" + instrs[i]));
        for (int j=0; j < instructionLexicalUses[i].length; j++) {
          System.err.println((""String_Node_Str"" + this.exposedNames[j].fst + ""String_Node_Str""+ instructionLexicalUses[i][j]));
        }
      }
    }
  }
}",0.9831888161387364
40245,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  CAstEntity E=S.getDefiningScope().getEntity();
  addExposedName(E,E,name,S.getDefiningScope().lookup(name).valueNumber(),false);
  int vn=S.valueNumber();
  if (useLocalValuesForLexicalVars()) {
    Access A=new Access(name,getEntityName(E),vn);
    addExposedName(context.top(),E,name,vn,false);
    addAccess(context.top(),A);
    return vn;
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,getEntityName(E),result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  if (name.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    Scope curScope=context.currentScope();
    while (!curScope.equals(definingScope)) {
      Symbol curSymbol=curScope.lookup(name);
      final int vn=curSymbol.valueNumber();
      Access A=new Access(name,entityName,vn);
      CAstEntity entity=curScope.getEntity();
      addExposedName(entity,E,name,vn,false);
      addAccess(entity,A);
      curScope=curScope.getParent();
    }
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}",0.4865616311399444
40246,"public void setLexicallyMutatedIR(IR ir){
  lexicalScopingChanges=true;
  cachedIR=ir;
  cachedDU=new DefUse(ir);
}","public void setLexicallyMutatedIR(IR ir){
  lexicalScopingChanges=true;
  cachedIR=ir;
  cachedDU=null;
}",0.9272727272727272
40247,"public DefUse getLexicallyMutatedDU(){
  if (lexicalScopingChanges) {
    return cachedDU;
  }
 else {
    return null;
  }
}","public DefUse getLexicallyMutatedDU(){
  if (lexicalScopingChanges) {
    if (cachedDU == null) {
      cachedDU=new DefUse(cachedIR);
    }
    return cachedDU;
  }
 else {
    return null;
  }
}",0.778816199376947
40248,"/** 
 * @return the indices i s.t. x[i] == y, or null if none found.
 */
private int[] extractIndices(int[] x,int y){
  int count=0;
  for (int i=0; i < x.length; i++) {
    if (x[i] == y) {
      count++;
    }
  }
  if (count == 0) {
    return null;
  }
 else {
    int[] result=new int[count];
    int j=0;
    for (int i=0; i < x.length; i++) {
      if (x[i] == y) {
        result[j++]=i;
      }
    }
    return result;
  }
}","/** 
 * @return the indices i s.t. x[i] == y, or null if none found.
 */
private int[] extractIndices(int[] x,int y){
}",0.430379746835443
40249,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      setLocal(locals,p.getY(),p.getX());
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  if (vn < 0) {
    return null;
  }
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals=setLocal(locals,p.getY(),p.getX());
    }
  }
  return locals == null ? null : extractIndices(locals,vn);
}",0.9536152796725784
40250,"protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}","protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}",0.9992166692777692
40251,"public boolean inRead(){
  return false;
}","public boolean inRead(){
  return true;
}",0.9156626506024096
40252,"public void setAssign(CAstNode receiverTemp,CAstNode elementTemp){
  Assertions.UNREACHABLE();
}","/** 
 * store the CAstNodes used to represent the loop variable for the prototype-chain traversal (receiverTemp) and the desired property (elementTemp)
 */
public void setAssign(CAstNode receiverTemp,CAstNode elementTemp){
  this.receiverTemp=receiverTemp;
  this.elementTemp=elementTemp;
}",0.3834196891191709
40253,"private static String composeString(Collection<String> s){
  StringBuffer result=new StringBuffer();
  Iterator<String> it=s.iterator();
  for (int i=0; i < s.size() - 1; i++) {
    result.append(it.next());
    result.append(';');
  }
  if (it.hasNext()) {
    result.append(it.next());
  }
  return result.toString();
}","private static String composeString(Collection<String> s){
  StringBuffer result=new StringBuffer();
  Iterator<String> it=s.iterator();
  for (int i=0; i < s.size() - 1; i++) {
    result.append(it.next());
    result.append(File.pathSeparator);
  }
  if (it.hasNext()) {
    result.append(it.next());
  }
  return result.toString();
}",0.9680365296803652
40254,"public nCFABuilder(int n,IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setInstanceKeys(new ClassBasedInstanceKeys(options,cha));
  ContextSelector def=new DefaultContextSelector(options,cha);
  ContextSelector contextSelector=new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new nCFAContextSelector(n,contextSelector);
  setContextSelector(contextSelector);
  SSAContextInterpreter defI=new DefaultSSAInterpreter(options,cache);
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache()),defI);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  setContextInterpreter(contextInterpreter);
}","public nCFABuilder(int n,IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setInstanceKeys(new ClassBasedInstanceKeys(options,cha));
  ContextSelector def=new DefaultContextSelector(options,cha);
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new nCFAContextSelector(n,contextSelector);
  setContextSelector(contextSelector);
  SSAContextInterpreter defI=new DefaultSSAInterpreter(options,cache);
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache()),defI);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? defI : new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  setContextInterpreter(contextInterpreter);
}",0.964354527938343
40255,"public void copyState(IVariable v){
  MachineState other=(MachineState)v;
  if (other.stack == null) {
    stack=null;
  }
 else {
    stack=new int[other.stack.length];
    System.arraycopy(other.stack,0,stack,0,other.stack.length);
  }
  if (other.locals == null) {
    locals=null;
  }
 else {
    locals=new int[other.locals.length];
    System.arraycopy(other.locals,0,locals,0,other.locals.length);
  }
  stackHeight=other.stackHeight;
}","public void copyState(MachineState other){
  if (other.stack == null) {
    stack=null;
  }
 else {
    stack=new int[other.stack.length];
    System.arraycopy(other.stack,0,stack,0,other.stack.length);
  }
  if (other.locals == null) {
    locals=null;
  }
 else {
    locals=new int[other.locals.length];
    System.arraycopy(other.locals,0,locals,0,other.locals.length);
  }
  stackHeight=other.stackHeight;
}",0.0912280701754386
40256,"/** 
 * @return the state at the entry to a given block
 */
public MachineState getIn(ShrikeCFG.BasicBlock bb){
  return (MachineState)solver.getIn(bb);
}","/** 
 * @return the state at the entry to a given block
 */
public MachineState getIn(ShrikeCFG.BasicBlock bb){
  return solver.getIn(bb);
}",0.9523809523809524
40257,"public MachineState getEntryState(){
  return (MachineState)solver.getIn(cfg.entry());
}","public MachineState getEntryState(){
  return solver.getIn(cfg.entry());
}",0.9135802469135802
40258,"protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}","protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}",0.9984330930742714
40259,"/** 
 * create a CAstNode l representing a loop that traverses the prototype chain from receiver searching for the constant property element. update nodeMap to map root to an expression that reads the property from the right node.
 * @param root
 * @param receiver
 * @param element
 * @param context
 * @param nodeMap
 * @return
 */
private CAstNode makeConstRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  CAstNode get, result;
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elt=(String)element.getValue();
  if (elt.equals(""String_Node_Str"") || elt.equals(""String_Node_Str"")) {
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,get=Ast.makeNode(CAstNode.OBJECT_REF,receiver,Ast.makeConstant(elt)));
  }
 else {
    if (context.inAssignment()) {
      context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt));
    }
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt)));
  }
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}","/** 
 * create a CAstNode l representing a loop that traverses the prototype chain from receiver searching for the constant property element. update nodeMap to map root to an expression that reads the property from the right node.
 * @param root
 * @param receiver
 * @param element
 * @param context
 * @param nodeMap
 * @return
 */
private CAstNode makeConstRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  CAstNode get, result;
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elt=(String)element.getValue();
  if (elt.equals(""String_Node_Str"") || elt.equals(""String_Node_Str"")) {
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,get=Ast.makeNode(CAstNode.OBJECT_REF,receiver,Ast.makeConstant(elt)));
  }
 else {
    if (context.inAssignment()) {
      context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt));
    }
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt)));
  }
  nodeMap.put(Pair.make(root,context.key()),result);
  nodeMap.put(Pair.make(root,ExpanderKey.EXTRA),get);
  return result;
}",0.98075265728239
40260,"/** 
 * similar to makeConstRead(), but desired property is some expression instead of a constant
 * @see #makeConstRead(CAstNode,CAstNode,CAstNode,RewriteContext,Map)
 */
private CAstNode makeVarRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elementTemp=TEMP_NAME + (readTempCounter++);
  if (context.inAssignment()) {
    context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)));
  }
  CAstNode get;
  CAstNode result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(elementTemp,false,false)),element),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp))));
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}","/** 
 * similar to makeConstRead(), but desired property is some expression instead of a constant
 * @see #makeConstRead(CAstNode,CAstNode,CAstNode,RewriteContext,Map)
 */
private CAstNode makeVarRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elementTemp=TEMP_NAME + (readTempCounter++);
  if (context.inAssignment()) {
    context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)));
  }
  CAstNode get;
  CAstNode result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(elementTemp,false,false)),element),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp))));
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}",0.9968010236724248
40261,"private static void getMethodInClassOrSuperclass(IMethodBinding met,ITypeBinding klass,boolean superclassonly,HashMap<ITypeBinding,IMethodBinding> overridden){
  if (!superclassonly) {
    for (    IMethodBinding ourmet : klass.getDeclaredMethods())     if (met.isSubsignature(ourmet) && (met.getModifiers() & Modifier.PRIVATE) == 0) {
      overridden.put(ourmet.getMethodDeclaration().getReturnType(),ourmet.getMethodDeclaration());
      break;
    }
  }
  for (  ITypeBinding iface : klass.getInterfaces())   getMethodInClassOrSuperclass(met,iface,false,overridden);
  ITypeBinding superclass=klass.getSuperclass();
  if (superclass != null)   getMethodInClassOrSuperclass(met,superclass,false,overridden);
}","private static void getMethodInClassOrSuperclass(IMethodBinding met,ITypeBinding klass,boolean superclassonly,HashMap<ITypeBinding,IMethodBinding> overridden){
  if (!superclassonly) {
    for (    IMethodBinding ourmet : klass.getDeclaredMethods())     if (met.overrides(ourmet)) {
      overridden.put(ourmet.getMethodDeclaration().getReturnType(),ourmet.getMethodDeclaration());
      break;
    }
  }
  for (  ITypeBinding iface : klass.getInterfaces())   getMethodInClassOrSuperclass(met,iface,false,overridden);
  ITypeBinding superclass=klass.getSuperclass();
  if (superclass != null)   getMethodInClassOrSuperclass(met,superclass,false,overridden);
}",0.936542669584245
40262,"/** 
 * Make a ""fake"" function (it doesn't exist in source code but it does in bytecode) for covariant return types.
 * @param overriding Declaration of the overriding method.
 * @param overridden Binding of the overridden method, in a a superclass or implemented interface.
 * @param oldContext
 * @return
 */
private CAstEntity makeSyntheticCovariantRedirect(MethodDeclaration overriding,IMethodBinding overridingBinding,IMethodBinding overridden,WalkContext oldContext){
  final Map<CAstNode,CAstEntity> memberEntities=new LinkedHashMap<CAstNode,CAstEntity>();
  final MethodContext context=new MethodContext(oldContext,memberEntities);
  CAstNode calltarget;
  if ((overridingBinding.getModifiers() & Modifier.STATIC) == 0)   calltarget=makeNode(context,fFactory,null,CAstNode.THIS);
 else   calltarget=makeNode(context,fFactory,null,CAstNode.VOID);
  ITypeBinding paramTypes[]=overridden.getParameterTypes();
  ArrayList<CAstNode> arguments=new ArrayList<CAstNode>();
  int i=0;
  for (  Object o : overriding.parameters()) {
    SingleVariableDeclaration svd=(SingleVariableDeclaration)o;
    CAstNode varNode=makeNode(context,fFactory,null,CAstNode.VAR,fFactory.makeConstant(svd.getName().getIdentifier()));
    ITypeBinding fromType=JDT2CAstUtils.getErasedType(paramTypes[i],ast);
    ITypeBinding toType=JDT2CAstUtils.getErasedType(overridingBinding.getParameterTypes()[i],ast);
    if (fromType.equals(toType))     arguments.add(varNode);
 else     arguments.add(createCast(null,varNode,fromType,toType,context));
    i++;
  }
  CAstNode callnode=createMethodInvocation(null,overridingBinding,calltarget,arguments,context);
  CAstNode mdast=makeNode(context,fFactory,null,CAstNode.LOCAL_SCOPE,makeNode(context,fFactory,null,CAstNode.BLOCK_STMT,makeNode(context,fFactory,null,CAstNode.RETURN,callnode)));
  ArrayList<CAstType> paramCAstTypes=new ArrayList<CAstType>(overridden.getParameterTypes().length);
  for (  ITypeBinding paramType : overridden.getParameterTypes())   paramCAstTypes.add(fTypeDict.getCAstTypeFor(paramType));
  return new ProcedureEntity(mdast,overriding,overridingBinding.getDeclaringClass(),memberEntities,context,paramCAstTypes,overridden.getReturnType());
}","/** 
 * Make a ""fake"" function (it doesn't exist in source code but it does in bytecode) for covariant return types.
 * @param overriding Declaration of the overriding method.
 * @param overridden Binding of the overridden method, in a a superclass or implemented interface.
 * @param oldContext
 * @return
 */
private CAstEntity makeSyntheticCovariantRedirect(MethodDeclaration overriding,IMethodBinding overridingBinding,IMethodBinding overridden,WalkContext oldContext){
  final Map<CAstNode,CAstEntity> memberEntities=new LinkedHashMap<CAstNode,CAstEntity>();
  final MethodContext context=new MethodContext(oldContext,memberEntities);
  CAstNode calltarget;
  if ((overridingBinding.getModifiers() & Modifier.STATIC) == 0)   calltarget=makeNode(context,fFactory,null,CAstNode.SUPER);
 else   calltarget=makeNode(context,fFactory,null,CAstNode.VOID);
  ITypeBinding paramTypes[]=overridden.getParameterTypes();
  ArrayList<CAstNode> arguments=new ArrayList<CAstNode>();
  int i=0;
  for (  Object o : overriding.parameters()) {
    SingleVariableDeclaration svd=(SingleVariableDeclaration)o;
    CAstNode varNode=makeNode(context,fFactory,null,CAstNode.VAR,fFactory.makeConstant(svd.getName().getIdentifier()));
    ITypeBinding fromType=JDT2CAstUtils.getErasedType(paramTypes[i],ast);
    ITypeBinding toType=JDT2CAstUtils.getErasedType(overridingBinding.getParameterTypes()[i],ast);
    if (fromType.equals(toType)) {
      arguments.add(varNode);
    }
 else {
      arguments.add(createCast(null,varNode,fromType,toType,context));
    }
    i++;
  }
  CAstNode callnode=createMethodInvocation(null,overridingBinding,calltarget,arguments,context);
  CAstNode mdast=makeNode(context,fFactory,null,CAstNode.LOCAL_SCOPE,makeNode(context,fFactory,null,CAstNode.BLOCK_STMT,makeNode(context,fFactory,null,CAstNode.RETURN,callnode)));
  ArrayList<CAstType> paramCAstTypes=new ArrayList<CAstType>(overridden.getParameterTypes().length);
  for (  ITypeBinding paramType : overridden.getParameterTypes())   paramCAstTypes.add(fTypeDict.getCAstTypeFor(paramType));
  return new ProcedureEntity(mdast,overriding,overridingBinding.getDeclaringClass(),memberEntities,context,paramCAstTypes,overridden.getReturnType());
}",0.9920544835414302
40263,"/** 
 * @param n
 * @param bodyDecls
 * @param enumConstants
 * @param typeBinding
 * @param name Used in creating default constructor, and passed into new ClassEntity()
 * @param context
 * @return
 */
private CAstEntity createClassDeclaration(ASTNode n,List bodyDecls,List enumConstants,ITypeBinding typeBinding,String name,int modifiers,boolean isInterface,boolean isAnnotation,WalkContext context){
  final List<CAstEntity> memberEntities=new ArrayList<CAstEntity>();
  ArrayList<ASTNode> inits=new ArrayList<ASTNode>();
  ArrayList<ASTNode> staticInits=new ArrayList<ASTNode>();
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      EnumConstantDeclaration ecd=(EnumConstantDeclaration)decl;
      staticInits.add(ecd);
    }
  }
  for (  Object decl : bodyDecls) {
    if (decl instanceof Initializer) {
      Initializer initializer=(Initializer)decl;
      boolean isStatic=((initializer.getModifiers() & Modifier.STATIC) != 0);
      (isStatic ? staticInits : inits).add(initializer);
    }
 else     if (decl instanceof FieldDeclaration) {
      FieldDeclaration fd=(FieldDeclaration)decl;
      for (      Object f : fd.fragments()) {
        VariableDeclarationFragment frag=(VariableDeclarationFragment)f;
        if (frag.getInitializer() != null) {
          boolean isStatic=((fd.getModifiers() & Modifier.STATIC) != 0);
          (isStatic ? staticInits : inits).add(frag);
        }
      }
    }
  }
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      memberEntities.add(visit((EnumConstantDeclaration)decl,context));
    }
  }
  for (  Object d : bodyDecls) {
    BodyDeclaration decl=(BodyDeclaration)d;
    if (decl instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)decl;
      Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(fieldDecl.getModifiers(),false,false);
      for (      Object f : fieldDecl.fragments()) {
        VariableDeclarationFragment fieldFrag=(VariableDeclarationFragment)f;
        memberEntities.add(new FieldEntity(fieldFrag.getName().getIdentifier(),fieldFrag.resolveBinding().getType(),quals,makePosition(fieldFrag.getStartPosition(),fieldFrag.getStartPosition() + fieldFrag.getLength())));
      }
    }
 else     if (decl instanceof Initializer) {
    }
 else     if (decl instanceof MethodDeclaration) {
      MethodDeclaration metDecl=(MethodDeclaration)decl;
      if (typeBinding.isEnum() && metDecl.isConstructor())       memberEntities.add(createEnumConstructorWithParameters(metDecl.resolveBinding(),metDecl,context,inits,metDecl));
 else {
        memberEntities.add(visit(metDecl,typeBinding,context,inits));
        Collection<IMethodBinding> overriddenMets=JDT2CAstUtils.getOverriddenMethod(metDecl.resolveBinding());
        if (overriddenMets != null) {
          for (          IMethodBinding overridden : overriddenMets)           if (!JDT2CAstUtils.sameSignatureAndReturnType(metDecl.resolveBinding(),overridden))           memberEntities.add(makeSyntheticCovariantRedirect(metDecl,metDecl.resolveBinding(),overridden,context));
        }
      }
    }
 else     if (decl instanceof AbstractTypeDeclaration) {
      memberEntities.add(visit((AbstractTypeDeclaration)decl,context));
    }
 else     if (decl instanceof AnnotationTypeMemberDeclaration) {
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"");
    }
  }
  for (  Object m : typeBinding.getDeclaredMethods()) {
    IMethodBinding met=(IMethodBinding)m;
    if (met.isDefaultConstructor()) {
      if (typeBinding.isEnum())       memberEntities.add(createEnumConstructorWithParameters(met,n,context,inits,null));
 else       if (met.getParameterTypes().length > 0)       memberEntities.add(createDefaultConstructorWithParameters(met,n,context,inits));
 else       memberEntities.add(createDefaultConstructor(name,typeBinding,context,inits,n));
    }
  }
  if (typeBinding.isEnum() && !typeBinding.isAnonymous())   doEnumHiddenEntities(typeBinding,staticInits,memberEntities,context);
  if (!staticInits.isEmpty()) {
    Map<CAstNode,CAstEntity> childEntities=HashMapFactory.make();
    final MethodContext newContext=new MethodContext(context,childEntities);
    CAstNode[] bodyNodes=new CAstNode[staticInits.size()];
    for (int i=0; i < staticInits.size(); i++)     bodyNodes[i]=visitFieldInitNode(staticInits.get(i),newContext);
    CAstNode staticInitAst=makeNode(newContext,fFactory,n,CAstNode.BLOCK_STMT,bodyNodes);
    memberEntities.add(new ProcedureEntity(staticInitAst,typeBinding,childEntities,newContext));
  }
  Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(modifiers,isInterface,isAnnotation);
  return new ClassEntity(typeBinding,name,quals,memberEntities,makePosition(n));
}","/** 
 * @param n
 * @param bodyDecls
 * @param enumConstants
 * @param typeBinding
 * @param name Used in creating default constructor, and passed into new ClassEntity()
 * @param context
 * @return
 */
private CAstEntity createClassDeclaration(ASTNode n,List bodyDecls,List enumConstants,ITypeBinding typeBinding,String name,int modifiers,boolean isInterface,boolean isAnnotation,WalkContext context){
  final List<CAstEntity> memberEntities=new ArrayList<CAstEntity>();
  ArrayList<ASTNode> inits=new ArrayList<ASTNode>();
  ArrayList<ASTNode> staticInits=new ArrayList<ASTNode>();
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      EnumConstantDeclaration ecd=(EnumConstantDeclaration)decl;
      staticInits.add(ecd);
    }
  }
  for (  Object decl : bodyDecls) {
    if (decl instanceof Initializer) {
      Initializer initializer=(Initializer)decl;
      boolean isStatic=((initializer.getModifiers() & Modifier.STATIC) != 0);
      (isStatic ? staticInits : inits).add(initializer);
    }
 else     if (decl instanceof FieldDeclaration) {
      FieldDeclaration fd=(FieldDeclaration)decl;
      for (      Object f : fd.fragments()) {
        VariableDeclarationFragment frag=(VariableDeclarationFragment)f;
        if (frag.getInitializer() != null) {
          boolean isStatic=((fd.getModifiers() & Modifier.STATIC) != 0);
          (isStatic ? staticInits : inits).add(frag);
        }
      }
    }
  }
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      memberEntities.add(visit((EnumConstantDeclaration)decl,context));
    }
  }
  for (  Object d : bodyDecls) {
    BodyDeclaration decl=(BodyDeclaration)d;
    if (decl instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)decl;
      Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(fieldDecl.getModifiers(),false,false);
      for (      Object f : fieldDecl.fragments()) {
        VariableDeclarationFragment fieldFrag=(VariableDeclarationFragment)f;
        memberEntities.add(new FieldEntity(fieldFrag.getName().getIdentifier(),fieldFrag.resolveBinding().getType(),quals,makePosition(fieldFrag.getStartPosition(),fieldFrag.getStartPosition() + fieldFrag.getLength())));
      }
    }
 else     if (decl instanceof Initializer) {
    }
 else     if (decl instanceof MethodDeclaration) {
      MethodDeclaration metDecl=(MethodDeclaration)decl;
      if (typeBinding.isEnum() && metDecl.isConstructor())       memberEntities.add(createEnumConstructorWithParameters(metDecl.resolveBinding(),metDecl,context,inits,metDecl));
 else {
        memberEntities.add(visit(metDecl,typeBinding,context,inits));
        Collection<IMethodBinding> overriddenMets=JDT2CAstUtils.getOverriddenMethod(metDecl.resolveBinding());
        if (overriddenMets != null) {
          for (          IMethodBinding overridden : overriddenMets)           if (!JDT2CAstUtils.sameErasedSignatureAndReturnType(metDecl.resolveBinding(),overridden))           memberEntities.add(makeSyntheticCovariantRedirect(metDecl,metDecl.resolveBinding(),overridden,context));
        }
      }
    }
 else     if (decl instanceof AbstractTypeDeclaration) {
      memberEntities.add(visit((AbstractTypeDeclaration)decl,context));
    }
 else     if (decl instanceof AnnotationTypeMemberDeclaration) {
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"");
    }
  }
  for (  Object m : typeBinding.getDeclaredMethods()) {
    IMethodBinding met=(IMethodBinding)m;
    if (met.isDefaultConstructor()) {
      if (typeBinding.isEnum())       memberEntities.add(createEnumConstructorWithParameters(met,n,context,inits,null));
 else       if (met.getParameterTypes().length > 0)       memberEntities.add(createDefaultConstructorWithParameters(met,n,context,inits));
 else       memberEntities.add(createDefaultConstructor(name,typeBinding,context,inits,n));
    }
  }
  if (typeBinding.isEnum() && !typeBinding.isAnonymous())   doEnumHiddenEntities(typeBinding,staticInits,memberEntities,context);
  if (!staticInits.isEmpty()) {
    Map<CAstNode,CAstEntity> childEntities=HashMapFactory.make();
    final MethodContext newContext=new MethodContext(context,childEntities);
    CAstNode[] bodyNodes=new CAstNode[staticInits.size()];
    for (int i=0; i < staticInits.size(); i++)     bodyNodes[i]=visitFieldInitNode(staticInits.get(i),newContext);
    CAstNode staticInitAst=makeNode(newContext,fFactory,n,CAstNode.BLOCK_STMT,bodyNodes);
    memberEntities.add(new ProcedureEntity(staticInitAst,typeBinding,childEntities,newContext));
  }
  Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(modifiers,isInterface,isAnnotation);
  return new ClassEntity(typeBinding,name,quals,memberEntities,makePosition(n));
}",0.9993705413344524
40264,"protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction){
  super.visitInvokeInternal(instruction);
  if (instruction instanceof AbstractLexicalInvoke) {
    AbstractLexicalInvoke I=(AbstractLexicalInvoke)instruction;
    for (int wi=0; wi < I.getNumberOfDefs(); wi++) {
      if (I.isLexicalDef(wi)) {
        Access w=I.getLexicalDef(wi);
        for (int ri=0; ri < I.getNumberOfUses(); ri++) {
          if (I.isLexicalUse(ri)) {
            Access r=I.getLexicalUse(ri);
            if (w.variableName.equals(r.variableName)) {
              if (w.variableDefiner == null ? r.variableDefiner == null : w.variableDefiner.equals(r.variableDefiner)) {
                PointerKey rk=getBuilder().getPointerKeyForLocal(node,r.valueNumber);
                PointerKey wk=getBuilder().getPointerKeyForLocal(node,w.valueNumber);
                system.newConstraint(wk,assignOperator,rk);
              }
            }
          }
        }
      }
    }
  }
}","protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction){
  super.visitInvokeInternal(instruction);
  if (instruction instanceof AbstractLexicalInvoke) {
    AbstractLexicalInvoke I=(AbstractLexicalInvoke)instruction;
    for (int wi=0; wi < I.getNumberOfDefs(); wi++) {
      if (I.isLexicalDef(wi)) {
        Access w=I.getLexicalDef(wi);
        for (int ri=0; ri < I.getNumberOfUses(); ri++) {
          if (I.isLexicalUse(ri)) {
            Access r=I.getLexicalUse(ri);
            if (w.variableName.equals(r.variableName)) {
              if (w.variableDefiner == null ? r.variableDefiner == null : w.variableDefiner.equals(r.variableDefiner)) {
                PointerKey rk=getBuilder().getPointerKeyForLocal(node,r.valueNumber);
                PointerKey wk=getBuilder().getPointerKeyForLocal(node,w.valueNumber);
                if (contentsAreInvariant(symbolTable,du,r.valueNumber)) {
                  system.recordImplicitPointsToSet(rk);
                  for (                  InstanceKey ik : getInvariantContents(r.valueNumber)) {
                    system.newConstraint(wk,ik);
                  }
                }
 else {
                  system.newConstraint(wk,assignOperator,rk);
                }
              }
            }
          }
        }
      }
    }
  }
}",0.8518197573656846
40265,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or null if not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}",0.998531571218796
40266,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of  {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href=""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"">bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public static String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=null;
  try {
    uri=new URI(url.toString());
  }
 catch (  URISyntaxException e) {
    Assertions.UNREACHABLE();
  }
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public static String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  String filePath=uri.getPath();
  return filePath;
}",0.8433575677461996
40267,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or null if not found.
 * @throws IllegalArgumentException if p is null
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 * @throws IllegalArgumentException if p is null
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}",0.999140154772141
40268,"/** 
 * escape spaces in a URL, primarily to work around a bug in   {@link File#toURL()}
 * @param url
 * @return an escaped version of the URL
 */
private static URL fixupFileURLSpaces(URL url){
  String urlString=url.toExternalForm();
  StringBuffer fixedUpUrl=new StringBuffer();
  int lastIndex=0;
  while (true) {
    int spaceIndex=urlString.indexOf(' ',lastIndex);
    if (spaceIndex < 0) {
      fixedUpUrl.append(urlString.substring(lastIndex));
      break;
    }
    fixedUpUrl.append(urlString.substring(lastIndex,spaceIndex));
    fixedUpUrl.append(""String_Node_Str"");
    lastIndex=spaceIndex + 1;
  }
  try {
    return new URL(fixedUpUrl.toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
  return null;
}","/** 
 * escape spaces in a URL, primarily to work around a bug in  {@link File#toURL()}
 * @param url
 * @return an escaped version of the URL
 */
private static URL fixupFileURLSpaces(URL url){
  String urlString=url.toExternalForm();
  StringBuffer fixedUpUrl=new StringBuffer();
  int lastIndex=0;
  while (true) {
    int spaceIndex=urlString.indexOf(' ',lastIndex);
    if (spaceIndex < 0) {
      fixedUpUrl.append(urlString.substring(lastIndex));
      break;
    }
    fixedUpUrl.append(urlString.substring(lastIndex,spaceIndex));
    fixedUpUrl.append(""String_Node_Str"");
    lastIndex=spaceIndex + 1;
  }
  try {
    return new URL(fixedUpUrl.toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
  return null;
}",0.9993610223642172
40269,"/** 
 * @return the jar file packaged with this plug-in of the given name, or null if not found: wrapped as a JarFileModule or aNestedJarFileModule
 * @throws IOException
 */
public static Module getJarFileFromClassLoader(String fileName,ClassLoader loader) throws IOException {
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ fileName);
  }
  if (url == null) {
    try {
      return new JarFileModule(new JarFile(fileName,false));
    }
 catch (    ZipException e) {
      throw new IOException(""String_Node_Str"" + fileName);
    }
  }
  if (url.getProtocol().equals(""String_Node_Str"")) {
    JarURLConnection jc=(JarURLConnection)url.openConnection();
    JarFile f=jc.getJarFile();
    JarEntry entry=jc.getJarEntry();
    JarFileModule parent=new JarFileModule(f);
    return new NestedJarFileModule(parent,entry);
  }
 else {
    String filePath=filePathFromURL(url);
    return new JarFileModule(new JarFile(filePath,false));
  }
}","/** 
 * @return the jar file packaged with this plug-in of the given name, or nullif not found: wrapped as a JarFileModule or a NestedJarFileModule
 * @throws IOException
 */
public static Module getJarFileFromClassLoader(String fileName,ClassLoader loader) throws IOException {
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ fileName);
  }
  if (url == null) {
    try {
      return new JarFileModule(new JarFile(fileName,false));
    }
 catch (    ZipException e) {
      throw new IOException(""String_Node_Str"" + fileName);
    }
  }
  if (url.getProtocol().equals(""String_Node_Str"")) {
    JarURLConnection jc=(JarURLConnection)url.openConnection();
    JarFile f=jc.getJarFile();
    JarEntry entry=jc.getJarEntry();
    JarFileModule parent=new JarFileModule(f);
    return new NestedJarFileModule(parent,entry);
  }
 else {
    String filePath=filePathFromURL(url);
    return new JarFileModule(new JarFile(filePath,false));
  }
}",0.9991666666666666
40270,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(JDTJavaIRTests.PROJECT_NAME){
    @Override protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.9721175584024114
40271,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9742268041237112
40272,"protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,engine,sources,libs);
}","@Override protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,(JDTJavaSourceAnalysisEngine)engine,sources,libs);
}",0.908235294117647
40273,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(PROJECT_NAME){
    @Override protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.9832317073170732
40274,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9742268041237112
40275,"protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,engine,sources,libs);
}","@Override protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,(JDTJavaSourceAnalysisEngine)engine,sources,libs);
}",0.908235294117647
40276,"public static void populateScope(String projectName,JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
}","public static void populateScope(String projectName,JDTJavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
}",0.990228013029316
40277,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=makeSourceLoader(classLoaderReference,cha,parent);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.909657320872274
40278,"@SuppressWarnings(""String_Node_Str"") public void loadAllSources(Set modules){
}","public void loadAllSources(Set modules){
}",0.6942148760330579
40279,"protected void loadAllSources(Set<ModuleEntry> modules){
  getTranslator().loadAllSources(modules);
  fTypeMap=null;
}","protected void loadAllSources(Set<ModuleEntry> modules){
  getTranslator().loadAllSources(modules);
}",0.9223744292237442
40280,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
            break;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9978067644003232
40281,"/** 
 * Build an IR, then check integrity on two flavors of CFG
 */
private void doMethod(String methodSig){
  try {
    AnalysisScope scope=AnalysisScopeReader.makePrimordialScope(FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    MethodReference mr=StringStuff.makeMethodReference(Language.JAVA,methodSig);
    IMethod m=cha.resolveMethod(mr);
    if (m == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + mr);
    }
    AnalysisOptions options=new AnalysisOptions();
    AnalysisCache cache=new AnalysisCache();
    options.getSSAOptions().setPiNodePolicy(SSAOptions.getAllBuiltInPiNodes());
    IR ir=cache.getSSACache().findOrCreateIR(m,Everywhere.EVERYWHERE,options.getSSAOptions());
    ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      System.err.println(cfg);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
}","/** 
 * Build an IR, then check integrity on two flavors of CFG
 */
private void doMethod(String methodSig){
  try {
    MethodReference mr=StringStuff.makeMethodReference(Language.JAVA,methodSig);
    IMethod m=cha.resolveMethod(mr);
    if (m == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + mr);
    }
    AnalysisOptions options=new AnalysisOptions();
    AnalysisCache cache=new AnalysisCache();
    options.getSSAOptions().setPiNodePolicy(SSAOptions.getAllBuiltInPiNodes());
    IR ir=cache.getSSACache().findOrCreateIR(m,Everywhere.EVERYWHERE,options.getSSAOptions());
    ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      System.err.println(cfg);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
}",0.931391337677271
40282,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9586992641822928
40283,"/** 
 * Return a view of the   {@link ControlFlowGraph} for an {@link IR}, which elides all exceptional exits from PEIs in the IR.
 */
public static Graph<ISSABasicBlock> sanitize(IR ir,IClassHierarchy cha) throws IllegalArgumentException, WalaException {
  if (ir == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
  Graph<ISSABasicBlock> g=SlowSparseNumberedGraph.make();
  for (Iterator<? extends ISSABasicBlock> it=cfg.iterator(); it.hasNext(); ) {
    g.addNode(it.next());
  }
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
      ISSABasicBlock b2=(ISSABasicBlock)it2.next();
      if (!b2.isExitBlock()) {
        g.addEdge(b,b2);
      }
    }
  }
  ISSABasicBlock exit=cfg.exit();
  for (Iterator it=cfg.getPredNodes(exit); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    SSAInstruction s=ir.getInstructions()[b.getLastInstructionIndex()];
    if (s == null) {
      continue;
    }
    if (s instanceof SSAReturnInstruction || s instanceof SSAThrowInstruction) {
      g.addEdge(b,exit);
    }
 else {
      TypeReference[] exceptions=null;
      try {
        exceptions=computeExceptions(cha,ir,s);
      }
 catch (      InvalidClassFileException e1) {
        e1.printStackTrace();
        Assertions.UNREACHABLE();
      }
      for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
        IBasicBlock c=(IBasicBlock)it2.next();
        if (c.isCatchBlock()) {
          SSACFG.ExceptionHandlerBasicBlock cb=(ExceptionHandlerBasicBlock)c;
          for (Iterator it3=cb.getCaughtExceptionTypes(); it3.hasNext(); ) {
            TypeReference ex=(TypeReference)it3.next();
            IClass exClass=cha.lookupClass(ex);
            if (exClass == null) {
              throw new WalaException(""String_Node_Str"" + ex);
            }
            for (int i=0; i < exceptions.length; i++) {
              if (exceptions[i] != null) {
                IClass exi=cha.lookupClass(exceptions[i]);
                if (exi == null) {
                  throw new WalaException(""String_Node_Str"" + exceptions[i]);
                }
                if (cha.isSubclassOf(exi,exClass)) {
                  exceptions[i]=null;
                }
              }
            }
          }
        }
      }
      TypeReference[] declared=null;
      try {
        declared=ir.getMethod().getDeclaredExceptions();
      }
 catch (      InvalidClassFileException e) {
        e.printStackTrace();
        Assertions.UNREACHABLE();
      }
      if (declared != null && exceptions != null) {
        for (int i=0; i < exceptions.length; i++) {
          boolean isDeclared=false;
          if (exceptions[i] != null) {
            IClass exi=cha.lookupClass(exceptions[i]);
            if (exi == null) {
              throw new WalaException(""String_Node_Str"" + exceptions[i]);
            }
            for (int j=0; j < declared.length; j++) {
              IClass dc=cha.lookupClass(declared[j]);
              if (dc == null) {
                throw new WalaException(""String_Node_Str"" + declared[j]);
              }
              if (cha.isSubclassOf(exi,dc)) {
                isDeclared=true;
                break;
              }
            }
            if (isDeclared) {
              g.addEdge(b,exit);
            }
          }
        }
      }
    }
  }
  return g;
}","/** 
 * Return a view of the   {@link ControlFlowGraph} for an {@link IR}, which elides all exceptional exits from PEIs in the IR.
 */
public static Graph<ISSABasicBlock> sanitize(IR ir,IClassHierarchy cha) throws IllegalArgumentException, WalaException {
  if (ir == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
  Graph<ISSABasicBlock> g=SlowSparseNumberedGraph.make();
  for (Iterator<? extends ISSABasicBlock> it=cfg.iterator(); it.hasNext(); ) {
    g.addNode(it.next());
  }
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
      ISSABasicBlock b2=(ISSABasicBlock)it2.next();
      if (!b2.isExitBlock()) {
        g.addEdge(b,b2);
      }
    }
  }
  ISSABasicBlock exit=cfg.exit();
  for (Iterator it=cfg.getPredNodes(exit); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    SSAInstruction s=ir.getInstructions()[b.getLastInstructionIndex()];
    if (s == null) {
      continue;
    }
    if (s instanceof SSAReturnInstruction || s instanceof SSAThrowInstruction || cfg.getSuccNodeCount(b) == 1) {
      g.addEdge(b,exit);
    }
 else {
      TypeReference[] exceptions=null;
      try {
        exceptions=computeExceptions(cha,ir,s);
      }
 catch (      InvalidClassFileException e1) {
        e1.printStackTrace();
        Assertions.UNREACHABLE();
      }
      for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
        IBasicBlock c=(IBasicBlock)it2.next();
        if (c.isCatchBlock()) {
          SSACFG.ExceptionHandlerBasicBlock cb=(ExceptionHandlerBasicBlock)c;
          for (Iterator it3=cb.getCaughtExceptionTypes(); it3.hasNext(); ) {
            TypeReference ex=(TypeReference)it3.next();
            IClass exClass=cha.lookupClass(ex);
            if (exClass == null) {
              throw new WalaException(""String_Node_Str"" + ex);
            }
            for (int i=0; i < exceptions.length; i++) {
              if (exceptions[i] != null) {
                IClass exi=cha.lookupClass(exceptions[i]);
                if (exi == null) {
                  throw new WalaException(""String_Node_Str"" + exceptions[i]);
                }
                if (cha.isSubclassOf(exi,exClass)) {
                  exceptions[i]=null;
                }
              }
            }
          }
        }
      }
      TypeReference[] declared=null;
      try {
        declared=ir.getMethod().getDeclaredExceptions();
      }
 catch (      InvalidClassFileException e) {
        e.printStackTrace();
        Assertions.UNREACHABLE();
      }
      if (declared != null && exceptions != null) {
        for (int i=0; i < exceptions.length; i++) {
          boolean isDeclared=false;
          if (exceptions[i] != null) {
            IClass exi=cha.lookupClass(exceptions[i]);
            if (exi == null) {
              throw new WalaException(""String_Node_Str"" + exceptions[i]);
            }
            for (int j=0; j < declared.length; j++) {
              IClass dc=cha.lookupClass(declared[j]);
              if (dc == null) {
                throw new WalaException(""String_Node_Str"" + declared[j]);
              }
              if (cha.isSubclassOf(exi,dc)) {
                isDeclared=true;
                break;
              }
            }
            if (isDeclared) {
              g.addEdge(b,exit);
            }
          }
        }
      }
    }
  }
  return g;
}",0.995481502400452
40284,"/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    removeClassFiles(classFiles,classModuleEntries);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
  loadAllClasses(classModuleEntries);
  loadAllSources(sourceModuleEntries);
}","/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    if (OPTIMIZE_JAR_FILE_IO && archive instanceof JarFileModule) {
      getJarFileContents((JarFileModule)archive);
    }
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    removeClassFiles(classFiles,classModuleEntries);
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    Map<String,Object> allClassAndSourceFileContents=null;
    if (OPTIMIZE_JAR_FILE_IO) {
    }
    loadAllClasses(classFiles,allClassAndSourceFileContents);
    loadAllSources(sourceFiles);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
}",0.6871711857547551
40285,"/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle reader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClass klass=new ShrikeClass(reader,this,cha);
        if (klass.getReference().getName().equals(T)) {
          loadedClasses.put(T,klass);
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}","/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries,Map<String,Object> fileContents){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle entryReader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClassReaderHandle reader=entryReader;
        if (fileContents != null) {
          final Object contents=fileContents.get(entry.getName());
          if (contents != null) {
            reader=new ByteArrayReaderHandle(entry,(byte[])contents);
          }
        }
        ShrikeClass tmpKlass=new ShrikeClass(reader,this,cha);
        if (tmpKlass.getReference().getName().equals(T)) {
          loadedClasses.put(T,new ShrikeClass(entryReader,this,cha));
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}",0.9051768323936444
40286,"@SuppressWarnings(""String_Node_Str"") void processJSCall(CGNode caller,JavaScriptInvoke instruction,CGNode target,InstanceKey function,InstanceKey constParams[][],PointerKey uniqueCatchKey){
  caller.addTarget(instruction.getCallSite(),target);
  if (!getBuilder().haveAlreadyVisited(target)) {
    getBuilder().markDiscovered(target);
  }
  IR sourceIR=getBuilder().getCFAContextInterpreter().getIR(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IR targetIR=getBuilder().getCFAContextInterpreter().getIR(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    int fn=targetST.getConstant(i);
    PointerKey F=(i == 0) ? getBuilder().getFilteredPointerKeyForLocal(target,targetST.getParameter(i),function) : getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        system.newConstraint(F,constParams[i][j]);
      }
      if (av != -1)       newFieldWrite(target,av,fn,constParams[i]);
    }
 else {
      PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
      system.newConstraint(F,(F instanceof FilteredPointerKey) ? getBuilder().filterOperator : assignOperator,A);
      if (av != -1)       newFieldWrite(target,av,fn,F);
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        int fn=targetST.getConstant(i);
        if (constParams != null && constParams[i] != null) {
          newFieldWrite(target,av,fn,constParams[i]);
        }
 else {
          PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
          newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=getBuilder().getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=getInvariantContents(sourceST,sourceDU,caller,nullvn);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        system.newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    int svn=targetST.getConstant(argCount);
    int lnv=targetST.getConstant(""String_Node_Str"");
    newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=getBuilder().getPointerKeyForReturnValue(target);
    PointerKey RA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(0));
    system.newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=getBuilder().getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(1));
    system.newConstraint(EA,assignOperator,EF);
  }
}","@SuppressWarnings(""String_Node_Str"") void processJSCall(CGNode caller,JavaScriptInvoke instruction,CGNode target,InstanceKey function,InstanceKey constParams[][],PointerKey uniqueCatchKey){
  caller.addTarget(instruction.getCallSite(),target);
  if (!getBuilder().haveAlreadyVisited(target)) {
    getBuilder().markDiscovered(target);
  }
  IR sourceIR=getBuilder().getCFAContextInterpreter().getIR(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IR targetIR=getBuilder().getCFAContextInterpreter().getIR(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    int fn=targetST.getConstant(i);
    PointerKey F=(i == 0) ? getBuilder().getFilteredPointerKeyForLocal(target,targetST.getParameter(i),function.getConcreteType()) : getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        system.newConstraint(F,constParams[i][j]);
      }
      if (av != -1)       newFieldWrite(target,av,fn,constParams[i]);
    }
 else {
      PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
      system.newConstraint(F,(F instanceof FilteredPointerKey) ? getBuilder().filterOperator : assignOperator,A);
      if (av != -1)       newFieldWrite(target,av,fn,F);
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        int fn=targetST.getConstant(i);
        if (constParams != null && constParams[i] != null) {
          newFieldWrite(target,av,fn,constParams[i]);
        }
 else {
          PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
          newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=getBuilder().getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=getInvariantContents(sourceST,sourceDU,caller,nullvn);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        system.newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    int svn=targetST.getConstant(argCount);
    int lnv=targetST.getConstant(""String_Node_Str"");
    newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=getBuilder().getPointerKeyForReturnValue(target);
    PointerKey RA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(0));
    system.newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=getBuilder().getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(1));
    system.newConstraint(EA,assignOperator,EF);
  }
}",0.9973714953271028
40287,"@Test public void testTestCD5() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=findOrCreateAnalysisScope();
  IClassHierarchy cha=findOrCreateCHA(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE_TESTCD5);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMainMethod(cg);
  Statement s=new MethodEntryStatement(main);
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.NONE,ControlDependenceOptions.FULL);
  dumpSlice(slice);
  Assert.assertTrue(slice.size() > 1);
}","@Test public void testTestCD5() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=findOrCreateAnalysisScope();
  IClassHierarchy cha=findOrCreateCHA(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE_TESTCD5);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMainMethod(cg);
  Statement s=new MethodEntryStatement(main);
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.NONE,ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);
  dumpSlice(slice);
  Assert.assertTrue(slice.size() > 1);
}",0.9880823401950164
40288,"public void setPc(int pc){
  Integer lineNum=pcToLine.get(pc);
  if (lineNum != null) {
    irLines.ensureIndexIsVisible(lineNum);
    irLines.setSelectedIndex(lineNum);
  }
}","public void setPc(int pc){
  Integer lineNum=pcToLine.get(pc);
  if (lineNum != null) {
    irLines.ensureIndexIsVisible(lineNum);
    irLines.setSelectedIndex(lineNum);
  }
 else {
    removeSelection();
  }
}",0.9090909090909092
40289,"public void setIRAndPc(IR ir,int pc){
  setIR(ir);
  if (pc != NA) {
    setPc(pc);
  }
 else {
    int curSelectedIndex=irLines.getSelectedIndex();
    irLines.removeSelectionInterval(curSelectedIndex,curSelectedIndex);
  }
}","public void setIRAndPc(IR ir,int pc){
  setIR(ir);
  if (pc != NA) {
    setPc(pc);
  }
 else {
    removeSelection();
  }
}",0.7085714285714285
40290,"public void setSource(URL url,int sourceLine){
  sourceCodeLocation.setText(""String_Node_Str"" + url);
  loadSource(url);
  if (sourceLine != IrViewer.NA) {
    sourceCodeLines.ensureIndexIsVisible(sourceLine - 1);
    sourceCodeLines.setSelectedIndex(sourceLine - 1);
    sourceCodeLines.validate();
  }
}","public void setSource(URL url,int sourceLine){
  boolean succsess=loadSource(url);
  if (succsess) {
    sourceCodeLocation.setText(""String_Node_Str"" + url);
    if (sourceLine != IrViewer.NA) {
      sourceCodeLines.ensureIndexIsVisible(sourceLine - 1);
      sourceCodeLines.setSelectedIndex(sourceLine - 1);
      sourceCodeLines.validate();
    }
  }
 else {
    sourceCodeLocation.setText(""String_Node_Str"" + url);
  }
}",0.7890410958904109
40291,"public void removeSource(){
  sourceURL=null;
  sourceCodeLocation=new JTextField(""String_Node_Str"");
  sourceCodeLinesList.clear();
  sourceCodeLines.validate();
}","public void removeSource(){
  sourceURL=null;
  sourceCodeLocation.setText(""String_Node_Str"");
  sourceCodeLinesList.clear();
  sourceCodeLines.validate();
}",0.9595015576323987
40292,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  symtab.getConstant(""String_Node_Str"");
  symtab.getConstant(""String_Node_Str"");
  for (int i=0; i < 15; i++) {
    symtab.getConstant(i);
  }
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  symtab.getConstant(""String_Node_Str"");
  symtab.getConstant(""String_Node_Str"");
  for (int i=0; i < 20; i++) {
    symtab.getConstant(i);
  }
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9970414201183432
40293,"protected void doFieldWrite(WalkContext context,int receiver,CAstNode elt,CAstNode parent,int rval){
  this.visit(elt,context,this);
  if (elt.getKind() == CAstNode.CONSTANT && elt.getValue() instanceof String) {
    context.cfg().addInstruction(((JSInstructionFactory)insts).PutInstruction(receiver,rval,(String)elt.getValue()));
  }
 else {
    context.cfg().addInstruction(((JSInstructionFactory)insts).PropertyWrite(receiver,getValue(elt),rval));
  }
}","protected void doFieldWrite(WalkContext context,int receiver,CAstNode elt,CAstNode parent,int rval){
}",0.3655913978494624
40294,"public void handleSimpleTag(HTML.Tag t,MutableAttributeSet a,int pos){
  System.out.println(""String_Node_Str"" + t);
  if (script) {
    try {
      writeEmbeddedScript(""String_Node_Str"" + t);
      Enumeration names=a.getAttributeNames();
      while (names.hasMoreElements()) {
        Object name=names.nextElement();
        Object val=a.getAttribute(name);
        writeEmbeddedScript(""String_Node_Str"" + name + ""String_Node_Str""+ val+ ""String_Node_Str"");
      }
      writeEmbeddedScript(""String_Node_Str"" + t + ""String_Node_Str"");
    }
 catch (    IOException e) {
    }
  }
 else {
    String nm=createElement(t,a);
    endElement(nm);
  }
}","public void handleSimpleTag(HTML.Tag t,MutableAttributeSet a,int pos){
  System.out.println(""String_Node_Str"" + t);
  if (script) {
  }
 else {
    String nm=createElement(t,a,pos);
    endElement(nm);
  }
}",0.4737456242707117
40295,"protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}","protected String createElement(HTML.Tag t,MutableAttributeSet a,int pos){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
        scriptStart=pos;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}",0.9903197418597828
40296,"public void handleEndTag(HTML.Tag t,int pos){
  if (t.toString().toUpperCase().equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    try {
      writeEmbeddedScript(""String_Node_Str"");
    }
 catch (    IOException e) {
    }
    script=false;
  }
  endElement(stack.pop());
}","public void handleEndTag(HTML.Tag t,int pos){
  if (t.toString().toUpperCase().equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    if (script)     try {
      int scriptEnd=pos;
      InputStreamReader script=new InputStreamReader(input.openStream());
      char[] buf=new char[scriptEnd];
      script.read(buf);
      String s=String.valueOf(buf,scriptStart,scriptEnd - scriptStart);
      writeEmbeddedScript(s.substring(s.indexOf('>') + 1));
    }
 catch (    IOException e) {
    }
    script=false;
  }
  endElement(stack.pop());
}",0.6542491268917345
40297,"private void writeEmbeddedScript(String text) throws IOException {
  embeddedScriptFile.write(text);
  embeddedScriptFile.write(""String_Node_Str"");
}","private void writeEmbeddedScript(String text) throws IOException {
  embeddedScriptFile.write(text);
}",0.8127490039840638
40298,"public void handleStartTag(HTML.Tag t,MutableAttributeSet a,int pos){
  String varName=createElement(t,a);
  stack.push(varName);
}","public void handleStartTag(HTML.Tag t,MutableAttributeSet a,int pos){
  String varName=createElement(t,a,pos);
  stack.push(varName);
}",0.9849624060150376
40299,"public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
case CATCH:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case METHOD_EXIT:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}","public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
case CATCH:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case METHOD_EXIT:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9730941704035876
40300,"public HTMLEditorKit.ParserCallback createCallback(URL input,FileWriter domTreeFile,FileWriter embeddedScriptFile,FileWriter entrypointFile){
  return new HTMLCallback(input,domTreeFile,embeddedScriptFile,entrypointFile);
}","public HTMLCallback createCallback(URL input,FileWriter domTreeFile,FileWriter embeddedScriptFile,FileWriter entrypointFile){
  return new HTMLCallback(input,domTreeFile,embeddedScriptFile,entrypointFile);
}",0.9627906976744186
40301,"public void generate(URL input,File outFile) throws IOException {
  InputStreamReader fr=getStream(input);
  FileWriter out=new FileWriter(outFile);
  FileWriter out1=new FileWriter(temp1);
  FileWriter out2=new FileWriter(temp2);
  FileWriter out3=new FileWriter(temp3);
  ParserDelegator pd=new ParserDelegator();
  HTMLEditorKit.ParserCallback cb=callbackFactory.createCallback(input,out1,out2,out3);
  pd.parse(fr,cb,ignoreCharset);
  out1.close();
  out2.close();
  out3.close();
  out.write(""String_Node_Str"" + input + ""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp2);
  writeRegion(out,""String_Node_Str"",temp1);
  out.write(""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp3);
  out.write(""String_Node_Str"");
  generateTrailer(out,cb);
  out.close();
}","public void generate(URL input,File outFile) throws IOException {
  InputStreamReader fr=getStream(input);
  FileWriter out=new FileWriter(outFile);
  FileWriter out1=new FileWriter(temp1);
  FileWriter out2=new FileWriter(temp2);
  FileWriter out3=new FileWriter(temp3);
  ParserDelegator pd=new ParserDelegator();
  HTMLCallback cb=callbackFactory.createCallback(input,out1,out2,out3);
  pd.parse(fr,cb,ignoreCharset);
  out1.flush();
  out1.close();
  out2.flush();
  out2.close();
  out3.flush();
  out3.close();
  out.write(""String_Node_Str"" + input + ""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp2);
  writeRegion(out,""String_Node_Str"",temp1);
  out.write(""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp3);
  out.write(""String_Node_Str"");
  generateTrailer(out,cb);
  out.close();
}",0.96
40302,"protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer);
            writeEmbeddedScript(""String_Node_Str"");
          }
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}","protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}",0.9719350073855244
40303,"private void getScript(char[] data){
  if (script) {
    try {
      writeEmbeddedScript(data);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
}","private void getScript(char[] data){
  if (script) {
    try {
      writeEmbeddedScript(data,data.length);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
}",0.9689119170984456
40304,"public static int countNormals(Collection<Statement> slice){
  int count=0;
  for (  Statement s : slice) {
    if (s.getKind().equals(Statement.Kind.NORMAL)) {
      NormalStatement ns=(NormalStatement)s;
      count++;
    }
  }
  return count;
}","public static int countNormals(Collection<Statement> slice){
  int count=0;
  for (  Statement s : slice) {
    if (s.getKind().equals(Statement.Kind.NORMAL)) {
      count++;
    }
  }
  return count;
}",0.9002217294900222
40305,"@Override public void visitCheckCast(SSACheckCastInstruction instruction){
  TypeAbstraction typeAbs=null;
  for (  TypeReference type : instruction.getDeclaredResultTypes()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      typeAbs=BOTTOM;
    }
 else {
      if (typeAbs == null) {
        typeAbs=new ConeType(klass);
      }
 else {
        typeAbs=typeAbs.meet(new ConeType(klass));
      }
    }
  }
}","@Override public void visitCheckCast(SSACheckCastInstruction instruction){
  TypeAbstraction typeAbs=null;
  for (  TypeReference type : instruction.getDeclaredResultTypes()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      typeAbs=BOTTOM;
    }
 else {
      if (typeAbs == null) {
        typeAbs=new ConeType(klass);
      }
 else {
        typeAbs=typeAbs.meet(new ConeType(klass));
      }
    }
  }
  result=new DeclaredTypeOperator(typeAbs);
}",0.9491150442477876
40306,"/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,boolean includeSource,boolean cpeFromMainProject) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,includeSource,false);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      List<Module> s=MapUtil.findOrCreateList(modules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    if (includeSource) {
      List<Module> s=MapUtil.findOrCreateList(modules,Loader.APPLICATION);
      s.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
    }
 else     if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      List<Module> s=MapUtil.findOrCreateList(modules,cpeFromMainProject ? Loader.APPLICATION : loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        if (isPluginProject(javaProject)) {
          resolvePluginClassPath(javaProject.getProject(),includeSource);
        }
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,scopeType == AnalysisScopeType.SOURCE_FOR_PROJ_AND_LINKED_PROJS ? includeSource : false,false);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        List<Module> s=MapUtil.findOrCreateList(modules,loader);
        if (!includeSource) {
          s.add(new BinaryDirectoryTreeModule(output));
        }
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,boolean includeSource,boolean cpeFromMainProject) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,includeSource,false);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      List<Module> s=MapUtil.findOrCreateList(modules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    if (includeSource) {
      List<Module> s=MapUtil.findOrCreateList(modules,Loader.APPLICATION);
      s.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
    }
 else     if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      List<Module> s=MapUtil.findOrCreateList(modules,cpeFromMainProject ? Loader.APPLICATION : loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        if (isPluginProject(javaProject)) {
          resolvePluginClassPath(javaProject.getProject(),includeSource);
        }
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,scopeType == AnalysisScopeType.SOURCE_FOR_PROJ_AND_LINKED_PROJS ? includeSource : false,false);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        List<Module> s=MapUtil.findOrCreateList(modules,loader);
        if (!includeSource) {
          if (output.exists()) {
            s.add(new BinaryDirectoryTreeModule(output));
          }
        }
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}",0.9918923581162672
40307,"public static CGNode findMainMethod(CallGraph cg){
  Descriptor d=Descriptor.findOrCreateUTF8(""String_Node_Str"");
  Atom name=Atom.findOrCreateUnicodeAtom(""String_Node_Str"");
  for (Iterator<? extends CGNode> it=cg.getSuccNodes(cg.getFakeRootNode()); it.hasNext(); ) {
    CGNode n=it.next();
    if (n.getMethod().getName().equals(name) && n.getMethod().getDescriptor().equals(d)) {
      return n;
    }
  }
  Assertions.UNREACHABLE(""String_Node_Str"");
  return null;
}","public static CGNode findMainMethod(CallGraph cg){
  Descriptor d=Descriptor.findOrCreateUTF8(""String_Node_Str"");
  Atom name=Atom.findOrCreateUnicodeAtom(""String_Node_Str"");
  return findMethod(cg,d,name);
}",0.5331369661266568
40308,"/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}","/** 
 * Create nodes corresponding to <ul> <li>phi instructions <li>getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}",0.998502994011976
40309,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      final NormalStatement statement=new NormalStatement(node,i);
      delegate.addNode(statement);
      if (s instanceof SSAAbstractInvokeInstruction) {
        callSite2Statement.put(((SSAAbstractInvokeInstruction)s).getCallSite(),statement);
        addParamPassingStatements(i,ref,ir);
      }
    }
  }
}",0.8323076923076923
40310,"public Iterator<? extends Statement> getCallSites(Statement r,PDG callee){
switch (r.getKind()) {
case EXC_RET_CALLER:
{
      ExceptionalReturnCaller n=(ExceptionalReturnCaller)r;
      SSAAbstractInvokeInstruction call=n.getInstruction();
      PDG pdg=getProcOf(r);
      return pdg.getCallerParamStatements(call).iterator();
    }
case NORMAL_RET_CALLER:
{
    NormalReturnCaller n=(NormalReturnCaller)r;
    SSAAbstractInvokeInstruction call=n.getInstruction();
    PDG pdg=getProcOf(r);
    return pdg.getCallerParamStatements(call).iterator();
  }
case HEAP_RET_CALLER:
{
  HeapStatement.HeapReturnCaller n=(HeapStatement.HeapReturnCaller)r;
  SSAAbstractInvokeInstruction call=n.getCall();
  PDG pdg=getProcOf(r);
  return pdg.getCallerParamStatements(call).iterator();
}
default :
Assertions.UNREACHABLE(r.getKind().toString());
return null;
}
}","public Iterator<? extends Statement> getCallSites(Statement r,PDG callee){
switch (r.getKind()) {
case EXC_RET_CALLER:
{
      ExceptionalReturnCaller n=(ExceptionalReturnCaller)r;
      SSAAbstractInvokeInstruction call=n.getInstruction();
      PDG pdg=getProcOf(r);
      return pdg.getCallStatements(call).iterator();
    }
case NORMAL_RET_CALLER:
{
    NormalReturnCaller n=(NormalReturnCaller)r;
    SSAAbstractInvokeInstruction call=n.getInstruction();
    PDG pdg=getProcOf(r);
    return pdg.getCallStatements(call).iterator();
  }
case HEAP_RET_CALLER:
{
  HeapStatement.HeapReturnCaller n=(HeapStatement.HeapReturnCaller)r;
  SSAAbstractInvokeInstruction call=n.getCall();
  PDG pdg=getProcOf(r);
  return pdg.getCallStatements(call).iterator();
}
default :
Assertions.UNREACHABLE(r.getKind().toString());
return null;
}
}",0.9875518672199172
40311,"/** 
 * create a demand points-to analysis runner using a   {@link DemandPointerFlowGraph} as the underlying flow graph.
 * @see #make(CallGraph,HeapModel,MemoryAccessMap,IClassHierarchy,AnalysisOptions,StateMachineFactory,IFlowGraph)
 */
public static DemandRefinementPointsTo makeWithDefaultFlowGraph(CallGraph cg,HeapModel model,MemoryAccessMap mam,IClassHierarchy cha,AnalysisOptions options,StateMachineFactory<IFlowLabel> stateMachineFactory){
  return make(cg,new ThisFilteringHeapModel(model,cha),mam,cha,options,stateMachineFactory,new DemandPointerFlowGraph(cg,model,mam,cha));
}","/** 
 * create a demand points-to analysis runner
 * @param cg the underlying call graph for the analysis
 * @param model the heap model to be used for the analysis
 * @param mam indicates what code reads or writes each field
 * @param cha
 * @param options
 * @param stateMachineFactory factory for state machines to track additional properties like calling context
 */
public static DemandRefinementPointsTo makeWithDefaultFlowGraph(CallGraph cg,HeapModel model,MemoryAccessMap mam,IClassHierarchy cha,AnalysisOptions options,StateMachineFactory<IFlowLabel> stateMachineFactory){
  final ThisFilteringHeapModel thisFilteringHeapModel=new ThisFilteringHeapModel(model,cha);
  return new DemandRefinementPointsTo(cg,thisFilteringHeapModel,mam,cha,options,stateMachineFactory,new DemandPointerFlowGraph(cg,thisFilteringHeapModel,mam,cha));
}",0.2729181245626312
40312,"public JDTJava15IRTests(){
  super(""String_Node_Str"",""String_Node_Str"");
}","public JDTJava15IRTests(){
  super(""String_Node_Str"");
}",0.8615384615384616
40313,"public JDTJavaIRTests(){
  super(""String_Node_Str"",""String_Node_Str"");
}","public JDTJavaIRTests(){
  super(""String_Node_Str"");
}",0.8571428571428571
40314,"public PolyglotJavaIRTests(){
  super(""String_Node_Str"");
}","public PolyglotJavaIRTests(){
  super(null);
}",0.819047619047619
40315,"protected String singleJavaPkgInputForTest(String pkgName){
  return pkgName + File.separator + getName().substring(4)+ ""String_Node_Str"";
}","protected String singleJavaPkgInputForTest(String pkgName){
  return pkgName + File.separator + getTestName().substring(4)+ ""String_Node_Str"";
}",0.9859154929577464
40316,"protected String singleInputForTest(){
  return getName().substring(4);
}","protected String singleInputForTest(){
  return getTestName().substring(4);
}",0.9733333333333334
40317,"protected String singleJavaInputForTest(){
  return getName().substring(4) + ""String_Node_Str"";
}","protected String singleJavaInputForTest(){
  return getTestName().substring(4) + ""String_Node_Str"";
}",0.9797979797979798
40318,"public IRTests(String name,String projectName){
  this.name=name;
  this.projectName=projectName;
}","protected IRTests(String projectName){
  this.projectName=projectName;
}",0.7602339181286549
40319,"protected String[] simplePkgTestEntryPoint(String pkgName){
  return new String[]{""String_Node_Str"" + pkgName + ""String_Node_Str""+ getName().substring(4)};
}","protected String[] simplePkgTestEntryPoint(String pkgName){
  return new String[]{""String_Node_Str"" + pkgName + ""String_Node_Str""+ getTestName().substring(4)};
}",0.9874213836477987
40320,"protected String[] simpleTestEntryPoint(){
  return new String[]{""String_Node_Str"" + getName().substring(4)};
}","protected String[] simpleTestEntryPoint(){
  return new String[]{""String_Node_Str"" + getTestName().substring(4)};
}",0.9823008849557522
40321,"public JLexTest(String name){
  super(name,null);
}","public JLexTest(){
  super(null);
}",0.813953488372093
40322,"public JavaIRTests(String name){
  this(name,null);
}","public JavaIRTests(){
  this(null);
}",0.8222222222222222
40323,"public NameAwareTestClassRunner(Class<?> klass) throws InitializationError {
  super(klass);
}","public NameAwareTestClassRunner(Class<?> klass){
  super(klass);
}",0.825
40324,"public SyncDuplicatorTest(String name){
  super(name,null);
}","public SyncDuplicatorTest(){
  super(null);
}",0.8490566037735849
40325,"@Test public void testFlowsToLocals() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  doFlowsToSizeTest(TestInfo.FLOWSTO_TEST_LOCALS,1);
}","@Test public void testFlowsToLocals() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  doFlowsToSizeTest(TestInfo.FLOWSTO_TEST_LOCALS,4);
}",0.994475138121547
40326,"/** 
 * get all the pointer keys that some instance key can flow to
 */
public Pair<PointsToResult,Collection<PointerKey>> getFlowsTo(InstanceKey ik){
}","/** 
 * get all the pointer keys that some instance key can flow to
 * @return a pair consisting of (1) a {@link PointsToResult} indicating whether a flows-to set was computed, and (2) the lastcomputed flows-to set for the instance key (possibly <code>null</code> if no flows-to set could be computed in the budget)
 */
public Pair<PointsToResult,Collection<PointerKey>> getFlowsTo(InstanceKey ik){
}",0.5507246376811594
40327,"/** 
 * returns the instance key corresponding to the single allocation site of type FlowsToType
 */
private static InstanceKey getFlowsToInstanceKey(CGNode mainMethod,HeapModel heapModel){
}","/** 
 * returns the instance key corresponding to the single allocation site of type FlowsToType
 */
private InstanceKey getFlowsToInstanceKey(CGNode mainMethod,HeapModel heapModel){
}",0.9813333333333332
40328,"private Collection<PointerKey> getFlowsToSetToTest(String mainClass) throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  final DemandRefinementPointsTo dmp=makeDemandPointerAnalysis(mainClass);
  CGNode mainMethod=AbstractPtrTest.findMainMethod(dmp.getBaseCallGraph());
  InstanceKey keyToQuery=AbstractPtrTest.getFlowsToInstanceKey(mainMethod,dmp.getHeapModel());
  Collection<PointerKey> flowsTo=dmp.getFlowsTo(keyToQuery).snd;
  return flowsTo;
}","private Collection<PointerKey> getFlowsToSetToTest(String mainClass) throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  final DemandRefinementPointsTo dmp=makeDemandPointerAnalysis(mainClass);
  CGNode mainMethod=AbstractPtrTest.findMainMethod(dmp.getBaseCallGraph());
  InstanceKey keyToQuery=getFlowsToInstanceKey(mainMethod,dmp.getHeapModel());
  Collection<PointerKey> flowsTo=dmp.getFlowsTo(keyToQuery).snd;
  return flowsTo;
}",0.9833333333333332
40329,"@Override protected void compute(){
  InstanceKey ik=queriedIkAndState.getInstanceKey();
  g.addSubgraphForNode(((InstanceKeyWithNode)ik).getNode());
  for (  Object pred : Iterator2Iterable.make(g.getPredNodes(ik,NewLabel.v()))) {
    PointerKey predPk=(PointerKey)pred;
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,queriedIkAndState.getState());
    theFlowsToSet.add(predPkAndState);
    findOrCreate(pkToP2Set,predPkAndState).add(queriedIkAndStateNum);
    addToPToWorklist(predPkAndState);
  }
  worklistLoop();
}","@Override protected void compute(){
  InstanceKey ik=queriedIkAndState.getInstanceKey();
  g.addSubgraphForNode(((InstanceKeyWithNode)ik).getNode());
  for (  Object pred : Iterator2Iterable.make(g.getPredNodes(ik,NewLabel.v()))) {
    PointerKey predPk=(PointerKey)pred;
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,queriedIkAndState.getState());
    theFlowsToSet.add(predPkAndState);
    findOrCreate(pkToTrackedSet,predPkAndState).add(queriedIkAndStateNum);
    addToTrackedPToWorklist(predPkAndState);
  }
  worklistLoop();
}",0.9835466179159048
40330,"/** 
 * here, we want to add the graph unconditionally if pkAndState can point to the queried instance key
 */
@Override protected boolean calleeSubGraphMissingAndShouldNotBeAdded(boolean addGraphs,CGNode callee,PointerKeyAndState pkAndState){
  if (find(pkToP2Set,pkAndState).contains(queriedIkAndStateNum)) {
    return false;
  }
 else {
    return super.calleeSubGraphMissingAndShouldNotBeAdded(addGraphs,callee,pkAndState);
  }
}","/** 
 * when doing backward interprocedural propagation, is it true that we should not add a graph representation for a callee _and_ that the subgraph for the callee is missing?
 * @param addGraphs whether graphs should always be added
 * @param callee
 * @param pkAndState
 * @return
 */
protected boolean calleeSubGraphMissingAndShouldNotBeAdded(boolean addGraphs,CGNode callee,PointerKeyAndState pkAndState){
  return !addGraphs && !g.hasSubgraphForNode(callee);
}",0.3596004439511653
40331,"@Override protected void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  final MutableIntSet curPkP2Set=find(pkToP2Set,curPkAndState);
  if (curPkP2Set.contains(queriedIkAndStateNum)) {
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,stateMachine.transition(curPkAndState.getState(),label));
    if (addAllToP2Set(pkToP2Set,predPkAndState,curPkP2Set,label)) {
      theFlowsToSet.add(predPkAndState);
      addToPToWorklist(predPkAndState);
    }
  }
 else {
    super.handleBackCopy(curPkAndState,predPk,label);
  }
}","protected void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState),label)) {
      addToPToWorklist(predPkAndState);
    }
  }
}",0.2967032967032967
40332,"/** 
 * Does the file name represent a .java file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isSourceFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1 && fileName.indexOf(CLASSPATH) == -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .java file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isSourceFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(""String_Node_Str"");
}",0.7990373044524669
40333,"/** 
 * Does the file name represent a .class file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isClassFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  if (suffixIndex > -1 && fileName.indexOf(CLASSPATH) == -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .class file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isClassFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(CLASS_SUFFIX);
}",0.7965895249695494
40334,"/** 
 * Strip the "".class"" or "".java"" suffix from a file name TODO: generalize for all suffixes
 * @param fileName the file name
 * @throws IllegalArgumentException  if fileName is null
 */
public static String stripSuffix(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  suffixIndex=(suffixIndex > -1) ? suffixIndex : fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1) {
    return fileName.substring(0,suffixIndex);
  }
 else {
    return fileName;
  }
}","/** 
 * Strip the "".class"" or "".java"" suffix from a file name TODO: generalize for all suffixes
 * @param fileName the file name
 * @throws IllegalArgumentException if fileName is null
 */
public static String stripSuffix(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  suffixIndex=(suffixIndex > -1) ? suffixIndex : fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1) {
    return fileName.substring(0,suffixIndex);
  }
 else {
    return fileName;
  }
}",0.9991311902693312
40335,"/** 
 * Does the file name represent a .jar file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isJarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(JAR_SUFFIX);
  if (suffixIndex > -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .jar file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isJarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(JAR_SUFFIX);
}",0.8316062176165803
40336,"/** 
 * Does the file name represent a .war file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isWarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(WAR_SUFFIX);
  if (suffixIndex > -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .war file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isWarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(WAR_SUFFIX);
}",0.8316062176165803
40337,"private DeclaredTypeOperator getPointerTypeOperator(TypeReference type){
  if (type.isPrimitiveType()) {
    return new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      return new DeclaredTypeOperator(BOTTOM);
    }
 else {
      return new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}","private DeclaredTypeOperator getPointerTypeOperator(TypeReference type){
  if (type.isPrimitiveType()) {
    return new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      return new DeclaredTypeOperator(BOTTOM);
    }
 else {
      return new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}",0.9751633986928104
40338,"@Override public void visitInvoke(SSAInvokeInstruction instruction){
  TypeReference type=instruction.getDeclaredResultType();
  if (type.isReferenceType()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
 else   if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    result=null;
  }
}","@Override public void visitInvoke(SSAInvokeInstruction instruction){
  TypeReference type=instruction.getDeclaredResultType();
  if (type.isReferenceType()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
 else   if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    result=null;
  }
}",0.981427174975562
40339,"@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      Iterator<TypeReference> types=defaultExceptions.iterator();
      TypeReference t=types.next();
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        v.setType(BOTTOM);
      }
 else {
        v.setType(new PointType(klass));
      }
      while (types.hasNext()) {
        t=types.next();
        klass=cha.lookupClass(t);
        if (klass != null) {
          v.setType(v.getType().meet(new PointType(klass)));
        }
      }
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
catch (        UnsupportedOperationException e) {
          x=new TypeReference[]{language.getThrowableType()};
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(language.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      Iterator<TypeReference> types=defaultExceptions.iterator();
      TypeReference t=types.next();
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        v.setType(BOTTOM);
      }
 else {
        v.setType(new PointType(klass));
      }
      while (types.hasNext()) {
        t=types.next();
        klass=cha.lookupClass(t);
        if (klass != null) {
          v.setType(v.getType().meet(new PointType(klass)));
        }
      }
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
catch (        UnsupportedOperationException e) {
          x=new TypeReference[]{language.getThrowableType()};
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.9964611659526914
40340,"@Override public void visitGet(SSAGetInstruction instruction){
  TypeReference type=instruction.getDeclaredFieldType();
  if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}","@Override public void visitGet(SSAGetInstruction instruction){
  TypeReference type=instruction.getDeclaredFieldType();
  if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}",0.978675645342312
40341,"/** 
 * traverse the bundle description for an Eclipse project and populate the analysis scope accordingly
 */
private void resolvePluginClassPath(IProject p,boolean includeSource) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  for (int i=0; i < 3 && bd == null; i++) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    bd=findModel(p).getBundleDescription();
  }
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION,includeSource);
}","/** 
 * traverse the bundle description for an Eclipse project and populate the analysis scope accordingly
 */
private void resolvePluginClassPath(IProject p,boolean includeSource) throws CoreException, IOException {
  IPluginModelBase model=findModel(p);
  if (!model.isInSync() || model.isDisposed()) {
    model.load();
  }
  BundleDescription bd=model.getBundleDescription();
  for (int i=0; i < 3 && bd == null; i++) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    bd=findModel(p).getBundleDescription();
  }
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION,includeSource);
}",0.8940646130728775
40342,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
            caughtException=null;
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9644517020474814
40343,"public Collection<IMethod> getAllMethods() throws ClassHierarchyException {
  Collection<IMethod> result=new LinkedList<IMethod>();
  Iterator<IMethod> declaredMethods=getDeclaredMethods().iterator();
  while (declaredMethods.hasNext()) {
    result.add(declaredMethods.next());
  }
  IClass s=getSuperclass();
  while (s != null) {
    Iterator<IMethod> superDeclaredMethods=s.getDeclaredMethods().iterator();
    while (superDeclaredMethods.hasNext()) {
      result.add(superDeclaredMethods.next());
    }
    s=s.getSuperclass();
  }
  return result;
}","public Collection<IMethod> getAllMethods() throws ClassHierarchyException {
  Collection<IMethod> result=new LinkedList<IMethod>();
  Iterator<IMethod> declaredMethods=getDeclaredMethods().iterator();
  while (declaredMethods.hasNext()) {
    result.add(declaredMethods.next());
  }
  if (isInterface()) {
    for (    IClass i : getDirectInterfaces()) {
      result.addAll(i.getAllMethods());
    }
  }
  IClass s=getSuperclass();
  while (s != null) {
    Iterator<IMethod> superDeclaredMethods=s.getDeclaredMethods().iterator();
    while (superDeclaredMethods.hasNext()) {
      result.add(superDeclaredMethods.next());
    }
    s=s.getSuperclass();
  }
  return result;
}",0.9011345218800648
40344,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,new String[]{""String_Node_Str""});
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,new String[]{""String_Node_Str""});
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9539406345957012
40345,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,new String[]{""String_Node_Str""});
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,new String[]{""String_Node_Str""});
}",0.8872180451127819
40346,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9528795811518324
40347,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
40348,"protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
    public IRTranslatorExtension getTranslatorExtension(){
      JavaIRTranslatorExtension ext=new JavaIRTranslatorExtension();
      ext.setCAstRewriterFactory(new CAstRewriterFactory(){
        public CAstRewriter createCAstRewriter(        CAst ast){
          return new SynchronizedBlockDuplicator(ast,true,testMethod);
        }
      }
);
      return ext;
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
    public IRTranslatorExtension getTranslatorExtension(){
      JavaIRTranslatorExtension ext=new JavaIRTranslatorExtension();
      ext.setCAstRewriterFactory(new CAstRewriterFactory(){
        public CAstRewriter createCAstRewriter(        CAst ast){
          return new SynchronizedBlockDuplicator(ast,true,testMethod);
        }
      }
);
      return ext;
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9731343283582088
40349,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
40350,"@Override protected void buildAnalysisScope(){
  try {
    scope=makeSourceAnalysisScope();
    if (getExclusionsFile() != null) {
      scope.setExclusions(new FileOfClasses(new File(getExclusionsFile())));
    }
    EclipseProjectPath epath=getEclipseProjectPath();
    for (    Module m : epath.getModules(Loader.PRIMORDIAL,true)) {
      scope.addToScope(scope.getPrimordialLoader(),m);
    }
    ClassLoaderReference app=scope.getApplicationLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,true)) {
      scope.addToScope(app,m);
    }
    for (    Module m : epath.getModules(Loader.EXTENSION,true)) {
      if (!(m instanceof BinaryDirectoryTreeModule))       scope.addToScope(app,m);
    }
    ClassLoaderReference src=((JavaSourceAnalysisScope)scope).getSourceLoader();
    for (    Module m : epath.getModules(Loader.SOURCE,false)) {
      scope.addToScope(src,m);
    }
  }
 catch (  IOException e) {
    Assertions.UNREACHABLE(e.toString());
  }
}","@Override protected void buildAnalysisScope(){
  try {
    scope=makeSourceAnalysisScope();
    if (getExclusionsFile() != null) {
      scope.setExclusions(FileOfClasses.createFileOfClasses(new File(getExclusionsFile())));
    }
    EclipseProjectPath epath=getEclipseProjectPath();
    for (    Module m : epath.getModules(Loader.PRIMORDIAL,true)) {
      scope.addToScope(scope.getPrimordialLoader(),m);
    }
    ClassLoaderReference app=scope.getApplicationLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,true)) {
      scope.addToScope(app,m);
    }
    for (    Module m : epath.getModules(Loader.EXTENSION,true)) {
      if (!(m instanceof BinaryDirectoryTreeModule))       scope.addToScope(app,m);
    }
    ClassLoaderReference src=((JavaSourceAnalysisScope)scope).getSourceLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,false)) {
      scope.addToScope(src,m);
    }
  }
 catch (  IOException e) {
    Assertions.UNREACHABLE(e.toString());
  }
}",0.9803129732458354
40351,"@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha);
}",0.9014084507042254
40352,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(EclipseProjectPath.SOURCE_REF)) {
    ClassLoaderImpl cl=new PolyglotSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha,getExtensionFor(classLoaderReference));
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new PolyglotSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha,getExtensionFor(classLoaderReference));
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.957983193277311
40353,"public PolyglotClassLoaderFactory(SetOfClasses exclusions,IRTranslatorExtension javaExtInfo){
  super(exclusions);
  fExtensionMap.put(EclipseProjectPath.SOURCE_REF,javaExtInfo);
}","public PolyglotClassLoaderFactory(SetOfClasses exclusions,IRTranslatorExtension javaExtInfo){
  super(exclusions);
  fExtensionMap.put(JavaSourceAnalysisScope.SOURCE,javaExtInfo);
}",0.9030470914127424
40354,"public void performVerboseAction(){
  System.err.println(""String_Node_Str"" + nEvaluated);
  System.err.println(""String_Node_Str"" + nCreated);
  System.err.println(""String_Node_Str"" + workList.size());
  if (MORE_VERBOSE) {
    AbstractStatement s=workList.takeStatement();
    System.err.println(""String_Node_Str"" + lineBreak(s.toString(),132));
    if (s instanceof VerboseAction) {
      ((VerboseAction)s).performVerboseAction();
    }
    workList.insertStatement(s);
  }
}","public void performVerboseAction(){
  System.err.println(""String_Node_Str"" + nEvaluated);
  System.err.println(""String_Node_Str"" + nCreated);
  System.err.println(""String_Node_Str"" + workList.size());
  if (MORE_VERBOSE) {
    if (!workList.isEmpty()) {
      AbstractStatement s=workList.takeStatement();
      System.err.println(""String_Node_Str"" + lineBreak(s.toString(),132));
      if (s instanceof VerboseAction) {
        ((VerboseAction)s).performVerboseAction();
      }
      workList.insertStatement(s);
    }
  }
}",0.9511465603190428
40355,"/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}","/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in the value of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}",0.9995557529986672
40356,"public boolean isPEI(){
  return true;
}","public boolean isPEI(){
  return !isStatic();
}",0.8505747126436781
40357,"public boolean isPEI(){
  return true;
}","public boolean isPEI(){
  return !isStatic();
}",0.8505747126436781
40358,"public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration<JarEntry> e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}","public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  if (in == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (out == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration<JarEntry> e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}",0.9181773640372366
40359,"@Override final public int hashCode(){
  return getType().hashCode() + 14411 * getValue().hashCode();
}","@Override final public int hashCode(){
  int v=getValue() == null ? 0 : getValue().hashCode();
  return getType().hashCode() + 14411 * v;
}",0.6776859504132231
40360,"/** 
 * @return the constant value pushed: an Integer, a Long, a Float, a Double, aString, or null
 */
public abstract Object getValue();","/** 
 * @return the constant value pushed: an Integer, a Long, a Float, a Double, a String, or null
 */
public abstract Object getValue();",0.9963636363636365
40361,"@Override final public boolean equals(Object o){
  if (o instanceof ConstantInstruction) {
    ConstantInstruction i=(ConstantInstruction)o;
    return i.getType().equals(getType()) && i.getValue().equals(getValue());
  }
 else {
    return false;
  }
}","@Override final public boolean equals(Object o){
  if (o instanceof ConstantInstruction) {
    ConstantInstruction i=(ConstantInstruction)o;
    if (!i.getType().equals(getType())) {
      return false;
    }
    if (i.getValue() == null) {
      if (getValue() == null) {
        return true;
      }
 else {
        return false;
      }
    }
 else {
      if (getValue() == null) {
        return false;
      }
 else {
        return i.getValue().equals(getValue());
      }
    }
  }
 else {
    return false;
  }
}",0.5400516795865633
40362,"protected InstanceofInstruction(String type){
  super(OP_instanceof);
  this.type=type;
}","protected InstanceofInstruction(String type){
  super(OP_instanceof);
  this.type=type;
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6768060836501901
40363,"/** 
 * Build an editor for specific method data. After patching the code you can retrieve the new code, handlers and instructions-to-bytecode-offsets map.
 */
public MethodEditor(Instruction[] instructions,ExceptionHandler[][] handlers,int[] instructionsToBytecodes){
  methodInfo=null;
  this.instructionsToBytecodes=instructionsToBytecodes;
  this.instructions=instructions;
  this.handlers=handlers;
}","/** 
 * Build an editor for specific method data. After patching the code you can retrieve the new code, handlers and instructions-to-bytecode-offsets map.
 */
public MethodEditor(Instruction[] instructions,ExceptionHandler[][] handlers,int[] instructionsToBytecodes){
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  methodInfo=null;
  this.instructionsToBytecodes=instructionsToBytecodes;
  this.instructions=instructions;
  this.handlers=handlers;
}",0.8970099667774086
40364,"/** 
 * Compute the promoted type that the JVM uses to manipulate values of type ""t"" on its working stack.
 * @throws IllegalArgumentException  if t is null
 */
public static String getStackType(String t){
  if (t == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (t.charAt(0)) {
case 'Z':
case 'C':
case 'B':
case 'S':
    return ""String_Node_Str"";
default :
  return t;
}
}","/** 
 * Compute the promoted type that the JVM uses to manipulate values of type ""t"" on its working stack.
 * @throws IllegalArgumentException  if t is null
 */
public static String getStackType(String t){
  if (t == null || t.length() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + t);
  }
switch (t.charAt(0)) {
case 'Z':
case 'C':
case 'B':
case 'S':
    return ""String_Node_Str"";
default :
  return t;
}
}",0.973621103117506
40365,"/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 * @throws IllegalArgumentException  if type == null
 */
static int getParamsCount(String type) throws IllegalArgumentException {
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 * @throws IllegalArgumentException  if type == null
 */
static int getParamsCount(String type) throws IllegalArgumentException {
  if (type == null || type.length() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}",0.970954356846473
40366,"/** 
 * @return true iff t is a primitive type
 */
public static boolean isPrimitiveType(String t){
  if (t == null) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case 'L':
case '[':
      return false;
default :
    return true;
}
}
}","/** 
 * @return true iff t is a primitive type
 */
public static boolean isPrimitiveType(String t){
  if (t == null || t.length() == 0) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case 'L':
case '[':
      return false;
default :
    return true;
}
}
}",0.9625246548323472
40367,"/** 
 * Initialize a verifier.
 * @throws NullPointerException  if info is null
 */
public Verifier(MethodData info) throws NullPointerException {
  super(info);
}","/** 
 * Initialize a verifier.
 * @throws NullPointerException if info is null
 */
public Verifier(MethodData info) throws NullPointerException {
  super(info);
}",0.9969230769230768
40368,"public static void main(String[] args){
  for (int i=0; i < args.length; i++) {
    try {
      byte[] data=Util.readFully(new FileInputStream(args[i]));
      ClassReader r=new ClassReader(data);
      System.out.println(Util.makeClass(r.getName()) + ""String_Node_Str"" + computeSerialVersionUID(r));
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    InvalidClassFileException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
  }
}","public static void main(String[] args){
  for (int i=0; i < args.length; i++) {
    if (args[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    try {
      byte[] data=Util.readFully(new FileInputStream(args[i]));
      ClassReader r=new ClassReader(data);
      System.out.println(Util.makeClass(r.getName()) + ""String_Node_Str"" + computeSerialVersionUID(r));
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    InvalidClassFileException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
  }
}",0.9110105580693816
40369,"/** 
 * Call this when you're done modifying classes.
 */
final public void close() throws IOException {
  if (passUnmodifiedClasses) {
    writeUnmodifiedClasses();
  }
  if (outputJar != null) {
    outputJar.close();
  }
  if (cachedJar != null) {
    cachedJar.close();
  }
}","/** 
 * Call this when you're done modifying classes.
 */
final public void close() throws IOException, IllegalStateException {
  if (passUnmodifiedClasses) {
    writeUnmodifiedClasses();
  }
  if (outputJar != null) {
    outputJar.close();
  }
  if (cachedJar != null) {
    cachedJar.close();
  }
}",0.9604130808950088
40370,"/** 
 * Parse an argument list to find elements to instrument and the name of the output file. The ""-o filename"" option selects the output JAR file name. Any other argument not starting with ""-"" is added to the list of elements to instrument, if it appears to be the name of a class file, JAR file, or directory. If any argument starting with ""--"" is encountered, the rest of the command-line is considered leftover
 * @return the arguments that were not understood
 * @throws IllegalArgumentException  if args == null
 */
final public String[] parseStandardArgs(String[] args) throws IllegalArgumentException, IOException {
  if (args == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<String> leftover=new ArrayList<String>();
  for (int i=0; i < args.length; i++) {
    String a=args[i];
    if (a.equals(""String_Node_Str"") && i + 1 < args.length) {
      setOutputJar(new File(args[i + 1]));
      i++;
      continue;
    }
 else     if (!a.startsWith(""String_Node_Str"")) {
      if (addInputElement(a)) {
        continue;
      }
    }
 else     if (a.startsWith(""String_Node_Str"")) {
      for (int j=i; j < args.length; j++) {
        leftover.add(args[j]);
      }
      break;
    }
    leftover.add(a);
  }
  String[] r=new String[leftover.size()];
  leftover.toArray(r);
  return r;
}","/** 
 * Parse an argument list to find elements to instrument and the name of the output file. The ""-o filename"" option selects the output JAR file name. Any other argument not starting with ""-"" is added to the list of elements to instrument, if it appears to be the name of a class file, JAR file, or directory. If any argument starting with ""--"" is encountered, the rest of the command-line is considered leftover
 * @return the arguments that were not understood
 * @throws IllegalArgumentException  if args == null
 */
final public String[] parseStandardArgs(String[] args) throws IllegalArgumentException, IOException {
  if (args == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<String> leftover=new ArrayList<String>();
  for (int i=0; i < args.length; i++) {
    String a=args[i];
    if (a == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (a.equals(""String_Node_Str"") && i + 1 < args.length) {
      setOutputJar(new File(args[i + 1]));
      i++;
      continue;
    }
 else     if (!a.startsWith(""String_Node_Str"")) {
      if (addInputElement(a)) {
        continue;
      }
    }
 else     if (a.startsWith(""String_Node_Str"")) {
      for (int j=i; j < args.length; j++) {
        leftover.add(args[j]);
      }
      break;
    }
    leftover.add(a);
  }
  String[] r=new String[leftover.size()];
  leftover.toArray(r);
  return r;
}",0.9596541786743517
40371,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    buf[offset]=(byte)(v >> 24);
    buf[offset + 1]=(byte)(v >> 16);
    buf[offset + 2]=(byte)(v >> 8);
    buf[offset + 3]=(byte)v;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
}",0.7985739750445633
40372,"/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}","/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset < 0 || offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  try {
    buf[offset]=(byte)(v >> 8);
    buf[offset + 1]=(byte)v;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
}",0.8741496598639455
40373,"/** 
 * @param bytes the raw class file data
 * @param offset the start of the constant pool data
 * @param itemCount the number of items in the pool
 */
public ConstantPoolParser(byte[] bytes,int offset,int itemCount) throws InvalidClassFileException {
  this.bytes=bytes;
  if (offset < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  if (itemCount < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + itemCount);
  }
  parseConstantPool(offset,itemCount);
}","/** 
 * @param bytes the raw class file data
 * @param offset the start of the constant pool data
 * @param itemCount the number of items in the pool
 */
public ConstantPoolParser(byte[] bytes,int offset,int itemCount) throws InvalidClassFileException {
  this.bytes=bytes;
  if (offset < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  if (itemCount < 0 || itemCount > MAX_CP_ITEMS) {
    throw new IllegalArgumentException(""String_Node_Str"" + itemCount);
  }
  parseConstantPool(offset,itemCount);
}",0.972972972972973
40374,"public boolean containsValue(Object value){
  if (keysAndValues == null) {
    return false;
  }
  for (int i=size(); i < keysAndValues.length; i++) {
    if (keysAndValues[i].equals(value)) {
      return true;
    }
  }
  return false;
}","public boolean containsValue(Object value){
  if (keysAndValues == null) {
    return false;
  }
  for (int i=size(); i < keysAndValues.length; i++) {
    Object v=keysAndValues[i];
    if (v == null) {
      if (value == null) {
        return true;
      }
    }
 else {
      if (v.equals(value)) {
        return true;
      }
    }
  }
  return false;
}",0.6532663316582915
40375,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.965089216446858
40376,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
40377,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.965089216446858
40378,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
40379,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(EclipseProjectPath.SOURCE_REF)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.9543147208121828
40380,"protected static void dumpIR(CallGraph cg,boolean assertReachable) throws IOException {
  Set<IMethod> unreachable=HashSetFactory.make();
  IClassHierarchy cha=cg.getClassHierarchy();
  IClassLoader sourceLoader=cha.getLoader(EclipseProjectPath.SOURCE_REF);
  for (Iterator iter=sourceLoader.iterateAllClasses(); iter.hasNext(); ) {
    IClass clazz=(IClass)iter.next();
    Trace.println(clazz);
    if (clazz.isInterface())     continue;
    for (    IMethod m : clazz.getDeclaredMethods()) {
      if (m.isAbstract()) {
        Trace.println(m);
      }
 else {
        Iterator nodeIter=cg.getNodes(m.getReference()).iterator();
        if (!nodeIter.hasNext()) {
          Trace.println(""String_Node_Str"" + m.getReference() + ""String_Node_Str"");
          unreachable.add(m);
          continue;
        }
        CGNode node=(CGNode)nodeIter.next();
        Trace.println(node.getIR());
      }
    }
  }
  if (assertReachable) {
    Assert.assertTrue(""String_Node_Str"" + unreachable.toString(),unreachable.isEmpty());
  }
}","protected static void dumpIR(CallGraph cg,boolean assertReachable) throws IOException {
  Set<IMethod> unreachable=HashSetFactory.make();
  IClassHierarchy cha=cg.getClassHierarchy();
  IClassLoader sourceLoader=cha.getLoader(JavaSourceAnalysisScope.SOURCE);
  for (Iterator iter=sourceLoader.iterateAllClasses(); iter.hasNext(); ) {
    IClass clazz=(IClass)iter.next();
    Trace.println(clazz);
    if (clazz.isInterface())     continue;
    for (    IMethod m : clazz.getDeclaredMethods()) {
      if (m.isAbstract()) {
        Trace.println(m);
      }
 else {
        Iterator nodeIter=cg.getNodes(m.getReference()).iterator();
        if (!nodeIter.hasNext()) {
          Trace.println(""String_Node_Str"" + m.getReference() + ""String_Node_Str"");
          unreachable.add(m);
          continue;
        }
        CGNode node=(CGNode)nodeIter.next();
        Trace.println(node.getIR());
      }
    }
  }
  if (assertReachable) {
    Assert.assertTrue(""String_Node_Str"" + unreachable.toString(),unreachable.isEmpty());
  }
}",0.9791363415817564
40381,"private MethodReference getSliceRootReference(String className,String methodName,String methodDescriptor){
  TypeName clsName=TypeName.string2TypeName(""String_Node_Str"" + className.replace('.','/'));
  TypeReference clsRef=TypeReference.findOrCreate(EclipseProjectPath.SOURCE_REF,clsName);
  Atom nameAtom=Atom.findOrCreateUnicodeAtom(methodName);
  Descriptor descr=Descriptor.findOrCreateUTF8(methodDescriptor);
  return MethodReference.findOrCreate(clsRef,nameAtom,descr);
}","private MethodReference getSliceRootReference(String className,String methodName,String methodDescriptor){
  TypeName clsName=TypeName.string2TypeName(""String_Node_Str"" + className.replace('.','/'));
  TypeReference clsRef=TypeReference.findOrCreate(JavaSourceAnalysisScope.SOURCE,clsName);
  Atom nameAtom=Atom.findOrCreateUnicodeAtom(methodName);
  Descriptor descr=Descriptor.findOrCreateUTF8(methodDescriptor);
  return MethodReference.findOrCreate(clsRef,nameAtom,descr);
}",0.9528795811518324
40382,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha);
}",0.8955223880597015
40383,"public ClassLoaderReference getSourceLoader(){
  return getLoader(EclipseProjectPath.SOURCE);
}","public ClassLoaderReference getSourceLoader(){
  return SOURCE;
}",0.8125
40384,"public JavaSourceAnalysisScope(Collection<Language> languages){
  super(languages);
  initForJava();
  EclipseProjectPath.SOURCE_REF.setParent(getLoader(APPLICATION));
  getLoader(SYNTHETIC).setParent(EclipseProjectPath.SOURCE_REF);
  loadersByName.put(EclipseProjectPath.SOURCE,EclipseProjectPath.SOURCE_REF);
  setLoaderImpl(getLoader(SYNTHETIC),""String_Node_Str"");
  setLoaderImpl(EclipseProjectPath.SOURCE_REF,""String_Node_Str"");
}","public JavaSourceAnalysisScope(Collection<Language> languages){
  super(languages);
  initForJava();
  loadersByName.put(SOURCE.getName(),SOURCE);
  setLoaderImpl(getLoader(SYNTH_SOURCE.getName()),""String_Node_Str"");
  setLoaderImpl(SOURCE,""String_Node_Str"");
}",0.4310344827586206
40385,"public Iterator<T> iterator(){
  return new ArrayIterator<T>(entries);
}","public Iterator<T> iterator(){
  if (entries.length == 0) {
    return EmptyIterator.instance();
  }
  return new ArrayIterator<T>(entries);
}",0.6728971962616822
40386,"private int findReturnToVar(int v,int addr,boolean[] visited) throws InvalidBytecodeException {
  while (true) {
    if (visited[addr]) {
      return 0;
    }
 else     if (retInfo[addr] != null && retInfo[addr].retVar == v) {
      return addr;
    }
 else {
      int offset=decodedOffset[addr];
      if (offset == UNSEEN) {
        return 0;
      }
      int size=decodedSize[addr];
      Instruction instr=null;
      visited[addr]=true;
      for (int j=0; j < rawHandlers.length; j+=4) {
        if (rawHandlers[j] <= addr && addr < rawHandlers[j + 1]) {
          int handlerAddr=rawHandlers[j + 2];
          if (decodedOffset[handlerAddr] < 0) {
            byte[] stackWords=new byte[code.length * 2];
            decodeAt(handlerAddr,1,stackWords);
          }
          int r=findReturnToVar(v,handlerAddr,visited);
          if (r != 0) {
            return r;
          }
        }
      }
      if (JSRs[addr] != 0) {
        if (!doesSubroutineReturn(JSRs[addr])) {
          return 0;
        }
      }
 else {
        for (int j=0; j < size; j++) {
          instr=decoded.get(offset + j);
          if (instr instanceof StoreInstruction && ((StoreInstruction)instr).getVarIndex() == v) {
            return 0;
          }
          int[] targets=instr.getBranchTargets();
          for (int k=0; k < targets.length; k++) {
            if (targets[k] >= 0) {
              int r=findReturnToVar(v,targets[k],visited);
              if (r != 0) {
                return r;
              }
            }
          }
        }
        if (instr != null && !instr.isFallThrough()) {
          return 0;
        }
      }
      do {
        addr++;
      }
 while (decodedOffset[addr] == INSIDE_INSTRUCTION);
    }
  }
}","private int findReturnToVar(int v,int addr,boolean[] visited) throws InvalidBytecodeException {
  while (true) {
    if (visited[addr]) {
      return 0;
    }
 else     if (retInfo[addr] != null && retInfo[addr].retVar == v) {
      return addr;
    }
 else {
      int offset=decodedOffset[addr];
      if (offset == UNSEEN) {
        return 0;
      }
      int size=decodedSize[addr];
      Instruction instr=null;
      visited[addr]=true;
      for (int j=0; j < rawHandlers.length; j+=4) {
        if (rawHandlers[j] <= addr && addr < rawHandlers[j + 1]) {
          int handlerAddr=rawHandlers[j + 2];
          if (decodedOffset[handlerAddr] < 0) {
            byte[] stackWords=new byte[code.length * 2];
            stackWords[0]=1;
            decodeAt(handlerAddr,1,stackWords);
          }
          int r=findReturnToVar(v,handlerAddr,visited);
          if (r != 0) {
            return r;
          }
        }
      }
      if (JSRs[addr] != 0) {
        if (!doesSubroutineReturn(JSRs[addr])) {
          return 0;
        }
      }
 else {
        for (int j=0; j < size; j++) {
          instr=decoded.get(offset + j);
          if (instr instanceof StoreInstruction && ((StoreInstruction)instr).getVarIndex() == v) {
            return 0;
          }
          int[] targets=instr.getBranchTargets();
          for (int k=0; k < targets.length; k++) {
            if (targets[k] >= 0) {
              int r=findReturnToVar(v,targets[k],visited);
              if (r != 0) {
                return r;
              }
            }
          }
        }
        if (instr != null && !instr.isFallThrough()) {
          return 0;
        }
      }
      do {
        addr++;
      }
 while (decodedOffset[addr] == INSIDE_INSTRUCTION);
    }
  }
}",0.9917166523850328
40387,"/** 
 * @return StringBuffer holding dot output representing G
 * @throws WalaException
 */
private static <T>StringBuffer dotOutput(Graph<T> g,NodeDecorator labels,String title) throws WalaException {
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  if (title != null) {
    result.append(""String_Node_Str"" + title + ""String_Node_Str"");
  }
 else {
    result.append(""String_Node_Str"");
  }
  String rankdir=getRankDir();
  if (rankdir != null) {
    result.append(""String_Node_Str"" + rankdir + ""String_Node_Str"");
  }
  String fontsizeStr=""String_Node_Str"" + fontSize;
  String fontcolorStr=(fontColor != null) ? ""String_Node_Str"" + fontColor : ""String_Node_Str"";
  String fontnameStr=(fontName != null) ? ""String_Node_Str"" + fontName : ""String_Node_Str"";
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  Collection dotNodes=computeDotNodes(g);
  outputNodes(labels,result,dotNodes);
  for (Iterator<? extends T> it=g.iterator(); it.hasNext(); ) {
    T n=it.next();
    for (Iterator<? extends T> it2=g.getSuccNodes(n); it2.hasNext(); ) {
      T s=it2.next();
      result.append(""String_Node_Str"");
      result.append(getPort(n,labels));
      result.append(""String_Node_Str"");
      result.append(getPort(s,labels));
      result.append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  return result;
}","/** 
 * @return StringBuffer holding dot output representing G
 * @throws WalaException
 */
private static <T>StringBuffer dotOutput(Graph<T> g,NodeDecorator labels,String title) throws WalaException {
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  if (title != null) {
    result.append(""String_Node_Str"" + title + ""String_Node_Str"");
  }
 else {
    result.append(""String_Node_Str"");
  }
  String rankdir=getRankDir();
  if (rankdir != null) {
    result.append(""String_Node_Str"" + rankdir + ""String_Node_Str"");
  }
  String fontsizeStr=""String_Node_Str"" + fontSize;
  String fontcolorStr=(fontColor != null) ? ""String_Node_Str"" + fontColor : ""String_Node_Str"";
  String fontnameStr=(fontName != null) ? ""String_Node_Str"" + fontName : ""String_Node_Str"";
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  Collection dotNodes=computeDotNodes(g);
  outputNodes(labels,result,dotNodes);
  for (Iterator<? extends T> it=g.iterator(); it.hasNext(); ) {
    T n=it.next();
    for (Iterator<? extends T> it2=g.getSuccNodes(n); it2.hasNext(); ) {
      T s=it2.next();
      result.append(""String_Node_Str"");
      result.append(getPort(n,labels));
      result.append(""String_Node_Str"");
      result.append(getPort(s,labels));
      result.append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  return result;
}",0.9892021595680864
40388,"/** 
 * create a new field-element
 * @param fld - field element to serve as part of a path
 */
public FieldPathElement(IField fld){
  Assertions.precondition(fld != null,""String_Node_Str"");
  this.fld=fld;
}","/** 
 * create a new field-element
 * @param fld - field element to serve as part of a path
 */
public FieldPathElement(IField fld){
  if (fld == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.fld=fld;
}",0.8099547511312217
40389,"/** 
 * create a new anchor element
 * @param lpk -anchor element to serve as head of path
 */
public LocalPathElement(AbstractPointerKey lpk){
  this.lpk=lpk;
  if (Assertions.verifyAssertions) {
    Assertions._assert(lpk != null);
  }
}","/** 
 * create a new anchor element
 * @param lpk - anchor element to serve as head of path
 */
public LocalPathElement(AbstractPointerKey lpk){
  this.lpk=lpk;
  if (lpk == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.7257731958762886
40390,"protected HeapGraph(PointerAnalysis pa){
  this.pa=pa;
}","protected HeapGraph(PointerAnalysis pa){
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.pa=pa;
}",0.5743589743589743
40391,"public FieldImpl(IClass declaringClass,FieldReference canonicalRef,int accessFlags,Collection<Annotation> annotations){
  this.declaringClass=declaringClass;
  this.fieldRef=canonicalRef;
  this.accessFlags=accessFlags;
  this.annotations=annotations;
  if (Assertions.verifyAssertions) {
    Assertions._assert(declaringClass != null);
    Assertions._assert(fieldRef != null);
  }
}","public FieldImpl(IClass declaringClass,FieldReference canonicalRef,int accessFlags,Collection<Annotation> annotations){
  this.declaringClass=declaringClass;
  this.fieldRef=canonicalRef;
  this.accessFlags=accessFlags;
  this.annotations=annotations;
  if (declaringClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fieldRef == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6528623629719854
40392,"private void resolvePluginClassPath(IProject p) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION);
}","private void resolvePluginClassPath(IProject p) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION);
}",0.8299595141700404
40393,"/** 
 * If file extension is not provided, use system default
 * @throws JavaModelException
 * @throws IOException
 */
private void resolveProjectClasspathEntries() throws JavaModelException, IOException {
  resolveClasspathEntries(project.getRawClasspath(),Loader.EXTENSION);
}","private void resolveProjectClasspathEntries() throws JavaModelException, IOException {
  resolveClasspathEntries(project.getRawClasspath(),Loader.EXTENSION);
}",0.7276887871853547
40394,"/** 
 * @return Collection of IClasses, representing the interfaces this class implements.
 */
protected Collection<IClass> computeAllInterfacesAsCollection() throws ClassHierarchyException {
  Collection<IClass> c=getDirectInterfaces();
  Set<IClass> result=HashSetFactory.make();
  for (Iterator<IClass> it=c.iterator(); it.hasNext(); ) {
    IClass klass=it.next();
    if (klass.isInterface()) {
      result.add(klass);
    }
 else {
      Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + klass));
    }
  }
  for (Iterator<IClass> it=c.iterator(); it.hasNext(); ) {
    BytecodeClass I=(BytecodeClass)it.next();
    if (I.isInterface()) {
      result.addAll(I.computeAllInterfacesAsCollection());
    }
 else {
      Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + I));
    }
  }
  IClass sup=null;
  try {
    sup=getSuperclass();
  }
 catch (  ClassHierarchyException e1) {
    Assertions.UNREACHABLE();
  }
  if (sup != null) {
    result.addAll(sup.getAllImplementedInterfaces());
  }
  return result;
}","/** 
 * @return Collection of IClasses, representing the interfaces this class implements.
 */
protected Collection<IClass> computeAllInterfacesAsCollection() throws ClassHierarchyException {
  Collection<IClass> c=getDirectInterfaces();
  Set<IClass> result=HashSetFactory.make();
  for (Iterator<IClass> it=c.iterator(); it.hasNext(); ) {
    IClass klass=it.next();
    if (klass.isInterface()) {
      result.add(klass);
    }
 else {
      Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + klass));
    }
  }
  Set<IClass> last=null;
  do {
    last=HashSetFactory.make(result);
    for (    IClass i : last) {
      result.addAll(i.getDirectInterfaces());
    }
  }
 while (last.size() < result.size());
  IClass sup=null;
  try {
    sup=getSuperclass();
  }
 catch (  ClassHierarchyException e1) {
    Assertions.UNREACHABLE();
  }
  if (sup != null) {
    result.addAll(sup.getAllImplementedInterfaces());
  }
  return result;
}",0.8190954773869347
40395,"/** 
 * Method array2Set.
 * @param interfaces a set of class names
 * @return Set of all IClasses that can be loaded corresponding to the class names in the interfaces array; raise warnings ifclasses can not be loaded
 */
private Collection<IClass> array2IClassSet(ImmutableByteArray[] interfaces){
  ArrayList<IClass> result=new ArrayList<IClass>(interfaces.length);
  for (int i=0; i < interfaces.length; i++) {
    ImmutableByteArray name=interfaces[i];
    IClass klass=null;
    klass=loader.lookupClass(TypeName.findOrCreate(name));
    if (klass == null) {
      Warnings.add(ClassNotFoundWarning.create(name));
    }
 else {
      result.add(klass);
    }
  }
  return result;
}","/** 
 * @param interfaces a set of class names
 * @return Set of all IClasses that can be loaded corresponding to the class names in the interfaces array; raise warnings ifclasses can not be loaded
 */
private Collection<IClass> array2IClassSet(ImmutableByteArray[] interfaces){
  ArrayList<IClass> result=new ArrayList<IClass>(interfaces.length);
  for (int i=0; i < interfaces.length; i++) {
    ImmutableByteArray name=interfaces[i];
    IClass klass=null;
    klass=loader.lookupClass(TypeName.findOrCreate(name));
    if (klass == null) {
      Warnings.add(ClassNotFoundWarning.create(name));
    }
 else {
      result.add(klass);
    }
  }
  return result;
}",0.984478935698448
40396,"private void populate(CGNode n){
  if (n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SyntheticMethod sm=(SyntheticMethod)n.getMethod();
    SSAInstruction[] statements=sm.getStatements();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","private void populate(CGNode n){
  if (n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9637345679012346
40397,"private void populate(CGNode n){
  if (n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9925925925925926
40398,"private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    IR ir=n.getIR();
    if (ir == null) {
      return;
    }
    SSAInstruction[] statements=ir.getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9719696969696968
40399,"/** 
 * TODO: really shouldn't allow A to be null.
 */
public DelegatingSSAContextInterpreter(SSAContextInterpreter A,SSAContextInterpreter B){
  super(A,B);
  this.A=A;
  this.B=B;
  if (Assertions.verifyAssertions) {
    Assertions._assert(B != null,""String_Node_Str"");
  }
}","/** 
 * neither A nor B should be null.
 */
public DelegatingSSAContextInterpreter(SSAContextInterpreter A,SSAContextInterpreter B){
  super(A,B);
  this.A=A;
  this.B=B;
  if (A == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (B == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6427406199021207
40400,"public ZeroXCFABuilder(IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect,int instancePolicy){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  ContextSelector def=new DefaultContextSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  setContextSelector(contextSelector);
  SSAContextInterpreter c=new DefaultSSAInterpreter(options,cache);
  c=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache(),reflect),c);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,c);
  setContextInterpreter(contextInterpreter);
  ZeroXInstanceKeys zik=makeInstanceKeys(cha,options,contextInterpreter,instancePolicy);
  setInstanceKeys(zik);
}","public ZeroXCFABuilder(IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect,int instancePolicy){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  ContextSelector def=new DefaultContextSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  setContextSelector(contextSelector);
  SSAContextInterpreter c=new DefaultSSAInterpreter(options,cache);
  c=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache(),reflect),c);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? c : new DelegatingSSAContextInterpreter(appContextInterpreter,c);
  setContextInterpreter(contextInterpreter);
  ZeroXInstanceKeys zik=makeInstanceKeys(cha,options,contextInterpreter,instancePolicy);
  setInstanceKeys(zik);
}",0.9818365287588294
40401,"protected SSAContextInterpreter makeContextInterpreter(SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect){
  SSAContextInterpreter defI=new DefaultSSAInterpreter(getOptions(),getAnalysisCache());
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,getOptions(),getAnalysisCache(),reflect),defI);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  return contextInterpreter;
}","protected SSAContextInterpreter makeContextInterpreter(SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect){
  SSAContextInterpreter defI=new DefaultSSAInterpreter(getOptions(),getAnalysisCache());
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,getOptions(),getAnalysisCache(),reflect),defI);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? defI : new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  return contextInterpreter;
}",0.9637883008356546
40402,"/** 
 * @param line a whitespace-delimited string of column names
 */
private void populateColumnHeadings(String line,Character delimiter){
  StringTokenizer st=new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  for (int i=0; i < nColumns; i++) {
    columnHeadings.set(i,(String)st.nextElement());
  }
}","/** 
 * @param line a whitespace-delimited string of column names
 */
private void populateColumnHeadings(String line,Character delimiter){
  StringTokenizer st=delimiter == null ? new StringTokenizer(line) : new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  for (int i=0; i < nColumns; i++) {
    columnHeadings.set(i,(String)st.nextElement());
  }
}",0.9333333333333332
40403,"private void populateRow(int row,String line,Character delimiter){
  StringTokenizer st=new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  Assertions.productionAssertion(nColumns == getNumberOfColumns(),""String_Node_Str"" + getNumberOfColumns() + ""String_Node_Str""+ nColumns+ ""String_Node_Str""+ row+ ""String_Node_Str""+ line.length()+ ""String_Node_Str""+ line);
  SimpleVector<String> r=new SimpleVector<String>();
  rows.add(row,r);
  for (int i=0; i < nColumns; i++) {
    r.set(i,(String)st.nextElement());
  }
}","private void populateRow(int row,String line,Character delimiter){
  StringTokenizer st=delimiter == null ? new StringTokenizer(line) : new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  Assertions.productionAssertion(nColumns == getNumberOfColumns(),""String_Node_Str"" + getNumberOfColumns() + ""String_Node_Str""+ nColumns+ ""String_Node_Str""+ row+ ""String_Node_Str""+ line.length()+ ""String_Node_Str""+ line);
  SimpleVector<String> r=new SimpleVector<String>();
  rows.add(row,r);
  for (int i=0; i < nColumns; i++) {
    r.set(i,(String)st.nextElement());
  }
}",0.9577464788732394
40404,"@Override public void addSeed(PathEdge<T> seed){
  unbalancedSeeds.add(Pair.make(seed.entry,seed.d1));
  super.addSeed(seed);
}","@Override public void addSeed(PathEdge<T> seed){
  if (getSeeds().contains(seed)) {
    return;
  }
  unbalancedSeeds.add(Pair.make(seed.entry,seed.d1));
  super.addSeed(seed);
}",0.8327868852459016
40405,"/** 
 * Spawn a process to execute the given command
 * @return an object representing the process
 * @throws WalaException
 * @throws IllegalArgumentException
 * @throws IOException
 */
protected Process spawnProcess(String cmd) throws IllegalArgumentException, IOException {
  if (cmd == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (logger != null) {
    logger.fine(""String_Node_Str"" + cmd);
  }
  String[] ev=getEnv() == null ? null : buildEnv(getEnv());
  Process p=Runtime.getRuntime().exec(cmd,ev,getWorkingDir());
  return p;
}","/** 
 * Spawn a process to execute the given command
 * @return an object representing the process
 * @throws WalaException
 * @throws IllegalArgumentException
 * @throws IOException
 */
protected Process spawnProcess(String cmd) throws IllegalArgumentException, IOException {
  if (cmd == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + cmd);
  if (logger != null) {
    logger.fine(""String_Node_Str"" + cmd);
  }
  String[] ev=getEnv() == null ? null : buildEnv(getEnv());
  Process p=Runtime.getRuntime().exec(cmd,ev,getWorkingDir());
  return p;
}",0.9602032176121932
40406,"/** 
 * This is fragile.  Use with care.
 * @return a String representing the path to the wala.core plugin installation
 */
public static String getWalaCorePluginHome(){
  if (CorePlugin.getDefault() == null) {
    return null;
  }
  String install=Platform.getInstallLocation().getURL().getPath();
  Bundle b=Platform.getBundle(""String_Node_Str"");
  String l=b.getLocation();
  if (l.startsWith(""String_Node_Str"")) {
    l=l.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return install + File.separator + l;
}","/** 
 * This is fragile.  Use with care.
 * @return a String representing the path to the wala.core plugin installation
 */
public static String getWalaCorePluginHome(){
  if (CorePlugin.getDefault() == null) {
    return null;
  }
  String install=Platform.getInstallLocation().getURL().getPath();
  Bundle b=Platform.getBundle(""String_Node_Str"");
  String l=b.getLocation();
  if (l.startsWith(""String_Node_Str"")) {
    l=l.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (l.startsWith(""String_Node_Str"")) {
    return l.replace(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    return install + File.separator + l;
  }
}",0.8973913043478261
40407,"/** 
 * Return the unique receiver of an invocation of method on an object of type declaringClass
 * @param receiverClass type of receiver
 * @param selector method signature
 * @return Method resolved method abstraction
 * @throws IllegalArgumentException if receiverClass is null
 */
public IMethod resolveMethod(IClass receiverClass,Selector selector){
  if (receiverClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IMethod result=findMethod(receiverClass,selector);
  if (result != null) {
    return result;
  }
 else {
    IClass superclass=null;
    try {
      superclass=receiverClass.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      Assertions.UNREACHABLE();
    }
    if (superclass == null) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + selector + ""String_Node_Str"");
      }
      return null;
    }
 else {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + receiverClass + ""String_Node_Str""+ superclass+ ""String_Node_Str""+ selector);
      }
      return resolveMethod(superclass,selector);
    }
  }
}","/** 
 * Return the unique target of an invocation of method on an object of type declaringClass
 * @param receiverClass type of receiver
 * @param selector method signature
 * @return Method resolved method abstraction
 * @throws IllegalArgumentException if receiverClass is null
 */
public IMethod resolveMethod(IClass receiverClass,Selector selector){
  if (receiverClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IMethod result=findMethod(receiverClass,selector);
  if (result != null) {
    return result;
  }
 else {
    IClass superclass=null;
    try {
      superclass=receiverClass.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      Assertions.UNREACHABLE();
    }
    if (superclass == null) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + selector + ""String_Node_Str"");
      }
      return null;
    }
 else {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + receiverClass + ""String_Node_Str""+ superclass+ ""String_Node_Str""+ selector);
      }
      return resolveMethod(superclass,selector);
    }
  }
}",0.9936189608021878
40408,"/** 
 * Find the possible receivers of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
@SuppressWarnings(""String_Node_Str"") private Set<IMethod> findOrCreateTargetSet(IClass declaredClass,MethodReference ref){
  Map<MethodReference,Set<IMethod>> classCache=(Map<MethodReference,Set<IMethod>>)CacheReference.get(targetCache.get(declaredClass));
  if (classCache == null) {
    classCache=HashMapFactory.make(3);
    targetCache.put(declaredClass,CacheReference.make(classCache));
  }
  Set<IMethod> result=classCache.get(ref);
  if (result == null) {
    result=getPossibleTargets(declaredClass,ref);
    classCache.put(ref,result);
  }
  return result;
}","/** 
 * Find the possible targets of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
@SuppressWarnings(""String_Node_Str"") private Set<IMethod> findOrCreateTargetSet(IClass declaredClass,MethodReference ref){
  Map<MethodReference,Set<IMethod>> classCache=(Map<MethodReference,Set<IMethod>>)CacheReference.get(targetCache.get(declaredClass));
  if (classCache == null) {
    classCache=HashMapFactory.make(3);
    targetCache.put(declaredClass,CacheReference.make(classCache));
  }
  Set<IMethod> result=classCache.get(ref);
  if (result == null) {
    result=getPossibleTargets(declaredClass,ref);
    classCache.put(ref,result);
  }
  return result;
}",0.9904240766073872
40409,"/** 
 * Find the possible receivers of a call to a method reference where the receiver is of a certain type
 * @param receiverClass the class of the receiver
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
public Set<IMethod> getPossibleTargets(IClass receiverClass,MethodReference ref);","/** 
 * Find the possible targets of a call to a method reference where the receiver is of a certain type
 * @param receiverClass the class of the receiver
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
public Set<IMethod> getPossibleTargets(IClass receiverClass,MethodReference ref);",0.9791044776119404
40410,"/** 
 * Add a New statement of the given type
 * @return instruction added, or null
 * @throws IllegalArgumentException if T is null
 */
private SSANewInstruction addAllocation(TypeReference T,boolean invokeCtor){
  if (T == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int instance=nextLocal++;
  SSANewInstruction result=null;
  if (T.isReferenceType()) {
    NewSiteReference ref=NewSiteReference.make(statements.size(),T);
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      Arrays.fill(sizes,getValueNumberForIntConstant(1));
      result=new SSANewInstruction(instance,ref,sizes);
    }
 else {
      result=new SSANewInstruction(instance,ref);
    }
    statements.add(result);
    IClass klass=cha.lookupClass(T);
    if (klass == null) {
      Warnings.add(AllocationFailure.create(T));
      return null;
    }
    if (klass.isArrayClass()) {
      int arrayRef=result.getDef();
      TypeReference e=klass.getReference().getArrayElementType();
      while (e != null && !e.isPrimitiveType()) {
        NewSiteReference n=NewSiteReference.make(statements.size(),e);
        int alloc=nextLocal++;
        SSANewInstruction ni=null;
        if (e.isArrayType()) {
          int[] sizes=new int[T.getDimensionality()];
          Arrays.fill(sizes,getValueNumberForIntConstant(1));
          ni=new SSANewInstruction(alloc,n,sizes);
        }
 else {
          ni=new SSANewInstruction(alloc,n);
        }
        statements.add(ni);
        SSAArrayStoreInstruction store=new SSAArrayStoreInstruction(arrayRef,0,alloc,e);
        statements.add(store);
        e=e.isArrayType() ? e.getArrayElementType() : null;
        arrayRef=alloc;
      }
    }
    if (invokeCtor) {
      IMethod ctor=cha.resolveMethod(klass,MethodReference.initSelector);
      if (ctor != null) {
        addInvocation(new int[]{instance},CallSiteReference.make(statements.size(),ctor.getReference(),IInvokeInstruction.Dispatch.SPECIAL));
      }
    }
  }
  cache.invalidate(this,Everywhere.EVERYWHERE);
  return result;
}","/** 
 * Add a New statement of the given type
 * @return instruction added, or null
 * @throws IllegalArgumentException if T is null
 */
private SSANewInstruction addAllocation(TypeReference T,boolean invokeCtor){
  if (T == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int instance=nextLocal++;
  SSANewInstruction result=null;
  if (T.isReferenceType()) {
    NewSiteReference ref=NewSiteReference.make(statements.size(),T);
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      Arrays.fill(sizes,getValueNumberForIntConstant(1));
      result=new SSANewInstruction(instance,ref,sizes);
    }
 else {
      result=new SSANewInstruction(instance,ref);
    }
    statements.add(result);
    IClass klass=cha.lookupClass(T);
    if (klass == null) {
      Warnings.add(AllocationFailure.create(T));
      return null;
    }
    if (klass.isArrayClass()) {
      int arrayRef=result.getDef();
      TypeReference e=klass.getReference().getArrayElementType();
      while (e != null && !e.isPrimitiveType()) {
        NewSiteReference n=NewSiteReference.make(statements.size(),e);
        int alloc=nextLocal++;
        SSANewInstruction ni=null;
        if (e.isArrayType()) {
          int[] sizes=new int[T.getDimensionality()];
          Arrays.fill(sizes,getValueNumberForIntConstant(1));
          ni=new SSANewInstruction(alloc,n,sizes);
        }
 else {
          ni=new SSANewInstruction(alloc,n);
        }
        statements.add(ni);
        SSAArrayStoreInstruction store=new SSAArrayStoreInstruction(arrayRef,getValueNumberForIntConstant(0),alloc,e);
        statements.add(store);
        e=e.isArrayType() ? e.getArrayElementType() : null;
        arrayRef=alloc;
      }
    }
    if (invokeCtor) {
      IMethod ctor=cha.resolveMethod(klass,MethodReference.initSelector);
      if (ctor != null) {
        addInvocation(new int[]{instance},CallSiteReference.make(statements.size(),ctor.getReference(),IInvokeInstruction.Dispatch.SPECIAL));
      }
    }
  }
  cache.invalidate(this,Everywhere.EVERYWHERE);
  return result;
}",0.9927919269581932
40411,"/** 
 * don't call this unless you really know what you're doing
 */
public Operator getOperator(){
  if (opcode < OP_iand) {
    return Operator.values()[(opcode - OP_iadd) / 4];
  }
 else {
    return Operator.values()[(opcode - OP_iand) / 2];
  }
}","public Operator getOperator(){
  if (opcode < OP_iand) {
    return Operator.values()[(opcode - OP_iadd) / 4];
  }
 else {
    return Operator.values()[5 + (opcode - OP_iand) / 2];
  }
}",0.8329519450800915
40412,"public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case PI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
return caller.getValueNumber() == callee.getValueNumber() && cg.getPossibleTargets(caller.getNode(),caller.getInstruction().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE(src.getKind());
return false;
}
}","public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case PI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
case METHOD_EXIT:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
SSAAbstractInvokeInstruction call=caller.getInstruction();
final CGNode calleeNode=callee.getNode();
if (!cg.getPossibleTargets(caller.getNode(),call.getCallSite()).contains(calleeNode)) {
return false;
}
if (dOptions.isTerminateAtCast() && call.isDispatch() && caller.getValueNumber() == call.getReceiver()) {
return false;
}
if (dOptions.isTerminateAtCast() && isUninformativeForReflection(calleeNode)) {
return false;
}
for (int i=0; i < calleeNode.getMethod().getNumberOfParameters(); i++) {
if (call.getUse(i) == caller.getValueNumber()) {
  if (callee.getValueNumber() == i + 1) {
    return true;
  }
}
}
return false;
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE(src.getKind());
return false;
}
}",0.8885482140119577
40413,"private CAstNode walkNodesInternal(final Node n,WalkContext context){
  int NT=n.getType();
switch (NT) {
case Token.FUNCTION:
{
      int fnIndex=n.getExistingIntProp(Node.FUNCTION_PROP);
      FunctionNode fn=context.top().getFunctionNode(fnIndex);
      CAstEntity fne=walkEntity(fn,context);
      if (context.expressionContext()) {
        CAstNode fun=Ast.makeNode(CAstNode.FUNCTION_EXPR,Ast.makeConstant(fne));
        context.addScopedEntity(fun,fne);
        return fun;
      }
 else {
        context.addInitializer(Ast.makeNode(CAstNode.FUNCTION_STMT,Ast.makeConstant(fne)));
        context.addScopedEntity(null,fne);
        return Ast.makeNode(CAstNode.EMPTY);
      }
    }
case Token.CATCH_SCOPE:
{
    Node catchVarNode=n.getFirstChild();
    String catchVarName=catchVarNode.getString();
    Assertions._assert(catchVarName != null);
    context.setCatchVar(catchVarName);
    return Ast.makeNode(CAstNode.EMPTY);
  }
case Token.LOCAL_BLOCK:
{
  return Ast.makeNode(CAstNode.BLOCK_EXPR,gatherChildren(n,context));
}
case Token.TRY:
{
Node catchNode=((Node.Jump)n).target;
Node finallyNode=((Node.Jump)n).getFinally();
ArrayList<Node> tryList=new ArrayList<Node>();
ArrayList<Node> catchList=new ArrayList<Node>();
ArrayList<Node> finallyList=new ArrayList<Node>();
ArrayList<Node> current=tryList;
Node c;
for (c=n.getFirstChild(); c.getNext() != null; c=c.getNext()) {
  if (c == catchNode) {
    current=catchList;
  }
 else   if (c == finallyNode) {
    current=finallyList;
  }
  if (c.getType() == Token.GOTO && (c.getNext() == catchNode || c.getNext() == finallyNode)) {
    continue;
  }
  current.add(c);
}
CAstNode finallyBlock=null;
if (finallyNode != null) {
  int i=0;
  CAstNode[] finallyAsts=new CAstNode[finallyList.size()];
  for (Iterator<Node> fns=finallyList.iterator(); fns.hasNext(); ) {
    finallyAsts[i++]=walkNodes(fns.next(),context);
  }
  finallyBlock=Ast.makeNode(CAstNode.BLOCK_STMT,finallyAsts);
}
if (catchNode != null) {
  int i=0;
  WalkContext catchChild=new CatchBlockContext(context);
  CAstNode[] catchAsts=new CAstNode[catchList.size()];
  for (Iterator<Node> cns=catchList.iterator(); cns.hasNext(); ) {
    catchAsts[i++]=walkNodes(cns.next(),catchChild);
  }
  CAstNode catchBlock=Ast.makeNode(CAstNode.CATCH,Ast.makeConstant(catchChild.getCatchVar()),Ast.makeNode(CAstNode.BLOCK_STMT,catchAsts));
  context.cfg().map(catchBlock,catchBlock);
  i=0;
  WalkContext tryChild=new TryBlockContext(context,catchBlock);
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),tryChild);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  if (finallyBlock != null) {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),finallyBlock),walkNodes(c,context));
  }
 else {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),walkNodes(c,context));
  }
}
 else {
  int i=0;
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),context);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.BLOCK_STMT,tryBlock),Ast.makeNode(CAstNode.BLOCK_STMT,finallyBlock)),walkNodes(c,context));
}
}
case Token.JSR:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.COMMA:
{
int count=0;
for (Node c=n.getFirstChild(); c != null; count++, c=c.getNext()) ;
CAstNode[] cs=new CAstNode[count];
int i=0;
for (Node c=n.getFirstChild(); c != null; i++, c=c.getNext()) {
if (c.getNext() == null) {
context.copyBase(n,c);
}
cs[i]=walkNodes(c,context);
}
return Ast.makeNode(CAstNode.BLOCK_EXPR,cs);
}
case Token.ENTERWITH:
case Token.LEAVEWITH:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.LOOP:
{
LoopContext child=new LoopContext(context);
CAstNode[] nodes=gatherChildren(n,child);
if (child.forInInitExpr != null) {
String nm=child.forInVar;
return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm,true)),walkNodes(child.forInInitExpr,context)),nodes);
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,nodes);
}
}
case Token.WITH:
case Token.FINALLY:
case Token.BLOCK:
case Token.LABEL:
{
Node c1=n.getFirstChild();
if (c1 != null && c1.getType() == Token.SWITCH) {
Node switchValue=c1.getFirstChild();
CAstNode defaultLabel=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(defaultLabel,defaultLabel);
for (Node kase=switchValue.getNext(); kase != null; kase=kase.getNext()) {
Assertions._assert(kase.getType() == Token.CASE);
Node caseLbl=kase.getFirstChild();
Node target=((Node.Jump)kase).target;
context.cfg().add(c1,target,walkNodes(caseLbl,context));
}
context.cfg().add(c1,defaultLabel,CAstControlFlowMap.SWITCH_DEFAULT);
CAstNode switchAst=Ast.makeNode(CAstNode.SWITCH,walkNodes(switchValue,context),Ast.makeNode(CAstNode.BLOCK_STMT,defaultLabel,gatherChildren(n,context,1)));
noteSourcePosition(context,switchAst,c1);
context.cfg().map(c1,switchAst);
return switchAst;
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,gatherChildren(n,context));
}
}
case Token.EXPR_VOID:
case Token.EXPR_RESULT:
case Token.POS:
{
WalkContext child=new ExpressionContext(context);
Node expr=n.getFirstChild();
if (NT == Token.EXPR_RESULT) {
child.copyBase(n,expr);
}
return walkNodes(expr,child);
}
case Token.CALL:
{
if (!isPrimitiveCall(context,n)) {
CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
Node callee=n.getFirstChild();
WalkContext child=new BaseCollectingContext(context,callee,base);
CAstNode fun=walkNodes(callee,child);
if (child.foundBase(callee)) return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,callee.getNext(),context)));
 else return makeCall(fun,Ast.makeConstant(null),callee.getNext(),context);
}
 else {
return Ast.makeNode(CAstNode.PRIMITIVE,gatherChildren(n,context,1));
}
}
case Token.NAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.THIS:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
}
case Token.THISFN:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(((FunctionNode)context.top()).getFunctionName()));
}
case Token.STRING:
{
return Ast.makeConstant(n.getString());
}
case Token.NUMBER:
{
return Ast.makeConstant(n.getDouble());
}
case Token.FALSE:
{
return Ast.makeConstant(false);
}
case Token.TRUE:
{
return Ast.makeConstant(true);
}
case Token.NULL:
{
return Ast.makeConstant(null);
}
case Token.ADD:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
case Token.BITAND:
case Token.EQ:
case Token.SHEQ:
case Token.GE:
case Token.GT:
case Token.LE:
case Token.LT:
case Token.SHNE:
case Token.NE:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(NT),walkNodes(l,context),walkNodes(r,context));
}
case Token.NEG:
{
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(Token.SUB),Ast.makeConstant(0),walkNodes(n.getFirstChild(),context));
}
case Token.BITNOT:
case Token.NOT:
{
return Ast.makeNode(CAstNode.UNARY_EXPR,translateOpcode(NT),walkNodes(n.getFirstChild(),context));
}
case Token.VAR:
{
Node nm=n.getFirstChild();
context.addInitializer(Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm.getString())),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""))));
if (nm.getFirstChild() != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(nm.getString())),walkNodes(nm.getFirstChild(),child));
}
 else {
if (n.getNext().getType() == Token.ENUM_INIT_KEYS) {
context.getForInVar(nm.getString(),n.getNext().getFirstChild());
}
return Ast.makeNode(CAstNode.EMPTY);
}
}
case Token.REGEXP:
{
int regexIdx=n.getIntProp(Node.REGEXP_PROP,-1);
Assertions._assert(regexIdx != -1,""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top()));
String flags=context.top().getRegexpFlags(regexIdx);
Node flagsNode=Node.newString(flags);
String str=context.top().getRegexpString(regexIdx);
Node strNode=Node.newString(str);
strNode.addChildToFront(flagsNode);
return handleNew(context,""String_Node_Str"",strNode);
}
case Token.ENUM_INIT_KEYS:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.ENUM_ID:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_GET,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.ENUM_NEXT:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_HAS_NEXT,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.RETURN:
{
Node val=n.getFirstChild();
if (val != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.RETURN,walkNodes(val,child));
}
 else {
return Ast.makeNode(CAstNode.RETURN);
}
}
case Token.SETNAME:
{
Node nm=n.getFirstChild();
return Ast.makeNode(CAstNode.ASSIGN,walkNodes(nm,context),walkNodes(nm.getNext(),context));
}
case Token.BINDNAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.IFNE:
case Token.IFEQ:
{
context.cfg().add(n,((Node.Jump)n).target,Boolean.TRUE);
WalkContext child=new ExpressionContext(context);
CAstNode gotoAst=Ast.makeNode(CAstNode.IFGOTO,translateOpcode(NT),walkNodes(n.getFirstChild(),child),Ast.makeConstant(1));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.GOTO:
{
context.cfg().add(n,((Node.Jump)n).target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.BREAK:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.CONTINUE:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().getContinue(),null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().getContinue().labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.TARGET:
{
CAstNode result=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(n.labelId()),Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(n,result);
return result;
}
case Token.OR:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),Ast.makeConstant(true),walkNodes(r,context));
}
case Token.AND:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),walkNodes(r,context),Ast.makeConstant(false));
}
case Token.HOOK:
{
Node cond=n.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(cond,context),walkNodes(thenBranch,context),walkNodes(elseBranch,context));
}
case Token.INC:
case Token.DEC:
{
int flags=n.getIntProp(Node.INCRDECR_PROP,-1);
CAstNode op=((flags & Node.DECR_FLAG) != 0) ? CAstOperator.OP_SUB : CAstOperator.OP_ADD;
Node l=n.getFirstChild();
CAstNode last=walkNodes(l,context);
return Ast.makeNode((((flags & Node.POST_FLAG) != 0) ? CAstNode.ASSIGN_POST_OP : CAstNode.ASSIGN_PRE_OP),last,Ast.makeConstant(1),op);
}
case Token.NEW:
{
if (isPrimitiveCreation(context,n)) {
return makeBuiltinNew(context,n.getFirstChild().getString());
}
 else {
Node receiver=n.getFirstChild();
return handleNew(context,walkNodes(receiver,context),receiver.getNext());
}
}
case Token.ARRAYLIT:
{
int count=0;
for (Node x=n.getFirstChild(); x != null; count++, x=x.getNext()) ;
int i=0;
CAstNode[] args=new CAstNode[2 * count + 1];
args[i++]=(isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null);
int[] skips=(int[])n.getProp(Node.SKIP_INDEXES_PROP);
int skip=0;
int idx=0;
Node elt=n.getFirstChild();
while (elt != null) {
if (skips != null && skip < skips.length && skips[skip] == idx) {
skip++;
idx++;
continue;
}
args[i++]=Ast.makeConstant(idx++);
args[i++]=walkNodes(elt,context);
elt=elt.getNext();
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.OBJECTLIT:
{
Object[] propertyList=(Object[])n.getProp(Node.OBJECT_IDS_PROP);
CAstNode[] args=new CAstNode[propertyList.length * 2 + 1];
int i=0;
args[i++]=((isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null));
Node val=n.getFirstChild();
int nameIdx=0;
for (; nameIdx < propertyList.length; nameIdx++, val=val.getNext()) {
args[i++]=Ast.makeConstant(propertyList[nameIdx]);
args[i++]=walkNodes(val,context);
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.GETPROP:
case Token.GETELEM:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt));
}
 else {
return Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt);
}
}
case Token.SETPROP:
case Token.SETELEM:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node val=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(val,context));
}
case Token.DELPROP:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt),Ast.makeConstant(null)));
}
 else {
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt),Ast.makeConstant(null));
}
}
case Token.TYPEOFNAME:
{
return Ast.makeNode(CAstNode.TYPE_OF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString())));
}
case Token.TYPEOF:
{
return Ast.makeNode(CAstNode.TYPE_OF,walkNodes(n.getFirstChild(),context));
}
case Token.SETPROP_OP:
case Token.SETELEM_OP:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node op=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN_POST_OP,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(op.getFirstChild().getNext(),context),translateOpcode(op.getType()));
}
case Token.THROW:
{
CAstNode catchNode=context.getCatchTarget();
if (catchNode != null) context.cfg().add(n,context.getCatchTarget(),null);
 else context.cfg().add(n,CAstControlFlowMap.EXCEPTION_TO_EXIT,null);
CAstNode throwAst=Ast.makeNode(CAstNode.THROW,walkNodes(n.getFirstChild(),context));
context.cfg().map(n,throwAst);
return throwAst;
}
case Token.EMPTY:
{
return Ast.makeConstant(null);
}
default :
{
System.err.println(""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top())+ ""String_Node_Str""+ NT+ ""String_Node_Str""+ n.getClass()+ ""String_Node_Str"");
Assertions.UNREACHABLE();
return null;
}
}
}","private CAstNode walkNodesInternal(final Node n,WalkContext context){
  int NT=n.getType();
switch (NT) {
case Token.FUNCTION:
{
      int fnIndex=n.getExistingIntProp(Node.FUNCTION_PROP);
      FunctionNode fn=context.top().getFunctionNode(fnIndex);
      CAstEntity fne=walkEntity(fn,context);
      if (context.expressionContext()) {
        CAstNode fun=Ast.makeNode(CAstNode.FUNCTION_EXPR,Ast.makeConstant(fne));
        context.addScopedEntity(fun,fne);
        return fun;
      }
 else {
        context.addInitializer(Ast.makeNode(CAstNode.FUNCTION_STMT,Ast.makeConstant(fne)));
        context.addScopedEntity(null,fne);
        return Ast.makeNode(CAstNode.EMPTY);
      }
    }
case Token.CATCH_SCOPE:
{
    Node catchVarNode=n.getFirstChild();
    String catchVarName=catchVarNode.getString();
    Assertions._assert(catchVarName != null);
    context.setCatchVar(catchVarName);
    return Ast.makeNode(CAstNode.EMPTY);
  }
case Token.LOCAL_BLOCK:
{
  return Ast.makeNode(CAstNode.BLOCK_EXPR,gatherChildren(n,context));
}
case Token.TRY:
{
Node catchNode=((Node.Jump)n).target;
Node finallyNode=((Node.Jump)n).getFinally();
ArrayList<Node> tryList=new ArrayList<Node>();
ArrayList<Node> catchList=new ArrayList<Node>();
ArrayList<Node> finallyList=new ArrayList<Node>();
ArrayList<Node> current=tryList;
Node c;
for (c=n.getFirstChild(); c.getNext() != null; c=c.getNext()) {
  if (c == catchNode) {
    current=catchList;
  }
 else   if (c == finallyNode) {
    current=finallyList;
  }
  if (c.getType() == Token.GOTO && (c.getNext() == catchNode || c.getNext() == finallyNode)) {
    continue;
  }
  current.add(c);
}
CAstNode finallyBlock=null;
if (finallyNode != null) {
  int i=0;
  CAstNode[] finallyAsts=new CAstNode[finallyList.size()];
  for (Iterator<Node> fns=finallyList.iterator(); fns.hasNext(); ) {
    finallyAsts[i++]=walkNodes(fns.next(),context);
  }
  finallyBlock=Ast.makeNode(CAstNode.BLOCK_STMT,finallyAsts);
}
if (catchNode != null) {
  int i=0;
  WalkContext catchChild=new CatchBlockContext(context);
  CAstNode[] catchAsts=new CAstNode[catchList.size()];
  for (Iterator<Node> cns=catchList.iterator(); cns.hasNext(); ) {
    catchAsts[i++]=walkNodes(cns.next(),catchChild);
  }
  CAstNode catchBlock=Ast.makeNode(CAstNode.CATCH,Ast.makeConstant(catchChild.getCatchVar()),Ast.makeNode(CAstNode.BLOCK_STMT,catchAsts));
  context.cfg().map(catchBlock,catchBlock);
  i=0;
  WalkContext tryChild=new TryBlockContext(context,catchBlock);
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),tryChild);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  if (finallyBlock != null) {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),finallyBlock),walkNodes(c,context));
  }
 else {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),walkNodes(c,context));
  }
}
 else {
  int i=0;
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),context);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.BLOCK_STMT,tryBlock),Ast.makeNode(CAstNode.BLOCK_STMT,finallyBlock)),walkNodes(c,context));
}
}
case Token.JSR:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.COMMA:
{
int count=0;
for (Node c=n.getFirstChild(); c != null; count++, c=c.getNext()) ;
CAstNode[] cs=new CAstNode[count];
int i=0;
for (Node c=n.getFirstChild(); c != null; i++, c=c.getNext()) {
if (c.getNext() == null) {
context.copyBase(n,c);
}
cs[i]=walkNodes(c,context);
}
return Ast.makeNode(CAstNode.BLOCK_EXPR,cs);
}
case Token.ENTERWITH:
case Token.LEAVEWITH:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.LOOP:
{
LoopContext child=new LoopContext(context);
CAstNode[] nodes=gatherChildren(n,child);
if (child.forInInitExpr != null) {
String nm=child.forInVar;
return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm,true)),walkNodes(child.forInInitExpr,context)),nodes);
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,nodes);
}
}
case Token.WITH:
case Token.FINALLY:
case Token.BLOCK:
case Token.LABEL:
{
Node c1=n.getFirstChild();
if (c1 != null && c1.getType() == Token.SWITCH) {
Node switchValue=c1.getFirstChild();
CAstNode defaultLabel=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(defaultLabel,defaultLabel);
for (Node kase=switchValue.getNext(); kase != null; kase=kase.getNext()) {
Assertions._assert(kase.getType() == Token.CASE);
Node caseLbl=kase.getFirstChild();
Node target=((Node.Jump)kase).target;
context.cfg().add(c1,target,walkNodes(caseLbl,context));
}
context.cfg().add(c1,defaultLabel,CAstControlFlowMap.SWITCH_DEFAULT);
CAstNode switchAst=Ast.makeNode(CAstNode.SWITCH,walkNodes(switchValue,context),Ast.makeNode(CAstNode.BLOCK_STMT,defaultLabel,gatherChildren(n,context,1)));
noteSourcePosition(context,switchAst,c1);
context.cfg().map(c1,switchAst);
return switchAst;
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,gatherChildren(n,context));
}
}
case Token.EXPR_VOID:
case Token.EXPR_RESULT:
case Token.POS:
{
WalkContext child=new ExpressionContext(context);
Node expr=n.getFirstChild();
if (NT == Token.EXPR_RESULT) {
child.copyBase(n,expr);
}
return walkNodes(expr,child);
}
case Token.CALL:
{
if (!isPrimitiveCall(context,n)) {
CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
Node callee=n.getFirstChild();
WalkContext child=new BaseCollectingContext(context,callee,base);
CAstNode fun=walkNodes(callee,child);
if (child.foundBase(callee)) return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,callee.getNext(),context)));
 else return makeCall(fun,Ast.makeConstant(null),callee.getNext(),context);
}
 else {
return Ast.makeNode(CAstNode.PRIMITIVE,gatherChildren(n,context,1));
}
}
case Token.NAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.THIS:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
}
case Token.THISFN:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(((FunctionNode)context.top()).getFunctionName()));
}
case Token.STRING:
{
return Ast.makeConstant(n.getString());
}
case Token.NUMBER:
{
return Ast.makeConstant(n.getDouble());
}
case Token.FALSE:
{
return Ast.makeConstant(false);
}
case Token.TRUE:
{
return Ast.makeConstant(true);
}
case Token.NULL:
case Token.VOID:
{
return Ast.makeConstant(null);
}
case Token.ADD:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.EQ:
case Token.SHEQ:
case Token.GE:
case Token.GT:
case Token.LE:
case Token.LT:
case Token.SHNE:
case Token.NE:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(NT),walkNodes(l,context),walkNodes(r,context));
}
case Token.NEG:
{
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(Token.SUB),Ast.makeConstant(0),walkNodes(n.getFirstChild(),context));
}
case Token.BITNOT:
case Token.NOT:
{
return Ast.makeNode(CAstNode.UNARY_EXPR,translateOpcode(NT),walkNodes(n.getFirstChild(),context));
}
case Token.VAR:
{
Node nm=n.getFirstChild();
context.addInitializer(Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm.getString())),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""))));
if (nm.getFirstChild() != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(nm.getString())),walkNodes(nm.getFirstChild(),child));
}
 else {
return Ast.makeNode(CAstNode.EMPTY);
}
}
case Token.REGEXP:
{
int regexIdx=n.getIntProp(Node.REGEXP_PROP,-1);
Assertions._assert(regexIdx != -1,""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top()));
String flags=context.top().getRegexpFlags(regexIdx);
Node flagsNode=Node.newString(flags);
String str=context.top().getRegexpString(regexIdx);
Node strNode=Node.newString(str);
strNode.addChildToFront(flagsNode);
return handleNew(context,""String_Node_Str"",strNode);
}
case Token.ENUM_INIT_KEYS:
{
context.getForInVar(n.getFirstChild());
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.ENUM_ID:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_GET,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.ENUM_NEXT:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_HAS_NEXT,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.RETURN:
{
Node val=n.getFirstChild();
if (val != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.RETURN,walkNodes(val,child));
}
 else {
return Ast.makeNode(CAstNode.RETURN);
}
}
case Token.SETNAME:
{
Node nm=n.getFirstChild();
return Ast.makeNode(CAstNode.ASSIGN,walkNodes(nm,context),walkNodes(nm.getNext(),context));
}
case Token.BINDNAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.IFNE:
case Token.IFEQ:
{
context.cfg().add(n,((Node.Jump)n).target,Boolean.TRUE);
WalkContext child=new ExpressionContext(context);
CAstNode gotoAst=Ast.makeNode(CAstNode.IFGOTO,translateOpcode(NT),walkNodes(n.getFirstChild(),child),Ast.makeConstant(1));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.GOTO:
{
context.cfg().add(n,((Node.Jump)n).target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.BREAK:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.CONTINUE:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().getContinue(),null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().getContinue().labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.TARGET:
{
CAstNode result=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(n.labelId()),Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(n,result);
return result;
}
case Token.OR:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),Ast.makeConstant(true),walkNodes(r,context));
}
case Token.AND:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),walkNodes(r,context),Ast.makeConstant(false));
}
case Token.HOOK:
{
Node cond=n.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(cond,context),walkNodes(thenBranch,context),walkNodes(elseBranch,context));
}
case Token.INC:
case Token.DEC:
{
int flags=n.getIntProp(Node.INCRDECR_PROP,-1);
CAstNode op=((flags & Node.DECR_FLAG) != 0) ? CAstOperator.OP_SUB : CAstOperator.OP_ADD;
Node l=n.getFirstChild();
CAstNode last=walkNodes(l,context);
return Ast.makeNode((((flags & Node.POST_FLAG) != 0) ? CAstNode.ASSIGN_POST_OP : CAstNode.ASSIGN_PRE_OP),last,Ast.makeConstant(1),op);
}
case Token.NEW:
{
if (isPrimitiveCreation(context,n)) {
return makeBuiltinNew(context,n.getFirstChild().getString());
}
 else {
Node receiver=n.getFirstChild();
return handleNew(context,walkNodes(receiver,context),receiver.getNext());
}
}
case Token.ARRAYLIT:
{
int count=0;
for (Node x=n.getFirstChild(); x != null; count++, x=x.getNext()) ;
int i=0;
CAstNode[] args=new CAstNode[2 * count + 1];
args[i++]=(isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null);
int[] skips=(int[])n.getProp(Node.SKIP_INDEXES_PROP);
int skip=0;
int idx=0;
Node elt=n.getFirstChild();
while (elt != null) {
if (skips != null && skip < skips.length && skips[skip] == idx) {
skip++;
idx++;
continue;
}
args[i++]=Ast.makeConstant(idx++);
args[i++]=walkNodes(elt,context);
elt=elt.getNext();
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.OBJECTLIT:
{
Object[] propertyList=(Object[])n.getProp(Node.OBJECT_IDS_PROP);
CAstNode[] args=new CAstNode[propertyList.length * 2 + 1];
int i=0;
args[i++]=((isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null));
Node val=n.getFirstChild();
int nameIdx=0;
for (; nameIdx < propertyList.length; nameIdx++, val=val.getNext()) {
args[i++]=Ast.makeConstant(propertyList[nameIdx]);
args[i++]=walkNodes(val,context);
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.GETPROP:
case Token.GETELEM:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt));
}
 else {
return Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt);
}
}
case Token.SETPROP:
case Token.SETELEM:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node val=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(val,context));
}
case Token.DELPROP:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt),Ast.makeConstant(null)));
}
 else {
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt),Ast.makeConstant(null));
}
}
case Token.TYPEOFNAME:
{
return Ast.makeNode(CAstNode.TYPE_OF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString())));
}
case Token.TYPEOF:
{
return Ast.makeNode(CAstNode.TYPE_OF,walkNodes(n.getFirstChild(),context));
}
case Token.SETPROP_OP:
case Token.SETELEM_OP:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node op=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN_POST_OP,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(op.getFirstChild().getNext(),context),translateOpcode(op.getType()));
}
case Token.THROW:
{
CAstNode catchNode=context.getCatchTarget();
if (catchNode != null) context.cfg().add(n,context.getCatchTarget(),null);
 else context.cfg().add(n,CAstControlFlowMap.EXCEPTION_TO_EXIT,null);
CAstNode throwAst=Ast.makeNode(CAstNode.THROW,walkNodes(n.getFirstChild(),context));
context.cfg().map(n,throwAst);
return throwAst;
}
case Token.EMPTY:
{
return Ast.makeConstant(null);
}
default :
{
System.err.println(""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top())+ ""String_Node_Str""+ NT+ ""String_Node_Str""+ n.getClass()+ ""String_Node_Str"");
Assertions.UNREACHABLE();
return null;
}
}
}",0.993128692525045
40414,"public String getForInVar(String loopVarName,Node initExpr){
  this.loopVarName=loopVarName;
  this.forInVar=""String_Node_Str"" + counter++;
  this.forInInitExpr=initExpr;
  return forInVar;
}","public String getForInVar(Node initExpr){
  this.forInVar=""String_Node_Str"" + counter++;
  this.forInInitExpr=initExpr;
  return forInVar;
}",0.8459214501510574
40415,"public String getForInLoopVar(){
  Assertions._assert(loopVarName != null);
  return loopVarName;
}","public String getForInLoopVar(){
  return null;
}",0.6216216216216216
40416,"private CAstNode translateOpcode(int nodeType){
switch (nodeType) {
case Token.ADD:
    return CAstOperator.OP_ADD;
case Token.DIV:
  return CAstOperator.OP_DIV;
case Token.LSH:
return CAstOperator.OP_LSH;
case Token.MOD:
return CAstOperator.OP_MOD;
case Token.MUL:
return CAstOperator.OP_MUL;
case Token.RSH:
return CAstOperator.OP_RSH;
case Token.SUB:
return CAstOperator.OP_SUB;
case Token.URSH:
return CAstOperator.OP_URSH;
case Token.BITAND:
return CAstOperator.OP_BIT_AND;
case Token.EQ:
return CAstOperator.OP_EQ;
case Token.SHEQ:
return CAstOperator.OP_EQ;
case Token.IFEQ:
return CAstOperator.OP_EQ;
case Token.GE:
return CAstOperator.OP_GE;
case Token.GT:
return CAstOperator.OP_GT;
case Token.LE:
return CAstOperator.OP_LE;
case Token.LT:
return CAstOperator.OP_LT;
case Token.NE:
return CAstOperator.OP_NE;
case Token.SHNE:
return CAstOperator.OP_NE;
case Token.IFNE:
return CAstOperator.OP_NE;
case Token.BITNOT:
return CAstOperator.OP_BITNOT;
case Token.NOT:
return CAstOperator.OP_NOT;
default :
Assertions.UNREACHABLE();
return null;
}
}","private CAstNode translateOpcode(int nodeType){
switch (nodeType) {
case Token.ADD:
    return CAstOperator.OP_ADD;
case Token.DIV:
  return CAstOperator.OP_DIV;
case Token.LSH:
return CAstOperator.OP_LSH;
case Token.MOD:
return CAstOperator.OP_MOD;
case Token.MUL:
return CAstOperator.OP_MUL;
case Token.RSH:
return CAstOperator.OP_RSH;
case Token.SUB:
return CAstOperator.OP_SUB;
case Token.URSH:
return CAstOperator.OP_URSH;
case Token.BITAND:
return CAstOperator.OP_BIT_AND;
case Token.BITOR:
return CAstOperator.OP_BIT_OR;
case Token.BITXOR:
return CAstOperator.OP_BIT_XOR;
case Token.EQ:
return CAstOperator.OP_EQ;
case Token.SHEQ:
return CAstOperator.OP_EQ;
case Token.IFEQ:
return CAstOperator.OP_EQ;
case Token.GE:
return CAstOperator.OP_GE;
case Token.GT:
return CAstOperator.OP_GT;
case Token.LE:
return CAstOperator.OP_LE;
case Token.LT:
return CAstOperator.OP_LT;
case Token.NE:
return CAstOperator.OP_NE;
case Token.SHNE:
return CAstOperator.OP_NE;
case Token.IFNE:
return CAstOperator.OP_NE;
case Token.BITNOT:
return CAstOperator.OP_BITNOT;
case Token.NOT:
return CAstOperator.OP_NOT;
default :
Assertions.UNREACHABLE();
return null;
}
}",0.9546690843155032
40417,"private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  if (G.getNumberOfNodes() == 0) {
    return;
  }
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  T current=Q.get(0);
  visitChildren(current);
}","private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  if (G.getNumberOfNodes() == 0) {
    return;
  }
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  if (Q.size() > 0) {
    T current=Q.get(0);
    visitChildren(current);
  }
}",0.9510703363914372
40418,"/** 
 * Method getBasicBlockStarts, stolen from ShrikeBT verifier
 */
private void makeBasicBlocks(){
  ExceptionHandler[][] handlers;
  try {
    handlers=method.getHandlers();
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    handlers=null;
  }
  boolean[] r=new boolean[getInstructions().length];
  boolean[] catchers=new boolean[getInstructions().length];
  int blockCount=2;
  r[0]=true;
  Instruction[] instructions=(Instruction[])getInstructions();
  for (int i=0; i < instructions.length; i++) {
    int[] targets=instructions[i].getBranchTargets();
    if (targets.length > 0 || !instructions[i].isFallThrough()) {
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
    }
    for (int j=0; j < targets.length; j++) {
      if (!r[targets[j]]) {
        r[targets[j]]=true;
        blockCount++;
      }
    }
    if (Exceptions.isPEI(instructions[i])) {
      ExceptionHandler[] hs=handlers[i];
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
      if (hs != null && hs.length > 0) {
        for (int j=0; j < hs.length; j++) {
          exceptionHandlers.add(hs[j]);
          if (!r[hs[j].getHandler()]) {
            r[hs[j].getHandler()]=true;
            blockCount++;
          }
          catchers[hs[j].getHandler()]=true;
        }
      }
    }
  }
  BasicBlock entry=new BasicBlock(-1);
  addNode(entry);
  int j=1;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      BasicBlock b=new BasicBlock(i);
      addNode(b);
      if (catchers[i]) {
        setCatchBlock(j);
      }
      j++;
    }
  }
  BasicBlock exit=new BasicBlock(-1);
  addNode(exit);
}","private void makeBasicBlocks(){
  ExceptionHandler[][] handlers;
  try {
    handlers=method.getHandlers();
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    handlers=null;
  }
  boolean[] r=new boolean[getInstructions().length];
  boolean[] catchers=new boolean[getInstructions().length];
  int blockCount=2;
  r[0]=true;
  Instruction[] instructions=(Instruction[])getInstructions();
  for (int i=0; i < instructions.length; i++) {
    int[] targets=instructions[i].getBranchTargets();
    if (targets.length > 0 || !instructions[i].isFallThrough()) {
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
    }
    for (int j=0; j < targets.length; j++) {
      if (!r[targets[j]]) {
        r[targets[j]]=true;
        blockCount++;
      }
    }
    if (Exceptions.isPEI(instructions[i])) {
      ExceptionHandler[] hs=handlers[i];
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
      if (hs != null && hs.length > 0) {
        for (int j=0; j < hs.length; j++) {
          exceptionHandlers.add(hs[j]);
          if (!r[hs[j].getHandler()]) {
            r[hs[j].getHandler()]=true;
            blockCount++;
          }
          catchers[hs[j].getHandler()]=true;
        }
      }
    }
  }
  BasicBlock entry=new BasicBlock(-1);
  addNode(entry);
  int j=1;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      BasicBlock b=new BasicBlock(i);
      addNode(b);
      if (catchers[i]) {
        setCatchBlock(j);
      }
      j++;
    }
  }
  BasicBlock exit=new BasicBlock(-1);
  addNode(exit);
}",0.979591836734694
40419,"/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclassesOfError kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes(){
  if (subTypeRefsOfError == null) {
    computeSubClasses(TypeReference.JavaLangError);
    subTypeRefsOfError=HashSetFactory.make(subclassesOfError.size());
    for (Iterator it=subclassesOfError.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      subTypeRefsOfError.add(klass.getReference());
    }
  }
  return Collections.unmodifiableCollection(subTypeRefsOfError);
}","/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclasses of Error kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes(){
  if (subTypeRefsOfError == null) {
    computeSubClasses(TypeReference.JavaLangError);
    subTypeRefsOfError=HashSetFactory.make(subclassesOfError.size());
    for (Iterator it=subclassesOfError.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      subTypeRefsOfError.add(klass.getReference());
    }
  }
  return Collections.unmodifiableCollection(subTypeRefsOfError);
}",0.994915254237288
40420,"/** 
 * @param klass
 * @return the classes that immediately extend klass. if klass is an array class A[][]...[], we return array classesB[][]...[] (same dimensionality) where B is an immediate subclass of A. If A is primitive, we return the empty set.
 */
public Collection<IClass> getImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    return getImmediateArraySubclasses(klass);
  }
  Function<Node,IClass> node2Class=new Function<Node,IClass>(){
    public IClass apply(    Node n){
      return n.klass;
    }
  }
;
  return Iterator2Collection.toCollection(new MapIterator<Node,IClass>(findNode(klass).children.iterator(),node2Class));
}","/** 
 * @param klass
 * @return the classes that immediately extend klass. if klass is an array class A[][]...[], we return array classes B[][]...[](same dimensionality) where B is an immediate subclass of A. If A is primitive, we return the empty set.
 */
public Collection<IClass> getImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    return getImmediateArraySubclasses(klass);
  }
  Function<Node,IClass> node2Class=new Function<Node,IClass>(){
    public IClass apply(    Node n){
      return n.klass;
    }
  }
;
  return Iterator2Collection.toCollection(new MapIterator<Node,IClass>(findNode(klass).children.iterator(),node2Class));
}",0.9984825493171472
40421,"/** 
 * Return set of all subclasses of type in the Class Hierarchy TODO: Tune this implementation. Consider caching if necessary.
 */
public Collection<IClass> computeSubClasses(TypeReference type){
  IClass T=lookupClass(type);
  if (Assertions.verifyAssertions) {
    if (T == null) {
      Assertions._assert(T != null,""String_Node_Str"" + type);
    }
  }
  if (T.getReference().equals(TypeReference.JavaLangError)) {
    if (subclassesOfError == null) {
      subclassesOfError=computeSubClassesInternal(T);
    }
    return subclassesOfError;
  }
 else {
    return computeSubClassesInternal(T);
  }
}","/** 
 * Return set of all subclasses of type in the Class Hierarchy TODO: Tune this implementation. Consider caching if necessary.
 */
public Collection<IClass> computeSubClasses(TypeReference type){
  IClass t=lookupClass(type);
  if (Assertions.verifyAssertions) {
    if (t == null) {
      Assertions._assert(t != null,""String_Node_Str"" + type);
    }
  }
  if (t.getReference().equals(TypeReference.JavaLangError)) {
    if (subclassesOfError == null) {
      subclassesOfError=computeSubClassesInternal(t);
    }
    return subclassesOfError;
  }
 else   if (t.getReference().equals(TypeReference.JavaLangRuntimeException)) {
    if (runtimeExceptionClasses == null) {
      runtimeExceptionClasses=computeSubClassesInternal(t);
    }
    return runtimeExceptionClasses;
  }
 else {
    return computeSubClassesInternal(t);
  }
}",0.7420249653259362
40422,"/** 
 * @param klass
 * @return the number of classes that immediately extend klass. if klass is an array class A[][]...[], we returnnumber of immediate subclasses of A. If A is primitive, we return 0.
 */
public int getNumberOfImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    IClass innermost=getInnermostTypeOfArrayClass(klass);
    return innermost == null ? 0 : getNumberOfImmediateSubclasses(innermost);
  }
  Node node=findNode(klass);
  return node.children.size();
}","/** 
 * @param klass
 * @return the number of classes that immediately extend klass. if klass is an array class A[][]...[], we return number ofimmediate subclasses of A. If A is primitive, we return 0.
 */
public int getNumberOfImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    IClass innermost=getInnermostTypeOfArrayClass(klass);
    return innermost == null ? 0 : getNumberOfImmediateSubclasses(innermost);
  }
  Node node=findNode(klass);
  return node.children.size();
}",0.979757085020243
40423,"/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclassesOfError kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes();","/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclasses of Error kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes();",0.9897959183673468
40424,"/** 
 * @return Collection<TypeReference>, set of exception types a call to adeclared target might throw.
 * @throws InvalidClassFileException 
 * @throws IllegalArgumentException  if target is null
 * @throws IllegalArgumentException  if cha is null
 */
public static Collection<TypeReference> inferInvokeExceptions(MethodReference target,IClassHierarchy cha) throws InvalidClassFileException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (target == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<TypeReference> set=new ArrayList<TypeReference>(runtimeExceptions);
  set.addAll(cha.getJavaLangErrorTypes());
  IClass klass=cha.lookupClass(target.getDeclaringClass());
  if (klass == null) {
    Warnings.add(MethodResolutionFailure.moderate(target));
  }
  if (klass != null) {
    IMethod M=klass.getMethod(target.getSelector());
    if (M == null) {
      Warnings.add(MethodResolutionFailure.severe(target));
    }
 else {
      TypeReference[] exceptionTypes=M.getDeclaredExceptions();
      if (exceptionTypes != null) {
        set.addAll(Arrays.asList(exceptionTypes));
      }
    }
  }
  return set;
}","/** 
 * @return Collection<TypeReference>, set of exception types a call to adeclared target might throw.
 * @throws InvalidClassFileException 
 * @throws IllegalArgumentException  if target is null
 * @throws IllegalArgumentException  if cha is null
 */
public static Collection<TypeReference> inferInvokeExceptions(MethodReference target,IClassHierarchy cha) throws InvalidClassFileException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (target == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<TypeReference> set=new ArrayList<TypeReference>(cha.getJavaLangRuntimeExceptionTypes());
  set.addAll(cha.getJavaLangErrorTypes());
  IClass klass=cha.lookupClass(target.getDeclaringClass());
  if (klass == null) {
    Warnings.add(MethodResolutionFailure.moderate(target));
  }
  if (klass != null) {
    IMethod M=klass.getMethod(target.getSelector());
    if (M == null) {
      Warnings.add(MethodResolutionFailure.severe(target));
    }
 else {
      TypeReference[] exceptionTypes=M.getDeclaredExceptions();
      if (exceptionTypes != null) {
        set.addAll(Arrays.asList(exceptionTypes));
      }
    }
  }
  return set;
}",0.9896049896049895
40425,"/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          if (D5 != null) {
            D5.foreach(new IntSetAction(){
              public void act(              final int d5){
                for (int i=0; i < entries.length; i++) {
                  final T s_p=entries[i];
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + s_p);
                  }
                  IntSet D3=getInversePathEdges(s_p,c,d4);
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + D3);
                  }
                  if (D3 != null) {
                    D3.foreach(new IntSetAction(){
                      public void act(                      int d3){
                        propagate(s_p,d3,retSite,d5);
                      }
                    }
);
                  }
                }
              }
            }
);
          }
        }
      }
;
      D4.foreach(action);
    }
  }
}","/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          propToReturnSite(c,entries,retSite,d4,D5);
        }
      }
;
      D4.foreach(action);
    }
  }
}",0.8118524658101948
40426,"/** 
 * Propagate information for an ""exit"" edge to a caller return site [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 * @param entries the blocks in the supergraph that are entries for the procedure of c
 * @param retSite the return site being propagated to
 * @param retf the flow function
 */
private void propagateToReturnSiteWithBinaryFlowFunction(final PathEdge edge,final T c,final IntSet D4,final T[] entries,final T retSite,final IFlowFunction retf){
  D4.foreach(new IntSetAction(){
    public void act(    final int d4){
      final IntSet D5=computeBinaryFlow(d4,edge.d2,(IBinaryReturnFlowFunction)retf);
      if (D5 != null) {
        D5.foreach(new IntSetAction(){
          public void act(          final int d5){
            for (int i=0; i < entries.length; i++) {
              final T s_p=entries[i];
              if (DEBUG_LEVEL > 1) {
                System.err.println(""String_Node_Str"" + s_p);
              }
              IntSet D3=getInversePathEdges(s_p,c,d4);
              if (DEBUG_LEVEL > 1) {
                System.err.println(""String_Node_Str"" + D3);
              }
              if (D3 != null) {
                D3.foreach(new IntSetAction(){
                  public void act(                  int d3){
                    propagate(s_p,d3,retSite,d5);
                  }
                }
);
              }
            }
          }
        }
);
      }
    }
  }
);
}","/** 
 * Propagate information for an ""exit"" edge to a caller return site [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 * @param entries the blocks in the supergraph that are entries for the procedure of c
 * @param retSite the return site being propagated to
 * @param retf the flow function
 */
private void propagateToReturnSiteWithBinaryFlowFunction(final PathEdge edge,final T c,final IntSet D4,final T[] entries,final T retSite,final IFlowFunction retf){
  D4.foreach(new IntSetAction(){
    public void act(    final int d4){
      final IntSet D5=computeBinaryFlow(d4,edge.d2,(IBinaryReturnFlowFunction)retf);
      propToReturnSite(c,entries,retSite,d4,D5);
    }
  }
);
}",0.6691297208538588
40427,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitNew(NewInstruction)
 */
@Override public void visitNew(com.ibm.wala.shrikeBT.NewInstruction instruction){
  int result=reuseOrCreateDef();
  TypeReference t=ShrikeUtil.makeTypeReference(loader,instruction.getType());
  NewSiteReference ref=NewSiteReference.make(getCurrentProgramCounter(),t);
  if (t.isArrayType()) {
    int[] sizes=new int[t.getDimensionality()];
    for (int i=0; i < instruction.getArrayBoundsCount(); i++) {
      sizes[i]=workingState.pop();
    }
    for (int i=instruction.getArrayBoundsCount(); i < sizes.length; i++) {
      sizes[i]=symbolTable.getConstant(0);
    }
    emitInstruction(new SSANewInstruction(result,ref,sizes));
  }
 else {
    emitInstruction(new SSANewInstruction(result,ref));
    popN(instruction);
  }
  workingState.push(result);
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitNew(NewInstruction)
 */
@Override public void visitNew(com.ibm.wala.shrikeBT.NewInstruction instruction){
  int result=reuseOrCreateDef();
  TypeReference t=ShrikeUtil.makeTypeReference(loader,instruction.getType());
  NewSiteReference ref=NewSiteReference.make(getCurrentProgramCounter(),t);
  if (t.isArrayType()) {
    int[] sizes=new int[t.getDimensionality()];
    for (int i=0; i < instruction.getArrayBoundsCount(); i++) {
      sizes[instruction.getArrayBoundsCount() - 1 - i]=workingState.pop();
    }
    for (int i=instruction.getArrayBoundsCount(); i < sizes.length; i++) {
      sizes[i]=symbolTable.getConstant(0);
    }
    emitInstruction(new SSANewInstruction(result,ref,sizes));
  }
 else {
    emitInstruction(new SSANewInstruction(result,ref));
    popN(instruction);
  }
  workingState.push(result);
}",0.976798143851508
40428,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, thenreturn an array of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}",0.9867549668874172
40429,"@Override public String toString(SymbolTable symbolTable){
  return getValueString(symbolTable,result) + ""String_Node_Str"" + site.getDeclaredType()+ ""String_Node_Str""+ site.getProgramCounter()+ (params == null ? ""String_Node_Str"" : ""String_Node_Str"" + params.length);
}","@Override public String toString(SymbolTable symbolTable){
  return getValueString(symbolTable,result) + ""String_Node_Str"" + site.getDeclaredType()+ ""String_Node_Str""+ site.getProgramCounter()+ (params == null ? ""String_Node_Str"" : ""String_Node_Str"" + params.length + ""String_Node_Str""+ array2String(params,symbolTable));
}",0.9087837837837838
40430,"public void testMultiNewArray1() throws IOException, ClassHierarchyException {
  AnalysisScope scope=null;
  scope=AnalysisScopeReader.read(TestConstants.WALA_TESTDATA,FileProvider.getFile(""String_Node_Str""),MY_CLASSLOADER);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  IClass klass=cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.MULTI_DIM_MAIN));
  assertTrue(klass != null);
  IMethod m=klass.getMethod(Selector.make(""String_Node_Str""));
  assertTrue(m != null);
  AnalysisCache cache=new AnalysisCache();
  IR ir=cache.getIRFactory().makeIR(m,Everywhere.EVERYWHERE,new SSAOptions());
  assertTrue(ir != null);
  SSAInstruction[] instructions=ir.getInstructions();
  for (  SSAInstruction instr : instructions) {
    if (instr instanceof SSANewInstruction) {
    }
  }
}","public void testMultiNewArray1() throws IOException, ClassHierarchyException {
  AnalysisScope scope=null;
  scope=AnalysisScopeReader.read(TestConstants.WALA_TESTDATA,FileProvider.getFile(""String_Node_Str""),MY_CLASSLOADER);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  IClass klass=cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.MULTI_DIM_MAIN));
  assertTrue(klass != null);
  IMethod m=klass.getMethod(Selector.make(""String_Node_Str""));
  assertTrue(m != null);
  AnalysisCache cache=new AnalysisCache();
  IR ir=cache.getIRFactory().makeIR(m,Everywhere.EVERYWHERE,new SSAOptions());
  assertTrue(ir != null);
  SSAInstruction[] instructions=ir.getInstructions();
  for (  SSAInstruction instr : instructions) {
    if (instr instanceof SSANewInstruction) {
      System.err.println(instr.toString(ir.getSymbolTable()));
      assertTrue(instr.getNumberOfUses() == 3);
      assertTrue(ir.getSymbolTable().getIntValue(instr.getUse(0)) == 3);
      assertTrue(ir.getSymbolTable().getIntValue(instr.getUse(1)) == 4);
    }
  }
}",0.8646656134807793
40431,"public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation){
  IClass type=options.getClassTargetSelector().getAllocatedTarget(node,allocation);
  if (type == null) {
    return null;
  }
  if (node.getContext() instanceof ReceiverInstanceContext) {
    IMethod m=node.getMethod();
    CGNode n=ContainerContextSelector.findNodeRecursiveMatchingContext(m,node.getContext());
    if (n != null) {
      return new NormalAllocationInNode(n,allocation,type);
    }
  }
  InstanceKey key=new NormalAllocationInNode(node,allocation,type);
  return key;
}","public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation){
  IClass type=options.getClassTargetSelector().getAllocatedTarget(node,allocation);
  if (type == null) {
    return null;
  }
  if (node.getContext() instanceof ReceiverInstanceContext || node.getContext() instanceof CallerContext) {
    IMethod m=node.getMethod();
    CGNode n=ContainerContextSelector.findNodeRecursiveMatchingContext(m,node.getContext());
    if (n != null) {
      return new NormalAllocationInNode(n,allocation,type);
    }
  }
  InstanceKey key=new NormalAllocationInNode(node,allocation,type);
  return key;
}",0.9616666666666668
40432,"/** 
 * This method walks recursively up the definition of a context C, to see if the chain of contexts that give rise to C includes the method M. If C is a ReceiverInstanceContext, Let N be the node that allocated C.instance. If N.method == M, return N. Else return findRecursiveMatchingContext(M, N.context) Else return null
 */
public static CGNode findNodeRecursiveMatchingContext(IMethod M,Context C){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + M + ""String_Node_Str""+ C);
  }
  if (C instanceof ReceiverInstanceContext) {
    ReceiverInstanceContext ric=(ReceiverInstanceContext)C;
    if (!(ric.getReceiver() instanceof AllocationSiteInNode)) {
      return null;
    }
    AllocationSiteInNode I=(AllocationSiteInNode)ric.getReceiver();
    CGNode N=I.getNode();
    if (N.getMethod().equals(M)) {
      return N;
    }
 else {
      return findNodeRecursiveMatchingContext(M,N.getContext());
    }
  }
 else {
    return null;
  }
}","/** 
 * This method walks recursively up the definition of a context C, to see if the chain of contexts that give rise to C includes the method M. If C is a ReceiverInstanceContext, Let N be the node that allocated C.instance. If N.method == M, return N. Else return findRecursiveMatchingContext(M, N.context) Else return null
 */
public static CGNode findNodeRecursiveMatchingContext(IMethod m,Context c){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + m + ""String_Node_Str""+ c);
  }
  if (c instanceof ReceiverInstanceContext) {
    ReceiverInstanceContext ric=(ReceiverInstanceContext)c;
    if (!(ric.getReceiver() instanceof AllocationSiteInNode)) {
      return null;
    }
    AllocationSiteInNode i=(AllocationSiteInNode)ric.getReceiver();
    CGNode n=i.getNode();
    if (n.getMethod().equals(m)) {
      return n;
    }
 else {
      return findNodeRecursiveMatchingContext(m,n.getContext());
    }
  }
 else   if (c instanceof CallerContext) {
    CallerContext cc=(CallerContext)c;
    CGNode n=cc.getCaller();
    if (n.getMethod().equals(m)) {
      return n;
    }
 else {
      return findNodeRecursiveMatchingContext(m,n.getContext());
    }
  }
 else {
    return null;
  }
}",0.7222222222222222
40433,"/** 
 * Return the entry basic block for the CFG.
 * @return the entry basic block for the CFG.
 */
public T entry(){
  return getNode(0);
}","/** 
 * Return the entry basic block for the CFG.
 */
public T entry(){
  return getNode(0);
}",0.8034188034188035
40434,"/** 
 * Return the exit basic block for the CFG.
 * @return the exit basic block for the CFG.
 */
public T exit(){
  return exit;
}","/** 
 * Return the exit basic block for the CFG.
 */
public T exit(){
  return exit;
}",0.7926267281105991
40435,"/** 
 * @param method
 */
protected AbstractCFG(IMethod method){
  this.method=method;
  this.catchBlocks=new BitVector(10);
}","protected AbstractCFG(IMethod method){
  this.method=method;
  this.catchBlocks=new BitVector(10);
}",0.8849557522123894
40436,"public static ExplodedInterproceduralCFG make(CallGraph CG){
  return new ExplodedInterproceduralCFG(CG);
}","public static ExplodedInterproceduralCFG make(CallGraph cg){
  return new ExplodedInterproceduralCFG(cg);
}",0.9626168224299064
40437,"public boolean isEntryBlock(){
  return original.isEntryBlock();
}","public boolean isEntryBlock(){
  return instructionIndex == ENTRY_INDEX;
}",0.7
40438,"public int getPredNodeCount(ExplodedBasicBlock b) throws IllegalArgumentException {
  if (b == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (b.isEntryBlock()) {
    return 0;
  }
  if (b.equals(exit) || b.instructionIndex == b.original.getFirstInstructionIndex()) {
    return ir.getControlFlowGraph().getPredNodeCount(b.original);
  }
 else {
    return 1;
  }
}","public int getPredNodeCount(ExplodedBasicBlock b) throws IllegalArgumentException {
  if (b == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (b.isEntryBlock()) {
    return 0;
  }
  if (b.isExitBlock()) {
    return ir.getControlFlowGraph().getPredNodeCount(ir.getControlFlowGraph().exit());
  }
  if (b.instructionIndex == b.original.getFirstInstructionIndex()) {
    if (b.original.isEntryBlock()) {
      return 1;
    }
 else {
      return ir.getControlFlowGraph().getPredNodeCount(b.original);
    }
  }
 else {
    return 1;
  }
}",0.7866805411030177
40439,"public boolean isCatchBlock(){
  return (original.isCatchBlock() && instructionIndex == original.getFirstInstructionIndex());
}","public boolean isCatchBlock(){
  if (original == null) {
    return false;
  }
  return (original.isCatchBlock() && instructionIndex == original.getFirstInstructionIndex());
}",0.8410596026490066
40440,"public ExplodedBasicBlock(int instructionIndex,ISSABasicBlock original){
}","public ExplodedBasicBlock(int instructionIndex,ISSABasicBlock original){
  this.instructionIndex=instructionIndex;
  this.original=original;
}",0.6851851851851852
40441,"public boolean isExitBlock(){
  return original.isExitBlock();
}","public boolean isExitBlock(){
  return instructionIndex == EXIT_INDEX;
}",0.6764705882352942
40442,"private T getDominator(T node){
  return getInfo(node).dominator;
}","private T getDominator(T node){
}",0.66
40443,"/** 
 * The goal of this step is to perform a DFS numbering on the CFG, starting at the root. The exit node is not included.
 */
private void step1(){
  reachableNodeCount=0;
  DFSDiscoverTimeIterator<T> dfs=new SlowDFSDiscoverTimeIterator<T>(G,root){
    public static final long serialVersionUID=88831771771711L;
    @Override protected void visitEdge(    T from,    T to){
      if (DEBUG)       System.out.println(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      setParent(to,from);
    }
  }
;
  while (dfs.hasNext()) {
    T node=dfs.next();
    vertex[++reachableNodeCount]=node;
    setSemi(node,reachableNodeCount);
    if (DEBUG)     System.out.println(node + ""String_Node_Str"" + reachableNodeCount);
  }
}","/** 
 * The goal of this step is to perform a DFS numbering on the CFG, starting at the root. The exit node is not included.
 */
private void step1(){
}",0.3470319634703196
40444,"@Override protected final DominatorInfo getInfo(T node){
  return (DominatorInfo)infoMap[getGraph().getNumber(node)];
}","@Override protected final DominatorInfo getInfo(T node){
}",0.655367231638418
40445,"public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(22,slice.size());
}","public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(30,slice.size());
}",0.9981308411214952
40446,"@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  result.add((IMethod)match.getElement());
}","@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  if (match.getElement() instanceof IMethod) {
    result.add((IMethod)match.getElement());
  }
}",0.8262295081967214
40447,"/** 
 * @param typeSignature Some of the type signatures examples are ""QString;"" (String) and ""I"" (int) The type signatures may be either unresolved (for source types) or resolved (for binary types), and either basic (for basic types) or rich (for parameterized types). See {@link Signature} for details.
 */
public static String getHumanReadableType(String typeSignature){
  String simpleName=Signature.getSignatureSimpleName(typeSignature);
  return simpleName;
}","/** 
 * @param typeSignature Some of the type signatures examples are ""QString;"" (String) and ""I"" (int) The type signatures may beeither unresolved (for source types) or resolved (for binary types), and either basic (for basic types) or rich (for parameterized types). See  {@link Signature} for details.
 */
public static String getHumanReadableType(String typeSignature){
  String simpleName=Signature.getSignatureSimpleName(typeSignature);
  return simpleName;
}",0.9978494623655914
40448,"/** 
 * Use the search engine to find all methods in a java element
 */
public static Collection<IMethod> findMethods(IJavaElement elt){
  if (elt instanceof ICompilationUnit) {
    Collection<IMethod> result=HashSetFactory.make();
    for (    IType type : getClasses((ICompilationUnit)elt)) {
      try {
        for (        IMethod m : type.getMethods()) {
          result.add(m);
        }
      }
 catch (      JavaModelException e) {
        e.printStackTrace();
      }
    }
    return result;
  }
 else {
    final Collection<IMethod> result=HashSetFactory.make();
    SearchPattern p=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.METHOD,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_PATTERN_MATCH);
    IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{elt},IJavaSearchScope.SOURCES);
    SearchEngine engine=new SearchEngine();
    SearchRequestor requestor=new SearchRequestor(){
      @Override public void acceptSearchMatch(      SearchMatch match) throws CoreException {
        result.add((IMethod)match.getElement());
      }
    }
;
    try {
      engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
    return result;
  }
}","/** 
 * Use the search engine to find all methods in a java element
 */
public static Collection<IMethod> findMethods(IJavaElement elt){
  if (elt instanceof ICompilationUnit) {
    Collection<IMethod> result=HashSetFactory.make();
    for (    IType type : getClasses((ICompilationUnit)elt)) {
      try {
        for (        IMethod m : type.getMethods()) {
          result.add(m);
        }
      }
 catch (      JavaModelException e) {
        e.printStackTrace();
      }
    }
    return result;
  }
 else {
    final Collection<IMethod> result=HashSetFactory.make();
    SearchPattern p=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.METHOD,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_PATTERN_MATCH);
    SearchPattern p2=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.CONSTRUCTOR,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_PATTERN_MATCH);
    IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{elt},IJavaSearchScope.SOURCES);
    SearchEngine engine=new SearchEngine();
    SearchRequestor requestor=new SearchRequestor(){
      @Override public void acceptSearchMatch(      SearchMatch match) throws CoreException {
        if (match.getElement() instanceof IMethod) {
          result.add((IMethod)match.getElement());
        }
      }
    }
;
    try {
      engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
      engine.search(p2,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
    return result;
  }
}",0.8765473402475744
40449,"@Override protected void propagate(T s_p,int i,T n,int j){
  super.propagate(s_p,i,n,j);
  if (isExitFromSeedMethod(n)) {
    for (Iterator<? extends T> it2=supergraph.getSuccNodes(n); it2.hasNext(); ) {
      T retSite=it2.next();
      PartiallyBalancedTabulationProblem<T,P> problem=(PartiallyBalancedTabulationProblem<T,P>)getProblem();
      IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(n,retSite);
      if (f instanceof IUnaryFlowFunction) {
        IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
        IntSet facts=uf.getTargets(j);
        if (facts != null) {
          for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
            int d3=it4.next();
            T fakeEntry=problem.getFakeEntry(retSite);
            PathEdge<T> seed=PathEdge.createPathEdge(fakeEntry,d3,retSite,d3);
            addSeed(seed);
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
    }
  }
}","@Override protected void propagate(T s_p,int i,T n,int j){
  super.propagate(s_p,i,n,j);
  if (wasUsedAsUnbalancedSeed(s_p,i) && supergraph.isExit(n)) {
    for (Iterator<? extends T> it2=supergraph.getSuccNodes(n); it2.hasNext(); ) {
      T retSite=it2.next();
      PartiallyBalancedTabulationProblem<T,P> problem=(PartiallyBalancedTabulationProblem<T,P>)getProblem();
      IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(n,retSite);
      if (f instanceof IUnaryFlowFunction) {
        IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
        IntSet facts=uf.getTargets(j);
        if (facts != null) {
          for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
            int d3=it4.next();
            T fakeEntry=problem.getFakeEntry(retSite);
            PathEdge<T> seed=PathEdge.createPathEdge(fakeEntry,d3,retSite,d3);
            addSeed(seed);
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
    }
  }
}",0.9700355510411376
40450,"@Override public void addSeed(PathEdge<T> seed){
  seedProcedures.add(getSupergraph().getProcOf(seed.entry));
  super.addSeed(seed);
}","@Override public void addSeed(PathEdge<T> seed){
  unbalancedSeeds.add(Pair.make(seed.entry,seed.d1));
  super.addSeed(seed);
}",0.7662835249042146
40451,"/** 
 * @param catchClasses Set of TypeReference
 * @param klass an Exception Class
 * @return true iff klass is a subclass of some element of the Set
 * @throws IllegalArgumentException if catchClasses is null
 */
public static boolean catches(Set<IClass> catchClasses,IClass klass,IClassHierarchy cha){
  if (catchClasses == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (catchClasses.size() == 1) {
    IClass c=catchClasses.iterator().next();
    if (c.getReference().equals(TypeReference.JavaLangThread)) {
      return true;
    }
  }
  for (  IClass c : catchClasses) {
    if (cha.isAssignableFrom(c,klass)) {
      return true;
    }
  }
  return false;
}","/** 
 * @param catchClasses Set of TypeReference
 * @param klass an Exception Class
 * @return true iff klass is a subclass of some element of the Set
 * @throws IllegalArgumentException if catchClasses is null
 */
public static boolean catches(Set<IClass> catchClasses,IClass klass,IClassHierarchy cha){
  if (catchClasses == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (catchClasses.size() == 1) {
    IClass c=catchClasses.iterator().next();
    if (c != null && c.getReference().equals(TypeReference.JavaLangThread)) {
      return true;
    }
  }
  for (  IClass c : catchClasses) {
    if (c != null && cha.isAssignableFrom(c,klass)) {
      return true;
    }
  }
  return false;
}",0.9816124469589816
40452,"/** 
 * Add constraints to represent the flow of exceptions to the exceptional return value for this node
 */
protected void addNodePassthruExceptionConstraints(CGNode node,IR ir){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,ir.getExitBlock());
  PointerKey exception=heapModel.getPointerKeyForExceptionalReturnValue(node);
  addExceptionDefConstraints(ir,node,peis,exception,PropagationCallGraphBuilder.THROWABLE_SET);
}","/** 
 * Add constraints to represent the flow of exceptions to the exceptional return value for this node
 */
protected void addNodePassthruExceptionConstraints(CGNode node,IR ir){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,ir.getExitBlock());
  PointerKey exception=heapModel.getPointerKeyForExceptionalReturnValue(node);
  IClass c=node.getClassHierarchy().lookupClass(TypeReference.JavaLangThrowable);
  addExceptionDefConstraints(ir,node,peis,exception,Collections.singleton(c));
}",0.8492307692307692
40453,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<IClass> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}",0.9953465589027676
40454,"@Override public void visitGetCaughtException(SSAGetCaughtExceptionInstruction instruction){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,getBasicBlock());
  PointerKey def=heapModel.getPointerKeyForLocal(node,instruction.getDef());
  Set<TypeReference> types=SSAPropagationCallGraphBuilder.getCaughtExceptionTypes(instruction,ir);
  addExceptionDefConstraints(ir,node,peis,def,types);
}","@Override public void visitGetCaughtException(SSAGetCaughtExceptionInstruction instruction){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,getBasicBlock());
  PointerKey def=heapModel.getPointerKeyForLocal(node,instruction.getDef());
  Set<IClass> types=SSAPropagationCallGraphBuilder.getCaughtExceptionTypes(instruction,ir);
  addExceptionDefConstraints(ir,node,peis,def,types);
}",0.9771908763505402
40455,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            g.addNode(exceptionVar);
            g.addNode(ik);
            g.addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<IClass> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            g.addNode(exceptionVar);
            g.addNode(ik);
            g.addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}",0.9953872299101724
40456,"protected TabulationCancelException(CancelException cause,Result r){
  super(cause);
  this.result=r;
}","protected TabulationCancelException(Exception cause,Result r){
  super(cause);
  this.result=r;
}",0.97
40457,"/** 
 * Solve the dataflow problem.
 * @return a representation of the result
 */
public TabulationResult<T,P> solve() throws CancelException {
  try {
    initialize();
    forwardTabulateSLRPs();
    Result r=new Result();
    return r;
  }
 catch (  CancelException e) {
    Result r=new Result();
    throw new TabulationCancelException(e,r);
  }
}","/** 
 * Solve the dataflow problem.
 * @return a representation of the result
 */
public TabulationResult<T,P> solve() throws CancelException {
  try {
    initialize();
    forwardTabulateSLRPs();
    Result r=new Result();
    return r;
  }
 catch (  CancelException e) {
    Result r=new Result();
    throw new TabulationCancelException(e,r);
  }
catch (  CancelRuntimeException e) {
    Result r=new Result();
    throw new TabulationCancelException(e,r);
  }
}",0.8606356968215159
40458,"@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        if (DEBUG_TOPLEVEL) {
          System.err.println(""String_Node_Str"" + s);
        }
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}","@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : getWrites(field,loadBase)) {
      Collection<Pair<PointerKey,PointerKey>> baseAndStoredPairs=getBaseAndStored(fieldWrite,field);
      if (baseAndStoredPairs == null) {
        continue;
      }
      for (      Pair<PointerKey,PointerKey> p : baseAndStoredPairs) {
        PointerKey base=p.fst;
        PointerKey stored=p.snd;
        Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,base);
        for (        State nextState : reachedFlowStates) {
          if (DEBUG_TOPLEVEL) {
            System.err.println(""String_Node_Str"" + base + ""String_Node_Str""+ nextState);
          }
          h.propagate(new PointerKeyAndState(stored,nextState));
        }
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}",0.7465388711395101
40459,"Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  arrayRef=convertToHeapModel(arrayRef,mam.getHeapModel());
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      SSANewInstruction n=(SSANewInstruction)instruction;
      InstanceKey iKey=heapModel.getInstanceKeyForAllocation(node,n.getNewSite());
      if (iKey == null) {
        continue;
      }
      IClass klass=iKey.getConcreteType();
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass.isArrayClass() && ((ArrayClass)klass).getElementClass().isArrayClass());
      }
      int dim=0;
      InstanceKey lastInstance=iKey;
      while (klass != null && klass.isArrayClass()) {
        klass=((ArrayClass)klass).getElementClass();
        if (klass != null && klass.isArrayClass()) {
          InstanceKey ik=heapModel.getInstanceKeyForMultiNewArray(node,n.getNewSite(),dim);
          PointerKey pk=heapModel.getPointerKeyForArrayContents(lastInstance);
          written.add(pk);
          lastInstance=ik;
          dim++;
        }
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}","Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  arrayRef=convertToHeapModel(arrayRef,mam.getHeapModel());
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      NewMultiDimInfo multiDimInfo=DemandPointerFlowGraph.getInfoForNewMultiDim((SSANewInstruction)instruction,heapModel,node);
      for (      Pair<PointerKey,PointerKey> arrStoreInstr : multiDimInfo.arrStoreInstrs) {
        written.add(arrStoreInstr.snd);
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}",0.6466866466866467
40460,"public int[] computeColumnWidths(){
  int[] result=new int[getNumberOfColumns()];
  for (int i=0; i < getNumberOfColumns(); i++) {
    result[i]=columnHeadings.get(i).toString().length() + 1;
  }
  for (int j=0; j < getNumberOfRows(); j++) {
    for (int i=0; i < getNumberOfColumns(); i++) {
      result[i]=Math.max(result[i],getElement(j,i).toString().length() + 1);
    }
  }
  return result;
}","public int[] computeColumnWidths(){
  int[] result=new int[getNumberOfColumns()];
  for (int i=0; i < getNumberOfColumns(); i++) {
    result[i]=columnHeadings.get(i).toString().length() + 1;
  }
  for (int j=0; j < getNumberOfRows(); j++) {
    for (int i=0; i < getNumberOfColumns(); i++) {
      T element=getElement(j,i);
      result[i]=element == null ? result[i] : Math.max(result[i],element.toString().length() + 1);
    }
  }
  return result;
}",0.8766157461809636
40461,"@Override public void visitAssignGlobal(AssignGlobalLabel label,Object dst){
  for (Iterator<? extends Object> readIter=g.getReadsOfStaticField((StaticFieldKey)dst); readIter.hasNext(); ) {
    final PointerKey predPk=(PointerKey)readIter.next();
    doTransition(curState,AssignGlobalBarLabel.v(),new Function<State,Object>(){
      public Object apply(      State predPkState){
        PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
        if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
          addToTrackedPToWorklist(predPkAndState);
        }
        return null;
      }
    }
);
  }
}","@Override public void visitAssignGlobal(AssignGlobalLabel label,Object dst){
  for (Iterator<? extends Object> writesToStaticField=g.getWritesToStaticField((StaticFieldKey)dst); writesToStaticField.hasNext(); ) {
    final PointerKey writtenPk=(PointerKey)writesToStaticField.next();
    doTransition(curState,label,new Function<State,Object>(){
      public Object apply(      State nextState){
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
        return null;
      }
    }
);
  }
}",0.629661751951431
40462,"@Override public void visitNew(NewLabel label,Object dst){
  final InstanceKey ik=(InstanceKey)dst;
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
  }
  doTransition(curState,label,new Function<State,Object>(){
    public Object apply(    State newState){
      InstanceKeyAndState ikAndState=new InstanceKeyAndState(ik,newState);
      int n=ikAndStates.add(ikAndState);
      findOrCreate(pkToP2Set,curPkAndState).add(n);
      addToPToWorklist(curPkAndState);
      return null;
    }
  }
);
}","@Override public void visitNew(NewLabel label,Object dst){
  final InstanceKey ik=(InstanceKey)dst;
  if (DEBUG_TOPLEVEL) {
    System.err.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
  }
  doTransition(curState,label,new Function<State,Object>(){
    public Object apply(    State newState){
      if (!pred.test(ik)) {
        foundBadInstanceKey=true;
      }
      return null;
    }
  }
);
}",0.7052631578947368
40463,"private Collection<IMethod> getOTFTargets(CallSiteAndCGNode callSiteAndCGNode,SSAAbstractInvokeInstruction[] callInstrs,State callerState){
  final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
  final CGNode caller=callSiteAndCGNode.getCGNode();
  Collection<IMethod> result=HashSetFactory.make();
  for (  SSAAbstractInvokeInstruction callInstr : callInstrs) {
    PointerKey thisArg=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(0));
    PointerKeyAndState thisArgAndState=new PointerKeyAndState(thisArg,callerState);
    OrdinalSet<InstanceKeyAndState> thisPToSet=getPToSetFromComputer(ptoComputer,thisArgAndState);
    for (    InstanceKeyAndState ikAndState : thisPToSet) {
      InstanceKey ik=ikAndState.getInstanceKey();
      IMethod targetMethod=options.getMethodTargetSelector().getCalleeTarget(caller,call,ik.getConcreteType());
      if (targetMethod == null) {
        continue;
      }
      result.add(targetMethod);
    }
  }
  return result;
}","private Collection<IMethod> getOTFTargets(CallSiteAndCGNode callSiteAndCGNode,SSAAbstractInvokeInstruction[] callInstrs,State callerState){
  if (DEBUG_TOPLEVEL) {
    System.err.println(""String_Node_Str"" + callSiteAndCGNode);
  }
  final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
  final CGNode caller=callSiteAndCGNode.getCGNode();
  Collection<IMethod> result=HashSetFactory.make();
  for (  SSAAbstractInvokeInstruction callInstr : callInstrs) {
    PointerKey thisArg=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(0));
    PointerKeyAndState thisArgAndState=new PointerKeyAndState(thisArg,callerState);
    OrdinalSet<InstanceKeyAndState> thisPToSet=getPToSetFromComputer(ptoComputer,thisArgAndState);
    for (    InstanceKeyAndState ikAndState : thisPToSet) {
      InstanceKey ik=ikAndState.getInstanceKey();
      IMethod targetMethod=options.getMethodTargetSelector().getCalleeTarget(caller,call,ik.getConcreteType());
      if (targetMethod == null) {
        continue;
      }
      result.add(targetMethod);
    }
  }
  return result;
}",0.9561022672455378
40464,"/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either {@link #forwInstKeyToFields} or {@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  State state=ikAndState.getState();
  if (Assertions.verifyAssertions) {
  }
  ikToFields.put(ikAndState,field);
  for (Iterator<? extends Object> iter=g.getPredNodes(ikAndState.getInstanceKey(),NewLabel.v()); iter.hasNext(); ) {
    PointerKey ikPred=(PointerKey)iter.next();
    PointerKeyAndState ikPredAndState=new PointerKeyAndState(ikPred,state);
    int mappedIndex=ikAndStates.getMappedIndex(ikAndState);
    if (Assertions.verifyAssertions) {
      Assertions._assert(mappedIndex != -1);
    }
    if (findOrCreate(pkToTrackedSet,ikPredAndState).add(mappedIndex)) {
      addToTrackedPToWorklist(ikPredAndState);
    }
  }
}","/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either {@link #forwInstKeyToFields} or {@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  if (Assertions.verifyAssertions) {
  }
  ikToFields.put(ikAndState,field);
  addPredsOfIKeyAndStateToTrackedPointsTo(ikAndState);
}",0.5996002664890073
40465,"@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=label.getField();
  PointerKey dstPtrKey=(PointerKey)dst;
  if (refineFieldAccesses(field,curPk,dstPtrKey,label.bar(),curState)) {
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      boolean needField=backInstKeyToFields.get(ikAndState).contains(field);
      PointerKeyAndState loadedVal=new PointerKeyAndState(dstPtrKey,curState);
      addEncounteredLoad(new LoadEdge(curPkAndState,field,loadedVal));
      if (needField) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedVal).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          addToTrackedPToWorklist(loadedVal);
        }
      }
    }
  }
}","@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        System.err.println(""String_Node_Str"" + s);
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}",0.1856444945509207
40466,"public Object apply(State nextState){
  propagate(new PointerKeyAndState(retVal,nextState));
  return null;
}","public Object apply(State nextState){
  h.propagate(new PointerKeyAndState(succPk,nextState));
  return null;
}",0.9363636363636364
40467,"private void computeFlowsTo(PointsToComputer ptoComputer,OrdinalSet<InstanceKeyAndState> basePToSet,IField field){
  for (  InstanceKeyAndState ikAndState : basePToSet) {
    ptoComputer.trackInstanceField(ikAndState,field,ptoComputer.forwInstKeyToFields);
  }
  ptoComputer.worklistLoop();
}","private void computeFlowsTo(PointsToComputer ptoComputer,OrdinalSet<InstanceKeyAndState> basePToSet){
}",0.5215189873417722
40468,"@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey predPk=(PointerKey)dst;
  doTransition(curState,AssignBarLabel.noFilter(),new Function<State,Object>(){
    public Object apply(    State predPkState){
      PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
      if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
        addToTrackedPToWorklist(predPkAndState);
      }
      return null;
    }
  }
);
}","@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey succPk=(PointerKey)dst;
  doTransition(curState,label,new Function<State,Object>(){
    public Object apply(    State nextState){
      h.propagate(new PointerKeyAndState(succPk,nextState));
      return null;
    }
  }
);
}",0.4408060453400503
40469,"@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        System.err.println(""String_Node_Str"" + s);
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}","@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        if (DEBUG_TOPLEVEL) {
          System.err.println(""String_Node_Str"" + s);
        }
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}",0.988929889298893
40470,"public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      if (!basePointerOkay) {
      }
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk),AssignLabel.noFilter())) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + loadEdge);
        }
        addToPToWorklist(loadedValAndState);
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}","public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      if (!basePointerOkay) {
      }
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadedValAndState.getState())) {
        if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk),AssignLabel.noFilter())) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + loadEdge);
          }
          addToPToWorklist(loadedValAndState);
        }
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}",0.973819830962688
40471,"private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
  }
  return added;
}","private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
    System.err.println(""String_Node_Str"" + pkAndState + ""String_Node_Str"");
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(vals)) {
      System.err.println(ikAndState);
    }
    System.err.println(""String_Node_Str"");
  }
  return added;
}",0.8642981945253349
40472,"/** 
 * Compute an analysis scope for the current selection
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(IStructuredSelection selection) throws JavaModelException, IOException {
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(ResourcesPlugin.getWorkspace().getRoot().getLocation(),jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}","/** 
 * Compute an analysis scope for the current selection
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(IStructuredSelection selection) throws JavaModelException, IOException {
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}",0.9629629629629628
40473,"protected EclipseProjectPath(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
}","protected EclipseProjectPath(IJavaProject project) throws JavaModelException, IOException {
}",0.8857142857142857
40474,"public static EclipseProjectPath make(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
  if (workspaceRootPath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new EclipseProjectPath(workspaceRootPath,project);
}","public static EclipseProjectPath make(IJavaProject project) throws JavaModelException, IOException {
  return new EclipseProjectPath(project);
}",0.6728971962616822
40475,"protected IPath makeAbsolute(IPath p){
  if (p.toFile().exists()) {
    return p;
  }
  return workspaceRootPath.append(p);
}","protected IPath makeAbsolute(IPath p){
  if (p.toFile().exists()) {
    return p;
  }
  String projectName=p.segment(0);
  IJavaProject jp=JdtUtil.getJavaProject(projectName);
  if (jp != null) {
    if (jp.getProject().getRawLocation() != null) {
      return jp.getProject().getRawLocation().append(p.removeFirstSegments(1));
    }
 else {
      IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
      return workspaceRoot.getLocation().append(p);
    }
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"" + p);
    return null;
  }
}",0.3318777292576419
40476,"/** 
 * compute the analysis scope for a project in the current workspace
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(String projectName) throws JavaModelException, IOException {
  IJavaProject jp=getProjectFromWorkspace(projectName);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  EclipseProjectPath path=EclipseProjectPath.make(workspaceRoot.getLocation(),jp);
  return path.toAnalysisScope(null);
}","/** 
 * compute the analysis scope for a project in the current workspace
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(String projectName) throws JavaModelException, IOException {
  IJavaProject jp=getProjectFromWorkspace(projectName);
  EclipseProjectPath path=EclipseProjectPath.make(jp);
  return path.toAnalysisScope(null);
}",0.715765247410817
40477,"private IMethod makeUnaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9459962756052142
40478,"private IMethod makeNullaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(""String_Node_Str""));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(""String_Node_Str""));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9619921363040628
40479,"private IMethod makeUnaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9548989113530326
40480,"private IMethod makeArrayLengthConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeArrayLengthConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9186535764375876
40481,"private IMethod makeNullaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(0.0));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(0.0));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9605442176870748
40482,"private IMethod makeNullaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9305666400638468
40483,"private IMethod makeNullaryValueConstructor(IClass cls,Object value){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.addConstant(new Integer(8),new ConstantValue(value));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",8));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryValueConstructor(IClass cls,Object value){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.getNextProgramCounter();
  S.addConstant(new Integer(8),new ConstantValue(value));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",8));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.925545571245186
40484,"private IMethod makeUnaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9459962756052142
40485,"private IMethod makeUnaryValueConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryValueConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9178470254957508
40486,"private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(new JavaScriptStaticPropertyRead(nargs + 4,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(new JavaScriptInvoke(1,nargs + 7,args,nargs + 8,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 7,false));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 5,false));
  return record(key,new JavaScriptConstructor(ref,S,cls));
}","private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(new JavaScriptStaticPropertyRead(nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(new JavaScriptInvoke(1,nargs + 7,args,nargs + 8,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls));
}",0.949740034662045
40487,"private IMethod makeArrayContentsConstructor(IClass cls,int nargs){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addConstant(new Integer(nargs + 3),new ConstantValue(""String_Node_Str""));
  S.addStatement(new JavaScriptPropertyRead(nargs + 4,1,nargs + 3));
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  S.addConstant(new Integer(nargs + 7),new ConstantValue(nargs));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 7));
  int vn=nargs + 9;
  for (int i=0; i < nargs; i++, vn+=2) {
    S.addConstant(new Integer(vn),new ConstantValue(i));
    S.addStatement(new JavaScriptPropertyWrite(nargs + 5,vn,i + 1));
  }
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeArrayContentsConstructor(IClass cls,int nargs){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addConstant(new Integer(nargs + 3),new ConstantValue(""String_Node_Str""));
  S.addStatement(new JavaScriptPropertyRead(nargs + 4,1,nargs + 3));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  S.getNextProgramCounter();
  S.addConstant(new Integer(nargs + 7),new ConstantValue(nargs));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 7));
  S.getNextProgramCounter();
  int vn=nargs + 9;
  for (int i=0; i < nargs; i++, vn+=2) {
    S.addConstant(new Integer(vn),new ConstantValue(i));
    S.addStatement(new JavaScriptPropertyWrite(nargs + 5,vn,i + 1));
    S.getNextProgramCounter();
  }
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.934228187919463
40488,"private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  while (s.available() > 0) {
    byte[] data=new byte[s.available()];
    int nRead=s.read(data);
    b.write(data,0,nRead);
  }
}","private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}",0.8831683168316832
40489,"private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  while (s.available() > 0) {
    byte[] data=new byte[s.available()];
    s.read(data);
    p.print(new String(data));
  }
}","private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}",0.8752642706131079
40490,"/** 
 * @return the IClass that represents the array element type, or null if theelement type is a primitive
 */
public IClass getElementClass(){
  TypeReference elementType=getReference().getArrayElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}","/** 
 * @return the IClass that represents the array element type, or null if the element type is a primitive
 */
public IClass getElementClass(){
  TypeReference elementType=getReference().getArrayElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}",0.998463901689708
40491,"/** 
 * @return the IClass that represents the innermost array element type, ornull if the element type is a primitive
 */
public IClass getInnermostElementClass(){
  TypeReference elementType=getReference().getInnermostElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}","/** 
 * @return the IClass that represents the innermost array element type, or null if the element type is a primitive
 */
public IClass getInnermostElementClass(){
  TypeReference elementType=getReference().getInnermostElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}",0.9985652797704448
40492,"public Collection<IClass> getAllImplementedInterfaces(){
  HashSet<IClass> result=HashSetFactory.make(2);
  result.add(loader.lookupClass(TypeReference.array_interfaces[0]));
  result.add(loader.lookupClass(TypeReference.array_interfaces[1]));
  return result;
}","public Collection<IClass> getAllImplementedInterfaces(){
  HashSet<IClass> result=HashSetFactory.make(2);
  IClass klass=loader.lookupClass(TypeReference.array_interfaces[0]);
  if (klass != null) {
    result.add(klass);
  }
  klass=loader.lookupClass(TypeReference.array_interfaces[1]);
  if (klass != null) {
    result.add(klass);
  }
  return result;
}",0.6946688206785138
40493,"public Iterator<? extends T> getReturnSites(T c){
  return delegate.getCallSites(c);
}","public Iterator<? extends T> getReturnSites(T c,P callee){
  return delegate.getCallSites(c,callee);
}",0.9148936170212766
40494,"public Iterator<? extends T> getCallSites(T r){
  return delegate.getReturnSites(r);
}","public Iterator<? extends T> getCallSites(T r,P callee){
  return delegate.getReturnSites(r,callee);
}",0.9148936170212766
40495,"/** 
 * @return the blocks in the supergraph that represents exit nodes forprocedure p
 */
T[] getExitsForProcedure(P procedure);","/** 
 * @return the blocks in the supergraph that represents exit nodes for procedure p
 */
T[] getExitsForProcedure(P procedure);",0.996138996138996
40496,"/** 
 * @param call a ""call"" node in the supergraph
 * @return an Iterator of nodes that are normal (non-call) successors of thiscall. This should only apply to backwards problems, where we might have, say, a call and a goto flow into a return site.
 */
Iterator<T> getNormalSuccessors(T call);","/** 
 * @param call a ""call"" node in the supergraph
 * @return an Iterator of nodes that are normal (non-call) successors of this call. This should only apply tobackwards problems, where we might have, say, a call and a goto flow into a return site.
 */
Iterator<T> getNormalSuccessors(T call);",0.9965986394557824
40497,"/** 
 * @param call a ""call"" node in the supergraph
 * @return the corresponding return nodes. There may be many, because ofexceptional control flow.
 */
Iterator<? extends T> getReturnSites(T call);","/** 
 * @param call a ""call"" node in the supergraph
 * @param callee a ""called"" ""procedure"" in the supergraph.  if callee is null, answer return sites for which no callee was found.
 * @return the corresponding return nodes. There may be many, because of exceptional control flow.
 */
Iterator<? extends T> getReturnSites(T call,P callee);",0.7397769516728625
40498,"/** 
 * @param r a ""return"" node in the supergraph
 * @return the corresponding call nodes. There may be many.
 */
Iterator<? extends T> getCallSites(T r);","/** 
 * @param r a ""return"" node in the supergraph
 * @param callee a ""called"" ""procedure"" in the supergraph.  if callee is null, answer return sites for which no callee was found.
 * @return the corresponding call nodes. There may be many.
 */
Iterator<? extends T> getCallSites(T ret,P callee);",0.6873614190687362
40499,"/** 
 * @return the blocks in the supergraph that represents entry nodes forprocedure p
 */
T[] getEntriesForProcedure(P procedure);","/** 
 * @return the blocks in the supergraph that represents entry nodes for procedure p
 */
T[] getEntriesForProcedure(P procedure);",0.9962264150943396
40500,"@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getReturnSites(Object object){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getReturnSites((BasicBlockInContext)object);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedExit(n));
  }
}","@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getReturnSites(Object object,CGNode callee){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getReturnSites((BasicBlockInContext)object);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedExit(n));
  }
}",0.9819121447028424
40501,"/** 
 * This could be done more efficiently.
 */
private void computeTransverseEdges(){
  for (  BasicBlockInContext<ISSABasicBlock> bb : partialIPFG) {
    if (partialIPFG.hasCall(bb)) {
      Set targets=partialIPFG.getCallTargets(bb);
      for (Iterator it2=targets.iterator(); it2.hasNext(); ) {
        CGNode n=(CGNode)it2.next();
        if (!noCollapse.contains(n)) {
          Object s_n=nodeManager.getCollapsedEntry(n);
          Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,s_n);
          incoming.add(bb);
          Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,bb);
          outgoing.add(s_n);
          Object e_n=nodeManager.getCollapsedExit(n);
          for (Iterator returnSites=getReturnSites(bb); returnSites.hasNext(); ) {
            Object ret=returnSites.next();
            Set<Object> in=MapUtil.findOrCreateSet(incomingTransverseEdges,ret);
            in.add(e_n);
            Set<Object> out=MapUtil.findOrCreateSet(outgoingTransverseEdges,e_n);
            out.add(ret);
          }
        }
      }
    }
  }
  for (Iterator it=nodeManager.iterateCollapsedNodes(); it.hasNext(); ) {
    Object n=it.next();
    if (!nodeManager.isCollapsedEntry(n)) {
      continue;
    }
    CGNode node=nodeManager.getProcOfCollapsedNode(n);
    for (Iterator it2=cg.getSuccNodes(node); it2.hasNext(); ) {
      CGNode outNode=(CGNode)it2.next();
      if (noCollapse.contains(outNode)) {
        ControlFlowGraph<ISSABasicBlock> cfg=partialIPFG.getCFG(outNode);
        BasicBlockInContext<ISSABasicBlock> entry=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.entry());
        Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,entry);
        incoming.add(n);
        Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,n);
        outgoing.add(entry);
        BasicBlockInContext<ISSABasicBlock> exit=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.exit());
        Object retSite=nodeManager.getCollapsedExit(node);
        incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,retSite);
        incoming.add(exit);
        outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,exit);
        outgoing.add(retSite);
      }
    }
  }
}","/** 
 * This could be done more efficiently.
 */
private void computeTransverseEdges(){
  for (  BasicBlockInContext<ISSABasicBlock> bb : partialIPFG) {
    if (partialIPFG.hasCall(bb)) {
      Set targets=partialIPFG.getCallTargets(bb);
      for (Iterator it2=targets.iterator(); it2.hasNext(); ) {
        CGNode n=(CGNode)it2.next();
        if (!noCollapse.contains(n)) {
          Object s_n=nodeManager.getCollapsedEntry(n);
          Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,s_n);
          incoming.add(bb);
          Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,bb);
          outgoing.add(s_n);
          Object e_n=nodeManager.getCollapsedExit(n);
          for (Iterator returnSites=getReturnSites(bb,n); returnSites.hasNext(); ) {
            Object ret=returnSites.next();
            Set<Object> in=MapUtil.findOrCreateSet(incomingTransverseEdges,ret);
            in.add(e_n);
            Set<Object> out=MapUtil.findOrCreateSet(outgoingTransverseEdges,e_n);
            out.add(ret);
          }
        }
      }
    }
  }
  for (Iterator it=nodeManager.iterateCollapsedNodes(); it.hasNext(); ) {
    Object n=it.next();
    if (!nodeManager.isCollapsedEntry(n)) {
      continue;
    }
    CGNode node=nodeManager.getProcOfCollapsedNode(n);
    for (Iterator it2=cg.getSuccNodes(node); it2.hasNext(); ) {
      CGNode outNode=(CGNode)it2.next();
      if (noCollapse.contains(outNode)) {
        ControlFlowGraph<ISSABasicBlock> cfg=partialIPFG.getCFG(outNode);
        BasicBlockInContext<ISSABasicBlock> entry=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.entry());
        Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,entry);
        incoming.add(n);
        Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,n);
        outgoing.add(entry);
        BasicBlockInContext<ISSABasicBlock> exit=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.exit());
        Object retSite=nodeManager.getCollapsedExit(node);
        incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,retSite);
        incoming.add(exit);
        outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,exit);
        outgoing.add(retSite);
      }
    }
  }
}",0.9995573262505534
40502,"@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getSuccNodes(Object N){
  if (N instanceof IBasicBlock) {
    Set<Object> xverse=outgoingTransverseEdges.get(N);
    if (xverse == null) {
      return partialIPFG.getSuccNodes((BasicBlockInContext)N);
    }
 else {
      return new CompoundIterator<Object>(partialIPFG.getSuccNodes((BasicBlockInContext)N),xverse.iterator());
    }
  }
 else {
    if (isEntry(N)) {
      Set<Object> result=HashSetFactory.make(4);
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      for (Iterator it=cg.getSuccNodes(n); it.hasNext(); ) {
        CGNode s=(CGNode)it.next();
        if (!noCollapse.contains(s)) {
          result.add(nodeManager.getCollapsedEntry(s));
        }
      }
      result.add(nodeManager.getCollapsedExit(n));
      Set<Object> xverse=outgoingTransverseEdges.get(N);
      if (xverse != null) {
        result.addAll(xverse);
      }
      return result.iterator();
    }
 else {
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      Object entry=nodeManager.getCollapsedEntry(n);
      HashSet<Object> result=HashSetFactory.make(4);
      for (Iterator it=getPredNodes(entry); it.hasNext(); ) {
        Object callSite=it.next();
        for (Iterator returnSites=getReturnSites(callSite); returnSites.hasNext(); ) {
          result.add(returnSites.next());
        }
      }
      return result.iterator();
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getSuccNodes(Object N){
  if (N instanceof IBasicBlock) {
    Set<Object> xverse=outgoingTransverseEdges.get(N);
    if (xverse == null) {
      return partialIPFG.getSuccNodes((BasicBlockInContext)N);
    }
 else {
      return new CompoundIterator<Object>(partialIPFG.getSuccNodes((BasicBlockInContext)N),xverse.iterator());
    }
  }
 else {
    if (isEntry(N)) {
      Set<Object> result=HashSetFactory.make(4);
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      for (Iterator it=cg.getSuccNodes(n); it.hasNext(); ) {
        CGNode s=(CGNode)it.next();
        if (!noCollapse.contains(s)) {
          result.add(nodeManager.getCollapsedEntry(s));
        }
      }
      result.add(nodeManager.getCollapsedExit(n));
      Set<Object> xverse=outgoingTransverseEdges.get(N);
      if (xverse != null) {
        result.addAll(xverse);
      }
      return result.iterator();
    }
 else {
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      Object entry=nodeManager.getCollapsedEntry(n);
      HashSet<Object> result=HashSetFactory.make(4);
      for (Iterator it=getPredNodes(entry); it.hasNext(); ) {
        Object callSite=it.next();
        for (Iterator returnSites=getReturnSites(callSite,n); returnSites.hasNext(); ) {
          result.add(returnSites.next());
        }
      }
      return result.iterator();
    }
  }
}",0.9992957746478872
40503,"@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getCallSites(Object object){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getCallSites((BasicBlockInContext<ISSABasicBlock>)object);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedEntry(n));
  }
}","@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getCallSites(Object object,CGNode callee){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getCallSites((BasicBlockInContext<ISSABasicBlock>)object,callee);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedEntry(n));
  }
}",0.9739776951672864
40504,"/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          if (D5 != null) {
            D5.foreach(new IntSetAction(){
              public void act(              final int d5){
                for (int i=0; i < entries.length; i++) {
                  final T s_p=entries[i];
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + s_p);
                  }
                  IntSet D3=getInversePathEdges(s_p,c,d4);
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + D3);
                  }
                  if (D3 != null) {
                    D3.foreach(new IntSetAction(){
                      public void act(                      int d3){
                        propagate(s_p,d3,retSite,d5);
                      }
                    }
);
                  }
                }
              }
            }
);
          }
        }
      }
;
      D4.foreach(action);
    }
  }
}","/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          if (D5 != null) {
            D5.foreach(new IntSetAction(){
              public void act(              final int d5){
                for (int i=0; i < entries.length; i++) {
                  final T s_p=entries[i];
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + s_p);
                  }
                  IntSet D3=getInversePathEdges(s_p,c,d4);
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + D3);
                  }
                  if (D3 != null) {
                    D3.foreach(new IntSetAction(){
                      public void act(                      int d3){
                        propagate(s_p,d3,retSite,d5);
                      }
                    }
);
                  }
                }
              }
            }
);
          }
        }
      }
;
      D4.foreach(action);
    }
  }
}",0.9939501779359432
40505,"/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge<T> edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.target);
  final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.target));
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.target); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    MutableSparseIntSet reached=MutableSparseIntSet.makeEmpty();
    for (    final T returnSite : returnSites) {
      IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,returnSite);
      IntSet r=computeFlow(edge.d2,f);
      if (r != null) {
        reached.addAll(r);
      }
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,null);
    IntSet r=computeFlow(edge.d2,f);
    if (r != null) {
      reached.addAll(r);
    }
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.target,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final IntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final IntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.target); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.target,m);
    IntSet D3=computeFlow(edge.d2,f);
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.entry,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : returnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (hasCallee(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.target,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.target,returnSite);
    }
    IntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.entry,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}","/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge<T> edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.target);
  Collection<T> allReturnSites=HashSetFactory.make();
  allReturnSites.addAll(Iterator2Collection.toCollection(supergraph.getReturnSites(edge.target,null)));
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.target); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    MutableSparseIntSet reached=MutableSparseIntSet.makeEmpty();
    final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.target,supergraph.getProcOf(callee)));
    allReturnSites.addAll(returnSites);
    for (    final T returnSite : returnSites) {
      IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,returnSite);
      IntSet r=computeFlow(edge.d2,f);
      if (r != null) {
        reached.addAll(r);
      }
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,null);
    IntSet r=computeFlow(edge.d2,f);
    if (r != null) {
      reached.addAll(r);
    }
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.target,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final IntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final IntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.target); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.target,m);
    IntSet D3=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + D3);
    }
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.entry,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : allReturnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (hasCallee(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.target,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.target,returnSite);
    }
    IntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.entry,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}",0.9689172692271576
40506,"/** 
 * A debugging aid. TODO: move this elsewhere
 */
public static void clearSoftCaches(){
  float occupancy=1f - ((float)Runtime.getRuntime().freeMemory() / (float)Runtime.getRuntime().totalMemory());
  if (occupancy < OCCUPANCY_TRIGGER) {
    return;
  }
  if (getAnalysisCache() != null) {
    getAnalysisCache().getSSACache().wipe();
    getAnalysisCache().getCFGCache().wipe();
  }
  IClassHierarchy cha=getClassHierarchy();
  if (cha != null) {
    for (    IClass klass : cha) {
      if (klass instanceof ShrikeClass) {
        ShrikeClass c=(ShrikeClass)klass;
        c.clearSoftCaches();
      }
 else {
        for (Iterator it2=klass.getDeclaredMethods().iterator(); it2.hasNext(); ) {
          IMethod m=(IMethod)it2.next();
          if (m instanceof ShrikeCTMethod) {
            ((ShrikeCTMethod)m).clearCaches();
          }
        }
      }
    }
  }
}","/** 
 * A debugging aid. TODO: move this elsewhere
 */
public static void clearSoftCaches(){
  float occupancy=1f - ((float)Runtime.getRuntime().freeMemory() / (float)Runtime.getRuntime().totalMemory());
  if (occupancy < OCCUPANCY_TRIGGER) {
    return;
  }
  AnalysisCache cache=getAnalysisCache();
  if (cache != null) {
    cache.getSSACache().wipe();
    cache.getCFGCache().wipe();
  }
  IClassHierarchy cha=getClassHierarchy();
  if (cha != null) {
    for (    IClass klass : cha) {
      if (klass instanceof ShrikeClass) {
        ShrikeClass c=(ShrikeClass)klass;
        c.clearSoftCaches();
      }
 else {
        for (Iterator it2=klass.getDeclaredMethods().iterator(); it2.hasNext(); ) {
          IMethod m=(IMethod)it2.next();
          if (m instanceof ShrikeCTMethod) {
            ((ShrikeCTMethod)m).clearCaches();
          }
        }
      }
    }
  }
}",0.9469480889903024
40507,"Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      SSANewInstruction n=(SSANewInstruction)instruction;
      InstanceKey iKey=heapModel.getInstanceKeyForAllocation(node,n.getNewSite());
      IClass klass=iKey.getConcreteType();
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass.isArrayClass() && ((ArrayClass)klass).getElementClass().isArrayClass());
      }
      int dim=0;
      InstanceKey lastInstance=iKey;
      while (klass != null && klass.isArrayClass()) {
        klass=((ArrayClass)klass).getElementClass();
        if (klass != null && klass.isArrayClass()) {
          InstanceKey ik=heapModel.getInstanceKeyForMultiNewArray(node,n.getNewSite(),dim);
          PointerKey pk=heapModel.getPointerKeyForArrayContents(lastInstance);
          written.add(pk);
          lastInstance=ik;
          dim++;
        }
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}","Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      SSANewInstruction n=(SSANewInstruction)instruction;
      InstanceKey iKey=heapModel.getInstanceKeyForAllocation(node,n.getNewSite());
      if (iKey == null) {
        continue;
      }
      IClass klass=iKey.getConcreteType();
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass.isArrayClass() && ((ArrayClass)klass).getElementClass().isArrayClass());
      }
      int dim=0;
      InstanceKey lastInstance=iKey;
      while (klass != null && klass.isArrayClass()) {
        klass=((ArrayClass)klass).getElementClass();
        if (klass != null && klass.isArrayClass()) {
          InstanceKey ik=heapModel.getInstanceKeyForMultiNewArray(node,n.getNewSite(),dim);
          PointerKey pk=heapModel.getPointerKeyForArrayContents(lastInstance);
          written.add(pk);
          lastInstance=ik;
          dim++;
        }
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}",0.9848308051341892
40508,"public Iterator<PointerKey> getWritesToInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayWrites(pk);
  }
  Collection<MemoryAccess> writes=mam.getFieldWrites(pk,f);
  for (  MemoryAccess a : writes) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : writes) {
    IR ir=a.getNode().getIR();
    SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[a.getInstructionIndex()];
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getVal());
    written.add(r);
  }
  return written.iterator();
}","public Iterator<PointerKey> getWritesToInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayWrites(pk);
  }
  Collection<MemoryAccess> writes=mam.getFieldWrites(pk,f);
  for (  MemoryAccess a : writes) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : writes) {
    IR ir=a.getNode().getIR();
    SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[a.getInstructionIndex()];
    if (s == null) {
      continue;
    }
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getVal());
    written.add(r);
  }
  return written.iterator();
}",0.9668976135488836
40509,"/** 
 * Check to see if a particular call site should be bypassed, before checking normal resolution of the receiver.
 * @throws IllegalArgumentException if site is null
 */
public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass dispatchType){
  if (site == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MethodReference ref=site.getDeclaredTarget();
  IMethod resolved=null;
  if (ClassHierarchyMethodTargetSelector.feasibleChaResolution(cha,site,dispatchType)) {
    if (site.isVirtual() || site.isInterface()) {
      if (dispatchType != null) {
        resolved=cha.resolveMethod(dispatchType,ref.getSelector());
      }
    }
 else {
      IClass computedDispatchType=cha.lookupClass(site.getDeclaredTarget().getDeclaringClass());
      if (computedDispatchType != null) {
        resolved=cha.resolveMethod(computedDispatchType,ref.getSelector());
      }
    }
  }
  IMethod target=(resolved == null) ? findOrCreateSyntheticMethod(ref,site.isStatic()) : getBypassInternal(resolved,site.isStatic());
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + target);
  }
  if (target != null) {
    return target;
  }
 else {
    if (canIgnore(site.getDeclaredTarget())) {
      if (DEBUG)       System.err.println(""String_Node_Str"" + site);
      return null;
    }
    target=parent.getCalleeTarget(caller,site,dispatchType);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + target);
    }
    if (target != null) {
      IMethod bypassTarget=getBypassInternal(target,site.isStatic());
      if (DEBUG)       System.err.println(""String_Node_Str"" + target);
      return (bypassTarget == null) ? target : bypassTarget;
    }
 else     return target;
  }
}","/** 
 * Check to see if a particular call site should be bypassed, before checking normal resolution of the receiver.
 * @throws IllegalArgumentException if site is null
 */
public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass dispatchType){
  if (site == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MethodReference ref=site.getDeclaredTarget();
  IMethod resolved=null;
  if (ClassHierarchyMethodTargetSelector.feasibleChaResolution(cha,site,dispatchType)) {
    if (site.isVirtual() || site.isInterface()) {
      if (dispatchType != null) {
        resolved=cha.resolveMethod(dispatchType,ref.getSelector());
      }
    }
 else {
      IClass computedDispatchType=cha.lookupClass(site.getDeclaredTarget().getDeclaringClass());
      if (computedDispatchType != null) {
        resolved=cha.resolveMethod(computedDispatchType,ref.getSelector());
      }
    }
  }
  IMethod target=(resolved == null) ? findOrCreateSyntheticMethod(ref,site.isStatic()) : getBypassInternal(resolved,site.isStatic());
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + target);
  }
  if (target != null) {
    return target;
  }
 else {
    if (canIgnore(site.getDeclaredTarget())) {
      return findOrCreateSyntheticMethod(site.getDeclaredTarget(),site.isStatic());
    }
    target=parent.getCalleeTarget(caller,site,dispatchType);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + target);
    }
    if (target != null) {
      IMethod bypassTarget=getBypassInternal(target,site.isStatic());
      if (DEBUG)       System.err.println(""String_Node_Str"" + target);
      return (bypassTarget == null) ? target : bypassTarget;
    }
 else     return target;
  }
}",0.8516579406631762
40510,"private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  T current=Q.get(0);
  visitChildren(current);
}","private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  if (Q.size() > 0) {
    T current=Q.get(0);
    visitChildren(current);
  }
}",0.9420289855072465
40511,"public Iterator<PointerKey> getReadsOfInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayReads(pk);
  }
  Collection<MemoryAccess> reads=mam.getFieldReads(pk,f);
  for (  MemoryAccess a : reads) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> readInto=new ArrayList<PointerKey>();
  for (  MemoryAccess a : reads) {
    IR ir=a.getNode().getIR();
    SSAGetInstruction s=(SSAGetInstruction)ir.getInstructions()[a.getInstructionIndex()];
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    readInto.add(r);
  }
  return readInto.iterator();
}","public Iterator<PointerKey> getReadsOfInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayReads(pk);
  }
  Collection<MemoryAccess> reads=mam.getFieldReads(pk,f);
  for (  MemoryAccess a : reads) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> readInto=new ArrayList<PointerKey>();
  for (  MemoryAccess a : reads) {
    IR ir=a.getNode().getIR();
    SSAGetInstruction s=(SSAGetInstruction)ir.getInstructions()[a.getInstructionIndex()];
    if (s == null) {
      continue;
    }
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    readInto.add(r);
  }
  return readInto.iterator();
}",0.9667440061871616
40512,"protected Iterator<PointerKey> getArrayReads(PointerKey arrayRef){
  Collection<MemoryAccess> arrayReads=mam.getArrayReads(arrayRef);
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> read=new ArrayList<PointerKey>();
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    IR ir=a.getNode().getIR();
    SSAArrayLoadInstruction s=(SSAArrayLoadInstruction)ir.getInstructions()[a.getInstructionIndex()];
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    read.add(r);
  }
  return read.iterator();
}","protected Iterator<PointerKey> getArrayReads(PointerKey arrayRef){
  Collection<MemoryAccess> arrayReads=mam.getArrayReads(arrayRef);
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> read=new ArrayList<PointerKey>();
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    IR ir=a.getNode().getIR();
    SSAArrayLoadInstruction s=(SSAArrayLoadInstruction)ir.getInstructions()[a.getInstructionIndex()];
    if (s == null) {
      continue;
    }
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    read.add(r);
  }
  return read.iterator();
}",0.9700348432055748
40513,"public void map(Object astType,CAstType castType){
  fMap.put(astType,castType);
}","@SuppressWarnings(""String_Node_Str"") public void map(Object astType,CAstType castType){
  fMap.put(astType,castType);
}",0.8159203980099502
40514,"@Override public int hashCode(){
  return method.hashCode();
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((declaringClass == null) ? 0 : declaringClass.hashCode());
  result=prime * result + ((method == null) ? 0 : method.hashCode());
  return result;
}",0.3192182410423452
40515,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    SyntheticMethod other=(SyntheticMethod)obj;
    return (method.equals(other.method));
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final SyntheticMethod other=(SyntheticMethod)obj;
  if (declaringClass == null) {
    if (other.declaringClass != null)     return false;
  }
 else   if (!declaringClass.equals(other.declaringClass))   return false;
  if (method == null) {
    if (other.method != null)     return false;
  }
 else   if (!method.equals(other.method))   return false;
  return true;
}",0.4151898734177215
40516,"@Override protected MachineState makeEdgeVariable(BasicBlock from,BasicBlock to){
  if (Assertions.verifyAssertions) {
    Assertions._assert(from != null);
    Assertions._assert(to != null);
  }
  MachineState result=new MachineState(71167 * (from.hashCode() + to.hashCode()),from);
  return result;
}","@Override protected MachineState makeEdgeVariable(BasicBlock from,BasicBlock to){
  if (Assertions.verifyAssertions) {
    Assertions._assert(from != null);
    Assertions._assert(to != null);
  }
  MachineState result=new MachineState(71167 * from.hashCode() + to.hashCode(),from);
  return result;
}",0.9966887417218544
40517,"protected void visitInvokeInternal(SSAAbstractInvokeInstruction instruction){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  if (instruction.getCallSite().isStatic()) {
    CGNode n=getTargetForCall(node,instruction.getCallSite(),(InstanceKey)null);
    if (n == null) {
      Warnings.add(ResolutionFailure.create(node,instruction));
    }
 else {
      getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    PointerKey receiver=getPointerKeyForLocal(instruction.getReceiver());
    if (contentsAreInvariant(symbolTable,du,instruction.getReceiver())) {
      system.recordImplicitPointsToSet(receiver);
      InstanceKey[] ik=getInvariantContents(instruction.getReceiver());
      for (int i=0; i < ik.length; i++) {
        system.findOrCreateIndexForInstanceKey(ik[i]);
        CGNode n=getTargetForCall(node,instruction.getCallSite(),ik[i]);
        if (n == null) {
          Warnings.add(ResolutionFailure.create(node,instruction));
        }
 else {
          getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
          processClassInitializer(n.getMethod().getDeclaringClass());
        }
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ receiver);
      }
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,computeInvariantParameters(instruction),uniqueCatch);
      system.newSideEffect(dispatchOperator,receiver);
    }
  }
}","protected void visitInvokeInternal(SSAAbstractInvokeInstruction instruction){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  if (instruction.getCallSite().isStatic()) {
    CGNode n=getTargetForCall(node,instruction.getCallSite(),(InstanceKey)null);
    if (n == null) {
      Warnings.add(ResolutionFailure.create(node,instruction.getCallSite()));
    }
 else {
      getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    PointerKey receiver=getPointerKeyForLocal(instruction.getReceiver());
    if (contentsAreInvariant(symbolTable,du,instruction.getReceiver())) {
      system.recordImplicitPointsToSet(receiver);
      InstanceKey[] ik=getInvariantContents(instruction.getReceiver());
      for (int i=0; i < ik.length; i++) {
        system.findOrCreateIndexForInstanceKey(ik[i]);
        CGNode n=getTargetForCall(node,instruction.getCallSite(),ik[i]);
        if (n == null) {
          Warnings.add(ResolutionFailure.create(node,instruction));
        }
 else {
          getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
          processClassInitializer(n.getMethod().getDeclaringClass());
        }
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ receiver);
      }
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,computeInvariantParameters(instruction),uniqueCatch);
      system.newSideEffect(dispatchOperator,receiver);
    }
  }
}",0.9963312368972748
40518,"/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir,Collection<SSAInstruction> visited){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s != null && !visited.contains(s)) {
      visited.add(s);
      if (s instanceof SSAPhiInstruction) {
        delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
      }
 else       if (s instanceof SSAGetCaughtExceptionInstruction) {
        delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
      }
 else       if (s instanceof SSAPiInstruction) {
        delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
      }
 else {
        Assertions.UNREACHABLE(s.toString());
      }
    }
  }
}","/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}",0.581913499344692
40519,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
}",0.8981191222570533
40520,"/** 
 * Create all nodes in this PDG. Each node is a Statement.
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions,IR ir){
  if (ir != null) {
    Collection<SSAInstruction> visited=createNormalStatements(ir,ref);
    createSpecialStatements(ir,visited);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}","/** 
 * Create all nodes in this PDG. Each node is a Statement.
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions,IR ir){
  if (ir != null) {
    createNormalStatements(ir,ref);
    createSpecialStatements(ir);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}",0.9519553072625698
40521,"private ResolutionFailure(CGNode node,Object ref){
  this(node,ref,null);
}","private ResolutionFailure(CGNode node,T ref){
  this(node,ref,null);
}",0.9517241379310344
40522,"@Override public int hashCode(){
  return getMethod().hashCode() * 8999 + ref.hashCode() * 8461 + getLevel();
}","@Override public int hashCode(){
  final int prime=31;
  int result=super.hashCode();
  result=prime * result + ((message == null) ? 0 : message.hashCode());
  result=prime * result + ((ref == null) ? 0 : ref.hashCode());
  return result;
}",0.4045584045584046
40523,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    ResolutionFailure other=(ResolutionFailure)obj;
    return (getMethod().equals(other.getMethod()) && getLevel() == other.getLevel() && ref.equals(other.ref));
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!super.equals(obj))   return false;
  if (getClass() != obj.getClass())   return false;
  final ResolutionFailure other=(ResolutionFailure)obj;
  if (message == null) {
    if (other.message != null)     return false;
  }
 else   if (!message.equals(other.message))   return false;
  if (ref == null) {
    if (other.ref != null)     return false;
  }
 else   if (!ref.equals(other.ref))   return false;
  return true;
}",0.2829736211031175
40524,"public static ResolutionFailure create(CGNode node,Object ref,String msg) throws IllegalArgumentException {
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new ResolutionFailure(node,ref,msg);
}","public static <T>ResolutionFailure create(CGNode node,T ref){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new ResolutionFailure<T>(node,ref);
}",0.859122401847575
40525,"/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i, r cis an interface that extends i.
 */
public boolean implementsInterface(IClass c,IClass i){
  if (!i.isInterface()) {
    return false;
  }
  Set impls=implementors.get(i);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}","/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i, r c is an interface that extends i.
 */
public boolean implementsInterface(IClass c,IClass i){
  if (!i.isInterface()) {
    return false;
  }
  if (c.equals(i)) {
    return true;
  }
  Set impls=implementors.get(i);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}",0.9434954007884364
40526,"/** 
 * Get the targets for a method ref invoked on a class klass. The klass had better not be an interface.
 * @param ref method to invoke
 * @param klass declaringClass of receiver
 * @return Set the set of method implementations that might receive themessage
 */
private Set<IMethod> computeTargetsNotInterface(MethodReference ref,IClass klass){
  Node n=findNode(klass);
  HashSet<IMethod> result=HashSetFactory.make(3);
  if (n == null)   return result;
  Selector selector=ref.getSelector();
  IMethod resolved=resolveMethod(klass,selector);
  if (resolved != null) {
    result.add(resolved);
  }
  result.addAll(computeOverriders(n,selector));
  return result;
}","/** 
 * Get the targets for a method ref invoked on a class klass. The klass had better not be an interface.
 * @param ref method to invoke
 * @param klass declaringClass of receiver
 * @return Set the set of method implementations that might receive the message
 */
private Set<IMethod> computeTargetsNotInterface(MethodReference ref,IClass klass){
  Node n=findNode(klass);
  HashSet<IMethod> result=HashSetFactory.make(3);
  if (n == null)   return result;
  Selector selector=ref.getSelector();
  IMethod resolved=resolveMethod(klass,selector);
  if (resolved != null) {
    result.add(resolved);
  }
  result.addAll(computeOverriders(n,selector));
  return result;
}",0.999254287844892
40527,"/** 
 * Is c a subclass of T?
 * @throws IllegalArgumentException if c is null
 */
public boolean isSubclassOf(IClass c,IClass T){
  if (c == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    Assertions._assert(T != null,""String_Node_Str"");
  }
  if (c.isArrayClass()) {
    if (T.getReference() == TypeReference.JavaLangObject) {
      return true;
    }
 else     if (T.getReference().isArrayType()) {
      TypeReference elementType=T.getReference().getArrayElementType();
      if (elementType.isPrimitiveType()) {
        return elementType.equals(c.getReference().getArrayElementType());
      }
 else {
        IClass elementKlass=lookupClass(elementType);
        if (elementKlass == null) {
          Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + elementType));
          return false;
        }
        IClass ce=((ArrayClass)c).getElementClass();
        if (ce == null) {
          return false;
        }
        return isSubclassOf(ce,elementKlass);
      }
    }
 else {
      return false;
    }
  }
 else {
    if (T.getReference().isArrayType()) {
      return false;
    }
    if (c.getReference().equals(T.getReference())) {
      return true;
    }
    Node n1=map.get(c);
    if (n1 == null) {
      return false;
    }
    Node n2=map.get(T);
    if (n2 == null) {
      return false;
    }
    if (n1.left == -1) {
      return slowIsSubclass(c,T);
    }
 else     if (n2.left == -1) {
      return slowIsSubclass(c,T);
    }
 else {
      return (n2.left <= n1.left) && (n1.left <= n2.right);
    }
  }
}","/** 
 * Is c a subclass of T?
 * @throws IllegalArgumentException if c is null
 */
public boolean isSubclassOf(IClass c,IClass T){
  if (c == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    Assertions._assert(T != null,""String_Node_Str"");
  }
  if (c.isArrayClass()) {
    if (T.getReference() == TypeReference.JavaLangObject) {
      return true;
    }
 else     if (T.getReference().isArrayType()) {
      TypeReference elementType=T.getReference().getArrayElementType();
      if (elementType.isPrimitiveType()) {
        return elementType.equals(c.getReference().getArrayElementType());
      }
 else {
        IClass elementKlass=lookupClass(elementType);
        if (elementKlass == null) {
          Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + elementType));
          return false;
        }
        IClass ce=((ArrayClass)c).getElementClass();
        if (ce == null) {
          return false;
        }
        if (elementKlass.isInterface()) {
          return implementsInterface(ce,elementKlass);
        }
 else {
          return isSubclassOf(ce,elementKlass);
        }
      }
    }
 else {
      return false;
    }
  }
 else {
    if (T.getReference().isArrayType()) {
      return false;
    }
    if (c.getReference().equals(T.getReference())) {
      return true;
    }
    Node n1=map.get(c);
    if (n1 == null) {
      return false;
    }
    Node n2=map.get(T);
    if (n2 == null) {
      return false;
    }
    if (n1.left == -1) {
      return slowIsSubclass(c,T);
    }
 else     if (n2.left == -1) {
      return slowIsSubclass(c,T);
    }
 else {
      return (n2.left <= n1.left) && (n1.left <= n2.right);
    }
  }
}",0.961987428913499
40528,"/** 
 * @return the canonical IField that represents a given field , or null ifnone found
 * @throws IllegalArgumentException if f is null
 * @throws IllegalArgumentException if klass is null
 */
public IField resolveField(IClass klass,FieldReference f){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return klass.getField(f.getName());
}","/** 
 * @return the canonical IField that represents a given field , or null if none found
 * @throws IllegalArgumentException if f is null
 * @throws IllegalArgumentException if klass is null
 */
public IField resolveField(IClass klass,FieldReference f){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return klass.getField(f.getName());
}",0.9989189189189188
40529,"private SSAInstruction[] makeStatements(JavaTypeContext context){
  ArrayList<SSAInstruction> statements=new ArrayList<SSAInstruction>();
  int nextLocal=1;
  int retValue=nextLocal++;
  TypeReference tr=context.getType().getTypeReference();
  if (tr != null) {
    SSALoadClassInstruction l=new SSALoadClassInstruction(retValue,tr);
    statements.add(l);
    SSAReturnInstruction R=new SSAReturnInstruction(retValue,false);
    statements.add(R);
  }
 else {
    SSAThrowInstruction t=new SSAThrowInstruction(retValue);
    statements.add(t);
  }
  SSAInstruction[] result=new SSAInstruction[statements.size()];
  Iterator<SSAInstruction> it=statements.iterator();
  for (int i=0; i < result.length; i++) {
    result[i]=it.next();
  }
  return result;
}","private SSAInstruction[] makeStatements(JavaTypeContext context){
  ArrayList<SSAInstruction> statements=new ArrayList<SSAInstruction>();
  int retValue=2;
  TypeReference tr=context.getType().getTypeReference();
  if (tr != null) {
    SSALoadClassInstruction l=new SSALoadClassInstruction(retValue,tr);
    statements.add(l);
    SSAReturnInstruction R=new SSAReturnInstruction(retValue,false);
    statements.add(R);
  }
 else {
    SSAThrowInstruction t=new SSAThrowInstruction(retValue);
    statements.add(t);
  }
  SSAInstruction[] result=new SSAInstruction[statements.size()];
  statements.toArray(result);
  return result;
}",0.8610511159107271
40530,"public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof JavaTypeContext))   return false;
  return node.getMethod().getReference().equals(CLASS_NEW_INSTANCE_REF);
}","public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof JavaTypeContext)) {
    return false;
  }
  return node.getMethod().getReference().equals(CLASS_NEW_INSTANCE_REF);
}",0.9854545454545456
40531,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.getReference().equals(ClassNewInstanceContextInterpreter.CLASS_NEW_INSTANCE_REF) && isTypeConstant(receiver)) {
    IClass c=(IClass)((ConstantKey)receiver).getValue();
    return new JavaTypeContext(new PointType(c));
  }
  return null;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.getReference().equals(ClassNewInstanceContextInterpreter.CLASS_NEW_INSTANCE_REF) && isTypeConstant(receiver)) {
    IClass c=(IClass)((ConstantKey)receiver).getValue();
    if (!c.isAbstract() && !c.isInterface()) {
      return new JavaTypeContext(new PointType(c));
    }
  }
  return null;
}",0.9286640726329444
40532,"/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
 else {
  }
}","/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
}",0.9917920656634748
40533,"private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || typesAllocated.contains(T)) {
      continue;
    }
    typesAllocated.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}","private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || klass.isInterface() || typesAllocated.contains(T)) {
      continue;
    }
    typesAllocated.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}",0.9915781764921274
40534,"/** 
 * Private constructor ... only for internal use.
 * @throws IllegalArgumentException if type is null
 */
public PointType(IClass type){
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.type=type;
  if (Assertions.verifyAssertions) {
    Assertions._assert(type.getReference().isReferenceType());
  }
}","/** 
 * Private constructor ... only for internal use.
 * @throws IllegalArgumentException if type is null
 */
public PointType(IClass type){
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.type=type;
  if (Assertions.verifyAssertions) {
    Assertions._assert(type.getReference().isReferenceType());
    Assertions._assert(!type.isInterface());
  }
}",0.9395973154362416
40535,"@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,other.getType())) {
          return other;
        }
      }
      return other.meet(new ConeType(other.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}","@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,other.getType())) {
          return other;
        }
      }
      return other.meet(new ConeType(this.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}",0.9964014394242304
40536,"/** 
 * TODO: clean this up. Create the IR for the synthetic method (e.g. Method.invoke)
 * @param method is something like Method.invoke or Construction.newInstance
 * @param target is the method being called reflectively
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int i=0;
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[i++]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    parametersVn=3;
    if (target.isStatic()) {
    }
 else {
      args[i++]=2;
    }
  }
  for (int j=i; j < nargs; j++) {
    int indexConst=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(args[i++]=nextLocal++,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    constants.put(new Integer(indexConst),new ConstantValue(j - 1));
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}","/** 
 * TODO: clean this up. Create the IR for the synthetic method (e.g. Method.invoke)
 * @param method is something like Method.invoke or Construction.newInstance
 * @param target is the method being called reflectively
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[0]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    parametersVn=3;
    if (target.isStatic()) {
    }
 else {
      args[0]=2;
    }
  }
  int nextArg=target.isStatic() ? 0 : 1;
  int nextParameter=0;
  for (int j=nextArg; j < nargs; j++) {
    int indexConst=nextLocal++;
    constants.put(new Integer(indexConst),new ConstantValue(nextParameter++));
    int temp=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(temp,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    pc++;
    args[j]=nextLocal++;
    TypeReference type=target.getParameterType(j);
    SSACheckCastInstruction cast=SSAInstructionFactory.CheckCastInstruction(args[j],temp,type);
    m.addInstruction(null,cast,false);
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}",0.9061837796185706
40537,"protected CGNode makeFakeRootNode(){
  return findOrCreateNode(new JSFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}","protected CGNode makeFakeRootNode() throws CancelException {
  return findOrCreateNode(new JSFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}",0.9183673469387756
40538,"/** 
 * Compute a set of <n, d1> pairs that represent return statement factoids that should be considered reached in a partially balanced parentheses tabulation. We assume that the given   {@link TabulationResult} represents a solution to a fully balanced tabulation. We look atany exit statements that were reached, and compute the corresponding return factoids that could be reached, if we ignored parentheses. We return the set of such factoids, which represent roots to restart tabulation with.
 */
public static <T,P>Collection<Pair<T,Integer>> computeNewSeeds(TabulationResult<T,P> tabulation,PartiallyBalancedTabulationProblem<T,P> problem){
  Collection<Pair<T,Integer>> result=HashSetFactory.make();
  ISupergraph<T,P> supergraph=tabulation.getProblem().getSupergraph();
  for (  PathEdge<T> entry : tabulation.getSeeds()) {
    for (    T exit : supergraph.getExitsForProcedure(supergraph.getProcOf(entry.getEntry()))) {
      IntSet reached=tabulation.getSummaryTargets(entry.getEntry(),entry.getD1(),exit);
      if (reached != null) {
        for (IntIterator it=reached.intIterator(); it.hasNext(); ) {
          int d2=it.next();
          for (Iterator<? extends T> it2=supergraph.getSuccNodes(exit); it2.hasNext(); ) {
            T retSite=it2.next();
            IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(exit,retSite);
            if (f instanceof IUnaryFlowFunction) {
              IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
              IntSet facts=uf.getTargets(d2);
              for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
                int d3=it4.next();
                result.add(Pair.make(retSite,d3));
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return result;
}","/** 
 * Compute a set of <n, d1> pairs that represent return statement factoids that should be considered reached in a partially balanced parentheses tabulation. We assume that the given   {@link TabulationResult} represents a solution to a fully balanced tabulation. We look atany exit statements that were reached, and compute the corresponding return factoids that could be reached, if we ignored parentheses. We return the set of such factoids, which represent roots to restart tabulation with.
 */
public static <T,P>Collection<Pair<T,Integer>> computeNewSeeds(TabulationResult<T,P> tabulation,PartiallyBalancedTabulationProblem<T,P> problem){
  Collection<Pair<T,Integer>> result=HashSetFactory.make();
  ISupergraph<T,P> supergraph=tabulation.getProblem().getSupergraph();
  for (  PathEdge<T> entry : tabulation.getSeeds()) {
    for (    T exit : supergraph.getExitsForProcedure(supergraph.getProcOf(entry.getEntry()))) {
      IntSet reached=tabulation.getSummaryTargets(entry.getEntry(),entry.getD1(),exit);
      if (reached != null) {
        for (IntIterator it=reached.intIterator(); it.hasNext(); ) {
          int d2=it.next();
          for (Iterator<? extends T> it2=supergraph.getSuccNodes(exit); it2.hasNext(); ) {
            T retSite=it2.next();
            IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(exit,retSite);
            if (f instanceof IUnaryFlowFunction) {
              IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
              IntSet facts=uf.getTargets(d2);
              if (facts != null) {
                for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
                  int d3=it4.next();
                  result.add(Pair.make(retSite,d3));
                }
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return result;
}",0.9843376692328112
40539,"protected CGNode makeFakeRootNode(){
  return findOrCreateNode(new AstFakeRoot(FakeRootMethod.rootMethod,cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}","protected CGNode makeFakeRootNode() throws CancelException {
  return findOrCreateNode(new AstFakeRoot(FakeRootMethod.rootMethod,cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}",0.9310344827586208
40540,"protected CGNode makeFakeRootNode(){
  return findOrCreateNode(new CrossLanguageFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}","protected CGNode makeFakeRootNode() throws CancelException {
  return findOrCreateNode(new CrossLanguageFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}",0.9240506329113924
40541,"@SuppressWarnings(""String_Node_Str"") public AbstractRootMethod getLanguageRoot(Atom language){
  if (!languageRoots.containsKey(language)) {
    AbstractRootMethod languageRoot=roots.get(language,this);
    CGNode languageRootNode=findOrCreateNode(languageRoot,Everywhere.EVERYWHERE);
    languageRootNodes.add(languageRootNode);
    CallSiteReference site=CallSiteReference.make(1,languageRoot.getReference(),IInvokeInstruction.Dispatch.STATIC);
    CGNode fakeRootNode=getFakeRootNode();
    CrossLanguageFakeRoot fakeRootMethod=(CrossLanguageFakeRoot)fakeRootNode.getMethod();
    site=fakeRootMethod.addInvocationInternal(new int[0],site).getCallSite();
    fakeRootNode.addTarget(site,languageRootNode);
    languageRoots.put(language,languageRoot);
  }
  return (AbstractRootMethod)languageRoots.get(language);
}","@SuppressWarnings(""String_Node_Str"") public AbstractRootMethod getLanguageRoot(Atom language){
  if (!languageRoots.containsKey(language)) {
    AbstractRootMethod languageRoot=roots.get(language,this);
    CGNode languageRootNode=null;
    try {
      languageRootNode=findOrCreateNode(languageRoot,Everywhere.EVERYWHERE);
    }
 catch (    CancelException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
    languageRootNodes.add(languageRootNode);
    CallSiteReference site=CallSiteReference.make(1,languageRoot.getReference(),IInvokeInstruction.Dispatch.STATIC);
    CGNode fakeRootNode=getFakeRootNode();
    CrossLanguageFakeRoot fakeRootMethod=(CrossLanguageFakeRoot)fakeRootNode.getMethod();
    site=fakeRootMethod.addInvocationInternal(new int[0],site).getCallSite();
    fakeRootNode.addTarget(site,languageRootNode);
    languageRoots.put(language,languageRoot);
  }
  return (AbstractRootMethod)languageRoots.get(language);
}",0.9196177627880832
40542,"/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  Collection<IClass> c=HashSetFactory.make();
  for (  IClass klass : klasses) {
    if (klass.isArrayClass()) {
      c.add(klass);
    }
 else     if (this.klasses.contains(klass)) {
      c.add(klass);
    }
  }
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(c);
  return result;
}","/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  Collection<IClass> c=HashSetFactory.make();
  for (  IClass klass : klasses) {
    if (klass.isArrayClass()) {
      TypeReference elementType=klass.getReference().getArrayElementType();
      if (elementType.isPrimitiveType()) {
        c.add(klass);
      }
 else {
        c.add(klass.getClassHierarchy().lookupClass(TypeReference.JavaLangObject.getArrayTypeForElementType()));
      }
    }
 else     if (this.klasses.contains(klass)) {
      c.add(klass);
    }
  }
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(c);
  return result;
}",0.8306288032454361
40543,"public static boolean isConcreteStrutsPlugIn(IClass klass){
  TypeReference plugInType=TypeReference.findOrCreate(ClassLoaderReference.Application,plugInName);
  IClass plugInClass=klass.getClassHierarchy().lookupClass(plugInType);
  if (klass.isAbstract()) {
    return false;
  }
  if (klass.getReference().equals(plugInType)) {
    return false;
  }
  if (klass.getClassHierarchy().isAssignableFrom(plugInClass,klass)) {
    return true;
  }
  return false;
}","public static boolean isConcreteStrutsPlugIn(IClass klass){
  TypeReference plugInType=TypeReference.findOrCreate(ClassLoaderReference.Application,plugInName);
  IClass plugInClass=klass.getClassHierarchy().lookupClass(plugInType);
  if (plugInClass == null) {
    return false;
  }
  if (klass.isAbstract()) {
    return false;
  }
  if (klass.getReference().equals(plugInType)) {
    return false;
  }
  if (klass.getClassHierarchy().isAssignableFrom(plugInClass,klass)) {
    return true;
  }
  return false;
}",0.9476923076923076
40544,"/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
@SuppressWarnings(""String_Node_Str"") private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,String fileExtension) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,fileExtension);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    File file=makeAbsolute(e.getPath()).toFile();
    Set<Module> s=MapUtil.findOrCreateSet(sourceModules,Loader.SOURCE);
    s.add(new SourceDirectoryTreeModule(file,fileExtension));
    if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,fileExtension);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
        s.add(new BinaryDirectoryTreeModule(output));
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
@SuppressWarnings(""String_Node_Str"") private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,String fileExtension) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,fileExtension);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    File file=makeAbsolute(e.getPath()).toFile();
    Set<Module> s=MapUtil.findOrCreateSet(sourceModules,Loader.SOURCE);
    s.add(new SourceDirectoryTreeModule(file,fileExtension));
    if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,fileExtension);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
        s.add(new BinaryDirectoryTreeModule(output));
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}",0.9886939571150096
40545,"protected void addCtorInvokeInstruction(final TypeReference T,int alloc){
  MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
  CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
  int[] params=new int[1];
  params[0]=alloc;
  int exc=getExceptionsForType(T);
  SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
  calls.add(s);
  allInstructions.add(s);
}","/** 
 * Add an instruction to invoke the default constructor on the object of value number alloc of type t.
 */
protected void addCtorInvokeInstruction(final TypeReference t,int alloc){
  MethodReference init=MethodReference.findOrCreate(t,MethodReference.initAtom,MethodReference.defaultInitDesc);
  CallSiteReference site=CallSiteReference.make(getCallSiteForType(t),init,IInvokeInstruction.Dispatch.SPECIAL);
  int[] params=new int[1];
  params[0]=alloc;
  int exc=getExceptionsForType(t);
  SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
  calls.add(s);
  allInstructions.add(s);
}",0.8905109489051095
40546,"/** 
 * @param T
 * @return value number of the newly allocated object
 */
protected int addStatementsForConcreteSimpleType(final TypeReference T){
}","/** 
 * @param t type of object to allocate
 * @return value number of the newly allocated object
 */
protected int addStatementsForConcreteSimpleType(final TypeReference t){
}",0.9046153846153846
40547,"/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
}","/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
 else {
  }
}",0.9917920656634748
40548,"/** 
 * TODO: clean this up.
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int i=0;
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[i++]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    args[i++]=2;
    parametersVn=3;
  }
  for (int j=1; j < nargs; j++) {
    int indexConst=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(args[i++]=nextLocal++,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    constants.put(new Integer(indexConst),new ConstantValue(j - 1));
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}","/** 
 * TODO: clean this up. Create the IR for the synthetic method (e.g. Method.invoke)
 * @param method is something like Method.invoke or Construction.newInstance
 * @param target is the method being called reflectively
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int i=0;
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[i++]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    parametersVn=3;
    if (target.isStatic()) {
    }
 else {
      args[i++]=2;
    }
  }
  for (int j=i; j < nargs; j++) {
    int indexConst=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(args[i++]=nextLocal++,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    constants.put(new Integer(indexConst),new ConstantValue(j - 1));
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}",0.9404429155020426
40549,"public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof ReceiverInstanceContext)) {
    return false;
  }
  return node.getMethod().getReference().equals(METHOD_INVOKE) || node.getMethod().getReference().equals(CTOR_NEW_INSTANCE);
}","public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof ReceiverInstanceContext)) {
    return false;
  }
  ReceiverInstanceContext r=(ReceiverInstanceContext)node.getContext();
  if (!(r.getReceiver() instanceof ConstantKey)) {
    return false;
  }
  return node.getMethod().getReference().equals(METHOD_INVOKE) || node.getMethod().getReference().equals(CTOR_NEW_INSTANCE);
}",0.8238153098420413
40550,"/** 
 * Add any methods that look like they might be DispatchAction targets, based on the method signature. TODO: instead, parse the struts xml directly.
 * @param klass an Action
 */
private void addSpeculativeDispatchMethods(IClass klass,IClassHierarchy cha){
  IClass C=klass;
  while (C != null) {
    for (Iterator<IMethod> it=C.getDeclaredMethods().iterator(); it.hasNext(); ) {
      IMethod M=(IMethod)it.next();
      Descriptor D=M.getDescriptor();
      if (D.equals(executeDesc) || D.equals(httpExecuteDesc)) {
        MethodReference m=MethodReference.findOrCreate(klass.getReference(),M.getName(),M.getDescriptor());
        entrypoints.put(m,new StrutsActionEntrypoint(C,M,cha));
      }
    }
    try {
      C=C.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","/** 
 * Add any methods that look like they might be DispatchAction targets, based on the method signature. TODO: instead, parse the struts xml directly.
 * @param klass an Action
 */
private void addSpeculativeDispatchMethods(IClass klass,IClassHierarchy cha){
  IClass c=klass;
  while (c != null) {
    for (Iterator<IMethod> it=c.getDeclaredMethods().iterator(); it.hasNext(); ) {
      IMethod M=(IMethod)it.next();
      Descriptor D=M.getDescriptor();
      if (D.equals(executeDesc) || D.equals(httpExecuteDesc)) {
        MethodReference m=MethodReference.findOrCreate(klass.getReference(),M.getName(),M.getDescriptor());
        entrypoints.put(m,new StrutsActionEntrypoint(klass,M,cha));
      }
    }
    try {
      c=c.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9907514450867052
40551,"/** 
 * Creates a callee target based on the following criteria: <ol> <li> If the method being invoked through reflection is definitely static, then do not create a callee target for any <code>callee</code> method that is not static. In this case, return <code>null</code>. <li> If the method being invoked through reflection takes a constant number of parameters, <code>n</code>, then do not create a callee target for any <code>callee</code> method that takes a number of parameters different from <code>n</code>.  In this case, return <code>null</code>. <li> Otherwise, return a new   {@link ReceiverInstanceContext} for <code>receiver</code>.</ol>       
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (!mayUnderstand(caller,site,callee,receiver)) {
    return null;
  }
  IR ir=caller.getIR();
  SSAAbstractInvokeInstruction[] invokeInstructions=ir.getCalls(site);
  if (invokeInstructions.length != 1) {
    return new ReceiverInstanceContext(receiver);
  }
  SymbolTable st=ir.getSymbolTable();
  ConstantKey receiverConstantKey=(ConstantKey)receiver;
  IMethod m=(IMethod)receiverConstantKey.getValue();
  boolean isStatic=m.isStatic();
  boolean isConstructor=isConstructorConstant(receiver);
  if (!isConstructor) {
    int recvUse=invokeInstructions[0].getUse(1);
    if (st.isNullConstant(recvUse) && !isStatic) {
      return null;
    }
  }
  int numberOfParams=isStatic ? m.getNumberOfParameters() : m.getNumberOfParameters() - 1;
  int paramIndex=isConstructor ? 1 : 2;
  int paramUse=invokeInstructions[0].getUse(paramIndex);
  SSAInstruction instr=caller.getDU().getDef(paramUse);
  if (!(instr instanceof SSANewInstruction)) {
    return new ReceiverInstanceContext(receiver);
  }
  SSANewInstruction newInstr=(SSANewInstruction)instr;
  if (!newInstr.getConcreteType().isArrayType()) {
    return null;
  }
  int vn=newInstr.getUse(0);
  try {
    int arrayLength=st.getIntValue(vn);
    if (arrayLength == numberOfParams) {
      return new ReceiverInstanceContext(receiver);
    }
 else {
      return new IllegalArgumentExceptionContext();
    }
  }
 catch (  IllegalArgumentException e) {
    return new ReceiverInstanceContext(receiver);
  }
}","/** 
 * Creates a callee target based on the following criteria: <ol> <li> If the method being invoked through reflection is definitely static, then do not create a callee target for any <code>callee</code> method that is not static. In this case, return <code>null</code>. <li> If the method being invoked through reflection takes a constant number of parameters, <code>n</code>, then do not create a callee target for any <code>callee</code> method that takes a number of parameters different from <code>n</code>. In this case, return <code>null</code>. <li> Otherwise, return a new   {@link ReceiverInstanceContext} for <code>receiver</code>.</ol>
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (!mayUnderstand(caller,site,callee,receiver)) {
    return null;
  }
  IR ir=caller.getIR();
  SSAAbstractInvokeInstruction[] invokeInstructions=ir.getCalls(site);
  if (invokeInstructions.length != 1) {
    return new ReceiverInstanceContext(receiver);
  }
  SymbolTable st=ir.getSymbolTable();
  ConstantKey receiverConstantKey=(ConstantKey)receiver;
  IMethod m=(IMethod)receiverConstantKey.getValue();
  boolean isStatic=m.isStatic();
  boolean isConstructor=isConstructorConstant(receiver);
  if (!isConstructor) {
    int recvUse=invokeInstructions[0].getUse(1);
    if (st.isNullConstant(recvUse) && !isStatic) {
      return null;
    }
  }
  int numberOfParams=isStatic ? m.getNumberOfParameters() : m.getNumberOfParameters() - 1;
  int paramIndex=isConstructor ? 1 : 2;
  int paramUse=invokeInstructions[0].getUse(paramIndex);
  SSAInstruction instr=caller.getDU().getDef(paramUse);
  if (!(instr instanceof SSANewInstruction)) {
    return new ReceiverInstanceContext(receiver);
  }
  SSANewInstruction newInstr=(SSANewInstruction)instr;
  if (!newInstr.getConcreteType().isArrayType()) {
    return null;
  }
  int vn=newInstr.getUse(0);
  try {
    int arrayLength=st.getIntValue(vn);
    if (arrayLength == numberOfParams) {
      return new ReceiverInstanceContext(receiver);
    }
 else {
      return new IllegalArgumentExceptionContext();
    }
  }
 catch (  IllegalArgumentException e) {
    return new ReceiverInstanceContext(receiver);
  }
}",0.9982078853046596
40552,"/** 
 * This object may understand a dispatch to Constructor.newInstance().
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (targetMethod.getReference().equals(ReflectiveInvocationInterpreter.METHOD_INVOKE) || isConstructorConstant(instance) && targetMethod.getReference().equals(ReflectiveInvocationInterpreter.CTOR_NEW_INSTANCE)) {
    return true;
  }
  return false;
}","/** 
 * This object may understand a dispatch to Constructor.newInstance().
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (instance instanceof ConstantKey) {
    if (targetMethod.getReference().equals(ReflectiveInvocationInterpreter.METHOD_INVOKE) || isConstructorConstant(instance) && targetMethod.getReference().equals(ReflectiveInvocationInterpreter.CTOR_NEW_INSTANCE)) {
      return true;
    }
  }
  return false;
}",0.9455709711846318
40553,"/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  final boolean[] r=new boolean[instructions.length];
  r[0]=true;
  BranchVisitor branchVisitor=makeBranchVisitor(r);
  PEIVisitor peiVisitor=makePEIVisitor(r);
  for (int i=0; i < instructions.length; i++) {
    if (instructions[i] != null) {
      branchVisitor.setIndex(i);
      instructions[i].visit(branchVisitor);
      peiVisitor.setIndex(i);
      instructions[i].visit(peiVisitor);
    }
  }
  BasicBlock b=null;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      b=new BasicBlock(i);
      addNode(b);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + b);
      }
    }
    i2block[i]=b;
  }
  BasicBlock exit=new BasicBlock(-1);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + exit);
  }
  addNode(exit);
}","/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  final boolean[] r=new boolean[instructions.length];
  r[0]=true;
  BranchVisitor branchVisitor=makeBranchVisitor(r);
  PEIVisitor peiVisitor=makePEIVisitor(r);
  for (int i=0; i < instructions.length; i++) {
    if (instructions[i] != null) {
      branchVisitor.setIndex(i);
      instructions[i].visit(branchVisitor);
      peiVisitor.setIndex(i);
      instructions[i].visit(peiVisitor);
    }
  }
  BasicBlock b=null;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      b=new BasicBlock(i);
      addNode(b);
      int j=i;
      while (instructions[j] instanceof SSAPhiInstruction) {
        b.addPhi((SSAPhiInstruction)instructions[j]);
        j++;
      }
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + b);
      }
    }
    i2block[i]=b;
  }
  BasicBlock exit=new BasicBlock(-1);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + exit);
  }
  addNode(exit);
  clearPhis(instructions);
}",0.9119683481701286
40554,"@Override public void visitGoto(SSAGotoInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock();
}","@Override public void visitGoto(SSAGotoInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock(index);
}",0.9814126394052044
40555,"/** 
 * TODO: we do not yet support induced CFGS with exception handlers.
 * @param instructions
 * @throws IllegalArgumentException  if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + method);
  }
  i2block=new BasicBlock[instructions.length];
  if (instructions.length == 0) {
    makeEmptyBlocks();
  }
 else {
    makeBasicBlocks();
  }
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","/** 
 * TODO: we do not yet support induced CFGS with exception handlers. NOTE: SIDE EFFECT!!! ... nulls out phi instructions in the instruction array!
 * @throws IllegalArgumentException if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + method);
  }
  i2block=new BasicBlock[instructions.length];
  if (instructions.length == 0) {
    makeEmptyBlocks();
  }
 else {
    makeBasicBlocks();
  }
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9187279151943464
40556,"@Override public void visitReturn(SSAReturnInstruction instruction){
  breakBasicBlock();
}","@Override public void visitReturn(SSAReturnInstruction instruction){
  breakBasicBlock(index);
}",0.9732620320855616
40557,"@Override public void visitConditionalBranch(SSAConditionalBranchInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock();
}","@Override public void visitConditionalBranch(SSAConditionalBranchInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock(index);
}",0.9844236760124612
40558,"public InducedCFG makeControlFlowGraph(){
  return new InducedCFG(getStatements(),this,Everywhere.EVERYWHERE);
}","/** 
 * Create an   {@link InducedCFG} from an instruction array.NOTE: SIDE EFFECT!!! ... nulls out phi instructions in the instruction array!
 */
public InducedCFG makeControlFlowGraph(SSAInstruction[] instructions){
  return new InducedCFG(instructions,this,Everywhere.EVERYWHERE);
}",0.4886649874055415
40559,"@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  Map<Integer,ConstantValue> constants=null;
  if (valueNumberForConstantOne > -1) {
    constants=HashMapFactory.make(1);
    constants.put(new Integer(valueNumberForConstantOne),new ConstantValue(new Integer(1)));
  }
  return new SyntheticIR(this,Everywhere.EVERYWHERE,makeControlFlowGraph(),instrs,options,constants);
}","@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  Map<Integer,ConstantValue> constants=null;
  if (valueNumberForConstantOne > -1) {
    constants=HashMapFactory.make(1);
    constants.put(new Integer(valueNumberForConstantOne),new ConstantValue(new Integer(1)));
  }
  InducedCFG cfg=makeControlFlowGraph(instrs);
  return new SyntheticIR(this,Everywhere.EVERYWHERE,cfg,instrs,options,constants);
}",0.9172413793103448
40560,"@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  return new SyntheticIR(this,Everywhere.EVERYWHERE,makeControlFlowGraph(),instrs,options,summary.getConstants());
}","@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  return new SyntheticIR(this,Everywhere.EVERYWHERE,makeControlFlowGraph(instrs),instrs,options,summary.getConstants());
}",0.9861751152073732
40561,"/** 
 * Creates the union of two ordinal sets.
 * @param A ordinal set a
 * @param B ordinal set b
 * @return union of a and b
 * @throws IllegalArgumentException iff A or B is null
 */
public static <T>OrdinalSet<T> unify(OrdinalSet<T> A,OrdinalSet<T> B){
  if (A == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (B == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    if (A.size() != 0 && B.size() != 0) {
      Assertions._assert(A.mapping.equals(B.mapping));
    }
  }
  if (A.S != null && B.S == null) {
    return new OrdinalSet<T>(A.S,A.mapping);
  }
 else   if (A.S == null && B.S != null) {
    return new OrdinalSet<T>(B.S,B.mapping);
  }
  IntSet union=A.S.union(B.S);
  return new OrdinalSet<T>(union,A.mapping);
}","/** 
 * Creates the union of two ordinal sets.
 * @param A ordinal set a
 * @param B ordinal set b
 * @return union of a and b
 * @throws IllegalArgumentException iff A or B is null
 */
public static <T>OrdinalSet<T> unify(OrdinalSet<T> A,OrdinalSet<T> B){
  if (A == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (B == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    if (A.size() != 0 && B.size() != 0) {
      Assertions._assert(A.mapping.equals(B.mapping));
    }
  }
  if (A.S == null) {
    return (B.S == null) ? OrdinalSet.<T>empty() : new OrdinalSet<T>(B.S,B.mapping);
  }
 else   if (B.S == null) {
    return (A.S == null) ? OrdinalSet.<T>empty() : new OrdinalSet<T>(A.S,A.mapping);
  }
  IntSet union=A.S.union(B.S);
  return new OrdinalSet<T>(union,A.mapping);
}",0.8054567022538552
40562,"/** 
 * @return a set of ConcreteTypeKeys that represent the exceptions the PEI may throw.
 */
public InstanceKey getInstanceKeyForPEI(CGNode node,ProgramCounter peiLoc,TypeReference type){
  return new ConcreteTypeKey(cha.lookupClass(type));
}","/** 
 * @return a set of ConcreteTypeKeys that represent the exceptions the PEI may throw.
 */
public InstanceKey getInstanceKeyForPEI(CGNode node,ProgramCounter peiLoc,TypeReference type){
  IClass klass=cha.lookupClass(type);
  if (klass == null) {
    return null;
  }
  return new ConcreteTypeKey(cha.lookupClass(type));
}",0.856140350877193
40563,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
private void addExceptionDefConstraints(IR ir,DefUse du,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set catchClasses){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + node);
  }
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + peiLoc);
    }
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pei);
    }
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (!SHORT_CIRCUIT_SINGLE_USES || !hasUniqueCatchBlock(s,ir)) {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (contentsAreInvariant(ir.getSymbolTable(),du,s.getException())) {
        InstanceKey[] ik=getInvariantContents(ir.getSymbolTable(),du,node,s.getException(),this);
        for (int i=0; i < ik.length; i++) {
          system.findOrCreateIndexForInstanceKey(ik[i]);
          assignInstanceToCatch(exceptionVar,catchClasses,ik[i]);
        }
      }
 else {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            system.newConstraint(exceptionVar,getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory));
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
private void addExceptionDefConstraints(IR ir,DefUse du,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set catchClasses){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + node);
  }
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + peiLoc);
    }
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pei);
    }
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (!SHORT_CIRCUIT_SINGLE_USES || !hasUniqueCatchBlock(s,ir)) {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (contentsAreInvariant(ir.getSymbolTable(),du,s.getException())) {
        InstanceKey[] ik=getInvariantContents(ir.getSymbolTable(),du,node,s.getException(),this);
        for (int i=0; i < ik.length; i++) {
          system.findOrCreateIndexForInstanceKey(ik[i]);
          assignInstanceToCatch(exceptionVar,catchClasses,ik[i]);
        }
      }
 else {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory);
          if (ik == null) {
            continue;
          }
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            system.newConstraint(exceptionVar,getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory));
          }
        }
      }
    }
  }
}",0.9883677298311444
40564,"/** 
 * Usage: GVSlice -appJar [jar file name] -mainClass [main class] -srcCaller [method name] -srcCallee [method name] -dd [data dependence options] -cd [control dependence options] -dir [forward|backward] <ul> <li> ""jar file name"" should be something like ""c:/temp/testdata/java_cup.jar"" <li> ""main class"" should beshould be something like ""c:/temp/testdata/java_cup.jar"" <li> ""method name"" should be the name of a method. This takes a slice from the statement that calls ""srcCallee"" from ""srcCaller"" <li> ""data dependence options"" can be one of ""-full"", ""-no_base_ptrs"", ""-no_base_no_heap"", ""-no_heap"", ""-no_base_no_heap_no_cast"", or ""-none"".
 * @throws CancelException
 * @throws IllegalArgumentException
 * @see com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions <li> ""control dependence options"" can be ""-full"" or ""-none"" <li> the -dir argument tells whether to compute a forwards or backwards slice. </ul>
 */
public static void main(String[] args) throws WalaException, IllegalArgumentException, CancelException {
  run(args);
}","/** 
 * Usage: GVSlice -appJar [jar file name] -mainClass [main class] -srcCaller [method name] -srcCallee [method name] -dd [data dependence options] -cd [control dependence options] -dir [forward|backward] <ul> <li> ""jar file name"" should be something like ""c:/temp/testdata/java_cup.jar"" <li> ""main class"" should beshould be something like ""c:/temp/testdata/java_cup.jar"" <li> ""method name"" should be the name of a method. This takes a slice from the statement that calls ""srcCallee"" from ""srcCaller"" <li> ""data dependence options"" can be one of ""-full"", ""-no_base_ptrs"", ""-no_base_no_heap"", ""-no_heap"", ""-no_base_no_heap_no_cast"", or ""-none"".
 * @throws CancelException
 * @throws IllegalArgumentException
 * @throws IOException 
 * @see com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions <li> ""control dependence options"" can be ""-full"" or ""-none"" <li> the -dir argument tells whether to compute a forwards or backwards slice. </ul>
 */
public static void main(String[] args) throws WalaException, IllegalArgumentException, CancelException, IOException {
  run(args);
}",0.9825059101654846
40565,"/** 
 * Compute a slice from a call statements, dot it, and fire off ghostview to visualize the result
 * @param appJar should be something like ""c:/temp/testdata/java_cup.jar""
 * @param mainClass should be something like ""c:/temp/testdata/java_cup.jar""
 * @param srcCaller name of the method containing the statement of interest
 * @param srcCallee name of the method called by the statement of interest
 * @param goBackward do a backward slice?
 * @param dOptions options controlling data dependence
 * @param cOptions options controlling control dependence
 * @return a Process running ghostview to visualize the dot'ted representation of the slice
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Process run(String appJar,String mainClass,String srcCaller,String srcCallee,boolean goBackward,DataDependenceOptions dOptions,ControlDependenceOptions cOptions) throws IllegalArgumentException, CancelException {
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,mainClass);
    AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
    CallGraphBuilder builder=Util.makeVanillaZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
    CallGraph cg=builder.makeCallGraph(options,null);
    SDG sdg=new SDG(cg,builder.getPointerAnalysis(),dOptions,cOptions);
    CGNode callerNode=SlicerTest.findMethod(cg,srcCaller);
    Statement s=SlicerTest.findCallTo(callerNode,srcCallee);
    System.err.println(""String_Node_Str"" + s);
    Collection<Statement> slice=null;
    if (goBackward) {
      slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
 else {
      s=getReturnStatementForCall(s);
      slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
    SlicerTest.dumpSlice(slice);
    Graph<Statement> g=pruneSDG(sdg,slice);
    sanityCheck(slice,g);
    Properties p=null;
    try {
      p=WalaExamplesProperties.loadProperties();
      p.putAll(WalaProperties.loadProperties());
    }
 catch (    WalaException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
    String psFile=p.getProperty(WalaProperties.OUTPUT_DIR) + File.separatorChar + PS_FILE;
    String dotExe=p.getProperty(WalaExamplesProperties.DOT_EXE);
    DotUtil.dotify(g,makeNodeDecorator(),GVTypeHierarchy.DOT_FILE,psFile,dotExe);
    String gvExe=p.getProperty(WalaExamplesProperties.GHOSTVIEW_EXE);
    return GVUtil.launchGV(psFile,gvExe);
  }
 catch (  WalaException e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * Compute a slice from a call statements, dot it, and fire off ghostview to visualize the result
 * @param appJar should be something like ""c:/temp/testdata/java_cup.jar""
 * @param mainClass should be something like ""c:/temp/testdata/java_cup.jar""
 * @param srcCaller name of the method containing the statement of interest
 * @param srcCallee name of the method called by the statement of interest
 * @param goBackward do a backward slice?
 * @param dOptions options controlling data dependence
 * @param cOptions options controlling control dependence
 * @return a Process running ghostview to visualize the dot'ted representation of the slice
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Process run(String appJar,String mainClass,String srcCaller,String srcCallee,boolean goBackward,DataDependenceOptions dOptions,ControlDependenceOptions cOptions) throws IllegalArgumentException, CancelException, IOException {
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,mainClass);
    AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
    CallGraphBuilder builder=Util.makeVanillaZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
    CallGraph cg=builder.makeCallGraph(options,null);
    SDG sdg=new SDG(cg,builder.getPointerAnalysis(),dOptions,cOptions);
    CGNode callerNode=SlicerTest.findMethod(cg,srcCaller);
    Statement s=SlicerTest.findCallTo(callerNode,srcCallee);
    System.err.println(""String_Node_Str"" + s);
    Collection<Statement> slice=null;
    if (goBackward) {
      slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
 else {
      s=getReturnStatementForCall(s);
      slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
    SlicerTest.dumpSlice(slice);
    Graph<Statement> g=pruneSDG(sdg,slice);
    sanityCheck(slice,g);
    Properties p=null;
    try {
      p=WalaExamplesProperties.loadProperties();
      p.putAll(WalaProperties.loadProperties());
    }
 catch (    WalaException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
    String psFile=p.getProperty(WalaProperties.OUTPUT_DIR) + File.separatorChar + PS_FILE;
    String dotExe=p.getProperty(WalaExamplesProperties.DOT_EXE);
    DotUtil.dotify(g,makeNodeDecorator(),GVTypeHierarchy.DOT_FILE,psFile,dotExe);
    String gvExe=p.getProperty(WalaExamplesProperties.GHOSTVIEW_EXE);
    return GVUtil.launchGV(psFile,gvExe);
  }
 catch (  WalaException e) {
    e.printStackTrace();
    return null;
  }
}",0.9941437444543034
40566,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
 else {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
            }
          }
          if (caughtException != null) {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
            caughtException=null;
          }
          if (caughtException != null) {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9767952336155534
40567,"protected void addInstruction(final TypeReference T,SSAInstruction instr,boolean isAllocation){
  if (isAllocation) {
    if (types.contains(T))     return;
  }
  types.add(T);
  allInstructions.add(instr);
  if (isAllocation)   allocations.add(instr);
}","protected void addInstruction(final TypeReference T,SSAInstruction instr,boolean isAllocation){
  if (isAllocation) {
    if (typesAllocated.contains(T)) {
      return;
    }
 else {
      typesAllocated.add(T);
    }
  }
  allInstructions.add(instr);
  if (isAllocation) {
    allocations.add(instr);
  }
}",0.8932384341637011
40568,"/** 
 * @param type
 * @return a TypeAbstraction object representing this type. We just useConeTypes by default, since we don't propagate information allowing us to distinguish between points and cones yet.
 */
protected TypeAbstraction typeRef2TypeAbstraction(IClassHierarchy cha,TypeReference type){
  IClass klass=cha.lookupClass(type);
  if (klass != null) {
    return new ConeType(klass);
  }
  Assertions.UNREACHABLE(type.toString());
  return null;
}","/** 
 * @param type
 * @return a TypeAbstraction object representing this type. We just use ConeTypes by default, since we don't propagateinformation allowing us to distinguish between points and cones yet.
 */
protected TypeAbstraction typeRef2TypeAbstraction(IClassHierarchy cha,TypeReference type){
  IClass klass=cha.lookupClass(type);
  if (klass != null) {
    return new ConeType(klass);
  }
  Assertions.UNREACHABLE(type.toString());
  return null;
}",0.9978165938864628
40569,"protected int addStatementsForConcreteSimpleType(final TypeReference T){
  if (types.contains(T))   return -1;
  types.add(T);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + T);
  }
  NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
  int alloc=getLocalForType(T);
  SSANewInstruction a=new SSANewInstruction(alloc,ref);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + a);
  }
  addInstruction(T,a,true);
  SSAReturnInstruction r=new SSAReturnInstruction(alloc,false);
  addInstruction(T,r,false);
  return alloc;
}","/** 
 * @param T
 * @return value number of the newly allocated object
 */
protected int addStatementsForConcreteSimpleType(final TypeReference T){
}",0.2132564841498559
40570,"protected void addStatementsForTypeAbstraction(TypeAbstraction T){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ method);
  }
  T=interceptType(T);
  if (T == null) {
    return;
  }
  if ((T instanceof PointType) || (T instanceof ConeType)) {
    TypeReference ref=T.getType().getReference();
    NewSiteReference site=NewSiteReference.make(0,ref);
    IClass klass=options.getClassTargetSelector().getAllocatedTarget(null,site);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + klass + ""String_Node_Str""+ T);
    }
    if (T instanceof PointType) {
      addStatementsForConcreteType(ref);
    }
 else     if (T instanceof ConeType) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + T);
      }
      if (((ConeType)T).isInterface()) {
        Set implementors=T.getType().getClassHierarchy().getImplementors(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ implementors);
        }
        if (implementors.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (implementors.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,implementors.size()));
        }
        addStatementsForSetOfTypes(implementors.iterator());
      }
 else {
        Collection<IClass> subclasses=T.getType().getClassHierarchy().computeSubClasses(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ subclasses);
        }
        if (subclasses.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (subclasses.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,subclasses.size()));
        }
        addStatementsForSetOfTypes(subclasses.iterator());
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
    }
  }
 else   if (T instanceof SetType) {
    addStatementsForSetOfTypes(((SetType)T).iteratePoints());
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
  }
}","protected void addStatementsForTypeAbstraction(TypeAbstraction T){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ method);
  }
  T=interceptType(T);
  if (T == null) {
    return;
  }
  if ((T instanceof PointType) || (T instanceof ConeType)) {
    TypeReference ref=T.getType().getReference();
    NewSiteReference site=NewSiteReference.make(0,ref);
    IClass klass=options.getClassTargetSelector().getAllocatedTarget(null,site);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + klass + ""String_Node_Str""+ T);
    }
    if (T instanceof PointType) {
      if (!typesAllocated.contains(ref)) {
        addStatementsForConcreteType(ref);
      }
    }
 else     if (T instanceof ConeType) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + T);
      }
      if (((ConeType)T).isInterface()) {
        Set implementors=T.getType().getClassHierarchy().getImplementors(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ implementors);
        }
        if (implementors.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (implementors.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,implementors.size()));
        }
        addStatementsForSetOfTypes(implementors.iterator());
      }
 else {
        Collection<IClass> subclasses=T.getType().getClassHierarchy().computeSubClasses(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ subclasses);
        }
        if (subclasses.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (subclasses.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,subclasses.size()));
        }
        addStatementsForSetOfTypes(subclasses.iterator());
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
    }
  }
 else   if (T instanceof SetType) {
    addStatementsForSetOfTypes(((SetType)T).iteratePoints());
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
  }
}",0.9882405147548258
40571,"private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || types.contains(T)) {
      continue;
    }
    types.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}","private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || typesAllocated.contains(T)) {
      continue;
    }
    typesAllocated.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}",0.9933085501858736
40572,"/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.worked(monitor,1);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}","/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}",0.9883616830796778
40573,"public void testReflect1() throws WalaException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.REFLECT1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  Warnings.clear();
  CallGraphTest.doCallGraphs(options,new AnalysisCache(),cha,scope,useShortProfile(),false);
  for (Iterator<Warning> it=Warnings.iterator(); it.hasNext(); ) {
    Warning w=(Warning)it.next();
    if (w.toString().indexOf(""String_Node_Str"") > 0) {
      continue;
    }
    if (w.toString().indexOf(""String_Node_Str"") >= 0) {
      assertTrue(w.toString(),false);
    }
  }
}","/** 
 * test that when analyzing Reflect1.main(), there is no warning about ""Integer"".
 */
public void testReflect1() throws WalaException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.REFLECT1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  Warnings.clear();
  CallGraphTest.doCallGraphs(options,new AnalysisCache(),cha,scope,useShortProfile(),false);
  for (Iterator<Warning> it=Warnings.iterator(); it.hasNext(); ) {
    Warning w=(Warning)it.next();
    if (w.toString().indexOf(""String_Node_Str"") > 0) {
      continue;
    }
    if (w.toString().indexOf(""String_Node_Str"") >= 0) {
      assertTrue(w.toString(),false);
    }
  }
}",0.9506775067750678
40574,"@Override public void visitPut(SSAPutInstruction instruction){
  IField f=pa.getClassHierarchy().resolveField(instruction.getDeclaredField());
  if (f != null) {
    if (instruction.isStatic()) {
      result.add(h.getPointerKeyForStaticField(f));
    }
 else {
      PointerKey ref=h.getPointerKeyForLocal(n,instruction.getRef());
      for (      InstanceKey i : pa.getPointsToSet(ref)) {
        result.add(h.getPointerKeyForInstanceField(i,f));
      }
    }
  }
}","@Override public void visitPut(SSAPutInstruction instruction){
  IField f=pa.getClassHierarchy().resolveField(instruction.getDeclaredField());
  if (f != null) {
    if (instruction.isStatic()) {
      result.add(h.getPointerKeyForStaticField(f));
    }
 else {
      PointerKey ref=h.getPointerKeyForLocal(n,instruction.getRef());
      if (ref != null) {
        for (        InstanceKey i : pa.getPointsToSet(ref)) {
          result.add(h.getPointerKeyForInstanceField(i,f));
        }
      }
    }
  }
}",0.947799385875128
40575,"/** 
 * If the   {@link CallSiteReference} invokes Class.forName(s) and s is a string constant, return a{@link JavaTypeContext} representing the type named by s, if we can resolve it in the {@link IClassHierarchy}.
 * @see com.ibm.wala.ipa.callgraph.ContextSelector#getCalleeTarget(com.ibm.wala.ipa.callgraph.CGNode,com.ibm.wala.classLoader.CallSiteReference,com.ibm.wala.classLoader.IMethod,com.ibm.wala.ipa.callgraph.propagation.InstanceKey)
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.equals(forNameMethod)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return null;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      String className=StringStuff.deployment2CanonicalTypeString(symbolTable.getStringValue(use));
      TypeReference t=TypeReference.findOrCreate(caller.getMethod().getDeclaringClass().getClassLoader().getReference(),className);
      IClass klass=caller.getClassHierarchy().lookupClass(t);
      if (klass != null) {
        return new JavaTypeContext(new PointType(klass));
      }
    }
  }
  return null;
}","/** 
 * If the   {@link CallSiteReference} invokes Class.forName(s) and s is a string constant, return a{@link JavaTypeContext} representing the type named by s, if we can resolve it in the {@link IClassHierarchy}.
 * @see com.ibm.wala.ipa.callgraph.ContextSelector#getCalleeTarget(com.ibm.wala.ipa.callgraph.CGNode,com.ibm.wala.classLoader.CallSiteReference,com.ibm.wala.classLoader.IMethod,com.ibm.wala.ipa.callgraph.propagation.InstanceKey)
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.getReference().equals(ForNameContextInterpreter.FOR_NAME_REF)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return null;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      String className=StringStuff.deployment2CanonicalTypeString(symbolTable.getStringValue(use));
      TypeReference t=TypeReference.findOrCreate(caller.getMethod().getDeclaringClass().getClassLoader().getReference(),className);
      IClass klass=caller.getClassHierarchy().lookupClass(t);
      if (klass != null) {
        return new JavaTypeContext(new PointType(klass));
      }
    }
  }
  return null;
}",0.9806259314456036
40576,"public ForNameContextSelector(final IClassHierarchy cha){
}","public ForNameContextSelector(){
}",0.7311827956989247
40577,"/** 
 * This object may understand a dispatch to Class.forName(s) when s is a string constant.
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (targetMethod.equals(forNameMethod)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return false;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      return true;
    }
  }
  return false;
}","/** 
 * This object may understand a dispatch to Class.forName(s) when s is a string constant.
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (targetMethod.getReference().equals(ForNameContextInterpreter.FOR_NAME_REF)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return false;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      return true;
    }
  }
  return false;
}",0.9591836734693876
40578,"/** 
 * First check ""forName"" logic, then factory logic.
 */
private ReflectionContextSelector(IClassHierarchy cha,MethodTargetSelector methodTargetSelector){
  super(new ForNameContextSelector(cha),new FactoryContextSelector(cha,methodTargetSelector));
}","/** 
 * First check ""forName"" logic, then factory logic.
 */
private ReflectionContextSelector(IClassHierarchy cha,MethodTargetSelector methodTargetSelector){
  super(new ForNameContextSelector(),new FactoryContextSelector(cha,methodTargetSelector));
}",0.9940828402366864
40579,"@Override public void visitLoadClass(SSALoadClassInstruction instruction){
  PointerKey def=getPointerKeyForLocal(instruction.getDef());
  InstanceKey iKey=getInstanceKeyForClassObject(instruction.getLoadedClass());
  if (!contentsAreInvariant(symbolTable,du,instruction.getDef())) {
    system.newConstraint(def,iKey);
  }
 else {
    system.findOrCreateIndexForInstanceKey(iKey);
    system.recordImplicitPointsToSet(def);
  }
}","@Override public void visitLoadClass(SSALoadClassInstruction instruction){
  PointerKey def=getPointerKeyForLocal(instruction.getDef());
  InstanceKey iKey=getInstanceKeyForClassObject(instruction.getLoadedClass());
  IClass klass=getClassHierarchy().lookupClass(instruction.getLoadedClass());
  if (klass != null) {
    processClassInitializer(klass);
  }
  if (!contentsAreInvariant(symbolTable,du,instruction.getDef())) {
    system.newConstraint(def,iKey);
  }
 else {
    system.findOrCreateIndexForInstanceKey(iKey);
    system.recordImplicitPointsToSet(def);
  }
}",0.8591408591408591
40580,"/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.getDeclaringClass().equals(TypeReference.JavaLangSystem)) {
    if (m.getName().toString().equals(""String_Node_Str"")) {
      return true;
    }
  }
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  if (m.equals(ArraysCopyOfRange)) {
    return true;
  }
  if (m.equals(ArraysCopyOf)) {
    return true;
  }
  if (m.equals(ArraysCopyOf2)) {
    return true;
  }
  if (m.equals(StringValueOf)) {
    return true;
  }
  return false;
}","/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.getDeclaringClass().equals(TypeReference.JavaLangSystem)) {
    if (m.getName().toString().equals(""String_Node_Str"")) {
      return true;
    }
  }
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  if (m.equals(ArraysCopyOfRange)) {
    return true;
  }
  if (m.equals(ArraysCopyOf)) {
    return true;
  }
  if (m.equals(ArraysCopyOf2)) {
    return true;
  }
  if (m.equals(StringValueOf)) {
    return true;
  }
  if (m.equals(HashtableNewEntry)) {
    return true;
  }
  return false;
}",0.9422572178477692
40581,"/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 */
private void addParamPassingStatements(int callIndex,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)node.getIR().getInstructions()[callIndex];
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamCaller(node,callIndex,call.getUse(j));
    delegate.addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new NormalReturnCaller(node,callIndex);
    delegate.addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ExceptionalReturnCaller(node,callIndex);
      delegate.addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(cg,node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.HeapParamCaller(node,callIndex,p);
      delegate.addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(cg,node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.HeapReturnCaller(node,callIndex,p);
      delegate.addNode(st);
      rets.add(st);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 */
private void addParamPassingStatements(int callIndex,Map<CGNode,OrdinalSet<PointerKey>> ref,IR ir){
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ir.getInstructions()[callIndex];
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamCaller(node,callIndex,call.getUse(j));
    delegate.addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new NormalReturnCaller(node,callIndex);
    delegate.addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ExceptionalReturnCaller(node,callIndex);
      delegate.addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(cg,node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.HeapParamCaller(node,callIndex,p);
      delegate.addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(cg,node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.HeapReturnCaller(node,callIndex,p);
      delegate.addNode(st);
      rets.add(st);
    }
  }
}",0.993368700265252
40582,"/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(){
}","/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(IR ir,Map<SSAInstruction,Integer> instructionIndices){
}",0.9064748201438848
40583,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
  return visited;
}",0.9978494623655914
40584,"/** 
 * Create all nodes in this PDG. Each node is a Statement.
 * @param dOptions
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions){
  IR ir=node.getIR();
  if (ir != null) {
    Collection<SSAInstruction> visited=createNormalStatements(ir,ref);
    createSpecialStatements(ir,visited);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}","/** 
 * Create all nodes in this PDG. Each node is a Statement.
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions,IR ir){
  if (ir != null) {
    Collection<SSAInstruction> visited=createNormalStatements(ir,ref);
    createSpecialStatements(ir,visited);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}",0.9578622816032888
40585,"private void createScalarEdges(ControlDependenceOptions cOptions){
  createScalarDataDependenceEdges();
  createControlDependenceEdges(cOptions);
}","private void createScalarEdges(ControlDependenceOptions cOptions,IR ir,Map<SSAInstruction,Integer> instructionIndices){
  createScalarDataDependenceEdges(ir,instructionIndices);
  createControlDependenceEdges(cOptions,ir,instructionIndices);
}",0.7538461538461538
40586,"public static synchronized Statement ssaInstruction2Statement(CGNode node,SSAInstruction s,Map<SSAInstruction,Integer> instructionIndices){
}","public static synchronized Statement ssaInstruction2Statement(CGNode node,SSAInstruction s,Map<SSAInstruction,Integer> instructionIndices,IR ir){
}",0.9791666666666666
40587,"/** 
 * Create all control dependence edges in this PDG.
 */
private void createControlDependenceEdges(ControlDependenceOptions cOptions){
}","/** 
 * Create all control dependence edges in this PDG.
 */
private void createControlDependenceEdges(ControlDependenceOptions cOptions,IR ir,Map<SSAInstruction,Integer> instructionIndices){
}",0.8408408408408409
40588,"private void populate(){
  if (!isPopulated) {
    isPopulated=true;
    instructionIndices=computeInstructionIndices(node.getIR());
    createNodes(ref,cOptions);
    createScalarEdges(cOptions);
  }
}","/** 
 * WARNING: Since we're using a   {@link HashMap} of {@link SSAInstruction}s, and equals() of   {@link SSAInstruction}assumes a canonical representative for each instruction, we <bf>must</bf> ensure that we use the same IR object throughout initialization!!
 */
private void populate(){
  if (!isPopulated) {
    IR ir=node.getIR();
    isPopulated=true;
    Map<SSAInstruction,Integer> instructionIndices=computeInstructionIndices(ir);
    createNodes(ref,cOptions,ir);
    createScalarEdges(cOptions,ir,instructionIndices);
  }
}",0.3495934959349593
40589,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
          if (caughtException == null) {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
          }
 else {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
 else {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
            }
          }
          if (caughtException != null) {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9820340070580686
40590,"/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
          PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)returnAtCallerKey);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (caller.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}","/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
          PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)returnAtCallerKey);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (callee.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}",0.9998007571229328
40591,"/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst,dstToSrcLabel.bar());
  }
  IntSet trackedSet=find(pkToTrackedSet,dst);
  if (!trackedSet.isEmpty()) {
    if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
      addToTrackedPToWorklist(src);
    }
  }
}","/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  if (DEBUG) {
  }
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst,dstToSrcLabel.bar());
  }
  for (  PointerKeyAndState dstToHandle : matchingTrackedQueried(src,dst.getPointerKey(),dstToSrcLabel)) {
    IntSet trackedSet=find(pkToTrackedSet,dstToHandle);
    if (!trackedSet.isEmpty()) {
      if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
        addToTrackedPToWorklist(src);
      }
    }
  }
}",0.8811410459587956
40592,"public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
return caller.getValueNumber() == callee.getValueNumber() && cg.getPossibleTargets(caller.getNode(),caller.getInstruction().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case PI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
return caller.getValueNumber() == callee.getValueNumber() && cg.getPossibleTargets(caller.getNode(),caller.getInstruction().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE(src.getKind());
return false;
}
}",0.9963479415670652
40593,"/** 
 * @return the points-to set of <code>pk</code>, or <code>null</code> ifthe points-to set can't be computed in the allocated budget
 */
public Collection<InstanceKey> getPointsTo(PointerKey pk){
  return getPointsTo(pk,Predicate.<Collection<InstanceKey>>falsePred()).snd;
}","/** 
 * @return the points-to set of <code>pk</code>, or <code>null</code> if the points-to set can't be computed inthe allocated budget
 */
public Collection<InstanceKey> getPointsTo(PointerKey pk){
  return getPointsTo(pk,Predicate.<Collection<InstanceKey>>falsePred()).snd;
}",0.9964028776978416
40594,"private void propagateToCallee(){
  if (caller.getIR() == null) {
    return;
  }
  g.addSubgraphForNode(caller);
  SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
  for (int i=0; i < callInstrs.length; i++) {
    SSAAbstractInvokeInstruction callInstr=callInstrs[i];
    PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
    if (Assertions.verifyAssertions) {
      Assertions._assert(g.containsNode(actualPk));
      Assertions._assert(g.containsNode(localPk));
    }
    handler.handle(curPkAndState,actualPk,paramLabel);
  }
}","private void propagateToCallee(){
  g.addSubgraphForNode(caller);
  SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
  for (int i=0; i < callInstrs.length; i++) {
    SSAAbstractInvokeInstruction callInstr=callInstrs[i];
    PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
    if (Assertions.verifyAssertions) {
      Assertions._assert(g.containsNode(actualPk));
      Assertions._assert(g.containsNode(localPk));
    }
    handler.handle(curPkAndState,actualPk,paramLabel);
  }
}",0.9569120287253142
40595,"/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either  {@link #forwInstKeyToFields} or{@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  State state=ikAndState.getState();
  if (Assertions.verifyAssertions) {
    Assertions._assert(refineFieldAccesses(field));
  }
  ikToFields.put(ikAndState,field);
  for (Iterator<? extends Object> iter=g.getPredNodes(ikAndState.getInstanceKey(),NewLabel.v()); iter.hasNext(); ) {
    PointerKey ikPred=(PointerKey)iter.next();
    PointerKeyAndState ikPredAndState=new PointerKeyAndState(ikPred,state);
    int mappedIndex=ikAndStates.getMappedIndex(ikAndState);
    if (Assertions.verifyAssertions) {
      Assertions._assert(mappedIndex != -1);
    }
    if (findOrCreate(pkToTrackedSet,ikPredAndState).add(mappedIndex)) {
      addToTrackedPToWorklist(ikPredAndState);
    }
  }
}","/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either {@link #forwInstKeyToFields} or {@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  State state=ikAndState.getState();
  if (Assertions.verifyAssertions) {
    Assertions._assert(refineFieldAccesses(field));
  }
  ikToFields.put(ikAndState,field);
  for (Iterator<? extends Object> iter=g.getPredNodes(ikAndState.getInstanceKey(),NewLabel.v()); iter.hasNext(); ) {
    PointerKey ikPred=(PointerKey)iter.next();
    PointerKeyAndState ikPredAndState=new PointerKeyAndState(ikPred,state);
    int mappedIndex=ikAndStates.getMappedIndex(ikAndState);
    if (Assertions.verifyAssertions) {
      Assertions._assert(mappedIndex != -1);
    }
    if (findOrCreate(pkToTrackedSet,ikPredAndState).add(mappedIndex)) {
      addToTrackedPToWorklist(ikPredAndState);
    }
  }
}",0.9990503323836656
40596,"/** 
 * @param curPkAndState
 * @param predPk
 * @param label the label of the edge from curPk to predPk (must be barred)
 * @return those {@link PointerKeyAndState}s whose points-to sets have been queried, such that the   {@link PointerKey} is predPk, andtransitioning from its state on <code>label.bar()</code> yields the state of <code>curPkAndState</code>
 */
Collection<PointerKeyAndState> matchingPToQueried(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  Collection<PointerKeyAndState> ret=ArraySet.make();
  if (Assertions.verifyAssertions) {
    Assertions._assert(label.isBarred());
  }
  IFlowLabel unbarredLabel=label.bar();
  final State curState=curPkAndState.getState();
  Set<State> predPkStates=pointsToQueried.get(predPk);
  for (  State predState : predPkStates) {
    State transState=stateMachine.transition(predState,unbarredLabel);
    if (transState.equals(curState)) {
      ret.add(new PointerKeyAndState(predPk,predState));
    }
  }
  return ret;
}","/** 
 * @param curPkAndState
 * @param predPk
 * @param label the label of the edge from curPk to predPk (must be barred)
 * @return those {@link PointerKeyAndState}s whose points-to sets have been queried, such that the  {@link PointerKey} is predPk, and transitioning from its state on <code>label.bar()</code> yields thestate of <code>curPkAndState</code>
 */
Collection<PointerKeyAndState> matchingPToQueried(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  Collection<PointerKeyAndState> ret=ArraySet.make();
  if (Assertions.verifyAssertions) {
    Assertions._assert(label.isBarred());
  }
  IFlowLabel unbarredLabel=label.bar();
  final State curState=curPkAndState.getState();
  Set<State> predPkStates=pointsToQueried.get(predPk);
  for (  State predState : predPkStates) {
    State transState=stateMachine.transition(predState,unbarredLabel);
    if (transState.equals(curState)) {
      ret.add(new PointerKeyAndState(predPk,predState));
    }
  }
  return ret;
}",0.9984992496248124
40597,"void handleCopy(PointerKeyAndState curPkAndState,PointerKeyAndState succPkAndState){
  if (!addToInitWorklist(succPkAndState)) {
    if (addAllToP2Set(pkToP2Set,curPkAndState,find(pkToP2Set,succPkAndState))) {
      addToPToWorklist(curPkAndState);
    }
  }
}","void handleCopy(PointerKeyAndState curPkAndState,PointerKeyAndState succPkAndState,IFlowLabel label){
  if (!addToInitWorklist(succPkAndState)) {
    if (addAllToP2Set(pkToP2Set,curPkAndState,find(pkToP2Set,succPkAndState),label)) {
      addToPToWorklist(curPkAndState);
    }
  }
}",0.9576427255985268
40598,"public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      Assertions._assert(basePointerOkay,""String_Node_Str"" + loadedValAndState + ""String_Node_Str""+ baseAndStateToHandle);
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk))) {
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + loadEdge);
        }
        addToPToWorklist(loadedValAndState);
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}","public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      Assertions._assert(basePointerOkay,""String_Node_Str"" + loadedValAndState + ""String_Node_Str""+ baseAndStateToHandle);
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk),AssignLabel.noFilter())) {
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + loadEdge);
        }
        addToPToWorklist(loadedValAndState);
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}",0.995258709544424
40599,"public void handleTrackedPointsToWorklist(){
  while (!trackedPointsToWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=trackedPointsToWorklist.iterator().next();
    trackedPointsToWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    final MutableIntSet trackedSet=find(pkToTrackedSet,curPkAndState);
    IFlowLabelVisitor succVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=forwInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState storeDst=new PointerKeyAndState((PointerKey)dst,curState);
            encounteredStores.add(new StoreEdge(curPkAndState,field,storeDst));
            if (needField) {
              if (!addToInitWorklist(storeDst)) {
                InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
                findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storeDst));
              }
            }
          }
        }
      }
    }
;
    g.visitSuccs(curPk,succVisitor);
    IFlowLabelVisitor predVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        for (Iterator<? extends Object> readIter=g.getReadsOfStaticField((StaticFieldKey)dst); readIter.hasNext(); ) {
          final PointerKey predPk=(PointerKey)readIter.next();
          doTransition(curState,AssignGlobalBarLabel.v(),new Function<State,Object>(){
            public Object apply(            State predPkState){
              PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
              if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                addToTrackedPToWorklist(predPkAndState);
              }
              return null;
            }
          }
);
        }
      }
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          PointerKeyAndState storeBase=new PointerKeyAndState((PointerKey)dst,curState);
          encounteredStores.add(new StoreEdge(storeBase,field,curPkAndState));
          if (!addToInitWorklist(storeBase)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,storeBase))) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              findOrCreate(instFieldKeyToTrackedSet,ifk).addAll(trackedSet);
              trackInstanceField(ikAndState,field,backInstKeyToFields);
            }
          }
        }
 else {
          for (Iterator<PointerKey> readIter=g.getReadsOfInstanceField(field); readIter.hasNext(); ) {
            final PointerKey predPk=readIter.next();
            doTransition(curState,MatchBarLabel.v(),new Function<State,Object>(){
              public Object apply(              State predPkState){
                PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
                if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                  addToTrackedPToWorklist(predPkAndState);
                }
                return null;
              }
            }
);
          }
        }
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=backInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState loadedVal=new PointerKeyAndState((PointerKey)dst,curState);
            addEncounteredLoad(new LoadEdge(curPkAndState,field,loadedVal));
            if (needField) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              if (findOrCreate(pkToTrackedSet,loadedVal).addAll(find(instFieldKeyToTrackedSet,ifk))) {
                addToTrackedPToWorklist(loadedVal);
              }
            }
          }
        }
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        final PointerKey predPk=(PointerKey)dst;
        doTransition(curState,AssignBarLabel.v(),new Function<State,Object>(){
          public Object apply(          State predPkState){
            PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
            if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(predPkAndState);
            }
            return null;
          }
        }
);
      }
    }
;
    g.visitPreds(curPk,predVisitor);
    handleBackInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      final PointerKey dst,      IFlowLabel label){
        if (Assertions.verifyAssertions) {
          Assertions._assert(src == curPkAndState);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State dstState){
            PointerKeyAndState dstAndState=new PointerKeyAndState(dst,dstState);
            if (findOrCreate(pkToTrackedSet,dstAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(dstAndState);
            }
            return null;
          }
        }
);
      }
    }
,true);
  }
}","public void handleTrackedPointsToWorklist(){
  while (!trackedPointsToWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=trackedPointsToWorklist.iterator().next();
    trackedPointsToWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    final MutableIntSet trackedSet=find(pkToTrackedSet,curPkAndState);
    IFlowLabelVisitor succVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=forwInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState storeDst=new PointerKeyAndState((PointerKey)dst,curState);
            encounteredStores.add(new StoreEdge(curPkAndState,field,storeDst));
            if (needField) {
              if (!addToInitWorklist(storeDst)) {
                InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
                findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storeDst));
              }
            }
          }
        }
      }
    }
;
    g.visitSuccs(curPk,succVisitor);
    IFlowLabelVisitor predVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        for (Iterator<? extends Object> readIter=g.getReadsOfStaticField((StaticFieldKey)dst); readIter.hasNext(); ) {
          final PointerKey predPk=(PointerKey)readIter.next();
          doTransition(curState,AssignGlobalBarLabel.v(),new Function<State,Object>(){
            public Object apply(            State predPkState){
              PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
              if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                addToTrackedPToWorklist(predPkAndState);
              }
              return null;
            }
          }
);
        }
      }
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          PointerKeyAndState storeBase=new PointerKeyAndState((PointerKey)dst,curState);
          encounteredStores.add(new StoreEdge(storeBase,field,curPkAndState));
          if (!addToInitWorklist(storeBase)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,storeBase))) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              findOrCreate(instFieldKeyToTrackedSet,ifk).addAll(trackedSet);
              trackInstanceField(ikAndState,field,backInstKeyToFields);
            }
          }
        }
 else {
          for (Iterator<PointerKey> readIter=g.getReadsOfInstanceField(field); readIter.hasNext(); ) {
            final PointerKey predPk=readIter.next();
            doTransition(curState,MatchBarLabel.v(),new Function<State,Object>(){
              public Object apply(              State predPkState){
                PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
                if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                  addToTrackedPToWorklist(predPkAndState);
                }
                return null;
              }
            }
);
          }
        }
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=backInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState loadedVal=new PointerKeyAndState((PointerKey)dst,curState);
            addEncounteredLoad(new LoadEdge(curPkAndState,field,loadedVal));
            if (needField) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              if (findOrCreate(pkToTrackedSet,loadedVal).addAll(find(instFieldKeyToTrackedSet,ifk))) {
                addToTrackedPToWorklist(loadedVal);
              }
            }
          }
        }
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        final PointerKey predPk=(PointerKey)dst;
        doTransition(curState,AssignBarLabel.noFilter(),new Function<State,Object>(){
          public Object apply(          State predPkState){
            PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
            if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(predPkAndState);
            }
            return null;
          }
        }
);
      }
    }
;
    g.visitPreds(curPk,predVisitor);
    handleBackInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      final PointerKey dst,      IFlowLabel label){
        if (Assertions.verifyAssertions) {
          Assertions._assert(src == curPkAndState);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State dstState){
            PointerKeyAndState dstAndState=new PointerKeyAndState(dst,dstState);
            if (findOrCreate(pkToTrackedSet,dstAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(dstAndState);
            }
            return null;
          }
        }
);
      }
    }
,true);
  }
}",0.9992263388635776
40600,"void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState))) {
      addToPToWorklist(predPkAndState);
    }
  }
}","void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState),label)) {
      addToPToWorklist(predPkAndState);
    }
  }
}",0.990625
40601,"void handleInitWorklist(){
  while (!initWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=initWorklist.iterator().next();
    initWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    if (Assertions.verifyAssertions && curPk instanceof LocalPointerKey) {
      Assertions._assert(g.hasSubgraphForNode(((LocalPointerKey)curPk).getNode()));
    }
    IFlowLabelVisitor v=new AbstractFlowLabelVisitor(){
      @Override public void visitNew(      NewLabel label,      Object dst){
        final InstanceKey ik=(InstanceKey)dst;
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State newState){
            InstanceKeyAndState ikAndState=new InstanceKeyAndState(ik,newState);
            int n=ikAndStates.add(ikAndState);
            findOrCreate(pkToP2Set,curPkAndState).add(n);
            addToPToWorklist(curPkAndState);
            return null;
          }
        }
);
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=(label).getField();
        if (refineFieldAccesses(field)) {
          PointerKey loadBase=(PointerKey)dst;
          PointerKeyAndState loadBaseAndState=new PointerKeyAndState(loadBase,curState);
          addEncounteredLoad(new LoadEdge(loadBaseAndState,field,curPkAndState));
          if (!addToInitWorklist(loadBaseAndState)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,loadBaseAndState))) {
              trackInstanceField(ikAndState,field,forwInstKeyToFields);
            }
          }
        }
 else {
          handleAllCopies(curPkAndState,g.getWritesToInstanceField(field),MatchLabel.v());
        }
      }
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        handleAllCopies(curPkAndState,g.getWritesToStaticField((StaticFieldKey)dst),AssignGlobalLabel.v());
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        handleCopy(curPkAndState,(PointerKey)dst,AssignLabel.v());
      }
    }
;
    g.visitSuccs(curPk,v);
    handleForwInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      PointerKey dst,      IFlowLabel label){
        handleCopy(src,dst,label);
      }
    }
);
  }
}","void handleInitWorklist(){
  while (!initWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=initWorklist.iterator().next();
    initWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    if (Assertions.verifyAssertions && curPk instanceof LocalPointerKey) {
      Assertions._assert(g.hasSubgraphForNode(((LocalPointerKey)curPk).getNode()));
    }
    IFlowLabelVisitor v=new AbstractFlowLabelVisitor(){
      @Override public void visitNew(      NewLabel label,      Object dst){
        final InstanceKey ik=(InstanceKey)dst;
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State newState){
            InstanceKeyAndState ikAndState=new InstanceKeyAndState(ik,newState);
            int n=ikAndStates.add(ikAndState);
            findOrCreate(pkToP2Set,curPkAndState).add(n);
            addToPToWorklist(curPkAndState);
            return null;
          }
        }
);
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=(label).getField();
        if (refineFieldAccesses(field)) {
          PointerKey loadBase=(PointerKey)dst;
          PointerKeyAndState loadBaseAndState=new PointerKeyAndState(loadBase,curState);
          addEncounteredLoad(new LoadEdge(loadBaseAndState,field,curPkAndState));
          if (!addToInitWorklist(loadBaseAndState)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,loadBaseAndState))) {
              trackInstanceField(ikAndState,field,forwInstKeyToFields);
            }
          }
        }
 else {
          handleAllCopies(curPkAndState,g.getWritesToInstanceField(field),MatchLabel.v());
        }
      }
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        handleAllCopies(curPkAndState,g.getWritesToStaticField((StaticFieldKey)dst),AssignGlobalLabel.v());
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        handleCopy(curPkAndState,(PointerKey)dst,AssignLabel.noFilter());
      }
    }
;
    g.visitSuccs(curPk,v);
    handleForwInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      PointerKey dst,      IFlowLabel label){
        handleCopy(src,dst,label);
      }
    }
);
  }
}",0.9983079526226736
40602,"/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (caller.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}","/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
          PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)returnAtCallerKey);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (caller.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}",0.9737758656013112
40603,"/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst);
  }
  IntSet trackedSet=find(pkToTrackedSet,dst);
  if (!trackedSet.isEmpty()) {
    if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
      addToTrackedPToWorklist(src);
    }
  }
}","/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst,dstToSrcLabel.bar());
  }
  IntSet trackedSet=find(pkToTrackedSet,dst);
  if (!trackedSet.isEmpty()) {
    if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
      addToTrackedPToWorklist(src);
    }
  }
}",0.9816849816849816
40604,"@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey predPk=(PointerKey)dst;
  doTransition(curState,AssignBarLabel.v(),new Function<State,Object>(){
    public Object apply(    State predPkState){
      PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
      if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
        addToTrackedPToWorklist(predPkAndState);
      }
      return null;
    }
  }
);
}","@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey predPk=(PointerKey)dst;
  doTransition(curState,AssignBarLabel.noFilter(),new Function<State,Object>(){
    public Object apply(    State predPkState){
      PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
      if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
        addToTrackedPToWorklist(predPkAndState);
      }
      return null;
    }
  }
);
}",0.9906735751295336
40605,"/** 
 * handle flow from actuals to formals, and from returned values to variables at the caller
 * @param curPk
 * @param handler
 */
private void handleForwInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler){
  PointerKey curPk=curPkAndState.getPointerKey();
  if (curPk instanceof LocalPointerKey) {
    final LocalPointerKey localPk=(LocalPointerKey)curPk;
    if (g.isParam(localPk)) {
      final CGNode callee=localPk.getNode();
      final int paramPos=localPk.getValueNumber() - 1;
      for (      final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(localPk)) {
        final CGNode caller=callSiteAndCGNode.getCGNode();
        final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
        final IR ir=getIR(caller);
        final ParamLabel paramLabel=ParamLabel.make(callSiteAndCGNode);
        doTransition(curPkAndState.getState(),paramLabel,new Function<State,Object>(){
          private void propagateToCallee(){
            if (caller.getIR() == null) {
              return;
            }
            g.addSubgraphForNode(caller);
            SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
            for (int i=0; i < callInstrs.length; i++) {
              SSAAbstractInvokeInstruction callInstr=callInstrs[i];
              PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(actualPk));
                Assertions._assert(g.containsNode(localPk));
              }
              handler.handle(curPkAndState,actualPk,paramLabel);
            }
          }
          public Object apply(          State callerState){
            Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call);
            if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
              propagateToCallee();
            }
 else {
              if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
                propagateToCallee();
              }
 else {
                queryCallTargets(callSiteAndCGNode,ir,callerState);
              }
            }
            return null;
          }
        }
);
      }
    }
    SSAInvokeInstruction callInstr=g.getInstrReturningTo(localPk);
    if (callInstr != null) {
      CGNode caller=localPk.getNode();
      boolean isExceptional=localPk.getValueNumber() == callInstr.getException();
      CallSiteReference callSiteRef=callInstr.getCallSite();
      CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
      Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef);
      if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
        for (        CGNode callee : possibleCallees) {
          if (callee.getIR() == null) {
            continue;
          }
          g.addSubgraphForNode(callee);
          PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
          if (Assertions.verifyAssertions) {
            Assertions._assert(g.containsNode(retVal));
          }
          handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
        }
      }
 else {
        if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
          Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
          for (          CGNode callee : possibleCallees) {
            if (targetMethods.contains(callee.getMethod())) {
              if (callee.getIR() == null) {
                continue;
              }
              g.addSubgraphForNode(callee);
              PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(retVal));
              }
              handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
            }
          }
        }
 else {
          queryCallTargets(callSiteAndCGNode,getIR(caller),curPkAndState.getState());
        }
      }
    }
  }
}","/** 
 * handle flow from actuals to formals, and from returned values to variables at the caller
 * @param curPk
 * @param handler
 */
private void handleForwInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler){
  PointerKey curPk=curPkAndState.getPointerKey();
  if (curPk instanceof LocalPointerKey) {
    final LocalPointerKey localPk=(LocalPointerKey)curPk;
    if (g.isParam(localPk)) {
      final CGNode callee=localPk.getNode();
      final int paramPos=localPk.getValueNumber() - 1;
      for (      final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(localPk)) {
        final CGNode caller=callSiteAndCGNode.getCGNode();
        final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
        final IR ir=getIR(caller);
        if (ir == null)         continue;
        final ParamLabel paramLabel=ParamLabel.make(callSiteAndCGNode);
        doTransition(curPkAndState.getState(),paramLabel,new Function<State,Object>(){
          private void propagateToCallee(){
            g.addSubgraphForNode(caller);
            SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
            for (int i=0; i < callInstrs.length; i++) {
              SSAAbstractInvokeInstruction callInstr=callInstrs[i];
              PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(actualPk));
                Assertions._assert(g.containsNode(localPk));
              }
              handler.handle(curPkAndState,actualPk,paramLabel);
            }
          }
          public Object apply(          State callerState){
            SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
            PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
            Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)actualPk);
            if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
              propagateToCallee();
            }
 else {
              if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
                propagateToCallee();
              }
 else {
                queryCallTargets(callSiteAndCGNode,ir,callerState);
              }
            }
            return null;
          }
        }
);
      }
    }
    SSAInvokeInstruction callInstr=g.getInstrReturningTo(localPk);
    if (callInstr != null) {
      CGNode caller=localPk.getNode();
      boolean isExceptional=localPk.getValueNumber() == callInstr.getException();
      CallSiteReference callSiteRef=callInstr.getCallSite();
      CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
      Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
      if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
        for (        CGNode callee : possibleCallees) {
          if (callee.getIR() == null) {
            continue;
          }
          g.addSubgraphForNode(callee);
          PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
          if (Assertions.verifyAssertions) {
            Assertions._assert(g.containsNode(retVal));
          }
          handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
        }
      }
 else {
        if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
          Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
          for (          CGNode callee : possibleCallees) {
            if (targetMethods.contains(callee.getMethod())) {
              if (callee.getIR() == null) {
                continue;
              }
              g.addSubgraphForNode(callee);
              PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(retVal));
              }
              handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
            }
          }
        }
 else {
          queryCallTargets(callSiteAndCGNode,getIR(caller),curPkAndState.getState());
        }
      }
    }
  }
}",0.962078163052302
40606,"private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals){
}","private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
    Trace.println(""String_Node_Str"" + pkAndState + ""String_Node_Str"");
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(vals)) {
      Trace.println(ikAndState);
    }
    Trace.println(""String_Node_Str"");
  }
  return added;
}",0.2265552460538533
40607,"public AbstractDemandFlowGraph(final CallGraph cg,final HeapModel heapModel,final MemoryAccessMap mam,final ClassHierarchy cha){
  this.cg=cg;
  this.heapModel=heapModel;
  this.mam=mam;
  this.cha=cha;
}","public AbstractDemandFlowGraph(final CallGraph cg,final HeapModel heapModel,final MemoryAccessMap mam,final ClassHierarchy cha){
  super(mam,heapModel);
  this.cg=cg;
  this.cha=cha;
}",0.8247422680412371
40608,"public Set<CGNode> getPossibleTargets(CGNode node,CallSiteReference site){
  return cg.getPossibleTargets(node,site);
}","public Set<CGNode> getPossibleTargets(CGNode node,CallSiteReference site,LocalPointerKey actualPk){
  return cg.getPossibleTargets(node,site);
}",0.9049429657794676
40609,"private void addPhiConstraints(CGNode node,ControlFlowGraph<ISSABasicBlock> cfg,ISSABasicBlock b){
  for (Iterator<? extends IBasicBlock> iter=cfg.getSuccNodes(b); iter.hasNext(); ) {
    ISSABasicBlock sb=(ISSABasicBlock)iter.next();
    if (sb.isExitBlock()) {
      continue;
    }
    int n=0;
    for (Iterator<? extends IBasicBlock> back=cfg.getPredNodes(sb); back.hasNext(); n++) {
      if (back.next() == b) {
        break;
      }
    }
    if (DEBUG && Assertions.verifyAssertions) {
      Assertions._assert(n < cfg.getPredNodeCount(sb));
    }
    for (Iterator<SSAPhiInstruction> phis=sb.iteratePhis(); phis.hasNext(); ) {
      SSAPhiInstruction phi=phis.next();
      if (phi == null) {
        continue;
      }
      PointerKey def=heapModel.getPointerKeyForLocal(node,phi.getDef());
      if (phi.getUse(n) > 0) {
        PointerKey use=heapModel.getPointerKeyForLocal(node,phi.getUse(n));
        addNode(def);
        addNode(use);
        addEdge(def,use,AssignLabel.v());
      }
    }
  }
}","private void addPhiConstraints(CGNode node,ControlFlowGraph<ISSABasicBlock> cfg,ISSABasicBlock b){
  for (Iterator<? extends IBasicBlock> iter=cfg.getSuccNodes(b); iter.hasNext(); ) {
    ISSABasicBlock sb=(ISSABasicBlock)iter.next();
    if (sb.isExitBlock()) {
      continue;
    }
    int n=0;
    for (Iterator<? extends IBasicBlock> back=cfg.getPredNodes(sb); back.hasNext(); n++) {
      if (back.next() == b) {
        break;
      }
    }
    if (DEBUG && Assertions.verifyAssertions) {
      Assertions._assert(n < cfg.getPredNodeCount(sb));
    }
    for (Iterator<SSAPhiInstruction> phis=sb.iteratePhis(); phis.hasNext(); ) {
      SSAPhiInstruction phi=phis.next();
      if (phi == null) {
        continue;
      }
      PointerKey def=heapModel.getPointerKeyForLocal(node,phi.getDef());
      if (phi.getUse(n) > 0) {
        PointerKey use=heapModel.getPointerKeyForLocal(node,phi.getUse(n));
        addNode(def);
        addNode(use);
        addEdge(def,use,AssignLabel.noFilter());
      }
    }
  }
}",0.9955817378497792
40610,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.v());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.v());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}",0.9955839057899902
40611,"public static ApplicationWindow run(String classpath){
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(classpath,new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Graph<IClass> g=typeHierarchy2Graph(cha);
    g=pruneForAppLoader(g);
    final SWTTreeViewer v=new SWTTreeViewer();
    v.setGraphInput(g);
    Collection<IClass> roots=InferGraphRoots.inferRoots(g);
    if (roots.size() < 1) {
      System.err.println(""String_Node_Str"" + roots.size());
      System.exit(-1);
    }
    v.setRootsInput(roots);
    v.run();
    return v.getApplicationWindow();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","public static ApplicationWindow run(String classpath){
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(classpath,FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Graph<IClass> g=typeHierarchy2Graph(cha);
    g=pruneForAppLoader(g);
    final SWTTreeViewer v=new SWTTreeViewer();
    v.setGraphInput(g);
    Collection<IClass> roots=InferGraphRoots.inferRoots(g);
    if (roots.size() < 1) {
      System.err.println(""String_Node_Str"" + roots.size());
      System.exit(-1);
    }
    v.setRootsInput(roots);
    v.run();
    return v.getApplicationWindow();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.9863013698630136
40612,"/** 
 * Initialize the visitor used to perform the flow functions
 */
protected void init(BasicStackMachineVisitor v,com.ibm.wala.shrikeBT.Instruction.Visitor ev){
  this.visitor=v;
  this.edgeVisitor=ev;
}","/** 
 * Initialize the visitors used to perform the flow functions
 */
protected void init(BasicStackMachineVisitor v,com.ibm.wala.shrikeBT.Instruction.Visitor ev){
  this.visitor=v;
  this.edgeVisitor=ev;
}",0.9975786924939468
40613,"@Override public int hashCode(){
  return 3691 * phi.hashCode() + getNode().hashCode();
}","@Override public int hashCode(){
  return 3691 * phi.getDef() + getNode().hashCode();
}",0.9318181818181818
40614,"@Override public int hashCode(){
  return 3691 * pi.hashCode() + getNode().hashCode();
}","@Override public int hashCode(){
  return 3691 * pi.getDef() + getNode().hashCode();
}",0.9310344827586208
40615,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    PiStatement other=(PiStatement)obj;
    return getNode().equals(other.getNode()) && pi.equals(other.pi);
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    PiStatement other=(PiStatement)obj;
    return getNode().equals(other.getNode()) && pi.getDef() == other.getPi().getDef();
  }
 else {
    return false;
  }
}",0.8028169014084507
40616,"public Pair<Integer,SSAInstruction> getPi(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  Pair<Integer,SSAInstruction> result=p1.getPi(cond,def1,def2,symbolTable);
  if (result != null) {
    return result;
  }
  return p2.getPi(cond,def1,def2,symbolTable);
}","public Pair<Integer,SSAInstruction> getPi(SSAAbstractInvokeInstruction call,SymbolTable symbolTable){
  Pair<Integer,SSAInstruction> result=p1.getPi(call,symbolTable);
  if (result != null) {
    return result;
  }
  return p2.getPi(call,symbolTable);
}",0.7627416520210897
40617,"public Pair<Integer,SSAInstruction> getPi(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  if (def1 instanceof SSAInstanceofInstruction) {
    if (symbolTable.isBooleanOrZeroOneConstant(cond.getUse(1))) {
      return Pair.make(def1.getUse(0),def1);
    }
  }
  if (def2 instanceof SSAInstanceofInstruction) {
    if (symbolTable.isBooleanOrZeroOneConstant(cond.getUse(0))) {
      return Pair.make(def2.getUse(0),def2);
    }
  }
  return null;
}","public Pair<Integer,SSAInstruction> getPi(SSAAbstractInvokeInstruction call,SymbolTable symbolTable){
  return null;
}",0.3381642512077294
40618,"public Pair<Integer,SSAInstruction> getPi(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  if (symbolTable.isNullConstant(cond.getUse(1))) {
    return Pair.<Integer,SSAInstruction>make(cond.getUse(0),cond);
  }
  if (symbolTable.isNullConstant(cond.getUse(0))) {
    return Pair.<Integer,SSAInstruction>make(cond.getUse(1),cond);
  }
  return null;
}","public Pair<Integer,SSAInstruction> getPi(SSAAbstractInvokeInstruction call,SymbolTable symbolTable){
  return null;
}",0.4
40619,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitSwitch(SwitchInstruction)
 */
@Override public void visitSwitch(com.ibm.wala.shrikeBT.SwitchInstruction instruction){
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitSwitch(SwitchInstruction)
 */
@Override public void visitSwitch(com.ibm.wala.shrikeBT.SwitchInstruction instruction){
  int val=workingState.pop();
  emitInstruction(new SSASwitchInstruction(val,instruction.getDefaultLabel(),instruction.getCasesAndLabels()));
}",0.716
40620,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitInvoke(InvokeInstruction)
 */
@Override public void visitInvoke(com.ibm.wala.shrikeBT.InvokeInstruction instruction){
  int n=instruction.getPoppedCount();
  int[] params=new int[n];
  for (int i=n - 1; i >= 0; i--) {
    params[i]=workingState.pop();
  }
  MethodReference m=MethodReference.findOrCreate(loader,instruction.getClassType(),instruction.getMethodName(),instruction.getMethodSignature());
  IInvokeInstruction.Dispatch code=ShrikeUtil.getInvocationCode(instruction);
  CallSiteReference site=CallSiteReference.make(getCurrentProgramCounter(),m,code);
  int exc=reuseOrCreateException();
  if (instruction.getPushedWordSize() > 0) {
    int result=reuseOrCreateDef();
    workingState.push(result);
    emitInstruction(new SSAInvokeInstruction(result,params,exc,site));
  }
 else {
    emitInstruction(new SSAInvokeInstruction(params,exc,site));
  }
}","@Override public void visitInvoke(InvokeInstruction instruction){
  maybeInsertPi((SSAAbstractInvokeInstruction)getCurrentInstruction());
}",0.224105461393597
40621,"private void maybeInsertPi(SSAConditionalBranchInstruction cond){
  if (piNodePolicy != null) {
    Pair<Integer,SSAInstruction> pi=piNodePolicy.getPi(cond,creators[cond.getUse(0)],creators[cond.getUse(1)],symbolTable);
    if (pi != null) {
      reuseOrCreatePi(pi.snd,pi.fst);
    }
  }
}","private void maybeInsertPi(SSAConditionalBranchInstruction cond){
  if (piNodePolicy != null) {
    Pair<Integer,SSAInstruction> pi=piNodePolicy.getPi(cond,getDef(cond.getUse(0)),getDef(cond.getUse(1)),symbolTable);
    if (pi != null) {
      reuseOrCreatePi(pi.snd,pi.fst);
    }
  }
}",0.9342560553633218
40622,"/** 
 * @param index -index into IR instruction array
 * @param vn -value number
 */
public String[] getLocalNames(int index,int vn){
  try {
    if (!shrikeCFG.getMethod().hasLocalVariableTable()) {
      return null;
    }
 else {
      int[] localNumbers=findLocalsForValueNumber(index,vn);
      if (localNumbers == null) {
        return null;
      }
 else {
        ShrikeCTMethod m=(ShrikeCTMethod)shrikeCFG.getMethod();
        String[] result=new String[localNumbers.length];
        for (int i=0; i < localNumbers.length; i++) {
          result[i]=m.getLocalVariableName(m.getBytecodeIndex(index),localNumbers[i]);
        }
        return result;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * @param index - index into IR instruction array
 * @param vn - value number
 */
public String[] getLocalNames(int index,int vn){
  try {
    if (!shrikeCFG.getMethod().hasLocalVariableTable()) {
      return null;
    }
 else {
      int[] localNumbers=findLocalsForValueNumber(index,vn);
      if (localNumbers == null) {
        return null;
      }
 else {
        ShrikeCTMethod m=(ShrikeCTMethod)shrikeCFG.getMethod();
        String[] result=new String[localNumbers.length];
        for (int i=0; i < localNumbers.length; i++) {
          result[i]=m.getLocalVariableName(m.getBytecodeIndex(index),localNumbers[i]);
        }
        return result;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}",0.998719590268886
40623,"/** 
 * @param piCause
 * @param ref
 */
private void reuseOrCreatePi(SSAInstruction piCause,int ref){
  int n=getCurrentInstructionIndex();
  SSACFG.BasicBlock bb=cfg.getBlockForInstruction(n);
  BasicBlock path=getCurrentSuccessor();
  int outNum=shrikeCFG.getNumber(path);
  SSAPiInstruction pi=bb.getPiForRefAndPath(ref,path);
  if (pi == null) {
    pi=new SSAPiInstruction(symbolTable.newSymbol(),ref,outNum,piCause);
    bb.addPiForRefAndPath(ref,path,pi);
  }
  workingState.replaceValue(ref,pi.getDef());
}","/** 
 * @param piCause
 * @param ref
 */
private void reuseOrCreatePi(SSAInstruction piCause,int ref){
  int n=getCurrentInstructionIndex();
  SSACFG.BasicBlock bb=cfg.getBlockForInstruction(n);
  BasicBlock path=getCurrentSuccessor();
  int outNum=shrikeCFG.getNumber(path);
  SSAPiInstruction pi=bb.getPiForRefAndPath(ref,path);
  if (pi == null) {
    pi=new SSAPiInstruction(symbolTable.newSymbol(),ref,bb.getNumber(),outNum,piCause);
    bb.addPiForRefAndPath(ref,path,pi);
  }
  workingState.replaceValue(ref,pi.getDef());
}",0.985645933014354
40624,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vncorresponds to some set of locals, then return an array of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, thenreturn an array of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}",0.9986754966887416
40625,"@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (defs != null && defs.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (uses != null && uses.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSAPiInstruction(defs == null ? result : defs[0],uses == null ? val : uses[0],successorBlock,cause);
}","@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (defs != null && defs.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (uses != null && uses.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSAPiInstruction(defs == null ? result : defs[0],uses == null ? val : uses[0],piBlock,successorBlock,cause);
}",0.9671717171717172
40626,"/** 
 * @param s the successor block; this PI assignment happens on the transition between this basic block andthe successor block.
 */
SSAPiInstruction(int result,int val,int s,SSAInstruction cause){
  super(null,result,val);
  this.cause=cause;
  this.successorBlock=s;
}","/** 
 * @param s the successor block; this PI assignment happens on the transition between this basic block andthe successor block.
 */
SSAPiInstruction(int result,int val,int piBlock,int s,SSAInstruction cause){
  super(null,result,val);
  this.cause=cause;
  this.successorBlock=s;
  this.piBlock=piBlock;
}",0.9381443298969072
40627,"/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  BasicBlock entry=new BasicBlock(-1,-2);
  addNode(entry);
  this.entry=entry;
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  if (instructions.length > 0) {
    final boolean[] r=new boolean[instructions.length];
    r[0]=true;
    BranchVisitor branchVisitor=makeBranchVisitor(r);
    PEIVisitor peiVisitor=makePEIVisitor(r);
    for (int i=0; i < instructions.length; i++) {
      if (instructions[i] != null) {
        branchVisitor.setIndex(i);
        instructions[i].visit(branchVisitor);
        peiVisitor.setIndex(i);
        instructions[i].visit(peiVisitor);
      }
    }
    BasicBlock b=null;
    for (int i=0; i < r.length; i++) {
      if (r[i]) {
        int end=instructions.length - 1;
        for (int j=i; j < instructions.length; j++) {
          if (r[j]) {
            end=j;
            break;
          }
        }
        b=new BasicBlock(i,end);
        addNode(b);
      }
      i2block[i]=b;
    }
  }
  BasicBlock exit=new BasicBlock(-3,-4);
  addNode(exit);
  this.exit=exit;
}","/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  BasicBlock entry=new BasicBlock(-1,-2);
  addNode(entry);
  this.entry=entry;
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  if (instructions.length > 0) {
    final boolean[] r=new boolean[instructions.length];
    r[0]=true;
    BranchVisitor branchVisitor=makeBranchVisitor(r);
    PEIVisitor peiVisitor=makePEIVisitor(r);
    for (int i=0; i < instructions.length; i++) {
      if (instructions[i] != null) {
        branchVisitor.setIndex(i);
        instructions[i].visit(branchVisitor);
        peiVisitor.setIndex(i);
        instructions[i].visit(peiVisitor);
      }
    }
    BasicBlock b=null;
    for (int i=0; i < r.length; i++) {
      if (r[i]) {
        int end=instructions.length - 1;
        for (int j=i + 1; j < instructions.length; j++) {
          if (r[j]) {
            end=j;
            break;
          }
        }
        b=new BasicBlock(i,end);
        addNode(b);
      }
      i2block[i]=b;
    }
  }
  BasicBlock exit=new BasicBlock(-3,-4);
  addNode(exit);
  this.exit=exit;
}",0.9982547993019196
40628,"/** 
 * Add constraints for a call site after we have computed a reachable target for the dispatch Side effect: add edge to the call graph.
 * @param instruction
 * @param constParams if non-null, then constParams[i] holds the set of instance keys that are passed as param i, or null if param i is not invariant
 * @param uniqueCatchKey if non-null, then this is the unique PointerKey that catches all exceptions from this call site.
 */
@SuppressWarnings(""String_Node_Str"") private void processResolvedCall(CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  caller.addTarget(instruction.getCallSite(),target);
  if (FakeRootMethod.isFakeRootMethod(caller.getMethod().getReference())) {
    if (entrypointCallSites.contains(instruction.getCallSite())) {
      callGraph.registerEntrypoint(target);
    }
  }
  if (!haveAlreadyVisited(target)) {
    markDiscovered(target);
  }
  int nUses=instruction.getNumberOfParameters();
  int nExpected=target.getMethod().getNumberOfParameters();
  if (nUses != nExpected) {
    Warnings.add(ResolutionFailure.create(target,instruction,""String_Node_Str"" + nUses + ""String_Node_Str""+ nExpected));
    return;
  }
  boolean needsFilter=!instruction.getCallSite().isStatic() && needsFilterForReceiver(instruction,target);
  for (int i=0; i < instruction.getNumberOfParameters(); i++) {
    final int vn=i + 1;
    if (target.getMethod().getParameterType(i).isReferenceType()) {
      if (constParams != null && constParams[i] != null) {
        InstanceKey[] ik=constParams[i];
        for (int j=0; j < ik.length; j++) {
          if (needsFilter && (i == 0)) {
            FilteredPointerKey.TypeFilter C=getFilter(target);
            PointerKey formal=null;
            if (isRootType(C)) {
              formal=getPointerKeyForLocal(target,vn);
            }
 else {
              formal=getFilteredPointerKeyForLocal(target,vn,C);
            }
            system.newConstraint(formal,ik[j]);
          }
 else {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,ik[j]);
          }
        }
      }
 else {
        if (Assertions.verifyAssertions) {
          if (instruction.getUse(i) < 0) {
            Assertions.UNREACHABLE(""String_Node_Str"" + instruction + ""String_Node_Str""+ caller);
          }
        }
        PointerKey actual=getPointerKeyForLocal(caller,instruction.getUse(i));
        if (needsFilter && (i == 0)) {
          FilteredPointerKey.TypeFilter C=getFilter(target);
          if (isRootType(C)) {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,assignOperator,actual);
          }
 else {
            FilteredPointerKey formal=getFilteredPointerKeyForLocal(target,vn,C);
            system.newConstraint(formal,filterOperator,actual);
          }
        }
 else {
          PointerKey formal=getPointerKeyForLocal(target,vn);
          system.newConstraint(formal,assignOperator,actual);
        }
      }
    }
  }
  if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
    PointerKey result=getPointerKeyForLocal(caller,instruction.getDef());
    PointerKey ret=getPointerKeyForReturnValue(target);
    system.newConstraint(result,assignOperator,ret);
  }
  PointerKey e=getPointerKeyForLocal(caller,instruction.getException());
  PointerKey er=getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,er);
  }
 else {
    system.newConstraint(e,assignOperator,er);
  }
}","/** 
 * Add constraints for a call site after we have computed a reachable target for the dispatch Side effect: add edge to the call graph.
 * @param instruction
 * @param constParams if non-null, then constParams[i] holds the set of instance keys that are passed as param i, ornull if param i is not invariant
 * @param uniqueCatchKey if non-null, then this is the unique PointerKey that catches all exceptions from this callsite.
 */
@SuppressWarnings(""String_Node_Str"") private void processResolvedCall(CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  caller.addTarget(instruction.getCallSite(),target);
  if (FakeRootMethod.isFakeRootMethod(caller.getMethod().getReference())) {
    if (entrypointCallSites.contains(instruction.getCallSite())) {
      callGraph.registerEntrypoint(target);
    }
  }
  if (!haveAlreadyVisited(target)) {
    markDiscovered(target);
  }
  int nUses=instruction.getNumberOfParameters();
  int nExpected=target.getMethod().getNumberOfParameters();
  if (nUses != nExpected) {
    Warnings.add(ResolutionFailure.create(target,instruction,""String_Node_Str"" + nUses + ""String_Node_Str""+ nExpected));
    return;
  }
  boolean needsFilter=!instruction.getCallSite().isStatic() && needsFilterForReceiver(instruction,target);
  for (int i=0; i < instruction.getNumberOfParameters(); i++) {
    final int vn=i + 1;
    if (target.getMethod().getParameterType(i).isReferenceType()) {
      if (constParams != null && constParams[i] != null) {
        InstanceKey[] ik=constParams[i];
        for (int j=0; j < ik.length; j++) {
          if (needsFilter && (i == 0)) {
            FilteredPointerKey.TypeFilter C=getFilter(target);
            PointerKey formal=null;
            if (isRootType(C)) {
              formal=getPointerKeyForLocal(target,vn);
            }
 else {
              formal=getFilteredPointerKeyForLocal(target,vn,C);
            }
            system.newConstraint(formal,ik[j]);
          }
 else {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,ik[j]);
          }
        }
      }
 else {
        if (Assertions.verifyAssertions) {
          if (instruction.getUse(i) < 0) {
            Assertions.UNREACHABLE(""String_Node_Str"" + instruction + ""String_Node_Str""+ caller);
          }
        }
        PointerKey actual=getPointerKeyForLocal(caller,instruction.getUse(i));
        if (needsFilter && (i == 0)) {
          FilteredPointerKey.TypeFilter C=getFilter(target);
          if (isRootType(C)) {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,assignOperator,actual);
          }
 else {
            FilteredPointerKey formal=getFilteredPointerKeyForLocal(target,vn,C);
            system.newConstraint(formal,filterOperator,actual);
          }
        }
 else {
          PointerKey formal=getPointerKeyForLocal(target,vn);
          system.newConstraint(formal,assignOperator,actual);
        }
      }
    }
  }
  if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
    PointerKey result=getPointerKeyForLocal(caller,instruction.getDef());
    PointerKey ret=getPointerKeyForReturnValue(target);
    system.newConstraint(result,assignOperator,ret);
  }
  PointerKey e=getPointerKeyForLocal(caller,instruction.getException());
  PointerKey er=getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,er);
  }
 else {
    system.newConstraint(e,assignOperator,er);
  }
}",0.9997454823110206
40629,"/** 
 * @param call
 * @param node
 * @param constParams if non-null, then constParams[i] holds the String constant that is passed as param i, or null if param i is not a String constant
 */
DispatchOperator(SSAAbstractInvokeInstruction call,ExplicitCallGraph.ExplicitNode node,InstanceKey[][] constParams,PointerKey uniqueCatch){
  this.call=call;
  this.node=node;
  this.constParams=constParams;
  this.uniqueCatch=uniqueCatch;
}","/** 
 * @param call
 * @param node
 * @param constParams if non-null, then constParams[i] holds the String constant that is passed as param i, or nullif param i is not a String constant
 */
DispatchOperator(SSAAbstractInvokeInstruction call,ExplicitCallGraph.ExplicitNode node,InstanceKey[][] constParams,PointerKey uniqueCatch){
  this.call=call;
  this.node=node;
  this.constParams=constParams;
  this.uniqueCatch=uniqueCatch;
}",0.9988412514484356
40630,"private int booleanConstantTest(SSAConditionalBranchInstruction c,int v){
  int result=0;
  if ((symbolTable.isZeroOrFalse(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isZeroOrFalse(c.getUse(1)) && c.getUse(0) == v)) {
    result=-1;
  }
 else   if ((symbolTable.isOneOrTrue(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isOneOrTrue(c.getUse(1)) && c.getUse(0) == v)) {
    result=1;
  }
  if (c.getOperator() == ConditionalBranchInstruction.Operator.NE) {
    result=-result;
  }
  return result;
}","/** 
 * TODO: What is this doing? Document me!
 */
private int booleanConstantTest(SSAConditionalBranchInstruction c,int v){
  int result=0;
  if ((symbolTable.isZeroOrFalse(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isZeroOrFalse(c.getUse(1)) && c.getUse(0) == v)) {
    result=-1;
  }
 else   if ((symbolTable.isOneOrTrue(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isOneOrTrue(c.getUse(1)) && c.getUse(0) == v)) {
    result=1;
  }
  if (c.getOperator() == ConditionalBranchInstruction.Operator.NE) {
    result=-result;
  }
  return result;
}",0.9522024367385192
40631,"/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 * @param klass
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (target != null && callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}","/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (target != null && callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}",0.9950124688279302
40632,"/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 * @param klass
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}","/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 * @param klass
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (target != null && callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}",0.9943855271366188
40633,"/** 
 * @param appJar something like ""c:/temp/testdata/java_cup.jar""
 * @return a call graph
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Graph<CGNode> buildPrunedCallGraph(String appJar,File exclusionFile) throws WalaException, IllegalArgumentException, CancelException {
  AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,exclusionFile != null ? exclusionFile : new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha);
  AnalysisOptions options=new AnalysisOptions(scope,entrypoints);
  com.ibm.wala.ipa.callgraph.CallGraphBuilder builder=Util.makeZeroOneContainerCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  System.err.println(CallGraphStats.getStats(cg));
  Graph<CGNode> g=pruneForAppLoader(cg);
  return g;
}","/** 
 * @param appJar something like ""c:/temp/testdata/java_cup.jar""
 * @return a call graph
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Graph<CGNode> buildPrunedCallGraph(String appJar,File exclusionFile) throws WalaException, IllegalArgumentException, CancelException {
  AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,exclusionFile != null ? exclusionFile : new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha);
  AnalysisOptions options=new AnalysisOptions(scope,entrypoints);
  com.ibm.wala.ipa.callgraph.CallGraphBuilder builder=Util.makeZeroCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  System.err.println(CallGraphStats.getStats(cg));
  Graph<CGNode> g=pruneForAppLoader(cg);
  return g;
}",0.9938335046248716
40634,"public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return getTypesForContext(node.getContext()) != null;
}","public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (node.getMethod().isSynthetic()) {
    SyntheticMethod s=(SyntheticMethod)node.getMethod();
    if (s.isFactoryMethod()) {
      return getTypesForContext(node.getContext()) != null;
    }
  }
  return false;
}",0.6984732824427481
40635,"/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  final boolean[] r=new boolean[instructions.length];
  r[0]=true;
  BranchVisitor branchVisitor=makeBranchVisitor(r);
  PEIVisitor peiVisitor=makePEIVisitor(r);
  for (int i=0; i < instructions.length; i++) {
    if (instructions[i] != null) {
      branchVisitor.setIndex(i);
      instructions[i].visit(branchVisitor);
      peiVisitor.setIndex(i);
      instructions[i].visit(peiVisitor);
    }
  }
  BasicBlock b=null;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      b=new BasicBlock(i);
      addNode(b);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + b);
      }
    }
    i2block[i]=b;
  }
  BasicBlock exit=new BasicBlock(-1);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + exit);
  }
  addNode(exit);
}","/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  BasicBlock entry=new BasicBlock(-1,-2);
  addNode(entry);
  this.entry=entry;
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  if (instructions.length > 0) {
    final boolean[] r=new boolean[instructions.length];
    r[0]=true;
    BranchVisitor branchVisitor=makeBranchVisitor(r);
    PEIVisitor peiVisitor=makePEIVisitor(r);
    for (int i=0; i < instructions.length; i++) {
      if (instructions[i] != null) {
        branchVisitor.setIndex(i);
        instructions[i].visit(branchVisitor);
        peiVisitor.setIndex(i);
        instructions[i].visit(peiVisitor);
      }
    }
    BasicBlock b=null;
    for (int i=0; i < r.length; i++) {
      if (r[i]) {
        int end=instructions.length - 1;
        for (int j=i; j < instructions.length; j++) {
          if (r[j]) {
            end=j;
            break;
          }
        }
        b=new BasicBlock(i,end);
        addNode(b);
      }
      i2block[i]=b;
    }
  }
  BasicBlock exit=new BasicBlock(-3,-4);
  addNode(exit);
  this.exit=exit;
}",0.6679574056147144
40636,"BasicBlock(int start){
  this.start=start;
}","BasicBlock(int start,int end){
  this.start=start;
  this.end=end;
}",0.7857142857142857
40637,"/** 
 * TODO: we do not yet support induced CFGS with exception handlers.
 * @param instructions
 * @throws IllegalArgumentException  if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + method);
  }
  i2block=new BasicBlock[instructions.length];
  if (instructions.length == 0) {
    makeEmptyBlocks();
  }
 else {
    makeBasicBlocks();
  }
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","/** 
 * TODO: we do not yet support induced CFGS with exception handlers.
 * @param instructions
 * @throws IllegalArgumentException if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  i2block=new BasicBlock[instructions.length];
  makeBasicBlocks();
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.8988015978695073
40638,"public boolean isEntryBlock(){
  return getNumber() == 0;
}","public boolean isEntryBlock(){
  return this.equals(entry);
}",0.7833333333333333
40639,"/** 
 * Method getLastInstructionIndex.
 * @return int
 */
public int getLastInstructionIndex(){
  int exitNumber=InducedCFG.this.getNumber(exit());
  if (getGraphNodeId() == exitNumber) {
    return -2;
  }
  if (getGraphNodeId() == (exitNumber - 1)) {
    return getInstructions().length - 1;
  }
 else {
    BasicBlock next=getNode(getGraphNodeId() + 1);
    return next.getFirstInstructionIndex() - 1;
  }
}","public int getLastInstructionIndex(){
  return end;
}",0.2155172413793103
40640,"public boolean isExitBlock(){
  return getLastInstructionIndex() == -2;
}","public boolean isExitBlock(){
  return this.equals(exit);
}",0.7272727272727273
40641,"/** 
 * Compute outgoing edges in the control flow graph.
 */
private void computeEdges(){
  for (Iterator it=iterator(); it.hasNext(); ) {
    BasicBlock b=(BasicBlock)it.next();
    if (b.equals(exit()))     continue;
    b.computeOutgoingEdges();
  }
}","/** 
 * Compute outgoing edges in the control flow graph.
 */
private void computeEdges(){
  for (Iterator it=iterator(); it.hasNext(); ) {
    BasicBlock b=(BasicBlock)it.next();
    if (b.equals(exit()))     continue;
    if (b.equals(entry())) {
      addNormalEdge(b,getNode(b.getGraphNodeId() + 1));
      continue;
    }
    SSAInstruction last=(SSAInstruction)getInstructions()[b.getLastInstructionIndex()];
    if (last.isPEI()) {
      addExceptionalEdge(b,exit());
    }
    if (true) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + getNode(b.getGraphNodeId() + 1));
      }
      addNormalEdge(b,getNode(b.getGraphNodeId() + 1));
    }
    if (last instanceof SSAReturnInstruction) {
      BasicBlock exit=exit();
      addNormalEdge(b,exit);
    }
  }
}",0.4521739130434782
40642,"public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(22,slice.size());
}","public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(30,slice.size());
}",0.9981220657276996
40643,"/** 
 * Get the WCCM archive representing a particular module
 * @param M the module to analyze
 * @return Archive, or null if no WCCM conversion is possible
 */
@SuppressWarnings(""String_Node_Str"") public static Archive getArchive(Module M){
  CommonarchiveFactory factory=CommonarchiveFactoryImpl.getActiveFactory();
  try {
    if (M instanceof JarFileModule) {
      String fileName=((JarFileModule)M).getAbsolutePath();
      return factory.openArchive(fileName);
    }
 else     if (M instanceof TopLevelArchiveModule) {
      TopLevelArchiveModule AM=(TopLevelArchiveModule)M;
      return AM.materializeArchive();
    }
 else     if (M instanceof ClassFileModule) {
      return null;
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + M.getClass());
      return null;
    }
  }
 catch (  OpenFailureException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * Get the WCCM archive representing a particular module
 * @param M the module to analyze
 * @return Archive, or null if no WCCM conversion is possible
 */
@SuppressWarnings(""String_Node_Str"") public static Archive getArchive(Module M){
  CommonarchiveFactory factory=CommonarchiveFactoryImpl.getActiveFactory();
  try {
    if (M instanceof JarFileModule) {
      String fileName=((JarFileModule)M).getAbsolutePath();
      return factory.openArchive(fileName);
    }
 else     if (M instanceof TopLevelArchiveModule) {
      TopLevelArchiveModule AM=(TopLevelArchiveModule)M;
      return AM.materializeArchive();
    }
 else     if (M instanceof ClassFileModule) {
      return null;
    }
 else {
      return null;
    }
  }
 catch (  OpenFailureException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}",0.8410896708286039
40644,"/** 
 * Dump stats about the class hierarchy to stdout.
 * @param cha
 */
public static void printStats(ClassHierarchy cha) throws IllegalArgumentException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IClassLoader[] loaders=cha.getLoaders();
  for (int i=0; i < loaders.length; i++) {
    System.out.println(""String_Node_Str"" + loaders[i]);
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfClasses());
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfMethods());
  }
}","/** 
 * Dump stats about the class hierarchy to stdout.
 * @param cha
 */
public static void printStats(IClassHierarchy cha) throws IllegalArgumentException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IClassLoader[] loaders=cha.getLoaders();
  for (int i=0; i < loaders.length; i++) {
    System.out.println(""String_Node_Str"" + loaders[i]);
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfClasses());
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfMethods());
  }
}",0.999080036798528
40645,"/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  return false;
}","/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.getDeclaringClass().equals(TypeReference.JavaLangSystem)) {
    if (m.getName().toString().equals(""String_Node_Str"")) {
      return true;
    }
  }
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  return false;
}",0.8197474167623421
40646,"/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<? extends ISSABasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExplodedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement){
switch (s.getKind()) {
case NORMAL:
    NormalStatement n=(NormalStatement)s;
  Collection<PointerKey> ref=modRef.getRef(node,h,pa,n.getInstruction(),exclusions);
if (!ref.isEmpty()) {
  ISSABasicBlock bb=cfg.getBlockForInstruction(n.getInstructionIndex());
  BitVectorVariable v=solver.getIn(bb);
  MutableSparseIntSet defs=MutableSparseIntSet.makeEmpty();
  for (  PointerKey p : ref) {
    if (pointerKeyMod.get(p) != null) {
      defs.addAll(pointerKeyMod.get(p).intersection(v.getValue()));
    }
  }
  return new OrdinalSet<Statement>(defs,domain);
}
 else {
  return OrdinalSet.empty();
}
case HEAP_RET_CALLEE:
{
HeapStatement.ReturnCallee r=(HeapStatement.ReturnCallee)s;
PointerKey p=r.getLocation();
BitVectorVariable v=solver.getIn(cfg.exit());
if (pointerKeyMod.get(p) == null) {
  return OrdinalSet.empty();
}
return new OrdinalSet<Statement>(pointerKeyMod.get(p).intersection(v.getValue()),domain);
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)s;
ISSABasicBlock bb=cfg.getBlockForInstruction(r.getCallIndex());
BitVectorVariable v=solver.getIn(bb);
if (allCalleesMod(cg,r,mod) || pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case HEAP_PARAM_CALLER:
{
HeapStatement.ParamCaller r=(HeapStatement.ParamCaller)s;
NormalStatement call=ssaInstructionIndex2Statement.get(r.getCallIndex());
ISSABasicBlock callBlock=cfg.getBlockForInstruction(call.getInstructionIndex());
BitVectorVariable v=solver.getIn(callBlock);
if (pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PARAM_CALLER:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case PHI:
case PI:
case CATCH:
case METHOD_ENTRY:
return OrdinalSet.empty();
case HEAP_PARAM_CALLEE:
return OrdinalSet.empty();
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<? extends ISSABasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExplodedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement){
}",0.2958656330749354
40647,"private Set getTypesForContext(Context context){
  XMLReflectionReader spec=(XMLReflectionReader)userSpec;
  if (spec != null && context instanceof CallerSiteContext) {
    CallerSiteContext site=(CallerSiteContext)context;
    MemberReference m=site.getCaller().getMethod().getReference();
    ReflectionSummary summary=spec.getSummary(m);
    if (summary != null) {
      Set types=summary.getTypesForProgramLocation(site.getSite().getProgramCounter());
      if (types != null) {
        return types;
      }
    }
  }
  Set types=map.get(context);
  return types;
}","private Set getTypesForContext(Context context){
  XMLReflectionReader spec=(XMLReflectionReader)userSpec;
  if (spec != null && context instanceof CallerSiteContext) {
    CallerSiteContext site=(CallerSiteContext)context;
    MemberReference m=site.getCaller().getMethod().getReference();
    ReflectionSummary summary=spec.getSummary(m);
    if (summary != null) {
      Set types=summary.getTypesForProgramLocation(site.getCallSite().getProgramCounter());
      if (types != null) {
        return types;
      }
    }
  }
  Set types=map.get(context);
  return types;
}",0.9965034965034965
40648,"@Override public int hashCode(){
  return programCounter;
}","@Override public int hashCode(){
  return programCounter + 77;
}",0.959349593495935
40649,"@Override public int hashCode(){
  return callSite.hashCode() * super.hashCode();
}","@Override public int hashCode(){
  return callSite.hashCode() * 19 + super.hashCode();
}",0.9707602339181286
40650,"/** 
 * Compute an analysis scope for the current selection
 */
protected AnalysisScope computeScope(){
  IStructuredSelection selection=(IStructuredSelection)currentSelection;
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(ResourcesPlugin.getWorkspace().getRoot().getLocation(),jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}","/** 
 * Compute an analysis scope for the current selection
 * @throws IOException 
 * @throws JavaModelException 
 */
protected AnalysisScope computeScope() throws JavaModelException, IOException {
  IStructuredSelection selection=(IStructuredSelection)currentSelection;
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(ResourcesPlugin.getWorkspace().getRoot().getLocation(),jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}",0.937623112278398
40651,"private EclipseProjectPath(IPath workspaceRootPath,IJavaProject project){
}","private EclipseProjectPath(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
}",0.7894736842105263
40652,"public static EclipseProjectPath make(IPath workspaceRootPath,IJavaProject project){
  if (workspaceRootPath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new EclipseProjectPath(workspaceRootPath,project);
}","public static EclipseProjectPath make(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
  if (workspaceRootPath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new EclipseProjectPath(workspaceRootPath,project);
}",0.9242424242424242
40653,"/** 
 * compute the analysis scope for a project in the current workspace
 */
public static AnalysisScope computeScope(String projectName){
  IJavaProject jp=getProjectFromWorkspace(projectName);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  EclipseProjectPath path=EclipseProjectPath.make(workspaceRoot.getLocation(),jp);
  return path.toAnalysisScope(null);
}","/** 
 * compute the analysis scope for a project in the current workspace
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(String projectName) throws JavaModelException, IOException {
  IJavaProject jp=getProjectFromWorkspace(projectName);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  EclipseProjectPath path=EclipseProjectPath.make(workspaceRoot.getLocation(),jp);
  return path.toAnalysisScope(null);
}",0.8914285714285715
40654,"@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.98568167669641
40655,"private void processBytecodesWithShrikeBT(BytecodeInfo info) throws InvalidClassFileException {
  info.decoder=makeDecoder();
  if (Assertions.verifyAssertions) {
    if (!isAbstract() && info.decoder == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + getReference());
    }
  }
  if (info.decoder == null) {
    return;
  }
  info.pcMap=info.decoder.getInstructionsToBytecodes();
  processDebugInfo(info);
  SimpleVisitor simpleVisitor=new SimpleVisitor(info);
  Instruction[] instructions=info.decoder.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    simpleVisitor.setInstructionIndex(i);
    instructions[i].visit(simpleVisitor);
    if (Exceptions.isPEI(instructions[i])) {
      Collection<TypeReference> t=Exceptions.getIndependentExceptionTypes(instructions[i]);
      simpleVisitor.implicitExceptions.addAll(t);
    }
  }
  copyVisitorSetsToArrays(simpleVisitor,info);
}","private void processBytecodesWithShrikeBT(BytecodeInfo info) throws InvalidClassFileException {
  info.decoder=makeDecoder();
  if (Assertions.verifyAssertions) {
    if (!isAbstract() && info.decoder == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + getReference());
    }
  }
  if (info.decoder == null) {
    return;
  }
  info.pcMap=info.decoder.getInstructionsToBytecodes();
  processDebugInfo(info);
  SimpleVisitor simpleVisitor=new SimpleVisitor(info);
  Instruction[] instructions=info.decoder.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    simpleVisitor.setInstructionIndex(i);
    instructions[i].visit(simpleVisitor);
    if (Exceptions.isPEI(instructions[i])) {
      Collection<TypeReference> t=Exceptions.getIndependentExceptionTypes(instructions[i]);
      if (t != null) {
        simpleVisitor.implicitExceptions.addAll(t);
      }
    }
  }
  copyVisitorSetsToArrays(simpleVisitor,info);
}",0.9821717990275528
40656,"@Override public Collection<TypeReference> getExceptionTypes(){
  return Exceptions.getNullPointerException();
}","@Override public Collection<TypeReference> getExceptionTypes(){
  Collection<TypeReference> empty=Collections.emptySet();
  return isStatic() ? empty : Exceptions.getNullPointerException();
}",0.7392739273927392
40657,"/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
case OP_ldiv:
case OP_lrem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}","/** 
 * @param pei a potentially-excepting instruction
 * @return the exception types that pei may throw, independent of the classhierarchy.   null if none. Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
case OP_ldiv:
case OP_lrem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}",0.989247311827957
40658,"/** 
 * @param lifecycleEntrypoints Should EJB lifecycle entrypoints be considered as call graph entrypoints?
 */
public J2EEAnalysisScope(String baseScope,ClassLoader loader,String exclusionsFile,boolean lifecycleEntrypoints){
  super(baseScope,exclusionsFile,loader);
  this.lifecycleEntrypoints=lifecycleEntrypoints;
}","/** 
 * @param lifecycleEntrypoints Should EJB lifecycle entrypoints be considered as call graph entrypoints?
 */
public J2EEAnalysisScope(String baseScope,ClassLoader loader,String exclusionsFile,boolean lifecycleEntrypoints){
  super(Collections.singleton(Language.JAVA));
  AnalysisScope base=AnalysisScopeReader.read(baseScope,exclusionsFile,loader);
  for (  ClassLoaderReference cl : base.getLoaders()) {
    for (    Module m : base.getModules(cl)) {
      addToScope(cl,m);
    }
  }
  if (exclusionsFile != null) {
    FileOfClasses file=new FileOfClasses(exclusionsFile,loader);
    setExclusions(file);
  }
  this.lifecycleEntrypoints=lifecycleEntrypoints;
}",0.6484848484848484
40659,"/** 
 * @throws IllegalArgumentException  if method == null
 */
protected TypeReference[][] makeParameterTypes(IMethod method) throws IllegalArgumentException {
  if (method == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    if (!t.isPrimitiveType()) {
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        t=null;
      }
 else       if (klass.isAbstract()) {
        t=chooseAConcreteSubClass(klass);
      }
 else       if (klass.isInterface()) {
        t=chooseAnImplementor(klass);
      }
 else       if (klass.isArrayClass()) {
        ArrayClass arrayKlass=(ArrayClass)klass;
        IClass innermost=arrayKlass.getInnermostElementClass();
        if (innermost != null && innermost.isInterface()) {
          TypeReference impl=chooseAnImplementor(innermost);
          if (impl == null) {
            t=null;
          }
 else {
            t=TypeReference.findOrCreateArrayOf(impl);
            for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
              t=TypeReference.findOrCreateArrayOf(t);
            }
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}","/** 
 * @throws IllegalArgumentException  if method == null
 */
protected TypeReference[][] makeParameterTypes(IMethod method) throws IllegalArgumentException {
  if (method == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    if (!t.isPrimitiveType()) {
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        t=null;
      }
 else       if (!klass.isInterface() && klass.isAbstract()) {
        t=chooseAConcreteSubClass(klass);
      }
 else       if (klass.isInterface()) {
        t=chooseAnImplementor(klass);
      }
 else       if (klass.isArrayClass()) {
        ArrayClass arrayKlass=(ArrayClass)klass;
        IClass innermost=arrayKlass.getInnermostElementClass();
        if (innermost != null && innermost.isInterface()) {
          TypeReference impl=chooseAnImplementor(innermost);
          if (impl == null) {
            t=null;
          }
 else {
            t=TypeReference.findOrCreateArrayOf(impl);
            for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
              t=TypeReference.findOrCreateArrayOf(t);
            }
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}",0.9914285714285714
40660,"public IVocabulary getVocabulary(){
  return BasicVocabulary.make(Collections.emptySet());
}","public IVocabulary getVocabulary(){
  return BasicVocabulary.make(Collections.<IFunction>emptySet());
}",0.9435897435897436
40661,"protected IClassHierarchy buildClassHierarchy(){
  try {
    return ClassHierarchy.make(getScope(),loaderFactory,JavaScriptLoader.JS);
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE(e.toString());
    return null;
  }
}","public IClassHierarchy buildClassHierarchy(){
  try {
    return ClassHierarchy.make(getScope(),loaderFactory,JavaScriptLoader.JS);
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE(e.toString());
    return null;
  }
}",0.972972972972973
40662,"/** 
 * If s is a call statement, return the statement representing the normal return from s
 */
public static Statement getReturnStatementForCall(Statement s){
  if (s.getKind() == Kind.NORMAL) {
    SSAInstruction st=((NormalStatement)s).getInstruction();
    if (st instanceof SSAInvokeInstruction) {
      return new ParamStatement.NormalReturnCaller(s.getNode(),(SSAInvokeInstruction)st);
    }
 else {
      return s;
    }
  }
 else {
    return s;
  }
}","/** 
 * If s is a call statement, return the statement representing the normal return from s
 */
public static Statement getReturnStatementForCall(Statement s){
  if (s.getKind() == Kind.NORMAL) {
    SSAInstruction st=((NormalStatement)s).getInstruction();
    if (st instanceof SSAInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)st;
      if (call.getCallSite().getDeclaredTarget().getReturnType().equals(TypeReference.Void)) {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + call.getCallSite().getDeclaredTarget().getSignature() + ""String_Node_Str"");
      }
      return new ParamStatement.NormalReturnCaller(s.getNode(),(SSAInvokeInstruction)st);
    }
 else {
      return s;
    }
  }
 else {
    return s;
  }
}",0.7073552425665102
40663,"protected IClassHierarchy buildClassHierarchy(){
  IClassHierarchy cha=null;
  ClassLoaderFactory factory=getClassLoaderFactory(scope.getExclusions(),getTranslatorExtension());
  try {
    cha=ClassHierarchy.make(getScope(),factory);
  }
 catch (  ClassHierarchyException e) {
    System.err.println(""String_Node_Str"");
    System.err.println(e.toString());
    e.printStackTrace();
  }
  return cha;
}","public IClassHierarchy buildClassHierarchy(){
  IClassHierarchy cha=null;
  ClassLoaderFactory factory=getClassLoaderFactory(scope.getExclusions(),getTranslatorExtension());
  try {
    cha=ClassHierarchy.make(getScope(),factory);
  }
 catch (  ClassHierarchyException e) {
    System.err.println(""String_Node_Str"");
    System.err.println(e.toString());
    e.printStackTrace();
  }
  return cha;
}",0.9837702871410736
40664,"public static AnalysisScope makeScope(URL[] files,JavaScriptLoaderFactory loaders) throws IOException {
  return new CAstAnalysisScope(files,loaders);
}","public static AnalysisScope makeScope(URL[] files,JavaScriptLoaderFactory loaders) throws IOException {
  AnalysisScope result=new CAstAnalysisScope(files,loaders);
  result.addLanguageToScope(JavaScriptLoader.JS);
  return result;
}",0.7532467532467533
40665,"public boolean implementsInterface(IClass c,TypeReference T){
  return getHierarchy(c).implementsInterface(c,T);
}","public boolean implementsInterface(IClass c,IClass i){
  return getHierarchy(c).implementsInterface(c,i);
}",0.8959276018099548
40666,"public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  Assertions._assert(!isInterface());
  return gatherInterfaces();
}","public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  return gatherInterfaces();
}",0.8623188405797102
40667,"/** 
 * delete all files (recursively) in a directory. This is dangerous. Use with care.
 * @throws IOException if there's a problem deleting some file
 */
public static void deleteContents(String directory) throws IOException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      boolean result=f.delete();
      if (!result) {
        throw new IOException(""String_Node_Str"" + f);
      }
    }
  }
  int lastCount=Integer.MAX_VALUE;
  do {
    Collection f2=listFiles(directory,null,true);
    if (f2.size() == lastCount) {
      throw new IOException(""String_Node_Str"");
    }
    for (Iterator it=f2.iterator(); it.hasNext(); ) {
      File f=(File)it.next();
      f.delete();
    }
  }
 while (listFiles(directory,null,true).size() > 0);
}","/** 
 * delete all files (recursively) in a directory. This is dangerous. Use with care.
 * @throws IOException if there's a problem deleting some file
 */
public static void deleteContents(String directory) throws IOException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      boolean result=f.delete();
      if (!result) {
        throw new IOException(""String_Node_Str"" + f);
      }
    }
  }
  int lastCount=Integer.MAX_VALUE;
  do {
    Collection f2=listFiles(directory,null,true);
    if (f2.size() == lastCount) {
      throw new IOException(""String_Node_Str"");
    }
    lastCount=f2.size();
    for (Iterator it=f2.iterator(); it.hasNext(); ) {
      File f=(File)it.next();
      f.delete();
    }
  }
 while (listFiles(directory,null,true).size() > 0);
}",0.985607369027058
40668,"public IMethod getCalleeTarget(CGNode N,CallSiteReference site,IClass receiver){
  MethodReference m=site.getDeclaredTarget();
  if (isEJBSuperInterface(m.getDeclaringClass())) {
    IClass inferred=getReceiverClassFromTypeInference(N,site);
    if (inferred != null) {
      receiver=inferred;
    }
  }
  if (FakeRootMethod.isFakeRootMethod(N.getMethod().getReference())) {
    if (deployment.isMessageDriven(m.getDeclaringClass())) {
      if (m.getName().equals(onMessageAtom) && m.getDescriptor().equals(onMessageDesc)) {
        return hijackOnMessageEntrypoint(m);
      }
    }
 else     if (receiver != null && cha.implementsInterface(receiver,ServletEntrypoints.Servlet)) {
      IMethod resolved=cha.resolveMethod(receiver,m.getSelector());
      if (!resolved.isInit() && !resolved.isClinit()) {
        return hijackServletEntrypoint(m);
      }
    }
  }
  m=specializeForReceiverType(receiver,m);
  SyntheticMethod X=methodReferenceIntercept(m);
  if (X != null) {
    return X;
  }
  IMethod target=parent.getCalleeTarget(N,site,receiver);
  if (target == null) {
    return null;
  }
  X=methodReferenceIntercept(target.getReference());
  if (X != null) {
    return X;
  }
 else {
    return target;
  }
}","public IMethod getCalleeTarget(CGNode N,CallSiteReference site,IClass receiver){
  MethodReference m=site.getDeclaredTarget();
  if (isEJBSuperInterface(m.getDeclaringClass())) {
    IClass inferred=getReceiverClassFromTypeInference(N,site);
    if (inferred != null) {
      receiver=inferred;
    }
  }
  IClass servlet=cha.lookupClass(ServletEntrypoints.Servlet);
  if (FakeRootMethod.isFakeRootMethod(N.getMethod().getReference())) {
    if (deployment.isMessageDriven(m.getDeclaringClass())) {
      if (m.getName().equals(onMessageAtom) && m.getDescriptor().equals(onMessageDesc)) {
        return hijackOnMessageEntrypoint(m);
      }
    }
 else     if (receiver != null && cha.implementsInterface(receiver,servlet)) {
      IMethod resolved=cha.resolveMethod(receiver,m.getSelector());
      if (!resolved.isInit() && !resolved.isClinit()) {
        return hijackServletEntrypoint(m);
      }
    }
  }
  m=specializeForReceiverType(receiver,m);
  SyntheticMethod X=methodReferenceIntercept(m);
  if (X != null) {
    return X;
  }
  IMethod target=parent.getCalleeTarget(N,site,receiver);
  if (target == null) {
    return null;
  }
  X=methodReferenceIntercept(target.getReference());
  if (X != null) {
    return X;
  }
 else {
    return target;
  }
}",0.9666532744073926
40669,"/** 
 * @param scope scope of analysis
 * @param cha loaded class hierarchy
 */
public ServletEntrypoints(J2EEAnalysisScope scope,IClassHierarchy cha){
  TypeReference servletType=TypeReference.findOrCreate(scope.getExtensionLoader(),servletName);
  TypeReference actionServletType=TypeReference.findOrCreate(scope.getApplicationLoader(),actionServlet);
  IClass actionServletClass=cha.lookupClass(actionServletType);
  ClassLoaderReference appLoaderRef=scope.getApplicationLoader();
  IClassLoader appLoader=cha.getLoader(appLoaderRef);
  for (Iterator<IClass> it=appLoader.iterateAllClasses(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    if (DEBUG) {
      Trace.println(getClass() + ""String_Node_Str"" + klass);
    }
    if (cha.lookupClass(klass.getReference()) == null) {
      continue;
    }
    if (cha.lookupClass(actionServletType) != null) {
      if (cha.isSubclassOf(klass,actionServletClass)) {
        continue;
      }
    }
    if (cha.implementsInterface(klass,servletType)) {
      servlets.add(klass);
      final TypeReference type=klass.getReference();
      for (int i=0; i < servletMethodNames.length; i++) {
        Atom name=servletMethodNames[i];
        Descriptor desc=servletMethodDescs[i];
        MethodReference M=MethodReference.findOrCreate(type,name,desc);
        IMethod m=cha.resolveMethod(M);
        if (cha.resolveMethod(M) != null) {
          entrypoints.add(new DefaultEntrypoint(m,cha){
            /** 
 * Assume all ServletRequest and ServletResponse are HTTP flavor.
 */
            public TypeReference[] getParameterTypes(            int i){
              if (i == 0) {
                return new TypeReference[]{type};
              }
 else {
                TypeReference[] tArray=super.getParameterTypes(i);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(tArray.length == 1);
                }
                TypeReference T=tArray[0];
                TypeName n=T.getName();
                TypeReference Tp=concreteParameterMap.get(n);
                if (Tp != null) {
                  T=Tp;
                }
                return new TypeReference[]{T};
              }
            }
          }
);
        }
      }
    }
  }
}","/** 
 * @param scope scope of analysis
 * @param cha loaded class hierarchy
 */
public ServletEntrypoints(J2EEAnalysisScope scope,IClassHierarchy cha){
  TypeReference servletType=TypeReference.findOrCreate(scope.getExtensionLoader(),servletName);
  TypeReference actionServletType=TypeReference.findOrCreate(scope.getApplicationLoader(),actionServlet);
  IClass actionServletClass=cha.lookupClass(actionServletType);
  ClassLoaderReference appLoaderRef=scope.getApplicationLoader();
  IClassLoader appLoader=cha.getLoader(appLoaderRef);
  IClass servlet=cha.lookupClass(servletType);
  for (Iterator<IClass> it=appLoader.iterateAllClasses(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    if (DEBUG) {
      Trace.println(getClass() + ""String_Node_Str"" + klass);
    }
    if (cha.lookupClass(klass.getReference()) == null) {
      continue;
    }
    if (cha.lookupClass(actionServletType) != null) {
      if (cha.isSubclassOf(klass,actionServletClass)) {
        continue;
      }
    }
    if (cha.implementsInterface(klass,servlet)) {
      servlets.add(klass);
      final TypeReference type=klass.getReference();
      for (int i=0; i < servletMethodNames.length; i++) {
        Atom name=servletMethodNames[i];
        Descriptor desc=servletMethodDescs[i];
        MethodReference M=MethodReference.findOrCreate(type,name,desc);
        IMethod m=cha.resolveMethod(M);
        if (cha.resolveMethod(M) != null) {
          entrypoints.add(new DefaultEntrypoint(m,cha){
            /** 
 * Assume all ServletRequest and ServletResponse are HTTP flavor.
 */
            public TypeReference[] getParameterTypes(            int i){
              if (i == 0) {
                return new TypeReference[]{type};
              }
 else {
                TypeReference[] tArray=super.getParameterTypes(i);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(tArray.length == 1);
                }
                TypeReference T=tArray[0];
                TypeName n=T.getName();
                TypeReference Tp=concreteParameterMap.get(n);
                if (Tp != null) {
                  T=Tp;
                }
                return new TypeReference[]{T};
              }
            }
          }
);
        }
      }
    }
  }
}",0.9887491727332892
40670,"@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,T)) {
          return other;
        }
      }
      return other.meet(new ConeType(other.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}","@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,other.getType())) {
          return other;
        }
      }
      return other.meet(new ConeType(other.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}",0.9935691318327974
40671,"/** 
 * @return Collection of (IClass) interfaces this class implements, includingall ancestors of interfaces immediately implemented
 */
Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException ;","/** 
 * @return Collection of (IClass) interfaces this class implements, includingall ancestors of interfaces immediately implemented.
 */
Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException ;",0.9977220956719818
40672,"/** 
 * @return Collection of (IClass) interfaces this class directly implements
 */
Collection<IClass> getDirectInterfaces() throws ClassHierarchyException ;","/** 
 * @return Collection of (IClass) interfaces this class directly implementsIf this class is an interface, returns the interfaces it immediately extends.
 */
Collection<IClass> getDirectInterfaces() throws ClassHierarchyException ;",0.8040712468193384
40673,"public IMethod getMethod(Selector selector){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + selector + ""String_Node_Str""+ this);
  }
  if (methodMap == null) {
    try {
      computeMethodMap();
    }
 catch (    InvalidClassFileException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  IMethod result=methodMap.get(selector);
  if (result != null) {
    return result;
  }
  if (inheritCache != null) {
    result=inheritCache.get(selector);
    if (result != null) {
      return result;
    }
  }
  try {
    if (!selector.equals(MethodReference.clinitSelector) && !selector.equals(MethodReference.initSelector)) {
      ShrikeClass superclass=(ShrikeClass)getSuperclass();
      if (superclass != null) {
        IMethod inherit=superclass.getMethod(selector);
        if (inherit != null) {
          if (inheritCache == null) {
            inheritCache=new BimodalMap<Selector,IMethod>(5);
          }
          inheritCache.put(selector,inherit);
          return inherit;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
  try {
    if (isInterface() || isAbstract()) {
      final Iterator<IClass> it=(isInterface()) ? getAllAncestorInterfaces().iterator() : getAllImplementedInterfaces().iterator();
      while (it.hasNext()) {
        IClass k=it.next();
        result=k.getMethod(selector);
        if (result != null) {
          return result;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE(""String_Node_Str"" + this);
  }
  return null;
}","public IMethod getMethod(Selector selector){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + selector + ""String_Node_Str""+ this);
  }
  if (methodMap == null) {
    try {
      computeMethodMap();
    }
 catch (    InvalidClassFileException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  IMethod result=methodMap.get(selector);
  if (result != null) {
    return result;
  }
  if (inheritCache != null) {
    result=inheritCache.get(selector);
    if (result != null) {
      return result;
    }
  }
  try {
    if (!selector.equals(MethodReference.clinitSelector) && !selector.equals(MethodReference.initSelector)) {
      ShrikeClass superclass=(ShrikeClass)getSuperclass();
      if (superclass != null) {
        IMethod inherit=superclass.getMethod(selector);
        if (inherit != null) {
          if (inheritCache == null) {
            inheritCache=new BimodalMap<Selector,IMethod>(5);
          }
          inheritCache.put(selector,inherit);
          return inherit;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
  try {
    if (isInterface() || isAbstract()) {
      final Iterator<IClass> it=getAllImplementedInterfaces().iterator();
      while (it.hasNext()) {
        IClass k=it.next();
        result=k.getMethod(selector);
        if (result != null) {
          return result;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE(""String_Node_Str"" + this);
  }
  return null;
}",0.9817150063051704
40674,"public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
    try {
      Collection<IClass> ifaces=isInterface() ? getAllAncestorInterfaces() : getAllImplementedInterfaces();
      for (      IClass i : ifaces) {
        f=i.getField(name);
        if (f != null) {
          fieldMap.put(name,f);
          return f;
        }
      }
    }
 catch (    ClassHierarchyException e) {
    }
  }
  return null;
}","public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
    try {
      for (      IClass i : getAllImplementedInterfaces()) {
        f=i.getField(name);
        if (f != null) {
          fieldMap.put(name,f);
          return f;
        }
      }
    }
 catch (    ClassHierarchyException e) {
    }
  }
  return null;
}",0.8932461873638344
40675,"public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  if (Assertions.verifyAssertions) {
    if (isInterface()) {
      Assertions.UNREACHABLE(""String_Node_Str"" + this);
    }
  }
  if (allInterfaces != null) {
    return allInterfaces;
  }
 else {
    Collection<IClass> C=computeAllInterfacesAsCollection();
    allInterfaces=Collections.unmodifiableCollection(C);
    return allInterfaces;
  }
}","public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  if (allInterfaces != null) {
    return allInterfaces;
  }
 else {
    Collection<IClass> C=computeAllInterfacesAsCollection();
    allInterfaces=Collections.unmodifiableCollection(C);
    return allInterfaces;
  }
}",0.8274932614555256
40676,"/** 
 * @return true if it may be possible to resolve a call to a site on the concrete type dispatchType
 */
public static boolean feasibleChaResolution(IClassHierarchy cha,CallSiteReference site,IClass dispatchType){
  if (dispatchType == null) {
    return false;
  }
  if (dispatchType.isInterface()) {
    if (site.getDeclaredTarget().getSelector().equals(MethodReference.clinitSelector)) {
      return true;
    }
 else {
      return false;
    }
  }
  TypeReference targetType=site.getDeclaredTarget().getDeclaringClass();
  IClass resolvedType=cha.lookupClass(targetType);
  if (resolvedType == null) {
    return false;
  }
 else {
    if (resolvedType.isInterface()) {
      return cha.implementsInterface(dispatchType,resolvedType.getReference());
    }
 else {
      return cha.isSubclassOf(dispatchType,resolvedType);
    }
  }
}","/** 
 * @return true if it may be possible to resolve a call to a site on the concrete type dispatchType
 */
public static boolean feasibleChaResolution(IClassHierarchy cha,CallSiteReference site,IClass dispatchType){
  if (dispatchType == null) {
    return false;
  }
  if (dispatchType.isInterface()) {
    if (site.getDeclaredTarget().getSelector().equals(MethodReference.clinitSelector)) {
      return true;
    }
 else {
      return false;
    }
  }
  TypeReference targetType=site.getDeclaredTarget().getDeclaringClass();
  IClass resolvedType=cha.lookupClass(targetType);
  if (resolvedType == null) {
    return false;
  }
 else {
    if (resolvedType.isInterface()) {
      return cha.implementsInterface(dispatchType,resolvedType);
    }
 else {
      return cha.isSubclassOf(dispatchType,resolvedType);
    }
  }
}",0.9910233393177738
40677,"/** 
 * @param C
 * @return true iff C is a container class from java.util
 * @throws IllegalArgumentException  if C is null
 */
public static boolean isContainer(IClass C,IClassHierarchy cha){
  if (C == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (ClassLoaderReference.Primordial.equals(C.getClassLoader().getReference()) && TypeReference.JavaUtilCollection.getName().getPackage().equals(C.getReference().getName().getPackage())) {
    if (C.isInterface()) {
      IClass collection=cha.lookupClass(TypeReference.JavaUtilCollection);
      IClass map=cha.lookupClass(TypeReference.JavaUtilMap);
      if (Assertions.verifyAssertions) {
        Assertions._assert(collection != null);
        Assertions._assert(map != null);
      }
      Collection s;
      try {
        s=C.getAllAncestorInterfaces();
      }
 catch (      ClassHierarchyException e) {
        return false;
      }
      if (s.contains(collection) || s.contains(map)) {
        return true;
      }
    }
 else {
      if (cha.implementsInterface(C,TypeReference.JavaUtilCollection) || cha.implementsInterface(C,TypeReference.JavaUtilMap)) {
        return true;
      }
    }
  }
  if (miscContainers.contains(C.getReference())) {
    return true;
  }
  if (C.isArrayClass() && ((ArrayClass)C).getElementClass() != null && ((ArrayClass)C).getElementClass().getReference().isReferenceType()) {
    return true;
  }
  return false;
}","/** 
 * @param C
 * @return true iff C is a container class from java.util
 * @throws IllegalArgumentException  if C is null
 */
public static boolean isContainer(IClass C,IClassHierarchy cha){
  if (C == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (ClassLoaderReference.Primordial.equals(C.getClassLoader().getReference()) && TypeReference.JavaUtilCollection.getName().getPackage().equals(C.getReference().getName().getPackage())) {
    IClass collection=cha.lookupClass(TypeReference.JavaUtilCollection);
    IClass map=cha.lookupClass(TypeReference.JavaUtilMap);
    if (C.isInterface()) {
      if (Assertions.verifyAssertions) {
        Assertions._assert(collection != null);
        Assertions._assert(map != null);
      }
      Collection s;
      try {
        s=C.getAllImplementedInterfaces();
      }
 catch (      ClassHierarchyException e) {
        return false;
      }
      if (s.contains(collection) || s.contains(map)) {
        return true;
      }
    }
 else {
      if (cha.implementsInterface(C,collection) || cha.implementsInterface(C,map)) {
        return true;
      }
    }
  }
  if (miscContainers.contains(C.getReference())) {
    return true;
  }
  if (C.isArrayClass() && ((ArrayClass)C).getElementClass() != null && ((ArrayClass)C).getElementClass().getReference().isReferenceType()) {
    return true;
  }
  return false;
}",0.7408978437610463
40678,"private OrdinalSet<InstanceKey> computeImplicitPointsToSetAtCheckCast(CGNode node,SSACheckCastInstruction instruction){
  PointerKey rhs=pointerKeys.getPointerKeyForLocal(node,instruction.getVal());
  OrdinalSet<InstanceKey> rhsSet=getPointsToSet(rhs);
  MutableSparseIntSet S=MutableSparseIntSet.makeEmpty();
  IClass klass=getCallGraph().getClassHierarchy().lookupClass(instruction.getDeclaredResultType());
  if (klass == null) {
    return rhsSet;
  }
 else {
    if (klass.isInterface()) {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().implementsInterface(ik.getConcreteType(),klass.getReference())) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
 else {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().isSubclassOf(ik.getConcreteType(),klass)) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
  }
  return new OrdinalSet<InstanceKey>(S,instanceKeys);
}","private OrdinalSet<InstanceKey> computeImplicitPointsToSetAtCheckCast(CGNode node,SSACheckCastInstruction instruction){
  PointerKey rhs=pointerKeys.getPointerKeyForLocal(node,instruction.getVal());
  OrdinalSet<InstanceKey> rhsSet=getPointsToSet(rhs);
  MutableSparseIntSet S=MutableSparseIntSet.makeEmpty();
  IClass klass=getCallGraph().getClassHierarchy().lookupClass(instruction.getDeclaredResultType());
  if (klass == null) {
    return rhsSet;
  }
 else {
    if (klass.isInterface()) {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().implementsInterface(ik.getConcreteType(),klass)) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
 else {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().isSubclassOf(ik.getConcreteType(),klass)) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
  }
  return new OrdinalSet<InstanceKey>(S,instanceKeys);
}",0.9934354485776804
40679,"public void act(int i){
  InstanceKey I=system.getInstanceKey(i);
  if (!I.getConcreteType().isArrayClass()) {
    return;
  }
  TypeReference C=I.getConcreteType().getReference().getArrayElementType();
  if (C.isPrimitiveType()) {
    return;
  }
  IClass contents=getClassHierarchy().lookupClass(C);
  if (Assertions.verifyAssertions) {
    if (contents == null) {
      Assertions._assert(false,""String_Node_Str"" + C + ""String_Node_Str""+ I.getConcreteType());
    }
  }
  PointerKey p=getPointerKeyForArrayContents(I);
  if (contents.isInterface()) {
    if (getClassHierarchy().implementsInterface(instance.getConcreteType(),contents.getReference())) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
 else {
    if (getClassHierarchy().isSubclassOf(instance.getConcreteType(),contents)) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
}","public void act(int i){
  InstanceKey I=system.getInstanceKey(i);
  if (!I.getConcreteType().isArrayClass()) {
    return;
  }
  TypeReference C=I.getConcreteType().getReference().getArrayElementType();
  if (C.isPrimitiveType()) {
    return;
  }
  IClass contents=getClassHierarchy().lookupClass(C);
  if (Assertions.verifyAssertions) {
    if (contents == null) {
      Assertions._assert(false,""String_Node_Str"" + C + ""String_Node_Str""+ I.getConcreteType());
    }
  }
  PointerKey p=getPointerKeyForArrayContents(I);
  if (contents.isInterface()) {
    if (getClassHierarchy().implementsInterface(instance.getConcreteType(),contents)) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
 else {
    if (getClassHierarchy().isSubclassOf(instance.getConcreteType(),contents)) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
}",0.9913544668587896
40680,"private void registerArrayInstanceWithAllInterfacesOfElement(int index,IClass elementClass,int dim){
  Collection ifaces=null;
  try {
    ifaces=(elementClass.isInterface()) ? elementClass.getAllAncestorInterfaces() : elementClass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    Warnings.add(ClassHierarchyWarning.create(e.getMessage()));
    return;
  }
  for (Iterator it=ifaces.iterator(); it.hasNext(); ) {
    IClass I=(IClass)it.next();
    TypeReference iArrayRef=makeArray(I.getReference(),dim);
    IClass iArrayClass=null;
    iArrayClass=I.getClassLoader().lookupClass(iArrayRef.getName());
    MutableIntSet set=findOrCreateSparseSetForClass(iArrayClass);
    set.add(index);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + iArrayClass + ""String_Node_Str""+ set);
    }
  }
}","private void registerArrayInstanceWithAllInterfacesOfElement(int index,IClass elementClass,int dim){
  Collection ifaces=null;
  try {
    ifaces=elementClass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    Warnings.add(ClassHierarchyWarning.create(e.getMessage()));
    return;
  }
  for (Iterator it=ifaces.iterator(); it.hasNext(); ) {
    IClass I=(IClass)it.next();
    TypeReference iArrayRef=makeArray(I.getReference(),dim);
    IClass iArrayClass=null;
    iArrayClass=I.getClassLoader().lookupClass(iArrayRef.getName());
    MutableIntSet set=findOrCreateSparseSetForClass(iArrayClass);
    set.add(index);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + iArrayClass + ""String_Node_Str""+ set);
    }
  }
}",0.9537682077264092
40681,"/** 
 * Does c implement T?
 * @param c
 * @param T
 * @return true iff T is an interface and c is a class that implements T,
 */
public boolean implementsInterface(IClass c,TypeReference T){
  IClass tClass=lookupClass(T);
  if (Assertions.verifyAssertions) {
    if (tClass == null) {
      Assertions._assert(false,""String_Node_Str"" + T);
    }
  }
  if (!tClass.isInterface()) {
    return false;
  }
  Set impls=implementors.get(tClass);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}","/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i, rc is an interface that extends i.
 */
public boolean implementsInterface(IClass c,IClass i){
  if (!i.isInterface()) {
    return false;
  }
  Set impls=implementors.get(i);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}",0.6809954751131222
40682,"/** 
 * @param klass
 * @return true if the add succeeded; false if it failed for some reason
 * @throws IllegalArgumentException if klass is null
 */
public boolean addClass(IClass klass){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + klass);
  }
  Set<IClass> loadedSuperclasses;
  Collection loadedSuperInterfaces;
  try {
    loadedSuperclasses=computeSuperclasses(klass);
    loadedSuperInterfaces=klass.isInterface() ? null : klass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    if (klass instanceof ShrikeClass) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + klass);
      }
    }
    Warnings.add(ClassExclusion.create(klass.getReference(),e.getMessage()));
    return false;
  }
  Node node=findOrCreateNode(klass);
  if (klass.getReference().equals(language.getRootType())) {
    Assertions._assert(root == null);
    root=node;
  }
  Set workingSuperclasses=HashSetFactory.make(loadedSuperclasses);
  while (node != null) {
    IClass c=node.getJavaClass();
    IClass superclass=null;
    try {
      superclass=c.getSuperclass();
    }
 catch (    ClassHierarchyException e1) {
      Assertions.UNREACHABLE();
    }
    if (superclass != null) {
      workingSuperclasses.remove(superclass);
      Node supernode=findOrCreateNode(superclass);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + node.getJavaClass() + ""String_Node_Str""+ supernode.getJavaClass());
      }
      supernode.addChild(node);
      if (supernode.getJavaClass().getReference().equals(language.getRootType())) {
        node=null;
      }
 else {
        node=supernode;
      }
    }
 else {
      node=null;
    }
  }
  if (loadedSuperInterfaces != null) {
    for (Iterator it3=loadedSuperInterfaces.iterator(); it3.hasNext(); ) {
      IClass iface=(IClass)it3.next();
      try {
        computeSuperclasses(iface);
      }
 catch (      ClassHierarchyException e) {
        Warnings.add(ClassExclusion.create(iface.getReference(),e.getMessage()));
        continue;
      }
      if (DEBUG && Assertions.verifyAssertions) {
        if (!iface.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + iface);
        }
        if (klass.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + klass);
        }
      }
      recordImplements(klass,iface);
    }
  }
  return true;
}","/** 
 * @param klass
 * @return true if the add succeeded; false if it failed for some reason
 * @throws IllegalArgumentException if klass is null
 */
public boolean addClass(IClass klass){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + klass);
  }
  Set<IClass> loadedSuperclasses;
  Collection loadedSuperInterfaces;
  try {
    loadedSuperclasses=computeSuperclasses(klass);
    loadedSuperInterfaces=klass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    if (klass instanceof ShrikeClass) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + klass);
      }
    }
    Warnings.add(ClassExclusion.create(klass.getReference(),e.getMessage()));
    return false;
  }
  Node node=findOrCreateNode(klass);
  if (klass.getReference().equals(language.getRootType())) {
    Assertions._assert(root == null);
    root=node;
  }
  Set workingSuperclasses=HashSetFactory.make(loadedSuperclasses);
  while (node != null) {
    IClass c=node.getJavaClass();
    IClass superclass=null;
    try {
      superclass=c.getSuperclass();
    }
 catch (    ClassHierarchyException e1) {
      Assertions.UNREACHABLE();
    }
    if (superclass != null) {
      workingSuperclasses.remove(superclass);
      Node supernode=findOrCreateNode(superclass);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + node.getJavaClass() + ""String_Node_Str""+ supernode.getJavaClass());
      }
      supernode.addChild(node);
      if (supernode.getJavaClass().getReference().equals(language.getRootType())) {
        node=null;
      }
 else {
        node=supernode;
      }
    }
 else {
      node=null;
    }
  }
  if (loadedSuperInterfaces != null) {
    for (Iterator it3=loadedSuperInterfaces.iterator(); it3.hasNext(); ) {
      IClass iface=(IClass)it3.next();
      try {
        computeSuperclasses(iface);
      }
 catch (      ClassHierarchyException e) {
        Warnings.add(ClassExclusion.create(iface.getReference(),e.getMessage()));
        continue;
      }
      if (DEBUG && Assertions.verifyAssertions) {
        if (!iface.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + iface);
        }
        if (klass.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + klass);
        }
      }
      recordImplements(klass,iface);
    }
  }
  return true;
}",0.9940585945502972
40683,"/** 
 * Find the possible receivers of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
private Set<IMethod> computePossibleTargets(IClass declaredClass,MethodReference ref){
  if (declaredClass.isInterface()) {
    HashSet<IMethod> result=HashSetFactory.make(3);
    Set impls=implementors.get(declaredClass);
    if (impls == null) {
      return Collections.emptySet();
    }
    for (Iterator it=impls.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      if (Assertions.verifyAssertions) {
        Assertions._assert(!klass.isInterface());
      }
      result.addAll(computeTargetsNotInterface(ref,klass));
    }
    return result;
  }
 else {
    return computeTargetsNotInterface(ref,declaredClass);
  }
}","/** 
 * Find the possible receivers of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
private Set<IMethod> computePossibleTargets(IClass declaredClass,MethodReference ref){
  if (declaredClass.isInterface()) {
    HashSet<IMethod> result=HashSetFactory.make(3);
    Set impls=implementors.get(declaredClass);
    if (impls == null) {
      return Collections.emptySet();
    }
    for (Iterator it=impls.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      if (!klass.isInterface()) {
        result.addAll(computeTargetsNotInterface(ref,klass));
      }
    }
    return result;
  }
 else {
    return computeTargetsNotInterface(ref,declaredClass);
  }
}",0.926517571884984
40684,"/** 
 * Does an expression c1 x := c2 y typecheck? i.e. is c2 a subtype of c1?
 * @throws IllegalArgumentException if c1 is null
 * @throws IllegalArgumentException if c2 is null
 */
public boolean isAssignableFrom(IClass c1,IClass c2){
  if (c2 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1.isInterface()) {
    if (c2.isInterface()) {
      return isSubclassOf(c2,c1);
    }
 else {
      return implementsInterface(c2,c1.getReference());
    }
  }
 else {
    if (c2.isInterface()) {
      return c1.equals(getRootClass());
    }
 else {
      return isSubclassOf(c2,c1);
    }
  }
}","/** 
 * Does an expression c1 x := c2 y typecheck? i.e. is c2 a subtype of c1?
 * @throws IllegalArgumentException if c1 is null
 * @throws IllegalArgumentException if c2 is null
 */
public boolean isAssignableFrom(IClass c1,IClass c2){
  if (c2 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1.isInterface()) {
    return implementsInterface(c2,c1);
  }
 else {
    if (c2.isInterface()) {
      return c1.equals(getRootClass());
    }
 else {
      return isSubclassOf(c2,c1);
    }
  }
}",0.7646610814927647
40685,"/** 
 * Does c implement T?
 * @return true iff T is an interface and c is a class that implements T,
 */
public boolean implementsInterface(IClass c,TypeReference T);","/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i,
 */
public boolean implementsInterface(IClass c,IClass i);",0.9174311926605504
40686,"public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  Collection<IClass> realIfaces=realType.isInterface() ? realType.getAllAncestorInterfaces() : realType.getAllImplementedInterfaces();
  if (realType.isInterface()) {
    HashSet<IClass> result=HashSetFactory.make(realIfaces);
    result.add(realType);
    return result;
  }
 else {
    return realIfaces;
  }
}","public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  Collection<IClass> realIfaces=realType.getAllImplementedInterfaces();
  if (realType.isInterface()) {
    HashSet<IClass> result=HashSetFactory.make(realIfaces);
    result.add(realType);
    return result;
  }
 else {
    return realIfaces;
  }
}",0.9147496617050068
40687,"public static <T>Dominators make(Graph<T> G,T root){
  if (G instanceof NumberedGraph) {
    return new NumberedDominators((NumberedGraph)G,(INodeWithNumber)root);
  }
 else {
    return new GenericDominators(G,root);
  }
}","@SuppressWarnings(""String_Node_Str"") public static <T>Dominators<T> make(Graph<T> G,T root){
  if (G instanceof NumberedGraph && root instanceof INodeWithNumber) {
    return new NumberedDominators((NumberedGraph)G,(INodeWithNumber)root);
  }
 else {
    return new GenericDominators<T>(G,root);
  }
}",0.851145038167939
40688,"public String toString(){
  StringBuffer sb=new StringBuffer();
  for (Iterator<? extends T> i=G.iterator(); i.hasNext(); ) {
    T node=i.next();
    sb.append(""String_Node_Str"" + node + ""String_Node_Str"");
    for (Iterator j=dominators(node); j.hasNext(); )     sb.append(""String_Node_Str"" + j.next() + ""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  for (Iterator<? extends T> i=G.iterator(); i.hasNext(); ) {
    T node=i.next();
    sb.append(""String_Node_Str"" + node + ""String_Node_Str"");
    for (Iterator j=dominators(node); j.hasNext(); )     sb.append(""String_Node_Str"" + j.next() + ""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.9873096446700508
40689,"protected DominatorInfo getInfo(T node){
  if (!infoMap.containsKey(node))   infoMap.put(node,new DominatorInfo(node));
  return infoMap.get(node);
}","@Override protected DominatorInfo getInfo(T node){
  if (!infoMap.containsKey(node))   infoMap.put(node,new DominatorInfo(node));
  return infoMap.get(node);
}",0.9675324675324676
40690,"protected final DominatorInfo getInfo(T node){
  return (DominatorInfo)infoMap[node.getGraphNodeId()];
}","@Override protected final DominatorInfo getInfo(T node){
  return (DominatorInfo)infoMap[node.getGraphNodeId()];
}",0.9541284403669724
40691,"public NumberedGraph<T> getGraph(){
  return (NumberedGraph)G;
}","@Override public NumberedGraph<T> getGraph(){
  return (NumberedGraph<T>)G;
}",0.9078014184397164
40692,"@Override protected void initializeVariables(){
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(TypeAbstraction.TOP);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.932649420160571
40693,"/** 
 * @return Returns the iKeyFactory.
 */
protected ClassBasedInstanceKeys getIKeyFactory(){
  return iKeyFactory;
}","protected ClassBasedInstanceKeys getIKeyFactory(){
  return iKeyFactory;
}",0.7668393782383419
40694,"/** 
 */
private Map<PointerKey,Object> computePointerKeys(IClass klass){
  Map<PointerKey,Object> result=HashMapFactory.make();
  if (klass.isArrayClass()) {
    ArrayClass a=(ArrayClass)klass;
    if (a.getElementClass() != null && a.getElementClass().isReferenceType()) {
      PointerKey p=pointerKeys.getPointerKeyForArrayContents(new ConcreteTypeKey(a));
      result.put(p,p);
    }
  }
 else {
    try {
      for (Iterator<IField> it=klass.getAllFields().iterator(); it.hasNext(); ) {
        IField f=it.next();
        if (!f.getFieldTypeReference().isPrimitiveType()) {
          if (f.isStatic()) {
            PointerKey p=pointerKeys.getPointerKeyForStaticField(f);
            result.put(p,p);
          }
 else {
            PointerKey p=pointerKeys.getPointerKeyForInstanceField(new ConcreteTypeKey(klass),f);
            result.put(p,p);
          }
        }
      }
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  return result;
}","private Map<PointerKey,Object> computePointerKeys(IClass klass){
  Map<PointerKey,Object> result=HashMapFactory.make();
  if (klass.isArrayClass()) {
    ArrayClass a=(ArrayClass)klass;
    if (a.getElementClass() != null && a.getElementClass().isReferenceType()) {
      PointerKey p=pointerKeys.getPointerKeyForArrayContents(new ConcreteTypeKey(a));
      result.put(p,p);
    }
  }
 else {
    try {
      for (Iterator<IField> it=klass.getAllFields().iterator(); it.hasNext(); ) {
        IField f=it.next();
        if (!f.getFieldTypeReference().isPrimitiveType()) {
          if (f.isStatic()) {
            PointerKey p=pointerKeys.getPointerKeyForStaticField(f);
            result.put(p,p);
          }
 else {
            PointerKey p=pointerKeys.getPointerKeyForInstanceField(new ConcreteTypeKey(klass),f);
            result.put(p,p);
          }
        }
      }
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  return result;
}",0.9955730447614364
40695,"public PointerKey getPointerKeyForLocal(CGNode node,int valueNumber){
  initPKeysForNode(node);
  PointerKey p=pointerKeys.getPointerKeyForLocal(node,valueNumber);
  Object result=pKeys.get(p);
  if (result == null) {
    return null;
  }
  if (result instanceof FilteredPointerKey) {
    return (PointerKey)result;
  }
 else {
    if (result instanceof ConcreteTypeKey) {
      ConcreteTypeKey c=(ConcreteTypeKey)result;
      if (c.getConcreteType().getReference().equals(TypeReference.JavaLangString)) {
        return pointerKeys.getFilteredPointerKeyForLocal(node,valueNumber,new FilteredPointerKey.SingleClassFilter(c.getConcreteType()));
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
        return null;
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
      return null;
    }
  }
}","/** 
 * Note that this always returns a    {@link FilteredPointerKey}, since the   {@link TypeBasedPointerAnalysis} relies on thetype filter to compute points to sets.
 * @see com.ibm.wala.ipa.callgraph.propagation.PointerKeyFactory#getPointerKeyForLocal(com.ibm.wala.ipa.callgraph.CGNode,int)
 */
public FilteredPointerKey getPointerKeyForLocal(CGNode node,int valueNumber){
  initPKeysForNode(node);
  PointerKey p=pointerKeys.getPointerKeyForLocal(node,valueNumber);
  Object result=pKeys.get(p);
  if (result == null) {
    return null;
  }
  if (result instanceof FilteredPointerKey) {
    return (FilteredPointerKey)result;
  }
 else {
    if (result instanceof ConcreteTypeKey) {
      ConcreteTypeKey c=(ConcreteTypeKey)result;
      if (c.getConcreteType().getReference().equals(TypeReference.JavaLangString)) {
        return pointerKeys.getFilteredPointerKeyForLocal(node,valueNumber,new FilteredPointerKey.SingleClassFilter(c.getConcreteType()));
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
        return null;
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
      return null;
    }
  }
}",0.8312318137730359
40696,"/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  klasses=HashSetFactory.make(klasses);
  klasses.retainAll(this.klasses);
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(klasses);
  return result;
}","/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  Collection<IClass> c=HashSetFactory.make();
  for (  IClass klass : klasses) {
    if (klass.isArrayClass()) {
      c.add(klass);
    }
 else     if (this.klasses.contains(klass)) {
      c.add(klass);
    }
  }
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(c);
  return result;
}",0.8430379746835444
40697,"/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError  if klasses is null
 */
private TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}","/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError if klasses is null
 */
private TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}",0.9985007496251874
40698,"/** 
 * @throws IllegalArgumentException if dst is null
 */
public void addExceptionalEdge(T src,T dst){
  if (dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dst.equals(exit())) {
    exceptionalToExit.set(getNumber(src));
  }
 else {
    exceptionalEdgeManager.addEdge(src,dst);
    SimpleIntVector v=exceptionalSuccessors.get(getNumber(src));
    if (v == null) {
      v=new SimpleIntVector(-1);
      exceptionalSuccessors.set(getNumber(src),v);
    }
    v.set(v.getMaxIndex() + 1,getNumber(dst));
  }
}","/** 
 * @throws IllegalArgumentException if dst is null
 */
public void addExceptionalEdge(T src,T dst){
  if (dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dst.equals(exit())) {
    exceptionalToExit.set(getNumber(src));
  }
 else {
    exceptionalEdgeManager.addEdge(src,dst);
    SimpleIntVector v=exceptionalSuccessors.get(getNumber(src));
    if (v == null) {
      v=new SimpleIntVector(-1);
      exceptionalSuccessors.set(getNumber(src),v);
      v.set(0,getNumber(dst));
      return;
    }
    if (v.get(v.getMaxIndex()) != getNumber(dst)) {
      v.set(v.getMaxIndex() + 1,getNumber(dst));
    }
  }
}",0.9121338912133892
40699,"private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().getMappedIndex(new ConcreteTypeKey(klass));
    if (index >= 0) {
      s.add(index);
    }
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}","private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().add(new ConcreteTypeKey(klass));
    s.add(index);
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}",0.8297055057618438
40700,"/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}","/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
case OP_ldiv:
case OP_lrem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}",0.9924242424242424
40701,"/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_irem:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}","/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_irem:
case OP_ldiv:
case OP_lrem:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}",0.9863813229571984
40702,"@Override public void putAll(Map<? extends K,? extends V> arg0){
  if (arg0 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Map.Entry<K,V> E : entrySet()) {
    put(E.getKey(),E.getValue());
  }
}","@Override public void putAll(Map<? extends K,? extends V> arg0){
  if (arg0 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Map.Entry<? extends K,? extends V> E : arg0.entrySet()) {
    put(E.getKey(),E.getValue());
  }
}",0.9486652977412732
40703,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public Collection<? extends Object> getRootsInput(){
  return rootsInput;
}","public Collection<? extends Object> getRootsInput(){
  return rootsInput;
}",0.6756756756756757
40704,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void setRootsInput(Collection<? extends Object> newRootsInput){
  rootsInput=newRootsInput;
}","public void setRootsInput(Collection<? extends Object> newRootsInput){
  rootsInput=newRootsInput;
}",0.7352941176470589
40705,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public List<IAction> getPopUpActions(){
  return popUpActions;
}","public List<IAction> getPopUpActions(){
  return popUpActions;
}",0.64
40706,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public Graph getGraphInput(){
  return graphInput;
}","public Graph getGraphInput(){
  return graphInput;
}",0.5909090909090909
40707,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public NodeDecorator getNodeDecoratorInput(){
  return nodeDecoratorInput;
}","public NodeDecorator getNodeDecoratorInput(){
  return nodeDecoratorInput;
}",0.6785714285714286
40708,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void setNodeDecoratorInput(NodeDecorator newNodeDecoratorInput){
  nodeDecoratorInput=newNodeDecoratorInput;
}","public void setNodeDecoratorInput(NodeDecorator newNodeDecoratorInput){
  nodeDecoratorInput=newNodeDecoratorInput;
}",0.7647058823529411
40709,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void setGraphInput(Graph newGraphInput){
  graphInput=newGraphInput;
}","public void setGraphInput(Graph newGraphInput){
  graphInput=newGraphInput;
}",0.6814159292035398
40710,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
@Override public String toString(){
  StringBuffer result=new StringBuffer(super.toString());
  result.append(""String_Node_Str"");
  result.append(graphInput);
  result.append(""String_Node_Str"");
  result.append(rootsInput);
  result.append(""String_Node_Str"");
  result.append(nodeDecoratorInput);
  result.append(""String_Node_Str"");
  result.append(popUpActions);
  result.append(')');
  return result.toString();
}","@Override public String toString(){
  StringBuffer result=new StringBuffer(super.toString());
  result.append(""String_Node_Str"");
  result.append(graphInput);
  result.append(""String_Node_Str"");
  result.append(rootsInput);
  result.append(""String_Node_Str"");
  result.append(nodeDecoratorInput);
  result.append(""String_Node_Str"");
  result.append(popUpActions);
  result.append(')');
  return result.toString();
}",0.9201773835920176
40711,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public SWTTreeViewer(){
  super();
}","public SWTTreeViewer(){
  super();
}",0.5
40712,"public boolean isCatchBlock(){
  return original.isCatchBlock();
}","public boolean isCatchBlock(){
  return (original.isCatchBlock() && instructionIndex == original.getFirstInstructionIndex());
}",0.6839378238341969
40713,"@SuppressWarnings(""String_Node_Str"") public String getLabel(Object o) throws WalaException {
  T t=(T)o;
  if (t instanceof BasicBlockInContext) {
    BasicBlockInContext bb=(BasicBlockInContext)t;
    if (bb.getDelegate() instanceof ExplodedBasicBlock) {
      ExplodedBasicBlock delegate=(ExplodedBasicBlock)bb.getDelegate();
      String s=delegate.getNumber() + ""String_Node_Str"" + result.getResult(t)+ ""String_Node_Str""+ delegate.getInstruction();
      for (Iterator<SSAPhiInstruction> phis=delegate.iteratePhis(); phis.hasNext(); ) {
        SSAPhiInstruction phi=phis.next();
        s+=""String_Node_Str"" + phi;
      }
      return s;
    }
  }
  return t + ""String_Node_Str"" + result.getResult(t);
}","@SuppressWarnings(""String_Node_Str"") public String getLabel(Object o) throws WalaException {
  T t=(T)o;
  if (t instanceof BasicBlockInContext) {
    BasicBlockInContext bb=(BasicBlockInContext)t;
    if (bb.getDelegate() instanceof ExplodedBasicBlock) {
      ExplodedBasicBlock delegate=(ExplodedBasicBlock)bb.getDelegate();
      String s=delegate.getNumber() + ""String_Node_Str"" + result.getResult(t)+ ""String_Node_Str""+ delegate.getInstruction();
      for (Iterator<SSAPhiInstruction> phis=delegate.iteratePhis(); phis.hasNext(); ) {
        SSAPhiInstruction phi=phis.next();
        s+=""String_Node_Str"" + phi;
      }
      if (delegate.isCatchBlock()) {
        s+=""String_Node_Str"" + delegate.getCatchInstruction();
      }
      return s;
    }
  }
  return t + ""String_Node_Str"" + result.getResult(t);
}",0.9161205766710354
40714,"private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    klasses=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
  }
  klasses=HashSetFactory.make(klasses);
  klasses.retainAll(this.klasses);
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(klasses);
  return result;
}","/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  klasses=HashSetFactory.make(klasses);
  klasses.retainAll(this.klasses);
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(klasses);
  return result;
}",0.7860696517412935
40715,"/** 
 * @param c Collection<IClass>
 */
private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().getMappedIndex(new ConcreteTypeKey(klass));
    if (index >= 0) {
      s.add(index);
    }
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}","private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().getMappedIndex(new ConcreteTypeKey(klass));
    if (index >= 0) {
      s.add(index);
    }
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}",0.9535962877030162
40716,"/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.n);
  final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.n));
  final Collection<T> returnSitesWithCallee=HashSetFactory.make();
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.n); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.n,callee);
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  returnSitesWithCallee.add(returnSite);
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.n,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final SparseIntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final SparseIntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.n); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.n,m);
    SparseIntSet D3=computeFlow(edge.d2,f);
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.s_p,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : returnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (returnSitesWithCallee.contains(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.n,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.n,returnSite);
    }
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.s_p,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}","/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.n);
  final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.n));
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.n); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.n,callee);
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.n,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final SparseIntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final SparseIntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.n); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.n,m);
    SparseIntSet D3=computeFlow(edge.d2,f);
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.s_p,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : returnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (hasCallee(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.n,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.n,returnSite);
    }
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.s_p,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}",0.9846407586846716
40717,"@Override public PointerAnalysis getPointerAnalysis(){
  return new TypeBasedPointerAnalysis(getOptions(),allocatedClasses,getCallGraph());
}","@Override public PointerAnalysis getPointerAnalysis(){
  return TypeBasedPointerAnalysis.make(getOptions(),allocatedClasses,getCallGraph());
}",0.9681978798586572
40718,"public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation) throws UnimplementedError {
  Assertions.UNREACHABLE();
  return null;
}","public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation) throws UnimplementedError {
  return iKeyFactory.getInstanceKeyForAllocation(node,allocation);
}",0.7616279069767442
40719,"public InstanceKey getInstanceKeyForMultiNewArray(CGNode node,NewSiteReference allocation,int dim) throws UnimplementedError {
  Assertions.UNREACHABLE();
  return null;
}","public InstanceKey getInstanceKeyForMultiNewArray(CGNode node,NewSiteReference allocation,int dim) throws UnimplementedError {
  return iKeyFactory.getInstanceKeyForMultiNewArray(node,allocation,dim);
}",0.7238605898123325
40720,"/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError  if klasses is null
 */
public TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}","/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError  if klasses is null
 */
private TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}",0.9835082458770614
40721,"/** 
 * get the ""normal"" successors (sic) for a return site; i.e., the ""normal"" CFG predecessors that are not call nodes.
 * @see com.ibm.wala.dataflow.IFDS.ISupergraph#getCalledNodes(java.lang.Object)
 */
public Iterator<T> getNormalSuccessors(final T ret){
  Iterator<? extends Object> allPreds=delegate.getPredNodes(ret);
  Filter sameProc=new Filter(){
    @SuppressWarnings(""String_Node_Str"") public boolean accepts(    Object o){
      return getProcOf(ret).equals(getProcOf((T)o));
    }
  }
;
  Iterator<Object> sameProcPreds=new FilterIterator<Object>(allPreds,sameProc);
  Filter notCall=new Filter(){
    @SuppressWarnings(""String_Node_Str"") public boolean accepts(    Object o){
      return !delegate.isCall((T)o);
    }
  }
;
  return new FilterIterator<T>(sameProcPreds,notCall);
}","/** 
 * get the ""normal"" successors (sic) for a return site; i.e., the ""normal"" CFG predecessors that are not call nodes.
 * @see com.ibm.wala.dataflow.IFDS.ISupergraph#getCalledNodes(java.lang.Object)
 */
public Iterator<T> getNormalSuccessors(final T ret){
  Iterator<? extends Object> allPreds=delegate.getPredNodes(ret);
  Filter sameProc=new Filter<T>(){
    public boolean accepts(    T o){
      return getProcOf(ret).equals(getProcOf(o)) && !delegate.isExit(o);
    }
  }
;
  Iterator<Object> sameProcPreds=new FilterIterator<Object>(allPreds,sameProc);
  Filter notCall=new Filter<T>(){
    public boolean accepts(    T o){
      return !delegate.isCall(o);
    }
  }
;
  return new FilterIterator<T>(sameProcPreds,notCall);
}",0.488569562377531
40722,"@SuppressWarnings(""String_Node_Str"") public boolean accepts(Object o){
  return !delegate.isCall((T)o);
}","public boolean accepts(T o){
  return !delegate.isCall(o);
}",0.7151515151515152
40723,"public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Statement src,Statement dest){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Statement s=src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
case NORMAL:
return ReachabilityFunctions.killReachability;
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Statement src,Statement dest){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Statement s=src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case EXC_RET_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
case NORMAL:
return ReachabilityFunctions.killReachability;
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}",0.9884169884169884
40724,"/** 
 * @return the cfg for n, or null if none found
 * @throws IllegalArgumentException if n == null
 */
@Override public ControlFlowGraph<ExplodedBasicBlock> getCFG(CGNode n) throws IllegalArgumentException {
  if (n == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IR ir=n.getIR();
  return ExplodedControlFlowGraph.make(ir);
}","/** 
 * @return the cfg for n, or null if none found
 * @throws IllegalArgumentException if n == null
 */
@Override public ControlFlowGraph<ExplodedBasicBlock> getCFG(CGNode n) throws IllegalArgumentException {
  if (n == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IR ir=n.getIR();
  if (ir == null) {
    return null;
  }
  return ExplodedControlFlowGraph.make(ir);
}",0.9456953642384106
40725,"@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (uses != null && uses.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSABinaryOpInstruction(operator,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1]);
}","@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (uses != null && uses.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSABinaryOpInstruction(operator,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1],mayBeInteger);
}",0.9807407407407408
40726,"SSABinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2){
  super();
  this.result=result;
  this.val1=val1;
  this.val2=val2;
  this.operator=operator;
  Assertions._assert(val1 != -1 && val2 != -1);
}","SSABinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2,boolean mayBeInteger){
  super();
  this.result=result;
  this.val1=val1;
  this.val2=val2;
  this.operator=operator;
  this.mayBeInteger=mayBeInteger;
  Assertions._assert(val1 != -1 && val2 != -1);
}",0.8960302457466919
40727,"/** 
 * @see com.ibm.wala.ssa.SSAInstruction#getDef()
 */
@Override public boolean hasDef(){
  return true;
}","@Override public boolean hasDef(){
  return true;
}",0.6375
40728,"@Override public boolean isPEI(){
  return operator == BinaryOpInstruction.Operator.DIV || operator == BinaryOpInstruction.Operator.REM;
}","@Override public boolean isPEI(){
  return mayBeInteger && operator == BinaryOpInstruction.Operator.DIV || operator == BinaryOpInstruction.Operator.REM;
}",0.9452054794520548
40729,"/** 
 * UGH! This must be the Shrike OPCODE, not the Shrike OPERATOR code!!!!!
 * @artifact 38486
 * @return instruction opcode
 */
public BinaryOpInstruction.IOperator getOperator(){
  return operator;
}","/** 
 * Ugh.  clean up shrike operator stuff.
 */
public BinaryOpInstruction.IOperator getOperator(){
  return operator;
}",0.5950920245398773
40730,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitShift(ShiftInstruction)
 */
@Override public void visitShift(com.ibm.wala.shrikeBT.ShiftInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2));
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitShift(ShiftInstruction)
 */
@Override public void visitShift(com.ibm.wala.shrikeBT.ShiftInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2,true));
}",0.9936305732484076
40731,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitBinaryOp(BinaryOpInstruction)
 */
@Override public void visitBinaryOp(com.ibm.wala.shrikeBT.BinaryOpInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2));
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitBinaryOp(BinaryOpInstruction)
 */
@Override public void visitBinaryOp(com.ibm.wala.shrikeBT.BinaryOpInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  boolean isFloat=instruction.getType().equals(TYPE_double) || instruction.getType().equals(TYPE_float);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2,!isFloat));
}",0.8758169934640523
40732,"public static SSABinaryOpInstruction BinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2){
  return new SSABinaryOpInstruction(operator,result,val1,val2);
}","public static SSABinaryOpInstruction BinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2,boolean mayBeInteger){
  return new SSABinaryOpInstruction(operator,result,val1,val2,mayBeInteger);
}",0.9186602870813396
40733,"/** 
 * @param x set of factoid numbers that previously have been established to hold at a program point
 * @param j a new factoid number which has been discovered to hold at a program point
 * @return the factoid number z which should actually be propagated, based ona merge of the new fact j into the old state represented by x
 */
int merge(IntSet x,int j);","/** 
 * @param x set of factoid numbers that previously have been established to hold at a program point
 * @param j a new factoid number which has been discovered to hold at a program point
 * @return the factoid number z which should actually be propagated, based ona merge of the new fact j into the old state represented by x. return -1 if no fact should be propagated.
 */
int merge(IntSet x,int j);",0.9424083769633508
40734,"protected TypeReference[] makeParameterTypes(MethodReference method,int i){
  TypeReference nominal=method.getParameterType(i);
  if (nominal.isPrimitiveType() || nominal.isArrayType())   return new TypeReference[]{nominal};
 else {
    IClass nc=getCha().lookupClass(nominal);
    Collection subcs=nc.isInterface() ? getCha().getImplementors(nominal) : getCha().computeSubClasses(nominal);
    Set<TypeReference> subs=HashSetFactory.make();
    for (Iterator I=subcs.iterator(); I.hasNext(); ) {
      IClass cs=(IClass)I.next();
      if (!cs.isAbstract() && !cs.isInterface())       subs.add(cs.getReference());
    }
    return subs.toArray(new TypeReference[subs.size()]);
  }
}","protected TypeReference[] makeParameterTypes(IMethod method,int i){
  TypeReference nominal=method.getParameterType(i);
  if (nominal.isPrimitiveType() || nominal.isArrayType())   return new TypeReference[]{nominal};
 else {
    IClass nc=getCha().lookupClass(nominal);
    Collection subcs=nc.isInterface() ? getCha().getImplementors(nominal) : getCha().computeSubClasses(nominal);
    Set<TypeReference> subs=HashSetFactory.make();
    for (Iterator I=subcs.iterator(); I.hasNext(); ) {
      IClass cs=(IClass)I.next();
      if (!cs.isAbstract() && !cs.isInterface())       subs.add(cs.getReference());
    }
    return subs.toArray(new TypeReference[subs.size()]);
  }
}",0.9926362297496318
40735,"/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}","/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}",0.9961685823754788
40736,"/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}","/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_irem:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}",0.99304865938431
40737,"boolean hasNormalEdge(T src,T dst);","/** 
 * This method must return true if and only if a normal edge from src to dst exists in the original CFG and should be kept for the pruned version of that CFG.  Note that this must _must_ return false for any normal edge that is not in the original CFG.
 */
boolean hasNormalEdge(T src,T dst);",0.2108433734939759
40738,"boolean hasExceptionalEdge(T src,T dst);","/** 
 * This method must return true if and only if an exceptional edge from src to dst exists in the original CFG and should be kept for the pruned version of that CFG.  Note that this must _must_ return false for any exceptional edge that is not in the original CFG.
 */
boolean hasExceptionalEdge(T src,T dst);",0.2266288951841359
40739,"public boolean hasNormalEdge(T src,T dst){
  return true;
}","public boolean hasNormalEdge(T src,T dst){
  return cfg.getNormalSuccessors(src).contains(dst);
}",0.7564102564102564
40740,"public static <T extends IBasicBlock>PrunedCFG<T> make(ControlFlowGraph<T> cfg){
  return PrunedCFG.make(cfg,new ExceptionEdgePruner<T>());
}","public static <T extends IBasicBlock>PrunedCFG<T> make(ControlFlowGraph<T> cfg){
  return PrunedCFG.make(cfg,new ExceptionEdgePruner<T>(cfg));
}",0.9894736842105264
40741,"public Iterator<T> getPredNodes(T N){
  return new CompoundIterator<T>(getNormalPredecessors(N),getExceptionalPredecessors(N));
}","public Iterator<T> getPredNodes(final T N){
  return new FilterIterator<T>(cfg.getPredNodes(N),new Filter<T>(){
    public boolean accepts(    T o){
      return currentCFGNodes.containsNode(o) && (filter.hasNormalEdge(o,N) || filter.hasExceptionalEdge(o,N));
    }
  }
);
}",0.3523573200992556
40742,"public Iterator<T> getSuccNodes(T N){
  return new CompoundIterator<T>(getNormalSuccessors(N),getExceptionalSuccessors(N));
}","public Iterator<T> getSuccNodes(final T N){
  return new FilterIterator<T>(cfg.getSuccNodes(N),new Filter<T>(){
    public boolean accepts(    T o){
      return currentCFGNodes.containsNode(o) && (filter.hasNormalEdge(N,o) || filter.hasExceptionalEdge(N,o));
    }
  }
);
}",0.3508771929824561
40743,"/** 
 * Wrap an SSAInstruction in a Statement
 */
public Statement ssaInstruction2Statement(SSAInstruction s){
}","public Statement ssaInstruction2Statement(SSAInstruction s,Map<SSAInstruction,Integer> instructionIndices){
}",0.5610859728506787
40744,"/** 
 * @return for each SSAInstruction, its instruction index in the irinstruction array
 */
private Map<SSAInstruction,Integer> computeInstructionIndices(IR ir){
  Map<SSAInstruction,Integer> result=HashMapFactory.make();
  if (ir != null) {
    SSAInstruction[] instructions=ir.getInstructions();
    for (int i=0; i < instructions.length; i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        result.put(s,new Integer(i));
      }
    }
  }
  return result;
}","/** 
 * @return for each SSAInstruction, its instruction index in the irinstruction array
 */
public static Map<SSAInstruction,Integer> computeInstructionIndices(IR ir){
  Map<SSAInstruction,Integer> result=HashMapFactory.make();
  if (ir != null) {
    SSAInstruction[] instructions=ir.getInstructions();
    for (int i=0; i < instructions.length; i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        result.put(s,new Integer(i));
      }
    }
  }
  return result;
}",0.9816326530612244
40745,"/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(){
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return;
  }
  IR ir=node.getIR();
  if (ir == null) {
    return;
  }
  DefUse DU=node.getDU();
  SSAInstruction[] instructions=ir.getInstructions();
  for (Iterator<? extends Statement> it=iterator(); it.hasNext(); ) {
    Statement s=it.next();
switch (s.getKind()) {
case NORMAL:
case CATCH:
case PI:
case PHI:
{
        SSAInstruction statement=statement2SSAInstruction(instructions,s);
        if (!(statement instanceof SSAAbstractInvokeInstruction)) {
          if (dOptions.isTerminateAtCast() && (statement instanceof SSACheckCastInstruction)) {
            break;
          }
          if (dOptions.isTerminateAtCast() && (statement instanceof SSAInstanceofInstruction)) {
            break;
          }
          for (int i=0; i < statement.getNumberOfDefs(); i++) {
            int def=statement.getDef(i);
            for (Iterator<SSAInstruction> it2=DU.getUses(def); it2.hasNext(); ) {
              SSAInstruction use=it2.next();
              if (dOptions.isIgnoreBasePtrs()) {
                if (use instanceof SSANewInstruction) {
                  continue;
                }
                if (hasBasePointer(use)) {
                  int base=getBasePointer(use);
                  if (def == base) {
                    continue;
                  }
                  if (use instanceof SSAArrayReferenceInstruction) {
                    SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
                    if (def == arr.getIndex()) {
                      continue;
                    }
                  }
                }
              }
              Statement u=ssaInstruction2Statement(use);
              addEdge(s,u);
            }
          }
        }
        break;
      }
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
{
      if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
        Assertions._assert(!s.getKind().equals(Kind.EXC_RET_CALLER));
      }
      ValueNumberCarrier a=(ValueNumberCarrier)s;
      for (Iterator<SSAInstruction> it2=DU.getUses(a.getValueNumber()); it2.hasNext(); ) {
        SSAInstruction use=it2.next();
        if (dOptions.isIgnoreBasePtrs()) {
          if (use instanceof SSANewInstruction) {
            continue;
          }
          if (hasBasePointer(use)) {
            int base=getBasePointer(use);
            if (a.getValueNumber() == base) {
              continue;
            }
            if (use instanceof SSAArrayReferenceInstruction) {
              SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
              if (a.getValueNumber() == arr.getIndex()) {
                continue;
              }
            }
          }
        }
        Statement u=ssaInstruction2Statement(use);
        addEdge(s,u);
      }
      break;
    }
case NORMAL_RET_CALLEE:
  for (  NormalStatement ret : computeReturnStatements(ir)) {
    addEdge(ret,s);
  }
break;
case EXC_RET_CALLEE:
if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
Assertions.UNREACHABLE();
}
for (NormalStatement pei : getPEIs(ir)) {
if (dOptions.isTerminateAtCast() && (pei.getInstruction() instanceof SSACheckCastInstruction)) {
continue;
}
if (pei.getInstruction() instanceof SSAAbstractInvokeInstruction) {
SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)pei.getInstruction();
Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
addEdge(st,s);
}
 else {
addEdge(pei,s);
}
}
break;
case PARAM_CALLER:
{
ParamStatement.ParamCaller pac=(ParamStatement.ParamCaller)s;
int vn=pac.getValueNumber();
if (vn > -1) {
if (ir.getSymbolTable().isParameter(vn)) {
Statement a=new ParamStatement.ParamCallee(node,vn);
addEdge(a,pac);
}
 else {
SSAInstruction d=DU.getDef(vn);
if (dOptions.isTerminateAtCast() && (d instanceof SSACheckCastInstruction)) {
break;
}
if (d != null) {
if (d instanceof SSAAbstractInvokeInstruction) {
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)d;
  if (vn == call.getException()) {
    Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
    addEdge(st,pac);
  }
 else {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addEdge(st,pac);
  }
}
 else {
  Statement ds=ssaInstruction2Statement(d);
  addEdge(ds,pac);
}
}
}
}
}
break;
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
break;
default :
Assertions.UNREACHABLE(s.toString());
break;
}
}
}","/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(){
}",0.1003184713375796
40746,"/** 
 * Assuming a set of facts holds, simplify a CNF formula
 */
private static Collection<? extends IMaxTerm> simplifyCNF(ICNFFormula f,Collection<IMaxTerm> facts,ISemiDecisionProcedure dec){
  Collection<IMaxTerm> result=HashSetFactory.make();
  Collection<IMaxTerm> removedClauses=HashSetFactory.make();
  for (  IMaxTerm d : collectClauses(Collections.singleton(f))) {
    Collection<IMaxTerm> otherFacts=HashSetFactory.make(facts);
    otherFacts.addAll(collectClauses(Collections.singleton(f)));
    otherFacts.remove(d);
    otherFacts.removeAll(removedClauses);
    if (d instanceof Disjunction) {
      d=simplifyDisjunction((Disjunction)d,otherFacts,dec);
    }
    if (dec.isContradiction(d,otherFacts)) {
      return Collections.singleton(BooleanConstantFormula.FALSE);
    }
 else     if (facts.contains(d) || dec.isTautology(d,otherFacts)) {
      removedClauses.add(d);
    }
 else {
      result.add(d);
    }
  }
  if (result.isEmpty()) {
    return Collections.singleton(BooleanConstantFormula.TRUE);
  }
  return result;
}","/** 
 * Assuming a set of facts holds, simplify a CNF formula
 */
private static Collection<? extends IMaxTerm> simplifyCNF(ICNFFormula f,Collection<IMaxTerm> facts,ISemiDecisionProcedure dec){
  Collection<IMaxTerm> result=HashSetFactory.make();
  Collection<IMaxTerm> removedClauses=HashSetFactory.make();
  for (  IMaxTerm d : collectClauses(Collections.singleton(f))) {
    Collection<IMaxTerm> otherFacts=HashSetFactory.make(facts);
    otherFacts.addAll(collectClauses(Collections.singleton(f)));
    otherFacts.remove(d);
    otherFacts.removeAll(removedClauses);
    IMaxTerm checkD=d;
    if (d instanceof Disjunction) {
      checkD=simplifyDisjunction((Disjunction)d,otherFacts,dec);
    }
    if (dec.isContradiction(checkD,otherFacts)) {
      return Collections.singleton(BooleanConstantFormula.FALSE);
    }
 else     if (facts.contains(checkD) || dec.isTautology(checkD,otherFacts)) {
      removedClauses.add(d);
    }
 else {
      result.add(checkD);
    }
  }
  if (result.isEmpty()) {
    return Collections.singleton(BooleanConstantFormula.TRUE);
  }
  return result;
}",0.9568884723523898
40747,"private JavaLauncher(String programArgs,String mainClass,List<String> xtraClasspath){
  super();
  this.programArgs=programArgs;
  this.mainClass=mainClass;
  this.xtraClasspath=xtraClasspath;
}","private JavaLauncher(String programArgs,String mainClass,List<String> xtraClasspath){
  super();
  this.programArgs=programArgs;
  this.mainClass=mainClass;
  if (xtraClasspath != null) {
    this.xtraClasspath.addAll(xtraClasspath);
  }
}",0.74364896073903
40748,"/** 
 * Launch the java process.
 * @throws WalaException
 */
public Process start() throws WalaException {
  String cp=makeClasspath();
  String heap=""String_Node_Str"";
  String cmd=getJavaExe() + heap + cp+ ""String_Node_Str""+ makeLibPath()+ ""String_Node_Str""+ getMainClass()+ ""String_Node_Str""+ getProgramArgs();
  Process p=spawnProcess(cmd);
  stdOutDrain=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  stdInDrain=drainStdErr(p);
  return p;
}","/** 
 * Launch the java process.
 */
public Process start() throws WalaException {
  System.err.println(System.getProperty(""String_Node_Str""));
  String cp=makeClasspath();
  String heap=""String_Node_Str"";
  String cmd=getJavaExe() + heap + cp+ ""String_Node_Str""+ makeLibPath()+ ""String_Node_Str""+ getMainClass()+ ""String_Node_Str""+ getProgramArgs();
  Process p=spawnProcess(cmd);
  stdOutDrain=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  stdInDrain=drainStdErr(p);
  return p;
}",0.2252631578947368
40749,"private String makeClasspath(){
  String cp=""String_Node_Str"" + System.getProperty(""String_Node_Str"");
  if (getXtraClassPath() == null || getXtraClassPath().isEmpty()) {
    return cp;
  }
 else {
    for (Iterator it=getXtraClassPath().iterator(); it.hasNext(); ) {
      cp+=(String)it.next();
      if (it.hasNext()) {
        cp+=""String_Node_Str"";
      }
    }
    cp+=""String_Node_Str"";
    return cp;
  }
}","private String makeClasspath(){
  String cp=""String_Node_Str"" + System.getProperty(""String_Node_Str"");
  if (getXtraClassPath() == null || getXtraClassPath().isEmpty()) {
    return cp;
  }
 else {
    cp+=""String_Node_Str"";
    for (Iterator it=getXtraClassPath().iterator(); it.hasNext(); ) {
      cp+=(String)it.next();
      if (it.hasNext()) {
        cp+=""String_Node_Str"";
      }
    }
    cp+=""String_Node_Str"";
    return cp;
  }
}",0.968494749124854
40750,"public String prettyPrint(ILogicDecorator d){
  if (clauses.size() == 1) {
    return getF1().prettyPrint(d);
  }
 else {
    StringBuffer result=new StringBuffer();
    result.append(""String_Node_Str"");
    result.append(getF1().prettyPrint(d));
    result.append(""String_Node_Str"");
    result.append(d.prettyPrint(getConnective()));
    result.append(""String_Node_Str"");
    result.append(getF2().prettyPrint(d));
    result.append(""String_Node_Str"");
    return result.toString();
  }
}","public String prettyPrint(ILogicDecorator d){
  if (d == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return d.prettyPrint(this);
}",0.3852080123266564
40751,"private static IMaxTerm simplifyDisjunction(Disjunction d,Collection<IMaxTerm> otherFacts,ISemiDecisionProcedure dec){
  Collection<IFormula> result=HashSetFactory.make();
  for (  IFormula f : d.getClauses()) {
    if (dec.isContradiction(f,otherFacts)) {
      result.add(BooleanConstantFormula.FALSE);
    }
 else     if (dec.isTautology(f,otherFacts)) {
      result.add(BooleanConstantFormula.TRUE);
    }
 else {
      result.add(f);
    }
  }
  return Disjunction.make(result);
}","private static IMaxTerm simplifyDisjunction(Disjunction d,Collection<IMaxTerm> otherFacts,ISemiDecisionProcedure dec){
}",0.396039603960396
40752,"/** 
 * @param P governing pointer analysis
 * @throws NullPointerException if P is null
 */
public BasicHeapGraph(final PointerAnalysis P,final CallGraph callGraph) throws NullPointerException {
  super(P.getHeapModel());
  this.pointerAnalysis=P;
  this.callGraph=callGraph;
  final OrdinalSetMapping<PointerKey> pointerKeys=getPointerKeys();
  final NumberedNodeManager<Object> nodeMgr=new NumberedNodeManager<Object>(){
    public Iterator<Object> iterator(){
      return new CompoundIterator<Object>(pointerKeys.iterator(),P.getInstanceKeyMapping().iterator());
    }
    public int getNumberOfNodes(){
      return pointerKeys.getSize() + P.getInstanceKeyMapping().getSize();
    }
    public void addNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public void removeNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public int getNumber(    Object N){
      if (N instanceof PointerKey) {
        return pointerKeys.getMappedIndex((PointerKey)N);
      }
 else {
        if (Assertions.verifyAssertions) {
          if (!(N instanceof InstanceKey)) {
            Assertions.UNREACHABLE(N.getClass().toString());
          }
        }
        int inumber=P.getInstanceKeyMapping().getMappedIndex((InstanceKey)N);
        return (inumber == -1) ? -1 : inumber + pointerKeys.getMaximumIndex();
      }
    }
    public Object getNode(    int number){
      if (number > pointerKeys.getMaximumIndex()) {
        return P.getInstanceKeyMapping().getMappedObject(number - pointerKeys.getSize());
      }
 else {
        return pointerKeys.getMappedObject(number);
      }
    }
    public int getMaxNumber(){
      return getNumberOfNodes() - 1;
    }
    public boolean containsNode(    Object n){
      return getNumber(n) != -1;
    }
    public Iterator<Object> iterateNodes(    IntSet s){
      return new NumberedNodeIterator<Object>(s,this);
    }
  }
;
  final IBinaryNaturalRelation pred=computePredecessors(nodeMgr);
  final IntFunction<Object> toNode=new IntFunction<Object>(){
    public Object apply(    int i){
      return nodeMgr.getNode(i);
    }
  }
;
  this.G=new AbstractNumberedGraph<Object>(){
    private final EdgeManager<Object> edgeMgr=new EdgeManager<Object>(){
      public Iterator<Object> getPredNodes(      Object N){
        int n=nodeMgr.getNumber(N);
        IntSet p=pred.getRelated(n);
        if (p == null) {
          return EmptyIterator.instance();
        }
 else {
          return new IntMapIterator<Object>(p.intIterator(),toNode);
        }
      }
      public int getPredNodeCount(      Object N){
        int n=nodeMgr.getNumber(N);
        return pred.getRelatedCount(n);
      }
      public Iterator<? extends Object> getSuccNodes(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        if (succ == null) {
          return EmptyIterator.instance();
        }
        SparseIntSet s=new MutableSparseIntSet(succ);
        return new IntMapIterator<Object>(s.intIterator(),toNode);
      }
      public int getSuccNodeCount(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        return succ == null ? 0 : succ.length;
      }
      public void addEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeAllIncidentEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeIncomingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeOutgoingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public boolean hasEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
        return false;
      }
    }
;
    @Override protected NodeManager<Object> getNodeManager(){
      return nodeMgr;
    }
    @Override protected EdgeManager<Object> getEdgeManager(){
      return edgeMgr;
    }
  }
;
}","/** 
 * @param P governing pointer analysis
 * @throws NullPointerException if P is null
 */
public BasicHeapGraph(final PointerAnalysis P,final CallGraph callGraph) throws NullPointerException {
  super(P.getHeapModel());
  this.pointerAnalysis=P;
  this.callGraph=callGraph;
  final OrdinalSetMapping<PointerKey> pointerKeys=getPointerKeys();
  final NumberedNodeManager<Object> nodeMgr=new NumberedNodeManager<Object>(){
    public Iterator<Object> iterator(){
      return new CompoundIterator<Object>(pointerKeys.iterator(),P.getInstanceKeyMapping().iterator());
    }
    public int getNumberOfNodes(){
      return pointerKeys.getSize() + P.getInstanceKeyMapping().getSize();
    }
    public void addNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public void removeNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public int getNumber(    Object N){
      if (N instanceof PointerKey) {
        return pointerKeys.getMappedIndex((PointerKey)N);
      }
 else {
        if (Assertions.verifyAssertions) {
          if (!(N instanceof InstanceKey)) {
            Assertions.UNREACHABLE(N.getClass().toString());
          }
        }
        int inumber=P.getInstanceKeyMapping().getMappedIndex((InstanceKey)N);
        return (inumber == -1) ? -1 : inumber + pointerKeys.getMaximumIndex() + 1;
      }
    }
    public Object getNode(    int number){
      if (number > pointerKeys.getMaximumIndex()) {
        return P.getInstanceKeyMapping().getMappedObject(number - pointerKeys.getSize());
      }
 else {
        return pointerKeys.getMappedObject(number);
      }
    }
    public int getMaxNumber(){
      return getNumberOfNodes() - 1;
    }
    public boolean containsNode(    Object n){
      return getNumber(n) != -1;
    }
    public Iterator<Object> iterateNodes(    IntSet s){
      return new NumberedNodeIterator<Object>(s,this);
    }
  }
;
  final IBinaryNaturalRelation pred=computePredecessors(nodeMgr);
  final IntFunction<Object> toNode=new IntFunction<Object>(){
    public Object apply(    int i){
      return nodeMgr.getNode(i);
    }
  }
;
  this.G=new AbstractNumberedGraph<Object>(){
    private final EdgeManager<Object> edgeMgr=new EdgeManager<Object>(){
      public Iterator<Object> getPredNodes(      Object N){
        int n=nodeMgr.getNumber(N);
        IntSet p=pred.getRelated(n);
        if (p == null) {
          return EmptyIterator.instance();
        }
 else {
          return new IntMapIterator<Object>(p.intIterator(),toNode);
        }
      }
      public int getPredNodeCount(      Object N){
        int n=nodeMgr.getNumber(N);
        return pred.getRelatedCount(n);
      }
      public Iterator<? extends Object> getSuccNodes(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        if (succ == null) {
          return EmptyIterator.instance();
        }
        SparseIntSet s=new MutableSparseIntSet(succ);
        return new IntMapIterator<Object>(s.intIterator(),toNode);
      }
      public int getSuccNodeCount(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        return succ == null ? 0 : succ.length;
      }
      public void addEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeAllIncidentEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeIncomingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeOutgoingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public boolean hasEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
        return false;
      }
    }
;
    @Override protected NodeManager<Object> getNodeManager(){
      return nodeMgr;
    }
    @Override protected EdgeManager<Object> getEdgeManager(){
      return edgeMgr;
    }
  }
;
}",0.999498997995992
40753,"/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(ExplodedBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAInvokeInstruction) {
        Statement st=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
        if (st == null) {
          System.err.println(ssaInstructionIndex2Statement);
          Assertions.UNREACHABLE(""String_Node_Str"" + b + ""String_Node_Str""+ b.getLastInstructionIndex()+ ""String_Node_Str""+ s);
        }
        int domainIndex=domain.getMappedIndex(st);
        assert(domainIndex != -1);
        return heapReturnCaller.getRelated(domainIndex);
      }
 else {
        Collection<PointerKey> gen=modRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}","/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(ExplodedBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAAbstractInvokeInstruction) {
        Statement st=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
        if (st == null) {
          System.err.println(ssaInstructionIndex2Statement);
          Assertions.UNREACHABLE(""String_Node_Str"" + b + ""String_Node_Str""+ b.getLastInstructionIndex()+ ""String_Node_Str""+ s);
        }
        int domainIndex=domain.getMappedIndex(st);
        assert(domainIndex != -1);
        return heapReturnCaller.getRelated(domainIndex);
      }
 else {
        Collection<PointerKey> gen=modRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}",0.996572407883462
40754,"public UnaryOperator getEdgeTransferFunction(IBasicBlock src,IBasicBlock dst){
  ExplodedBasicBlock s=(ExplodedBasicBlock)src;
  if (s.getInstruction() != null && !(s.getInstruction() instanceof SSAInvokeInstruction) && !cfg.getNormalSuccessors(src).contains(dst)) {
    return BitVectorIdentity.instance();
  }
 else {
    BitVector kill=kill(s);
    IntSet gen=gen(s);
    if (kill == null) {
      if (gen == null) {
        return BitVectorIdentity.instance();
      }
 else {
        return new BitVectorUnionVector(new BitVectorIntSet(gen).getBitVector());
      }
    }
 else {
      if (gen == null) {
        return new BitVectorMinusVector(kill);
      }
 else {
        return new BitVectorKillGen(kill,new BitVectorIntSet(gen).getBitVector());
      }
    }
  }
}","public UnaryOperator getEdgeTransferFunction(IBasicBlock src,IBasicBlock dst){
  ExplodedBasicBlock s=(ExplodedBasicBlock)src;
  if (s.getInstruction() != null && !(s.getInstruction() instanceof SSAAbstractInvokeInstruction) && !cfg.getNormalSuccessors(src).contains(dst)) {
    return BitVectorIdentity.instance();
  }
 else {
    BitVector kill=kill(s);
    IntSet gen=gen(s);
    if (kill == null) {
      if (gen == null) {
        return BitVectorIdentity.instance();
      }
 else {
        return new BitVectorUnionVector(new BitVectorIntSet(gen).getBitVector());
      }
    }
 else {
      if (gen == null) {
        return new BitVectorMinusVector(kill);
      }
 else {
        return new BitVectorKillGen(kill,new BitVectorIntSet(gen).getBitVector());
      }
    }
  }
}",0.9948652118100128
40755,"public boolean isImplicit(PointerKey p){
  int i=findOrCreateIndex(p);
  return pointsToSets.get(i) == IMPLICIT;
}","public boolean isImplicit(PointerKey p){
  int i=getIndex(p);
  return i != -1 && pointsToSets.get(i) == IMPLICIT;
}",0.9043478260869564
40756,"@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else   if (rhs == this) {
    return this;
  }
 else   if (rhs instanceof PrimitiveType) {
    if (size() > ((PrimitiveType)rhs).size()) {
      return this;
    }
 else {
      return rhs;
    }
  }
 else {
    return TOP;
  }
}","@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else   if (rhs == this) {
    return this;
  }
 else   if (rhs instanceof PrimitiveType) {
    TypeReference other=((PrimitiveType)rhs).reference;
    if (reference == TypeReference.Double) {
      return this;
    }
 else     if (other == TypeReference.Double) {
      return rhs;
    }
 else     if (reference == TypeReference.Float) {
      return this;
    }
 else     if (other == TypeReference.Float) {
      return rhs;
    }
 else {
      if (size() > ((PrimitiveType)rhs).size()) {
        return this;
      }
 else {
        return rhs;
      }
    }
  }
 else {
    return TOP;
  }
}",0.5583657587548638
40757,"public void testPrimordial() throws ClassHierarchyException {
  if (useShortProfile()) {
    return;
  }
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialMainEntrypoints(scope,cha);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
}","public void testPrimordial() throws ClassHierarchyException {
  if (useShortProfile()) {
    return;
  }
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialMainEntrypoints(scope,cha);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
}",0.9939024390243902
40758,"/** 
 * Constructor for SpecJTest.
 * @param arg0
 */
public CallGraphTest(String arg0){
  super(arg0);
}","public CallGraphTest(String arg0){
  super(arg0);
}",0.6538461538461539
40759,"public void testIO() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialPublicEntrypoints(scope,cha,""String_Node_Str"");
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
}","public void testIO() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialPublicEntrypoints(scope,cha,""String_Node_Str"");
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
}",0.9934924078091106
40760,"public void testJava_cup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  doCallGraphs(options,new AnalysisCache(),cha,scope,null,useShortProfile(),false);
}","public void testJava_cup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  doCallGraphs(options,new AnalysisCache(),cha,scope,null,useShortProfile(),false,true);
}",0.994994994994995
40761,"/** 
 * TODO: refactor this to avoid excessive code bloat.
 */
public static void doCallGraphs(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,String dcgFile,boolean stopAfterZeroCFA,boolean stopAfterZeroContainerCFA){
  CallGraph cg=CallGraphTestUtil.buildRTA(options,cache,cha,scope);
  try {
    GraphIntegrity.check(cg);
  }
 catch (  UnsoundGraphException e1) {
    e1.printStackTrace();
    assertTrue(e1.getMessage(),false);
  }
  Set<MethodReference> rtaMethods=CallGraphStats.collectMethods(cg);
  Trace.println(""String_Node_Str"" + rtaMethods.size());
  Trace.println(CallGraphStats.getStats(cg));
  Trace.println(""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZero=checkCallGraph(cg,null,rtaMethods,""String_Node_Str"");
  if (stopAfterZeroCFA) {
    return;
  }
  cg=CallGraphTestUtil.buildZeroOneCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZeroOne=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroContainerCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZeroContainer=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  if (stopAfterZeroContainerCFA)   return;
  cg=CallGraphTestUtil.buildZeroOneContainerCFA(options,cache,cha,scope);
  checkCallGraph(cg,squashZeroContainer,null,""String_Node_Str"");
  checkCallGraph(cg,squashZeroOne,null,""String_Node_Str"");
  if (dcgFile != null) {
    checkAgainstDCG(cg,dcgFile);
  }
  checkICFG(cg);
  return;
}","/** 
 * TODO: refactor this to avoid excessive code bloat.
 */
public static void doCallGraphs(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,String dcgFile,boolean stopAfterZeroCFA,boolean stopAfterZeroContainerCFA,boolean testPAToString){
  CallGraph cg=CallGraphTestUtil.buildRTA(options,cache,cha,scope);
  try {
    GraphIntegrity.check(cg);
  }
 catch (  UnsoundGraphException e1) {
    e1.printStackTrace();
    assertTrue(e1.getMessage(),false);
  }
  Set<MethodReference> rtaMethods=CallGraphStats.collectMethods(cg);
  Trace.println(""String_Node_Str"" + rtaMethods.size());
  Trace.println(CallGraphStats.getStats(cg));
  Trace.println(""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroCFA(options,cache,cha,scope,testPAToString);
  Graph<MethodReference> squashZero=checkCallGraph(cg,null,rtaMethods,""String_Node_Str"");
  if (stopAfterZeroCFA) {
    return;
  }
  cg=CallGraphTestUtil.buildZeroOneCFA(options,cache,cha,scope,testPAToString);
  Graph<MethodReference> squashZeroOne=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroContainerCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZeroContainer=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  if (stopAfterZeroContainerCFA)   return;
  cg=CallGraphTestUtil.buildZeroOneContainerCFA(options,cache,cha,scope);
  checkCallGraph(cg,squashZeroContainer,null,""String_Node_Str"");
  checkCallGraph(cg,squashZeroOne,null,""String_Node_Str"");
  if (dcgFile != null) {
    checkAgainstDCG(cg,dcgFile);
  }
  checkICFG(cg);
  return;
}",0.9829855537720706
40762,"public static CallGraph buildZeroCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  S.stop();
  Trace.println(S.report());
  return cg;
}","public static CallGraph buildZeroCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,boolean testPAtoString){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  if (testPAtoString) {
    builder.getPointerAnalysis().toString();
  }
  S.stop();
  Trace.println(S.report());
  return cg;
}",0.8829268292682927
40763,"public static CallGraph buildZeroOneCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  S.stop();
  Trace.println(S.report());
  return cg;
}","public static CallGraph buildZeroOneCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,boolean testPAtoString){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  if (testPAtoString) {
    builder.getPointerAnalysis().toString();
  }
  S.stop();
  Trace.println(S.report());
  return cg;
}",0.8846153846153846
40764,"public void testClassConstants() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  TypeReference mainClassRef=TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.CLASSCONSTANT_MAIN);
  Assert.assertTrue(cha.lookupClass(mainClassRef) != null);
  Iterable<Entrypoint> entrypoints=Util.makeMainEntrypoints(scope,cha,TestConstants.CLASSCONSTANT_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraph cg=CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
  Trace.println(""String_Node_Str"");
  Trace.println(cg);
  MethodReference mainMethodRef=MethodReference.findOrCreate(mainClassRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> mainMethodNodes=cg.getNodes(mainMethodRef);
  Assert.assertFalse(mainMethodNodes.isEmpty());
  CGNode mainMethodNode=(CGNode)mainMethodNodes.iterator().next();
  Trace.println(""String_Node_Str"");
  Trace.println(mainMethodNode.getIR());
  TypeReference classRef=TypeReference.findOrCreate(ClassLoaderReference.Primordial,""String_Node_Str"");
  MethodReference hashCodeRef=MethodReference.findOrCreate(classRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> hashCodeNodes=cg.getNodes(hashCodeRef);
  Assert.assertFalse(hashCodeNodes.isEmpty());
  Assert.assertTrue(cg.hasEdge(mainMethodNode,hashCodeNodes.iterator().next()));
}","public void testClassConstants() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  TypeReference mainClassRef=TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.CLASSCONSTANT_MAIN);
  Assert.assertTrue(cha.lookupClass(mainClassRef) != null);
  Iterable<Entrypoint> entrypoints=Util.makeMainEntrypoints(scope,cha,TestConstants.CLASSCONSTANT_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraph cg=CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
  Trace.println(""String_Node_Str"");
  Trace.println(cg);
  MethodReference mainMethodRef=MethodReference.findOrCreate(mainClassRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> mainMethodNodes=cg.getNodes(mainMethodRef);
  Assert.assertFalse(mainMethodNodes.isEmpty());
  CGNode mainMethodNode=(CGNode)mainMethodNodes.iterator().next();
  Trace.println(""String_Node_Str"");
  Trace.println(mainMethodNode.getIR());
  TypeReference classRef=TypeReference.findOrCreate(ClassLoaderReference.Primordial,""String_Node_Str"");
  MethodReference hashCodeRef=MethodReference.findOrCreate(classRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> hashCodeNodes=cg.getNodes(hashCodeRef);
  Assert.assertFalse(hashCodeNodes.isEmpty());
  Assert.assertTrue(cg.hasEdge(mainMethodNode,hashCodeNodes.iterator().next()));
}",0.9979757085020244
40765,"public void testJavaCup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope));
}","public void testJavaCup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false));
}",0.9939148073022313
40766,"public void testJLex() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JLEX);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JLEX_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope));
}","public void testJLex() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JLEX);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JLEX_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false));
}",0.9937759336099584
40767,"public void testBcelVerifier() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.BCEL);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.BCEL_VERIFIER_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope));
}","public void testBcelVerifier() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.BCEL);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.BCEL_VERIFIER_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false));
}",0.9939879759519038
40768,"private CallGraph doGraph(boolean usePiNodes) throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.PI_TEST_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  options.getSSAOptions().setUsePiNodes(usePiNodes);
  return CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
}","private CallGraph doGraph(boolean usePiNodes) throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.PI_TEST_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  options.getSSAOptions().setUsePiNodes(usePiNodes);
  return CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
}",0.9947552447552448
40769,"/** 
 * Constructor for SpecJTest.
 * @param arg0
 */
public MultiDimArrayTest(String arg0){
  super(arg0);
}","/** 
 * @param arg0
 */
public MultiDimArrayTest(String arg0){
  super(arg0);
}",0.8404255319148937
40770,"public int getMaxNumber(){
  Assertions.UNREACHABLE();
  return 0;
}","public int getMaxNumber(){
  return getNumberOfNodes() - 1;
}",0.6046511627906976
40771,"public int getNumber(){
  if (isEntryBlock()) {
    return 0;
  }
 else   if (isExitBlock()) {
    return getNumberOfNodes() - 1;
  }
 else {
    return instructionIndex;
  }
}","public int getNumber(){
  if (isEntryBlock()) {
    return 0;
  }
 else   if (isExitBlock()) {
    return getNumberOfNodes() - 1;
  }
 else {
    return instructionIndex + 1;
  }
}",0.9887640449438202
40772,"public IBasicBlock getNode(int number){
  if (number == 0) {
    return entry();
  }
 else   if (number == getNumberOfNodes() - 1) {
    return exit();
  }
 else {
    return normalNodes.get(number);
  }
}","public IBasicBlock getNode(int number){
  if (number == 0) {
    return entry();
  }
 else   if (number == getNumberOfNodes() - 1) {
    return exit();
  }
 else {
    return normalNodes.get(number - 1);
  }
}",0.9903381642512076
40773,"@SuppressWarnings(""String_Node_Str"") public Collection<? extends IFunction> getFunctions(){
  Set<? extends IFunction> s=HashSetFactory.make();
  s.addAll(a.getFunctions());
  s.addAll(b.getFunctions());
  return s;
}","@SuppressWarnings(""String_Node_Str"") public Collection<? extends IFunction> getFunctions(){
  Collection<? extends IFunction> s=HashSetFactory.make();
  s.addAll(a.getFunctions());
  s.addAll(b.getFunctions());
  return s;
}",0.9705215419501134
40774,"@SuppressWarnings(""String_Node_Str"") public Collection<? extends IRelation> getRelations(){
  Set<? extends IRelation> s=HashSetFactory.make();
  s.addAll(a.getRelations());
  s.addAll(b.getRelations());
  return s;
}","@SuppressWarnings(""String_Node_Str"") public Collection<? extends IRelation> getRelations(){
  Collection<? extends IRelation> s=HashSetFactory.make();
  s.addAll(a.getRelations());
  s.addAll(b.getRelations());
  return s;
}",0.9705215419501134
40775,"@SuppressWarnings(""String_Node_Str"") public Collection<InstanceKey> getPointsTo(PointerKey pk){
  Assertions._assert(pk instanceof LocalPointerKey,""String_Node_Str"");
  LocalPointerKey lpk=(LocalPointerKey)pk;
  SimpleDemandPointerFlowGraph g=new SimpleDemandPointerFlowGraph(cg,heapModel,fam,cha);
  CGNode node=lpk.getNode();
  g.addSubgraphForNode(node);
  if (!g.containsNode(pk)) {
    return Collections.emptySet();
  }
  if (VERBOSE) {
    Trace.println(g.toString());
  }
  Filter iKeyFilter=new Filter(){
    public boolean accepts(    Object o){
      return o instanceof InstanceKey;
    }
  }
;
  SlowDFSDiscoverTimeIterator<Object> dfs=new SlowDFSDiscoverTimeIterator<Object>(g,pk);
  return Iterator2Collection.toCollection((Iterator<? extends InstanceKey>)new FilterIterator<Object>(dfs,iKeyFilter));
}","@SuppressWarnings(""String_Node_Str"") public Collection<InstanceKey> getPointsTo(PointerKey pk){
  Assertions._assert(pk instanceof LocalPointerKey,""String_Node_Str"");
  LocalPointerKey lpk=(LocalPointerKey)pk;
  SimpleDemandPointerFlowGraph g=new SimpleDemandPointerFlowGraph(cg,heapModel,fam,cha);
  CGNode node=lpk.getNode();
  g.addSubgraphForNode(node);
  if (!g.containsNode(pk)) {
    return Collections.emptySet();
  }
  if (VERBOSE) {
    Trace.println(g.toString());
  }
  Filter iKeyFilter=new Filter(){
    public boolean accepts(    Object o){
      return o instanceof InstanceKey;
    }
  }
;
  SlowDFSDiscoverTimeIterator<Object> dfs=new SlowDFSDiscoverTimeIterator<Object>(g,pk);
  return Iterator2Collection.toCollection((Iterator<? extends InstanceKey>)(Iterator)new FilterIterator<Object>(dfs,iKeyFilter));
}",0.9939172749391728
40776,"private FunctionTerm(IFunction f,List<ITerm> parameters) throws IllegalArgumentException {
  this.f=f;
  this.parameters=parameters;
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","private FunctionTerm(IFunction f,List<ITerm> parameters) throws IllegalArgumentException {
  this.f=f;
  this.parameters=parameters;
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  ITerm t : parameters) {
    if (t == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}",0.6666666666666666
40777,"/** 
 * Does the term t1 match the pattern t2? Note that this deals with wildcards.
 */
private static boolean termsMatch(ITerm t1,ITerm t2){
  if (t1.equals(t2)) {
    return true;
  }
switch (t1.getKind()) {
case CONSTANT:
case VARIABLE:
    return Wildcard.STAR.equals(t2);
case FUNCTION:
  if (Wildcard.STAR.equals(t2)) {
    return true;
  }
 else {
    if (t2 instanceof FunctionTerm) {
      FunctionTerm f1=(FunctionTerm)t1;
      FunctionTerm f2=(FunctionTerm)t2;
      if (f1.getFunction().equals(f2.getFunction())) {
        for (int i=0; i < f1.getParameters().size(); i++) {
          ITerm x=f1.getParameters().get(i);
          ITerm y=f2.getParameters().get(i);
          if (!termsMatch(x,y)) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  }
default :
Assertions.UNREACHABLE();
return false;
}
}","/** 
 * Does the term t1 match the pattern t2? Note that this deals with wildcards. Records bindings from Wildcards to Terms in the binding map ... modified as a side effect.
 */
private static boolean termsMatch(ITerm t1,ITerm t2,Map<Wildcard,ITerm> binding){
  if (t1.equals(t2)) {
    return true;
  }
  if (t2 instanceof Wildcard) {
    Wildcard w=(Wildcard)t2;
    ITerm b=binding.get(w);
    if (b != null) {
      return b.equals(t1);
    }
 else {
      binding.put(w,t1);
      return true;
    }
  }
switch (t1.getKind()) {
case CONSTANT:
case VARIABLE:
    return false;
case FUNCTION:
  if (t2 instanceof FunctionTerm) {
    FunctionTerm f1=(FunctionTerm)t1;
    FunctionTerm f2=(FunctionTerm)t2;
    if (f1.getFunction().equals(f2.getFunction())) {
      for (int i=0; i < f1.getParameters().size(); i++) {
        ITerm x=f1.getParameters().get(i);
        ITerm y=f2.getParameters().get(i);
        if (!termsMatch(x,y,binding)) {
          return false;
        }
      }
      return true;
    }
  }
return false;
default :
Assertions.UNREACHABLE();
return false;
}
}",0.6990788126919141
40778,"/** 
 * does the structure of some formula f suggest an immediate substitution to simplify the system, based on theory of equality?
 * @return a pair (p1, p2) meaning ""substitute p2 for p1""
 */
private static Pair<ITerm,ITerm> getNextEqualitySubstitution(Collection<IFormula> s,Collection<? extends IFormula> theory,Collection<IFormula> alreadyUsed){
  Collection<IFormula> candidates=HashSetFactory.make();
  candidates.addAll(s);
  candidates.addAll(theory);
  for (  IFormula f : candidates) {
    if (!alreadyUsed.contains(f)) {
      Pair<ITerm,ITerm> substitution=equalitySuggestsSubsitution(f);
      if (substitution != null) {
        alreadyUsed.add(f);
        return substitution;
      }
    }
  }
  return null;
}","/** 
 * does the structure of some formula f suggest an immediate substitution to simplify the system, based on theory of equality?
 * @return a pair (p1, p2) meaning ""substitute p2 for p1""
 */
private static Pair<ITerm,ITerm> getNextEqualitySubstitution(Collection<IFormula> s,Collection<? extends IFormula> theory,Collection<IFormula> alreadyUsed){
  Collection<IFormula> candidates=HashSetFactory.make();
  candidates.addAll(s);
  candidates.addAll(theory);
  for (  IFormula f : candidates) {
    if (!alreadyUsed.contains(f)) {
      Pair<ITerm,ITerm> substitution=equalitySuggestsSubstitution(f);
      if (substitution != null) {
        alreadyUsed.add(f);
        return substitution;
      }
    }
  }
  return null;
}",0.9993127147766324
40779,"/** 
 * in term t, substitute t2 for free occurrences of t1
 */
private static ITerm substitute(ITerm t,ITerm t1,ITerm t2){
  if (termsMatch(t,t1)) {
    return t2;
  }
switch (t.getKind()) {
case CONSTANT:
    return t;
case FUNCTION:
  FunctionTerm f=(FunctionTerm)t;
List<ITerm> terms=new LinkedList<ITerm>();
for (ITerm p : f.getParameters()) {
terms.add(substitute(p,t1,t2));
}
return FunctionTerm.make(f.getFunction(),terms);
case VARIABLE:
if (t1.equals(t)) {
return t2;
}
 else {
return t;
}
default :
Assertions.UNREACHABLE();
return null;
}
}","/** 
 * in term t, substitute t2 for free occurrences of t1
 */
private static ITerm substitute(ITerm t,ITerm t1,ITerm t2,Map<Wildcard,ITerm> binding){
}",0.4056737588652482
40780,"private Wildcard(){
}","private Wildcard(int number){
  this.number=number;
}",0.5675675675675675
40781,"@Override public int hashCode(){
  return 151;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + number;
  return result;
}",0.5263157894736842
40782,"@Override public boolean equals(Object obj){
  return this == obj;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final Wildcard other=(Wildcard)obj;
  if (number != other.number)   return false;
  return true;
}",0.3652694610778443
40783,"@Override public String toString(){
  return ""String_Node_Str"";
}","@Override public String toString(){
  return number == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + number + ""String_Node_Str"";
}",0.6735751295336787
40784,"public Iterator<SSAPhiInstruction> iteratePhis(){
  compressPhis();
  if (stackSlotPhis == null) {
    if (localPhis == null) {
      return EmptyIterator.instance();
    }
 else {
      return Arrays.asList(localPhis).iterator();
    }
  }
 else {
    if (localPhis == null) {
      return Arrays.asList(stackSlotPhis).iterator();
    }
 else {
      return new CompoundIterator<SSAPhiInstruction>(Arrays.asList(stackSlotPhis).iterator(),Arrays.asList(localPhis).iterator());
    }
  }
}","public Iterator<SSAPhiInstruction> iteratePhis(){
  compressPhis();
  if (stackSlotPhis == null) {
    if (localPhis == null) {
      return EmptyIterator.instance();
    }
 else {
      LinkedList<SSAPhiInstruction> result=new LinkedList<SSAPhiInstruction>();
      for (      SSAPhiInstruction phi : localPhis) {
        if (phi != null) {
          result.add(phi);
        }
      }
      return result.iterator();
    }
  }
 else {
    if (localPhis == null) {
      LinkedList<SSAPhiInstruction> result=new LinkedList<SSAPhiInstruction>();
      for (      SSAPhiInstruction phi : stackSlotPhis) {
        if (phi != null) {
          result.add(phi);
        }
      }
      return result.iterator();
    }
 else {
      LinkedList<SSAPhiInstruction> result=new LinkedList<SSAPhiInstruction>();
      for (      SSAPhiInstruction phi : localPhis) {
        if (phi != null) {
          result.add(phi);
        }
      }
      return result.iterator();
    }
  }
}",0.3591501028101439
40785,"public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(30,slice.size());
}","public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(22,slice.size());
}",0.9977324263038548
40786,"/** 
 * Process the given array reference node. Factored out so that derived languages can reuse this code for specially-marked types of array references (as in X10, for which different instruction types get generated, but whose structure is essentially the same as an ordinary array reference).
 */
protected boolean doVisitArrayRefNode(CAstNode n,CAstNode v,CAstNode a,boolean assign,boolean preOp,Context context,CAstVisitor visitor){
  if (assign ? visitor.visitArrayRefAssign(n,v,a,context,visitor) : visitor.visitArrayRefAssignOp(n,v,a,preOp,context,visitor))   return true;
  visitor.visit(n.getChild(0),context,visitor);
  visitor.visitChildren(n,2,context,visitor);
  if (assign)   visitor.leaveArrayRefAssign(n,v,a,context,visitor);
 else   visitor.leaveArrayRefAssignOp(n,v,a,preOp,context,visitor);
  return true;
}","/** 
 * Process the given array reference node. Factored out so that derived languages can reuse this code for specially-marked types of array references (as in X10, for which different instruction types get generated, but whose structure is essentially the same as an ordinary array reference).
 */
protected boolean doVisitArrayRefNode(CAstNode n,CAstNode v,CAstNode a,boolean assign,boolean preOp,Context context,CAstVisitor visitor){
  if (assign ? visitor.visitArrayRefAssign(n,v,a,context,visitor) : visitor.visitArrayRefAssignOp(n,v,a,preOp,context,visitor))   return true;
  visitor.visit(n.getChild(0),context,visitor);
  visitor.visitChildren(n,2,context,visitor);
  if (assign)   visitor.leaveArrayRefAssign(n,v,a,context,visitor);
 else   visitor.leaveArrayRefAssignOp(n,v,a,preOp,context,visitor);
  return false;
}",0.9957703927492448
40787,"protected boolean visitAssignNodes(CAstNode n,Context context,CAstNode v,CAstNode a,CAstVisitor visitor){
  int NT=a.getKind();
  boolean assign=NT == CAstNode.ASSIGN;
  boolean preOp=NT == CAstNode.ASSIGN_PRE_OP;
switch (n.getKind()) {
case CAstNode.ARRAY_REF:
{
      return doVisitArrayRefNode(n,v,a,assign,preOp,context,visitor);
    }
case CAstNode.OBJECT_REF:
{
    if (assign ? visitor.visitObjectRefAssign(n,v,a,context,visitor) : visitor.visitObjectRefAssignOp(n,v,a,preOp,context,visitor))     return true;
    visitor.visit(n.getChild(0),context,visitor);
    if (assign)     visitor.leaveObjectRefAssign(n,v,a,context,visitor);
 else     visitor.leaveObjectRefAssignOp(n,v,a,preOp,context,visitor);
    break;
  }
case CAstNode.BLOCK_EXPR:
{
  if (assign ? visitor.visitBlockExprAssign(n,v,a,context,visitor) : visitor.visitBlockExprAssignOp(n,v,a,preOp,context,visitor))   return true;
  if (visitor.visitAssignNodes(n.getChild(n.getChildCount() - 1),context,v,a,visitor))   return true;
  if (assign)   visitor.leaveBlockExprAssign(n,v,a,context,visitor);
 else   visitor.leaveBlockExprAssignOp(n,v,a,preOp,context,visitor);
  break;
}
case CAstNode.VAR:
{
if (assign ? visitor.visitVarAssign(n,v,a,context,visitor) : visitor.visitVarAssignOp(n,v,a,preOp,context,visitor)) return true;
if (assign) visitor.leaveVarAssign(n,v,a,context,visitor);
 else visitor.leaveVarAssignOp(n,v,a,preOp,context,visitor);
break;
}
default :
{
if (!visitor.doVisitAssignNodes(n,context,v,a,visitor)) {
Trace.println(""String_Node_Str"" + n.getKind());
throw new UnsupportedOperationException(""String_Node_Str"" + CAstPrinter.print(a,context.top().getSourceMap()));
}
}
}
return false;
}","protected boolean visitAssignNodes(CAstNode n,Context context,CAstNode v,CAstNode a,CAstVisitor visitor){
  int NT=a.getKind();
  boolean assign=NT == CAstNode.ASSIGN;
  boolean preOp=NT == CAstNode.ASSIGN_PRE_OP;
switch (n.getKind()) {
case CAstNode.ARRAY_REF:
{
      if (doVisitArrayRefNode(n,v,a,assign,preOp,context,visitor)) {
        return true;
      }
      break;
    }
case CAstNode.OBJECT_REF:
{
    if (assign ? visitor.visitObjectRefAssign(n,v,a,context,visitor) : visitor.visitObjectRefAssignOp(n,v,a,preOp,context,visitor))     return true;
    visitor.visit(n.getChild(0),context,visitor);
    if (assign)     visitor.leaveObjectRefAssign(n,v,a,context,visitor);
 else     visitor.leaveObjectRefAssignOp(n,v,a,preOp,context,visitor);
    break;
  }
case CAstNode.BLOCK_EXPR:
{
  if (assign ? visitor.visitBlockExprAssign(n,v,a,context,visitor) : visitor.visitBlockExprAssignOp(n,v,a,preOp,context,visitor))   return true;
  if (visitor.visitAssignNodes(n.getChild(n.getChildCount() - 1),context,v,a,visitor))   return true;
  if (assign)   visitor.leaveBlockExprAssign(n,v,a,context,visitor);
 else   visitor.leaveBlockExprAssignOp(n,v,a,preOp,context,visitor);
  break;
}
case CAstNode.VAR:
{
if (assign ? visitor.visitVarAssign(n,v,a,context,visitor) : visitor.visitVarAssignOp(n,v,a,preOp,context,visitor)) return true;
if (assign) visitor.leaveVarAssign(n,v,a,context,visitor);
 else visitor.leaveVarAssignOp(n,v,a,preOp,context,visitor);
break;
}
default :
{
if (!visitor.doVisitAssignNodes(n,context,v,a,visitor)) {
Trace.println(""String_Node_Str"" + n.getKind());
throw new UnsupportedOperationException(""String_Node_Str"" + CAstPrinter.print(a,context.top().getSourceMap()));
}
}
}
return false;
}",0.9838282857982946
40788,"/** 
 * Evaluate a meet of the stacks of machine states at the entry of a basic block. TODO: add some efficiency shortcuts. TODO: clean up and refactor.
 * @param bb the basic block at whose entry the meet occurs
 * @return true if the lhs value changes. false otherwise.
 */
private boolean meetStacks(IVariable lhs,IVariable[] rhs,BasicBlock bb,Meeter meeter){
  boolean changed=false;
  MachineState L=(MachineState)lhs;
  int height=computeMeetStackHeight(rhs);
  if (height > -1 && L.stack == null) {
    L.allocateStack();
    L.stackHeight=height;
    changed=true;
  }
  for (int i=0; i < height; i++) {
    int[] R=new int[rhs.length];
    for (int j=0; j < R.length; j++) {
      MachineState m=(MachineState)rhs[j];
      if (m.stack == null) {
        R[j]=TOP;
      }
 else {
        R[j]=m.stack[i];
      }
    }
    int meet=meeter.meetStack(i,R,bb);
    if (L.stack[i] == TOP) {
      if (meet != TOP) {
        changed=true;
        L.stack[i]=meet;
      }
    }
 else     if (meet != L.stack[i]) {
      changed=true;
      L.stack[i]=meet;
    }
  }
  return changed;
}","/** 
 * Evaluate a meet of the stacks of machine states at the entry of a basic block. TODO: add some efficiency shortcuts. TODO: clean up and refactor.
 * @param bb the basic block at whose entry the meet occurs
 * @return true if the lhs value changes. false otherwise.
 */
private boolean meetStacks(IVariable lhs,IVariable[] rhs,BasicBlock bb,Meeter meeter){
  boolean changed=false;
  MachineState L=(MachineState)lhs;
  int height=computeMeetStackHeight(rhs);
  if (height > -1 && L.stack == null) {
    L.allocateStack();
    L.stackHeight=height;
    changed=true;
  }
  for (int i=0; i < height; i++) {
    int[] R=new int[rhs.length];
    for (int j=0; j < R.length; j++) {
      MachineState m=(MachineState)rhs[j];
      if (m.stack == null) {
        R[j]=TOP;
      }
 else {
        R[j]=m.stack[i];
        if (R[j] == 0) {
          R[j]=TOP;
        }
      }
    }
    int meet=meeter.meetStack(i,R,bb);
    if (L.stack[i] == TOP) {
      if (meet != TOP) {
        changed=true;
        L.stack[i]=meet;
      }
    }
 else     if (meet != L.stack[i]) {
      changed=true;
      L.stack[i]=meet;
    }
  }
  return changed;
}",0.9754135002235136
40789,"@Override public String toString(){
  if (isTOP()) {
    return ""String_Node_Str"" + System.identityHashCode(this);
  }
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  result.append(""String_Node_Str"");
  if (stackHeight == 0) {
    result.append(""String_Node_Str"");
  }
 else {
    result.append(array2StringBuffer(stack,stackHeight));
  }
  result.append(""String_Node_Str"");
  result.append(array2StringBuffer(locals,maxLocals));
  result.append(""String_Node_Str"");
  result.append(System.identityHashCode(this));
  return result.toString();
}","@Override public String toString(){
  if (isTOP()) {
    return ""String_Node_Str"" + System.identityHashCode(this);
  }
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  result.append(""String_Node_Str"");
  if (stackHeight == 0) {
    result.append(""String_Node_Str"");
  }
 else {
    result.append(array2StringBuffer(stack,stackHeight));
  }
  result.append(""String_Node_Str"");
  result.append(array2StringBuffer(locals,maxLocals));
  result.append(""String_Node_Str"");
  return result.toString();
}",0.9548872180451128
40790,"/** 
 * @param index an instruction index from the original SSA IR
 * @return the basic block which contains this instruction.
 */
public IBasicBlock getBlockForInstruction(int index){
  SSAInstruction s=ir.getInstructions()[index];
  return instructionToBlock.get(s);
}","/** 
 * @param index an instruction index from the original SSA IR
 * @return the basic block which contains this instruction.
 */
public IBasicBlock getBlockForInstruction(int index){
  SSAInstruction s=null;
  do {
    s=ir.getInstructions()[index++];
  }
 while (s == null);
  return instructionToBlock.get(s);
}",0.9230769230769232
40791,"/** 
 * return the Instruction-Block for the given instruction.
 * @param inst -instruction
 * @return SingleInstructionBasicBlock containing the given instruction
 */
public SingleInstructionBasicBlock getInstructionBlock(SSAInstruction inst){
  return instructionToBlock.get(inst);
}","/** 
 * return the Instruction-Block for the given instruction. DEPRECATED: use getBlockForInstruction instead.
 * @param inst -instruction
 * @return SingleInstructionBasicBlock containing the given instruction
 */
@Deprecated public SingleInstructionBasicBlock getInstructionBlock(SSAInstruction inst){
  return instructionToBlock.get(inst);
}",0.9047619047619048
40792,"@SuppressWarnings(""String_Node_Str"") public Iterator<T> iterator(){
  return (Iterator<T>)Arrays.asList(store).iterator();
}","@SuppressWarnings(""String_Node_Str"") public Iterator<T> iterator(){
  ArrayList<T> result=new ArrayList<T>();
  for (int i=0; i <= maxIndex; i++) {
    result.add((T)store[i]);
  }
  return result.iterator();
}",0.5209580838323353
40793,"@Override public IFormula getF2(){
  Collection<? extends IFormula> c=HashSetFactory.make(clauses);
  c.remove(getF1());
  return make(c);
}","@Override public IFormula getF2(){
  Collection<? extends IFormula> c=HashSetFactory.make(clauses);
  c.remove(getF1());
  if (c.size() == 1) {
    return c.iterator().next();
  }
 else {
    return make(c);
  }
}",0.7932011331444759
40794,"private static Collection<IMaxTerm> collectMaxTerms(IFormula f){
switch (f.getKind()) {
case CONSTANT:
case QUANTIFIED:
case RELATION:
    return Collections.singleton((IMaxTerm)f);
case BINARY:
  AbstractBinaryFormula b=(AbstractBinaryFormula)f;
Collection<IMaxTerm> result=HashSetFactory.make();
result.addAll(collectMaxTerms(b.getF1()));
result.addAll(collectMaxTerms(b.getF2()));
return result;
case NEGATION:
default :
Assertions.UNREACHABLE(f);
return null;
}
}","private static Collection<IMaxTerm> collectMaxTerms(IFormula f){
switch (f.getKind()) {
case CONSTANT:
case QUANTIFIED:
case RELATION:
    return Collections.singleton((IMaxTerm)f);
case BINARY:
  AbstractBinaryFormula b=(AbstractBinaryFormula)f;
if (b.getConnective().equals(BinaryConnective.AND)) {
  Collection<IMaxTerm> result=HashSetFactory.make();
  result.addAll(collectMaxTerms(b.getF1()));
  result.addAll(collectMaxTerms(b.getF2()));
  return result;
}
 else if (b.getConnective().equals(BinaryConnective.OR)) {
  return Collections.singleton(orToMaxTerm(b));
}
 else {
  Assertions.UNREACHABLE();
  return null;
}
case NEGATION:
default :
Assertions.UNREACHABLE(f);
return null;
}
}",0.7310344827586207
40795,"private static Collection<Disjunction> collectClauses(AbstractBinaryFormula b){
  assert(b.getConnective().equals(BinaryConnective.AND));
  Collection<Disjunction> result=HashSetFactory.make();
  IFormula f1=b.getF1();
  if (f1 instanceof AbstractBinaryFormula) {
    AbstractBinaryFormula b1=(AbstractBinaryFormula)f1;
    if (b1.getConnective().equals(BinaryConnective.AND)) {
      result.addAll(collectClauses(b1));
    }
 else {
      result.add(toDisjunction(b1));
    }
  }
 else {
    result.add(toDisjunction(f1));
  }
  IFormula f2=b.getF2();
  if (f2 instanceof AbstractBinaryFormula) {
    AbstractBinaryFormula b2=(AbstractBinaryFormula)f2;
    if (b2.getConnective().equals(BinaryConnective.AND)) {
      result.addAll(collectClauses(b2));
    }
 else {
      result.add(toDisjunction(b2));
    }
  }
 else {
    result.add(toDisjunction(f2));
  }
  return result;
}","private static Collection<Disjunction> collectClauses(AbstractBinaryFormula b){
  if (b.getConnective().equals(BinaryConnective.AND)) {
    Collection<Disjunction> result=HashSetFactory.make();
    IFormula f1=b.getF1();
    if (f1 instanceof AbstractBinaryFormula) {
      AbstractBinaryFormula b1=(AbstractBinaryFormula)f1;
      if (b1.getConnective().equals(BinaryConnective.AND)) {
        result.addAll(collectClauses(b1));
      }
 else {
        result.add(toDisjunction(b1));
      }
    }
 else {
      result.add(toDisjunction(f1));
    }
    IFormula f2=b.getF2();
    if (f2 instanceof AbstractBinaryFormula) {
      AbstractBinaryFormula b2=(AbstractBinaryFormula)f2;
      if (b2.getConnective().equals(BinaryConnective.AND)) {
        result.addAll(collectClauses(b2));
      }
 else {
        result.add(toDisjunction(b2));
      }
    }
 else {
      result.add(toDisjunction(f2));
    }
    return result;
  }
 else {
    return Collections.singleton(toDisjunction(b));
  }
}",0.855923159018143
40796,"public String prettyPrint(ILogicDecorator d){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  result.append(f1.prettyPrint(d));
  result.append(""String_Node_Str"");
  result.append(d.prettyPrint(b));
  result.append(""String_Node_Str"");
  result.append(f2.prettyPrint(d));
  result.append(""String_Node_Str"");
  return result.toString();
}","public String prettyPrint(ILogicDecorator d){
  return d.prettyPrint(this);
}",0.3280898876404494
40797,"public String prettyPrint(IRelation r){
  return r.getSymbol();
}","public String prettyPrint(BinaryFormula f){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  result.append(f.getF1().prettyPrint(this));
  result.append(""String_Node_Str"");
  result.append(prettyPrint(f.getConnective()));
  result.append(""String_Node_Str"");
  result.append(f.getF2().prettyPrint(this));
  result.append(""String_Node_Str"");
  return result.toString();
}",0.1591397849462365
40798,String prettyPrint(IRelation r);,String prettyPrint(BinaryFormula binaryFormula);,0.65
40799,"private static Disjunction toDisjunction(IFormula f){
switch (f.getKind()) {
case BINARY:
    AbstractBinaryFormula b=(AbstractBinaryFormula)f;
  if (b.getConnective().equals(BinaryConnective.OR)) {
    IFormula f1=b.getF1();
    Disjunction d2=toDisjunction(b.getF2());
    Collection<IFormula> c=HashSetFactory.make();
    c.add(f1);
    c.addAll(d2.getClauses());
    return Disjunction.make(c);
  }
 else {
    Assertions.UNREACHABLE(b.getConnective());
    return null;
  }
case CONSTANT:
case QUANTIFIED:
case RELATION:
return Disjunction.make(Collections.singleton(simplify(f)));
case NEGATION:
default :
Assertions.UNREACHABLE(f.getKind());
return null;
}
}","private static Disjunction toDisjunction(IFormula f){
switch (f.getKind()) {
case BINARY:
    AbstractBinaryFormula b=(AbstractBinaryFormula)f;
  if (b.getConnective().equals(BinaryConnective.OR)) {
    IFormula f1=b.getF1();
    Disjunction d2=toDisjunction(b.getF2());
    Collection<IFormula> c=HashSetFactory.make();
    c.add(f1);
    c.addAll(d2.getClauses());
    return Disjunction.make(c);
  }
 else {
    Assertions.UNREACHABLE(b.getConnective());
    return null;
  }
case CONSTANT:
case QUANTIFIED:
case RELATION:
case NEGATION:
return Disjunction.make(Collections.singleton(simplify(f)));
default :
Assertions.UNREACHABLE(f.getKind());
return null;
}
}",0.9082706766917292
40800,"public static IFormula make(IFormula f){
  if (f instanceof RelationFormula) {
    RelationFormula r=(RelationFormula)f;
    if (r.getRelation().equals(BinaryRelation.EQUALS)) {
      return RelationFormula.make(BinaryRelation.NE,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.NE)) {
      return RelationFormula.make(BinaryRelation.EQUALS,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.GE)) {
      return RelationFormula.make(BinaryRelation.LT,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.GT)) {
      return RelationFormula.make(BinaryRelation.LE,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.LE)) {
      return RelationFormula.make(BinaryRelation.GT,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.LT)) {
      return RelationFormula.make(BinaryRelation.GE,r.getTerms());
    }
  }
  return new NotFormula(f);
}","public static IFormula make(IFormula f){
switch (f.getKind()) {
case RELATION:
    RelationFormula r=(RelationFormula)f;
  if (r.getRelation().equals(BinaryRelation.EQUALS)) {
    return RelationFormula.make(BinaryRelation.NE,r.getTerms());
  }
if (r.getRelation().equals(BinaryRelation.NE)) {
  return RelationFormula.make(BinaryRelation.EQUALS,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.GE)) {
return RelationFormula.make(BinaryRelation.LT,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.GT)) {
return RelationFormula.make(BinaryRelation.LE,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.LE)) {
return RelationFormula.make(BinaryRelation.GT,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.LT)) {
return RelationFormula.make(BinaryRelation.GE,r.getTerms());
}
return new NotFormula(f);
case CONSTANT:
case BINARY:
case NEGATION:
case QUANTIFIED:
default :
return new NotFormula(f);
}
}",0.8425026968716289
40801,"/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @param node the node we are computing heap reaching defs for
 * @param ir IR for the node
 * @param pa governing pointer analysis
 * @param mod the set of heap locations which may be written (transitively) by this node. These are logically return values in the SDG.
 * @param statements the statements whose def-use are considered interesting
 * @param exclusions heap locations that should be excluded from data dependence tracking
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  System.err.println(ir);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<Integer,NormalStatement> ssaInstructionIndex2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstructionIndex2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}","/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @param node the node we are computing heap reaching defs for
 * @param ir IR for the node
 * @param pa governing pointer analysis
 * @param mod the set of heap locations which may be written (transitively) by this node. These are logically return values in the SDG.
 * @param statements the statements whose def-use are considered interesting
 * @param exclusions heap locations that should be excluded from data dependence tracking
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<Integer,NormalStatement> ssaInstructionIndex2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstructionIndex2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}",0.9932642487046632
40802,"/** 
 * map each SSAInstruction index to the NormalStatement which represents it.
 */
private static Map<Integer,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<Integer,NormalStatement> result=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      System.err.println(""String_Node_Str"" + n.getInstructionIndex() + ""String_Node_Str""+ n);
      result.put(n.getInstructionIndex(),n);
    }
  }
  return result;
}","/** 
 * map each SSAInstruction index to the NormalStatement which represents it.
 */
private static Map<Integer,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<Integer,NormalStatement> result=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      result.put(n.getInstructionIndex(),n);
    }
  }
  return result;
}",0.8350100603621731
40803,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 * @param options
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}",0.9870689655172412
40804,"/** 
 * some code is required here in order to ""hop-over"" dead blocks that only contain null-instructions.
 * @param bb -basic block
 * @param instbb -an instruction basic-block (SingleInstructionBasicBlock)
 */
private void handleLastInstruction(BasicBlock bb,SingleInstructionBasicBlock instbb){
  Set<BBEdge> edgeWorkSet=HashSetFactory.make();
  if (!instbb.isPiBlock()) {
    for (Iterator sit=cfg.getSuccNodes(bb); sit.hasNext(); ) {
      BasicBlock succNode=(BasicBlock)sit.next();
      boolean fallThrough=isFallThroughEdge(bb,succNode);
      edgeWorkSet.add(new BBEdge(bb,succNode,fallThrough));
    }
  }
 else {
    SSAPiInstruction pi=(SSAPiInstruction)instbb.getInstruction();
    int succNum=pi.getSuccessor();
    BasicBlock succNode=(BasicBlock)cfg.getNode(succNum);
    boolean fallThrough=isFallThroughEdge(bb,succNode);
    edgeWorkSet.add(new BBEdge(bb,succNode,fallThrough));
  }
  if (bb.isExitBlock()) {
    addEdge(instbb,exitBlock);
  }
  while (!edgeWorkSet.isEmpty()) {
    Iterator workIt=edgeWorkSet.iterator();
    BBEdge edge=(BBEdge)workIt.next();
    boolean fallThru=false;
    if (isFallThroughEdge(edge.src,edge.dest)) {
      fallThru=true;
    }
    workIt.remove();
    if (edge.dest.isEntryBlock()) {
      addEdge(instbb,entryBlock);
      if (fallThru) {
        fallThroughTargets.put(instbb,entryBlock);
      }
    }
 else     if (edge.dest.isExitBlock()) {
      if (basicBlockHasNonNullInstruction(edge.dest)) {
        SSAInstruction succInst=getBasicBlockEntry(edge.dest);
        SingleInstructionBasicBlock succBlock=getInstructionBlock(succInst);
        addEdge(instbb,succBlock);
        if (fallThru) {
          fallThroughTargets.put(instbb,succBlock);
        }
      }
 else {
        addEdge(instbb,exitBlock);
        if (fallThru) {
          fallThroughTargets.put(instbb,exitBlock);
        }
      }
    }
 else     if (basicBlockHasNonNullInstruction(edge.dest)) {
      SSAInstruction succInst=getBasicBlockEntry(edge.dest);
      SingleInstructionBasicBlock succBlock=getInstructionBlock(succInst);
      addEdge(instbb,succBlock);
      if (fallThru) {
        fallThroughTargets.put(instbb,succBlock);
      }
    }
 else {
      for (Iterator sit=cfg.getSuccNodes(edge.dest); sit.hasNext(); ) {
        BasicBlock succNode=(BasicBlock)sit.next();
        edgeWorkSet.add(new BBEdge(bb,succNode,edge.isFallThrough));
      }
    }
  }
}","/** 
 * some code is required here in order to ""hop-over"" dead blocks that only contain null-instructions.
 * @param bb -basic block
 * @param instbb -an instruction basic-block (SingleInstructionBasicBlock)
 */
private void handleLastInstruction(BasicBlock bb,SingleInstructionBasicBlock instbb){
}",0.2209087550794237
40805,"/** 
 * process a basic block that does not have pi nodes
 * @param bb -basic block
 * @param blockInstructionArray -instructions of the basic-block
 */
private void processNoPi(BasicBlock bb,Object[] blockInstructionArray){
  int size=blockInstructionArray.length;
  for (int i=0; i < size; i++) {
    SSAInstruction inst=(SSAInstruction)blockInstructionArray[i];
    Assertions.productionAssertion(inst != null);
    SingleInstructionBasicBlock currBlock=getInstructionBlock(inst);
    if (i < size - 1) {
      SSAInstruction nextInst=(SSAInstruction)blockInstructionArray[i + 1];
      Assertions.productionAssertion(nextInst != null);
      SingleInstructionBasicBlock nextBlock=getInstructionBlock(nextInst);
      addEdge(currBlock,nextBlock);
      fallThroughTargets.put(currBlock,nextBlock);
    }
 else {
      handleLastInstruction(bb,currBlock);
    }
  }
}","/** 
 * process a basic block that does not have pi nodes
 * @param bb -basic block
 * @param blockInstructionArray -instructions of the basic-block
 */
private void processNoPi(BasicBlock bb,Object[] blockInstructionArray){
  int size=blockInstructionArray.length;
  for (int i=0; i < size; i++) {
    SSAInstruction inst=(SSAInstruction)blockInstructionArray[i];
    Assertions.productionAssertion(inst != null);
    SingleInstructionBasicBlock currBlock=getInstructionBlock(inst);
    if (currBlock == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + inst);
    }
    if (i < size - 1) {
      SSAInstruction nextInst=(SSAInstruction)blockInstructionArray[i + 1];
      Assertions.productionAssertion(nextInst != null);
      SingleInstructionBasicBlock nextBlock=getInstructionBlock(nextInst);
      addEdge(currBlock,nextBlock);
      fallThroughTargets.put(currBlock,nextBlock);
    }
 else {
      handleLastInstruction(bb,currBlock);
    }
  }
}",0.9503003823047516
40806,"/** 
 * create single-instruction basic-blocks distinguish blocks inside exception handler from other blocks. This is pretty horrible.
 */
private void createBasicBlocks(){
  List<IBasicBlock> basicBlockList=new ArrayList<IBasicBlock>();
  entry=0;
  entryBlock=new SingleInstructionBasicBlock(entry,null,-1);
  entryBlock.setIsEntryBlock(true);
  basicBlockList.add(entryBlock);
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    BasicBlock bb=(BasicBlock)it.next();
    for (Iterator phiIt=bb.iteratePhis(); phiIt.hasNext(); ) {
      SSAPhiInstruction phi=(SSAPhiInstruction)phiIt.next();
      if (phi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,phi,-1));
      }
    }
    for (Iterator piIt=bb.iteratePis(); piIt.hasNext(); ) {
      SSAPiInstruction pi=(SSAPiInstruction)piIt.next();
      if (pi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,pi,-1));
      }
    }
    for (int i=bb.getFirstInstructionIndex(); i <= bb.getLastInstructionIndex(); i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,s,i));
      }
    }
    if (bb instanceof ExceptionHandlerBasicBlock) {
      ExceptionHandlerBasicBlock ebb=(ExceptionHandlerBasicBlock)bb;
      SSAInstruction catchInst=ebb.getCatchInstruction();
      if (catchInst != null) {
        int blockNum=basicBlockList.size();
        new SingleInstructionExceptionHandlerBlock(blockNum,catchInst);
      }
    }
  }
  exit=basicBlockList.size();
  exitBlock=new SingleInstructionBasicBlock(exit,null,-1);
  exitBlock.setIsExitBlock(true);
  basicBlockList.add(exitBlock);
  basicBlocks=new SingleInstructionBasicBlock[basicBlockList.size()];
  for (int i=0; i < basicBlockList.size(); i++) {
    SingleInstructionBasicBlock sibb=(SingleInstructionBasicBlock)basicBlockList.get(i);
    basicBlocks[i]=sibb;
    SSAInstruction blockInstruction=sibb.getInstruction();
    if (blockInstruction != null) {
      instructionToBlock.put(blockInstruction,sibb);
    }
  }
}","/** 
 * create single-instruction basic-blocks distinguish blocks inside exception handler from other blocks. This is pretty horrible.
 */
private void createBasicBlocks(){
  List<IBasicBlock> basicBlockList=new ArrayList<IBasicBlock>();
  entry=0;
  entryBlock=new SingleInstructionBasicBlock(entry,null,-1);
  entryBlock.setIsEntryBlock(true);
  basicBlockList.add(entryBlock);
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    BasicBlock bb=(BasicBlock)it.next();
    for (Iterator phiIt=bb.iteratePhis(); phiIt.hasNext(); ) {
      SSAPhiInstruction phi=(SSAPhiInstruction)phiIt.next();
      if (phi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,phi,-1));
      }
    }
    for (Iterator piIt=bb.iteratePis(); piIt.hasNext(); ) {
      SSAPiInstruction pi=(SSAPiInstruction)piIt.next();
      if (pi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,pi,-1));
      }
    }
    for (int i=bb.getFirstInstructionIndex(); i <= bb.getLastInstructionIndex(); i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,s,i));
      }
    }
    if (bb instanceof ExceptionHandlerBasicBlock) {
      ExceptionHandlerBasicBlock ebb=(ExceptionHandlerBasicBlock)bb;
      SSAInstruction catchInst=ebb.getCatchInstruction();
      if (catchInst != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionExceptionHandlerBlock(blockNum,catchInst));
      }
    }
  }
  exit=basicBlockList.size();
  exitBlock=new SingleInstructionBasicBlock(exit,null,-1);
  exitBlock.setIsExitBlock(true);
  basicBlockList.add(exitBlock);
  basicBlocks=new SingleInstructionBasicBlock[basicBlockList.size()];
  for (int i=0; i < basicBlockList.size(); i++) {
    SingleInstructionBasicBlock sibb=(SingleInstructionBasicBlock)basicBlockList.get(i);
    basicBlocks[i]=sibb;
    SSAInstruction blockInstruction=sibb.getInstruction();
    if (blockInstruction != null) {
      instructionToBlock.put(blockInstruction,sibb);
    }
  }
}",0.9954995499549956
40807,"/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<SSAInstruction,NormalStatement> ssaInstruction2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstruction2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstruction2Statement,exclusions);
}","/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @param node the node we are computing heap reaching defs for
 * @param ir IR for the node
 * @param pa governing pointer analysis
 * @param mod the set of heap locations which may be written (transitively) by this node. These are logically return values in the SDG.
 * @param statements the statements whose def-use are considered interesting
 * @param exclusions heap locations that should be excluded from data dependence tracking
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  System.err.println(ir);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<Integer,NormalStatement> ssaInstructionIndex2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstructionIndex2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}",0.8553864168618267
40808,"/** 
 * map each SSAInstruction to the NormalStatement which represents it.
 */
private static Map<SSAInstruction,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<SSAInstruction,NormalStatement> ssaInstruction2Statement=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      ssaInstruction2Statement.put(n.getInstruction(),n);
    }
  }
  return ssaInstruction2Statement;
}","/** 
 * map each SSAInstruction index to the NormalStatement which represents it.
 */
private static Map<Integer,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<Integer,NormalStatement> result=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      System.err.println(""String_Node_Str"" + n.getInstructionIndex() + ""String_Node_Str""+ n);
      result.put(n.getInstructionIndex(),n);
    }
  }
  return result;
}",0.7383444338725024
40809,"private void initHeapReturnCaller(){
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.HEAP_RET_CALLER)) {
      HeapStatement.ReturnCaller r=(ReturnCaller)s;
      NormalStatement call=ssaInstruction2Statement.get(r.getCall());
      int i=domain.getMappedIndex(call);
      int j=domain.getMappedIndex(r);
      heapReturnCaller.add(i,j);
    }
  }
}","private void initHeapReturnCaller(){
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.HEAP_RET_CALLER)) {
      HeapStatement.ReturnCaller r=(ReturnCaller)s;
      NormalStatement call=ssaInstructionIndex2Statement.get(r.getCallIndex());
      int i=domain.getMappedIndex(call);
      int j=domain.getMappedIndex(r);
      heapReturnCaller.add(i,j);
    }
  }
}",0.9865591397849462
40810,"/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(SingleInstructionBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAInvokeInstruction) {
        return heapReturnCaller.getRelated(domain.getMappedIndex(ssaInstruction2Statement.get(s)));
      }
 else {
        Collection<PointerKey> gen=ModRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstruction2Statement.get(s);
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}","/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(SingleInstructionBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAInvokeInstruction) {
        Statement st=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
        if (st == null) {
          System.err.println(ssaInstructionIndex2Statement);
          Assertions.UNREACHABLE(""String_Node_Str"" + b + ""String_Node_Str""+ b.getLastInstructionIndex()+ ""String_Node_Str""+ s);
        }
        int domainIndex=domain.getMappedIndex(st);
        assert(domainIndex != -1);
        return heapReturnCaller.getRelated(domainIndex);
      }
 else {
        Collection<PointerKey> gen=ModRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}",0.7591836734693878
40811,"RDMap(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement,HeapExclusions exclusions){
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  this.exclusions=exclusions;
  Map<PointerKey,MutableIntSet> pointerKeyMod=initPointerKeyMod(domain,node,h,pa);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  eagerPopulate(pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
}","RDMap(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement,HeapExclusions exclusions){
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  this.exclusions=exclusions;
  Map<PointerKey,MutableIntSet> pointerKeyMod=initPointerKeyMod(domain,node,h,pa);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  eagerPopulate(pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstructionIndex2Statement);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
}",0.9802197802197802
40812,"private void eagerPopulate(Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement){
  for (  Statement s : domain) {
    delegate.put(s,computeResult(s,pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement));
  }
}","private void eagerPopulate(Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstruction2Statement){
  for (  Statement s : domain) {
    delegate.put(s,computeResult(s,pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement));
  }
}",0.9818569903948772
40813,"/** 
 * For each statement s, compute the set of statements that may def the heap value read by s.
 * @param mod
 * @param ssaInstruction2Statement
 */
private static Map<Statement,OrdinalSet<Statement>> makeResult(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement,HeapExclusions exclusions){
  return new RDMap(solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement,exclusions);
}","/** 
 * For each statement s, compute the set of statements that may def the heap value read by s.
 */
private static Map<Statement,OrdinalSet<Statement>> makeResult(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement,HeapExclusions exclusions){
  return new RDMap(solver,domain,node,h,pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}",0.9323843416370108
40814,"public RD(CGNode node,ExpandedControlFlowGraph cfg,PointerAnalysis pa,OrdinalSetMapping<Statement> domain,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement,HeapExclusions exclusions){
  this.node=node;
  this.cfg=cfg;
  this.domain=domain;
  this.pa=pa;
  this.h=new DelegatingExtendedHeapModel(pa.getHeapModel());
  this.ssaInstruction2Statement=ssaInstruction2Statement;
  this.exclusions=exclusions;
  initHeapReturnCaller();
}","public RD(CGNode node,ExpandedControlFlowGraph cfg,PointerAnalysis pa,OrdinalSetMapping<Statement> domain,Map<Integer,NormalStatement> ssaInstructionIndex2Statement,HeapExclusions exclusions){
  this.node=node;
  this.cfg=cfg;
  this.domain=domain;
  this.pa=pa;
  this.h=new DelegatingExtendedHeapModel(pa.getHeapModel());
  this.ssaInstructionIndex2Statement=ssaInstructionIndex2Statement;
  this.exclusions=exclusions;
  initHeapReturnCaller();
}",0.9595505617977528
40815,"/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
private OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement){
switch (s.getKind()) {
case NORMAL:
    NormalStatement n=(NormalStatement)s;
  Collection<PointerKey> ref=ModRef.getRef(node,h,pa,n.getInstruction(),exclusions);
if (!ref.isEmpty()) {
  IBasicBlock bb=cfg.getBlockForInstruction(n.getInstructionIndex());
  BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
  MutableSparseIntSet defs=new MutableSparseIntSet();
  for (  PointerKey p : ref) {
    if (pointerKeyMod.get(p) != null) {
      defs.addAll(pointerKeyMod.get(p).intersection(v.getValue()));
    }
  }
  return new OrdinalSet<Statement>(defs,domain);
}
 else {
  return OrdinalSet.empty();
}
case HEAP_RET_CALLEE:
{
HeapStatement.ReturnCallee r=(HeapStatement.ReturnCallee)s;
PointerKey p=r.getLocation();
BitVectorVariable v=(BitVectorVariable)solver.getIn(cfg.exit());
if (pointerKeyMod.get(p) == null) {
  return OrdinalSet.empty();
}
return new OrdinalSet<Statement>(pointerKeyMod.get(p).intersection(v.getValue()),domain);
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)s;
IBasicBlock bb=cfg.getBlockForInstruction(r.getCall());
BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
if (allCalleesMod(r,mod) || pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case HEAP_PARAM_CALLER:
{
HeapStatement.ParamCaller r=(HeapStatement.ParamCaller)s;
NormalStatement call=ssaInstruction2Statement.get(r.getCall());
IBasicBlock callBlock=cfg.getBlockForInstruction(call.getInstructionIndex());
BitVectorVariable v=(BitVectorVariable)solver.getIn(callBlock);
if (pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PARAM_CALLER:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case PHI:
case PI:
case CATCH:
case METHOD_ENTRY:
return OrdinalSet.empty();
case HEAP_PARAM_CALLEE:
return OrdinalSet.empty();
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
private OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement){
switch (s.getKind()) {
case NORMAL:
    NormalStatement n=(NormalStatement)s;
  Collection<PointerKey> ref=ModRef.getRef(node,h,pa,n.getInstruction(),exclusions);
if (!ref.isEmpty()) {
  IBasicBlock bb=cfg.getBlockForInstruction(n.getInstructionIndex());
  BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
  MutableSparseIntSet defs=new MutableSparseIntSet();
  for (  PointerKey p : ref) {
    if (pointerKeyMod.get(p) != null) {
      defs.addAll(pointerKeyMod.get(p).intersection(v.getValue()));
    }
  }
  return new OrdinalSet<Statement>(defs,domain);
}
 else {
  return OrdinalSet.empty();
}
case HEAP_RET_CALLEE:
{
HeapStatement.ReturnCallee r=(HeapStatement.ReturnCallee)s;
PointerKey p=r.getLocation();
BitVectorVariable v=(BitVectorVariable)solver.getIn(cfg.exit());
if (pointerKeyMod.get(p) == null) {
  return OrdinalSet.empty();
}
return new OrdinalSet<Statement>(pointerKeyMod.get(p).intersection(v.getValue()),domain);
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)s;
IBasicBlock bb=cfg.getBlockForInstruction(r.getCall());
BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
if (allCalleesMod(r,mod) || pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case HEAP_PARAM_CALLER:
{
HeapStatement.ParamCaller r=(HeapStatement.ParamCaller)s;
NormalStatement call=ssaInstructionIndex2Statement.get(r.getCallIndex());
IBasicBlock callBlock=cfg.getBlockForInstruction(call.getInstructionIndex());
BitVectorVariable v=(BitVectorVariable)solver.getIn(callBlock);
if (pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PARAM_CALLER:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case PHI:
case PI:
case CATCH:
case METHOD_ENTRY:
return OrdinalSet.empty();
case HEAP_PARAM_CALLEE:
return OrdinalSet.empty();
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}",0.994034302759135
40816,"public ParamCaller(CGNode node,SSAAbstractInvokeInstruction call,PointerKey loc){
  super(node,loc);
  this.call=call;
}","public ParamCaller(CGNode node,int callIndex,PointerKey loc){
  super(node,loc);
  this.callIndex=callIndex;
}",0.808695652173913
40817,"public SSAAbstractInvokeInstruction getCall(){
  return call;
}","public SSAAbstractInvokeInstruction getCall(){
  return (SSAAbstractInvokeInstruction)getNode().getIR().getInstructions()[callIndex];
}",0.6363636363636364
40818,"public ReturnCaller(CGNode node,SSAAbstractInvokeInstruction call,PointerKey loc){
  super(node,loc);
  this.call=call;
}","public ReturnCaller(CGNode node,int callIndex,PointerKey loc){
  super(node,loc);
  this.callIndex=callIndex;
}",0.8103448275862069
40819,"/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 * @param dOptions
 */
private void addParamPassingStatements(SSAAbstractInvokeInstruction call,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamStatement.ParamCaller(node,call,call.getUse(j));
    addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
      addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.ParamCaller(node,call,p);
      addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.ReturnCaller(node,call,p);
      addNode(st);
      rets.add(st);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 */
private void addParamPassingStatements(int callIndex,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)node.getIR().getInstructions()[callIndex];
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamStatement.ParamCaller(node,call,call.getUse(j));
    addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
      addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.ParamCaller(node,callIndex,p);
      addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.ReturnCaller(node,callIndex,p);
      addNode(st);
      rets.add(st);
    }
  }
}",0.9375433726578764
40820,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 * @param options
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements((SSAAbstractInvokeInstruction)s,ref);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 * @param options
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}",0.9305555555555556
40821,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  this.lines=new String[p.getLastLine() - p.getFirstLine() + 1];
  BufferedReader r=new BufferedReader(new InputStreamReader(p.getInputStream()));
  int line=1;
  while (line <= p.getLastLine()) {
    String theLine=r.readLine();
    if (line >= p.getFirstLine()) {
      lines[line - p.getFirstLine()]=line == p.getLastLine() ? theLine.substring(0,p.getLastCol() + 1) : theLine;
    }
    line++;
  }
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  this.lines=new String[p.getLastLine() - p.getFirstLine() + 1];
  BufferedReader r=new BufferedReader(new InputStreamReader(p.getInputStream()));
  int line=1;
  while (line <= p.getLastLine()) {
    String theLine=r.readLine();
    if (line >= p.getFirstLine()) {
      lines[line - p.getFirstLine()]=line == p.getLastLine() ? theLine.substring(0,Math.min(theLine.length(),p.getLastCol() + 1)) : theLine;
    }
    line++;
  }
}",0.97196261682243
40822,"/** 
 * @return TypeReference
 */
public FieldReference getDeclaredField(){
  return field;
}","public FieldReference getDeclaredField(){
  return field;
}",0.7763157894736842
40823,"@Override public boolean isPEI(){
  return true;
}","@Override public boolean isPEI(){
  return !isStatic();
}",0.8785046728971962
40824,"/** 
 * @return TypeReference
 */
public TypeReference getDeclaredFieldType(){
  return field.getFieldType();
}","public TypeReference getDeclaredFieldType(){
  return field.getFieldType();
}",0.8191489361702128
40825,"@Override public Collection<TypeReference> getExceptionTypes(){
  return null;
}","@Override public Collection<TypeReference> getExceptionTypes(){
  return Collections.emptySet();
}",0.8764044943820225
40826,"public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
  }
  return null;
}","public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
    try {
      Collection<IClass> ifaces=isInterface() ? getAllAncestorInterfaces() : getAllImplementedInterfaces();
      for (      IClass i : ifaces) {
        f=i.getField(name);
        if (f != null) {
          fieldMap.put(name,f);
          return f;
        }
      }
    }
 catch (    ClassHierarchyException e) {
    }
  }
  return null;
}",0.6743362831858407
40827,"/** 
 * Find the IMethod in the workspace corresponding to a method selector.
 * @return null if not found
 */
public static IMethod findJavaMethodInWorkspace(String klass,String selector){
  IType type=null;
  try {
    type=findJavaClassInWorkspace(klass);
  }
 catch (  Throwable t) {
    return null;
  }
  if (type == null) {
    return null;
  }
  String name=parseForName(selector,type);
  String[] paramTypes=parseForParameterTypes(selector);
  IMethod m=type.getMethod(name,paramTypes);
  IMethod[] methods=type.findMethods(m);
  if (methods != null && methods.length == 1) {
    return methods[0];
  }
 else {
    try {
      List<IMethod> matches=new ArrayList<IMethod>();
      ITypeParameter[] tp=type.getTypeParameters();
      Collection<String> typeParameterNames=HashSetFactory.make(tp.length);
      for (      ITypeParameter p : tp) {
        typeParameterNames.add(p.getElementName());
      }
      METHODS:       for (      IMethod x : type.getMethods()) {
        if (x.getElementName().equals(name)) {
          if (x.getParameterTypes().length == paramTypes.length) {
            for (int i=0; i < x.getParameterTypes().length; i++) {
              String s1=Signature.getTypeErasure(Signature.getSignatureSimpleName(x.getParameterTypes()[i]));
              String s2=Signature.getTypeErasure(Signature.getSignatureSimpleName(paramTypes[i]));
              if (typeParameterNames.contains(s1)) {
              }
 else {
                if (!s1.equals(s2)) {
                  continue METHODS;
                }
              }
            }
            matches.add(x);
          }
        }
      }
      if (matches.size() == 1) {
        return matches.get(0);
      }
 else {
        System.err.println(""String_Node_Str"" + m);
        return null;
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
      return null;
    }
  }
}","/** 
 * Find the IMethod in the workspace corresponding to a method selector. TODO: this is way too slow.   figure out something better.
 * @return null if not found
 */
public static IMethod findJavaMethodInWorkspace(String klass,String selector){
  IType type=null;
  try {
    type=findJavaClassInWorkspace(klass);
  }
 catch (  Throwable t) {
    return null;
  }
  if (type == null) {
    return null;
  }
  String name=parseForName(selector,type);
  String[] paramTypes=parseForParameterTypes(selector);
  IMethod m=type.getMethod(name,paramTypes);
  IMethod[] methods=type.findMethods(m);
  if (methods != null && methods.length == 1) {
    return methods[0];
  }
 else {
    try {
      List<IMethod> matches=new ArrayList<IMethod>();
      Collection<String> typeParameterNames=getTypeParameterNames(type);
      METHODS:       for (      IMethod x : type.getMethods()) {
        if (x.getElementName().equals(name)) {
          if (x.getParameterTypes().length == paramTypes.length) {
            for (int i=0; i < x.getParameterTypes().length; i++) {
              String s1=Signature.getTypeErasure(Signature.getSignatureSimpleName(x.getParameterTypes()[i]));
              String s2=Signature.getTypeErasure(Signature.getSignatureSimpleName(paramTypes[i]));
              if (typeParameterNames.contains(s1)) {
              }
 else {
                if (!s1.equals(s2)) {
                  continue METHODS;
                }
              }
            }
            matches.add(x);
          }
        }
      }
      if (matches.size() == 1) {
        return matches.get(0);
      }
 else {
        System.err.println(""String_Node_Str"" + m);
        return null;
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
      return null;
    }
  }
}",0.915032679738562
40828,"@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  kludge.add((IJavaElement)match.getElement());
}","@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  result.add((IMethod)match.getElement());
}",0.9105058365758756
40829,"/** 
 * Find the IType in the workspace corresponding to a class name. TODO: this is too slow. find a better way.
 * @return null if not found
 */
public static IType findJavaClassInWorkspace(String className){
  SearchPattern p=SearchPattern.createPattern(className,IJavaSearchConstants.CLASS,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_EXACT_MATCH);
  IJavaSearchScope scope=SearchEngine.createWorkspaceScope();
  SearchEngine engine=new SearchEngine();
  final Collection<IJavaElement> kludge=HashSetFactory.make();
  SearchRequestor requestor=new SearchRequestor(){
    @Override public void acceptSearchMatch(    SearchMatch match) throws CoreException {
      kludge.add((IJavaElement)match.getElement());
    }
  }
;
  try {
    engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  if (kludge.size() == 1) {
    System.err.println(""String_Node_Str"" + className);
    return (IType)kludge.iterator().next();
  }
 else {
    System.err.println(""String_Node_Str"" + className);
    return null;
  }
}","/** 
 * Find the IType in the workspace corresponding to a class name. TODO: this is too slow. find a better way.
 * @return null if not found
 */
public static IType findJavaClassInWorkspace(String className){
  SearchPattern p=SearchPattern.createPattern(className,IJavaSearchConstants.CLASS_AND_INTERFACE,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_EXACT_MATCH);
  IJavaSearchScope scope=SearchEngine.createWorkspaceScope();
  SearchEngine engine=new SearchEngine();
  final Collection<IJavaElement> kludge=HashSetFactory.make();
  SearchRequestor requestor=new SearchRequestor(){
    @Override public void acceptSearchMatch(    SearchMatch match) throws CoreException {
      kludge.add((IJavaElement)match.getElement());
    }
  }
;
  try {
    engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  if (kludge.size() == 1) {
    System.err.println(""String_Node_Str"" + className);
    return (IType)kludge.iterator().next();
  }
 else {
    System.err.println(""String_Node_Str"" + className);
    return null;
  }
}",0.9938271604938272
40830,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(String fileName) throws IOException {
  URL url=getFileURLFromPlugin(fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}",0.98355754857997
40831,"/** 
 * get a file URL for a file from a plugin
 * @param fileName the file name
 * @return the URL, or <code>null</code> if the file is not found
 * @throws IOException
 */
private static URL getFileURLFromPlugin(String fileName) throws IOException {
  URL url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
  if (url == null) {
    fileName=""String_Node_Str"" + fileName;
    url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
    if (url == null) {
      return null;
    }
  }
  url=FileLocator.toFileURL(url);
  url=fixupFileURLSpaces(url);
  return url;
}","/** 
 * get a file URL for a file from a plugin
 * @param fileName the file name
 * @return the URL, or <code>null</code> if the file is not found
 * @throws IOException
 */
private static URL getFileURLFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=FileLocator.find(p.getBundle(),new Path(fileName),null);
  if (url == null) {
    fileName=""String_Node_Str"" + fileName;
    url=FileLocator.find(p.getBundle(),new Path(fileName),null);
    if (url == null) {
      return null;
    }
  }
  url=FileLocator.toFileURL(url);
  url=fixupFileURLSpaces(url);
  return url;
}",0.6760098928277
40832,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static File getFileFromPlugin(String fileName) throws IOException {
  URL url=getFileURLFromPlugin(fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}",0.9691011235955056
40833,"/** 
 */
public static File getFile(String fileName) throws IOException {
  return (CorePlugin.getDefault() == null) ? getFileFromClassLoader(fileName) : getFileFromPlugin(fileName);
}","/** 
 */
public static File getFile(String fileName) throws IOException {
  return (CorePlugin.getDefault() == null) ? getFileFromClassLoader(fileName) : getFileFromPlugin(CorePlugin.getDefault(),fileName);
}",0.9387755102040816
40834,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
public static Module getJarFileModule(String fileName) throws IOException {
  if (CorePlugin.getDefault() == null) {
    return getJarFileFromClassLoader(fileName);
  }
 else {
    try {
      IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
      IFile file=workspaceRoot.getFile(new Path(fileName));
      if (file != null) {
        return new JarFileModule(new JarFile(fileName,false));
      }
    }
 catch (    Exception e) {
    }
    return getFromPlugin(fileName);
  }
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
public static Module getJarFileModule(String fileName) throws IOException {
  if (CorePlugin.getDefault() == null) {
    return getJarFileFromClassLoader(fileName);
  }
 else {
    try {
      IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
      IFile file=workspaceRoot.getFile(new Path(fileName));
      if (file != null) {
        return new JarFileModule(new JarFile(fileName,false));
      }
    }
 catch (    Exception e) {
    }
    return getFromPlugin(CorePlugin.getDefault(),fileName);
  }
}",0.981012658227848
40835,"public Instruction redirectTargets(int[] targetMap){
  return make(targetMap[label[0]]);
}","public Instruction redirectTargets(int[] targetMap) throws IllegalArgumentException {
  try {
    return make(targetMap[label[0]]);
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
}",0.5325443786982249
40836,"public Instruction redirectTargets(int[] targetMap){
  int[] cs=new int[casesAndLabels.length];
  for (int i=0; i < cs.length; i+=2) {
    cs[i]=casesAndLabels[i];
    cs[i + 1]=targetMap[casesAndLabels[i + 1]];
  }
  return make(cs,targetMap[defaultLabel]);
}","public Instruction redirectTargets(int[] targetMap) throws IllegalArgumentException {
  try {
    int[] cs=new int[casesAndLabels.length];
    for (int i=0; i < cs.length; i+=2) {
      cs[i]=casesAndLabels[i];
      cs[i + 1]=targetMap[casesAndLabels[i + 1]];
    }
    return make(cs,targetMap[defaultLabel]);
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
}",0.7558139534883721
40837,"public String getJavaLibraryVersion(){
  JarFile rtJar=getRtJar();
  Assertions._assert(rtJar != null,""String_Node_Str"");
  try {
    Manifest man=rtJar.getManifest();
    Assertions._assert(man != null,""String_Node_Str"");
    String result=man.getMainAttributes().getValue(""String_Node_Str"");
    if (result == null) {
      Attributes att=man.getMainAttributes();
      System.err.println(""String_Node_Str"" + att);
      Assertions.UNREACHABLE(""String_Node_Str"" + rtJar.getName() + ""String_Node_Str"");
    }
    return result;
  }
 catch (  java.io.IOException e) {
    Assertions.UNREACHABLE(""String_Node_Str"");
    return null;
  }
}","public String getJavaLibraryVersion() throws IllegalStateException {
  JarFile rtJar=getRtJar();
  if (rtJar == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    Manifest man=rtJar.getManifest();
    Assertions._assert(man != null,""String_Node_Str"");
    String result=man.getMainAttributes().getValue(""String_Node_Str"");
    if (result == null) {
      Attributes att=man.getMainAttributes();
      System.err.println(""String_Node_Str"" + att);
      Assertions.UNREACHABLE(""String_Node_Str"" + rtJar.getName() + ""String_Node_Str"");
    }
    return result;
  }
 catch (  java.io.IOException e) {
    Assertions.UNREACHABLE(""String_Node_Str"");
    return null;
  }
}",0.9174174174174174
40838,"public boolean isJava15Libraries(){
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}","public boolean isJava15Libraries() throws IllegalStateException {
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}",0.8706896551724138
40839,"/** 
 * @return the ClassLoaderReference specified by <code>name</code>.
 */
public ClassLoaderReference getLoader(Atom name){
  if (Assertions.verifyAssertions) {
    if (name.getVal(0) > 'Z') {
      Assertions._assert(name.getVal(0) <= 'Z',""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  return loadersByName.get(name);
}","/** 
 * @return the ClassLoaderReference specified by <code>name</code>.
 */
public ClassLoaderReference getLoader(Atom name) throws IllegalArgumentException {
  if (name.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    if (name.getVal(0) > 'Z') {
      Assertions._assert(name.getVal(0) <= 'Z',""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  return loadersByName.get(name);
}",0.8438287153652393
40840,"public boolean isJava14Libraries(){
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}","public boolean isJava14Libraries() throws IllegalStateException {
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}",0.8706896551724138
40841,"/** 
 * build a constraint saying v \in s
 */
public static IFormula makeSetConstraint(Variable v,IntSet s){
  IntIterator it=s.intIterator();
  int first=it.next();
  IFormula result=RelationFormula.makeEquals(v,first);
  while (it.hasNext()) {
    int i=it.next();
    result=BinaryFormula.or(result,RelationFormula.makeEquals(v,i));
  }
  return result;
}","/** 
 * build a constraint saying v \in s
 */
public static IFormula makeSetConstraint(Variable v,IntSet s){
  if (s.isEmpty()) {
    return RelationFormula.makeEquals(IntConstant.make(0),IntConstant.make(1));
  }
  IntIterator it=s.intIterator();
  int first=it.next();
  IFormula result=RelationFormula.makeEquals(v,first);
  while (it.hasNext()) {
    int i=it.next();
    result=BinaryFormula.or(result,RelationFormula.makeEquals(v,i));
  }
  return result;
}",0.8721071863580999
40842,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null || uses.length == 0 ? val1 : uses[0],uses == null ? val2 : uses[1]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (uses != null && uses.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + uses.length);
  }
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1]);
}",0.7161716171617162
40843,"public SSAPhiInstruction(int result,int[] params){
  super();
  this.result=result;
  this.params=params;
}","public SSAPhiInstruction(int result,int[] params) throws IllegalArgumentException {
  super();
  this.result=result;
  this.params=params;
  if (params.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6331360946745562
40844,"/** 
 * Note: names for class loader references must be unique.
 * @see java.lang.Object#equals(Object)
 */
public boolean equals(Object obj){
  if (Assertions.verifyAssertions) {
    Assertions._assert(this.getClass().equals(obj.getClass()));
  }
  ClassLoaderReference o=(ClassLoaderReference)obj;
  return name.equals(o.name);
}","/** 
 * Note: names for class loader references must be unique.
 * @see java.lang.Object#equals(Object)
 */
public boolean equals(Object obj){
  if (!getClass().equals(obj.getClass())) {
    return false;
  }
 else {
    ClassLoaderReference o=(ClassLoaderReference)obj;
    return name.equals(o.name);
  }
}",0.5446009389671361
40845,"public static TypeSignature make(String s){
  assert(s.length() > 0);
switch (s.charAt(0)) {
case TypeReference.VoidTypeCode:
    Assertions.UNREACHABLE();
  return null;
case TypeReference.BooleanTypeCode:
return BaseType.BOOLEAN;
case TypeReference.ByteTypeCode:
return BaseType.BYTE;
case TypeReference.ShortTypeCode:
return BaseType.SHORT;
case TypeReference.IntTypeCode:
return BaseType.INT;
case TypeReference.LongTypeCode:
return BaseType.LONG;
case TypeReference.FloatTypeCode:
return BaseType.FLOAT;
case TypeReference.DoubleTypeCode:
return BaseType.DOUBLE;
case TypeReference.CharTypeCode:
return BaseType.CHAR;
case 'L':
return ClassTypeSignature.makeClassTypeSig(s);
case 'T':
return TypeVariableSignature.make(s);
case TypeReference.ArrayTypeCode:
return ArrayTypeSignature.make(s);
default :
Assertions.UNREACHABLE(s);
return null;
}
}","public static TypeSignature make(String s) throws IllegalArgumentException {
  assert(s.length() > 0);
switch (s.charAt(0)) {
case TypeReference.VoidTypeCode:
    Assertions.UNREACHABLE();
  return null;
case TypeReference.BooleanTypeCode:
return BaseType.BOOLEAN;
case TypeReference.ByteTypeCode:
return BaseType.BYTE;
case TypeReference.ShortTypeCode:
return BaseType.SHORT;
case TypeReference.IntTypeCode:
return BaseType.INT;
case TypeReference.LongTypeCode:
return BaseType.LONG;
case TypeReference.FloatTypeCode:
return BaseType.FLOAT;
case TypeReference.DoubleTypeCode:
return BaseType.DOUBLE;
case TypeReference.CharTypeCode:
return BaseType.CHAR;
case 'L':
return ClassTypeSignature.makeClassTypeSig(s);
case 'T':
return TypeVariableSignature.make(s);
case TypeReference.ArrayTypeCode:
return ArrayTypeSignature.make(s);
default :
throw new IllegalArgumentException(""String_Node_Str"" + s);
}
}",0.930365296803653
40846,"/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs){
  ArrayList<String> sigs=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
switch (typeSigs.charAt(i)) {
case TypeReference.BooleanTypeCode:
case TypeReference.ByteTypeCode:
case TypeReference.IntTypeCode:
sigs.add(typeSigs.substring(i - 1,i + 1));
break;
case 'T':
case TypeReference.ClassTypeCode:
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
break;
default :
Assertions.UNREACHABLE(""String_Node_Str"" + typeSigs.charAt(i));
}
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs) throws IllegalArgumentException {
  ArrayList<String> sigs=new ArrayList<String>(10);
  if (typeSigs.length() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + typeSigs);
  }
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
switch (typeSigs.charAt(i)) {
case TypeReference.BooleanTypeCode:
case TypeReference.ByteTypeCode:
case TypeReference.IntTypeCode:
sigs.add(typeSigs.substring(i - 1,i + 1));
break;
case 'T':
case TypeReference.ClassTypeCode:
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
break;
default :
Assertions.UNREACHABLE(""String_Node_Str"" + typeSigs.charAt(i));
}
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}",0.9699624530663328
40847,"/** 
 * Is ""this"" atom a reserved member name? Note: Sun has reserved all member names starting with '<' for future use. At present, only <init> and <clinit> are used.
 */
public final boolean isReservedMemberName(){
  return val[0] == '<';
}","/** 
 * Is ""this"" atom a reserved member name? Note: Sun has reserved all member names starting with '<' for future use. At present, only <init> and <clinit> are used.
 */
public final boolean isReservedMemberName(){
  if (length() == 0) {
    return false;
  }
  return val[0] == '<';
}",0.9149338374291116
40848,"/** 
 * Parse ""this"" array descriptor to obtain number of dimensions in corresponding array type. this: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public final int parseForArrayDimensionality(){
  for (int i=0; ; ++i)   if (val[i] != '[')   return i;
}","/** 
 * Parse ""this"" array descriptor to obtain number of dimensions in corresponding array type. this: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public final int parseForArrayDimensionality() throws IllegalArgumentException {
  if (val.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; ; ++i) {
    if (val[i] != '[') {
      return i;
    }
  }
}",0.8221941992433796
40849,"public byte getVal(int i){
  return val[i];
}","/** 
 * @param i
 * @return
 */
public byte getVal(int i) throws IllegalArgumentException {
  try {
    return val[i];
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ val.length);
  }
}",0.286624203821656
40850,"/** 
 * Is ""this"" atom a class descriptor?
 */
public final boolean isClassDescriptor(){
  return val[0] == 'L';
}","/** 
 * Is ""this"" atom a class descriptor?
 */
public final boolean isClassDescriptor(){
  if (length() == 0) {
    return false;
  }
  return val[0] == 'L';
}",0.8351648351648352
40851,"/** 
 * Parse ""this"" array descriptor to obtain descriptor for array's element type. this: array descriptor - something like ""[I""
 * @return array element descriptor - something like ""I""
 */
public final Atom parseForArrayElementDescriptor(){
  return findOrCreate(val,1,val.length - 1);
}","/** 
 * Parse ""this"" array descriptor to obtain descriptor for array's element type. this: array descriptor - something like ""[I""
 * @return array element descriptor - something like ""I""
 */
public final Atom parseForArrayElementDescriptor() throws IllegalArgumentException {
  if (val.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return findOrCreate(val,1,val.length - 1);
}",0.82689556509299
40852,"/** 
 * Is ""this"" atom a method descriptor?
 */
public final boolean isMethodDescriptor(){
  return val[0] == '(';
}","/** 
 * Is ""this"" atom a method descriptor?
 */
public final boolean isMethodDescriptor() throws IllegalArgumentException {
  if (length() == 0) {
    return false;
  }
  return val[0] == '(';
}",0.7483870967741936
40853,"/** 
 * Return the innermost element type reference for an array
 */
public final Atom parseForInnermostArrayElementDescriptor(){
  int i=0;
  while (val[i] == '[') {
    i++;
  }
  return findOrCreate(val,i,val.length - i);
}","/** 
 * Return the innermost element type reference for an array
 */
public final Atom parseForInnermostArrayElementDescriptor() throws IllegalArgumentException {
  if (val.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int i=0;
  while (val[i] == '[') {
    i++;
  }
  return findOrCreate(val,i,val.length - i);
}",0.7888307155322862
40854,"public T next(){
  int i=numbers.next();
  T result=nodeManager.getNode(i);
  if (Assertions.verifyAssertions) {
    if (result == null) {
      Assertions._assert(result != null,""String_Node_Str"" + i);
    }
  }
  return result;
}","public T next() throws NoSuchElementException {
  int i=numbers.next();
  T result=nodeManager.getNode(i);
  if (Assertions.verifyAssertions) {
    if (result == null) {
      Assertions._assert(result != null,""String_Node_Str"" + i);
    }
  }
  return result;
}",0.9371196754563894
40855,"@SuppressWarnings(""String_Node_Str"") private static ECallGraph loadFromFile(String fileName,ClassLoader loader){
  Resource r=new XMIResourceImpl(URI.createURI(fileName));
  XMLResource.XMLMap xmlMap=new XMLMapImpl();
  xmlMap.setNoNamespacePackage(CallGraphPackage.eINSTANCE);
  Map<String,XMLMap> options=new HashMap<String,XMLMap>();
  options.put(XMLResource.OPTION_XML_MAP,xmlMap);
  try {
    r.load(options);
  }
 catch (  IOException e) {
    InputStream s=loader.getResourceAsStream(fileName);
    Assertions.productionAssertion(s != null,""String_Node_Str"" + fileName);
    ResourceSet resSet=new ResourceSetImpl();
    r=resSet.createResource(URI.createURI(""String_Node_Str""));
    options=new HashMap<String,XMLMap>();
    try {
      r.load(s,options);
    }
 catch (    IOException e2) {
      e2.printStackTrace();
      Assertions.UNREACHABLE(""String_Node_Str"" + fileName);
    }
  }
  EList contents=r.getContents();
  for (Iterator<EObject> it=contents.iterator(); it.hasNext(); ) {
    Object o=it.next();
    if (o instanceof ECallGraph) {
      return (ECallGraph)o;
    }
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private static ECallGraph loadFromFile(String fileName,ClassLoader loader) throws IllegalArgumentException {
  Resource r=new XMIResourceImpl(URI.createURI(fileName));
  XMLResource.XMLMap xmlMap=new XMLMapImpl();
  xmlMap.setNoNamespacePackage(CallGraphPackage.eINSTANCE);
  Map<String,XMLMap> options=new HashMap<String,XMLMap>();
  options.put(XMLResource.OPTION_XML_MAP,xmlMap);
  try {
    r.load(options);
  }
 catch (  IOException e) {
    InputStream s=loader.getResourceAsStream(fileName);
    if (s == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + fileName);
    }
    ResourceSet resSet=new ResourceSetImpl();
    r=resSet.createResource(URI.createURI(""String_Node_Str""));
    options=new HashMap<String,XMLMap>();
    try {
      r.load(s,options);
    }
 catch (    IOException e2) {
      e2.printStackTrace();
      Assertions.UNREACHABLE(""String_Node_Str"" + fileName);
    }
  }
  EList contents=r.getContents();
  for (Iterator<EObject> it=contents.iterator(); it.hasNext(); ) {
    Object o=it.next();
    if (o instanceof ECallGraph) {
      return (ECallGraph)o;
    }
  }
  return null;
}",0.9281332164767748
40856,"@SuppressWarnings(""String_Node_Str"") public static ECallGraphWrapper load(String fileName,ClassLoader loader){
  ECallGraph G=loadFromFile(fileName,loader);
  Assertions.productionAssertion(G != null);
  ECallGraphWrapper result=new ECallGraphWrapper();
  for (Iterator<EPair> it=G.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator<EPair> it=G.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}","@SuppressWarnings(""String_Node_Str"") public static ECallGraphWrapper load(String fileName,ClassLoader loader) throws IllegalArgumentException {
  ECallGraph G=loadFromFile(fileName,loader);
  Assertions.productionAssertion(G != null);
  ECallGraphWrapper result=new ECallGraphWrapper();
  for (Iterator<EPair> it=G.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator<EPair> it=G.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}",0.9702970297029704
40857,"/** 
 * @param o an EClassHierarchy
 * @return a ClassHierarchy populated according to the contents of o
 */
@SuppressWarnings(""String_Node_Str"") public static EClassHierarchyWrapper load(EObject o){
  EClassHierarchy cha=(EClassHierarchy)o;
  Assertions.productionAssertion(cha != null);
  EClassHierarchyWrapper result=new EClassHierarchyWrapper();
  for (Iterator<EObject> it=cha.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=cha.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}","/** 
 * @param o an EClassHierarchy
 * @return a ClassHierarchy populated according to the contents of o
 */
@SuppressWarnings(""String_Node_Str"") public static EClassHierarchyWrapper load(EClassHierarchy cha){
  Assertions.productionAssertion(cha != null);
  EClassHierarchyWrapper result=new EClassHierarchyWrapper();
  for (Iterator<EObject> it=cha.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=cha.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}",0.3498402555910543
40858,"/** 
 * TODO: refactor
 */
@SuppressWarnings(""String_Node_Str"") public static EInterfaceHierarchyWrapper load(EObject o){
  EInterfaceHierarchy h=(EInterfaceHierarchy)o;
  Assertions.productionAssertion(h != null);
  EInterfaceHierarchyWrapper result=new EInterfaceHierarchyWrapper();
  for (Iterator<EObject> it=h.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=h.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}","/** 
 * TODO: refactor
 */
@SuppressWarnings(""String_Node_Str"") public static EInterfaceHierarchyWrapper load(EInterfaceHierarchy h){
  Assertions.productionAssertion(h != null);
  EInterfaceHierarchyWrapper result=new EInterfaceHierarchyWrapper();
  for (Iterator<EObject> it=h.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=h.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}",0.2563176895306859
40859,"/** 
 * @param xmlFile an xml file
 * @return List<EObject> serialized in said file.
 */
public static List<EObject> readEObjects(String xmlFile,ClassLoader loader){
}","/** 
 * @param xmlFile an xml file
 * @return List<EObject> serialized in said file.
 */
public static List<EObject> readEObjects(String xmlFile,ClassLoader loader) throws WalaException {
  URL url=loader.getResource(xmlFile);
  URI fileURI=null;
  if (url != null) {
    fileURI=URI.createURI(url.toString());
  }
 else {
    fileURI=URI.createFileURI(xmlFile);
  }
  URIConverter converter=getURIConverter();
  ResourceSet resourceSet=new ResourceSetImpl();
  resourceSet.setURIConverter(converter);
  Resource resource=resourceSet.createResource(fileURI);
  try {
    resource.load(null);
  }
 catch (  IOException e) {
    throw new WalaException(""String_Node_Str"" + xmlFile + ""String_Node_Str"",e);
  }
  return resource.getContents();
}",0.36784140969163
40860,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null || uses.length == 0 ? val1 : uses[0],uses == null ? val2 : uses[1]);
}",0.9559471365638766
40861,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAGetCaughtExceptionInstruction(bbNumber,defs == null ? exceptionValueNumber : defs[0]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAGetCaughtExceptionInstruction(bbNumber,defs == null || defs.length == 0 ? exceptionValueNumber : defs[0]);
}",0.9415204678362572
40862,"/** 
 * Method getUse.
 * @param j
 * @return value number representing the jth use in this instruction. -1 meansTOP (i.e., the value doesn't matter)
 */
public int getUse(int j){
  Assertions.UNREACHABLE();
  return -1;
}","/** 
 * Method getUse.
 * @param j
 * @return value number representing the jth use in this instruction. -1 meansTOP (i.e., the value doesn't matter)
 */
public int getUse(int j) throws UnsupportedOperationException {
  throw new UnsupportedOperationException();
}",0.7736625514403292
40863,"public ExplodedSupergraph(ISupergraph<T,?> supergraph,IFlowFunctionMap flowFunctions){
  this.supergraph=supergraph;
  this.flowFunctions=flowFunctions;
}","public ExplodedSupergraph(ISupergraph<T,?> supergraph,IFlowFunctionMap<T> flowFunctions){
  this.supergraph=supergraph;
  this.flowFunctions=flowFunctions;
}",0.990353697749196
40864,"public Iterator<ExplodedSupergraphNode<T>> getPredNodes(ExplodedSupergraphNode<T> node){
  T dest=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getPredNodeCount(dest));
  for (Iterator<? extends T> it=supergraph.getPredNodes(dest); it.hasNext(); ) {
    T src=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IFlowFunction f=getFlowFunction(src,dest);
      if (f instanceof IReversibleFlowFunction) {
        IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
        IntSet sources=rf.getSources(node.getFact());
        if (sources != null) {
          for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(src,t));
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
      }
    }
 else {
      for (Iterator it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        Object callBlock=it2.next();
        IFlowFunction f=flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        if (f instanceof IReversibleFlowFunction) {
          IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
          IntSet sources=rf.getSources(node.getFact());
          if (sources != null) {
            for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
              int t=ii.next();
              result.add(new ExplodedSupergraphNode<T>(src,t));
            }
          }
        }
 else {
          Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
        }
      }
    }
  }
  return result.iterator();
}","public Iterator<ExplodedSupergraphNode<T>> getPredNodes(ExplodedSupergraphNode<T> node){
  T dest=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getPredNodeCount(dest));
  for (Iterator<? extends T> it=supergraph.getPredNodes(dest); it.hasNext(); ) {
    T src=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IFlowFunction f=getFlowFunction(src,dest);
      if (f instanceof IReversibleFlowFunction) {
        IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
        IntSet sources=rf.getSources(node.getFact());
        if (sources != null) {
          for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(src,t));
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
      }
    }
 else {
      for (Iterator<? extends T> it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        T callBlock=it2.next();
        IFlowFunction f=flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        if (f instanceof IReversibleFlowFunction) {
          IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
          IntSet sources=rf.getSources(node.getFact());
          if (sources != null) {
            for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
              int t=ii.next();
              result.add(new ExplodedSupergraphNode<T>(src,t));
            }
          }
        }
 else {
          Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
        }
      }
    }
  }
  return result.iterator();
}",0.9940191387559808
40865,"public Iterator<ExplodedSupergraphNode<T>> getSuccNodes(ExplodedSupergraphNode<T> node){
  T src=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getSuccNodeCount(src));
  for (Iterator<? extends T> it=supergraph.getSuccNodes(src); it.hasNext(); ) {
    T dest=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IUnaryFlowFunction f=(IUnaryFlowFunction)getFlowFunction(src,dest);
      IntSet targets=f.getTargets(node.getFact());
      if (targets != null) {
        for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
          int t=ii.next();
          result.add(new ExplodedSupergraphNode<T>(dest,t));
        }
      }
    }
 else {
      for (Iterator it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        Object callBlock=it2.next();
        IUnaryFlowFunction f=(IUnaryFlowFunction)flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        IntSet targets=f.getTargets(node.getFact());
        if (targets != null) {
          for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(dest,t));
          }
        }
      }
    }
  }
  return result.iterator();
}","public Iterator<ExplodedSupergraphNode<T>> getSuccNodes(ExplodedSupergraphNode<T> node){
  T src=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getSuccNodeCount(src));
  for (Iterator<? extends T> it=supergraph.getSuccNodes(src); it.hasNext(); ) {
    T dest=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IUnaryFlowFunction f=(IUnaryFlowFunction)getFlowFunction(src,dest);
      IntSet targets=f.getTargets(node.getFact());
      if (targets != null) {
        for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
          int t=ii.next();
          result.add(new ExplodedSupergraphNode<T>(dest,t));
        }
      }
    }
 else {
      for (Iterator<? extends T> it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        T callBlock=it2.next();
        IUnaryFlowFunction f=(IUnaryFlowFunction)flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        IntSet targets=f.getTargets(node.getFact());
        if (targets != null) {
          for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(dest,t));
          }
        }
      }
    }
  }
  return result.iterator();
}",0.9921630094043888
40866,"/** 
 * @param supergraph
 * @param flowFunctions
 * @param solver
 */
public ExplodedSupergraphWithSummaryEdges(ISupergraph<T,?> supergraph,IFlowFunctionMap flowFunctions,TabulationSolver<T,?> solver){
  super(supergraph,flowFunctions);
  this.solver=solver;
}","/** 
 * @param supergraph
 * @param flowFunctions
 * @param solver
 */
public ExplodedSupergraphWithSummaryEdges(ISupergraph<T,?> supergraph,IFlowFunctionMap<T> flowFunctions,TabulationSolver<T,?> solver){
  super(supergraph,flowFunctions);
  this.solver=solver;
}",0.9942857142857144
40867,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest, when the supergraph does not contain any callees of src. This happens via, e.g., slicing.
 */
public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest, when the supergraph does not contain any callees of src. This happens via, e.g., slicing.
 */
public IUnaryFlowFunction getCallNoneToReturnFlowFunction(T src,T dest);",0.9593220338983052
40868,"/** 
 * @param call supergraph node of the call instruction for this return edge.
 * @param src
 * @param dest
 * @return the flow function for a ""return"" edge in the supergraph fromsrc->dest
 */
public IFlowFunction getReturnFlowFunction(Object call,Object src,Object dest);","/** 
 * @param call supergraph node of the call instruction for this return edge.
 * @param src
 * @param dest
 * @return the flow function for a ""return"" edge in the supergraph fromsrc->dest
 */
public IFlowFunction getReturnFlowFunction(T call,T src,T dest);",0.9607476635514018
40869,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getCallFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getCallFlowFunction(T src,T dest);",0.9615384615384616
40870,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""normal"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getNormalFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""normal"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getNormalFlowFunction(T src,T dest);",0.9623655913978496
40871,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest
 */
public IUnaryFlowFunction getCallToReturnFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest
 */
public IUnaryFlowFunction getCallToReturnFlowFunction(T src,T dest);",0.965
40872,"public static IdentityFlowFunctions singleton(){
  return SINGLETON;
}","@SuppressWarnings(""String_Node_Str"") public static <T>IdentityFlowFunctions<T> singleton(){
  return SINGLETON;
}",0.7650273224043715
40873,public IFlowFunctionMap getFunctionMap();,public IFlowFunctionMap<T> getFunctionMap();,0.9647058823529412
40874,"public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Object src,Object dest){
  Statement s=(Statement)src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Statement src,Statement dest){
  Statement s=(Statement)src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}",0.9828947368421052
40875,"public IFlowFunction getReturnFlowFunction(Object call,Object src,Object dest){
  return ReachabilityFunctions.singleton().getReturnFlowFunction(call,src,dest);
}","public IFlowFunction getReturnFlowFunction(Statement call,Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getReturnFlowFunction(call,src,dest);
}",0.9009009009009008
40876,"public IUnaryFlowFunction getCallFlowFunction(Object src,Object dest){
  return ReachabilityFunctions.singleton().getCallFlowFunction(src,dest);
}","public IUnaryFlowFunction getCallFlowFunction(Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getCallFlowFunction(src,dest);
}",0.9261744966442952
40877,"public IUnaryFlowFunction getNormalFlowFunction(Object src,Object dest){
  return ReachabilityFunctions.singleton().getNormalFlowFunction(src,dest);
}","public IUnaryFlowFunction getNormalFlowFunction(Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getNormalFlowFunction(src,dest);
}",0.9281045751633988
40878,"public IUnaryFlowFunction getCallToReturnFlowFunction(Object src,Object dest){
  return ReachabilityFunctions.singleton().getCallToReturnFlowFunction(src,dest);
}","public IUnaryFlowFunction getCallToReturnFlowFunction(Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getCallToReturnFlowFunction(src,dest);
}",0.9333333333333332
40879,"public IFlowFunctionMap getFunctionMap(){
  return f;
}","public IFlowFunctionMap<Statement> getFunctionMap(){
  return f;
}",0.9090909090909092
40880,"/** 
 * Method newPhi.
 * @param rhs
 * @return int
 */
public int newPhi(int[] rhs){
  int result=getNewValueNumber();
  SSAPhiInstruction phi=new SSAPhiInstruction(result,(int[])rhs.clone());
  values[result]=new PhiValue(phi);
  return result;
}","/** 
 * Method newPhi.
 * @param rhs
 * @return int
 */
public int newPhi(int[] rhs) throws IllegalArgumentException {
  int result=getNewValueNumber();
  SSAPhiInstruction phi=new SSAPhiInstruction(result,(int[])rhs.clone());
  values[result]=new PhiValue(phi);
  return result;
}",0.9376181474480152
40881,"public static IWorkspace getWorkspace(){
  return ResourcesPlugin.getWorkspace();
}","/** 
 * @return null if there's a problem
 */
public static IWorkspace getWorkspace(){
  try {
    return ResourcesPlugin.getWorkspace();
  }
 catch (  Throwable t) {
    return null;
  }
}",0.6102941176470589
40882,"/** 
 * Add allocation statements to the fake root method for each possible value of parameter i. If necessary, add a phi to combine the values.
 * @param m
 * @param i
 * @return value number holding the parameter to the call; -1 if there wassome error
 */
protected int makeArgument(FakeRootMethod m,int i,WarningSet warnings){
  TypeReference[] p=getParameterTypes(i);
  if (p.length == 1) {
    SSANewInstruction n=m.addAllocation(p[0],warnings);
    return (n == null) ? -1 : n.getDef();
  }
 else {
    int[] values=new int[p.length];
    int countErrors=0;
    for (int j=0; j < p.length; j++) {
      SSANewInstruction n=m.addAllocation(p[j],warnings);
      int value=(n == null) ? -1 : n.getDef();
      if (value == -1) {
        countErrors++;
      }
 else {
        values[j - countErrors]=value;
      }
    }
    if (countErrors > 0) {
      int[] oldValues=values;
      values=new int[oldValues.length - countErrors];
      System.arraycopy(oldValues,0,values,0,values.length);
    }
    return m.addPhi(values);
  }
}","/** 
 * Add allocation statements to the fake root method for each possible value of parameter i. If necessary, add a phi to combine the values.
 * @param m
 * @param i
 * @return value number holding the parameter to the call; -1 if there wassome error
 */
protected int makeArgument(FakeRootMethod m,int i,WarningSet warnings){
  TypeReference[] p=getParameterTypes(i);
  if (p.length == 0) {
    return -1;
  }
 else   if (p.length == 1) {
    SSANewInstruction n=m.addAllocation(p[0],warnings);
    return (n == null) ? -1 : n.getDef();
  }
 else {
    int[] values=new int[p.length];
    int countErrors=0;
    for (int j=0; j < p.length; j++) {
      SSANewInstruction n=m.addAllocation(p[j],warnings);
      int value=(n == null) ? -1 : n.getDef();
      if (value == -1) {
        countErrors++;
      }
 else {
        values[j - countErrors]=value;
      }
    }
    if (countErrors > 0) {
      int[] oldValues=values;
      values=new int[oldValues.length - countErrors];
      System.arraycopy(oldValues,0,values,0,values.length);
    }
    return m.addPhi(values);
  }
}",0.9773584905660376
40883,"/** 
 * Add a call to this entrypoint from the fake root method
 * @param m the Fake Root Method
 * @return the call instruction added, or null if the operation fails
 */
public SSAAbstractInvokeInstruction addCall(FakeRootMethod m,WarningSet warnings){
  int paramValues[];
  CallSiteReference site=makeSite(0);
  if (site == null) {
    return null;
  }
  paramValues=new int[getNumberOfParameters()];
  for (int j=0; j < paramValues.length; j++) {
    paramValues[j]=makeArgument(m,j,warnings);
  }
  return m.addInvocation(paramValues,site);
}","/** 
 * Add a call to this entrypoint from the fake root method
 * @param m the Fake Root Method
 * @return the call instruction added, or null if the operation fails
 */
public SSAAbstractInvokeInstruction addCall(FakeRootMethod m,WarningSet warnings){
  int paramValues[];
  CallSiteReference site=makeSite(0);
  if (site == null) {
    return null;
  }
  paramValues=new int[getNumberOfParameters()];
  for (int j=0; j < paramValues.length; j++) {
    paramValues[j]=makeArgument(m,j,warnings);
    if (paramValues[j] == -1) {
      return null;
    }
  }
  return m.addInvocation(paramValues,site);
}",0.950477845351868
40884,"/** 
 * @param method
 */
protected TypeReference[][] makeParameterTypes(IMethod method){
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    IClass klass=cha.lookupClass(t);
    if (klass == null) {
      t=null;
    }
 else     if (klass.isAbstract()) {
      t=chooseAConcreteSubClass(klass);
    }
 else     if (klass.isInterface()) {
      t=chooseAnImplementor(klass);
    }
 else     if (klass.isArrayClass()) {
      ArrayClass arrayKlass=(ArrayClass)klass;
      IClass innermost=arrayKlass.getInnermostElementClass();
      if (innermost != null && innermost.isInterface()) {
        TypeReference impl=chooseAnImplementor(innermost);
        if (impl == null) {
          t=null;
        }
 else {
          t=TypeReference.findOrCreateArrayOf(impl);
          for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
            t=TypeReference.findOrCreateArrayOf(t);
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}","/** 
 * @param method
 */
protected TypeReference[][] makeParameterTypes(IMethod method){
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    if (!t.isPrimitiveType()) {
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        t=null;
      }
 else       if (klass.isAbstract()) {
        t=chooseAConcreteSubClass(klass);
      }
 else       if (klass.isInterface()) {
        t=chooseAnImplementor(klass);
      }
 else       if (klass.isArrayClass()) {
        ArrayClass arrayKlass=(ArrayClass)klass;
        IClass innermost=arrayKlass.getInnermostElementClass();
        if (innermost != null && innermost.isInterface()) {
          TypeReference impl=chooseAnImplementor(innermost);
          if (impl == null) {
            t=null;
          }
 else {
            t=TypeReference.findOrCreateArrayOf(impl);
            for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
              t=TypeReference.findOrCreateArrayOf(t);
            }
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}",0.9494097807757168
40885,"public TypeName getRawName(){
  String s=rawString().substring(0,rawString().length() - 1);
  s=s.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return TypeName.string2TypeName(s);
}","/** 
 * Return the name of the raw type for this signature
 */
public TypeName getRawName(){
  StringBuffer s=new StringBuffer();
  StringTokenizer t=new StringTokenizer(rawString(),""String_Node_Str"");
  while (t.hasMoreTokens()) {
    String x=t.nextToken();
    s.append(x.replaceAll(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    if (t.hasMoreElements()) {
      s.append('$');
    }
  }
  return TypeName.string2TypeName(s.toString());
}",0.3922155688622754
40886,"/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'*':
{
  args.add(""String_Node_Str"");
  continue;
}
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'-':
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'*':
{
  args.add(""String_Node_Str"");
  continue;
}
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}",0.9949206349206348
40887,"public static void deleteContents(String directory) throws WalaException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      f.delete();
    }
  }
  Collection f2=listFiles(directory,null,true);
  for (Iterator it=f2.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    f.delete();
  }
}","/** 
 * delete all files (recursively) in a directory. This is dangerous. Use with care.
 */
public static void deleteContents(String directory) throws WalaException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      f.delete();
    }
  }
  do {
    Collection f2=listFiles(directory,null,true);
    for (Iterator it=f2.iterator(); it.hasNext(); ) {
      File f=(File)it.next();
      f.delete();
    }
  }
 while (listFiles(directory,null,true).size() > 0);
}",0.8065173116089613
40888,"public TypeArgument[] getTypeArguments(){
  if (rawString().indexOf('<') == -1) {
    return null;
  }
 else {
    int start=rawString().indexOf('<');
    int end=endOfTypeArguments();
    return TypeArgument.make(rawString().substring(start,end));
  }
}","public TypeArgument[] getTypeArguments(){
  int lastDot=rawString().lastIndexOf('.');
  if (rawString().indexOf('<',lastDot) == -1) {
    return null;
  }
 else {
    int start=rawString().indexOf('<',lastDot);
    int end=endOfTypeArguments();
    return TypeArgument.make(rawString().substring(start,end));
  }
}",0.8802816901408451
40889,"private int endOfTypeArguments(){
  int i=rawString().indexOf('<') + 1;
  assert(i > 0);
  int depth=1;
  while (depth > 0) {
    if (rawString().charAt(i) == '>') {
      depth--;
    }
    if (rawString().charAt(i) == '<') {
      depth++;
    }
    i++;
  }
  return i;
}","private int endOfTypeArguments(){
  int lastDot=rawString().lastIndexOf('.');
  int i=rawString().indexOf('<',lastDot) + 1;
  assert(i > 0);
  int depth=1;
  while (depth > 0) {
    if (rawString().charAt(i) == '>') {
      depth--;
    }
    if (rawString().charAt(i) == '<') {
      depth++;
    }
    i++;
  }
  return i;
}",0.9066666666666666
40890,"private static TypeArgument makeTypeArgument(String s){
switch (s.charAt(0)) {
case '*':
    return WILDCARD;
case '+':
case '-':
  Assertions.UNREACHABLE();
return null;
default :
TypeSignature sig=TypeSignature.make(s);
return new TypeArgument(sig);
}
}","private static TypeArgument makeTypeArgument(String s){
switch (s.charAt(0)) {
case '*':
    return WILDCARD;
case '+':
{
    TypeSignature sig=TypeSignature.make(s.substring(1));
    return new TypeArgument(sig,WildcardIndicator.PLUS);
  }
case '-':
{
  TypeSignature sig=TypeSignature.make(s.substring(1));
  return new TypeArgument(sig,WildcardIndicator.MINUS);
}
default :
TypeSignature sig=TypeSignature.make(s);
return new TypeArgument(sig,null);
}
}",0.3994374120956399
40891,"/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}",0.9926617745163442
40892,"private TypeArgument(TypeSignature sig){
  super(sig.rawString());
  this.sig=sig;
}","private TypeArgument(TypeSignature sig,WildcardIndicator w){
  super(sig.rawString());
  this.sig=sig;
  this.w=w;
}",0.84
40893,"/** 
 * @param s a string that holds a sequence of formal type parameters beginningat index begin
 * @return the index where the next formal type parameter ends (actually, end +1)
 */
static int formalTypeParameterEnds(String s,int begin){
  int result=begin;
  while (s.charAt(result) != ':') {
    result++;
  }
  do {
    assert(s.charAt(result) == ':');
switch (s.charAt(++result)) {
case TypeReference.ClassTypeCode:
{
        while (s.charAt(result++) != ';')         ;
        break;
      }
case ':':
    break;
default :
  if (Assertions.verifyAssertions) {
    Assertions._assert(false,""String_Node_Str"" + s + ""String_Node_Str""+ (result - 1));
  }
}
}
 while (s.charAt(result) == ':');
return result;
}","/** 
 * @param s a string that holds a sequence of formal type parameters beginningat index begin
 * @return the index where the next formal type parameter ends (actually, end +1)
 */
static int formalTypeParameterEnds(String s,int begin){
  int result=begin;
  while (s.charAt(result) != ':') {
    result++;
  }
  do {
    assert(s.charAt(result) == ':');
switch (s.charAt(++result)) {
case TypeReference.ClassTypeCode:
{
        int depth=0;
        while (s.charAt(result) != ';' || depth > 0) {
          if (s.charAt(result) == '<') {
            depth++;
          }
          if (s.charAt(result) == '>') {
            depth--;
          }
          result++;
        }
        result++;
        break;
      }
case ':':
    break;
default :
  if (Assertions.verifyAssertions) {
    Assertions._assert(false,""String_Node_Str"" + s + ""String_Node_Str""+ (result - 1));
  }
}
}
 while (s.charAt(result) == ':');
return result;
}",0.851581508515815
40894,"/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs){
  ArrayList<String> sigs=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}","/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs){
  ArrayList<String> sigs=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
System.err.println(typeSigs + ""String_Node_Str"" + i);
switch (typeSigs.charAt(i)) {
case TypeReference.BooleanTypeCode:
case TypeReference.ByteTypeCode:
case TypeReference.IntTypeCode:
sigs.add(typeSigs.substring(i - 1,i + 1));
break;
case 'T':
case TypeReference.ClassTypeCode:
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
break;
default :
Assertions.UNREACHABLE(""String_Node_Str"" + typeSigs.charAt(i));
}
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}",0.9178765880217786
40895,"/** 
 * @param v
 * @param klass
 * @return -1 if there is no match
 */
public static int getTypeVariablePosition(TypeVariableSignature v,ShrikeClass klass){
  try {
    ClassSignature sig=klass.getClassSignature();
    if (sig == null) {
      return -1;
    }
    FormalTypeParameter[] fp=sig.getFormalTypeParameters();
    if (fp == null) {
      return -1;
    }
    for (int i=0; i < fp.length; i++) {
      FormalTypeParameter f=fp[i];
      if (f.getIdentifier().equals(v.getIdentifier())) {
        return i;
      }
    }
    Assertions.UNREACHABLE();
    return -1;
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return -1;
  }
}","/** 
 * @param v
 * @param klass
 * @return -1 if there is no match
 */
public static int getTypeVariablePosition(TypeVariableSignature v,ShrikeClass klass){
  try {
    ClassSignature sig=klass.getClassSignature();
    if (sig == null) {
      return -1;
    }
    FormalTypeParameter[] fp=sig.getFormalTypeParameters();
    if (fp == null) {
      return -1;
    }
    for (int i=0; i < fp.length; i++) {
      FormalTypeParameter f=fp[i];
      if (f.getIdentifier().equals(v.getIdentifier())) {
        return i;
      }
    }
    return -1;
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return -1;
  }
}",0.8531571218795888
40896,"/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'*':
{
  args.add(""String_Node_Str"");
  continue;
}
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}",0.9794855096059916
40897,"public boolean isReturn(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case HEAP_RET_CALLER:
    return true;
case EXC_RET_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL:
case NORMAL_RET_CALLEE:
case PARAM_CALLEE:
case PARAM_CALLER:
case PHI:
case PI:
case METHOD_ENTRY:
  return false;
default :
Assertions.UNREACHABLE(n.getKind().toString());
return false;
}
}","public boolean isReturn(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case HEAP_RET_CALLER:
    return true;
case EXC_RET_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL:
case NORMAL_RET_CALLEE:
case PARAM_CALLEE:
case PARAM_CALLER:
case PHI:
case PI:
case METHOD_ENTRY:
case CATCH:
  return false;
default :
Assertions.UNREACHABLE(n.getKind().toString());
return false;
}
}",0.9865470852017936
40898,"public boolean isEntry(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
    return true;
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL_RET_CALLEE:
  return false;
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean isEntry(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
    return true;
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL_RET_CALLEE:
case CATCH:
  return false;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.972027972027972
40899,"public boolean isCall(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLEE:
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PHI:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
    return false;
case HEAP_PARAM_CALLER:
case PARAM_CALLER:
  return true;
case NORMAL:
if (sdg.getCOptions().equals(ControlDependenceOptions.NONE)) {
  return false;
}
 else {
  NormalStatement s=(NormalStatement)n;
  return s.getInstruction() instanceof SSAAbstractInvokeInstruction;
}
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean isCall(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLEE:
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PHI:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
    return false;
case HEAP_PARAM_CALLER:
case PARAM_CALLER:
  return true;
case NORMAL:
if (sdg.getCOptions().equals(ControlDependenceOptions.NONE)) {
  return false;
}
 else {
  NormalStatement s=(NormalStatement)n;
  return s.getInstruction() instanceof SSAAbstractInvokeInstruction;
}
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9743164871582436
40900,"public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
  return true;
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9591567852437418
40901,"public int getMappedIndex(T o){
  return offset + delegate.getMappedIndex(o);
}","public int getMappedIndex(T o){
  if (delegate.getMappedIndex(o) == -1) {
    return -1;
  }
  return offset + delegate.getMappedIndex(o);
}",0.7214611872146118
40902,"private Set<ModuleEntry> getEntriesRecursive(File dir){
  Set<ModuleEntry> result=new HashSet<ModuleEntry>();
  File[] files=dir.listFiles();
  for (int i=0; i < files.length; i++) {
    if (files[i].isDirectory())     result.addAll(getEntriesRecursive(files[i]));
 else     if (includeFile(files[i]))     result.add(makeFile(files[i]));
  }
  return result;
}","private Set<ModuleEntry> getEntriesRecursive(File dir){
  Set<ModuleEntry> result=HashSetFactory.make();
  File[] files=dir.listFiles();
  if (files != null) {
    for (int i=0; i < files.length; i++) {
      if (files[i].isDirectory()) {
        result.addAll(getEntriesRecursive(files[i]));
      }
 else       if (includeFile(files[i])) {
        result.add(makeFile(files[i]));
      }
    }
  }
 else {
    Trace.println(""String_Node_Str"" + dir);
  }
  return result;
}",0.7697841726618705
40903,"DirectoryTreeModule(File root){
  this.root=root;
}","/** 
 * @param root a directory
 */
DirectoryTreeModule(File root){
}",0.55
40904,"public void bar() throws BadLanguageExceptionEx1 {
  throw new BadLanguageExceptionEx1();
}","public void bar(){
  throw new NullPointerException();
}",0.6394557823129252
40905,"public static void main(String[] args){
  Exception1 e1=new Exception1();
  try {
    FooEx1 f=new FooEx1();
    f.bar();
  }
 catch (  BadLanguageExceptionEx1 e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  Exception1 e1=new Exception1();
  try {
    FooEx1 f=new FooEx1();
    f.bar();
  }
 catch (  BadLanguageExceptionEx1 e) {
    e.printStackTrace();
  }
  try {
    FooEx2 f=new FooEx2();
    f.bar();
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}",0.782258064516129
40906,"private void setCatchInstructions(SSACFG ssacfg,AbstractCFG oldcfg){
  for (int i=0; i < oldcfg.getNumberOfNodes(); i++)   if (oldcfg.isCatchBlock(i)) {
    ExceptionHandlerBasicBlock B=(ExceptionHandlerBasicBlock)ssacfg.getNode(i);
    B.setCatchInstruction((SSAGetCaughtExceptionInstruction)getInstructions()[B.getFirstInstructionIndex()]);
  }
}","private void setCatchInstructions(SSACFG ssacfg,AbstractCFG oldcfg){
  for (int i=0; i < oldcfg.getNumberOfNodes(); i++)   if (oldcfg.isCatchBlock(i)) {
    ExceptionHandlerBasicBlock B=(ExceptionHandlerBasicBlock)ssacfg.getNode(i);
    B.setCatchInstruction((SSAGetCaughtExceptionInstruction)getInstructions()[B.getFirstInstructionIndex()]);
    getInstructions()[B.getFirstInstructionIndex()]=null;
  }
}",0.9230769230769232
40907,"private AstIR(AstMethod method,SSAInstruction[] instructions,SymbolTable symbolTable,SSACFG cfg,SSAOptions options){
  super(method,instructions,symbolTable,cfg,options);
  setCatchInstructions(getControlFlowGraph(),method.cfg);
  localMap=SSAConversion.convert(method,this,options);
  setupCatchTypes(getControlFlowGraph(),method.catchTypes);
  setupLocationMap();
}","private AstIR(AstMethod method,SSAInstruction[] instructions,SymbolTable symbolTable,SSACFG cfg,SSAOptions options){
  super(method,instructions,symbolTable,cfg,options);
  localMap=SSAConversion.convert(method,this,options);
  setCatchInstructions(getControlFlowGraph(),method.cfg);
  setupCatchTypes(getControlFlowGraph(),method.catchTypes);
  setupLocationMap();
}",0.8501362397820164
40908,"/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  HashSet<ExceptionHandler> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new HashSet<ExceptionHandler>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.contains(h)) {
          h.handler=labelDefs[h.handler];
          adjustedHandlers.add(h);
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}","/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  IdentityHashMap<ExceptionHandler,Object> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new IdentityHashMap<ExceptionHandler,Object>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.containsKey(h)) {
          adjustedHandlers.put(h,null);
          h.handler=labelDefs[h.handler];
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}",0.9853264856933236
40909,"private static String[] getJarsInDirectory(String dir){
  File f=new File(dir);
  Assertions.productionAssertion(f.isDirectory(),""String_Node_Str"" + dir);
  ArrayList<String> list=new ArrayList<String>();
  addJarFilesFromDirectory(f,list);
  String[] result=new String[list.size()];
  int i=0;
  for (Iterator<String> it=list.iterator(); it.hasNext(); ) {
    result[i++]=it.next();
  }
  return result;
}","private static String[] getJarsInDirectory(String dir){
  File f=new File(dir);
  Assertions.productionAssertion(f.isDirectory(),""String_Node_Str"" + dir);
  Collection<File> col=FileUtil.listFiles(dir,""String_Node_Str"",true);
  String[] result=new String[col.size()];
  int i=0;
  for (  File jarFile : col) {
    result[i++]=jarFile.getAbsolutePath();
  }
  return result;
}",0.6837387964148528
40910,"/** 
 */
public void init(){
  fakeRoot=makeFakeRootNode();
  Key k=new Key(fakeRoot.getMethod(),fakeRoot.getContext());
  registerNode(k,fakeRoot);
  fakeWorldClinit=makeFakeWorldClinitNode();
  k=new Key(fakeWorldClinit.getMethod(),fakeWorldClinit.getContext());
  registerNode(k,fakeWorldClinit);
  CallSiteReference site=CallSiteReference.make(1,fakeWorldClinit.getMethod().getReference(),IInvokeInstruction.Dispatch.STATIC);
  ((FakeRootMethod)fakeRoot.getMethod()).addInvocation(null,site);
  fakeRoot.addTarget(site,fakeWorldClinit);
}","/** 
 */
public void init(){
  fakeRoot=makeFakeRootNode();
  Key k=new Key(fakeRoot.getMethod(),fakeRoot.getContext());
  registerNode(k,fakeRoot);
  fakeWorldClinit=makeFakeWorldClinitNode();
  k=new Key(fakeWorldClinit.getMethod(),fakeWorldClinit.getContext());
  registerNode(k,fakeWorldClinit);
  CallSiteReference site=CallSiteReference.make(1,fakeWorldClinit.getMethod().getReference(),IInvokeInstruction.Dispatch.STATIC);
  site=((FakeRootMethod)fakeRoot.getMethod()).addInvocation(null,site).getCallSite();
  fakeRoot.addTarget(site,fakeWorldClinit);
}",0.9827742520398912
40911,"public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(22,slice.size());
}","public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(30,slice.size());
}",0.9978517722878624
40912,"public void testSlice1() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMainMethod(cg);
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(18,slice.size());
}","public void testSlice1() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMainMethod(cg);
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(26,slice.size());
}",0.9978189749182116
40913,"public static void main(String[] args) throws Exception {
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=(JarEntry)e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}","public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=(JarEntry)e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}",0.9352272727272728
40914,"public static ArrayStoreInstruction make(String type){
  int i=Util.getTypeIndex(type);
  if (i < 0 || i > TYPE_boolean_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  return preallocated[i];
}","public static ArrayStoreInstruction make(String type) throws IllegalArgumentException {
  int i=Util.getTypeIndex(type);
  if (i < 0 || i > TYPE_boolean_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  return preallocated[i];
}",0.9371428571428572
40915,"public static ConversionInstruction make(String fromType,String toType){
  int from=Util.getTypeIndex(fromType);
  int to=Util.getTypeIndex(toType);
  if (from < 0 || from > TYPE_double_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + fromType);
  }
  if (from == TYPE_int_index && (to >= TYPE_byte_index && to <= TYPE_short_index)) {
    return preallocated[(OP_i2b - OP_i2l) + (to - TYPE_byte_index)];
  }
 else {
    if (to < 0 || to > TYPE_double_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str""+ toType);
    }
    if (to == from) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str"");
    }
    return preallocated[from * 3 + (to > from ? to - 1 : to)];
  }
}","public static ConversionInstruction make(String fromType,String toType) throws IllegalArgumentException {
  int from=Util.getTypeIndex(fromType);
  int to=Util.getTypeIndex(toType);
  if (from < 0 || from > TYPE_double_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + fromType);
  }
  if (from == TYPE_int_index && (to >= TYPE_byte_index && to <= TYPE_short_index)) {
    return preallocated[(OP_i2b - OP_i2l) + (to - TYPE_byte_index)];
  }
 else {
    if (to < 0 || to > TYPE_double_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str""+ toType);
    }
    if (to == from) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str"");
    }
    return preallocated[from * 3 + (to > from ? to - 1 : to)];
  }
}",0.9791006966434452
40916,"public static LoadInstruction make(String type,int index){
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new LoadInstruction((short)(OP_iload + t),index);
  }
}","public static LoadInstruction make(String type,int index) throws IllegalArgumentException {
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new LoadInstruction((short)(OP_iload + t),index);
  }
}",0.953846153846154
40917,"/** 
 * @param type the type of the object that will be returned (in JVM format, e.g., [Ljava/lang/String;)
 * @param arrayBoundsCount the number of array dimensions to preconstruct (equal to the number of integer parameters this instruction expects)
 */
public static NewInstruction make(String type,int arrayBoundsCount){
  if (arrayBoundsCount < 0 || arrayBoundsCount > 255) {
    throw new IllegalArgumentException(""String_Node_Str"" + arrayBoundsCount);
  }
 else {
    if (type.length() < arrayBoundsCount + 1) {
      throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
    }
    for (int i=0; i < arrayBoundsCount; i++) {
      if (type.charAt(i) != '[') {
        throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
      }
    }
    short opcode;
    if (arrayBoundsCount == 0) {
      opcode=OP_new;
    }
 else     if (arrayBoundsCount == 1) {
      char ch=type.charAt(1);
      if (ch != 'L' && ch != '[') {
        opcode=OP_newarray;
      }
 else {
        opcode=OP_anewarray;
      }
    }
 else {
      opcode=OP_multianewarray;
    }
    return new NewInstruction(opcode,type,(short)arrayBoundsCount);
  }
}","/** 
 * @param type the type of the object that will be returned (in JVM format, e.g., [Ljava/lang/String;)
 * @param arrayBoundsCount the number of array dimensions to preconstruct (equal to the number of integer parameters this instruction expects)
 */
public static NewInstruction make(String type,int arrayBoundsCount) throws IllegalArgumentException {
  if (arrayBoundsCount < 0 || arrayBoundsCount > 255) {
    throw new IllegalArgumentException(""String_Node_Str"" + arrayBoundsCount);
  }
 else {
    if (type.length() < arrayBoundsCount + 1) {
      throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
    }
    for (int i=0; i < arrayBoundsCount; i++) {
      if (type.charAt(i) != '[') {
        throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
      }
    }
    short opcode;
    if (arrayBoundsCount == 0) {
      opcode=OP_new;
    }
 else     if (arrayBoundsCount == 1) {
      char ch=type.charAt(1);
      if (ch != 'L' && ch != '[') {
        opcode=OP_newarray;
      }
 else {
        opcode=OP_anewarray;
      }
    }
 else {
      opcode=OP_multianewarray;
    }
    return new NewInstruction(opcode,type,(short)arrayBoundsCount);
  }
}",0.9866881807180314
40918,"public static ReturnInstruction make(String type){
  if (type.equals(TYPE_void)) {
    return preallocatedVoid;
  }
 else {
    int t=Util.getTypeIndex(type);
    if (t < 0 || t > TYPE_Object_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + type);
    }
    return preallocated[t];
  }
}","public static ReturnInstruction make(String type) throws IllegalArgumentException {
  if (type.equals(TYPE_void)) {
    return preallocatedVoid;
  }
 else {
    int t=Util.getTypeIndex(type);
    if (t < 0 || t > TYPE_Object_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + type);
    }
    return preallocated[t];
  }
}",0.9491525423728814
40919,"public static StoreInstruction make(String type,int index){
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new StoreInstruction((short)(OP_istore + t),index);
  }
}","public static StoreInstruction make(String type,int index) throws IllegalArgumentException {
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new StoreInstruction((short)(OP_istore + t),index);
  }
}",0.954230235783634
40920,"/** 
 * Convert a JVM type name back into a Java class name.
 */
public static String makeClass(String t){
  if (t.startsWith(""String_Node_Str"")) {
    return t;
  }
 else   if (!t.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(t + ""String_Node_Str"");
  }
 else {
    return t.substring(1,t.length() - 1).replace('/','.');
  }
}","/** 
 * Convert a JVM type name back into a Java class name.
 */
public static String makeClass(String t) throws IllegalArgumentException {
  if (t.startsWith(""String_Node_Str"")) {
    return t;
  }
 else   if (!t.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(t + ""String_Node_Str"");
  }
 else {
    return t.substring(1,t.length() - 1).replace('/','.');
  }
}",0.9553450608930988
40921,"/** 
 * Append some class information to the store.
 * @param cl the JVM type of the class being added (e.g., Ljava/lang/Object;)
 * @param isInterface true iff it's an interface
 * @param isFinal true iff it's final
 * @param superClass the JVM type of the superclass, or null if this is Object
 * @param superInterfaces the JVM types of its implemented interfaces
 */
public void setClassInfo(String cl,boolean isInterface,boolean isFinal,String superClass,String[] superInterfaces){
  if (superClass != null && superClass.equals(cl)) {
    throw new Error(""String_Node_Str"" + cl + ""String_Node_Str"");
  }
  contents.put(cl,new ClassInfo(isInterface,isFinal,superClass,superInterfaces));
}","/** 
 * Append some class information to the store.
 * @param cl the JVM type of the class being added (e.g., Ljava/lang/Object;)
 * @param isInterface true iff it's an interface
 * @param isFinal true iff it's final
 * @param superClass the JVM type of the superclass, or null if this is Object
 * @param superInterfaces the JVM types of its implemented interfaces
 */
public void setClassInfo(String cl,boolean isInterface,boolean isFinal,String superClass,String[] superInterfaces) throws IllegalArgumentException {
  if (superClass != null && superClass.equals(cl)) {
    throw new IllegalArgumentException(""String_Node_Str"" + cl + ""String_Node_Str"");
  }
  contents.put(cl,new ClassInfo(isInterface,isFinal,superClass,superInterfaces));
}",0.9581589958158996
40922,"/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException {
  makeOutputJar();
  outputJar.setComment(comment);
}","/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException, IllegalArgumentException {
  makeOutputJar();
  outputJar.setComment(comment);
}",0.93048128342246
40923,"/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the double value in v.
 */
public static void setDouble(byte[] buf,int offset,double v){
  setLong(buf,offset,Double.doubleToRawLongBits(v));
}","/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the double value in v.
 */
public static void setDouble(byte[] buf,int offset,double v) throws IllegalArgumentException {
  setLong(buf,offset,Double.doubleToRawLongBits(v));
}",0.9230769230769232
40924,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 */
public static void setInt(byte[] buf,int offset,int v){
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}",0.801762114537445
40925,"/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the signed 64-bit value in v.
 */
public static void setLong(byte[] buf,int offset,long v){
  setInt(buf,offset,(int)(v >> 32));
  setInt(buf,offset + 4,(int)v);
}","/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the signed 64-bit value in v.
 */
public static void setLong(byte[] buf,int offset,long v) throws IllegalArgumentException {
  setInt(buf,offset,(int)(v >> 32));
  setInt(buf,offset + 4,(int)v);
}",0.929637526652452
40926,"/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 */
public static void setUShort(byte[] buf,int offset,int v){
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}","/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}",0.8358620689655173
40927,"/** 
 * Set the constant pool index for the name of the class.
 */
public void setNameIndex(int c){
  if (c < 1 || c > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
  thisClass=c;
}","/** 
 * Set the constant pool index for the name of the class.
 */
public void setNameIndex(int c) throws IllegalArgumentException {
  if (c < 1 || c > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
  thisClass=c;
}",0.9277899343544858
40928,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the float value in v.
 */
public static void setFloat(byte[] buf,int offset,float v){
  setInt(buf,offset,Float.floatToIntBits(v));
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the float value in v.
 */
public static void setFloat(byte[] buf,int offset,float v) throws IllegalArgumentException {
  setInt(buf,offset,Float.floatToIntBits(v));
}",0.9193154034229828
40929,"/** 
 * Set the byte at offset 'offset' in 'buf' to the unsigned 8-bit value in v.
 */
public static void setUByte(byte[] buf,int offset,int v){
  buf[offset]=(byte)v;
}","/** 
 * Set the byte at offset 'offset' in 'buf' to the unsigned 8-bit value in v.
 */
public static void setUByte(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)v;
}",0.7145877378435518
40930,"/** 
 * After you've added everything you need to the class, call this method to generate the actual class file data. This can only be called once.
 */
public byte[] makeBytes(){
  if (buf != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (thisClass == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  reserveBuf(10);
  setInt(buf,0,MAGIC);
  setUShort(buf,4,minorVersion);
  setUShort(buf,6,majorVersion);
  emitConstantPool();
  setUShort(buf,8,nextCPIndex);
  cachedCPEntries=null;
  int offset=reserveBuf(8);
  setUShort(buf,offset,accessFlags);
  setUShort(buf,offset + 2,thisClass);
  setUShort(buf,offset + 4,superClass);
  if (superInterfaces != null) {
    setUShort(buf,offset + 6,superInterfaces.length);
    reserveBuf(superInterfaces.length * 2);
    for (int i=0; i < superInterfaces.length; i++) {
      setUShort(buf,offset + 8 + i * 2,superInterfaces[i]);
    }
  }
 else {
    setUShort(buf,offset + 6,0);
  }
  offset=reserveBuf(2);
  int numFields=fields.size();
  setUShort(buf,offset,numFields);
  for (int i=0; i < numFields; i++) {
    emitElement(fields.get(i));
  }
  offset=reserveBuf(2);
  int numMethods=methods.size();
  setUShort(buf,offset,numMethods);
  for (int i=0; i < numMethods; i++) {
    emitElement(methods.get(i));
  }
  offset=reserveBuf(2);
  int numAttrs=classAttributes.size();
  setUShort(buf,offset,numAttrs);
  for (int i=0; i < numAttrs; i++) {
    emitElement(classAttributes.get(i));
  }
  if (buf.length == bufLen) {
    return buf;
  }
 else {
    byte[] b=new byte[bufLen];
    System.arraycopy(buf,0,b,0,bufLen);
    return b;
  }
}","/** 
 * After you've added everything you need to the class, call this method to generate the actual class file data. This can only be called once.
 */
public byte[] makeBytes() throws IllegalArgumentException {
  if (buf != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (thisClass == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  reserveBuf(10);
  setInt(buf,0,MAGIC);
  setUShort(buf,4,minorVersion);
  setUShort(buf,6,majorVersion);
  emitConstantPool();
  setUShort(buf,8,nextCPIndex);
  cachedCPEntries=null;
  int offset=reserveBuf(8);
  setUShort(buf,offset,accessFlags);
  setUShort(buf,offset + 2,thisClass);
  setUShort(buf,offset + 4,superClass);
  if (superInterfaces != null) {
    setUShort(buf,offset + 6,superInterfaces.length);
    reserveBuf(superInterfaces.length * 2);
    for (int i=0; i < superInterfaces.length; i++) {
      setUShort(buf,offset + 8 + i * 2,superInterfaces[i]);
    }
  }
 else {
    setUShort(buf,offset + 6,0);
  }
  offset=reserveBuf(2);
  int numFields=fields.size();
  setUShort(buf,offset,numFields);
  for (int i=0; i < numFields; i++) {
    emitElement(fields.get(i));
  }
  offset=reserveBuf(2);
  int numMethods=methods.size();
  setUShort(buf,offset,numMethods);
  for (int i=0; i < numMethods; i++) {
    emitElement(methods.get(i));
  }
  offset=reserveBuf(2);
  int numAttrs=classAttributes.size();
  setUShort(buf,offset,numAttrs);
  for (int i=0; i < numAttrs; i++) {
    emitElement(classAttributes.get(i));
  }
  if (buf.length == bufLen) {
    return buf;
  }
 else {
    byte[] b=new byte[bufLen];
    System.arraycopy(buf,0,b,0,bufLen);
    return b;
  }
}",0.9900271985494108
40931,"public int getSize(){
  verify();
  int size=14 + code.length + 2+ (exnHandlers == null ? 0 : exnHandlers.length) * 2 + 2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      size+=attributes[i].getSize();
    }
  }
  return size;
}","public int getSize() throws IllegalArgumentException {
  verify();
  int size=14 + code.length + 2+ (exnHandlers == null ? 0 : exnHandlers.length) * 2 + 2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      size+=attributes[i].getSize();
    }
  }
  return size;
}",0.940754039497307
40932,"public int copyInto(byte[] buf,int offset){
  verify();
  int start=offset;
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setUShort(buf,offset + 6,maxStack);
  ClassWriter.setUShort(buf,offset + 8,maxLocals);
  ClassWriter.setInt(buf,offset + 10,code.length);
  offset+=14;
  System.arraycopy(code,0,buf,offset,code.length);
  offset+=code.length;
  ClassWriter.setUShort(buf,offset,(exnHandlers == null ? 0 : exnHandlers.length) / 4);
  offset+=2;
  if (exnHandlers != null) {
    for (int i=0; i < exnHandlers.length; i++) {
      ClassWriter.setUShort(buf,offset,exnHandlers[i]);
      offset+=2;
    }
  }
  ClassWriter.setUShort(buf,offset,(attributes == null ? 0 : attributes.length));
  offset+=2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      offset=attributes[i].copyInto(buf,offset);
    }
  }
  ClassWriter.setInt(buf,start + 2,offset - start - 6);
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  verify();
  int start=offset;
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setUShort(buf,offset + 6,maxStack);
  ClassWriter.setUShort(buf,offset + 8,maxLocals);
  ClassWriter.setInt(buf,offset + 10,code.length);
  offset+=14;
  System.arraycopy(code,0,buf,offset,code.length);
  offset+=code.length;
  ClassWriter.setUShort(buf,offset,(exnHandlers == null ? 0 : exnHandlers.length) / 4);
  offset+=2;
  if (exnHandlers != null) {
    for (int i=0; i < exnHandlers.length; i++) {
      ClassWriter.setUShort(buf,offset,exnHandlers[i]);
      offset+=2;
    }
  }
  ClassWriter.setUShort(buf,offset,(attributes == null ? 0 : attributes.length));
  offset+=2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      offset=attributes[i].copyInto(buf,offset);
    }
  }
  ClassWriter.setInt(buf,start + 2,offset - start - 6);
  return offset;
}",0.9824933687002652
40933,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  ClassWriter.setUShort(buf,offset + 6,table == null ? 0 : table.length);
  offset+=8;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUShort(buf,offset,table[i]);
      offset+=2;
    }
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  ClassWriter.setUShort(buf,offset + 6,table == null ? 0 : table.length);
  offset+=8;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUShort(buf,offset,table[i]);
      offset+=2;
    }
  }
  return offset;
}",0.9592088998763906
40934,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 2);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 2);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}",0.9557046979865772
40935,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 5);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 5);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}",0.9557046979865772
40936,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  offset+=6;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUByte(buf,offset,table[i]);
      offset++;
    }
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  offset+=6;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUByte(buf,offset,table[i]);
      offset++;
    }
  }
  return offset;
}",0.9497716894977168
40937,"public int getSize(){
  verify();
  return 8;
}","public int getSize() throws IllegalArgumentException {
  verify();
  return 8;
}",0.7401574803149606
40938,"/** 
 * Convert a JVM type name (either for a primitive or a class name) into a Java type name.
 */
public static String makeClassAll(String t){
  String alias=classAliases.get(t);
  if (alias != null) {
    return alias;
  }
 else {
    return makeClass(t);
  }
}","/** 
 * Convert a JVM type name (either for a primitive or a class name) into a Java type name.
 */
static String makeClassAll(String t){
  String alias=classAliases.get(t);
  if (alias != null) {
    return alias;
  }
 else {
    return makeClass(t);
  }
}",0.9865642994241842
40939,"/** 
 * Compute the total number of JVM ""stack words"" occupied by the method parameters for method signature ""type"". Any ""this"" parameter is not included.
 */
public static int getParamsWordSize(String type){
  int index=1;
  int count=0;
  if (type.indexOf(')',1) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  while (type.charAt(index) != ')') {
    count+=getWordSize(type,index);
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the total number of JVM ""stack words"" occupied by the method parameters for method signature ""type"". Any ""this"" parameter is not included.
 */
public static int getParamsWordSize(String type) throws IllegalArgumentException {
  int index=1;
  int count=0;
  if (type.indexOf(')',1) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  while (type.charAt(index) != ')') {
    count+=getWordSize(type,index);
    index+=getTypeLength(type,index);
  }
  return count;
}",0.9664292980671414
40940,"/** 
 * Computes the character length of the internal JVM type given by s.substring(i).
 */
public static int getTypeLength(String s,int i){
switch (s.charAt(i)) {
case 'L':
    return s.indexOf(';',i) - i + 1;
case '[':
  return getTypeLength(s,i + 1) + 1;
default :
return 1;
}
}","/** 
 * Computes the character length of the internal JVM type given by s.substring(i).
 */
private static int getTypeLength(String s,int i){
switch (s.charAt(i)) {
case 'L':
    return s.indexOf(';',i) - i + 1;
case '[':
  return getTypeLength(s,i + 1) + 1;
default :
return 1;
}
}",0.9804618117229128
40941,"/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 */
public static int getParamsCount(String type){
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 */
static int getParamsCount(String type){
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}",0.9883527454242927
40942,"/** 
 * @return true iff t is an array type
 */
public static boolean isArrayType(String t){
  if (t == null) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case '[':
      return true;
default :
    return false;
}
}
}","/** 
 * @return true iff t is an array type
 */
public static boolean isArrayType(String t){
  if (t == null || t.length() == 0) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case '[':
      return true;
default :
    return false;
}
}
}",0.959830866807611
40943,"/** 
 * @return the JVM ""stack word size"" for the given JVM type, looking at index'index'
 */
public static byte getWordSize(String s,int index){
switch (s.charAt(index)) {
case 'V':
    return 0;
case 'J':
case 'D':
  return 2;
default :
return 1;
}
}","/** 
 * @return the JVM ""stack word size"" for the given JVM type, looking at index'index'
 */
static byte getWordSize(String s,int index){
switch (s.charAt(index)) {
case 'V':
    return 0;
case 'J':
case 'D':
  return 2;
default :
return 1;
}
}",0.9859154929577464
40944,"final void makeOutputJar() throws IOException {
  if (outputJar == null) {
    if (outputFile == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    outputJar=new JarOutputStream(new FileOutputStream(outputFile));
  }
}","final void makeOutputJar() throws IOException, IllegalStateException {
  if (outputJar == null) {
    if (outputFile == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    outputJar=new JarOutputStream(new FileOutputStream(outputFile));
  }
}",0.63671875
40945,"/** 
 * Complete and flush the entry initiated by addOutputJarEntry.
 */
final public void endOutputJarEntry() throws IOException {
  outputJar.closeEntry();
}","/** 
 * Complete and flush the entry initiated by addOutputJarEntry.
 */
final public void endOutputJarEntry() throws IOException, IllegalStateException {
  if (outputJar == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  outputJar.closeEntry();
}",0.7429906542056075
40946,"/** 
 * Skip the last class returned in every future traversal of the class list.
 */
final public void setIgnore(boolean ignore){
  if (inputIndex == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ignoringInputs.set(inputIndex - 1);
}","/** 
 * Skip the last class returned in every future traversal of the class list.
 */
final public void setIgnore(boolean ignore) throws IllegalArgumentException {
  if (inputIndex == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ignoringInputs.set(inputIndex - 1);
}",0.9398907103825136
40947,"private void putNextEntry(ZipEntry newEntry) throws IOException {
  outputJar.putNextEntry(newEntry);
  entryNames.add(newEntry.getName());
  if (manifestBuilder != null) {
    manifestBuilder.addEntry(newEntry);
  }
}","private void putNextEntry(ZipEntry newEntry) throws IOException, IllegalStateException {
  if (outputJar == null) {
    throw new IllegalStateException();
  }
  outputJar.putNextEntry(newEntry);
  entryNames.add(newEntry.getName());
  if (manifestBuilder != null) {
    manifestBuilder.addEntry(newEntry);
  }
}",0.8241965973534972
40948,"/** 
 * Add a raw ZipEntry to the output JAR. Call endOutputJarEntry() when you're done.
 * @return the OutputStream to be used to write the entry contents
 */
final public OutputStream addOutputJarEntry(ZipEntry ze) throws IOException {
  putNextEntry(ze);
  return outputJar;
}","/** 
 * Add a raw ZipEntry to the output JAR. Call endOutputJarEntry() when you're done.
 * @return the OutputStream to be used to write the entry contents
 */
final public OutputStream addOutputJarEntry(ZipEntry ze) throws IOException, IllegalStateException {
  if (outputJar == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  putNextEntry(ze);
  return outputJar;
}",0.8263473053892215
40949,"/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException, IllegalArgumentException {
  makeOutputJar();
  outputJar.setComment(comment);
}","/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException, IllegalStateException {
  makeOutputJar();
  outputJar.setComment(comment);
}",0.9722921914357684
40950,"/** 
 * Call this to copy any unmodified classes to the output. This is called automatically by close(); you should only call this if you want to write an entry to the JAR file *after* the unmodified classes. This will only ever be called once per output JAR.
 */
final public void writeUnmodifiedClasses() throws IOException {
  passUnmodifiedClasses=false;
  makeOutputJar();
  for (int i=0; i < inputs.size(); i++) {
    Input in=inputs.get(i);
    if (!in.isClass()) {
      if (in instanceof JarInput) {
        JarInput jin=(JarInput)in;
        ZipEntry entry=jin.getEntry();
        InputStream s=jin.open();
        try {
          ZipEntry newEntry=new ZipEntry(entry.getName());
          newEntry.setComment(entry.getComment());
          newEntry.setExtra(entry.getExtra());
          newEntry.setTime(entry.getTime());
          putNextEntry(newEntry);
          copyStream(s,outputJar);
          outputJar.closeEntry();
        }
  finally {
          s.close();
        }
      }
 else {
        throw new Error(""String_Node_Str"" + in);
      }
    }
 else {
      String name=in.getClassName();
      if (name == null) {
        BufferedInputStream s=new BufferedInputStream(in.open(),65536);
        try {
          Object cl=makeClassFromStream(s);
          String entryName=toEntryName(getClassName(cl));
          if (!entryNames.contains(entryName)) {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            writeClassTo(cl,null,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
        }
  finally {
          s.close();
        }
      }
 else {
        String entryName=toEntryName(name);
        if (!entryNames.contains(entryName)) {
          BufferedInputStream s=new BufferedInputStream(in.open());
          try {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            copyStream(s,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
  finally {
            s.close();
          }
        }
      }
    }
  }
}","/** 
 * Call this to copy any unmodified classes to the output. This is called automatically by close(); you should only call this if you want to write an entry to the JAR file *after* the unmodified classes. This will only ever be called once per output JAR.
 */
final public void writeUnmodifiedClasses() throws IOException, IllegalStateException {
  passUnmodifiedClasses=false;
  makeOutputJar();
  for (int i=0; i < inputs.size(); i++) {
    Input in=inputs.get(i);
    if (!in.isClass()) {
      if (in instanceof JarInput) {
        JarInput jin=(JarInput)in;
        ZipEntry entry=jin.getEntry();
        InputStream s=jin.open();
        try {
          ZipEntry newEntry=new ZipEntry(entry.getName());
          newEntry.setComment(entry.getComment());
          newEntry.setExtra(entry.getExtra());
          newEntry.setTime(entry.getTime());
          putNextEntry(newEntry);
          copyStream(s,outputJar);
          outputJar.closeEntry();
        }
  finally {
          s.close();
        }
      }
 else {
        throw new Error(""String_Node_Str"" + in);
      }
    }
 else {
      String name=in.getClassName();
      if (name == null) {
        BufferedInputStream s=new BufferedInputStream(in.open(),65536);
        try {
          Object cl=makeClassFromStream(s);
          String entryName=toEntryName(getClassName(cl));
          if (!entryNames.contains(entryName)) {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            writeClassTo(cl,null,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
        }
  finally {
          s.close();
        }
      }
 else {
        String entryName=toEntryName(name);
        if (!entryNames.contains(entryName)) {
          BufferedInputStream s=new BufferedInputStream(in.open());
          try {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            copyStream(s,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
  finally {
            s.close();
          }
        }
      }
    }
  }
}",0.9947380462136812
40951,"/** 
 * Set the bytecodes for this Code attribute.
 */
public void setCode(byte[] code){
  if (code.length > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + code.length);
  }
  if (code.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.code=code;
}","/** 
 * Set the bytecodes for this Code attribute.
 */
public void setCode(byte[] code) throws IllegalArgumentException {
  if (code.length > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + code.length);
  }
  if (code.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.code=code;
}",0.9485179407176288
40952,"public int getCodeLength(){
  return code.length;
}","public int getCodeLength() throws IllegalStateException {
  if (code == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return code.length;
}",0.4766355140186916
40953,"public int copyInto(byte[] buf,int offset){
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}",0.926829268292683
40954,"/** 
 * Set the index of the constant pool item holding the source file name.
 */
public void setSourceFileCPIndex(int index){
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}","/** 
 * Set the index of the constant pool item holding the source file name.
 */
public void setSourceFileCPIndex(int index) throws IllegalArgumentException {
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}",0.9394495412844036
40955,"public void launch() throws WalaException {
  Process p=spawnProcess(getCmd());
  Thread d1=drainStdErr(p);
  Thread d2=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  try {
    d1.join();
    d2.join();
  }
 catch (  InterruptedException e) {
    throw new WalaException(""String_Node_Str"",e);
  }
  if (isCaptureOutput()) {
    Drainer d=(Drainer)d2;
    setOutput(d.getCapture().toByteArray());
  }
}","public void launch() throws WalaException, IllegalArgumentException {
  Process p=spawnProcess(getCmd());
  Thread d1=drainStdErr(p);
  Thread d2=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  try {
    d1.join();
    d2.join();
  }
 catch (  InterruptedException e) {
    throw new WalaException(""String_Node_Str"",e);
  }
  if (isCaptureOutput()) {
    Drainer d=(Drainer)d2;
    setOutput(d.getCapture().toByteArray());
  }
}",0.9693396226415094
40956,"public AbstractStatement takeStatement(){
  AbstractStatement result=(AbstractStatement)super.take();
  contents.remove(result);
  return result;
}","public AbstractStatement takeStatement() throws NoSuchElementException {
  AbstractStatement result=(AbstractStatement)super.take();
  contents.remove(result);
  return result;
}",0.9046153846153846
40957,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAArrayLengthInstruction(defs == null ? result : defs[0],uses == null ? arrayref : uses[0]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (defs != null && defs.length != 1) {
    throw new IllegalArgumentException();
  }
  if (uses != null && uses.length != 1) {
    throw new IllegalArgumentException();
  }
  return new SSAArrayLengthInstruction(defs == null ? result : defs[0],uses == null ? arrayref : uses[0]);
}",0.6122448979591837
40958,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAThrowInstruction(uses == null ? getException() : uses[0]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (uses != null && uses.length != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSAThrowInstruction(uses == null ? getException() : uses[0]);
}",0.6584158415841584
40959,"/** 
 * @param b a byte array holding the string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreate(ImmutableByteArray b){
  TypeName returnType=StringStuff.parseForReturnTypeName(b);
  TypeName[] parameters=StringStuff.parseForParameterNames(b);
  Key k=new Key(returnType,parameters);
  Descriptor result=map.get(k);
  if (result == null) {
    result=new Descriptor(k);
    map.put(k,result);
  }
  return result;
}","/** 
 * @param b a byte array holding the string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreate(ImmutableByteArray b) throws IllegalArgumentException {
  TypeName returnType=StringStuff.parseForReturnTypeName(b);
  TypeName[] parameters=StringStuff.parseForParameterNames(b);
  Key k=new Key(returnType,parameters);
  Descriptor result=map.get(k);
  if (result == null) {
    result=new Descriptor(k);
    map.put(k,result);
  }
  return result;
}",0.9686013320647004
40960,"/** 
 * @param s string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreateUTF8(String s){
  byte[] b=UTF8Convert.toUTF8(s);
  return findOrCreate(new ImmutableByteArray(b));
}","/** 
 * @param s string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreateUTF8(String s) throws IllegalArgumentException {
  byte[] b=UTF8Convert.toUTF8(s);
  return findOrCreate(new ImmutableByteArray(b));
}",0.9415929203539825
40961,"public static TypeArgument make(String string){
  if (string.equals(""String_Node_Str"")) {
    return WILDCARD;
  }
 else {
    Assertions.UNREACHABLE();
    return null;
  }
}","public static TypeArgument make(String string) throws UnimplementedError {
  if (string.equals(""String_Node_Str"")) {
    return WILDCARD;
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"");
    return null;
  }
}",0.8883248730964467
40962,"/** 
 * Parse an array descriptor to obtain number of dimensions in corresponding array type. b: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public static short parseForArrayDimensionality(ImmutableByteArray b,int start,int length){
  for (int i=start; i < start + length; ++i) {
    if (b.b[i] != '[') {
      return (short)(i - start);
    }
  }
  Assertions.UNREACHABLE();
  return -1;
}","/** 
 * Parse an array descriptor to obtain number of dimensions in corresponding array type. b: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public static short parseForArrayDimensionality(ImmutableByteArray b,int start,int length) throws IllegalArgumentException {
  for (int i=start; i < start + length; ++i) {
    if (b.b[i] != '[') {
      return (short)(i - start);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + b);
}",0.8764044943820225
40963,"/** 
 * Parse method descriptor to obtain description of method's return type. TODO: tune this .. probably combine with parseForParameters.
 * @param b method descriptor - something like ""(III)V""
 * @return type description
 */
public static final TypeName parseForReturnTypeName(ImmutableByteArray b){
  if (Assertions.verifyAssertions) {
    if (b.get(0) != '(') {
      Assertions._assert(b.get(0) == '(',""String_Node_Str"" + b);
    }
  }
  int i=0;
  while (b.get(i++) != ')')   ;
switch (b.get(i)) {
case TypeReference.VoidTypeCode:
    return TypeReference.Void.getName();
case TypeReference.BooleanTypeCode:
  return TypeReference.Boolean.getName();
case TypeReference.ByteTypeCode:
return TypeReference.Byte.getName();
case TypeReference.ShortTypeCode:
return TypeReference.Short.getName();
case TypeReference.IntTypeCode:
return TypeReference.Int.getName();
case TypeReference.LongTypeCode:
return TypeReference.Long.getName();
case TypeReference.FloatTypeCode:
return TypeReference.Float.getName();
case TypeReference.DoubleTypeCode:
return TypeReference.Double.getName();
case TypeReference.CharTypeCode:
return TypeReference.Char.getName();
case TypeReference.ClassTypeCode:
case TypeReference.ArrayTypeCode:
if (b.get(b.length() - 1) == ';') {
return TypeName.findOrCreate(b,i,b.length() - i - 1);
}
 else {
return TypeName.findOrCreate(b,i,b.length() - i);
}
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
return null;
}
}","/** 
 * Parse method descriptor to obtain description of method's return type. TODO: tune this .. probably combine with parseForParameters.
 * @param b method descriptor - something like ""(III)V""
 * @return type description
 */
public static final TypeName parseForReturnTypeName(ImmutableByteArray b) throws IllegalArgumentException {
  if (b.length() <= 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  if (b.get(0) != '(') {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  int i=0;
  while (b.get(i++) != ')')   ;
switch (b.get(i)) {
case TypeReference.VoidTypeCode:
    return TypeReference.Void.getName();
case TypeReference.BooleanTypeCode:
  return TypeReference.Boolean.getName();
case TypeReference.ByteTypeCode:
return TypeReference.Byte.getName();
case TypeReference.ShortTypeCode:
return TypeReference.Short.getName();
case TypeReference.IntTypeCode:
return TypeReference.Int.getName();
case TypeReference.LongTypeCode:
return TypeReference.Long.getName();
case TypeReference.FloatTypeCode:
return TypeReference.Float.getName();
case TypeReference.DoubleTypeCode:
return TypeReference.Double.getName();
case TypeReference.CharTypeCode:
return TypeReference.Char.getName();
case TypeReference.ClassTypeCode:
case TypeReference.ArrayTypeCode:
if (b.get(b.length() - 1) == ';') {
return TypeName.findOrCreate(b,i,b.length() - i - 1);
}
 else {
return TypeName.findOrCreate(b,i,b.length() - i);
}
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
return null;
}
}",0.2486876640419947
40964,"/** 
 * Given that name[start:start+length] is a Type name in JVM format, strip the package and return the ""package-free"" class name
 * @return an ImmutableByteArray that represents the package, or null if it'sthe unnamed package
 */
public static ImmutableByteArray parseForClass(ImmutableByteArray name){
  return parseForClass(name,0,name.length());
}","/** 
 * Given that name[start:start+length] is a Type name in JVM format, strip the package and return the ""package-free"" class name
 * @return an ImmutableByteArray that represents the package, or null if it'sthe unnamed package
 */
public static ImmutableByteArray parseForClass(ImmutableByteArray name) throws IllegalArgumentException {
  return parseForClass(name,0,name.length());
}",0.9554655870445344
40965,"/** 
 * @param name
 * @param start
 * @param length
 * @return true iff the class returned by parseForClass is primitive
 */
public static boolean classIsPrimitive(ImmutableByteArray name,int start,int length){
  while (length > 0 && name.b[start] == '[') {
    start++;
    length--;
  }
  return name.b[start] != 'L';
}","/** 
 * @param name
 * @param start
 * @param length
 * @return true iff the class returned by parseForClass is primitive
 */
public static boolean classIsPrimitive(ImmutableByteArray name,int start,int length) throws IllegalArgumentException {
  while (length > 0 && name.b[start] == '[') {
    start++;
    length--;
  }
  if (start >= name.b.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + name);
  }
  return name.b[start] != 'L';
}",0.8267008985879333
40966,"/** 
 * @param methodSig something like ""java_cup.lexer.advance()V""
 */
public static MethodReference makeMethodReference(String methodSig){
  String type=methodSig.substring(0,methodSig.lastIndexOf('.'));
  type=deployment2CanonicalTypeString(type);
  TypeReference t=TypeReference.findOrCreate(ClassLoaderReference.Application,type);
  String methodName=methodSig.substring(methodSig.lastIndexOf('.') + 1,methodSig.indexOf('('));
  String desc=methodSig.substring(methodSig.indexOf('('));
  return MethodReference.findOrCreate(t,methodName,desc);
}","/** 
 * @param methodSig something like ""java_cup.lexer.advance()V""
 */
public static MethodReference makeMethodReference(String methodSig) throws IllegalArgumentException {
  if (methodSig.lastIndexOf('.') < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + methodSig);
  }
  String type=methodSig.substring(0,methodSig.lastIndexOf('.'));
  type=deployment2CanonicalTypeString(type);
  TypeReference t=TypeReference.findOrCreate(ClassLoaderReference.Application,type);
  String methodName=methodSig.substring(methodSig.lastIndexOf('.') + 1,methodSig.indexOf('('));
  String desc=methodSig.substring(methodSig.indexOf('('));
  return MethodReference.findOrCreate(t,methodName,desc);
}",0.8814102564102564
40967,"/** 
 * Parse method descriptor to obtain descriptions of method's parameters.
 * @return parameter descriptions, or null if there are no parameters
 */
public static final TypeName[] parseForParameterNames(ImmutableByteArray b){
  if (Assertions.verifyAssertions) {
    if (b.get(0) != '(') {
      Assertions._assert(b.get(0) == '(',""String_Node_Str"" + b);
    }
  }
  ArrayList<TypeName> sigs=new ArrayList<TypeName>(10);
  int i=1;
  while (true) {
switch (b.get(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName);
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName);
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName);
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName);
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName);
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName);
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName);
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName);
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName);
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
while (b.get(i++) != ';') ;
sigs.add(TypeName.findOrCreate(b,off,i - off - 1));
continue;
}
case TypeReference.ArrayTypeCode:
{
int off=i - 1;
while (b.get(i) == TypeReference.ArrayTypeCode) {
++i;
}
TypeName T=null;
if (b.get(i++) == TypeReference.ClassTypeCode) {
while (b.get(i++) != ';') ;
T=TypeName.findOrCreate(b,off,i - off - 1);
}
 else {
T=TypeName.findOrCreate(b,off,i - off);
}
sigs.add(T);
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<TypeName> it=sigs.iterator();
TypeName[] result=new TypeName[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
}
}
}","/** 
 * Parse method descriptor to obtain descriptions of method's parameters.
 * @return parameter descriptions, or null if there are no parameters
 */
public static final TypeName[] parseForParameterNames(ImmutableByteArray b) throws IllegalArgumentException {
  if (b.length() <= 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  if (b.get(0) != '(') {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  ArrayList<TypeName> sigs=new ArrayList<TypeName>(10);
  int i=1;
  while (true) {
switch (b.get(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName);
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName);
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName);
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName);
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName);
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName);
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName);
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName);
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName);
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
while (b.get(i++) != ';') ;
sigs.add(TypeName.findOrCreate(b,off,i - off - 1));
continue;
}
case TypeReference.ArrayTypeCode:
{
int off=i - 1;
while (b.get(i) == TypeReference.ArrayTypeCode) {
++i;
}
TypeName T=null;
if (b.get(i++) == TypeReference.ClassTypeCode) {
while (b.get(i++) != ';') ;
T=TypeName.findOrCreate(b,off,i - off - 1);
}
 else {
T=TypeName.findOrCreate(b,off,i - off);
}
sigs.add(T);
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<TypeName> it=sigs.iterator();
TypeName[] result=new TypeName[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
}
}
}",0.1578947368421052
40968,"/** 
 * Convert a JVM encoded type name to a readable type name.
 * @param jvmType a String containing a type name in JVM internal format.
 * @return the same type name in readable (source code) format.
 */
public static String jvmToReadableType(String jvmType){
  StringBuffer readable=new StringBuffer();
  int numberOfDimensions=0;
  char prefix=jvmType.charAt(0);
  while (prefix == '[') {
    numberOfDimensions++;
    prefix=jvmType.charAt(numberOfDimensions);
  }
  if (prefix == 'V') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'B') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'C') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'D') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'F') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'I') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'J') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'S') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'Z') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'L') {
    readable.append(jvmType.substring(numberOfDimensions + 1,jvmType.length()));
    readable=new StringBuffer(slashToDot(readable.toString()));
    readable=new StringBuffer(dollarToDot(readable.toString()));
  }
  for (int i=0; i < numberOfDimensions; ++i) {
    readable.append(""String_Node_Str"");
  }
  return readable.toString();
}","/** 
 * Convert a JVM encoded type name to a readable type name.
 * @param jvmType a String containing a type name in JVM internal format.
 * @return the same type name in readable (source code) format.
 */
public static String jvmToReadableType(String jvmType) throws IllegalArgumentException {
  StringBuffer readable=new StringBuffer();
  int numberOfDimensions=0;
  if (jvmType.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jvmType);
  }
  char prefix=jvmType.charAt(0);
  while (prefix == '[') {
    numberOfDimensions++;
    prefix=jvmType.charAt(numberOfDimensions);
  }
  if (prefix == 'V') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'B') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'C') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'D') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'F') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'I') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'J') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'S') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'Z') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'L') {
    readable.append(jvmType.substring(numberOfDimensions + 1,jvmType.length()));
    readable=new StringBuffer(slashToDot(readable.toString()));
    readable=new StringBuffer(dollarToDot(readable.toString()));
  }
  for (int i=0; i < numberOfDimensions; ++i) {
    readable.append(""String_Node_Str"");
  }
  return readable.toString();
}",0.955962712954034
40969,"/** 
 * Allocate a fresh label. This must be called during a pass and not during code emission.
 */
public int allocateLabel(){
  verifyState(DURING_PASS);
  return nextLabel++;
}","/** 
 * Allocate a fresh label. This must be called during a pass and not during code emission.
 */
public int allocateLabel() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  return nextLabel++;
}",0.9156010230179028
40970,"/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches(){
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  HashSet<ExceptionHandler> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new HashSet<ExceptionHandler>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.contains(h)) {
          adjustedHandlers.add(h);
          h.handler=labelDefs[h.handler];
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}","/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  HashSet<ExceptionHandler> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new HashSet<ExceptionHandler>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.contains(h)) {
          adjustedHandlers.add(h);
          h.handler=labelDefs[h.handler];
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}",0.9959294436906376
40971,"/** 
 * @return the value of the Utf8 string at constant pool item i
 */
public String getCPUtf8(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Utf8) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    int count=getUShort(offset + 1);
    int end=count + offset + 3;
    StringBuffer buf=new StringBuffer(count);
    offset+=3;
    while (offset < end) {
      byte x=getByte(offset);
      if ((x & 0x80) == 0) {
        if (x == 0) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)x);
        offset++;
      }
 else       if ((x & 0xE0) == 0xC0) {
        if (offset + 1 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        if ((y & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x1F) << 6) + (y & 0x3F)));
        offset+=2;
      }
 else       if ((x & 0xF0) == 0xE0) {
        if (offset + 2 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        byte z=getByte(offset + 2);
        if ((y & 0xC0) != 0x80 || (z & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x0F) << 12) + ((y & 0x3F) << 6) + (z & 0x3F)));
        offset+=3;
      }
 else {
        throw invalidUtf8(i,offset);
      }
    }
    s=buf.toString().intern();
    cpItems[i]=s;
  }
  return s;
}","/** 
 * @return the value of the Utf8 string at constant pool item i
 */
public String getCPUtf8(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Utf8) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    int count=getUShort(offset + 1);
    int end=count + offset + 3;
    StringBuffer buf=new StringBuffer(count);
    offset+=3;
    while (offset < end) {
      byte x=getByte(offset);
      if ((x & 0x80) == 0) {
        if (x == 0) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)x);
        offset++;
      }
 else       if ((x & 0xE0) == 0xC0) {
        if (offset + 1 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        if ((y & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x1F) << 6) + (y & 0x3F)));
        offset+=2;
      }
 else       if ((x & 0xF0) == 0xE0) {
        if (offset + 2 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        byte z=getByte(offset + 2);
        if ((y & 0xC0) != 0x80 || (z & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x0F) << 12) + ((y & 0x3F) << 6) + (z & 0x3F)));
        offset+=3;
      }
 else {
        throw invalidUtf8(i,offset);
      }
    }
    s=buf.toString().intern();
    cpItems[i]=s;
  }
  return s;
}",0.992298578199052
40972,"/** 
 * @return the name of the Class at constant pool item i, in JVM format (e.g.,java/lang/Object)
 */
public String getCPClass(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Class) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}","/** 
 * @return the name of the Class at constant pool item i, in JVM format (e.g.,java/lang/Object)
 */
public String getCPClass(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Class) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}",0.9832474226804124
40973,"/** 
 * @return the value of the Double at constant pool item i
 */
public double getCPDouble(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Double) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getDouble(offset + 1);
}","/** 
 * @return the value of the Double at constant pool item i
 */
public double getCPDouble(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Double) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getDouble(offset + 1);
}",0.9729166666666668
40974,"/** 
 * @return the type part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i, in JVM format (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPRefType(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATType(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the type part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i, in JVM format (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPRefType(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATType(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9824561403508772
40975,"/** 
 * @return the value of the Long at constant pool item i
 */
public long getCPLong(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Long) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getLong(offset + 1);
}","/** 
 * @return the value of the Long at constant pool item i
 */
public long getCPLong(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Long) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getLong(offset + 1);
}",0.9723404255319148
40976,"/** 
 * @return the name part of the NameAndType at constant pool item i
 */
public String getCPNATName(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the name part of the NameAndType at constant pool item i
 */
public String getCPNATName(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9806835066864784
40977,"/** 
 * @return the value of the Integer at constant pool item i
 */
public int getCPInt(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Integer) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getInt(offset + 1);
}","/** 
 * @return the value of the Integer at constant pool item i
 */
public int getCPInt(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Integer) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getInt(offset + 1);
}",0.9725158562367864
40978,"/** 
 * @return the size of the constant pool data in the raw class file buffer
 */
public int getRawSize(){
  return cpOffsets[cpOffsets.length - 1] - cpOffsets[1];
}","/** 
 * @return the size of the constant pool data in the raw class file buffer
 */
public int getRawSize() throws IllegalStateException {
  if (cpOffsets.length < 2) {
    throw new IllegalStateException();
  }
  return cpOffsets[cpOffsets.length - 1] - cpOffsets[1];
}",0.7643020594965675
40979,"/** 
 * @return the type part of the NameAndType at constant pool item i, in JVMformat (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPNATType(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the type part of the NameAndType at constant pool item i, in JVMformat (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPNATType(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9820193637621024
40980,"/** 
 * @return the name part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i
 */
public String getCPRefName(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATName(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the name part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i
 */
public String getCPRefName(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATName(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.981159420289855
40981,"/** 
 * @return the type of constant pool item i, or 0 if i is an unused constantpool item
 */
public byte getItemType(int i){
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0) {
    return 0;
  }
 else {
    return getByte(offset);
  }
}","/** 
 * @return the type of constant pool item i, or 0 if i is an unused constantpool item
 */
public byte getItemType(int i) throws IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0) {
    return 0;
  }
 else {
    return getByte(offset);
  }
}",0.9560585885486018
40982,"/** 
 * @return the String at constant pool item i
 */
public String getCPString(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_String) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}","/** 
 * @return the String at constant pool item i
 */
public String getCPString(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_String) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}",0.9821428571428572
40983,"/** 
 * @return the name of the class part of the FieldRef, MethodRef, orInterfaceMethodRef at constant pool item i
 */
public String getCPRefClass(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPClass(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the name of the class part of the FieldRef, MethodRef, orInterfaceMethodRef at constant pool item i
 */
public String getCPRefClass(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPClass(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9814814814814816
40984,"/** 
 * @return the value of the Float at constant pool item i
 */
public float getCPFloat(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Float) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getFloat(offset + 1);
}","/** 
 * @return the value of the Float at constant pool item i
 */
public float getCPFloat(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Float) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getFloat(offset + 1);
}",0.9726315789473684
40985,"/** 
 * @return the offset of the constant pool data in the raw class file buffer
 */
public int getRawOffset(){
  return cpOffsets[1];
}","/** 
 * @return the offset of the constant pool data in the raw class file buffer
 */
public int getRawOffset() throws IllegalStateException {
  if (cpOffsets.length < 2) {
    throw new IllegalStateException();
  }
  return cpOffsets[1];
}",0.726790450928382
40986,"public int copyInto(byte[] buf,int offset){
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}",0.926829268292683
40987,"/** 
 * Set the index of the constant pool item holding the constant value.
 */
public void setValueCPIndex(int index){
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}","/** 
 * Set the index of the constant pool item holding the constant value.
 */
public void setValueCPIndex(int index) throws IllegalArgumentException {
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}",0.9378531073446328
40988,"/** 
 * Add an integer value to this set.
 * @param i
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  boolean pr=primaryImpl.add(i);
  boolean sr=secondaryImpl.add(i);
  Assertions._assert(pr == sr);
  return pr;
}","/** 
 * Add an integer value to this set.
 * @param i
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  boolean pr=primaryImpl.add(i);
  boolean sr=secondaryImpl.add(i);
  if (pr != sr) {
    Assertions._assert(pr == sr,""String_Node_Str"" + i + ""String_Node_Str""+ primaryImpl+ ""String_Node_Str""+ pr+ ""String_Node_Str""+ i+ ""String_Node_Str""+ secondaryImpl+ ""String_Node_Str""+ sr);
  }
  return pr;
}",0.7310549777117384
40989,"/** 
 */
public int size(){
  Assertions._assert(primaryImpl.size() == secondaryImpl.size());
  return primaryImpl.size();
}","/** 
 */
public int size(){
  if (primaryImpl.size() != secondaryImpl.size()) {
    Assertions._assert(primaryImpl.size() == secondaryImpl.size(),""String_Node_Str"" + primaryImpl.size() + ""String_Node_Str""+ primaryImpl+ ""String_Node_Str""+ ""String_Node_Str""+ secondaryImpl.size()+ ""String_Node_Str""+ secondaryImpl);
  }
  return primaryImpl.size();
}",0.5254237288135594
40990,"void growCapacity(float fraction){
  expand(offset,(int)fraction * (bits.length << LOG_BITS_PER_UNIT));
}","void growCapacity(float fraction){
  expand(offset,(int)(fraction * (bits.length << LOG_BITS_PER_UNIT)));
}",0.9905660377358492
40991,"/** 
 * Add an integer value to this set.
 * @param i integer to add
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  if (!contains(i)) {
    if (densePart != null && densePart.getOffset() <= i && densePart.length() > i) {
      densePart.set(i);
    }
 else {
      sparsePart.add(i);
      fixAfterSparseInsert();
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Add an integer value to this set.
 * @param i integer to add
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  if (densePart != null && inDenseRange(i)) {
    if (!densePart.get(i)) {
      densePart.set(i);
      assertDisjoint();
      return true;
    }
  }
 else   if (!sparsePart.contains(i)) {
    sparsePart.add(i);
    assertDisjoint();
    fixAfterSparseInsert();
    return true;
  }
  return false;
}",0.585480093676815
40992,"/** 
 * @param i
 * @return true iff this set contains integer i
 */
public boolean contains(int i){
  return sparsePart.contains(i) || (densePart != null && densePart.contains(i));
}","/** 
 * @param i
 * @return true iff this set contains integer i
 */
public boolean contains(int i){
  if (densePart != null && inDenseRange(i)) {
    return densePart.contains(i);
  }
 else {
    return sparsePart.contains(i);
  }
}",0.7211538461538461
40993,"/** 
 * Add all members of set to this.
 * @param set
 * @return true iff the value of this changes.
 */
public boolean addAll(IntSet set){
  boolean change=false;
  if (set instanceof SemiSparseMutableIntSet) {
    SemiSparseMutableIntSet that=(SemiSparseMutableIntSet)set;
    if (densePart == null) {
      if (that.densePart != null) {
        densePart=new OffsetBitVector(that.densePart);
        for (int b=densePart.nextSetBit(0); b != -1; b=densePart.nextSetBit(b + 1)) {
          if (sparsePart.contains(b)) {
            sparsePart.remove(b);
          }
 else {
            change=true;
          }
        }
        for (IntIterator bits=that.sparsePart.intIterator(); bits.hasNext(); ) {
          change|=sparsePart.add(bits.next());
        }
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
 else {
      int oldSize=size();
      if (that.densePart != null) {
        densePart.or(that.densePart);
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          add(bs.next());
        }
        for (IntIterator bs=sparsePart.intIterator(); bs.hasNext(); ) {
          int b=bs.next();
          if (densePart.get(b)) {
            sparsePart.remove(b);
          }
        }
        change=(size() != oldSize);
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
  }
 else {
    for (IntIterator bs=set.intIterator(); bs.hasNext(); ) {
      change|=add(bs.next());
    }
  }
  return change;
}","/** 
 * Add all members of set to this.
 * @param set
 * @return true iff the value of this changes.
 */
public boolean addAll(IntSet set){
  boolean change=false;
  if (set instanceof SemiSparseMutableIntSet) {
    SemiSparseMutableIntSet that=(SemiSparseMutableIntSet)set;
    if (densePart == null) {
      if (that.densePart != null) {
        int oldSize=size();
        densePart=new OffsetBitVector(that.densePart);
        for (IntIterator bits=sparsePart.intIterator(); bits.hasNext(); ) {
          int bit=bits.next();
          if (inDenseRange(bit)) {
            densePart.set(bit);
          }
        }
        sparsePart.removeAll(densePart);
        sparsePart.addAll(that.sparsePart);
        change=size() != oldSize;
      }
 else {
        change=sparsePart.addAll(that.sparsePart);
        fixAfterSparseInsert();
      }
    }
 else {
      if (that.densePart != null) {
        int oldSize=size();
        densePart.or(that.densePart);
        sparsePart.addAll(that.sparsePart);
        for (IntIterator bits=sparsePart.intIterator(); bits.hasNext(); ) {
          int bit=bits.next();
          if (inDenseRange(bit)) {
            densePart.set(bit);
          }
        }
        sparsePart.removeAll(densePart);
        change=size() != oldSize;
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
  }
 else {
    for (IntIterator bs=set.intIterator(); bs.hasNext(); ) {
      change|=add(bs.next());
    }
  }
  assertDisjoint();
  return change;
}",0.2822505439850792
40994,"public void set(int x,Object value){
  if (Assertions.verifyAssertions) {
    Assertions._assert(x >= 0);
  }
  maxIndex=Math.max(maxIndex,x);
  if (value == null) {
    if (x >= store.length) {
      return;
    }
 else {
      store[x]=value;
    }
  }
 else {
    ensureCapacity(x);
    store[x]=value;
  }
}","public void set(int x,T value){
  if (Assertions.verifyAssertions) {
    Assertions._assert(x >= 0);
  }
  maxIndex=Math.max(maxIndex,x);
  if (value == null) {
    if (x >= store.length) {
      return;
    }
 else {
      store[x]=value;
    }
  }
 else {
    ensureCapacity(x);
    store[x]=value;
  }
}",0.9886547811993516
40995,"public Module asModule(){
  Assertions.UNREACHABLE();
  return null;
}","public Module asModule() throws UnimplementedError {
  Assertions.UNREACHABLE(""String_Node_Str"");
  return null;
}",0.7608695652173914
40996,"/** 
 * @param gen the intset of facts which are gen'ned by this flow function
 */
private VectorGenFlowFunction(SparseIntSet gen){
  this.gen=gen;
  if (Assertions.verifyAssertions) {
    Assertions._assert(gen.contains(0));
  }
}","/** 
 * @param gen the intset of facts which are gen'ned by this flow function
 */
private VectorGenFlowFunction(SparseIntSet gen){
  this.gen=gen;
}",0.7842105263157895
40997,"/** 
 * @param cmd
 * @throws WalaException
 */
protected Process spawnProcess(String cmd) throws WalaException {
  System.out.println(""String_Node_Str"" + cmd);
  String[] env=getEnv() == null ? null : buildEnv(getEnv());
  try {
    Process p=Runtime.getRuntime().exec(cmd,env,getWorkingDir());
    return p;
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new WalaException(""String_Node_Str"" + getClass());
  }
}","/** 
 * @param cmd
 * @throws WalaException
 */
protected Process spawnProcess(String cmd) throws WalaException, IllegalArgumentException {
  if (cmd == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + cmd);
  String[] env=getEnv() == null ? null : buildEnv(getEnv());
  try {
    Process p=Runtime.getRuntime().exec(cmd,env,getWorkingDir());
    return p;
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new WalaException(""String_Node_Str"" + getClass());
  }
}",0.8521560574948666
40998,"public TypeReference getConstantType(Object S){
  Class<? extends Object> key=(S == null) ? null : S.getClass();
  if (Assertions.verifyAssertions && !constantTypes.containsKey(key)) {
    Assertions._assert(constantTypes.containsKey(key),""String_Node_Str"" + S + ""String_Node_Str""+ key);
  }
  return constantTypes.get(key);
}","/** 
 * TODO: what is this and why is it here?
 */
public TypeReference getConstantType(Object S){
  Class<? extends Object> key=(S == null) ? null : S.getClass();
  if (Assertions.verifyAssertions && !constantTypes.containsKey(key)) {
    Assertions._assert(constantTypes.containsKey(key),""String_Node_Str"" + S + ""String_Node_Str""+ key);
  }
  return constantTypes.get(key);
}",0.9274537695590328
40999,"public PointsToSetVariable(){
  super();
  this.pointerKey=null;
}","public PointsToSetVariable(PointerKey key){
  super();
  if (Assertions.verifyAssertions) {
    Assertions._assert(key != null);
  }
  this.pointerKey=key;
}",0.5560538116591929
41000,"/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(DataDependenceOptions dOptions){
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return;
  }
  IR ir=node.getIR(new WarningSet());
  if (ir == null) {
    return;
  }
  DefUse DU=node.getCallGraph().getInterpreter(node).getDU(node,new WarningSet());
  SSAInstruction[] instructions=ir.getInstructions();
  for (Iterator<? extends Statement> it=iterateNodes(); it.hasNext(); ) {
    Statement s=it.next();
switch (s.getKind()) {
case NORMAL:
case CATCH:
case PI:
case PHI:
{
        SSAInstruction statement=statement2SSAInstruction(instructions,s);
        if (!(statement instanceof SSAInvokeInstruction)) {
          if (dOptions.isTerminateAtCast() && (statement instanceof SSACheckCastInstruction)) {
            break;
          }
          if (dOptions.isTerminateAtCast() && (statement instanceof SSAInstanceofInstruction)) {
            break;
          }
          for (int i=0; i < statement.getNumberOfDefs(); i++) {
            int def=statement.getDef(i);
            for (Iterator<SSAInstruction> it2=DU.getUses(def); it2.hasNext(); ) {
              SSAInstruction use=it2.next();
              if (dOptions.isIgnoreBasePtrs()) {
                if (use instanceof SSANewInstruction) {
                  continue;
                }
                if (hasBasePointer(use)) {
                  int base=getBasePointer(use);
                  if (def == base) {
                    continue;
                  }
                  if (use instanceof SSAArrayReferenceInstruction) {
                    SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
                    if (def == arr.getIndex()) {
                      continue;
                    }
                  }
                }
              }
              Statement u=ssaInstruction2Statement(use);
              addEdge(s,u);
            }
          }
        }
        break;
      }
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
{
      if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
        Assertions._assert(!s.getKind().equals(Kind.EXC_RET_CALLER));
      }
      ValueNumberCarrier a=(ValueNumberCarrier)s;
      for (Iterator<SSAInstruction> it2=DU.getUses(a.getValueNumber()); it2.hasNext(); ) {
        SSAInstruction use=it2.next();
        if (dOptions.isIgnoreBasePtrs()) {
          if (use instanceof SSANewInstruction) {
            continue;
          }
          if (hasBasePointer(use)) {
            int base=getBasePointer(use);
            if (a.getValueNumber() == base) {
              continue;
            }
            if (use instanceof SSAArrayReferenceInstruction) {
              SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
              if (a.getValueNumber() == arr.getIndex()) {
                continue;
              }
            }
          }
        }
        Statement u=ssaInstruction2Statement(use);
        addEdge(s,u);
      }
      break;
    }
case NORMAL_RET_CALLEE:
  for (  NormalStatement ret : computeReturnStatements(ir)) {
    addEdge(ret,s);
  }
break;
case EXC_RET_CALLEE:
if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
Assertions.UNREACHABLE();
}
for (NormalStatement pei : getPEIs(ir)) {
if (dOptions.isTerminateAtCast() && (pei.getInstruction() instanceof SSACheckCastInstruction)) {
continue;
}
if (pei.getInstruction() instanceof SSAInvokeInstruction) {
SSAInvokeInstruction call=(SSAInvokeInstruction)pei.getInstruction();
Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
addEdge(st,s);
}
 else {
addEdge(pei,s);
}
}
break;
case PARAM_CALLER:
{
ParamStatement.ParamCaller pac=(ParamStatement.ParamCaller)s;
int vn=pac.getValueNumber();
if (ir.getSymbolTable().isParameter(vn)) {
Statement a=new ParamStatement.ParamCallee(node,vn);
addEdge(a,pac);
}
 else {
SSAInstruction d=DU.getDef(vn);
if (dOptions.isTerminateAtCast() && (d instanceof SSACheckCastInstruction)) {
break;
}
if (d != null) {
if (d instanceof SSAInvokeInstruction) {
SSAInvokeInstruction call=(SSAInvokeInstruction)d;
if (vn == call.getException()) {
  Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
  addEdge(st,pac);
}
 else {
  Statement st=new ParamStatement.NormalReturnCaller(node,call);
  addEdge(st,pac);
}
}
 else {
Statement ds=ssaInstruction2Statement(d);
addEdge(ds,pac);
}
}
}
}
break;
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
break;
default :
Assertions.UNREACHABLE(s.toString());
break;
}
}
}","/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(DataDependenceOptions dOptions){
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return;
  }
  IR ir=node.getIR(new WarningSet());
  if (ir == null) {
    return;
  }
  DefUse DU=node.getCallGraph().getInterpreter(node).getDU(node,new WarningSet());
  SSAInstruction[] instructions=ir.getInstructions();
  for (Iterator<? extends Statement> it=iterateNodes(); it.hasNext(); ) {
    Statement s=it.next();
switch (s.getKind()) {
case NORMAL:
case CATCH:
case PI:
case PHI:
{
        SSAInstruction statement=statement2SSAInstruction(instructions,s);
        if (!(statement instanceof SSAInvokeInstruction)) {
          if (dOptions.isTerminateAtCast() && (statement instanceof SSACheckCastInstruction)) {
            break;
          }
          if (dOptions.isTerminateAtCast() && (statement instanceof SSAInstanceofInstruction)) {
            break;
          }
          for (int i=0; i < statement.getNumberOfDefs(); i++) {
            int def=statement.getDef(i);
            for (Iterator<SSAInstruction> it2=DU.getUses(def); it2.hasNext(); ) {
              SSAInstruction use=it2.next();
              if (dOptions.isIgnoreBasePtrs()) {
                if (use instanceof SSANewInstruction) {
                  continue;
                }
                if (hasBasePointer(use)) {
                  int base=getBasePointer(use);
                  if (def == base) {
                    continue;
                  }
                  if (use instanceof SSAArrayReferenceInstruction) {
                    SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
                    if (def == arr.getIndex()) {
                      continue;
                    }
                  }
                }
              }
              Statement u=ssaInstruction2Statement(use);
              addEdge(s,u);
            }
          }
        }
        break;
      }
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
{
      if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
        Assertions._assert(!s.getKind().equals(Kind.EXC_RET_CALLER));
      }
      ValueNumberCarrier a=(ValueNumberCarrier)s;
      for (Iterator<SSAInstruction> it2=DU.getUses(a.getValueNumber()); it2.hasNext(); ) {
        SSAInstruction use=it2.next();
        if (dOptions.isIgnoreBasePtrs()) {
          if (use instanceof SSANewInstruction) {
            continue;
          }
          if (hasBasePointer(use)) {
            int base=getBasePointer(use);
            if (a.getValueNumber() == base) {
              continue;
            }
            if (use instanceof SSAArrayReferenceInstruction) {
              SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
              if (a.getValueNumber() == arr.getIndex()) {
                continue;
              }
            }
          }
        }
        Statement u=ssaInstruction2Statement(use);
        addEdge(s,u);
      }
      break;
    }
case NORMAL_RET_CALLEE:
  for (  NormalStatement ret : computeReturnStatements(ir)) {
    addEdge(ret,s);
  }
break;
case EXC_RET_CALLEE:
if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
Assertions.UNREACHABLE();
}
for (NormalStatement pei : getPEIs(ir)) {
if (dOptions.isTerminateAtCast() && (pei.getInstruction() instanceof SSACheckCastInstruction)) {
continue;
}
if (pei.getInstruction() instanceof SSAInvokeInstruction) {
SSAInvokeInstruction call=(SSAInvokeInstruction)pei.getInstruction();
Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
addEdge(st,s);
}
 else {
addEdge(pei,s);
}
}
break;
case PARAM_CALLER:
{
ParamStatement.ParamCaller pac=(ParamStatement.ParamCaller)s;
int vn=pac.getValueNumber();
if (vn > -1) {
if (ir.getSymbolTable().isParameter(vn)) {
Statement a=new ParamStatement.ParamCallee(node,vn);
addEdge(a,pac);
}
 else {
SSAInstruction d=DU.getDef(vn);
if (dOptions.isTerminateAtCast() && (d instanceof SSACheckCastInstruction)) {
break;
}
if (d != null) {
if (d instanceof SSAInvokeInstruction) {
  SSAInvokeInstruction call=(SSAInvokeInstruction)d;
  if (vn == call.getException()) {
    Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
    addEdge(st,pac);
  }
 else {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addEdge(st,pac);
  }
}
 else {
  Statement ds=ssaInstruction2Statement(d);
  addEdge(ds,pac);
}
}
}
}
}
break;
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
break;
default :
Assertions.UNREACHABLE(s.toString());
break;
}
}
}",0.996149443230305
